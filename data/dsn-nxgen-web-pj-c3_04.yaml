- en: Chapter 4. Zooming User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。缩放用户界面
- en: In this chapter, we'll learn how to create a simple **ZUI**. This acronym stands
    for a **zooming user interface**; a graphical environment where users can change
    the scale of the viewed area in order to see more or less detail. For this project,
    we'll create a ZUI to let users move and explore an **infographic**, which is
    a visual graphic representation of data, information, or knowledge. The project
    we are going to build combines many CSS3 features, such as transitions, transformations,
    and Flexible Box Layout. It also introduces SVG and the various methods we can
    use to embed them in an HTML page. Additionally, as an extra challenge, we will
    also enable our page to perform on older browsers and will explore clever ways
    to accomplish this task.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建一个简单的**ZUI**。这个缩放用户界面的首字母缩写代表**缩放用户界面**；一个用户可以改变所看区域的比例以查看更多或更少细节的图形环境。对于这个项目，我们将创建一个ZUI，让用户移动和探索一个**信息图表**，这是数据、信息或知识的视觉图形表示。我们将要构建的项目结合了许多CSS3特性，如过渡、变换和灵活的盒子布局。它还介绍了SVG以及我们可以用来在HTML页面中嵌入它们的各种方法。此外，作为额外的挑战，我们还将使我们的页面在旧版浏览器上运行，并探索完成这项任务的巧妙方法。
- en: 'The following is a preview of the topics discussed in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章讨论的主题的预览：
- en: Infographics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息图表
- en: Flexible Box Layout
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的盒子布局
- en: Polyfills
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Polyfills
- en: Embedding SVG
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入SVG
- en: Modernizr
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Modernizr
- en: The `:target` pseudo-selector
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:target`伪选择器'
- en: CSS3 transforms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS3变换
- en: Targeting SVG with CSS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用CSS定位SVG
- en: Graceful degradation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅降级
- en: Infographics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息图表
- en: Infographics are rapidly changing the way we consume information by creating
    graphical representations that aggregate data or show flows, and are able to display
    a great quantity of knowledge in a very intuitive and easy-to-use way. A great
    source of information about this topic is the blog, FlowingData ([http://flowingdata.com/](http://flowingdata.com/)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 信息图表正在迅速改变我们消费信息的方式，通过创建图形表示来聚合数据或显示流程，并能够以非常直观和易于使用的方式显示大量知识。关于这个主题的一个很好的信息来源是FlowingData博客（[http://flowingdata.com/](http://flowingdata.com/)）。
- en: 'For this project, we will use the following stunning infographic created by
    Oxigenio, an Italian-based company ([http://www.officinastrategia.it](http://www.officinastrategia.it)):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用意大利公司Oxigenio创建的以下令人惊叹的信息图表（[http://www.officinastrategia.it](http://www.officinastrategia.it)）：
- en: '![Infographics](img/3264OT_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![信息图表](img/3264OT_04_01.jpg)'
- en: 'We want to reserve most of the browser''s viewport area for this amazing infographic,
    except for a sidebar, 200 px wide, which contains some commands we''ll see in
    a moment. First let''s define some basic HTML in an `index.html` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为这个惊人的信息图表保留大部分浏览器视口区域，除了一个宽度为200像素的侧边栏，其中包含一些我们马上会看到的命令。首先让我们在一个`index.html`文件中定义一些基本的HTML：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For this project, we use the `modernizr.js` and `prefixfree.js` files. So let's
    create a `js` directory under the root folder of our project and download them
    to there from their respective websites ([http://modernizr.com/downloads/modernizr-latest.js](http://modernizr.com/downloads/modernizr-latest.js)
    and [http://leaverou.github.com/prefixfree/](http://leaverou.github.com/prefixfree/)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们使用`modernizr.js`和`prefixfree.js`文件。因此，让我们在项目的根文件夹下创建一个`js`目录，并从它们各自的网站（[http://modernizr.com/downloads/modernizr-latest.js](http://modernizr.com/downloads/modernizr-latest.js)和[http://leaverou.github.com/prefixfree/](http://leaverou.github.com/prefixfree/)）下载它们到那里。
- en: Next we have to prepare a `css` folder and create an empty `application.css`
    in it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要准备一个`css`文件夹，并在其中创建一个空的`application.css`文件。
- en: 'The HTML structure we defined so far is quite simple and minimalistic: a `header`
    element and an `article` element surrounded by a `section` element. Now we want
    to place the `header` element on the left side with a fixed width of 200 px, and
    tell the `article` element to cover the remaining portion of the screen.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们定义的HTML结构非常简单和极简：一个`header`元素和一个被`section`元素包围的`article`元素。现在我们想把`header`元素放在左侧，宽度固定为200像素，并告诉`article`元素覆盖屏幕的剩余部分。
- en: We can achieve this element disposition with a variety of techniques. For the
    purpose of this book, we're going to use CSS3 Flexible Box Layout.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过各种技术实现这种元素布置。对于本书的目的，我们将使用CSS3灵活的盒子布局。
- en: Implementing Flexible Box Layout
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现灵活的盒子布局
- en: 'CSS2.1 defined four layout modes: block, inline, tabular, and positioned. CSS3
    has added some new layout modes, and one of them is **Flexible Box Layout**. This
    new mode is activated by a new value we can give to the `display` statement, and
    can be configured through a whole new set of properties.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CSS2.1定义了四种布局模式：块状、内联、表格和定位。CSS3添加了一些新的布局模式，其中之一是**灵活的盒子布局**。这种新模式是通过我们可以给`display`语句的一个新值来激活的，并且可以通过一整套新的属性进行配置。
- en: The basic idea behind this new layout mode is that within a container element
    (for example, our `section` element) we can specify the direction we want our
    inner elements to be displayed in. So if we say `horizontal` then the elements
    will flow from left to right, and if we say `vertical` they'll be positioned one
    below the other, top to bottom.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新布局模式背后的基本思想是，在容器元素（例如，我们的`section`元素）中，我们可以指定我们希望内部元素显示的方向。因此，如果我们说`horizontal`，那么元素将从左到右流动，如果我们说`vertical`，它们将依次从上到下排列。
- en: Then we can decide the size of each of the elements either by using fixed dimensions
    or by defining a grow factor.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过使用固定尺寸或定义增长因子来决定每个元素的大小。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a new space is available within the container, the elements increase their
    width proportionally to their grow factors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器内有新空间可用时，元素会按照它们的增长因子成比例地增加宽度。
- en: 'Enough talk! Let''s create a small demo to test this out:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 够说了！让我们创建一个小型演示来测试一下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can see how the `li` elements within the `ul` element start with the same
    width, which is exactly one-fifth of the width of the containing element. This
    is because they all have the same grow factor specified by the property `box-flex`,
    which makes them divide the available space equally. When we hover our mouse over
    one of the `li` elements, we change the `box-flex` value of the element; we hover
    over to `2` that makes its width twice as long as the others. The following is
    a screenshot with the page just loaded:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`ul`元素内的`li`元素以相同的宽度开始，这恰好是包含元素宽度的五分之一。这是因为它们都具有相同的增长因子，由属性`box-flex`指定，这使它们平均分配可用空间。当我们将鼠标悬停在`li`元素上时，我们改变了元素的`box-flex`值；我们将鼠标悬停在`2`上，使其宽度是其他元素的两倍。以下是刚加载页面的屏幕截图：
- en: '![Implementing Flexible Box Layout](img/3264OT_04_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![实现弹性盒布局](img/3264OT_04_02.jpg)'
- en: 'The following is a screenshot while hovering over an element:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是悬停在元素上时的屏幕截图：
- en: '![Implementing Flexible Box Layout](img/3264OT_04_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![实现弹性盒布局](img/3264OT_04_03.jpg)'
- en: 'By changing the direction property (`box-orient`) from `horizontal` to `vertical`,
    we can observe the same behavior on the opposite axis. Due to the structure of
    this specific example, we also have to modify `line-height` to remove the `200px`
    height we have set:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`box-orient`属性从`horizontal`更改为`vertical`，我们可以观察到在相反轴上的相同行为。由于这个特定示例的结构，我们还必须修改`line-height`以去除我们设置的`200px`高度：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the screenshot that shows the result:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示结果的屏幕截图：
- en: '![Implementing Flexible Box Layout](img/3264OT_04_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![实现弹性盒布局](img/3264OT_04_04.jpg)'
- en: Defining the basic structure
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义基本结构
- en: Now that we have the basics to create the structure of our project, we need
    to define a horizontal direction within the `section` element, and then set the
    `header` element's width to a fixed value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了创建项目结构的基础，我们需要在`section`元素内定义水平方向，然后将`header`元素的宽度设置为固定值。
- en: 'We have already created the `index.html` HTML in the first section of this
    chapter. Now let''s reprint the `body` section again for clarity:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的第一部分创建了`index.html` HTML。现在让我们为了清晰起见再次重印`body`部分：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can start adding the following instructions to `application.css`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始将以下指令添加到`application.css`：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ve added a little more instructions than in the previous example because
    we also want the `section` element to cover the whole browser''s viewport. Additionally,
    we should prevent the display of a vertical scroll bar because the only navigation
    mechanisms must be the ones offered by the ZUI. So we''ve added an `overflow:
    hidden` property to both `section` and `article`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在上一个示例中添加了更多的说明，因为我们还希望`section`元素覆盖整个浏览器视口。此外，我们应该防止显示垂直滚动条，因为唯一的导航机制必须是ZUI提供的。因此，我们在`section`和`article`中都添加了`overflow:
    hidden`属性。'
- en: 'If we now load the project in a browser that supports CSS3, we can appreciate
    the result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在支持CSS3的浏览器中加载项目，我们可以欣赏结果：
- en: '![Defining the basic structure](img/3264OT_04_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![定义基本结构](img/3264OT_04_05.jpg)'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Flexible Box Layout Module specification is evolving rapidly, and currently
    none of the web browsers support all of the specs. Our implementation corresponds
    to the following document published on July 23, 2009:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性盒布局模块规范正在迅速发展，目前没有一个web浏览器支持所有规范。我们的实现对应于2009年7月23日发布的以下文档：
- en: '[http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/](http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/](http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/)'
- en: Adding Polyfills
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Polyfills
- en: For the first time since the beginning of this book, we are using CSS3 to define
    the structure of our page. This means we cannot simply rely on graceful degradation
    to support older browsers because it would compromise the whole structure of the
    project. Instead, we're going to look for some JavaScript libraries that are able
    to emulate the behavior we have implemented. This, of course, can lead to some
    problems if the user's browser is missing both JavaScript support and Flexible
    Box Layout, but at least we can hope that the number of such users is pretty low.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自本书开始以来，我们首次使用CSS3来定义页面的结构。这意味着我们不能简单地依赖优雅降级来支持旧版浏览器，因为这会损害项目的整体结构。相反，我们将寻找一些能够模拟我们已实现行为的JavaScript库。当然，如果用户的浏览器缺少JavaScript支持和弹性盒布局，这可能会导致一些问题，但至少我们可以希望这样的用户数量非常少。
- en: 'There are different types of such JavaScript libraries, categorized by how
    much extra work is required to obtain the same result as the native implementation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的JavaScript库，根据需要多少额外工作来获得与原生实现相同的结果进行分类：
- en: '**Generic libraries**: Generic libraries don''t allow the developer to obtain
    exactly the same result, but give him/her some tools to code an alternative implementation
    of the solution.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用库**：通用库不允许开发人员获得完全相同的结果，但给他/她一些工具来编写解决方案的替代实现。'
- en: '**Shims**: Shims allow the developer to mimic the native implementation perfectly,
    but achieving it requires an extra cost in terms of work.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shims**：Shims允许开发人员完美地模仿原生实现，但实现它需要额外的工作成本。'
- en: '**Polyfills**: Polyfills are the best ones. These libraries read our code,
    detect the unsupported features, and implement the required JavaScript workaround
    without the need to add extra code.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Polyfills**：Polyfills是最好的。这些库读取我们的代码，检测不支持的功能，并实现所需的JavaScript解决方法，而无需添加额外的代码。'
- en: 'We need to find a polyfill that emulates Flexible Box Layout Module. We can
    start our search from the following page, created and kept by the authors of Modernizr
    that lists all the polyfills they have tested and found to work:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一个模拟弹性盒布局模块的polyfill。我们可以从以下页面开始搜索，这个页面是由Modernizr的作者创建和维护的，列出了他们测试过并发现有效的所有polyfills：
- en: '[https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)'
- en: After scrolling down the page, we find Flexie, which claims to add support to
    Flexible Box Layout for older browsers (up to IE6). All we have to do is download
    the library, `flexie.js`, to our `js` folder (it is also available from GitHub
    at [https://github.com/doctyper/flexie](https://github.com/doctyper/flexie), within
    the `src` folder).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面向下滚动后，我们找到了Flexie，它声称为旧版浏览器（最多到IE6）添加了对弹性盒布局的支持。我们所要做的就是将库`flexie.js`下载到我们的`js`文件夹中（它也可以从GitHub上获取，网址为[https://github.com/doctyper/flexie](https://github.com/doctyper/flexie)，在`src`文件夹中）。
- en: 'Let''s modify our `index.html` file by adding the following lines just before
    the `</body>` tag:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`</body>`标签之前添加以下行来修改我们的`index.html`文件：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can test if everything went well by loading our project in a browser
    that doesn''t support CSS3 Flexible Box Layout. The following is a screenshot
    taken from IE8:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试一下，看看是否一切顺利，加载我们的项目到不支持CSS3弹性盒布局的浏览器中。以下是从IE8中获取的屏幕截图：
- en: '![Adding Polyfills](img/3264OT_04_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![添加Polyfills](img/3264OT_04_06.jpg)'
- en: As we see from the output, there's no striped background but the overall structure
    is well preserved.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，没有条纹背景，但整体结构得到了很好的保留。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Adding a polyfill to a project inevitably increases its level of complexity.
    Polyfills are almost always able to emulate the CSS3 feature they are built for,
    but in a way that obviously differs from the native implementation. It might be
    that a polyfill needs to inject extra elements to our page, or to add CSS properties.
    So it's a good rule of thumb to add these libraries earlier, during the development
    of our pages and to test them often in order to catch conflicts between the developing
    pages and libraries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目添加Polyfill不可避免地增加了其复杂性。Polyfills几乎总是能够模拟它们为之构建的CSS3功能，但显然与原生实现有所不同。可能需要Polyfill向我们的页面注入额外的元素，或者添加CSS属性。因此，在开发页面时尽早添加这些库，并经常测试，以便捕捉开发页面和库之间的冲突，这是一个很好的经验法则。
- en: Embedding SVG
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入SVG
- en: We'd like to use **Scalable Vector Graphics** (**SVG**) instead of a raster
    image where supported. We're building a ZUI so our infographic needs to be zoomed,
    and using a vector graphic allows us to preserve the quality of the object. Vector
    images, in fact, are size independent and thus don't get pixelated when scaled.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在支持的情况下使用**可缩放矢量图形**（**SVG**）而不是光栅图像。我们正在构建一个ZUI，因此我们的信息图表需要进行缩放，使用矢量图形可以保持对象的质量。事实上，矢量图像是大小独立的，因此在缩放时不会出现像素化。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about vector images and SVG can be found on Wikipedia at [http://en.wikipedia.org/wiki/Vector_graphics](http://en.wikipedia.org/wiki/Vector_graphics).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有关矢量图像和SVG的更多信息可以在维基百科上找到[http://en.wikipedia.org/wiki/Vector_graphics](http://en.wikipedia.org/wiki/Vector_graphics)。
- en: 'There are three ways to embed an SVG:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种嵌入SVG的方式：
- en: As an `<object>` element. This is the most supported way of adding SVG. However,
    it is limited in a sense that the SVG is treated like an external element and
    therefore cannot be manipulated through JavaScript (except for some obvious properties,
    such as `width` and `height`).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`<object>`元素。这是添加SVG的最受支持的方式。然而，它在某种程度上受到限制，因为SVG被视为外部元素，因此不能通过JavaScript进行操作（除了一些明显的属性，如`width`和`height`）。
- en: As a value for CSS where an image is required.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为CSS的值，需要图像的地方。
- en: Directly into our HTML code. This approach offers the most interaction available
    between the SVG and the page. As we'll see later in this chapter, we can interact
    with the vector graphic directly from CSS, or even from JavaScript.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在我们的HTML代码中。这种方法提供了SVG和页面之间最多的交互。正如我们将在本章后面看到的，我们可以直接从CSS或甚至从JavaScript与矢量图形进行交互。
- en: 'Let''s go for the third way because we want our CSS to be able to affect part
    of the SVG graphic. First of all, let''s create a `div` element that is going
    to act as a container for our SVG element within the `<article>` we created earlier
    in this chapter:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择第三种方式，因为我们希望我们的CSS能够影响SVG图形的一部分。首先，让我们创建一个`div`元素，它将作为我们在本章前面创建的`<article>`中的SVG元素的容器：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we can use jQuery to load the SVG file from the `img` folder directly
    into the container we just created by adding a few lines to our `index.html` file,
    after the `script` tags we wrote earlier:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用jQuery从`img`文件夹直接加载SVG文件到我们刚刚创建的容器中，只需在我们之前编写的`index.html`文件的`script`标签后添加几行：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In these lines, we first ask jQuery to wait until the DOM is ready, and then
    to load the content of our SVG file inside the `div` element with the `.panel`
    class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们首先要求jQuery等待DOM准备就绪，然后将我们的SVG文件的内容加载到具有`.panel`类的`div`元素中。
- en: Now we can add a bit of CSS to center the `div` element both vertically and
    horizontally in the containing `article`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一些CSS来使`div`元素在包含的`article`中垂直和水平居中。
- en: 'This can be weird because only Webkit browsers and IE9+ seem to accept a container
    with size `100%`, so we have to discriminate between these browsers and the others.
    So let''s add the following instructions to `application.css`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会很奇怪，因为只有Webkit浏览器和IE9+似乎接受大小为`100%`的容器，所以我们必须区分这些浏览器和其他浏览器。因此，让我们在`application.css`中添加以下指令：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have now covered all the possible cases:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了所有可能的情况：
- en: We used Prefix Free's ability to add an extra class to the `<html>` element
    to detect Webkit and Microsoft browsers, and set the container size to `100%`
    for these browsers in order to obtain an SVG as big as the container permits
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了Prefix Free的能力，向`<html>`元素添加了一个额外的类，以检测Webkit和Microsoft浏览器，并为这些浏览器设置容器大小为`100%`，以便获得尽可能大的SVG容器。
- en: If the browser is not one of those discussed in the previous item, we align
    the SVG centrally and set a fixed size
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果浏览器不是前一项讨论中的浏览器之一，我们将SVG居中对齐并设置固定大小
- en: If there is an image instead of the SVG (we'll see in a moment how we can handle
    this), we do basically the same thing as in the previous item.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有图像而不是SVG（我们马上会看到我们如何处理这个），我们基本上做与前一项相同的事情。
- en: 'If we now reload the project in our browser, we can see the display of the
    SVG:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在浏览器中重新加载项目，我们可以看到SVG的显示：
- en: '![Embedding SVG](img/3264OT_04_07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入SVG](img/3264OT_04_07.jpg)'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the fact that we're using AJAX, we need a proper web server to try this
    project. Just double-clicking on the `index.html` file won't generate the expected
    results. Refer to the *Preface* section of the book to get more information on
    how to install a web server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了AJAX，我们需要一个合适的Web服务器来尝试这个项目。只需双击`index.html`文件，不会生成预期的结果。请参考本书的*前言*部分，以获取有关如何安装Web服务器的更多信息。
- en: Of course there are browsers that don't support SVG. IE8 is among them, so we
    need to find a solution in order to keep our project enjoyable on these browsers
    too.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些浏览器不支持SVG。IE8就是其中之一，因此我们需要找到一个解决方案，以便在这些浏览器上也能保持我们的项目愉快。
- en: Taking advantage of Modernizr
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Modernizr
- en: 'We have already had a glimpse of Modernizr in the last chapter, it''s a library
    that does plenty of things, some of which are listed as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经对Modernizr有所了解，它是一个库，可以做很多事情，其中一些列在下面：
- en: It adds support for new HTML5 tags in older browsers.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为旧浏览器添加了对新HTML5标签的支持。
- en: It exposes some methods in JavaScript allowing us to test for a certain CSS3/HTML5
    feature. For example, `Modernizr.multiplebg` returns `true` or `false` depending
    on the support of multiple backgrounds.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在JavaScript中公开了一些方法，允许我们测试某个CSS3/HTML5功能。例如，`Modernizr.multiplebg`根据对多个背景的支持返回`true`或`false`。
- en: It adds some classes to the `<html>` element reflecting the support of certain
    CSS3/HTML5 features. For example, `<html class="multiplebg">` or `<html class="no-multiplebg">`
    depending on the support of multiple backgrounds.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它向`<html>`元素添加了一些类，反映了对某些CSS3/HTML5功能的支持。例如，根据对多个背景的支持，是`<html class="multiplebg">`还是`<html
    class="no-multiplebg">`。
- en: We have already added this library to our project. However, if not properly
    tuned, Modernizr performs all the tests to detect the supported features even
    if we're not going to use them. To enhance the performance of the library, we
    can select which tests we want it to perform.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这个库添加到我们的项目中。但是，如果没有正确调整，Modernizr会执行所有测试来检测支持的功能，即使我们不打算使用它们。为了增强库的性能，我们可以选择要执行哪些测试。
- en: To do that, we have to click on the download page of Modernizr ([http://modernizr.com/download/](http://modernizr.com/download/))
    and check only the features we're going to use this library for.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须单击Modernizr的下载页面（[http://modernizr.com/download/](http://modernizr.com/download/)），并仅检查我们将使用此库的功能。
- en: 'For this project, we need to test for inline SVG support. The following is
    a screenshot with the checkboxes on the right-hand side checked:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要测试对内联SVG的支持。以下是屏幕截图，右侧的复选框已被选中：
- en: '![Taking advantage of Modernizr](img/3264OT_04_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![利用Modernizr](img/3264OT_04_08.jpg)'
- en: Next we click on the **Generate!** button, and then on the **Download** button
    to download and overwrite the `modernizr.js` file we have in our project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们单击**生成！**按钮，然后单击**下载**按钮，以下载并覆盖我们项目中的`modernizr.js`文件。
- en: We may now check the generated HTML code for our project and see how the `html`
    elements get enriched by an `inlinesvg` class if the browser supports inline SVG,
    or a `no-inlinesvg` class otherwise.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查我们项目的生成HTML代码，看看如果浏览器支持内联SVG，则`html`元素如何被`inlinesvg`类丰富，否则是`no-inlinesvg`类。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can check the generated HTML code using the browser's development console.
    If using Google Chrome, for example, press *Ctrl* + *Shift* + *I* (on Windows
    and Linux), or press *Command* + *Option* + *I* (on Mac).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用浏览器的开发控制台检查生成的HTML代码。例如，如果使用Google Chrome，按下*Ctrl* + *Shift* + *I*（在Windows和Linux上），或按下*Command*
    + *Option* + *I*（在Mac上）。
- en: '![Taking advantage of Modernizr](img/3264OT_04_09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![利用Modernizr](img/3264OT_04_09.jpg)'
- en: 'We''re now going to implement an alternative to the SVG graphic using a plain
    image; and then, by taking advantage of the class provided to us by Modernizr,
    switch between one or the other depending upon the browser''s support. So let''s
    first add a small HTML snippet to `index.html` just before the `</article>` tag:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要实现一个替代SVG图形的方法，使用普通图像；然后，通过利用Modernizr提供给我们的类，根据浏览器的支持切换其中一个。因此，让我们首先在`index.html`的`</article>`标签之前添加一个小的HTML片段：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we need to modify our `application.css`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要修改我们的`application.css`：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we now reload the project in IE8, we can see how everything is handled correctly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在IE8中重新加载项目，我们可以看到一切都被正确处理了：
- en: '![Taking advantage of Modernizr](img/3264OT_04_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![利用Modernizr](img/3264OT_04_10.jpg)'
- en: The :target pseudo-selector
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: :target伪选择器
- en: Now we can start adding some interaction to our project. What we want is to
    expose some controls in the `<header>` sidebar that, when clicked, zoom to a defined
    area of the infographic.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始为我们的项目添加一些交互。我们希望在`<header>`侧边栏中公开一些控件，当单击时，可以缩放到信息图表的指定区域。
- en: 'To achieve this, we are going to take advantage of a new CSS3 pseudo-selector:
    `:target`. It gets activated when an anchor becomes the target of the current
    URL. Let''s create a small example to try this out:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将利用一个新的CSS3伪选择器：`:target`。当锚点成为当前URL的目标时，它会被激活。让我们创建一个小例子来尝试一下：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the previous example, we basically say that when an `a` element becomes
    the target of the current URL, its background color must turn yellow. The following
    screenshot shows the result (notice the URL):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们基本上说当`a`元素成为当前URL的目标时，它的背景颜色必须变成黄色。下面的屏幕截图显示了结果（注意URL）：
- en: '![The :target pseudo-selector](img/3264OT_04_11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![:target伪选择器](img/3264OT_04_11.jpg)'
- en: 'Now we need a set of `a` elements containing the command we want the user to
    be able to execute. So let''s add a `nav` element within the `header` element
    in our `index.html` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一组包含用户可以执行的命令的`a`元素。所以让我们在我们的`index.html`文件的`header`元素中添加一个`nav`元素：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we can style these commands with a few CSS instructions in our `application.css`
    file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在我们的`application.css`文件中使用一些CSS指令来为这些命令设置样式：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we reload the project, we can see the result:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新加载项目，我们可以看到结果：
- en: '![The :target pseudo-selector](img/3264OT_04_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![`:target`伪选择器](img/3264OT_04_12.jpg)'
- en: Adding some anchors
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一些锚点
- en: 'Now we need to place the `a` elements that are targets of the commands we just
    implemented. And here comes a small trick: if we put these elements on the top
    of our page and then we hide them, we can use proximity selectors (`+` and `~`)
    to match the elements that follow them and be able to virtually reach every other
    element in the page.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要放置`a`元素，这些元素是我们刚刚实现的命令的目标。这里有一个小技巧：如果我们将这些元素放在页面顶部然后隐藏它们，我们可以使用邻接选择器（`+`和`~`）来匹配它们后面的元素，并能够虚拟地到达页面中的每个其他元素。
- en: 'So, let''s start by adding an `a` element for each command we have specified,
    just below the `body` element of our `index.html` file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们从在我们的`index.html`文件的`body`元素下方为我们指定的每个命令添加一个`a`元素开始：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Good! Now if we want to change the `header` background color when the **Italy**
    command has been clicked, we can add a simple line to our CSS:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！现在，如果我们想在单击**Italy**命令后更改`header`背景颜色，我们可以在我们的CSS中添加一行简单的代码：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Of course we don't want to do that, but by using the same principle we can trigger
    some changes to the infographic. First we have to learn about transformations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然我们不想这样做，但是通过使用相同的原理，我们可以触发信息图的一些变化。首先我们必须学习有关变换的知识。
- en: CSS3 transforms
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS3变换
- en: We are going to explore a whole new set of properties with the goal of being
    able to arbitrarily scale an element using CSS. This is the last core technique
    we need to learn to complete the ZUI, and the properties involved are called **CSS3
    transforms**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索一整套新的属性，目标是能够使用CSS任意缩放元素。这是我们需要学习的最后一个核心技术，涉及的属性被称为**CSS3变换**。
- en: 'With CSS3 transforms we can apply some modifiers to the elements on a page,
    namely:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS3变换，我们可以对页面上的元素应用一些修饰符，即：
- en: '`translateX(x)`, `translateY(y)`, and `translate(x,y)`: These modifiers move
    the element along one or both axes by a distance specified by the `x` and `y`
    variables (in px)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateX(x)`, `translateY(y)`, 和 `translate(x,y)`: 这些修饰符通过由`x`和`y`变量指定的距离沿一个或两个轴移动元素（以px为单位）'
- en: '`rotate(deg)`: It rotates the element by the value specified by the `deg` variable,
    which must be expressed in grades (from 0 to 360 degrees)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate(deg)`: 它通过由`deg`变量指定的值旋转元素，该值必须以度数表示（从0到360度）'
- en: '`scaleX(s)`, `scaleY(s)`, and `scale(s,[s])`: It scales the element of the
    value specified by a scale factor `s` where a scale of `1` corresponds to keeping
    the element at the same size'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaleX(s)`, `scaleY(s)`, 和 `scale(s,[s])`: 它通过比例因子`s`缩放元素，其中比例为`1`表示保持元素大小不变'
- en: '`skewX(k)` and `skewY(k)`: It applies a skew transformation by the given `k`
    angle expressed in grades (from 0 to 360 degrees)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skewX(k)` 和 `skewY(k)`: 它通过给定的`k`角度（以度数表示，从0到360度）应用倾斜变换'
- en: There's also a `matrix` modifier that accepts six parameters and lets us define
    a transformation matrix. More information about the `matrix` modifier can be found
    at [http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined](http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个接受六个参数并让我们定义一个变换矩阵的`matrix`修饰符。有关`matrix`修饰符的更多信息可以在[http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined](http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined)找到。
- en: 'Let''s experiment with these modifiers in a small demo:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个小演示中尝试这些修饰符：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, transformations can be combined in order to obtain some interesting
    results. The following is a screenshot of this demo running in a CSS3-compliant
    browser:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，变换可以组合在一起以获得一些有趣的结果。以下是在符合CSS3标准的浏览器中运行此演示的屏幕截图：
- en: '![CSS3 transforms](img/3264OT_04_13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![CSS3变换](img/3264OT_04_13.jpg)'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Another good feature to note is the fact that the element position is calculated
    *before* the transformation is applied. A proof of this is the fact that the scaled
    `div` element doesn't move the others down, but simply overlaps them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要注意的好功能是元素位置在应用变换之前进行计算。这一点的证明是缩放的`div`元素不会使其他元素向下移动，而只是重叠。
- en: Applying transformations
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用变换
- en: 'Now we only need to put together what we have just learned, and transform the
    infographic in response to a click of one of the commands. To have a smooth transformation,
    let''s specify a transition of `1` second to all the transform properties in `application.css`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将我们刚学到的东西放在一起，并在点击其中一个命令时转换信息图。为了实现平滑的变换，让我们在`application.css`中的所有变换属性上指定一个`1`秒的过渡：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Good! Let''s reload the project in a browser:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！让我们在浏览器中重新加载项目：
- en: '![Applying transformations](img/3264OT_04_14.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![应用变换](img/3264OT_04_14.jpg)'
- en: Flashing issues
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闪烁问题
- en: 'All of the latest Chrome versions (up to version 18 at the time of writing)
    switch between CPU and GPU-accelerated graphics when some CSS properties are applied
    (transitions are among them). This could generate a flash on the screen if the
    computer is not fast enough to handle it. One solution is to force Chrome to apply
    a GPU-accelerated property when the page loads. In this solution, the 3D transform
    properties we''ll see in the next few chapters come in handy, so we can add a
    null `translateZ` property to the `body` element as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，所有最新版本的Chrome浏览器（截至18版本）在应用某些CSS属性时会在CPU和GPU加速图形之间切换（其中包括过渡）。如果计算机处理不够快，这可能会在屏幕上产生闪烁。一种解决方法是在页面加载时强制Chrome应用GPU加速属性。在这种解决方案中，我们将在接下来的几章中看到的3D变换属性非常有用，因此我们可以向`body`元素添加一个空的`translateZ`属性，如下所示：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, we have to remember that this solution lowers the quality of the SVG
    because Chrome doesn't seem to refine graphics after a `transform` property while
    accelerated. Additionally, 3D transform properties such as the one we just used
    should be treated with caution on mobile environments as they are memory intensive.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须记住，这种解决方案降低了SVG的质量，因为Chrome似乎不会在加速后对图形进行细化。此外，像我们刚刚使用的这样的3D变换属性在移动环境中应该谨慎对待，因为它们占用内存。
- en: Adding a mask
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加蒙版
- en: We might want to add a small description mask for each of the zoom areas available.
    In the mask, we also want the user to be able to move between the zoomed areas
    using small arrows.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想为每个可用的缩放区域添加一个小的描述蒙版。在蒙版中，我们还希望用户能够使用小箭头在缩放区域之间移动。
- en: 'First of all let''s define the HTML needed: there will be four masks, one for
    each of the three commands, and one for the central area. We can add the required
    markup just after the `</section>` tag:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义所需的HTML：将有四个蒙版，一个用于三个命令中的每一个，一个用于中心区域。我们可以在`</section>`标签之后添加所需的标记：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we have to place the `#mask` element just below the bottom line of the
    viewport, and activate it when one of the commands is triggered. So let''s write
    the following instructions in `application.css`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将`#mask`元素放置在视口底线的下方，并在触发其中一个命令时激活它。因此，让我们在`application.css`中写入以下指令：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the highlighted chunk of code, we instructed the browser to:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的突出部分，我们指示浏览器：
- en: Hide the `#mask` element below the browser bottom line
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏`#mask`元素在浏览器底线以下
- en: Hide all the `div` elements within the `#mask` element
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏`#mask`元素内的所有`div`元素
- en: Show only the `div` element within the `#mask` element corresponding to the
    targeted `a` element
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅显示与目标`a`元素对应的`#mask`元素内的`div`元素
- en: Reveal the `#mask` element when one of the `a` elements is `:target`
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`a`元素是`:target`时，显示`#mask`元素
- en: 'Now we need to take care of the `italy2` anchor. So let''s add another `a`
    element just before `<section>` in `index.html`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要处理`italy2`锚点。因此，让我们在`index.html`中的`<section>`之前再添加一个`a`元素：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the corresponding CSS in `application.css`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在`application.css`中对应的CSS：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Well done! Now let''s reload the project in the browser:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在让我们在浏览器中重新加载项目：
- en: '![Adding a mask](img/3264OT_04_15.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![添加蒙版](img/3264OT_04_15.jpg)'
- en: Targeting SVG with CSS
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用CSS定位SVG
- en: 'Ok, time for some final touches. What we want now is to provide a mechanism
    to toggle the visibility of the labels of the infographic. Due to the fact that
    our SVG is inline, we can turn them off by simply adding `opacity: 0` to their
    `id` selector, in the same way as we would have done with plain HTML elements.
    So let''s add the following lines to `application.css`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '好的，是时候做最后的修饰了。现在我们想要的是提供一个机制来切换信息图表标签的可见性。由于我们的SVG是内联的，我们可以通过简单地向它们的`id`选择器添加`opacity:
    0`来关闭它们，就像我们对普通HTML元素所做的那样。因此，让我们在`application.css`中添加以下行：'
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next step is to find a way to let the user toggle the `opacity` value. We
    can achieve this result using a checkbox and taking advantage of the `:checked`
    pseudo-selector more or less as we did with the `:target` one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到一种让用户切换`opacity`值的方法。我们可以使用复选框来实现这个结果，并利用`:checked`伪选择器，就像我们使用`:target`一样。
- en: 'So, first of all let''s add a checkbox just before the `<section>` tag in our
    `index.html` file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先让我们在`index.html`文件中的`<section>`标签之前添加一个复选框：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then, let''s add the corresponding label just before the `</ul>` tag in
    the `nav` command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`nav`命令的`</ul>`标签之前添加相应的标签：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now add the following lines to `application.css`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`application.css`中添加以下行：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is a final screenshot of our project:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们项目的最终截图：
- en: '![Targeting SVG with CSS](img/3264OT_04_16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![用CSS定位SVG](img/3264OT_04_16.jpg)'
- en: Graceful degradation
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优雅降级
- en: Because we added CSS transformations, things started to go wrong on older browsers.
    In fact, both transformations and the `:target` pseudo-selector are not supported
    on older browsers, so we have to find a valid alternative. One solution can be
    to listen to URL hash changes via JavaScript and use a `hashchange` event to add
    a class reflecting the current hash to both `section` and `#mask` elements. This
    class can then be used to trigger some CSS properties.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们添加了CSS变换，旧版浏览器开始出现问题。事实上，旧版浏览器不支持变换和`:target`伪选择器，因此我们必须找到一个有效的替代方案。一个解决方案可以是通过JavaScript监听URL哈希变化，并使用`hashchange`事件将当前哈希值反映到`section`和`#mask`元素的类中。然后可以使用这个类来触发一些CSS属性。
- en: To be able to listen to the `hashchange` event on older browsers, we need a
    small JavaScript library. We can download it from [http://benalman.com/code/projects/jquery-hashchange/docs/files/jquery-ba-hashchange-js.html](http://benalman.com/code/projects/jquery-hashchange/docs/files/jquery-ba-hashchange-js.html),
    rename it to `jquery.hashchange.js`, and place it in our `js` folder. Next we
    have to replace our copy of Modernizr (`js/modernizr.js`) with a new one that
    also includes the test for **multiple backgrounds**. To achieve this, we can use
    the same procedure as discussed earlier.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在旧版浏览器上监听`hashchange`事件，我们需要一个小的JavaScript库。我们可以从[http://benalman.com/code/projects/jquery-hashchange/docs/files/jquery-ba-hashchange-js.html](http://benalman.com/code/projects/jquery-hashchange/docs/files/jquery-ba-hashchange-js.html)下载它，将其重命名为`jquery.hashchange.js`，并放置在我们的`js`文件夹中。接下来，我们必须用一个包含**多重背景**测试的新版本替换我们的Modernizr副本(`js/modernizr.js`)。为了实现这一点，我们可以使用与之前讨论过的相同的过程。
- en: 'Now we need to insert this library and then add some small JavaScript code
    just before the `</body>` tag:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要插入这个库，然后在`</body>`标签之前添加一些小的JavaScript代码：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Good! Now we can emulate the `transform` property by varying the width, height,
    and position of the `img.panel` element. Additionally, we can also use the class
    we added dynamically with JavaScript to show and hide the `#mask` element.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！现在我们可以通过改变`img.panel`元素的宽度、高度和位置来模拟`transform`属性。此外，我们还可以使用JavaScript动态添加的类来显示和隐藏`#mask`元素。
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following screenshot shows the final result:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了最终结果：
- en: '![Graceful degradation](img/3264OT_04_17.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![优雅降级](img/3264OT_04_17.jpg)'
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to deal with CSS3 properties that structurally
    affect our page. We also discovered transformations, and some cool ways to interact
    with SVG. In the next chapter, we'll discuss how to enhance an image gallery.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何处理对我们页面结构产生影响的CSS3属性。我们还发现了转换，以及一些与SVG互动的酷炫方式。在下一章中，我们将讨论如何增强图库。
