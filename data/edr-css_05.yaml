- en: Chapter 5. File Organisation and Naming Conventions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。文件组织和命名约定
- en: In the last chapter we took a high-level overview of the design considerations
    of ECSS. In this chapter we will start digging a little deeper into how we actually
    get started using ECSS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对ECSS的设计考虑进行了高层次的概述。在本章中，我们将深入探讨如何实际开始使用ECSS。
- en: Two cornerstones of making ECSS work for you are adhering to the file organisation
    and class naming convention principles. Let's look at each of these aspects next.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使ECSS适合您的两个基石是遵守文件组织和类命名约定原则。让我们接下来看看这些方面。
- en: Project organisation
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目组织
- en: If we want to facilitate the easy removal of code from our website/application,
    we need to think about the way we organise the files that make up our project.
    Typically, when building websites, particularly web applications, it's useful
    to think in terms of modules or components; definable sections of the user interface.
    These modules might be defined primarily by visual areas or perhaps due to the
    files that generate them. Either way, taking the time to consider the organisation
    of these modules is well worth the time investment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要方便地从我们的网站/应用程序中删除代码，我们需要考虑我们组成项目的文件的方式。通常，在构建网站，特别是Web应用程序时，考虑模块或组件的方式是有用的；可定义的用户界面部分。这些模块可能主要由视觉区域定义，或者可能由生成它们的文件定义。无论哪种方式，花时间考虑这些模块的组织都是值得的。
- en: Ordinarily, it's a common practice to split the files in a project by technology
    type.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，按技术类型将项目中的文件拆分是一种常见做法。
- en: 'Consider this basic folder structure:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个基本的文件夹结构：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In each of these folders you might name related files. For example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文件夹中，您可能会命名相关文件。例如：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The rub though is that beyond a certain point, even giving the files related
    names, it's difficult to reason about how each style sheet, logic file and template
    in a project relate. There might be 80+ CSS partials in the `css` folder and 50+
    template stubs in the `html` folder.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题在于，超过一定程度后，即使给文件命名，也很难理清项目中每个样式表、逻辑文件和模板之间的关系。在`css`文件夹中可能有80多个CSS部分，在`html`文件夹中可能有50多个模板存根。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I recognise the reality is that the *view* part of a website or application
    is usually generated by any number of different technologies such as Ruby, PHP,
    .NET or even JavaScript - rather than vanilla HTML.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到现实情况是，网站或应用程序的*view*部分通常是由多种不同的技术生成的，如Ruby、PHP、.NET甚至JavaScript - 而不是纯粹的HTML。
- en: It then becomes increasingly necessary to rely on *find* in the text editor/IDE
    to find any templates that a certain class is being used on. The same is true
    in reverse; *find* is needed to locate the partial(s) that contain the styles
    needed for a certain module template.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，越来越需要依赖*find*在文本编辑器/IDE中查找某个类别正在使用的任何模板。反之亦然；需要*find*来定位包含某个模块模板所需样式的部分。
- en: This structure doesn't make things unworkable, just inefficient and it typically
    requires a little mental orientation to remember what goes with what.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构并不会使事情变得不可行，只是效率低下，通常需要一点心理定位来记住什么与什么相关。
- en: 'While not essential for ECSS, it''s generally preferable that rather than organise
    by technology type, files are organised and grouped by visual or logical component.
    So, instead of this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于ECSS来说并非必需，但通常更倾向于按视觉或逻辑组件组织文件，而不是按技术类型组织。因此，不是这样：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We aim for something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是这样的：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At first glance this may seem like a seemingly unimportant distinction but it
    brings important benefits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是一个看似不重要的区别，但它带来了重要的好处。
- en: The code for each component becomes physically self-enclosed. Then, on our enduring
    project, when features need changing or are deprecated, all associated code for
    that module (styles, view logic (HTML), and JS) can be easily updated/removed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件的代码都是物理上自包含的。然后，在我们持久的项目中，当需要更改或废弃功能时，可以轻松更新/删除与该模块相关的所有代码（样式、视图逻辑（HTML）和JS）。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Due credit**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**应有的赞誉**'
- en: '*Nicolas Gallagher* ([http://nicolasgallagher.com/](http://nicolasgallagher.com/))
    is always ahead of the game when it comes to thinking about CSS implementations
    at scale and I took and adapted large elements (specifically code organisation
    by component) of this approach from his work. I''d been name-spacing components
    for some time (and I''m therefore claiming pseudo multiple discovery) but the
    approach of organising code by component is taken entirely from *hearing him talk*
    ([https://www.youtube.com/watch?v=m0oMHG6ZXvo](https://www.youtube.com/watch?v=m0oMHG6ZXvo))
    on this matter.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nicolas Gallagher* ([http://nicolasgallagher.com/](http://nicolasgallagher.com/))
    在考虑规模化的CSS实现时总是领先一步，我从他的工作中借鉴并调整了大部分元素（特别是按组件组织代码）。我已经为组件命名空间化了一段时间（因此我宣称伪多重发现），但按组件组织代码的方法完全是从*听他谈论*
    ([https://www.youtube.com/watch?v=m0oMHG6ZXvo](https://www.youtube.com/watch?v=m0oMHG6ZXvo))
    中得来的。'
- en: With the exception of intentionally *global* CSS, all code that relates to the
    presentation of a component or module should be included in the partials that
    sit alongside the HTML/JS of that component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有意的*全局*CSS之外，与组件或模块的呈现相关的所有代码都应包含在与该组件的HTML/JS并列的部分中。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although you may not like it, there's always a degree of global CSS needed;
    at the very least a simple set of reset or normalise styles for example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能不喜欢，但总是需要一定程度的全局CSS；至少需要一组简单的重置或规范化样式。
- en: When a module is deprecated, all files associated with it can be easily removed
    from the codebase in one go; just delete the folder containing the module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块被废弃时，可以轻松地一次性从代码库中删除与之相关的所有文件；只需删除包含该模块的文件夹。
- en: 'Just to be crystal clear, consider this folder structure for our imagined `ShoppingCart`
    component:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，考虑我们想象中的`ShoppingCart`组件的文件夹结构：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now suppose we create a new shopping cart:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们创建一个新的购物车：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As soon as our `v2` shopping cart is finished, it's easy to remove the code
    for the prior version from our code base; we just delete the folder `ShoppingCart`
    containing our old code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`v2`购物车完成，就可以轻松地从我们的代码库中删除先前版本的代码；我们只需删除包含旧代码的`ShoppingCart`文件夹。
- en: When same folder organisation isn't possible
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当无法使用相同的文件夹组织时
- en: It may not be possible or preferable to contain style sheets, assets, and application
    logic within the same folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可能无法或不希望将样式表、资源和应用程序逻辑包含在同一个文件夹中。
- en: 'In that situation, the next best choice is to mimic the structure of the logic.
    To exemplify. Suppose the logic for a component is stored in a folder structure
    like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，下一个最佳选择是模仿逻辑的结构。举例来说。假设一个组件的逻辑存储在这样的文件夹结构中：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We should mimic this structure as far as possible. On any sizeable application
    this will make locating related files easier. So we might do this – matching the
    folder hierarchy of the logic file as much as possible:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应尽可能模仿这种结构。在任何规模的应用程序中，这将使查找相关文件变得更容易。因此，我们可以这样做-尽可能地匹配逻辑文件的文件夹层次结构：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Same parent folder should definitely be considered the *gold* standard when
    using ECSS but in the absence of that, mimicking the structure of the logic files
    should provide some of the benefits.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ECSS时，相同的父文件夹应该被认为是*黄金*标准，但在没有这种情况下，模仿逻辑文件的结构应该能够提供一些好处。
- en: With a concrete idea of how to organise the files within our project, let's
    turn to the principle way in which we can convey additional meaning and developer
    convenience to our selectors/classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有了如何组织项目中的文件的具体想法，让我们转向我们可以向我们的选择器/类传达附加含义和开发人员便利的主要方式。
- en: Naming classes and selectors with ECSS
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ECSS命名类和选择器
- en: Back in [Chapter 3](ch03.html "Chapter 3. Implementing Received Wisdom"), *Implementing
    Received Wisdom*, I recognised the benefits that the BEM approach of naming CSS
    selectors gave us. Naming a block and then naming any child elements in relation
    to that block created a namespace for the child elements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第3章](ch03.html "第3章。实施接收到的智慧")，*实施接收到的智慧*，我意识到BEM方法在命名CSS选择器方面给我们带来的好处。首先命名一个块，然后根据该块命名任何子元素，为子元素创建了一个命名空间。
- en: Namespacing the CSS of a module creates a form of isolation. By preventing name
    collisions with other elements, chunks of CSS can be more easily moved from one
    environment to another (from prototype to production for example). It's also far
    less likely that a change of styles on one selector would inadvertently affect
    another.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的CSS命名空间创建了一种隔离形式。通过防止与其他元素发生名称冲突，CSS块可以更轻松地从一个环境移动到另一个环境（例如从原型到生产）。这也大大减少了一个选择器的样式更改无意中影响其他选择器的可能性。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a number of other approaches to solve the name collision problem.
    For example, if you are building an application with the popular *React* ([https://facebook.github.io/react/](https://facebook.github.io/react/))
    framework, consider *Radium* ([https://github.com/FormidableLabs/radium](https://github.com/FormidableLabs/radium))
    which will inline the styles for each node so you can effectively serve no CSS
    at all. Naturally, there are trade-offs such as a lack of caching and no way to
    add reset styles but it it certainly solves the issue at hand. In addition, when
    not building with React, consider *CSS Modules* ([https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules)).
    While requiring more involved tooling than ECSS it means you could forgo having
    to think about naming things altogether as it creates CSS scoped for you. Read
    *more about that here* ([https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284](https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他方法来解决名称冲突的问题。例如，如果您正在使用流行的*React* ([https://facebook.github.io/react/](https://facebook.github.io/react/))
    框架构建应用程序，请考虑使用*Radium* ([https://github.com/FormidableLabs/radium](https://github.com/FormidableLabs/radium))，它将为每个节点内联样式，因此您可以有效地不提供任何CSS。当然，这也存在一些权衡，比如缺乏缓存和无法添加重置样式，但它确实解决了手头的问题。此外，当不使用React构建时，请考虑*CSS模块*
    ([https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules))。虽然需要比ECSS更多的工具支持，但它意味着您可以完全不考虑命名事物，因为它会为您创建CSS作用域。在这里*了解更多*
    ([https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284](https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284))。
- en: 'ECSS takes the notion of selector namespacing and turns it *up to 11* ([https://en.wikipedia.org/wiki/Up_to_eleven](https://en.wikipedia.org/wiki/Up_to_eleven)).
    Selectors are effectively namespaced in two ways:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ECSS采用选择器命名空间的概念，并将其*提升到11* ([https://en.wikipedia.org/wiki/Up_to_eleven](https://en.wikipedia.org/wiki/Up_to_eleven))。选择器实际上以两种方式进行命名空间：
- en: 'A micro namespace: usually used to designate context but can also indicate
    a parent module'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型命名空间：通常用于指定上下文，但也可以指示父模块
- en: 'The module''s own namespace: usually the name of the logic file that created
    the element in question'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块自己的命名空间：通常是创建所讨论元素的逻辑文件的名称
- en: Let's look at these in more detail. The *micro* namespace is a simple 2–3 letter
    namespace for each module. Building a shopping cart? Try`.` `sc-` as your micro
    namespace. Building the next version of that same shopping cart? That'll be`.`
    `sc2-` then. It's just enough to isolate your component styles and allow the styles
    to be more self documenting. Let's consider a more involved example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些。*微型*命名空间是每个模块的简单2-3个字母的命名空间。构建购物车？尝试使用`.` `sc-` 作为您的微型命名空间。构建同一购物车的下一个版本？那就是`.`
    `sc2-`。这足以隔离您的组件样式，并允许样式更具自我说明性。让我们考虑一个更复杂的例子。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When it comes to naming things, different things will make sense in different
    projects. While ECSS can happily adapt to different approaches, I would recommend
    a consistent approach on each project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名事物时，不同的项目会有不同的合理性。虽然ECSS可以适应不同的方法，但我建议在每个项目中采用一致的方法。
- en: For example, suppose the micro namespace was being used to convey the parent
    or origin of the logic that created it. Back to our shopping cart example. We
    might have a file called `ShoppingCart.php` that contains all the logic relating
    to our imaginary shopping cart. We could therefore use `sc-` as an abbreviation
    of that file name so we know that any elements that begin with that namespace
    relate to the shopping cart and are rendered by that related file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设微命名空间用于传达创建它的逻辑的父级或起源。回到我们的购物车示例。我们可能有一个名为`ShoppingCart.php`的文件，其中包含了与我们想象中的购物车相关的所有逻辑。因此，我们可以使用`sc-`作为该文件名的缩写，以便我们知道以该命名空间开头的任何元素都与购物车相关，并由相关文件渲染。
- en: 'In this case, we would then have selectors like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将有类似以下的选择器：
- en: '`sc-Title` : The title of the shopping cart'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sc-Title`：购物车的标题'
- en: '`sc-RemoveBtn` : A button that removes an item from the shopping cart'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sc-RemoveBtn`：从购物车中移除物品的按钮'
- en: 'Here the selectors are quite compact-aesthetically pleasing if a selector can
    even be described in that way. However, suppose we have a shopping cart which
    can live in multiple contexts. A mini cart view and a full page view. In that
    instance we might decide to use the micro namespace to convey context. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的选择器非常紧凑-如果一个选择器甚至可以用这种方式描述的话，那么它在美学上是令人愉悦的。然而，假设我们有一个可以存在于多个上下文中的购物车。迷你购物车视图和完整页面视图。在这种情况下，我们可能决定使用微命名空间来传达上下文。例如：
- en: '`mc-ShoppingCart_Title` : The title of the shopping cart, generated by the
    file `ShoppingCart` when in the *mini cart* view/context.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mc-ShoppingCart_Title`：购物车的标题，在*迷你购物车*视图/上下文中由文件`ShoppingCart`生成。'
- en: '`mc-ShoppingCart_RemoveBtn` : The remove button of the shopping cart, generated
    by the file `ShoppingCart` when in the *mini cart* view/context.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mc-ShoppingCart_RemoveBtn`：购物车的删除按钮，在*迷你购物车*视图/上下文中由文件`ShoppingCart`生成。'
- en: Neither of these is the one true way. Part of ECSS philosophy is that while
    some core principles are essential, it can adapt to differing needs. Generally
    speaking, for smaller scale use cases, the former approach is fine. However, despite
    the comparative verbosity of the selectors in the second approach, it is the most
    resilient and self-documenting. With the second approach you know context, the
    file that generated the selector (and therefore the module it belongs to) and
    the element it relates to.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都不是唯一的方法。ECSS哲学的一部分是，虽然一些核心原则是必不可少的，但它可以适应不同的需求。一般来说，对于较小规模的用例，前一种方法是可以的。然而，尽管第二种方法中选择器的相对冗长，但它是最具弹性和自我记录的。通过第二种方法，您可以了解上下文，生成选择器的文件（因此它所属的模块）和它所关联的元素。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is more specific information about applying ECSS conventions to web applications
    and visual modules in [Chapter 7](ch07.html "Chapter 7. Applying ECSS to Your
    Website or Application"), *Applying ECSS to Your Website or Application*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。将ECSS应用于您的网站或应用程序")中，有关将ECSS约定应用于Web应用程序和视觉模块的更具体信息，*将ECSS应用于您的网站或应用程序*。
- en: Reiterating the benefits
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重申好处
- en: As namespaced modules and components are almost guaranteed to not leak into
    one another, it makes it incredibly easy to build out and iterate on new designs.
    It affords a hitherto un-thinkable blanket of impunity. Just make a new partial
    file for the thing you are building, assign a suitable micro-namespace and module
    name and write your styles, confident in the fact you won't be adversely affecting
    anything you don't want to. If the new thing you are building doesn't work out,
    you can just delete the partial file, also confident that you won't be removing
    the styles for something else. CSS authoring and maintenance confidence - finally!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命名空间模块和组件几乎肯定不会相互泄漏，因此非常容易构建和迭代新设计。这提供了一个迄今为止难以想象的免责保护。只需为正在构建的事物创建一个新的部分文件，分配一个合适的微命名空间和模块名称，并编写您的样式，确信您不会对任何不想要的东西产生不利影响。如果您正在构建的新事物不起作用，您可以删除部分文件，也可以确信您不会删除其他东西的样式。CSS编写和维护的信心-终于！
- en: Source order becomes unimportant
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源顺序变得不重要
- en: 'As our rules are now isolated, it makes the order of rules in a style sheet
    unimportant. This benefit becomes essential when working on a large-scale project.
    In these scenarios it is often preferable for partial files to be assembled in
    any order. With rules isolated from each other, this is simple. With our *self-quarantined* rules,
    it makes file globbing of partial styles sheets simple and risk free. With some
    basic tooling in place you can compile all the CSS partials within a module in
    one fell swoop like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的规则现在是隔离的，因此样式表中规则的顺序变得不重要。在处理大型项目时，这一好处变得至关重要。在这些情况下，通常希望可以以任何顺序组装部分文件。由于规则彼此隔离，这很简单。有了我们的*自我隔离*规则，部分样式表的文件全局匹配变得简单且无风险。通过一些基本的工具，您可以像这样一次性编译模块中的所有CSS部分：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: No more writing `@import` statements for every partial in a project and worrying
    about the order they are in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不再为项目中的每个部分编写`@import`语句，并担心它们的顺序。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We will talk more about file globbing in [Chapter 9](ch09.html "Chapter 9. Tooling
    for an ECSS Approach"), *Tooling for an ECSS Approach*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](ch09.html "第9章。ECSS方法的工具")中更多地讨论文件全局匹配，*ECSS方法的工具*。
- en: Anatomy of the ECSS naming convention
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECSS命名约定的解剖
- en: As the naming of items is so useful and essential to achieving our goals, the
    following section documents the naming convention of ECSS in more detail. Think
    of this like a *Haynes manual* ([https://haynes.co.uk/catalog/manuals-online](https://haynes.co.uk/catalog/manuals-online))
    for your CSS selectors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目名称对于实现我们的目标非常有用和必要，下一节将更详细地记录ECSS的命名约定。把它想象成你的CSS选择器的*Haynes手册*([https://haynes.co.uk/catalog/manuals-online](https://haynes.co.uk/catalog/manuals-online))。
- en: 'Here''s a breakdown of an ECSS selector:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是ECSS选择器的分解：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To illustrate the separate sections, here is the anatomy of that selector with
    the sections delineated with square brackets:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明各个部分，这是该选择器的解剖，用方括号划分各个部分：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: With more than a couple of developers on a project I'd recommended that commits
    to a codebase are automatically rejected that don't follow the ECSS naming pattern.
    Some information on necessary tooling to facilitate this is covered in [Chapter
    9](ch09.html "Chapter 9. Tooling for an ECSS Approach"), *Tooling for an ECSS
    Approach*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个项目中有多个开发人员的情况下，我建议对不遵循ECSS命名模式的代码提交进行自动拒绝。关于必要的工具支持的一些信息在[第9章](ch09.html
    "第9章 工具支持ECSS方法")中有所涉及，*工具支持ECSS方法*。
- en: Explanation of selector sections
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择器部分的解释
- en: 'Let''s go back over the various parts of the ECSS selector and the allowed
    character types:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下ECSS选择器的各个部分和允许的字符类型：
- en: '`Namespace`: This is a **required** part of every selector. The micro-namespace
    should be all lowercase/train-case. It is typically an abbreviation to denote
    context or originating logic.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Namespace`：这是每个选择器的**必需**部分。微命名空间应该全部小写/短横线命名法。通常是一个缩写，用于表示上下文或起始逻辑。'
- en: '`Module or Component`: This is a upper camel case/pascal case. It should always
    be preceded by a hyphen character (`-`).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模块或组件`：这是大驼峰命名法。它应该始终前面有一个连字符（`-`）。'
- en: '`ChildNode`: This is an optional section of the selector. It should be upper
    camel case/pascal case and preceded by an underscore (`_`).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChildNode`：这是选择器的一个可选部分。它应该是大驼峰命名法，并且前面有一个下划线（`_`）。'
- en: '`Variant`: This is a further optional section of the selector. It should be
    written all lowercase/train-case.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Variant`：这是选择器的另一个可选部分。它应该全部小写/短横线命名法。'
- en: 'Using this syntax, each part of a class name can be logically discerned from
    another. More information on what these sections are and how they should be employed
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法，类名的每个部分都可以从另一个逻辑上区分出来。更多关于这些部分是什么以及它们应该如何使用的信息如下：
- en: Namespace
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: As discussed above, the first part of a HTML class/CSS selector is the micro
    namespace (all lowercase/train-case). The namespace is used to prevent collisions
    and provide some soft isolation for easier maintenance of rules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，HTML类/CSS选择器的第一部分是微命名空间（全部小写/短横线命名法）。命名空间用于防止冲突，并为规则的更轻松维护提供一些软隔离。
- en: Module or Component
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块或组件
- en: This is the visual module or piece of logic that created the selector. It should
    be written in upper camel case. I've seen ECSS applied to great effect when the
    module or component directly references the name of the file that creates it.
    For example, a file called `CallOuts.js` could have a selector such as `sw-CallOuts`
    (the `sw-` micro namespace here used to denote it would be used *Site Wide*).
    This removes any ambiguity for future developers as to the origin point of this
    element.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建选择器的视觉模块或逻辑片段。它应该用大驼峰命名法。我看到ECSS被成功应用时，模块或组件直接引用了创建它的文件的名称。例如，一个名为`CallOuts.js`的文件可以有一个选择器，如`sw-CallOuts`（这里的`sw-`微命名空间用于表示它将被*站点范围*使用）。这样可以消除未来开发人员对该元素起点的歧义。
- en: Child node
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子节点
- en: If something UpperCamelCase is preceded by an underscore (`_`) it is a child
    node of a module or component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个大驼峰命名法前面有一个下划线（`_`），那么它是模块或组件的子节点。
- en: 'For example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `_Header` is indicating that this node is the `Header` child node of the
    `Item` module or component that belongs to the `sc` namespace (and if it it were
    a component, that namespace could indicate the parent module).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_Header`表示这个节点是属于`sc`命名空间的`Item`模块或组件的`Header`子节点（如果它是一个组件，那么该命名空间可以表示父模块）。
- en: Variant
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变体
- en: 'If something is all lowercase/train-case and not the first part of a class
    name it is a variant flag. The variant flag is reserved for eventualities where
    many variants of a selector need to be referenced. Suppose we have a module that
    needs to display a different background image depending upon what category number
    has been assigned to it. We might use the variant indicator like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个东西全部小写/短横线命名法，并且不是类名的第一部分，那么它是一个变体标志。变体标志保留用于需要引用许多选择器变体的情况。假设我们有一个模块，需要根据分配给它的类别编号显示不同的背景图像。我们可以像这样使用变体指示器：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here the `-bg3` part of the selector indicates that this`.` `sc-Item_Header`
    is the category 3 version (and can therefore have an appropriate style assigned).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择器的`-bg3`部分表示这个`sc-Item_Header`是类别3版本（因此可以分配适当的样式）。
- en: Doubling up on ECSS selectors
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在ECSS选择器上加倍
- en: Our previous example indicates a perfect situation where it would be appropriate
    to use two classes on the element. One to assign default styles and another to
    set specifics of a variant.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子表明了一个完美的情况，适合在元素上使用两个类。一个用于分配默认样式，另一个用于设置变体的具体内容。
- en: 'Consider this markup:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个标记：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we would set the universal styles for the element with `sc-Item_Header`
    and then the styles specific to the variant with `sc-Item_Header-bg1`. There's
    nothing revolutionary about this approach, I'm just documenting it here to make
    it clear there is nothing in the ECSS approach that precludes this practice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`sc-Item_Header`为元素设置通用样式，然后使用`sc-Item_Header-bg1`为变体设置特定样式。这种方法并不具有革命性，我只是在这里记录它，以明确指出ECSS方法中没有任何阻止这种做法的地方。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We''ve covered a lot of detail in this chapter. The two main areas we looked
    at were how to organise the language files of our project so that they can be
    more easily maintained and how to name HTML classes/CSS selectors in ECSS so that
    the class of an element in the DOM can tell us everything we need to know about
    its origin, purpose and intended context. We also had a detailed look at the accepted
    syntax for ECSS selectors: where and how to apply casing differences to delineate
    different parts of the selector. So far, we have only concerned ourself with static
    elements. In the next chapter we will look at how ECSS deals with the changing
    state of a website or application.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了很多细节。我们主要关注了两个方面：如何组织项目的语言文件，以便更容易维护；以及如何命名HTML类/CSS选择器，使得DOM中元素的类可以告诉我们关于其来源、目的和预期上下文的一切。我们还详细研究了ECSS选择器的接受语法：在哪里以及如何应用大小写区别来划分选择器的不同部分。到目前为止，我们只关注静态元素。在下一章中，我们将看看ECSS如何处理网站或应用程序的变化状态。
