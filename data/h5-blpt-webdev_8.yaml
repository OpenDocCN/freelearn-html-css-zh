- en: Appendix A. You Are an Expert,Now What?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A.你现在是一名专家，接下来做什么？
- en: We are all set with our website. We have learned how to write its code, build
    it with the build scripts and deploy it to the production code, so that it goes
    live without any hiccups. You are effectively done learning HTML5 Boilerplate.
    If you are curious in becoming a better web developer, you could spend time understanding
    some other relevant and useful parts of the Web! Let us explore a few of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好我们的网站了。我们学会了如何编写它的代码，使用构建脚本来构建它，以及将其部署到生产环境中，这样它就能顺利上线。你已经有效地掌握了HTML5
    Boilerplate的学习。如果你对成为一个更好的网页开发者感兴趣，你可以花时间去了解网络相关的其他有用部分！让我们一起探索其中的一些。
- en: Writing unit tests for your code
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的代码编写单元测试
- en: We wrote some JavaScript for our website. While the browsers let us know if
    the code is written incorrectly, there is no way to tell if the code works as
    intended. Perhaps there are edge cases that we failed to account for. The code
    should be as robust as possible and works around all expected use cases and is
    capable of handling most error conditions. You can ensure this is possible by
    writing tests to test every function your code calls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的网站编写了一些JavaScript代码。虽然浏览器会告诉我们代码是否编写错误，但没有办法告诉我们代码是否如预期工作。也许有些边缘情况我们没有考虑到。代码应该尽可能健壮，并处理所有预期的用例和大多数错误条件。你可以通过编写测试来测试你的代码调用的每个函数，从而确保这是可能的。
- en: A unit can be considered as the smallest testable part of your code. When you
    write unit tests, you ensure every section of the code behaves correctly. The
    easiest way to get started with unit tests is to use a test suite.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以被认为是你的代码中最小的可测试部分。当你编写单元测试时，你确保代码的每个部分都正确运行。开始编写单元测试的最简单方法是使用测试套件。
- en: '`QUnit.js` is a popular browser-based test suite that tests your code in the
    browser. Let us use this on our code that we wrote for the Sun and Sand Festival
    website.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`QUnit.js`是一个流行的基于浏览器的测试套件，用于在浏览器中测试你的代码。让我们在我们的为阳光与沙滩音乐节网站编写的代码中使用它。'
- en: Creating a testing environment
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试环境
- en: Let us create a `tests` folder within our project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的项目中创建一个`tests`文件夹。
- en: Then, we download `QUnit.js` from `code.jquery.com/qunit/qunit-1.9.0.js` and
    the associated CSS file `qunit.css` from `code.jquery.com/qunit/qunit-1.9.0.css`.
    The latest versions of these files can be found at `github.com/jquery/qunit`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`code.jquery.com/qunit/qunit-1.9.0.js`下载`QUnit.js`，并从`code.jquery.com/qunit/qunit-1.9.0.css`下载相关的CSS文件`qunit.css`。这些文件的最新版本可以在`github.com/jquery/qunit`找到。
- en: 'We now create a testing environment by creating a `tests.html` page within
    the `tests` folder, and have the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过在`tests`文件夹中创建一个`tests.html`页面来创建一个测试环境，并具有以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we have included our `main.js`, file that we are using on our
    website. We will be testing the code we wrote for the tabs used to display the
    line up.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们包括了我们的`main.js`文件，这个文件是我们网站所使用的。我们将测试我们为显示阵容而编写的标签代码。
- en: Now, we will create the `test.js` file, where we will write all our tests for
    our code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`test.js`文件，我们将在其中编写我们代码的所有测试。
- en: As our test depends on the markup that is used for the tabs, let us copy the
    markup without the content from `index.html` to `tests.html`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的测试依赖于用于标签的标记，让我们从`index.html`中复制不含内容的标记到`tests.html`。
- en: 'If we execute this test as it is, we will get an error claiming global failure.
    If you open up the console of your browser''s developer tools, you should see
    the following error:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按原样执行这个测试，我们会得到一个全局失败的错误。如果你打开浏览器开发者工具的控制台，你应该会看到以下的错误：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is because we invoke the plugins from `main.js` but we have not included
    those plugins here because we are not testing them. We can corral all of our plugin-dependent
    code and invoke them only if QUnit is not used, by testing for the existence of
    QUnit first before invoking plugins and frameworks like in the following snippet
    of code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们从`main.js`中调用插件，但我们在这里没有包含这些插件，因为我们不是在测试它们。我们可以在QUnit没有被使用的情况下，只测试插件和框架的存在，如以下代码片段所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Make sure you remove the condition—`if(window.QUnit == undefined)`—in the production
    code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你移除生产代码中的条件—`if(window.QUnit == undefined)`。
- en: 'Now, let us write a test to confirm that when a navigation tab is clicked the
    correct class is applied to itself by using the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们写一个测试，以确认当一个导航标签被点击时，正确的类被应用于它，使用以下的代码片段：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `test()` function is a function available from the QUnit test suite. The
    first argument is the title of the text, and the second is the actual test function
    you want to execute.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`test()`函数是QUnit测试套件中可用的函数。第一个参数是文本的标题，第二个参数是你想要执行的实际测试函数。'
- en: We also use `ok()`, which is one of the assertions from the QUnit test suite
    to confirm the class does apply. An assertion is an essential element of unit
    testing, where you test if the result of the execution of your code returns the
    expected value. QUnit has different kinds of assertions that are all documented
    at `api.qunitjs.com/category/assert/`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`ok()`，这是QUnit测试套件中的一个断言。断言是单元测试的基本元素，在这里你测试你的代码执行结果是否返回期望的值。QUnit有不同种类的断言，具体请参阅`api.qunitjs.com/category/assert/`。
- en: In `ok()`, the first argument we pass to this function is an expression that
    evaluates to true or false. The second argument is the message you want to display
    when the assertion is executed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ok()`函数中，我们传递给这个函数的第一个参数是一个表达式，该表达式计算结果为真或假。第二个参数是在断言执行时你希望显示的信息。
- en: 'Now, let us test that the inactive navigation items do not contain the class
    name that makes a navigation item appear active, by using the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下代码段来测试非活动导航项是否不包含使导航项显示为活动的类名：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let us now execute these tests! Open the `tests.html` page in your browser.
    You should see something like the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行这些测试！在你的浏览器中打开`tests.html`页面。你应该会看到类似下面的截图：
- en: '![Creating a testing environment](img/8505_App_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建测试环境](img/8505_App_01.jpg)'
- en: You can execute more complicated tests too! Learn more about QUnit from their
    online cookbook at `qunitjs.com/cookbook/`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以执行更复杂的测试！详细了解QUnit请访问他们的在线食谱本`qunitjs.com/cookbook/`。
- en: Esoteric defaults you should know about
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该知道的神秘默认设置
- en: There is a lot of research that was done to arrive at the defaults that are
    part of HTML5 Boilerplate. It is really fun to understand how different browsers
    behave and what drove us to choose the defaults as they are.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得出HTML5 Boilerplate中的默认设置，进行了大量的研究。了解不同浏览器的行为以及我们为何选择这些默认设置是非常有趣的。
- en: Meta UTF-8
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元UTF-8
- en: The `meta` element represents any metadata information for the page. Setting
    `<meta charset="utf-8">` in the `<head>` element will ensure browsers parse the
    page with UTF-8 encoding in the absence of any other information about the encoding
    of the page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta`元素代表页面的任何元数据信息。在`<head>`元素中设置`<meta charset="utf-8">`将确保在没有关于页面编码的其他信息时，浏览器以UTF-8编码解析页面。'
- en: The interesting thing to note is that most browsers look for character encoding
    metadata only within the first 512 bytes of the page. Hence, you need to ensure
    that if you have a lot of data in your `<head>` element, this meta element occurs
    before everything else.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，大多数浏览器只在页面的前512字节内寻找字符编码元数据。因此，如果你在`<head>`元素中有大量的数据，你需要确保这个元元素出现在其他一切之前。
- en: 'In the absence of `charset` encoding information, browsers have to guess which
    `charset` encoding to apply. The HTML5 spec outlines the sniffing algorithm that
    all browsers must implement at [www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#encoding-sniffing-algorithm](http://www.whatwg.org/specs/web-apps/current-     work/multipage/parsing.html#encoding-sniffing-algorithm). Unfortunately, older
    browsers had their own mechanisms for guessing character encoding.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '在没有`charset`编码信息的情况下，浏览器必须猜测应应用哪种`charset`编码。HTML5规范概述了所有浏览器必须实现的嗅探算法，具体请参阅[www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#encoding-sniffing-algorithm](http://www.whatwg.org/specs/web-apps/current-     work/multipage/parsing.html#encoding-sniffing-algorithm)。不幸的是，旧版浏览器有自己猜测字符编码的机制。'
- en: In the case of Internet Explorer 7 and below, the default character encoding
    preference is typically set to `Auto Select`. This means the browser scans the
    content of the page to detect what character encoding would best apply. In case
    of Internet Explorer, if it finds a UTF-7 string within 4096 characters of the
    page, it would assume the page uses UTF-7 encoding and your page will become vulnerable
    to cross-site scripting attacks using UTF-7 encoding. Hence, the `meta` element
    declaration and right on top of the page in the `index.html` page.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Internet Explorer 7及以下版本的情况下，默认的字符编码偏好通常设置为`Auto Select`。这意味着浏览器扫描页面的内容以检测最适合的字符编码。在Internet
    Explorer中，如果在页面的前4096个字符内找到一个UTF-7字符串，它将假设页面使用UTF-7编码，你的页面将变得容易受到使用UTF-7编码的跨站脚本攻击。因此，在`index.html`页面顶部使用`meta`元素声明。
- en: Note that if your server sends an HTTP header that is of a different encoding,
    then that would take precedence. Make sure your server is set up to serve the
    right `charset` encoding as an HTTP header.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你的服务器发送了一个编码不同的HTTP头，那么这将优先考虑。确保你的服务器设置为在HTTP头中提供正确的`charset`编码。
- en: The HTML Doctype
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML Doctype
- en: Before the standardization of HTML and CSS, most markup and styles did not render
    consistently in any browser. But when we had standards about how markup should
    be written and more and more developers started adopting these standards, browsers
    then had to face the problem of detecting which of the pages on the Internet conformed
    to these standards and which weren't.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML和CSS标准化之前，大多数标记和样式在任何一个浏览器中都无法一致地渲染。但是当我们有了关于标记应该如何编写的标准，越来越多的开发者开始采用这些标准时，浏览器不得不面对的问题是在互联网上的哪些页面符合这些标准，哪些页面不符合。
- en: The Doctype was invented so that developers could inform the browser to render
    the page using the newer standards mode. Without a Doctype declaration, browsers
    would render the page in what is known as **Quirks Mode** (the way browsers used
    to render the pages before standards became an acceptable practice). In IE6, having
    a comment or an XML namespace declaration above the Doctype would render the page
    in Quirks Mode too. In the early 2000s when using the XHTML Doctype with an XML
    namespace declaration was recommended, this would be the cause of significant
    issues in Internet Explorer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文档类型（Doctype）的发明是为了让开发者能够通知浏览器使用较新的标准模式来渲染页面。没有Doctype声明，浏览器将使用所谓的**怪异模式**（浏览器以前在标准成为可接受做法之前渲染页面的方式）来渲染页面。在IE6中，在Doctype上方有一个注释或XML命名空间声明会导致页面也以怪异模式渲染。在2000年代初建议使用带有XML命名空间声明的XHTML
    Doctype时，这将在Internet Explorer中引起重大问题。
- en: Not all Doctype declarations render in standards mode. The easiest way to use
    standards mode is to use the smallest recommended Doctype, `<!doctype html>`.
    You can use any mix of upper or lowercases in the Doctype declaration (for example,
    `<!DoCtYpE hTmL>`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的Doctype声明都在标准模式下渲染。使用标准模式的最简单方法是使用最小的推荐Doctype，`<!doctype html>`。在Doctype声明中可以使用任何大写或小写的混合（例如，`<!DoCtYpE
    hTmL>`）。
- en: The details behind the clearfix solution
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除解决方案的详细信息
- en: The `clearfix` CSS class is used to make sure floated elements fit in their
    parent container. The very first exploration of this idea occurred in 2002, and
    is elaborated further in the article at [www.positioniseverything.net/easyclearing.html](http://www.positioniseverything.net/easyclearing.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearfix`CSS类用于确保浮动元素适合其父容器。这个想法的第一次探索发生在2002年，并在[www.positioniseverything.net/easyclearing.html](http://www.positioniseverything.net/easyclearing.html)的文章中进一步阐述。'
- en: 'The `clearfix` selector works in the following manner:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearfix`选择器按照以下方式工作：'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The biggest problem with this method is that margins do not collapse consistently
    across all browsers. Thierry Koblentz writes more about it at [www.tjkdesign.com/lab/clearfix/new-clearfix.html](http://www.tjkdesign.com/lab/clearfix/new-clearfix.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法最大的问题是，边距在所有浏览器上的一致性坍缩。Theirry Koblentz在[www.tjkdesign.com/lab/clearfix/new-clearfix.html](http://www.tjkdesign.com/lab/clearfix/new-clearfix.html)上写了更多关于它。
- en: 'Thierry Koblentz updated this method in 2010 introducing the use of both `:before`
    and `:after` pseudo-elements in the post at [www.yuiblog.com/blog/2010/09/27/clearfix-reloaded-overflowhidden-demystified/
    to be so](http://www.yuiblog.com/blog/2010/09/27/clearfix-reloaded-overflowhidden-demystified/
    to be so). Both the pseudo-elements are used in the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 蒂埃里·科布伦茨在2010年更新了这种方法，引入了`:before`和`:after`伪元素的使用，在[www.yuiblog.com/blog/2010/09/27/clearfix-reloaded-overflowhidden-demystified/](http://www.yuiblog.com/blog/2010/09/27/clearfix-reloaded-overflowhidden-demystified/)的一篇文章中进行了更新。这两个伪元素如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using both pseudo-elements prevents the problem of inconsistent margin collapsing
    while using the `clearfix` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个伪元素防止了在使用`clearfix`类时不一致的边距合并问题。
- en: 'Nicolas Gallagher, in 2011, found an alternative way that reduces the lines
    of code necessary for the `clearfix` class if our target browsers are IE6 and
    higher and other modern browsers, as he explains in his article at `nicolasgallagher.com/micro-clearfix-hack/`.
    Nicolas'' code is given in the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，尼古拉斯·加利亚尔发现了一种替代方法，如果我们的目标浏览器是IE6及以上版本和其他现代浏览器，将大大减少`clearfix`类的代码行数，他在`nicolasgallagher.com/micro-clearfix-hack/`的文章中解释了这一点。尼古拉斯的代码如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this method, using `display: table` would create an anonymous table cell
    (more information on what this means is available in the specification at [www.w3.org/TR/CSS2/tables.html#anonymous-boxes](http://www.w3.org/TR/CSS2/tables.html#anonymous-boxes))
    within the pseudo-element, which prevents the collapsing of top margins. The `content`
    property does not require any content within to work, but this method uses a space
    character to overcome an Opera bug when used on elements that are editable.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种方法中，使用`display: table`会在伪元素内创建一个匿名表格单元（有关这意味着什么的更多信息可以在规范[www.w3.org/TR/CSS2/tables.html#anonymous-boxes](http://www.w3.org/TR/CSS2/tables.html#anonymous-boxes)中找到），这防止了顶端边距的合并。`content`属性不需要任何内容在其中工作，但这种方法使用一个空格字符来克服当在可编辑元素上使用时的Opera错误。'
- en: This is how the `clearfix` class evolved! As you can see, a great deal of research
    and development went into crafting the best `clearfix` class possible that would
    work across dominant browser platforms.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`clearfix`类的发展过程！正如你所看到的，为了制作可能跨越主要浏览器平台的最佳`clearfix`类，进行了大量的研究和开发。
- en: What do the print styles do?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印样式做什么？
- en: The HTML5 Boilerplate stylesheet comes with a set of styles that are useful
    defaults when a user prints your page. Styling how a page would appear in print
    is something that most of us do not consider while designing a web page, and HTML5
    Boilerplate gives you a set of good defaults, so you do not have to consider it
    most of the time (however, it would be good practice to do so).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 Boilerplate样式表带有一组在用户打印您的页面时非常有用的默认样式。设计一个页面在打印时的外观是我们在设计网页时大多数不会考虑的事情，而HTML5
    Boilerplate为您提供了一组良好的默认值，因此您大多数时候不需要考虑（然而，这样做是一个好的实践）。
- en: Print media query
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印媒体查询
- en: 'We have inlined all our print styles within a CSS media query called "print".
    This media query is matched whenever a user selects a page for printing, and these
    style rules will be applied in that case. We declare all of our rules within the
    `@media print` query as shown in the following code snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有的打印样式内嵌在一个名为“print”的CSS媒体查询中。当用户选择打印页面时，这个媒体查询会被匹配，在这种情况下应用这些样式规则。我们在下面的代码片段中展示了所有的规则都声明在`@media
    print`查询内：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Optimizing colors and backgrounds
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化颜色和背景
- en: We then make sure we optimize the page to appear most readable when printed
    and also ensure we are not wasting too much printing ink printing superfluous
    images, colors, and text. This means we make sure we remove all background images
    or images, which are just of a slightly different shade of white or transparent
    for all elements. We also make sure all of the colors are black as it means the
    printer does not have to mix any ink and hence can print faster. We also remove
    shadows, as that would make the text less readable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们确保优化页面，使其在打印时最易读，并确保我们不会浪费太多的打印墨水打印不必要的图片、颜色和文字。这意味着我们确保移除所有背景图片或图片，这些图片对于所有元素来说只是稍微不同的白色或透明色。我们还确保所有的颜色都是黑色，因为这意味着打印机不需要混合任何墨水，因此可以更快地打印。我们还移除了阴影，因为这会使文字更难读。
- en: 'The final rule we have for these updates is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们针对这些更新的最后一条规则如下：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Better links
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的链接
- en: 'Not many designers now use `text-decoration: underline` to style links on pages.
    Typically, people use colors to indicate something is a link. However, underlines
    are easier to discern in case of print, especially when you have no control over
    the printer and colors used to render them. Hence, we have all links (active or
    visited) to be styled with a line below the text by using the following code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '现在很少有设计师使用 `text-decoration: underline` 来为页面上的链接设置样式。通常，人们使用颜色来指示某物是链接。然而，在打印时，下划线更容易辨认，尤其是当你无法控制打印机和渲染它们的颜色时。因此，我们让所有链接（活动或已访问）通过以下代码片段使用下划线样式：'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It would also be helpful to have a reference to the actual link in print as
    there is no way for the user to navigate to that link if they are reading from
    a printed page and would like to visit the link. We do this by using the `attr()`
    function in CSS. `attr()` returns the value of an attribute of the element that
    the current rule will be applied to. In this case, as we are applying it on links,
    we can use `attr()` to obtain the value of the `href` attribute of links and print
    them. A space character is used to concatenate strings together when they are
    used as a value in the `content` property. We also want to make sure that if a
    link has a title, we print that too as a title is only visible on hovering on
    a link. All of this expressed in CSS looks like the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印时提供实际链接的参考也会很有帮助，因为用户如果从打印的页面阅读并希望访问链接，没有办法导航到该链接。我们通过在 CSS 中使用 `attr()`
    函数来实现。`attr()` 返回当前规则将应用于的元素的属性的值。在这种情况下，由于我们将其应用于链接，我们可以使用 `attr()` 来获取链接的 `href`
    属性的值并打印它们。当它们作为 `content` 属性的值使用时，使用空格字符将字符串连接在一起。我们还希望确保如果链接有标题，我们也打印出来，因为标题只有在悬停在链接上时才可见。所有这些在
    CSS 中表达出来就像以下的代码片段：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But, this means even links that are just linking to another location in the
    same page or are used for JavaScript actions (with the `javascript:` prefix) would
    render the same way! So, we would need to make sure we do not do this for these
    links.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这意味着即使是链接到同一页面其他位置的链接或用于 JavaScript 操作（带有 `javascript:` 前缀）的链接也会以同样的方式呈现！所以，我们需要确保我们不对这些链接这样做。
- en: For this, we use the attribute selector that allows us to select elements that
    have properties that begin, end, or contain certain values. By using the selector
    `a[href^="javascript:"]:after`, we ensure we are only selecting the `:after` pseudo-elements
    of links that have the attribute `href`, whose value starts with the string `javascript:`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用属性选择器，它允许我们选择具有以特定值开始、结束或包含的属性的元素。通过使用选择器 `a[href^="javascript:"]:after`，我们确保我们只选择具有
    `href` 属性的链接的 `:after` 伪元素，该属性的值以 `javascript:` 字符串开头。
- en: Similarly, we also select all links which have the `href` attribute that begin
    with the `#` character, as that means such links are inline links linking to another
    location within the same page.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也选择所有 `href` 属性以 `#` 字符开头的链接，因为这意味着这样的链接是内联链接，链接到同一页面内的另一个位置。
- en: 'We then make sure we render no content for pseudo-elements within these links.
    The rule then looks like the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们确保对 these links 中的 pseudo-elements 不渲染任何内容。规则看起来像以下的代码片段：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Do note that these rules are not available for IE6 and if it is highly necessary
    to offer this functionality in IE6, you would like to use JavaScript that provides
    this.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些规则不适用于 IE6，如果必须在 IE6 中提供此功能，您可能需要使用提供此功能的 JavaScript。
- en: Rendering all code and quotes within one page
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在同一页面内渲染所有代码和引用
- en: 'It sometimes happens that your printed page would contain quotes or code, and
    as a reader, it is annoying to keep referring back to a previous page when the
    code (or the quote) could all have been within one page without any break. For
    this, we can use the CSS `page-break-inside` property that allows you to tell
    the browser if you prefer these elements to break over two pages or stay within
    the same page. The code for this is shown in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您的打印页面可能包含引用或代码，作为读者，当代码（或引用）本可以在一个页面内无任何中断地包含时，需要不断参考之前的页面是很烦人的。为此，我们可以使用
    CSS `page-break-inside` 属性，它允许您告诉浏览器您更愿意让这些元素在两页之间断开还是保持在同一页面上。下面的代码片段显示了此代码：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Do note that `page-break-inside` is not supported in Firefox, but is available
    in all other browsers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Firefox 不支持 `page-break-inside`，但在所有其他浏览器中都可以使用。
- en: Rendering tables better
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好地渲染表格
- en: 'By default, putting headings within the `thead` tag would ensure that the headings
    get repeated every time a table breaks across two pages. However, only Firefox
    and Opera have support for this at the moment. In IE, you can do this but you
    would have to explicitly state it, as stated in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，将标题放在`thead`标签内将确保当表格跨两页时，标题会重复。然而，目前只有Firefox和Opera支持这一点。在IE中，你可以这样做，但你必须明确指出，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rendering images better
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好地渲染图像
- en: 'Ideally, we want to prevent table rows and images from breaking across pages,
    so we use the now familiar `page-break-inside` property to tell the browser of
    our preference, as shown in the following code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们想要防止表格行和图像跨页断裂，因此我们使用现在熟悉的`page-break-inside`属性来告诉浏览器我们的偏好，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It also does not appear too well, when images run off beyond the page or print
    cropped while appearing in full on the website. Hence, we restrict the maximum
    width to be as wide as the page itself and no more, as shown in the following
    code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像超出页面或打印时被裁剪而在网站上以完整形式显示时，它也不太好看。因此，我们将最大宽度限制为与页面本身一样宽，不超过此宽度，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Margins on pages
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面边距
- en: 'The `@page` rule allows you to modify the properties of a page when printing.
    All browsers except Firefox support this rule. This rule sets the margins to be
    `0.5 cm` per page, as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`@page`规则允许你在打印时修改页面的属性。除了Firefox之外，所有浏览器都支持这个规则。这个规则将页边距设置为每页`0.5 cm`，如下面的代码片段所示：'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Optimal settings for orphans and widows
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 孤儿和寡妇的最优设置
- en: '**Orphans** are the lines of text that appear at the bottom of the page. **Widows**
    are those that appear at the top of the page. We make sure that lines do not break
    in a manner that leaves fewer lines at the bottom or top than desired. This will
    create a more readable experience. The following code snippet is used for that
    purpose:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**孤儿**是指出现在页面底部的文本行。**寡妇**是指出现在页面顶部的那些。我们确保文本行不要以留下比所需更少的行在底部或顶部的方式断裂。这将创造一个更易读的体验。以下代码片段用于此目的：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keeping headings with content
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持标题与内容在一起
- en: 'It is not readable to have the headings appear at the bottom of one page and
    the content that the heading is for, appearing on the next. To tell the browsers
    to avoid doing this, we can use the `page-break-after` setting, as shown in the
    following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标题出现在一页的底部，而其对应的内容却出现在下一页，这将使得内容难以阅读。为了告诉浏览器避免这样做，我们可以使用`page-break-after`设置，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What are protocol-relative URLs?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议相关URL是什么？
- en: 'In HTML5 Boilerplate, when we refer to jQuery, we refer to it as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5 Boilerplate中，当我们提到jQuery时，我们是这样提到的：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that we do not have either `http` or `https` in front of the URL; instead,
    it starts with `//`. These are called protocol-relative URLs and are useful when
    you want to use a protocol-agnostic resource in a HTTP or HTTPS environment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有在URL前面加上`http`或`https`；相反，它以`//`开头。这些被称为协议相关URL，当你想在HTTP或HTTPS环境中使用一个协议无关的资源时，它们很有用。
- en: When you serve pages using HTTPS, browsers will throw warnings and errors when
    the page loads assets and resources that use HTTP protocol. To prevent this, you
    need to ensure you use the HTTPS protocol for all the assets you are requesting.
    This is typically not a problem if you are using relative URLs to refer to assets
    within the parent folder of your page. However, if you are referring to external
    URLs like the CDN URL for jQuery (shown previously), then you need to ensure you
    use `https` when the page is being served with the HTTPS protocol and the `http`
    prefix when the page is being served with HTTP protocol.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用HTTPS提供页面时，浏览器在页面加载使用HTTP协议的资产和资源时会抛出警告和错误。为了防止这种情况，你需要确保你使用HTTPS协议来请求所有资产。如果你使用相对URL来引用页面所在的父文件夹中的资产，这通常不是问题。然而，如果你在引用像jQuery的CDN
    URL（前面提到）这样的外部URL，那么你需要确保在页面使用HTTPS协议时使用`https`，而在页面使用HTTP协议时使用`http`前缀。
- en: Instead of using JavaScript to do that determination, simply omitting the protocol
    ensures browsers use the currently used protocol when requesting that external
    URL. In this case, if this page gets served on HTTPS as `https://example.com`,
    then the URL requested will be [https://ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js](https://ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是用JavaScript来做这个决定，简单地省略协议可以确保浏览器在请求那个外部URL时使用当前的协议。在这种情况下，如果这个页面以HTTPS的形式提供，即`https://example.com`，那么请求的URL将是[https://ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js](https://ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js)。
- en: You can learn more about this at `paulirish.com/2010/the-protocol-relative-url/`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`paulirish.com/2010/the-protocol-relative-url/`了解更多关于这个内容。
- en: Using conditional comments
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用条件注释
- en: Historically, IE6, IE7, and IE8 have been browsers with the most bugs and inconsistent
    rendering of styles. There are many ways to serve styles to IE versions 8 and
    below, here are a few.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，IE6、IE7和IE8是拥有最多bug和样式渲染不一致的浏览器。有多种方法可以向IE8及以下版本提供样式，以下是其中几种。
- en: Browser style hacks
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器样式hack
- en: The most prevalent technique is to use hacks in CSS style rules that target
    only one browser.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的技术是在CSS样式规则中使用hack，这些规则只针对一个浏览器。
- en: 'For IE6 and below, use the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IE6及以下版本，使用以下代码片段：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For IE7, use the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IE7，使用以下代码片段：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For IE8, use the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IE8，使用以下代码片段：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are more hacks that target two or more browsers (or exclude two or more
    browsers) all listed in the post at `paulirish.com/2009/browser-specific-css-hacks/`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多针对两个或更多浏览器（或排除两个或更多浏览器）的hack，全部列在`paulirish.com/2009/browser-specific-css-hacks/`这篇文章中。
- en: The problem with these hacks is that first they exploit holes in the browser's
    parsing technology. If browsers fix these parsing errors then they may not work.
    Luckily, we do not have to fear about this for older browsers such as IE6 and
    IE7.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些hack的问题在于，首先它们利用浏览器解析技术的漏洞。如果浏览器修复了这些解析错误，它们可能就无法工作。幸运的是，我们不必担心IE6和IE7等旧浏览器。
- en: These hacks are also not readable and without comments it is impossible to understand
    which browsers they target.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些hack也不易读，如果没有注释，就无法理解它们针对哪些浏览器。
- en: The advantage of these methods is that you can keep your style rules together,
    and you do not have to serve a separate stylesheet for the browsers requiring
    hacks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的优势在于你可以保持你的样式规则在一起，而且你不需要为需要hack的浏览器提供单独的样式表。
- en: Server-side browser detection
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端浏览器检测
- en: 'When they make a request to a web server, browsers send a User Agent String
    along with the request. Servers can serve different resources based on their interpretation
    of the User Agent String. For example, if a browser identifies itself as IE6 with
    the following User Agent String:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们向服务器发起请求时，浏览器会随请求发送一个User Agent字符串。服务器可以根据它们对User Agent字符串的解释提供不同的资源。例如，如果一个浏览器用以下的User
    Agent字符串将自己标识为IE6：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, the server can send back a different stylesheet to IE6\. While this may
    seem like a simple, easy solution, the problem occurs when browsers lie. Historically,
    browsers have never exactly claimed to be which browser they are, and hence, it
    is likely that you may send the wrong stylesheet to a browser.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器可以回传一个不同的样式表给IE6。虽然这看起来是一个简单、容易的解决方案，但问题出现在浏览器撒谎的时候。历史上，浏览器从未准确声称自己是哪个浏览器，因此，很可能会向一个浏览器发送错误的样式表。
- en: It also involves a little overhead server-side to process the request according
    to the browser's User Agent setting, and hence is not an ideal way to serve different
    stylesheets to IE8 and below.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这也涉及到一点服务器端的处理开销，以根据浏览器的User Agent设置处理请求，因此这不是向IE8及以下版本提供不同样式表的理想方式。
- en: Stylesheets based on conditional comments
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于条件注释的样式表
- en: 'Conditional comments are HTML comments with special syntax that are understood
    by IE9 and below. The following is a sample conditional comment:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 条件注释是IE9及以下版本能理解的具有特殊语法的HTML注释。以下是一个条件注释的示例：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All browsers except Internet Explorer 9 and below ignore content within these
    conditional comments. IE9 and below try to interpret the `if` condition within
    these comments and selectively render the content if the version number of the
    IE browser matches the one within the `if` condition.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有浏览器（除了IE9及以下版本）都会忽略这些条件注释内的内容。IE9及以下版本会尝试解释这些注释内的`if`条件，并根据IE浏览器的版本号是否与`if`条件中的版本号匹配来选择性地渲染内容。
- en: The previous example will render the `p` tag on all 8, 7, 6, and below versions
    of IE.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例将在所有8、7、6及以下版本的IE上渲染`p`标签。
- en: 'Conditional comments are perfect to target older versions of IE and this is
    what HTML5 Boilerplate uses. There are two ways of using them. The first is to
    output a separate stylesheet based on matching a conditional comment, as shown
    in the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 条件注释完美地针对老版本的IE，HTML5 Boilerplate就是这么做的。使用它们有两种方法。第一种是基于匹配条件注释输出一个单独的样式表，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will make IE8 and below use `legacy.css` and other browsers will ignore
    this snippet of code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使IE8及以下使用`legacy.css`，其他浏览器将忽略这段代码。
- en: The problem with a standalone stylesheet is that while you develop your styles
    you have two different stylesheets to target, and occasionally IE-specific stylesheets
    could be forgotten.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 独立样式表的问题在于，在开发样式时，您需要针对两个不同的样式表，偶尔IE特定的样式表可能会被遗忘。
- en: 'Some people provide only a very basic experience for IE8 and below, as shown
    in the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人只为IE8及以下提供一个非常基础的体验，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But HTML5 Boilerplate prefers a more readable and targeted approach that provides
    the best possible styles to all browsers using class names, which we will look
    at next.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但HTML5 Boilerplate更喜欢一个更可读且针对性的方法，使用类名向所有浏览器提供最佳可能的样式，我们接下来会看到。
- en: Class names based on conditional comments
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于条件注释的类名
- en: 'An iteration of the previous conditional comments method would be to append
    class names on the root element based on conditional comments, as shown in the
    following code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个条件注释方法的迭代将是基于条件注释在根元素上附加类名，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then in your stylesheet, you can use it to set styles in IE8 and below as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的样式表中，您可以使用它在IE8及以下设置样式，如下所示：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can read more about this solution at `paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/`上阅读更多关于这个解决方案的信息。
- en: This solution does not require separate stylesheets, but allows you to write
    readable class names that indicate why that style rule exists in the stylesheet.
    This is the solution we have adopted in HTML5 Boilerplate, and recommend.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案不需要单独的样式表，但允许你编写可读的类名，表明样式表中为何存在该样式规则。这是我们在HTML5 Boilerplate中采用的解决方案，并推荐使用。
- en: What is meta x-ua-compatible?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是元标签x-ua-compatible？
- en: '`x-ua-compatible` is a header that defines how Internet Explorer renders your
    pages. It declares which mode Internet Explorer should use to render your page.
    This is primarily targeted towards older websites that break in Internet Explorer
    9 onwards because of better support for standards. It can be set in two ways.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`x-ua-compatible`是一个头部标签，用于定义Internet Explorer如何渲染您的页面。它声明了Internet Explorer应使用哪种模式来渲染您的页面。这主要针对那些在Internet
    Explorer 9及以后版本中因对标准支持更好而断裂的老网站。它可以以两种方式设置。'
- en: Meta tag in your HTML page
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML页面中的元标签
- en: 'In this case, we merely add a `meta` tag between the `<head></head>` tag in
    your HTML pages as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需在HTML页面的`<head></head>`标签之间添加一个`meta`标签，如下所示：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: HTTP header response from the server
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP头响应自服务器
- en: 'In Apache, in the `.htaccess` file, writing the following would make the server
    send the `X-UA-Compatible` HTTP header as a response to any request on that parent
    folder:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apache中，在`.htaccess`文件中编写以下内容，会使服务器对那个父文件夹的任何请求发送`X-UA-Compatible` HTTP头作为响应：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We recommend this method of setting its value because HTTP header values override
    any value set via the `meta` tag. Moreover, using the `meta` tag with IE conditional
    comments on the `html` element causes this `meta` tag to be ignored. The `X-UA-Compatible`
    header can have the following values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐这种设置其值的方法，因为HTTP头值会覆盖通过`meta`标签设置的任何值。此外，在`html`元素上使用IE条件注释的`meta`标签会导致忽略这个`meta`标签。`X-UA-Compatible`头可以有以下值。
- en: Edge
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Edge
- en: This would use the latest mode of rendering available. For example, within Internet
    Explorer 10, it would be IE10\. We would want to always use the latest rendering
    mode available, as this means we have access to the latest and most standards-compliant
    version of the browser. This is why it is our default option in HTML5 Boilerplate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用可用的最新渲染模式。例如，在Internet Explorer 10中，它将是IE10。我们总是希望使用最新的渲染模式，因为这意味着我们能够访问最新的、最符合标准的浏览器版本。这就是为什么它是HTML5
    Boilerplate中的默认选项。
- en: IE9
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IE9
- en: This would use only IE9 mode to render the page. For example, when you use this
    mode and this page is viewed in Internet Explorer 10, it would use the IE9 mode
    to render the page.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只使用IE9模式来渲染页面。例如，当您使用这种模式时，如果这个页面在Internet Explorer 10中被查看，它将使用IE9模式来渲染页面。
- en: IE8
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IE8
- en: This would render the page as though it is being viewed on Internet Explorer
    8.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染页面，好像它是在Internet Explorer 8上查看的一样。
- en: IE7
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IE7
- en: This mode renders content, as it would display if Internet Explorer 7 rendered
    it in standards mode.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式会以Internet Explorer 7以标准模式渲染内容的方式渲染页面。
- en: Emulate IE9
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟IE9
- en: This mode tells Internet Explorer to use the `<!DOCTYPE>` directive to determine
    how to render content. Standards mode directives are displayed in IE9 mode and
    quirks mode directives are displayed in IE5 mode. All Emulate modes, unlike the
    previous modes, respect the `<!DOCTYPE>` directive.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式告诉Internet Explorer使用`<!DOCTYPE>`指令来确定如何渲染内容。标准模式下的指令在IE9模式下显示，怪异模式下的指令在IE5模式下显示。所有模拟模式与之前的模式不同，都尊重`<!DOCTYPE>`指令。
- en: Emulate IE8
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟IE8
- en: This mode tells Internet Explorer to use the `<!DOCTYPE>` directive to determine
    how to render content. Standards mode directives are displayed in IE8 mode and
    quirks mode directives are displayed in IE5 mode. Unlike IE8 mode, Emulate IE8
    mode respects the `<!DOCTYPE>` directive.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式告诉Internet Explorer使用`<!DOCTYPE>`指令来确定如何渲染内容。标准模式下的指令在IE8模式下显示，怪异模式下的指令在IE5模式下显示。与IE8模式不同，模拟IE8模式尊重`<!DOCTYPE>`指令。
- en: Emulate IE7
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟IE7
- en: This mode tells Internet Explorer to use the `<!DOCTYPE>` directive to determine
    how to render content. Standards mode directives are displayed in Internet Explorer
    7 standards mode and quirks mode directives are displayed in IE5 mode. Unlike
    IE7 mode, Emulate IE7 mode respects the `<!DOCTYPE>` directive. For many websites,
    this is the preferred compatibility mode.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式告诉Internet Explorer使用`<!DOCTYPE>`指令来确定如何渲染内容。标准模式下的指令在Internet Explorer
    7的标准模式下显示，而在IE5模式下显示怪异模式下的指令。与IE7模式不同，模拟IE7模式尊重`<!DOCTYPE>`指令。对于许多网站来说，这是首选的兼容性模式。
- en: IE5
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IE5
- en: This mode renders content as if Internet Explorer 7 displayed it in quirks mode.
    You can learn more about these modes on MSDN documentation at `msdn.microsoft.com/en-us/library/cc288325(v=VS.85).aspx`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式会以Internet Explorer 7在怪异模式下显示内容的方式渲染内容。您可以在MSDN文档`msdn.microsoft.com/en-us/library/cc288325(v=VS.85).aspx`上了解这些模式。
- en: Contribute
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贡献
- en: 'If you like what you have seen so far of the project, you might want to contribute!
    Contributing to HTML5 Boilerplate is rewarding in all the learning and understanding
    that you get out of making even the smallest of changes. There are two ways to
    contribute; these are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这个项目到目前为止所看到的内容，你可能想要贡献！为HTML5 Boilerplate做出贡献在你的学习和理解中即使做出最小的更改也是有益的。贡献有两种方式，如下所述：
- en: Reporting issues
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告问题
- en: Submitting pull requests
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交拉取请求
- en: Reporting issues
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告问题
- en: If you find something that is a mistake or is incorrect in one of the files
    in HTML5 Boilerplate, then you can file an issue so any of the contributors can
    take a look at it and see if it can be resolved.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在HTML5 Boilerplate的文件中发现了一个错误或者是不正确的内容，那么您可以提交一个问题，任何贡献者都可以查看并看看是否可以解决。
- en: The trick is to find out if something is an issue on HTML5 Boilerplate or something
    is caused by the code your project uses. You can verify if this is a problem with
    HTML5 Boilerplate by starting a clean install of HTML5 Boilerplate and verifying
    if the error still occurs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是找出是否是HTML5 Boilerplate的问题，或者是项目代码引起的。您可以通过开始安装HTML5 Boilerplate的干净版本并验证错误是否仍然发生来验证这是否是HTML5
    Boilerplate的问题。
- en: If it is an issue with HTML5 Boilerplate, before you file an issue, make sure
    it has not been already reported. The GitHub Issues page at `github.com/h5bp/html5-boilerplate/issues`
    lists all open issues. Use the **Search** bar on top to search for the issue you
    are facing. It is likely that it may have been fixed, but the fix has not yet
    been pushed to stable branch.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到HTML5 Boilerplate的问题，在提交问题时，请确保它没有被报告过。GitHub问题页面`github.com/h5bp/html5-boilerplate/issues`列出了所有开放的问题。在顶部的**搜索**栏中搜索您遇到的问题。很可能它已经被修复，但修复还没有推送到稳定分支。
- en: 'If the issue is brand new, then make sure you isolate the problem in a way
    that is obvious through a reduced test case (Chris Coyier writes about what a
    reduced test case is in `css-tricks.com/reduced-test-cases/`). When you file a
    bug report, make sure it is easy to understand, so we can find a speedy solution.
    Ideally your bug report should contain the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题全新的，那么确保你通过一个减少的测试用例以一种明显的方式隔离问题（Chris Coyier在`css-tricks.com/reduced-test-cases/`中撰写了关于减少测试用例的内容）。当你提交一个bug报告时，确保它易于理解，这样我们才能找到一个快速的解决方案。理想情况下，你的bug报告应该包含以下内容：
- en: A short and descriptive title
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简短且描述性的标题
- en: A summary of the issue and the browser/Operating Systems where this bug occurs
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题的概述以及此bug发生的浏览器/操作系统
- en: If it is possible, steps to reproduce the bug
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，重现bug的步骤
- en: A URL to the reduced test case (you can host one on `jsfiddle.net` or `codepen.io`)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个减少的测试用例的URL（你可以在`jsfiddle.net`或`codepen.io`上托管一个）
- en: Any other information that would be relevant to the bug, including lines of
    code that might be the cause of the bug, and potential solutions
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能引起bug的代码行以及其他与bug相关的信息
- en: Ideally, a bug report should be self-contained, so contributors do not have
    to follow up with you again to find out more about the bug and can instead focus
    on resolving it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，一个bug报告应该是自包含的，这样贡献者不需要再次与你联系以了解关于bug的更多信息，而可以专注于解决它。
- en: Following this process to file a bug report is a learning experience in itself
    in how to find out what is wrong with the markup, style, or script that you wrote.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个流程提交一个bug报告本身就是了解如何找出你编写的标记、样式或脚本中错误的的学习过程。
- en: Pull requests
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取请求
- en: If you have ideas on how to improve HTML5 Boilerplate, patches to fix some existing
    issues, improvements or new features, you would submit what is known as a **pull
    request**. A pull request is a set of changes you can submit for review to the
    HTML5 Boilerplate GitHub repository, so it can be reviewed by the core contributors
    and merged into HTML5 Boilerplate if found to be useful.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有关于如何改进HTML5 Boilerplate的想法，或者有修补现有问题的补丁，改进或新功能，你可以提交所谓的**pull请求**。Pull请求是一组你可以提交给HTML5
    Boilerplate GitHub存储库进行审查的更改，以便可以让核心贡献者审查并如果认为有用的话将其合并到HTML5 Boilerplate中。
- en: A good way to start contributing would be to find a small issue that you think
    you can fix, fork the GitHub project (learn more on what this means at `help.github.com/articles/fork-a-repo`),
    work on your changes and submit a pull request.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 开始贡献的一个好方法是找到一个你认为可以解决的小问题，分叉GitHub项目（在`help.github.com/articles/fork-a-repo`上了解这意味着什么），在你的更改上工作并提交一个pull请求。
- en: If your contribution changes a lot of lines of code and alters the nature of
    the project drastically, consider opening an issue on the GitHub project first.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的贡献改变了大量代码并极大地改变了项目的性质，首先考虑在GitHub项目上打开一个 issues。
- en: 'The following are the steps to get started with creating a pull request:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要开始创建拉取请求的步骤：
- en: Fork the project.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分叉项目。
- en: Clone your fork (in your terminal, enter `git clone https://github.com/<your-username>/html5-boilerplate.git`
    and press *Enter*).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆你的分叉（在终端中，输入`git clone https://github.com/<your-username>/html5-boilerplate.git`并按*Enter*）。
- en: Add an upstream remote (in your terminal enter `git remote add upstream https://github.com/h5bp/html5-boilerplate.git`
    and press *Enter*).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中添加一个上游远程（输入`git remote add upstream https://github.com/h5bp/html5-boilerplate.git`并按*Enter*）。
- en: Get the latest changes from upstream (for example, by entering `git pull upstream
    master` and pressing *Enter* in your terminal).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上游获取最新更改（例如，通过在终端中输入`git pull upstream master`并按*Enter*）。
- en: Create a new topic branch to contain your feature, change, or fix (`git checkout
    -b <topic-branch-name>`).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的主题分支来包含你的功能、更改或修复（`git checkout -b <topic-branch-name>`）。
- en: Make sure that your changes adhere to the current coding conventions used throughout
    the project; that is, indentation, accurate comments, and so on.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的更改遵守项目整个中使用的当前编码约定；也就是说，缩进、准确的注释等。
- en: Commit your changes in logical chunks; use Git's interactive rebase feature
    (more about this feature at `help.github.com/articles/interactive-rebase`) to
    tidy up your commits before making them public. Please adhere to these Git commit
    message guidelines at `tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html`
    or your pull request is unlikely be merged into the main project.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的更改逻辑上分组提交；使用 Git 的交互式重置功能（关于此功能的更多信息请访问 `help.github.com/articles/interactive-rebase`）来在公开之前整理你的提交。请遵守这些
    Git 提交信息指南（访问 `tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html`），否则你的拉取请求很可能不会被合并到主项目。
- en: Locally merge (or rebase) the upstream branch into your topic branch.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将上游分支合并（或重置）到你的主题分支。
- en: Push your topic branch up to your fork (`git push origin <topic-branch-name>`).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的主题分支推送到你的分叉（`git push origin <topic-branch-name>`）。
- en: Open a pull request with a clear title and description. Please mention which
    browsers you tested in.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用清晰的标题和描述打开一个拉取请求。请提到你测试了哪些浏览器。
- en: This may seem like a lot of work, but it makes your pull requests significantly
    easier to understand and faster to merge. Moreover, your code becomes the documentation
    of the work you have done and anyone who wants to know why that section looks
    the way it does can go back to your commits and understand exactly why it is the
    case.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是很多工作，但它使你的拉取请求显著更容易理解且更快合并。此外，你的代码成为了你所做工作的文档，任何想要知道为什么某个部分是这样的都可以回溯到你的提交并确切了解原因。
- en: Working on HTML5 Boilerplate would get you started with best practices of collaborative
    development that you can take back to your workplace or any other collaborative
    work you do.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML5 样板代码上工作将帮助你开始采用协作开发的最佳实践，你可以将这些实践带回你的工作场所或任何其他协作工作中。
