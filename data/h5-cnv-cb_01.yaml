- en: Chapter 1. Getting Started withPaths and Text
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。开始使用路径和文本
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖：
- en: Drawing a line
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一条线
- en: Drawing an arc
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一条弧线
- en: Drawing a Quadratic curve
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制二次曲线
- en: Drawing a Bezier curve
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制贝塞尔曲线
- en: Drawing a zigzag
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制锯齿
- en: Drawing a spiral
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制螺旋
- en: Working with text
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本
- en: Drawing 3D text with shadows
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阴影绘制3D文本
- en: 'Unlocking the power of fractals: Drawing a haunted tree'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放分形的力量：绘制一棵幽灵树
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter is designed to demonstrate the fundamental capabilities of the
    HTML5 canvas by providing a series of progressively complex tasks. The HTML5 canvas
    API provides the basic tools necessary to draw and style different types of sub
    paths including lines, arcs, Quadratic curves, and Bezier curves, as well as a
    means for creating paths by connecting sub paths. The API also provides great
    support for text drawing with several styling properties. Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在通过一系列逐渐复杂的任务来演示HTML5画布的基本功能。HTML5画布API提供了绘制和样式化不同类型子路径的基本工具，包括线条、弧线、二次曲线和贝塞尔曲线，以及通过连接子路径创建路径的方法。该API还提供了对文本绘制的良好支持，具有几种样式属性。让我们开始吧！
- en: Drawing a line
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一条线
- en: When learning how to draw with the HTML5 canvas for the first time, most people
    are interested in drawing the most basic and rudimentary element of the canvas.
    This recipe will show you how to do just that by drawing a simple straight line.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次学习如何使用HTML5画布绘制时，大多数人都对绘制最基本和最原始的画布元素感兴趣。这个配方将向您展示如何通过绘制简单的直线来做到这一点。
- en: '![Drawing a line](img/1369_01_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![绘制一条线](img/1369_01_01.jpg)'
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a diagonal line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一条对角线：
- en: 'Define a 2D canvas context and set the line style:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文并设置线条样式：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Position the canvas context and draw the line:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位画布上下文并绘制线条：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入到HTML文档的主体中：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Downloading the example code**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码** '
- en: You can run the demos and download the resources for this book from [www.html5canvastutorials.com/cookbook](http://www.html5canvastutorials.com/cookbook)
    or you can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[www.html5canvastutorials.com/cookbook](http://www.html5canvastutorials.com/cookbook)运行演示并下载本书的资源，或者您可以从您在[http://www.PacktPub.com](http://www.PacktPub.com)购买的所有Packt图书的帐户中下载示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see from the preceding code, we need to wait for the page to load
    before trying to access the canvas tag by its ID. We can accomplish this with
    the `window.onload` initializer. Once the page loads, we can access the canvas
    DOM element with `document.getElementById()` and we can define a 2D `canvas` context
    by passing `2d` into the `getContext()` method of the canvas object. As we will
    see in the last two chapters, we can also define 3D contexts by passing in other
    contexts such as `webgl`, `experimental-webgl`, and others.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，我们需要等待页面加载完成，然后再尝试通过其ID访问画布标签。我们可以通过`window.onload`初始化器来实现这一点。页面加载完成后，我们可以使用`document.getElementById()`访问画布DOM元素，并通过将`2d`传递给画布对象的`getContext()`方法来定义一个2D画布上下文。正如我们将在最后两章中看到的，我们还可以通过传递其他上下文（如`webgl`、`experimental-webgl`等）来定义3D上下文。
- en: When drawing a particular element, such as a path, sub path, or shape, it's
    important to understand that styles can be set at any time, either before or after
    the element is drawn, but that the style must be applied immediately after the
    element is drawn for it to take effect, We can set the width of our line with
    the `lineWidth` property, and we can set the line color with the `strokeStyle`
    property. Think of this behavior like the steps that we would take if we were
    to draw something onto a piece of paper. Before we started to draw, we would choose
    a colored marker (`strokeStyle`) with a certain tip thickness (`lineWidth`).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制特定元素（如路径、子路径或形状）时，重要的是要理解样式可以在任何时候设置，无论是在元素绘制之前还是之后，但是样式必须在元素绘制后立即应用才能生效，我们可以使用`lineWidth`属性设置线条的宽度，使用`strokeStyle`属性设置线条颜色。想象一下，这个行为就像我们在纸上画东西时会采取的步骤。在我们开始画之前，我们会选择一个带有特定尖端厚度的彩色标记（`strokeStyle`）。
- en: 'Now that we have our marker in hand, so to speak, we can position it onto the
    canvas using the `moveTo()` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们手里有了标记，可以使用`moveTo()`方法将其定位到画布上：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Think of the canvas context as a drawing cursor. The `moveTo()` method creates
    a new sub path for the given point. The coordinates in the top-left corner of
    the canvas are (0,0), and the coordinates in the bottom-right corner are (canvas
    width, canvas height).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将画布上下文视为绘图光标。`moveTo()`方法为给定点创建一个新的子路径。画布左上角的坐标为（0,0），右下角的坐标为（画布宽度，画布高度）。
- en: 'Once we have positioned our drawing cursor, we can draw the line using the
    `lineTo()` method by defining the coordinates of the line''s end point:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定位了绘图光标，我们可以使用`lineTo()`方法绘制线条，定义线条终点的坐标：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, to make the line visible, we can use the `stroke()` method. Unless,
    otherwise specified, the default stroke color is black.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使线条可见，我们可以使用`stroke()`方法。除非另有规定，默认的描边颜色是黑色。
- en: 'To summarize, here''s the typical drawing procedure we should follow when drawing
    lines with the HTML5 canvas API:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当使用HTML5画布API绘制线条时，我们应该遵循的典型绘制过程如下：
- en: Style your line (like choosing a colored marker with a specific tip thickness).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式你的线条（比如选择一个特定尖端厚度的彩色标记）。
- en: Position the canvas context using `moveTo()` (like placing the marker onto a
    piece of paper).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`moveTo()`定位画布上下文（就像把标记放在纸上）。
- en: Draw the line with `lineTo()`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lineTo()`绘制线条。
- en: Make the line visible using `stroke()`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`stroke()`使线条可见。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'HTML5 canvas lines can also have one of three varying line caps, including
    **butt**, **round**, and **square**. The line cap style can be set using the `lineCap`
    property of the canvas context. Unless otherwise specified, the line cap style
    is defaulted to butt. The following diagram shows three lines, each with varying
    line cap styles. The top line is using the default butt line cap, the middle line
    is using the round line cap, and the bottom line is using a square line cap:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5画布线条也可以具有三种不同的线帽，包括**butt**、**round**和**square**。线帽样式可以使用画布上下文的`lineCap`属性进行设置。除非另有规定，线帽样式默认为butt。下图显示了三条线，每条线都具有不同的线帽样式。顶部线使用默认的butt线帽，中间线使用round线帽，底部线使用square线帽：
- en: '![There''s more...](img/1369_01_14.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1369_01_14.jpg)'
- en: Notice that the middle and bottom lines are slightly longer than the top line,
    even though all of the line widths are equal. This is because the round line cap
    and the square line cap increase the length of a line by an amount equal to the
    width of the line. For example, if our line is 200 px long and 10 px wide, and
    we use a round or square line cap style, the resulting line will be 210 px long
    because each cap adds 5 px to the line length.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，中间和底部线比顶部线稍长，尽管所有线宽度相等。这是因为round线帽和square线帽会使线的长度增加，增加的量等于线的宽度。例如，如果我们的线长为200像素，宽度为10像素，并且使用round或square线帽样式，那么结果线的长度将为210像素，因为每个线帽都会增加5像素的线长。
- en: See also...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a zigzag*'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制锯齿*'
- en: '*Putting it all together: Drawing a jet* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将所有内容放在一起：在[第2章](ch02.html "第2章。形状绘制和合成")中绘制喷气式飞机'
- en: Drawing an arc
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一条弧
- en: When drawing with the HTML5 canvas, it's sometimes necessary to draw perfect
    arcs. If you're interested in drawing happy rainbows, smiley faces, or diagrams,
    this recipe would be a good start for your endeavor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用HTML5画布绘制时，有时需要绘制完美的弧。如果你对绘制快乐的彩虹、笑脸或图表感兴趣，这个方法将是你努力的良好起点。
- en: '![Drawing an arc](img/1369_01_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![绘制一条弧](img/1369_01_02.jpg)'
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a simple arc:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制简单的弧：
- en: 'Define a 2D canvas context and set the arc style:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文并设置弧线样式：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Draw the arc:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制弧：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的body中：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We can create an HTML5 arc with the `arc()` method which is defined by a section
    of the circumference of an imaginary circle. Take a look at the following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`arc()`方法创建HTML5弧，该方法由虚拟圆的圆周部分定义。看一下下面的图表：
- en: '![How it works...](img/1369_01_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1369_01_05.jpg)'
- en: 'The imaginary circle is defined by a center point and a radius. The circumference
    section is defined by a starting angle, an ending angle, and whether or not the
    arc is drawn counter-clockwise:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟圆由一个中心点和一个半径定义。圆周部分由起始角度、结束角度以及弧是顺时针绘制还是逆时针绘制来定义：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the angles start with 0π at the right of the circle and move clockwise
    to 3π/2, π, π/2, and then back to 0\. For this recipe, we've used 1.1π as the
    starting angle and 1.9π as the ending angle. This means that the starting angle
    is just slightly above center on the left side of the imaginary circle, and the
    ending angle is just slightly above center on the right side of the imaginary
    circle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，角度从圆的右侧0π开始，顺时针移动到3π/2、π、π/2，然后返回0。对于这个方法，我们使用1.1π作为起始角度，1.9π作为结束角度。这意味着起始角度略高于虚拟圆左侧的中心，结束角度略高于虚拟圆右侧的中心。
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The values for the starting angle and the ending angle do not necessarily have
    to lie within 0π and 2π. In fact, the starting angle and ending angle can be any
    real number because the angles can overlap themselves as they travel around the
    circle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 起始角度和结束角度的值不一定要在0π和2π之间。实际上，起始角度和结束角度可以是任何实数，因为角度可以在围绕圆圈旋转时重叠。
- en: For example, let's say that we define our starting angle as 3π. This is equivalent
    to one full revolution around the circle (2π) and another half revolution around
    the circle (1π). In other words, 3π is equivalent to 1π. As another example, -
    3π is also equivalent to 1π because the angle travels one and a half revolutions
    counter-clockwise around the circle, ending up at 1π.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们将起始角度定义为3π。这相当于围绕圆圈一周（2π）再围绕圆圈半周（1π）。换句话说，3π等同于1π。另一个例子，-3π也等同于1π，因为角度沿着圆圈逆时针旋转一周半，最终到达1π。
- en: 'Another method for creating arcs with the HTML5 canvas is to make use of the
    `arcTo()` method. The resulting arc from the `arcTo()` method is defined by the
    context point, a control point, an ending point, and a radius:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML5画布创建弧的另一种方法是利用`arcTo()`方法。`arcTo()`方法生成的弧由上下文点、控制点、结束点和半径定义：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unlike the `arc()` method, which positions an arc by its center point, the `arcTo()`
    method is dependent on the context point, similar to the `lineTo()` method. The
    `arcTo()` method is most commonly used when creating rounded corners for paths
    or shapes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与`arc()`方法不同，`arcTo()`方法依赖于上下文点来定位弧，类似于`lineTo()`方法。`arcTo()`方法在创建路径或形状的圆角时最常用。
- en: See also...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a circle in* [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章。形状绘制和合成")中绘制一个圆'
- en: '*Animating mechanical gears* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布生动起来")中制作机械齿轮动画'
- en: '*Animating a clock in* [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas
    to Life with Animation")'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布生动起来")中制作时钟动画'
- en: Drawing a Quadratic curve
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制二次曲线
- en: In this recipe, we'll learn how to draw a Quadratic curve. Quadratic curves
    provide much more flexibility and natural curvatures compared to its cousin, the
    arc, and are an excellent tool for creating custom shapes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何绘制二次曲线。与其表亲弧线相比，二次曲线提供了更多的灵活性和自然的曲线，是创建自定义形状的绝佳工具。
- en: '![Drawing a Quadratic curve](img/1369_01_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![绘制二次曲线](img/1369_01_03.jpg)'
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to draw a Quadratic curve:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制二次曲线：
- en: 'Define a 2D canvas context and set the curve style:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文并设置曲线样式：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Position the canvas context and draw the Quadratic curve:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位画布上下文并绘制二次曲线：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的主体中：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'HTML5 Quadratic curves are defined by the context point, a control point, and
    an ending point:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5二次曲线由上下文点、一个控制点和一个结束点定义：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Take a look at the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表：
- en: '![How it works...](img/1369_01_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1369_01_06.jpg)'
- en: The curvature of a Quadratic curve is defined by three characteristic tangents.
    The first part of the curve is tangential to an imaginary line that starts with
    the context point and ends with the control point. The peak of the curve is tangential
    to an imaginary line that starts with midpoint 1 and ends with midpoint 2\. Finally,
    the last part of the curve is tangential to an imaginary line that starts with
    the control point and ends with the ending point.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 二次曲线的曲率由三个特征切线定义。曲线的第一部分与一条虚拟线相切，该虚拟线从上下文点开始，到控制点结束。曲线的顶点与从中点1开始到中点2结束的虚拟线相切。最后，曲线的最后一部分与从控制点开始到结束点结束的虚拟线相切。
- en: See also...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Putting it all together: Drawing a jet*, in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将所有内容放在一起：在[第2章](ch02.html "第2章。形状绘制和组合")中绘制喷气机*'
- en: '*Unlocking the power of fractals: Drawing a haunted tree*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解锁分形的力量：绘制一棵幽灵树*'
- en: Drawing a Bezier curve
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制贝塞尔曲线
- en: If Quadratic curves don't meet your needs, the Bezier curve might do the trick.
    Also known as cubic curves, the Bezier curve is the most advanced curvature available
    with the HTML5 canvas API.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二次曲线不能满足您的需求，贝塞尔曲线可能会起作用。贝塞尔曲线也被称为三次曲线，是HTML5画布API中最先进的曲线。
- en: '![Drawing a Bezier curve](img/1369_01_04.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![绘制贝塞尔曲线](img/1369_01_04.jpg)'
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to draw an arbitrary Bezier curve:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制任意贝塞尔曲线：
- en: 'Define a 2D canvas context and set the curve style:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文并设置曲线样式：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Position the canvas context and draw the Bezier curve:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位画布上下文并绘制贝塞尔曲线：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的主体中：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'HTML5 canvas Bezier curves are defined by the context point, two control points,
    and an ending point. The additional control point gives us much more control over
    its curvature compared to Quadratic curves:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5画布贝塞尔曲线由上下文点、两个控制点和一个结束点定义。与二次曲线相比，额外的控制点使我们对其曲率有更多控制：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Take a look at the following diagram:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表：
- en: '![How it works...](img/1369_01_07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1369_01_07.jpg)'
- en: Unlike Quadratic curves, which are defined by three characteristic tangents,
    the Bezier curve is defined by five characteristic tangents. The first part of
    the curve is tangential to an imaginary line that starts with the context point
    and ends with the first control point. The next part of the curve is tangential
    to the imaginary line that starts with midpoint 1 and ends with midpoint 3\. The
    peak of the curve is tangential to the imaginary line that starts with midpoint
    2 and ends with midpoint 4\. The fourth part of the curve is tangential to the
    imaginary line that starts with midpoint 3 and ends with midpoint 5\. Finally,
    the last part of the curve is tangential to the imaginary line that starts with
    the second control point and ends with the ending point.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与二次曲线不同，贝塞尔曲线由五个特征切线定义，而不是三个。曲线的第一部分与一条虚拟线相切，该虚拟线从上下文点开始，到第一个控制点结束。曲线的下一部分与从中点1开始到中点3结束的虚拟线相切。曲线的顶点与从中点2开始到中点4结束的虚拟线相切。曲线的第四部分与从中点3开始到中点5结束的虚拟线相切。最后，曲线的最后一部分与从第二个控制点开始到结束点结束的虚拟线相切。
- en: See also...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Randomizing shape properties: Drawing a field of flowers* in [Chapter 2](ch02.html
    "Chapter 2. Shape Drawing and Composites")'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机化形状属性：在[第2章](ch02.html "第2章。形状绘制和组合")中绘制一片花海*'
- en: '*Putting it all together: Drawing a jet* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将所有内容放在一起：在[第2章](ch02.html "第2章。形状绘制和组合")中绘制喷气机*'
- en: Drawing a zigzag
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制锯齿
- en: In this recipe, we'll introduce path drawing by iteratively connecting line
    subpaths to draw a zigzag path.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过迭代连接线子路径来介绍路径绘制，以绘制锯齿路径。
- en: '![Drawing a zigzag](img/1369_01_08.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![绘制锯齿](img/1369_01_08.jpg)'
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to draw a zigzag path:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制锯齿路径：
- en: 'Define a 2D canvas context and initialize the zigzag parameters:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文并初始化锯齿参数：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the zigzag style and begin the path:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义锯齿样式并开始路径：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Draw seven connecting zigzag lines and then make the zigzag path visible with
    `stroke()`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制七条连接的锯齿线，然后使用`stroke()`使锯齿路径可见：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的主体中：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To draw a zigzag, we can connect alternating diagonal lines to form a path.
    Programmatically, this can be achieved by setting up a loop that draws diagonal
    lines moving upwards and to the right on odd iterations, and downwards and to
    the right on even iterations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制锯齿，我们可以连接交替的对角线以形成路径。通过设置一个循环来实现，该循环在奇数迭代上向上和向右绘制对角线，在偶数迭代上向下和向右绘制对角线。
- en: The key thing to pay attention to in this recipe is the `beginPath()` method.
    This method essentially declares that a path is being drawn, such that the end
    of each line sub path defines the beginning of the next sub path. Without using
    the `beginPath()` method, we would have to tediously position the canvas context
    using `moveTo()` for each line segment while ensuring that the ending points of
    the previous line segment match the starting point of the current line segment.
    As we will see in the next chapter, the `beginPath()` method is also a required
    step for creating shapes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中需要注意的关键事项是`beginPath()`方法。这个方法本质上声明正在绘制一个路径，以便每个线段子路径的结束定义下一个子路径的开始。如果不使用`beginPath()`方法，我们将不得不费力地使用`moveTo()`来定位每个线段，同时确保前一个线段的结束点与当前线段的起点匹配。正如我们将在下一章中看到的，`beginPath()`方法也是创建形状的必要步骤。
- en: Line join styles
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线连接样式
- en: Notice how the connection between each line segment comes to a sharp point.
    This is because the line join style of the HTML5 canvas path is defaulted to **miter**.
    Alternatively, we could also set the line join style to **round** or **bevel**
    with the `lineJoin` property of the canvas context.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个线段之间的连接是如何形成尖锐点的。这是因为HTML5 canvas路径的线连接样式默认为**miter**。或者，我们也可以使用画布上下文的`lineJoin`属性将线连接样式设置为**round**或**bevel**。
- en: If your line segments are fairly thin and don't connect at steep angles, it
    can be somewhat difficult to distinguish different line join styles. Typically,
    different line join styles are more noticeable when the path thickness exceeds
    5 px and the angle between line sub paths is relatively small.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的线段相当细，并且不以陡峭的角度连接，要区分不同的线连接样式可能有些困难。通常，当路径厚度超过5像素且线段之间的角度相对较小时，不同的线连接样式会更加明显。
- en: Drawing a spiral
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制螺旋线
- en: Caution, this recipe may induce hypnosis. In this recipe, we'll draw a spiral
    by connecting a series of short lines to form a spiral path.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个示例可能会引起催眠。在这个示例中，我们将通过连接一系列短线段来形成螺旋路径来绘制一个螺旋线。
- en: '![Drawing a spiral](img/1369_01_10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![绘制螺旋线](img/1369_01_10.jpg)'
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a centered spiral:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个居中的螺旋线：
- en: 'Define a 2D canvas context and initialize the spiral parameters:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文并初始化螺旋参数：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Set the spiral style:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置螺旋线样式：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Rotate about the center of the canvas three times (50 iterations per full revolution)
    while increasing the radius by 0.75 for each iteration and draw a line segment
    to the current point from the previous point with `lineTo()`. Finally, make the
    spiral visible with `stroke()`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 围绕画布中心旋转三次（每次完整旋转50次迭代），同时增加半径0.75，并使用`lineTo()`从上一个点到当前点绘制一条线段。最后，使用`stroke()`使螺旋线可见：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的body中：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw a spiral with HTML5 canvas, we can place our drawing cursor in the center
    of the canvas, iteratively increase the radius and angle about the center, and
    then draw a super short line from the previous point to the current point. Another
    way to think about it is to imagine yourself as a kid standing on a sidewalk with
    a piece of colored chalk. Bend down and put the chalk on the sidewalk, and then
    start turning in a circle (not too fast, though, unless you want to get dizzy
    and fall over). As you spin around, move the piece of chalk outward away from
    you. After a few revolutions, you'll have drawn a neat little spiral.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTML5 canvas绘制螺旋线，我们可以将绘图游标放在画布中心，迭代增加半径和角度，然后从上一个点到当前点绘制一个超短的线段。另一种思考方式是想象自己站在人行道上，手里拿着一支彩色粉笔。弯下腰把粉笔放在人行道上，然后开始围绕中心转圈（不要转得太快，除非你想晕倒）。当你转动时，把粉笔向外移动。几圈之后，你就画出了一个漂亮的小螺旋线。
- en: Working with text
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文本
- en: Almost all applications require some sort of text to effectively communicate
    something to the user. This recipe will show you how to draw a simple text string
    with an optimistic welcoming.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的应用程序都需要一些文本来有效地向用户传达信息。这个示例将向您展示如何绘制一个简单的文本字符串，带有一种乐观的欢迎。
- en: '![Working with text](img/1369_01_12.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![处理文本](img/1369_01_12.jpg)'
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to write text on the canvas:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在canvas上写字：
- en: 'Define a 2D canvas context and set the text style:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文并设置文本样式：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Horizontally and vertically align the text, and then draw it:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平和垂直对齐文本，然后绘制它：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的body中：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw text with the HTML5 canvas, we can define the font style and size with
    the `font` property, the font color with the `fillStyle` property, the horizontal
    text alignment with the `textAlign` property, and the vertical text alignment
    with the `textBaseline` property. The `textAlign` property can be set to `left`,
    `center`, or `right`, and the `textBaseline` property can be set to `top`, `hanging`,
    `middle`, `alphabetic`, `ideographic`, or `bottom`. Unless otherwise specified,
    the `textAlign` property is defaulted to `left`, and the `textBaseline` property
    is defaulted to alphabetic.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要在HTML5 canvas上绘制文本，我们可以使用`font`属性定义字体样式和大小，使用`fillStyle`属性定义字体颜色，使用`textAlign`属性定义水平文本对齐，使用`textBaseline`属性定义垂直文本对齐。`textAlign`属性可以设置为`left`、`center`或`right`，`textBaseline`属性可以设置为`top`、`hanging`、`middle`、`alphabetic`、`ideographic`或`bottom`。除非另有规定，否则`textAlign`属性默认为`left`，`textBaseline`属性默认为alphabetic。
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In addition to `fillText()`, the HTML5 canvas API also supports `strokeText()`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`fillText()`之外，HTML5 canvas API还支持`strokeText()`：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method will color the perimeter of the text instead of filling it. To set
    both the fill and stroke for HTML canvas text, you can use both the `fillText()`
    and the `strokeText()` methods together. It's good practice to use the `fillText()`
    method before the `strokeText()` method in order to render the stroke thickness
    correctly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将为文本的周边着色而不是填充。要为HTML画布文本设置填充和描边，可以同时使用`fillText（）`和`strokeText（）`方法。在渲染描边厚度时，最好先使用`fillText（）`方法，然后再使用`strokeText（）`方法。
- en: See also...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing 3D text with shadows*'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带阴影的3D文字绘制*'
- en: '*Creating a mirror transform in* [Chapter 4](ch04.html "Chapter 4. Mastering
    Transformations")'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在* [第4章](ch04.html "第4章. 掌握变换") *中创建镜像变换*'
- en: '*Drawing a simple logo and randomizing its position, rotation, and scale in*
    [Chapter 4](ch04.html "Chapter 4. Mastering Transformations")'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在* [第4章](ch04.html "第4章. 掌握变换") *中绘制简单的标志并随机化其位置、旋转和比例*'
- en: Drawing 3D text with shadows
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带阴影的3D文字绘制
- en: If 2D text doesn't get you jazzed, you might consider drawing 3D text instead.
    Although the HTML5 canvas API doesn't directly provide us with a means for creating
    3D text, we can certainly create a custom `draw3dText()` method using the existing
    API.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果2D文本不能激发你的热情，你可以考虑绘制3D文本。尽管HTML5画布API并没有直接为我们提供创建3D文本的手段，但我们可以使用现有的API创建自定义的`draw3dText（）`方法。
- en: '![Drawing 3D text with shadows](img/1369_01_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![带阴影的3D文字绘制](img/1369_01_11.jpg)'
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create 3D text:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建3D文本：
- en: 'Set the canvas context and the text style:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置画布上下文和文本样式：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Align and draw the 3D text:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对齐并绘制3D文本：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define the `draw3dText()` function that draws multiple text layers and adds
    a shadow:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`draw3dText（）`函数，绘制多个文本层并添加阴影：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的主体中嵌入画布标记：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw 3D text with the HTML5 canvas, we can stack multiple layers of the same
    text on top of one another to create the illusion of depth. In this recipe, we've
    set the text depth to five, which means that our custom `draw3dText()` method
    layers five instances of "Hello 3D World!" on top of one another. We can color
    these layers black to create the illusion of darkness beneath our text.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTML5画布绘制3D文本，我们可以将多个相同文本的图层叠加在一起，以创建深度的错觉。在这个示例中，我们将文本深度设置为五，这意味着我们的自定义`draw3dText（）`方法会在一起叠加五个“Hello
    3D World！”的实例。我们可以将这些图层着色为黑色，以在文本下方创建黑暗的错觉。
- en: Next, we can add a colored top layer to portray a forward-facing surface. Finally,
    we can apply a soft shadow beneath the text by setting the `shadowColor`, `shadowBlur`,
    `shadowOffsetX`, and `shadowOffsetY` properties of the canvas context. As we'll
    see in later recipes, these properties aren't limited to text and can also be
    applied to sub paths, paths, and shapes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加一个有颜色的顶层来描绘一个朝前的表面。最后，我们可以通过设置画布上下文的`shadowColor`，`shadowBlur`，`shadowOffsetX`和`shadowOffsetY`属性，在文本下方应用柔和的阴影。正如我们将在后面的示例中看到的，这些属性不仅限于文本，还可以应用于子路径、路径和形状。
- en: 'Unlocking the power of fractals: Drawing a haunted tree'
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放分形的力量：绘制一棵幽灵树
- en: First thing's first—what are fractals? If you don't already know, fractals are
    the awesome result when you mix mathematics with art, and can be found in all
    sorts of patterns that make up life. Algorithmically, a fractal is based on an
    equation that undergoes recursion. In this recipe, we'll create an organic-looking
    tree by drawing a trunk which forks into two branches, and then draw two more
    branches that stem from the branches we just drew. After twelve iterations, we'll
    end up with an elaborate, seemingly chaotic mesh of branches and twigs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是分形？如果你还不知道，分形是数学与艺术相结合的令人惊叹的结果，可以在构成生活的各种模式中找到。从算法上讲，分形是基于经历递归的方程。在这个示例中，我们将通过绘制一个分叉成两个分支的树干，然后从我们刚刚绘制的两个分支中再绘制两个分支，来创建一个有机的树。
- en: '![Unlocking the power of fractals: Drawing a haunted tree](img/1369_01_13.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![释放分形的力量：绘制一棵幽灵树](img/1369_01_13.jpg)'
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a tree using fractals:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制使用分形的树：
- en: 'Create a recursive function that draws a single branch that forks out into
    two branches, and then recursively calls itself to draw another two branches from
    the end points of the forked branches:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个递归函数，绘制一个分叉成两个分支的单个分支，然后递归调用自身，从分叉分支的端点绘制另外两个分支：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Initialize the canvas context and begin drawing the tree fractal by calling
    `drawBranches()`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化画布上下文，并通过调用`drawBranches（）`开始绘制树分形：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的主体中嵌入画布标记：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To create a tree using fractals, we need to design the recursive function that
    defines the mathematical nature of a tree. If you take a moment and study a tree
    (they are quite beautiful if you think about it), you'll notice that each branch
    forks into smaller branches. In turn, those branches fork into even smaller branches,
    and so on. This means that our recursive function should draw a single branch
    that forks into two branches, and then recursively calls itself to draw another
    two branches that stem from the two branches we just drew.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用分形创建树，我们需要设计定义树的数学特性的递归函数。如果你花一点时间研究一棵树（如果你仔细想想，它们是相当美丽的），你会注意到每个分支都分叉成更小的分支。反过来，这些分支又分叉成更小的分支，依此类推。这意味着我们的递归函数应该绘制一个分叉成两个分支的单个分支，然后递归调用自身，从我们刚刚绘制的两个分支中再绘制两个分支。
- en: Now that we have a plan for creating our fractal, we can implement it using
    the HTML5 canvas API. The easiest way to draw a branch that forks into two branches
    is by drawing two Quadratic curves that bend outwards from one another.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建分形的计划，我们可以使用HTML5画布API来实现它。绘制一个分叉成两个分支的最简单方法是通过绘制两个二次曲线，这些曲线从彼此弯曲向外。
- en: If we were to use the exact same drawing procedure for each iteration, our tree
    would be perfectly symmetrical and quite uninteresting. To help make our tree
    look more natural, we can introduce random variables that offset the ending points
    of each branch.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对每次迭代使用完全相同的绘图过程，我们的树将会是完全对称且相当无趣的。为了使我们的树看起来更自然，我们可以引入随机变量来偏移每个分支的结束点。
- en: There's more...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The fun thing about this recipe is that every tree is different. If you code
    this one up for yourself and continuously refresh your browser, you'll see that
    every tree formation is completely unique. You might also be interested in tweaking
    the branch-drawing algorithm to create different kinds of trees, or even draw
    leaves at the tips of the smallest branches.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的有趣之处在于每棵树都是不同的。如果你自己编写这个代码并不断刷新你的浏览器，你会发现每棵树的形成都是完全独特的。你可能还会对调整分支绘制算法以创建不同类型的树，甚至在最小的分支尖端绘制叶子感兴趣。
- en: Some other great examples of fractals can be found in sea shells, snowflakes,
    feathers, plant life, crystals, mountains, rivers, and lightning.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他很好的分形例子可以在海贝壳、雪花、羽毛、植物、晶体、山脉、河流和闪电中找到。
