- en: Chapter 3. Working with Images and Videos
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用图像和视频
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Drawing an image
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制图像
- en: Cropping an image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪图像
- en: Copying and pasting sections of the canvas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制和粘贴画布的部分
- en: Working with video
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视频
- en: Getting image data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取图像数据
- en: 'Introduction to pixel manipulation: inverting image colors'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素操作简介：反转图像颜色
- en: Inverting video colors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转视频颜色
- en: Converting image colors to grayscale
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像颜色转换为灰度
- en: Converting a canvas drawing into a data URL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将画布绘制转换为数据URL
- en: Saving a canvas drawing as an image
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将画布绘制保存为图像
- en: Loading the canvas with a data URL
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据URL加载画布
- en: Creating a pixelated image focus
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建像素化图像焦点
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter focuses on yet another very exciting topic of the HTML5 canvas,
    images and videos. Along with providing basic functionality for positioning, sizing,
    and cropping images and videos, the HTML5 canvas API also allows us to access
    and modify the color and transparency of each pixel for both mediums. Let's get
    started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍HTML5画布、图像和视频的另一个非常令人兴奋的主题。除了提供定位、调整大小和裁剪图像和视频的基本功能外，HTML5画布API还允许我们访问和修改每个像素的颜色和透明度。让我们开始吧！
- en: Drawing an image
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制图像
- en: Let's jump right in by drawing a simple image. In this recipe, we'll learn how
    to load an image and draw it somewhere on the canvas.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过绘制一个简单的图像来开始。在本示例中，我们将学习如何加载图像并在画布上的某个位置绘制它。
- en: '![Drawing an image](img/1369_03_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![绘制图像](img/1369_03_01.jpg)'
- en: 'Follow these steps to draw an image in the center of the canvas:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在画布中央绘制图像：
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define the canvas context:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create an `image` object, set the `onload` property to a function that draws
    the image, and then set the source of the image:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`image`对象，将`onload`属性设置为绘制图像的函数，然后设置图像的源：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的主体中：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw an image, we first need to create an `image` object using new `Image()`.
    Notice that we've set the `onload` property of the `image` object *before* defining
    the source of the image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制图像，我们首先需要使用`new Image()`创建一个`image`对象。请注意，我们在定义图像的源*之前*设置了`image`对象的`onload`属性。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's good practice to define what we want to do with the image when it loads
    *before* setting its source. Theoretically, if we were to define the source of
    the image before we define the `onload` property; the image could possibly load
    before the definition is complete (although, it's very unlikely).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置图像源*之前*定义加载图像时要执行的操作是一个很好的做法。理论上，如果我们在定义`onload`属性之前定义图像的源，图像可能会在定义完成之前加载（尽管这很不太可能）。
- en: 'The key method in this recipe is the `drawImage()` method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的关键方法是`drawImage()`方法：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Where `imageObj` is the `image` object, and `destX` and `destY` is where we
    want to position the image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`imageObj`是`image`对象，`destX`和`destY`是我们想要放置图像的位置。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In addition to defining an image position with `destX` and `destY`, we can
    also add two additional parameters, `destWidth` and `destHeight` to define the
    size of our image:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`destX`和`destY`定义图像位置外，我们还可以添加两个额外的参数，`destWidth`和`destHeight`来定义图像的大小：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the most part, it's a good idea to stay away from resizing an image with
    the `drawImage()` method, simply because the quality of the scaled image will
    be noticeably reduced, similar to the result when we resize an image with the
    width and height properties of an HTML image element. If image quality is something
    you're concerned about (why on earth wouldn't you be?), it's usually best to work
    with thumbnail images alongside bigger images if you're creating an application
    that needs scaled images. If, on the other hand, your application dynamically
    shrinks and expands images, using the `drawImage()` method with `destWidth` and
    `destHeight` to scale images is a perfectly acceptable approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好不要使用`drawImage()`方法调整图像的大小，因为缩放图像的质量会明显降低，类似于使用HTML图像元素的宽度和高度属性调整图像大小时的结果。如果图像质量是您关心的问题（为什么你不会关心？），通常最好在创建需要缩放图像的应用程序时使用缩略图图像。另一方面，如果您的应用程序动态缩小和扩展图像，使用`drawImage()`方法和`destWidth`和`destHeight`来缩放图像是一个完全可以接受的方法。
- en: Cropping an image
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裁剪图像
- en: In this recipe, we'll crop out a section of an image and then draw the result
    onto the canvas.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将裁剪图像的一部分，然后将结果绘制到画布上。
- en: '![Cropping an image](img/1369_03_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![裁剪图像](img/1369_03_02.jpg)'
- en: Follow these steps to crop out a section of an image and draw the result onto
    the canvas.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤裁剪图像的一部分并将结果绘制到画布上。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define the canvas context:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create an image object, set the `onload` property to a function that crops
    the image, and then set the source of the image:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图像对象，将`onload`属性设置为裁剪图像的函数，然后设置图像的源：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的主体中：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the last recipe, we discussed two different ways that we can use the `drawImage()`
    method to draw images on the canvas. In the first case, we can pass an `image`
    object and a position to simply draw an image at the given position. In the second
    case, we can pass an `image` object, a position, and a size to draw an image at
    the given position with the given size. Additionally, we can also add six more
    parameters to the `drawImage()` method if we wanted to crop an image:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们讨论了使用`drawImage()`方法在画布上绘制图像的两种不同方式。在第一种情况下，我们可以传递一个`image`对象和一个位置，简单地在给定位置绘制图像。在第二种情况下，我们可以传递一个`image`对象，一个位置和一个大小，在给定位置以给定大小绘制图像。此外，如果我们想要裁剪图像，还可以向`drawImage()`方法添加六个参数：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Take a look at the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表：
- en: '![imagecropping, stepsHow it works...](img/1369_03_02a.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图像裁剪，步骤是如何工作的...](img/1369_03_02a.jpg)'
- en: As you can see, `sourceX` and `sourceY` refer to the top-left corner of the
    cropped region in the source image. `sourceWidth` and `sourceHeight` refer to
    the width and height of the cropped image from the source. `destX` and `destY`
    refer to the position of the cropped image on the canvas, and `destWidth` and
    `destHeight` refer to the width and height of the resulting cropped image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`sourceX`和`sourceY`指的是源图像中裁剪区域的左上角。`sourceWidth`和`sourceHeight`指的是源图像中裁剪图像的宽度和高度。`destX`和`destY`指的是裁剪图像在画布上的位置，`destWidth`和`destHeight`指的是结果裁剪图像的宽度和高度。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you don't intend to scale a cropped image, then `destWidth` equals `sourceWidth`
    and `destHeight` equals `sourceHeight`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不打算缩放裁剪的图像，则`destWidth`等于`sourceWidth`，`destHeight`等于`sourceHeight`。
- en: Copying and pasting sections of the canvas
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制和粘贴画布的部分
- en: In this recipe, we'll cover yet another interesting usage of the `drawImage()`
    method—copying sections of the canvas. First, we'll draw a spade in the center
    of the canvas, then we'll copy the right side of the spade and then paste it to
    the left, and then we'll copy the left side of the spade and then paste it to
    the right.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将介绍`drawImage()`方法的另一个有趣用法——复制画布的部分。首先，我们将在画布中心绘制一个梅花，然后我们将复制梅花的右侧，然后粘贴到左侧，然后我们将复制梅花的左侧，然后粘贴到右侧。
- en: '![Copying and pasting sections of the canvas](img/1369_03_02b.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![复制和粘贴画布的部分](img/1369_03_02b.jpg)'
- en: 'Follow these steps to draw a spade in the center of the canvas and then copy-and-paste
    sections of the shape back onto the canvas:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在画布中心绘制一个梅花，然后将形状的部分复制并粘贴回画布上：
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define the canvas context:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Draw a spade in the center of the canvas using the `drawSpade()` function that
    we created in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites"),
    *Shape Drawing and Composites*:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在[第2章](ch02.html "第2章。形状绘制和合成")中创建的`drawSpade()`函数，在画布中心绘制一个梅花，*形状绘制和合成*：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Copy the right half of the spade and then paste it on the canvas to the left
    of the spade using the `drawImage()` method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制梅花的右半部分，然后使用`drawImage()`方法将其粘贴到梅花左侧的画布上：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Copy the left half of the spade and then paste it on the canvas to the right
    of the spade using the `drawImage()` method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制梅花的左半部分，然后使用`drawImage()`方法将其粘贴到梅花右侧的画布上：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To copy a section of the canvas, we can pass the `canvas` object to the `drawImage()`
    method instead of an `image` object:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制画布的一部分，我们可以将`canvas`对象传递给`drawImage()`方法，而不是一个`image`对象：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we'll see in the next recipe, not only can we copy sections of an image or
    a canvas with `drawImage()`, we can also copy sections of HTML5 video.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一个示例中看到的，我们不仅可以使用`drawImage()`复制图像或画布的部分，还可以复制HTML5视频的部分。
- en: Working with video
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视频
- en: Although the HTML5 canvas API doesn't provide a direct method for drawing videos
    on the canvas like it does for images, we can certainly work with videos by capturing
    frames from a hidden video tag and then copying them onto the canvas with a loop.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HTML5画布API没有提供像图像那样在画布上绘制视频的直接方法，但我们可以通过从隐藏的视频标签中捕获帧，然后通过循环将它们复制到画布上来处理视频。
- en: '![Working with video](img/1369_03_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用视频](img/1369_03_03.jpg)'
- en: Getting ready...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Before we get started, let's talk about the supported HTML5 video formats for
    each browser. At the time of writing, the video format war continues to rage on,
    in which all of the major browsers—Chrome, Firefox, Opera, Safari, and IE—continue
    to drop and add support for different video formats. To make things worse, each
    time a major browser adds or drops support for a particular video format, developers
    have to once again re-formulate the minimal set of video formats that's required
    for their applications to work across all browsers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们谈谈每个浏览器支持的HTML5视频格式。在撰写本文时，视频格式之争仍在继续，所有主要浏览器——Chrome、Firefox、Opera、Safari和IE——继续增加和删除对不同视频格式的支持。更糟糕的是，每当一个主要浏览器增加或删除对特定视频格式的支持时，开发人员就必须重新制定所需的最小视频格式集，以确保其应用程序在所有浏览器中正常工作。
- en: At the time of writing, the three major video formats are Ogg Theora, H.264,
    and WebM. For the video recipes in this chapter, we'll be using a combination
    of Ogg Theora and H.264\. When working with video, it's strongly advised that
    you do a search online to see what the current status is for video support as
    it is a subject to change at any moment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，三种主要的视频格式是Ogg Theora、H.264和WebM。在本章的视频示例中，我们将使用Ogg Theora和H.264的组合。在处理视频时，强烈建议您在网上搜索，了解视频支持的当前状态，因为它可能随时发生变化。
- en: There's more! Once you've decided which video formats to support, you'll probably
    need a video format converter to convert the video file that you have on hand
    to other video formats. One great option for converting video formats is the Miro
    Video Converter, which supports video format conversions for just about any video
    format including Ogg Theora, H.264, or WebM formats.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多！一旦您决定支持哪些视频格式，您可能需要一个视频格式转换器，将手头的视频文件转换为其他视频格式。一个很好的视频格式转换选项是Miro Video
    Converter，它支持几乎任何视频格式的视频格式转换，包括Ogg Theora、H.264或WebM格式。
- en: 'Miro Video Converter is probably the most common video converter available
    at the time of writing, although you can certainly use any other video format
    converter of your liking. You can download Miro Video Converter from: [http://www.mirovideoconverter.com/](http://www.mirovideoconverter.com/).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Miro Video Converter可能是目前最常见的视频转换器，尽管您当然可以使用任何其他您喜欢的视频格式转换器。您可以从以下网址下载Miro Video
    Converter：[http://www.mirovideoconverter.com/](http://www.mirovideoconverter.com/)。
- en: 'Follow these steps to draw a video onto the canvas:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将视频绘制到画布上：
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a cross-browser method that requests an animation frame:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个跨浏览器的方法来请求动画帧：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the `drawFrame()` function which copies the current video frame, pastes
    it onto the canvas using the `drawImage()` method, and then requests a new animation
    frame to draw the next frame:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawFrame()`函数，它会复制当前视频帧，使用`drawImage()`方法将其粘贴到canvas上，然后请求新的动画帧来绘制下一帧：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the canvas context, get the video tag, and draw the first video frame:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义canvas上下文，获取视频标签，并绘制第一帧视频：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Embed the canvas and the video tag inside the body of the HTML document:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body中嵌入canvas和video标签：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw a video on an HTML5 canvas, we first need to embed a hidden video tag
    in the HTML document. In this recipe, and in future video recipes, I've used the
    Ogg Theora and H.264 (mp4) video formats.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在HTML5画布上绘制视频，我们首先需要在HTML文档中嵌入一个隐藏的视频标签。在这个示例中，以及将来的视频示例中，我使用了Ogg Theora和H.264（mp4）视频格式。
- en: Next, when the page loads, we can use our cross-browser `requestAnimFrame()`
    method to capture the video frames as fast as the browser will allow and then
    draw them onto the canvas.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当页面加载时，我们可以使用跨浏览器的`requestAnimFrame()`方法尽可能快地捕获视频帧，然后将它们绘制到canvas上。
- en: Getting image data
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取图像数据
- en: Now that we know how to draw images and videos, let's try accessing the image
    data to see what kind of properties we can play with.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何绘制图像和视频，让我们尝试访问图像数据，看看我们可以玩的属性有哪些。
- en: '![Getting image data](img/1369_03_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![获取图像数据](img/1369_03_04.jpg)'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'WARNING: This recipe must run on a web server due to security constraints with
    the `getImageData()` method.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：由于`getImageData()`方法的安全限制，此示例必须在Web服务器上运行。
- en: Getting ready...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Before we get started working with image data, it's important that we cover
    canvas security and the RGBA color space.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处理图像数据之前，重要的是我们要了解画布安全和RGBA颜色空间。
- en: So why is canvas security important with respect to accessing image data? Simply
    put, in order to access image data, we need to use the `getImateData()` method
    of the canvas context which will throw a `SECURITY_ERR` exception if we try accessing
    image data from an image residing on a non-web server file system, or if we try
    accessing image data from an image on a different domain. In other words, if you're
    going to try out these demos for yourself, they won't work if your files reside
    on your local file system. You'll need to run the rest of the recipes in this
    chapter on a web server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么画布安全对于访问图像数据很重要呢？简单来说，为了访问图像数据，我们需要使用画布上下文的`getImageData()`方法，如果我们尝试从非Web服务器文件系统上的图像或不同域上的图像访问图像数据，它将抛出`SECURITY_ERR`异常。换句话说，如果你要自己尝试这些演示，如果你的文件存储在本地文件系统上，它们将无法工作。你需要在Web服务器上运行本章的其余部分。
- en: 'Next, since pixel manipulation is all about altering the RGB values of pixels,
    we should probably cover the RGB color model and the RGBA color space while we''re
    at it. RGB represents the red, green, and blue components of a pixel''s color.
    Each component is an integer between 0 and 255, where 0 represents no color and
    255 represents full color. RGB values are often times represented as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于像素操作主要是改变像素的RGB值，我们可能应该在这里介绍RGB颜色模型和RGBA颜色空间。RGB代表像素颜色的红色、绿色和蓝色分量。每个分量都是0到255之间的整数，其中0表示没有颜色，255表示完整的颜色。RGB值通常表示如下：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here are some common color values represented with the RGB color model:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用RGB颜色模型表示的一些常见颜色值：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In addition to RGB, pixels can also have an alpha channel which refers to its
    opacity. An alpha channel of 0 is a fully transparent pixel, and an alpha channel
    of 255 is a fully opaque pixel. RGBA color space simply refers to the RGB color
    model (RGB) plus the alpha channel (A).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了RGB，像素还可以有一个alpha通道，它指的是像素的不透明度。alpha通道为0是完全透明的像素，alpha通道为255是完全不透明的像素。RGBA颜色空间简单地指的是RGB颜色模型（RGB）加上alpha通道（A）。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful not to confuse the alpha channel range of HTML5 canvas pixels, which
    are integers 0 to 255, and the alpha channel range of CSS colors, which are decimals
    0.0 to 1.0.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意不要混淆HTML5画布像素的alpha通道范围（整数0到255）和CSS颜色的alpha通道范围（小数0.0到1.0）。
- en: 'Follow these steps to write out the image data properties of an image:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤写出图像数据的属性：
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define a canvas context:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个canvas上下文：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create an `image` object, set the `onload` property to a function which draws
    the image:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`image`对象，将`onload`属性设置为一个绘制图像的函数：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Get the image data, write out its properties, and then set the source of the
    `image` object outside of the `onload` definition:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取图像数据，写出其属性，然后在`onload`定义之外设置`image`对象的源：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Embed the canvas tag into the body of the HTML document:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的body中：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The idea behind this recipe is to draw an image, get its image data, and then
    write out the image data properties to the screen. As you can see from the preceding
    code, we can get the image data using the `getImageData()` method of the canvas
    context:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的思路是绘制图像，获取其图像数据，然后将图像数据属性写到屏幕上。从前面的代码中可以看到，我们可以使用canvas上下文的`getImageData()`方法获取图像数据：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the `getImageData()` method only works with the canvas context and
    not the `image` object itself. As a result, in order to get image data, we must
    first draw an image onto the canvas and then use `getImageData()` method of the
    canvas context.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`getImageData()`方法只能与canvas上下文一起使用，而不能直接使用`image`对象本身。因此，为了获取图像数据，我们必须先将图像绘制到canvas上，然后使用canvas上下文的`getImageData()`方法。
- en: 'The `ImageData` object contains three properties: `width`, `height`, and `data`.
    As you can see from the screenshot in the beginning of this recipe, our `ImageData`
    object contains a `width` property of 300, a `height` property of 214, and a `data`
    property which is an array of pixel information, which in this case has a length
    of 256,800 elements. The key to the `ImageData` object, in all honesty, is the
    `data` property. The `data` property contains the RGBA information for each pixel
    in our image. Since our image is made up of 300 * 214 = 64,200 pixels, the length
    of this array is 4 * 64,200 = 256,800 elements.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageData`对象包含三个属性：`width`、`height`和`data`。从这个食谱开头的截图中可以看到，我们的`ImageData`对象包含一个宽度属性为300，一个高度属性为214，以及一个`data`属性，它是一个像素信息数组，在这种情况下，长度为256,800个元素。说实话，`ImageData`对象的关键是`data`属性。`data`属性包含我们图像中每个像素的RGBA信息。由于我们的图像由300
    * 214 = 64,200像素组成，因此这个数组的长度为4 * 64,200 = 256,800个元素。'
- en: 'Introduction to pixel manipulation: inverting image colors'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素处理简介：反转图像颜色
- en: Now that we know how to access image data, including the RGBA for every pixel
    in an image or video, our next step is to explore the possibilities of pixel manipulation.
    In this recipe, we'll invert the colors of an image by inverting the color of
    each pixel.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何访问图像数据，包括图像或视频中每个像素的RGBA，我们的下一步是探索像素处理的可能性。在这个食谱中，我们将通过反转每个像素的颜色来反转图像的颜色。
- en: '![Introduction to pixel manipulation: inverting image colors](img/1369_03_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![像素处理简介：反转图像颜色](img/1369_03_05.jpg)'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'WARNING: This recipe must be run on a web server due to security constraints
    with the `getImageData()` method.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：由于`getImageData()`方法的安全限制，这个食谱必须在web服务器上运行。
- en: 'Follow these steps to invert the colors of an image:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤反转图像的颜色：
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Define the canvas context:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义canvas上下文：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create an `image` object and set the `onload` property to a function that draws
    the image and gets the image data:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`image`对象，并将`onload`属性设置为绘制图像和获取图像数据的函数：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Loop through all of the pixels in the image and invert the colors:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历图像中的所有像素并反转颜色：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Overwrite the original image with the manipulated image, and then set the source
    of the image outside of the `onload` definition:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用处理后的图像覆盖原始图像，然后在`onload`定义之外设置图像的源：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Embed the canvas tag into the body of the HTML document:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入到HTML文档的body中：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To invert the color of an image using HTML5 canvas, we can simply loop through
    all of the pixels in an image and then invert each pixel using a color inverting
    algorithm. Don''t worry it''s easier than it sounds. To invert a pixel''s color,
    we can invert each of its RGB components by subtracting each value from 255 as
    follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML5画布反转图像的颜色，我们可以简单地循环遍历图像中的所有像素，然后使用颜色反转算法反转每个像素。别担心，这比听起来容易。要反转像素的颜色，我们可以通过从255中减去每个值来反转其RGB分量中的每一个值，如下所示：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the pixels have been updated, we can redraw the image using the `putImageData()`
    method of the canvas context:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦像素被更新，我们可以使用画布上下文的`putImageData()`方法重新绘制图像：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method basically allows us to draw an image using image data instead of
    a source image with the `drawImage()` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法基本上允许我们使用图像数据而不是`drawImage()`方法的源图像来绘制图像。
- en: Inverting video colors
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转视频颜色
- en: The purpose of this recipe is to demonstrate how to perform pixel manipulations
    on videos in much the same way as we did with images. In this recipe, we'll invert
    the colors of a short video clip.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的目的是演示如何对视频进行像素处理，方法与处理图像的方式基本相同。在这个食谱中，我们将反转一个短视频片段的颜色。
- en: '![drawImage() methodIpixel manipulationworkingnverting video colors](img/1369_03_06.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![drawImage()方法像素处理工作中反转视频颜色](img/1369_03_06.jpg)'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'WARNING: This recipe must be run on a web server due to security constraints
    with the `getImageData()` method.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：由于`getImageData()`方法的安全限制，这个食谱必须在web服务器上运行。
- en: 'Follow these steps to invert the colors of a video:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤反转视频的颜色：
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a cross-browser method that requests an animation frame:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个跨浏览器的方法来请求动画帧：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the `drawFrame()` function that captures the current video frame, inverts
    the colors, draws the frame on the canvas, and then requests a new animation frame:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawFrame()`函数，捕获当前视频帧，反转颜色，将帧绘制在画布上，然后请求一个新的动画帧：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the canvas context, get the video tag, and draw the first animation
    frame:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文，获取视频标签，并绘制第一个动画帧：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Embed the video and canvas element into the body of the HTML document:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视频和canvas元素嵌入到HTML文档的body中：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Similarly to the previous recipe, we can perform pixel manipulations on video
    in much the same way that we did with images because the `getImageData()` method
    gets the image data from the canvas context regardless of how the context was
    rendered. In this recipe, we can simply invert the color of each pixel on the
    canvas for each video frame provided by the `requestAnimFrame()` method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的食谱类似，我们可以对视频进行像素处理，方法与处理图像的方式基本相同，因为`getImageData()`方法从画布上下文获取图像数据，而不管上下文是如何渲染的。在这个食谱中，我们可以简单地反转画布上每个像素的颜色，对应`requestAnimFrame()`方法提供的每个视频帧。
- en: Converting image colors to grayscale
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像颜色转换为灰度
- en: In this recipe, we'll explore another common pixel manipulation algorithm, converting
    colors to grayscale.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨另一个常见的像素处理算法，将颜色转换为灰度。
- en: '![requestAnimFrame() methodConverting image colors to grayscale](img/1369_03_07.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![requestAnimFrame()方法将图像颜色转换为灰度](img/1369_03_07.jpg)'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'WARNING: This recipe must be ran on a web server due to security constraints
    with the `getImageData()` method.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：由于`getImageData()`方法的安全限制，这个食谱必须在web服务器上运行。
- en: 'Follow these steps to convert the colors of an image to grayscale:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将图像的颜色转换为灰度：
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Define the canvas context:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义canvas上下文：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create an `image` object and set the `onload` property to a function that draws
    the image and gets the image data:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`image`对象，并将`onload`属性设置为绘制图像并获取图像数据的函数：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Loop through the pixels in the image and convert the colors to grayscale using
    the equation for brightness:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历图像中的像素，并使用亮度方程将颜色转换为灰度：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Overwrite the original image with the manipulated image and then set the image
    source after the `onload` definition:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用处理后的图像覆盖原始图像，然后在`onload`定义后设置图像源：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Embed the canvas element inside the body of the HTML document:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas元素嵌入HTML文档的body中：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To convert an RGB color into a gradation of gray, we need to obtain the brightness
    of the color. We can use the equation of brightness to obtain the grayscale value
    of a colored pixel. This equation is based on the fact that humans are most sensitive
    to green light, followed by red light, and are least sensitive to blue light:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要将RGB颜色转换为灰度渐变，我们需要获取颜色的亮度。我们可以使用亮度方程来获取彩色像素的灰度值。这个方程基于这样一个事实，即人类对绿光最敏感，其次是红光，对蓝光最不敏感：
- en: '`Brightness = 0.34 * R + 0.5 * G + 0.16 * B`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`亮度= 0.34 * R + 0.5 * G + 0.16 * B`'
- en: To account for physiological effects, notice that we've added more weight to
    the green value (most sensitive) followed by the red value (less sensitive) followed
    by the blue value (least sensitive).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑生理效应，请注意我们已经增加了对绿色值的权重（最敏感），然后是红色值（较不敏感），最后是蓝色值（最不敏感）。
- en: With this equation in hand, we can simply loop through all of the pixels in
    our image, calculate the perceived brightness, assign this value to each of the
    RGB values, and then re-draw the image onto the canvas.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个方程，我们可以简单地循环遍历图像中的所有像素，计算感知亮度，将这个值分配给RGB值中的每个值，然后重新绘制图像到画布上。
- en: Converting a canvas drawing into a data URL
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将画布绘图转换为数据URL
- en: In addition to image data, we can also extract an image data URL which is basically
    just a very long text string containing encoded information about the canvas image.
    Data URLs are extremely handy if we want to save the canvas drawing in local storage
    or in an offline database. In this recipe, we'll draw a cloud shape, get its data
    URL, and then insert it into the HTML page so that we can see what it looks like.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图像数据，我们还可以提取图像数据URL，它基本上只是一个包含有关画布图像的编码信息的非常长的文本字符串。如果我们想要将画布绘图保存在本地存储或离线数据库中，数据URL非常方便。在这个示例中，我们将绘制一个云形状，获取其数据URL，然后将其插入到HTML页面中，以便我们可以看到它的样子。
- en: 'Follow these steps to convert a canvas drawing into a data URL:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将画布绘图转换为数据URL：
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define the canvas context and draw a cloud shape:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文并绘制云形状：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Get the data URL of the canvas using the `toDataURL()` method of the `canvas`
    object:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`canvas`对象的`toDataURL()`方法获取画布的数据URL：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Insert the (long) data URL into a `<p>` tag so that we can see it:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将（长）数据URL插入到`<p>`标签中，以便我们可以看到它：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Embed the canvas tag inside the body of the HTML document and create a `<p>`
    tag which will be used to store the data URL:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的body中，并创建一个`<p>`标签，用于存储数据URL：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The key to this recipe is the `toDataURL()` method which converts a canvas
    drawing into a data URL:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的关键是`toDataURL()`方法，它将画布绘图转换为数据URL：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When running this demo, you''ll see a very long data URL that looks something
    like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此演示时，您将看到一个非常长的数据URL，看起来像这样：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What you're looking at here is just a small snippet of the entire data URL.
    The important part to pay attention to in the URL is the very beginning, which
    starts with `data:image/png;base64`. This means that the data URL is a PNG image
    which is represented by a base 64 encoding.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里看到的只是整个数据URL的一小部分。URL中需要注意的重要部分是非常开始的部分，以`data:image/png;base64`开头。这意味着数据URL是一个PNG图像，由base
    64编码表示。
- en: Unlike image data, which is a native array of pixel data, an image data URL
    is special because it's a string that can be stored with local storage, or it
    can be passed to a web server to be saved in an offline database. In other words,
    image data is useful for inspecting and manipulating each individual pixel that
    makes up an image, while image data URLs are intended to be used for storing the
    canvas drawing and to be passed between the client and server.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与图像数据不同，图像数据URL是特殊的，因为它是一个字符串，可以与本地存储一起存储，或者可以传递到Web服务器以保存在离线数据库中。换句话说，图像数据用于检查和操作构成图像的每个单独像素，而图像数据URL旨在用于存储画布绘图并在客户端和服务器之间传递。
- en: Saving a canvas drawing as an image
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将画布绘图保存为图像
- en: In addition to saving the canvas drawing in local storage or in an offline database,
    we can also use an image data URL to save the canvas drawing as an image so that
    a user can then save it to their local computer. In this recipe, we'll get the
    image data URL of the canvas drawing and then set it to the source of an `image`
    object so that a user can right click and download the image as a PNG.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将画布绘图保存在本地存储或离线数据库中，我们还可以使用图像数据URL将画布绘图保存为图像，以便用户可以将其保存到本地计算机。在这个示例中，我们将获取画布绘图的图像数据URL，然后将其设置为`image`对象的源，以便用户可以右键单击并将图像下载为PNG。
- en: 'Follow these steps to save a canvas drawing as an image:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将画布绘图保存为图像：
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define the canvas context and draw a cloud shape:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文并绘制云形状：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Get the data URL:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取数据URL：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Set the source of an image tag to the data URL so that a user can download
    it:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像标签的源设置为数据URL，以便用户可以下载它：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Embed the canvas tag in the body of the HTML document and add an image tag
    which will contain the canvas drawing:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入HTML文档的body中，并添加一个图像标签，其中将包含画布绘图：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After drawing something on the canvas, we can create an image that the user
    can save by getting the image data URL using the `toDataURL()` method, and then
    setting the source of an `image` object to the data URL. Once the image has loaded
    (which is nearly instantaneous because the image is being loaded directly and
    doesn't have to make a request to a web server), the user can right click on the
    image to save it to their local computer.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制完某些内容后，我们可以创建一个用户可以保存的图像，方法是使用`toDataURL()`方法获取图像数据URL，然后将`image`对象的源设置为数据URL。一旦图像加载完成（因为图像是直接加载的，不需要向Web服务器发出请求，所以几乎是瞬间完成的），用户可以右键单击图像将其保存到本地计算机。
- en: Loading the canvas with a data URL
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据URL加载画布
- en: To load the canvas with a data URL, we can extend the previous recipe by creating
    an `image` object with the data URL and then drawing it on the canvas using our
    good friend `drawImage()`. In this recipe, we'll make a simple Ajax call to get
    the data URL from a text file and then use the URL to draw the image on the canvas.
    In the real world of course, you'll probably be fetching the image data URL from
    local storage or by calling a data service.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用数据URL加载画布，我们可以通过创建一个带有数据URL的`image`对象并使用我们的好朋友`drawImage()`将其绘制到画布上来扩展上一个示例。在这个示例中，我们将通过创建一个简单的Ajax调用来从文本文件获取数据URL，然后使用该URL将图像绘制到画布上。当然，在现实世界中，您可能会从本地存储获取图像数据URL，或者通过调用数据服务来获取。
- en: 'Follow these steps to load a canvas drawing with a data URL:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用数据URL加载画布绘图：
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Define the `loadCanvas()` function which takes a data URL as input, defines
    a canvas context, creates a new image using the data URL, and then draws the image
    onto the canvas once it has loaded:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`loadCanvas()`函数，该函数以数据URL作为输入，定义画布上下文，使用数据URL创建一个新的图像，然后在加载完成后将图像绘制到画布上：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Make an AJAX call to get a data URL stored on your server, and then call `loadCanvas()`
    with the response text when the response is received:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行一个AJAX调用，以获取存储在服务器上的数据URL，然后在接收到响应时使用响应文本调用`loadCanvas()`：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入到HTML文档的body中：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To get the image data URL from a web server, we can set up an AJAX call (Asynchronous
    JavaScript and XML) to make a request to a web server and get the data URL as
    a response. When we get a status code of 200, which means that the request and
    response was successful, we can get the image data URL from `request.responseText`,
    and then pass it to the `loadCanvas()` function. This function will then create
    a new `image` object, set its source to the data URL, and then draw the image
    onto the canvas once it has loaded.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Web服务器获取图像数据URL，我们可以设置一个AJAX调用（异步JavaScript和XML）来向Web服务器发出请求并获取数据URL作为响应。当我们得到状态码200时，这意味着请求和响应成功，我们可以从`request.responseText`获取图像数据URL，然后将其传递给`loadCanvas()`函数。然后，该函数将创建一个新的`image`对象，将其源设置为数据URL，然后在加载完成后将图像绘制到画布上。
- en: Creating a pixelated image focus
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个像素化图像焦点
- en: Looking for a fancy way to focus an image? How about a pixelated image focus?
    In this recipe, we'll explore the art of image pixelation by looping through an
    algorithm that pixelates an image less and less until it's completely focused.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找一种时髦的方法来聚焦图像？像素化图像焦点怎么样？在这个示例中，我们将通过循环一个像素化算法来探索图像像素化的艺术，直到完全聚焦。
- en: '![Creating a pixelated image focus](img/1369_03_08.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![创建像素化图像焦点](img/1369_03_08.jpg)'
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'WARNING: This recipe must be run on a web server due to security constraints
    with the `getImageData()` method.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：由于`getImageData()`方法的安全限制，必须在Web服务器上运行此示例。
- en: 'Follow these steps to create a pixilation function that slowly focuses an image:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个逐渐聚焦图像的像素化函数：
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Define the `focusImage()` function which de-pixelates an image based on a pixilation
    value:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`focusImage()`函数，该函数根据像素化值去像素化图像：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define the canvas context, fps value that determines how fast or slow the image
    focuses, the corresponding time interval, and the initial pixilation amount:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文、决定图像聚焦速度的fps值、相应的时间间隔和初始像素化量：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a new `image` object, set the `onload` property to a function that creates
    a timed loop that calls the `focusImage()` function and decrements the pixilation
    value for each call until the image is focused, and then set the image source
    outside of the `onload` definition:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`image`对象，将`onload`属性设置为创建一个定时循环的函数，该函数调用`focusImage()`函数并递减每次调用的像素化值，直到图像聚焦，然后在`onload`定义之外设置图像源：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Embed the canvas tag into the body of the HTML document:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入到HTML文档的body中：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Before jumping into the pixelation algorithm, let's define pixelation. Pixelation
    of an image occurs when the human eye can detect the individual pixels that make
    up the image. Old school video game graphics and small images that have been enlarged
    are good examples of pixilation. In layman terms, if we define pixilation as a
    condition in which the pixels that make up the image are visible, this simply
    means that the pixels themselves are fairly large. In fact, the larger the pixels
    are, the more pixelated the image becomes. We can use this observation to create
    a pixilation algorithm.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入像素化算法之前，让我们定义像素化。当人眼可以检测到构成图像的单个像素时，图像就会出现像素化。老式视频游戏图形和被放大的小图像是像素化的很好的例子。通俗地说，如果我们将像素化定义为构成图像的像素可见的条件，这就意味着像素本身相当大。事实上，像素越大，图像就越像素化。我们可以利用这一观察结果来创建像素化算法。
- en: To create an algorithm that pixelates an image, we can take color samples of
    the image and then draw oversized pixels in its place. As pixels need to be square,
    we can construct pixel sizes of 1 x 1 (standard pixel size), 2 x 2, 3 x 3, 4 x
    4, and so on. The larger the pixels are, the more pixelated the image will look.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个像素化图像的算法，我们可以对图像进行颜色采样，然后用超大像素代替。由于像素需要是正方形的，我们可以构造1 x 1（标准像素大小）、2 x 2、3
    x 3、4 x 4等像素大小。像素越大，图像看起来就越像素化。
- en: 'Until now, our recipes have simply looped through all of the pixels in the
    `data` property and converted them with a simple algorithm, without paying much
    attention to which pixels are being updated. In this recipe, however, we''ll need
    to inspect sample pixels by looking at specific areas in the image based on x,y
    coordinates. We can use the following equations to pick out the RGBA components
    of a pixel based on the x, y coordinates:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的方法只是简单地循环遍历`data`属性中的所有像素，并用简单的算法转换它们，而没有太关注哪些像素正在被更新。然而，在这个方法中，我们需要通过查看基于x，y坐标的图像特定区域来检查样本像素。我们可以使用以下方程式根据x，y坐标来挑选出像素的RGBA分量：
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: With these equations in hand, we can use `setInterval()` to render a series
    of pixelated images over time, in which each successive pixelated image is less
    pixelated than the previous image, until the pixilation value equals 0 and the
    image is restored to its original state.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些方程，我们可以使用`setInterval()`在一段时间内渲染一系列像素化的图像，其中每个连续的像素化图像都比上一个图像少像素化，直到像素化值等于0，图像恢复到原始状态。
