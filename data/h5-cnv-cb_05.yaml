- en: Chapter 5. Bringing the Canvas to Life with Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。通过动画让画布活跃起来
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating an Animation class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个动画类
- en: Creating a linear motion
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建线性运动
- en: Creating an acceleration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建加速度
- en: Creating an oscillation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建振荡
- en: Oscillating a bubble
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 振荡气泡
- en: Swinging a pendulum
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆动钟摆
- en: Animating mechanical gears
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画机械齿轮
- en: Animating a clock
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画时钟
- en: Simulating particle physics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟粒子物理
- en: Creating microscopic life forms
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建微观生命形式
- en: Stressing the canvas and displaying the FPS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力测试画布并显示FPS
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the first half of this book, we covered the fundamental capabilities of the
    HTML5 canvas, including path drawing, shape drawing, working with images and video,
    and transformations. This chapter focuses on animation, which is not a part of
    the HTML5 canvas API. Although the API doesn't provide us with animation functionality,
    we can certainly create an Animation class that can be used to support animation
    projects. We'll cover the essential types of motion including linear motion, accelerations,
    and oscillations, and we'll use what we've learned to create some really awesome
    demos. Let's get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前半部分，我们介绍了HTML5画布的基本功能，包括路径绘制、形状绘制、图像和视频处理以及变换。本章重点介绍动画，这不是HTML5画布API的一部分。尽管API没有提供动画功能，但我们肯定可以创建一个动画类，用于支持动画项目。我们将涵盖基本的运动类型，包括线性运动、加速度和振荡，并利用所学知识创建一些真正令人惊叹的演示。让我们开始吧！
- en: Creating an Animation class
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个动画类
- en: As the HTML5 canvas API doesn't provide methods for animation, we'll have to
    create our own Animation class for handling an animation stage. This recipe will
    cover the basics of animation and provide an Animation class for all of our future
    animation projects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTML5画布API没有提供动画方法，我们必须为处理动画阶段创建自己的动画类。本教程将介绍动画的基础知识，并为我们未来的动画项目提供一个动画类。
- en: Getting ready...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了...
- en: As browsers and computer hardware are not created equally, it's important to
    understand that the optimal **FPS** (**Frames Per Second**) value for each animation
    varies depending on the browser, the computer's hardware, and the animation's
    algorithm. Therefore, it would be quite difficult for a developer to figure out
    what the best FPS value is for each user. Fortunately, browsers are now implementing
    a `requestAnimationFrame` method of the `window` object which can automatically
    determine the best FPS for animations (thank goodness). As we'll see later in
    this chapter, a typical FPS value for a smooth animation is somewhere between
    40 and 60 frames per second.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器和计算机硬件并非完全相同，因此重要的是要了解每个动画的最佳FPS（每秒帧数）值取决于浏览器、计算机硬件和动画算法。因此，开发人员很难弄清楚每个用户的最佳FPS值是多少。幸运的是，浏览器现在正在实现`window`对象的`requestAnimationFrame`方法，该方法可以自动确定动画的最佳FPS（谢天谢地）。正如我们将在本章后面看到的，流畅动画的典型FPS值在40到60帧之间。
- en: '![Getting ready...](img/1369_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![准备好了...](img/1369_05_01.jpg)'
- en: Take a look at the preceding diagram. To create an animation, we first need
    to initialize the objects on our stage. We can refer to the canvas as a "stage"
    because the objects in the canvas that will be moving can be seen as "actors"
    on the stage. Moreover, the stage analogy provides us with a sense that stuff
    is *happening* in the canvas, instead of just sitting there. Once our objects
    are initialized, we can start an animation loop that updates the stage, clears
    the canvas, redraws the stage, and then request a new animation frame.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的图表。要创建动画，我们首先需要初始化舞台上的对象。我们可以将画布称为“舞台”，因为画布上的移动对象可以看作是舞台上的“演员”。此外，舞台的类比使我们感到画布中的东西正在发生，而不仅仅是静静地坐在那里。一旦我们的对象初始化完成，我们就可以开始一个动画循环，更新舞台，清除画布，重绘舞台，然后请求一个新的动画帧。
- en: As this behavior can define any type of animation, it makes a lot of sense for
    us to create an Animation class that handles these steps for us under the covers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种行为可以定义任何类型的动画，所以我们创建一个处理这些步骤的动画类对我们来说是有意义的。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'Follow these steps to create an Animation class which will support the animation
    recipes in this chapter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个动画类，该类将支持本章的动画示例：
- en: 'Define the `Animation` constructor and create a cross-browser `requestAnimationFrame`
    method:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Animation`构造函数并创建一个跨浏览器的`requestAnimationFrame`方法：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define the `getContext()` method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getContext()`方法：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the `getCanvas()` method:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getCanvas()`方法：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define the `clear()` method which clears the canvas:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`clear()`方法，清除画布：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the `setStage()` method that sets the `stage()` function. This function
    will execute for each animation frame:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setStage()`方法，设置`stage()`函数。该函数将为每个动画帧执行：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the `isAnimating()` method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`isAnimating()`方法：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define the `getFrame()` method that returns the frame number:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getFrame()`方法，返回帧数：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the `start()` method that starts the animation:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`start()`方法，开始动画：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the `stop()` method that stops the animation:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stop()`方法，停止动画：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define the `getTimeInterval()` method that returns the time in milliseconds
    between the last frame and the current frame:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getTimeInterval()`方法，返回上一帧和当前帧之间的毫秒时间：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the `getTime()` method that returns the time in milliseconds that the
    animation has been running:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getTime()`方法，返回动画运行的毫秒时间：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the `getFps()` method that returns the current FPS of the animation:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getFps()`方法，返回动画的当前FPS：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `animationLoop()` method that handles the animation loop:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`animationLoop()`方法，处理动画循环：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The idea of the `Animation` class is to simplify our animation projects by encapsulating
    and hiding all of the logic that animations require, such as providing the time
    interval between frames, handling the animation loop, and clearing the canvas.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “Animation”类的思想是通过封装和隐藏动画所需的所有逻辑，简化我们的动画项目，例如提供帧之间的时间间隔，处理动画循环和清除画布。
- en: The key to the `Animation` class is inside the `Animation` constructor, where
    we set the `requestAnimFrame` method of the `window` object. This method acts
    as a cross-browser implementation of the `requestAnimationFrame`, which allows
    the user's browser to decide what the optimal FPS of the animation should be.
    The FPS is completely dynamic and will change throughout the animation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “Animation”类的关键在于“Animation”构造函数中，我们设置了“window”对象的“requestAnimFrame”方法。这个方法充当了“requestAnimationFrame”的跨浏览器实现，允许用户的浏览器决定动画的最佳FPS。FPS是完全动态的，并且会在整个动画过程中发生变化。
- en: Our `Animation` class also provides some handy methods such as `getTimeInterval()`,
    which returns the number of milliseconds since the last animation frame, the `getTime()`
    method which returns the number of milliseconds the animation has ran since it
    was started, a `start()` method which starts the animation, a `stop()` method
    which stops the animation, and a `clear()` method which clears the canvas.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Animation”类还提供了一些方便的方法，比如“getTimeInterval（）”，它返回自上一个动画帧以来的毫秒数，“getTime（）”方法返回动画自启动以来运行的毫秒数，“start（）”方法启动动画，“stop（）”方法停止动画，“clear（）”方法清除画布。
- en: Now that we have a working `Animation` class ready for prime time, the rest
    of the animations in this chapter, and your future animation projects as well,
    will be a piece of cake.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可以投入使用的“Animation”类，本章中的其余动画以及您未来的动画项目都将变得轻而易举。
- en: Creating a linear motion
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建线性运动
- en: 'In this recipe, we''ll try out our `Animation` class by creating a simple linear
    motion animation by moving a box from the left of the canvas to the right of the
    canvas:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过创建一个简单的线性运动动画来尝试我们的“Animation”类，将一个盒子从画布的左侧移动到右侧：
- en: '![Creating a linear motion](img/1369_05_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![创建线性运动](img/1369_05_02.jpg)'
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to move a box from one side of the canvas to the other:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将一个盒子从画布的一侧移动到另一侧：
- en: 'Link to the `Animation` class:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到“Animation”类：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instantiate an `Animation` object and get the canvas context:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个“Animation”对象并获取画布上下文：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the box''s linear speed and create a `box` object that contains the
    box''s position and size:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义盒子的线性速度并创建一个包含盒子位置和大小的“box”对象：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set the `stage()` function, which updates the box''s position, clears the canvas,
    and draws the box:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置“stage（）”函数，更新盒子的位置，清除画布并绘制盒子：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Start the animation:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作…
- en: To create a simple linear motion, first we need to instantiate a new `Animation`
    object, and then get the canvas and context. Next, we can define the speed of
    the box, which for this recipe we've set to 100 pixels / second, and we can create
    a `box` object that contains the box's position and size.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建简单的线性运动，首先我们需要实例化一个新的“Animation”对象，然后获取画布和上下文。接下来，我们可以定义盒子的速度，对于这个示例，我们将速度设置为每秒100像素，并且可以创建一个包含盒子位置和大小的“box”对象。
- en: Now that our box has been initialized, we can define the `stage()` function
    which will be executed within the animation loop. For each animation loop, we
    can update the position of the box by first calculating the distance that the
    box moved between the last frame and the current frame, and then update the box's
    x position by adding the distance that it travelled. Once the box reaches the
    edge of the canvas, we can stop the animation by calling `stop()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的盒子已经初始化，我们可以定义“stage（）”函数，该函数将在动画循环中执行。对于每个动画循环，我们可以通过首先计算盒子在上一帧和当前帧之间移动的距离，然后通过添加它移动的距离来更新盒子的x位置。一旦盒子到达画布的边缘，我们可以通过调用“stop（）”来停止动画。
- en: Finally, once the `stage()` function has been defined, we can start the animation
    with the `start()` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦“stage（）”函数被定义，我们可以使用“start（）”方法开始动画。
- en: See also...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅…
- en: '*Drawing a rectangle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and
    Composites")'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章。形状绘制和合成")中绘制一个矩形*'
- en: Creating acceleration
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建加速度
- en: Now that we have a handle on the basics of animation, let's try something a
    little bit more complex by accelerating a box downwards due to the force of gravity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了动画的基础知识，让我们尝试一些更复杂的东西，通过重力加速一个盒子向下移动。
- en: '![startAnimation() methodCreating acceleration](img/1369_05_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![startAnimation（）方法创建加速度](img/1369_05_03.jpg)'
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to draw a box at the top of the canvas which falls downward
    due to the force of gravity:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在画布顶部绘制一个盒子，由于重力的作用而向下移动：
- en: 'Link to the `Animation` class:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到“Animation”类：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instantiate an `Animation` object and get the canvas context:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个“Animation”对象并获取画布上下文：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define gravity and create a `box` object that contains the box''s position,
    x and y velocity, and size:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义重力并创建一个包含盒子位置、x和y速度以及大小的“box”对象：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Set the `stage()` function which updates the box, clears the canvas, and draws
    the box:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置“stage（）”函数，更新盒子，清除画布并绘制盒子：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Start the animation:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To create an acceleration, we can increment the velocity of the box, update
    the position of the box with the new velocity, clear the canvas, and then draw
    the box.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建加速度，我们可以增加盒子的速度，更新盒子的位置，清除画布，然后绘制盒子。
- en: 'We can calculate the new y velocity of the box for each frame by adding the
    change in velocity due to gravity, which is set to 2 pixels / second^2:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加由于重力引起的速度变化来计算盒子每帧的新y速度，这被设置为每秒2像素/秒^2：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we can calculate the new y position of the box by adding the distance
    that it travelled since the last frame:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过添加自上一帧以来移动的距离来计算框的新y位置：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In other words, the change in y position is equal to the box's velocity multiplied
    by the change in time (the time interval).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，y位置的变化等于框的速度乘以时间的变化（时间间隔）。
- en: Finally, we can add a condition that checks to see if the box has reached the
    bottom of the canvas, and if it has, we can then stop the animation with the `stop()`
    method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个条件来检查框是否已经到达画布的底部，如果是，我们可以使用`stop()`方法停止动画。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Accelerations are particularly useful when applying forces to an object or particle.
    Some examples of applied forces include gravity, air resistance, damping, floor
    friction, and electromagnetic forces. For really intensive animations that require
    a lot of physics, you might consider looking for an open source vector library
    to help handle velocities and accelerations in both the x and y direction.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当施加力到一个物体或粒子时，加速度特别有用。一些施加力的例子包括重力、空气阻力、阻尼、地板摩擦和电磁力。对于需要大量物理学的强烈动画，您可能考虑寻找一个开源矢量库，以帮助处理x和y方向的速度和加速度。
- en: See also...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a rectangle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and
    Composites")'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。形状绘制和复合")中绘制一个矩形
- en: Creating oscillation
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建振荡
- en: In this recipe, we'll explore the third major type of motion—oscillation. Some
    good examples of oscillations are a bouncing weight attached to a spring, an oscillating
    bubble, or a pendulum that swings back and forth.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨第三种主要类型的运动——振荡。一些振荡的好例子是挂在弹簧上的弹簧、振荡气泡或来回摆动的摆。
- en: '![Craccelerationworkingeating oscillation](img/1369_05_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![振荡气泡](img/1369_05_04.jpg)'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to oscillate a box back and forth:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来使框来回振荡：
- en: 'Link to the `Animation` class:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Animation`类：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Instantiate an `Animation` object and get the canvas context:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`Animation`对象并获取画布上下文：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a `box` object that contains the box''s position and size:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含框的位置和大小的`box`对象：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the parameters required for the harmonic oscillation equation:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义谐波振荡方程所需的参数：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Set the `stage()` function which updates the box''s position based on the harmonic
    oscillation equation, clears the canvas, and then draws the box:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，根据谐波振荡方程更新框的位置，清除画布，然后绘制框：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Start the animation:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Once the page loads, we can instantiate a new `Animation` object and then get
    the canvas and context.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，我们可以实例化一个新的`Animation`对象，然后获取画布和上下文。
- en: 'Next, we can create a `box` object which defines the box''s position and size,
    and then define the variables required for the equation of harmonic oscillation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个`box`对象，定义框的位置和大小，然后定义谐波振荡方程所需的变量：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For this recipe, we've set the amplitude `A` to `150`, the period `T` to `2`
    seconds, and the offset `x0` and the phase difference `Φ` to `0`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将振幅`A`设置为`150`，周期`T`设置为`2`秒，偏移`x0`和相位差`Φ`设置为`0`。
- en: For each animation frame, we can leverage the equation for harmonic oscillation
    to update the box's position, clear the canvas, and then draw the box using the
    `rect()` method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个动画帧，我们可以利用谐波振荡方程来更新框的位置，清除画布，然后使用`rect()`方法绘制框。
- en: Finally, we can start the animation using the `start()` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`start()`方法开始动画。
- en: See also...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a rectangle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and
    Composites")'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。形状绘制和复合")中绘制一个矩形
- en: Oscillating a bubble
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 振荡气泡
- en: In this recipe, we'll create a life-like oscillating bubble using the principles
    of harmonic oscillation and canvas transformations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用谐波振荡和画布变换的原理来创建一个逼真的振荡气泡。
- en: '![Oscillating a bubble](img/1369_05_05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![振荡气泡](img/1369_05_05.jpg)'
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a life-like oscillating bubble floating in the
    air:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个在空中漂浮的逼真的振荡气泡：
- en: 'Link to the `Animation` class:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Animation`类：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Instantiate an `Animation` object and get the canvas context:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`Animation`对象并获取画布上下文：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set the `stage()` function which updates the width and height scale of the
    bubble, clears the canvas, scales the canvas context, and then draws the bubble:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，更新气泡的宽度和高度比例，清除画布，缩放画布上下文，然后绘制气泡：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Start the animation:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入到HTML文档的主体中：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Before we talk about oscillating a bubble, it's a good idea to first cover how
    we can use canvas transformations to stretch the bubble in both the x and y direction.
    To draw a bubble that has been stretched horizontally, we can translate the context
    to the center of the canvas, scale the context horizontally, and then draw a bubble.
    To draw a bubble that has been stretched vertically, we can translate it to the
    center of the canvas, scale the context vertically, and then draw the bubble.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论振荡气泡之前，首先介绍如何使用画布变换来在x和y方向上拉伸气泡是一个好主意。要绘制水平拉伸的气泡，我们可以将上下文转换到画布的中心，水平缩放上下文，然后绘制气泡。要绘制垂直拉伸的气泡，我们可以将其转换到画布的中心，垂直缩放上下文，然后绘制气泡。
- en: In order to oscillate the bubble, we need to alternate which direction the canvas
    is scaled in such a way that the horizontal scale and the vertical scale always
    equals a constant, which in our case is 1.8, so that the volume of the bubble
    remains constant. Once this relationship is in place, we can use the equation
    of harmonic oscillation to oscillate both the x and y scale of the bubble.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使气泡振荡，我们需要交替改变画布的缩放方向，使水平缩放和垂直缩放始终等于一个常数，在我们的例子中是1.8，这样气泡的体积保持不变。一旦建立了这种关系，我们就可以使用谐波振荡方程来振荡气泡的x和y缩放。
- en: When the page first loads, we can instantiate a new `Animation` object and get
    the canvas and context. Next, we can set the `stage()` function which is responsible
    for updating the bubble, clearing the canvas, and then drawing the bubble for
    each animation frame. To update the bubble for each frame, we can calculate the
    horizontal and vertical scale of the bubble by using the equation of harmonic
    oscillation. Next, we can clear the canvas, and then draw the bubble using the
    `arc()` method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面首次加载时，我们可以实例化一个新的`Animation`对象并获取画布和上下文。接下来，我们可以设置`stage()`函数，负责更新气泡，清除画布，然后为每个动画帧绘制气泡。为了更新每一帧的气泡，我们可以使用谐波振荡方程来计算气泡的水平和垂直缩放。接下来，我们可以清除画布，然后使用`arc()`方法绘制气泡。
- en: Finally, once the `stage()` function has been set, we can start the animation
    with the `start()` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦`stage()`函数设置好，我们就可以用`start()`方法开始动画。
- en: See also...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章.形状绘制和组合")中绘制圆形*'
- en: '*Scaling the canvas context* in [Chapter 4](ch04.html "Chapter 4. Mastering
    Transformations")'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第4章](ch04.html "第4章.掌握变换")中缩放画布上下文*'
- en: '*Transforming a circle into an oval* in [Chapter 4](ch04.html "Chapter 4. Mastering
    Transformations")'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第4章](ch04.html "第4章.掌握变换")中将圆形变成椭圆*'
- en: Swinging a pendulum
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摆动钟摆
- en: Unlike the bubble recipe, whose width and height oscillate as a function of
    time, in this recipe we'll create a pendulum whose *angle* oscillates as a function
    of time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与气泡示例不同，这个示例中的钟摆的宽度和高度不随时间变化，而是钟摆的*角度*随时间变化。
- en: '![Swinging a pendulum](img/1369_05_06.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![摆动钟摆](img/1369_05_06.jpg)'
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to swing a pendulum back and forth:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来摆动钟摆：
- en: 'Link to the `Animation` class:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Animation`类：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Instantiate a new `Animation` object and get the canvas context:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的`Animation`对象并获取画布上下文：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the properties of the pendulum:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义钟摆的属性：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Set the `stage()` function which updates the angle of the pendulum, clears
    the canvas, and then draws the pendulum:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，更新钟摆的角度，清除画布，然后绘制钟摆：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Start the animation:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入HTML文档的主体中：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the page loads, we can instantiate a new `Animation` object and then get
    the canvas and context. Next, we can define the properties of our pendulum, including
    the angular amplitude, the period, the initial angle theta, the pendulum length,
    width, and the center of rotation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，我们可以实例化一个新的`Animation`对象，然后获取画布和上下文。接下来，我们可以定义钟摆的属性，包括角振幅、周期、初始角度θ、钟摆长度、宽度和旋转中心。
- en: Once our pendulum has been initialized, we can set the `stage()` function which
    will update the pendulum angle with the equation of harmonic oscillation, clear
    the canvas, and then immediately redraw the pendulum.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的钟摆初始化完成，我们可以设置`stage()`函数，它将使用谐波振荡方程更新钟摆角度，清除画布，然后立即重新绘制钟摆。
- en: We can create a pendulum by drawing a couple of circles at the rotation point,
    drawing a thick line from the rotation point to the weight of the pendulum to
    form the shaft, and then drawing a big circle at the end of the line that has
    a nice diagonal gray gradient to create the illusion of a polished surface.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在旋转点绘制一对圆圈，从旋转点到钟摆重物绘制粗线来形成轴，然后在线的末端绘制一个大圆圈，具有漂亮的对角灰色渐变，以营造抛光表面的 illusio。
- en: Once the `stage()` function has been set, we can start the animation with the
    `start()` method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`stage()`函数设置好，我们就可以用`start()`方法开始动画。
- en: See also...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a line* in [Chapter 1](ch01.html "Chapter 1. Getting Started withPaths
    and Text")'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第1章](ch01.html "第1章.开始使用路径和文本")中绘制直线*'
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章.形状绘制和组合")中绘制圆形*'
- en: '*Working with custom shapes and fill styles* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章.形状绘制和组合")中使用自定义形状和填充样式*'
- en: Animating mechanical gears
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画机械齿轮
- en: For the mechanics and engineers out there, this one's for you. In this recipe,
    we'll create a system of interconnected rotating gears.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些懂机械和工程的人，这个是给你们的。在这个示例中，我们将创建一个相互连接的旋转齿轮系统。
- en: '![Animating mechanical gears](img/1369_05_08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![动画机械齿轮](img/1369_05_08.jpg)'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to animate a system of interconnected gears:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来动画一个相互连接的齿轮系统：
- en: 'Link to the `Animation` class:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Animation`类：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define the constructor for the `Gear` class:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Gear`类的构造函数：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define the `draw` method of the `Gear` class which draws a `gear` object:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Gear`类的`draw`方法，绘制`gear`对象：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instantiate an `Animation` object and get the canvas context:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`Animation`对象并获取画布上下文：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Build an array of `gear` objects:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个`gear`对象的数组：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Set the `stage()` function which updates the rotation of each gear, clears
    the canvas, and then draws the gears:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，更新每个齿轮的旋转，清除画布，然后绘制齿轮：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Start the animation:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入HTML文档的主体中：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To create a system of rotating gears, we can reuse the gear drawing procedure
    from [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites") and create
    a `Gear` class that has some additional properties such as number of teeth, color,
    theta, and theta speed. `theta` defines the angular position of the gear and `thetaSpeed`
    defines the angular speed of the gear. We can also add a `clockwise` property
    to the `Gear` class that defines the direction of the gear rotation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个旋转齿轮系统，我们可以重用[第2章](ch02.html "第2章.形状绘制和组合")中的齿轮绘制过程，并创建一个`Gear`类，该类具有一些额外的属性，如齿数、颜色、θ和θ速度。`θ`定义了齿轮的角位置，`θSpeed`定义了齿轮的角速度。我们还可以在`Gear`类中添加一个`clockwise`属性，该属性定义了齿轮旋转的方向。
- en: Once the page loads, we can instantiate a new `Animation` object and get the
    canvas and context. Next, we can initialize some gears by instantiating `Gear`
    objects and pushing them onto the gears array. Now that our stage is initialized,
    we can set the `stage()` function which will update the angle of each gear, clear
    the canvas, and then draw each of the gears using the `draw()` method of the `Gear`
    class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，我们可以实例化一个新的`Animation`对象并获取画布和上下文。接下来，我们可以通过实例化`Gear`对象并将其推入齿轮数组来初始化一些齿轮。现在我们的舞台已经初始化，我们可以设置`stage()`函数，该函数将更新每个齿轮的角度，清除画布，然后使用`Gear`类的`draw()`方法绘制每个齿轮。
- en: Now that the `stage()` function has been set, we can start the animation with
    the `start()` method.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`stage()`函数已经设置好了，我们可以使用`start()`方法开始动画。
- en: See also...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制一个圆*在[第2章](ch02.html "第2章.形状绘制和组合")中'
- en: '*Creating patterns with loops: drawing a gear* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用循环创建图案：绘制齿轮*在[第2章](ch02.html "第2章.形状绘制和组合")中'
- en: Animating a clock
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时钟动画
- en: For those of you who slip into a trance when you're developing cool projects,
    where time seems to melt away, this one's for you. In this recipe, we'll create
    a nifty animated clock to remind us of the real-world time outside of cyber space.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些在开发酷炫项目时陷入恍惚状态，时间似乎消失的人，这个是给你的。在这个示例中，我们将创建一个漂亮的动画时钟，以提醒我们网络空间之外的真实世界时间。
- en: '![Animating a clock](img/1369_05_10.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![时钟动画](img/1369_05_10.jpg)'
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to animate the hour, minute, and second hands on a clock:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在时钟上动画时针、分针和秒针：
- en: 'Link to the `Animation` class:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Animation`类：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Instantiate an `Animation` object, get the canvas context, and define the clock
    radius:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`Animation`对象，获取画布上下文，并定义时钟半径：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Set the `stage()` function which gets the current time, calculates the angle
    for the hour hand, minute hand, and second hand, clears the canvas, and then draws
    the clock:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，该函数获取当前时间，计算时针、分针和秒针的角度，清除画布，然后绘制时钟：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Start the animation:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the page loads, we can instantiate a new `Animation` object and then get
    the canvas and context. Next, we can start defining the `stage()` function which
    is responsible for updating the clock, clearing the canvas, and then drawing the
    clock for each animation loop.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载时，我们可以实例化一个新的`Animation`对象，然后获取画布和上下文。接下来，我们可以开始定义`stage()`函数，该函数负责更新时钟、清除画布，然后为每个动画循环绘制时钟。
- en: In the update portion of the code, we can instantiate a new `Date()` object
    and then get the hours, minutes, and seconds. Next, we can adjust the hour and
    minute to represent a 12-hour time (AM and PM).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的更新部分，我们可以实例化一个新的`Date()`对象，然后获取小时、分钟和秒。接下来，我们可以调整小时和分钟，以表示12小时制时间（上午和下午）。
- en: 'After clearing the canvas, we can begin drawing the clock:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 清除画布后，我们可以开始绘制时钟：
- en: Translate the canvas context to the center of the canvas with the `translate()`
    method
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`translate()`方法将画布上下文转换到画布的中心
- en: Draw the body with the `arc()` method
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`arc()`方法绘制主体
- en: Create a loop that draws the numbers of the clock around the edge with the `fillText()`
    method
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个循环，使用`fillText()`方法在边缘绘制时钟的数字
- en: Apply a drop shadow with the `shadowOffsetX` and `shadowOffsetY` properties
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`shadowOffsetX`和`shadowOffsetY`属性应用阴影
- en: Draw the clock rim by stroking the circle with `stroke()`
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`stroke()`方法描绘时钟边缘
- en: Draw each of the clock hands by rotating the canvas context and then drawing
    a thin trapezoid whose thickest end resides at the center.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过旋转画布上下文并绘制一个最厚的梯形来绘制每个时钟指针，其最厚的一端位于中心。
- en: Finally, once the `stage()` function has been set, we can start the animation
    with the `start()` method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦`stage()`函数设置好了，我们就可以使用`start()`方法开始动画。
- en: See also...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Working with text* in [Chapter 1](ch01.html "Chapter 1. Getting Started withPaths
    and Text")'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用文本*在[第1章](ch01.html "第1章.路径和文本入门")'
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制一个圆*在[第2章](ch02.html "第2章.形状绘制和组合")中'
- en: '*Working with custom shapes and fill styles* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用自定义形状和填充样式*在[第2章](ch02.html "第2章.形状绘制和组合")中'
- en: Simulating particle physics
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟粒子物理学
- en: Now that we've covered the basics of classical physics, let's put it all together.
    In this recipe, we'll simulate particle physics by modeling gravity, boundary
    conditions, collision damping, and floor friction.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了古典物理学的基础知识，让我们把它们整合起来。在这个示例中，我们将通过模拟重力、边界条件、碰撞阻尼和地板摩擦来模拟粒子物理学。
- en: '![Simulating particle physics](img/1369_05_09.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![模拟粒子物理学](img/1369_05_09.jpg)'
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to launch a particle inside the canvas and observe it''s
    projectile path as it bounces on the walls, gradually falls down to the floor
    due to gravity, and then slows to a stop due to floor friction:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在画布内启动一个粒子，并观察它在墙上弹跳、逐渐因重力落到地板上，然后因地板摩擦而减速停止的弹道：
- en: 'Link to the `Animation` class:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Animation`类：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define the `applyPhysics()` function which takes a particle as input and updates
    its position and velocity based on physics variables such as gravity, collision
    damping, and floor friction:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`applyPhysics()`函数，它以粒子作为输入，并根据重力、碰撞阻尼和地板摩擦等物理变量更新其位置和速度：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Instantiate a new `Animation` object and get the canvas context:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的`Animation`对象并获取画布上下文：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Initialize a `particle` object with a position, x and y velocity, and radius:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置、x和y速度以及半径初始化一个`particle`对象：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Set the `stage()` function which updates the particle by passing it to the
    `applyPhysics()` function, clears the canvas, and then draws the particle:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，通过将其传递给`applyPhysics()`函数来更新粒子，清除画布，然后绘制粒子：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Start the animation:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE64]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body内嵌入画布标签：
- en: '[PRE65]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To simulate particle physics, we need to handle the particle's x and y position
    and the particle's velocity in both the x and y direction for each frame. The
    key to understanding particle physics simulations is to remember that the movement
    of the particle in the system is based on the sum of all the forces acting on
    the particle. In our case, gravity will be pulling the particle downwards, collisions
    against the walls, ceiling, and floor will reduce the particle's velocity according
    to the collision damper constant, and floor friction will reduce the particle's
    horizontal speed when it rolls on the floor.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟粒子物理学，我们需要处理每一帧粒子的x和y位置以及粒子在x和y方向的速度。理解粒子物理模拟的关键是要记住，粒子在系统中的运动是基于作用在粒子上的所有力的总和。在我们的情况下，重力将使粒子向下移动，与墙壁、天花板和地板的碰撞将根据碰撞阻尼常数减少粒子的速度，地板摩擦将在粒子在地板上滚动时减少其水平速度。
- en: To start off, when the page loads we can instantiate a new `Animation` object
    and then get the canvas and context. Next, we can initialize a particle with a
    position, initial velocity, and size. Now that we've initialized the actors on
    the stage (the particle), we can set the `stage()` function which will update
    the particle, clear the canvas, and then draw the particle for each animation
    frame.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当页面加载时，我们可以实例化一个新的`Animation`对象，然后获取画布和上下文。接下来，我们可以初始化一个具有位置、初始速度和大小的粒子。现在我们已经在舞台上初始化了演员（粒子），我们可以设置`stage()`函数，该函数将更新粒子，清除画布，然后为每个动画帧绘制粒子。
- en: The update logic happens inside the `applyPhysics()` function, which is passed
    a reference to the `Animation` object, and also the `particle` object. The `applyPhysics()`
    function walks through a list of conditions that updates the particle's position
    and velocity.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 更新逻辑发生在`applyPhysics()`函数内，该函数接收对`Animation`对象的引用，以及`particle`对象。`applyPhysics()`函数遍历一系列条件，更新粒子的位置和速度。
- en: After the `applyPhysics()` function has been called and the particle has been
    updated, we can clear the canvas and then draw the particle by drawing a simple
    circle whose radius is equal to the radius of the particle.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`applyPhysics()`函数并更新粒子后，我们可以清除画布，然后通过绘制一个简单的圆来绘制粒子，其半径等于粒子的半径。
- en: Finally, once the `stage()` function has been set, we can start the animation
    with the `start()` method.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦`stage()`函数被设置，我们可以使用`start()`方法开始动画。
- en: There's more...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you really wanted to get fancy, you could even add additional forces such
    as air resistance. As a general rule of thumb, the more forces that you add to
    a particle simulation, the more life-like it becomes. You can play around with
    different initial positions and velocities to see different projectile paths.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想要变得花哨，甚至可以添加额外的力，比如空气阻力。作为一个经验法则，你添加到粒子模拟中的力越多，它就越像真实的生命。你可以尝试不同的初始位置和速度，看看不同的抛射路径。
- en: See also...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章。形状绘制和组合")中绘制一个圆形*'
- en: Creating microscopic life forms
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建微观生命形式
- en: Have you ever seen microscopic life forms in a microscope and observed how they
    wiggle around? This recipe is inspired by the alien-like world of micro-organisms.
    In this recipe, we'll create 100 random microbes and let them loose in the canvas.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾在显微镜中看到微生物，并观察它们如何摇摆？这个配方受到微生物的外星世界的启发。在这个配方中，我们将创建100个随机微生物，并让它们在画布上自由移动。
- en: '![Creating microscopic life forms](img/1369_05_11.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![创建微观生命形式](img/1369_05_11.jpg)'
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to create wiggling microbes moving inside the canvas:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在画布内创建摇摆的微生物：
- en: 'Link to the `Animation` class:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Animation`类：
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define the `getRandColor()` function that returns a random color:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getRandColor()`函数，返回一个随机颜色：
- en: '[PRE67]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define the `getRandTheta()` function that returns a random theta:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getRandTheta()`函数，返回一个随机角度：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define the `updateMicrobes()` function that updates `microbe` objects by adding
    a new head segment with a randomly generated angle to each microbe, and then removing
    the tail segment:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateMicrobes()`函数，通过为每个微生物添加一个新的头部段并生成随机角度，然后移除尾部段来更新`microbe`对象：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Define the `drawMicrobes()` function that draws all of the microbes:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawMicrobes()`函数来绘制所有的微生物：
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Instantiate an `Animation` object and get the canvas context:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`Animation`对象并获取画布上下文：
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Initialize 100 microbes:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化100个微生物：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Set the `stage()` function that updates the microbes by calling the `updateMicrobes()`
    function, clears the canvas, and then draws the microbes by calling the `drawMicrobes()`
    function:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，通过调用`updateMicrobes()`函数来更新微生物，清除画布，然后通过调用`drawMicrobes()`函数来绘制微生物：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Start the animation:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE74]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body内嵌入画布：
- en: '[PRE75]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To create a micro-organism, we can draw a series of connected segments to create
    a short snake-like creature. We can represent a micro-organism as an object containing
    a head position and an array of angles. These angles represent the angle between
    segments.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个微生物，我们可以绘制一系列连接的段，以创建一个类似蛇的短生物。我们可以将微生物表示为一个包含头部位置和角度数组的对象。这些角度表示段之间的角度。
- en: This recipe initializes 100 randomized micro-organisms and positions them in
    the center of the canvas. Our `stage()` function contains the `updateMicrobes()`
    and `drawMicrobes()` function.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例初始化了100个随机化的微生物，并将它们放在画布的中心。我们的`stage()`函数包含`updateMicrobes()`和`drawMicrobes()`函数。
- en: The `updateMicrobes()` function loops through all of the microbe objects, adds
    a new head segment, and removes the tail segment for each microbe. In this way,
    the segments of each microbe will wiggle as they move across the canvas. When
    the head of a microbe hits the edge of the canvas, its angle will be increased
    by 90 degrees so that it bounces back into the canvas area.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateMicrobes()`函数循环遍历所有微生物对象，为每个微生物添加一个新的头部段，并删除每个微生物的尾部段。这样，每个微生物的段在移动时会摆动。当微生物的头部碰到画布的边缘时，它的角度将增加90度，以便它反弹回画布区域。'
- en: The `drawMicrobes()` function loops through all of the `microbe` objects, positions
    the drawing cursor at the head for each microbe, and then draws 20 line segments
    according to the angle of each segment.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawMicrobes()`函数循环遍历所有`microbe`对象，将绘图光标定位在每个微生物的头部，然后根据每个段的角度绘制20条线段。'
- en: See also...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a spiral* in [Chapter 1](ch01.html "Chapter 1. Getting Started withPaths
    and Text")'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html“第1章。路径和文本入门”)中绘制螺旋
- en: '*Creating a drawing application* in [Chapter 6](ch06.html "Chapter 6. Interacting
    with the Canvas: Attaching Event Listeners to Shapes and Regions")'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html“第6章。与画布交互：将事件侦听器附加到形状和区域”)中创建一个绘图应用程序
- en: Stressing the canvas and displaying the FPS
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强调画布并显示FPS
- en: After seeing the last recipe, you might be thinking "Is there a limit to how
    many microbes we can animate?" The straightforward answer to this question is
    yes. As the 2D context of the HTML5 canvas is not hardware-accelerated, and as
    our animations are driven purely by JavaScript, there is definitely a point where
    the browser will start to choke if it's working overtime. To illustrate this,
    we can draw the FPS of our animation and observe the relationship between the
    number of microbes on the screen and the FPS value.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到上一个示例之后，你可能会想“我们可以动画化多少微生物？”这个问题的直接答案是肯定的。由于HTML5画布的2D上下文不是硬件加速的，而且我们的动画纯粹由JavaScript驱动，所以肯定有一个点，当浏览器加班工作时，它会开始变得吃力。为了说明这一点，我们可以绘制我们动画的FPS，并观察屏幕上微生物数量与FPS值之间的关系。
- en: '![Stressing the canvas and displaying the FPS](img/1369_05_12.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![强调画布并显示FPS](img/1369_05_12.jpg)'
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to stress the canvas and display the FPS:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来强调画布并显示FPS：
- en: 'Link to the `Animation` class:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Animation`类：
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Define the `drawFps()` function that draws the FPS value in the top-right corner
    of the canvas:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawFps()`函数，在画布的右上角绘制FPS值：
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Define the `getRandColor()` function that returns a random color:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getRandColor()`函数，返回一个随机颜色：
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Define the `getRandTheta()` function that returns a random theta:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getRandTheta()`函数，返回一个随机的θ：
- en: '[PRE79]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define the `updateMicrobes()` function that updates `microbe` objects by adding
    a new head segment with a randomly generated angle to each microbe and then removing
    the tail segment:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateMicrobes()`函数，通过为每个微生物添加一个具有随机生成角度的新头部段来更新`microbe`对象，然后删除尾部段：
- en: '[PRE80]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Define the `drawMicrobes()` function that draws all of the microbes:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawMicrobes()`函数，绘制所有的微生物：
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Instantiate an `Animation` object and get the canvas context:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`Animation`对象并获取画布上下文：
- en: '[PRE82]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Initialize 1,500 microbes:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化1,500个微生物：
- en: '[PRE83]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Set the `stage()` function which updates the microbes, updates the FPS value
    every 10 frames, clears the canvas, and then draws the microbes and the FPS value:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，该函数更新微生物，每10帧更新一次FPS值，清除画布，然后绘制微生物和FPS值：
- en: '[PRE84]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Start the animation:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始动画：
- en: '[PRE85]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE86]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw the FPS of the animation, we can create the `drawFps()` function that
    takes in an FPS value as input, draws a black box in the upper-right corner of
    the canvas, and then writes out the FPS value. To avoid updating the FPS too frequently,
    we can store a copy of the FPS value in the variable `FPS`, and update it every
    10 frames. In this way, the FPS will update, at the most, six times per second.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制动画的FPS，我们可以创建`drawFps()`函数，该函数以FPS值作为输入，绘制画布右上角的黑色框，然后写出FPS值。为了避免过于频繁地更新FPS，我们可以将FPS值的副本存储在变量`FPS`中，并在每10帧更新一次。这样，FPS最多每秒更新6次。
- en: To stress the canvas, we can simply initialize more microbes. In this recipe,
    we've initialized 1,500 microbes. If you try out the code for yourself, you can
    play with different numbers to see how the FPS is affected.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调画布，我们可以简单地初始化更多的微生物。在这个示例中，我们初始化了1,500个微生物。如果你自己尝试这段代码，你可以尝试不同的数字，看看FPS如何受到影响。
- en: There's more...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As mentioned earlier, a typical animation should run at about 40 to 60 FPS.
    If the FPS drops below 30, you'll start to notice a slight lag in the animation.
    When testing in Google Chrome on a 32-bit Windows 7 machine with a 2.2 GHz AMD
    processor and 2 GB of RAM (yes I know, I need to upgrade), I was seeing about
    5 FPS when animating 1,500 microbes. It doesn't look bad, but it's not great.
    When animating 2,000 microbes or more, the animation starts to look unacceptably
    choppy.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，典型的动画应该以大约40到60 FPS运行。如果FPS低于30，你会开始注意到动画有轻微的延迟。在32位Windows 7机器上使用Google
    Chrome进行测试，配备2.2 GHz AMD处理器和2 GB RAM（是的，我知道，我需要升级），当我在动画1,500个微生物时，我看到大约5 FPS。看起来不错，但也不是很好。当动画2,000个或更多的微生物时，动画开始看起来不可接受地卡顿。
- en: Almost all of the animations that we've created with the 2D context perform
    great on desktops and laptops. However, if you find yourself in a situation where
    your animations are computationally expensive enough that they aren't performing
    well in the 2D context, you might consider using WebGL instead (we'll cover WebGL
    in [Chapter 9](ch09.html "Chapter 9. Introducing WebGL"), *Introduction to WebGL*).
    Unlike the 2D context, WebGL leverages hardware acceleration. At the time of writing,
    the 2D context in all of the major browsers does not utilize hardware acceleration.
    Using WebGL does come at a cost, however, because it's much more difficult to
    develop and maintain WebGL animations than it is to create 2D context animations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用2D上下文创建的几乎所有动画在台式机和笔记本电脑上表现良好。然而，如果您发现自己处于一个情况，您的动画在2D上下文中的计算开销足够大，以至于表现不佳，您可能会考虑改用WebGL（我们将在[第9章](ch09.html
    "第9章。介绍WebGL")中介绍WebGL，*WebGL简介*）。与2D上下文不同，WebGL利用硬件加速。在撰写本文时，所有主要浏览器中的2D上下文都不利用硬件加速。然而，使用WebGL确实会带来成本，因为开发和维护WebGL动画要比创建2D上下文动画困难得多。
- en: See also...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Working with text* in [Chapter 1](ch01.html "Chapter 1. Getting Started withPaths
    and Text")'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始使用路径和文本")中处理文本
- en: '*Drawing a spiral* in [Chapter 1](ch01.html "Chapter 1. Getting Started withPaths
    and Text")'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始使用路径和文本")中绘制螺旋线
- en: '*Creating a drawing application* in [Chapter 6](ch06.html "Chapter 6. Interacting
    with the Canvas: Attaching Event Listeners to Shapes and Regions")'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。与画布交互：将事件侦听器附加到形状和区域")中创建绘图应用程序
