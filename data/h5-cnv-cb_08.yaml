- en: Chapter 8. Saving the World with Game Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。用游戏开发拯救世界
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating sprite sheets for the hero and enemies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为英雄和敌人创建精灵表
- en: Creating level images and boundary maps
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建关卡图像和边界地图
- en: Creating an Actor class for the hero and enemies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为英雄和敌人创建一个Actor类
- en: Creating a Level class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个关卡类
- en: Creating a Health Bar class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个生命条类
- en: Creating a Controller class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个控制器类
- en: Creating a Model class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模型类
- en: Creating a View class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个View类
- en: Setting up the HTML document and starting the game
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置HTML文档并开始游戏
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'I wouldn''t be surprised if some of you bought this book solely for this chapter—after
    all, what fun is it to master the HTML5 canvas without being able to create your
    own video games? Of all the chapters in this book, this chapter was by far my
    favorite (with the next chapter being a close second). We might not actually be
    able to save the world with game development, but it sure is fun to create our
    own virtual worlds and save those instead. In this chapter, we''re going to pull
    all of our new found knowledge together to create Canvas Hero, a side-scroller
    action game starring the Canvas Hero, who can run, jump, levitate, and punch through
    a futuristic world full of menacing bad guys. Here are some of the features of
    the game:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人仅仅因为这一章而购买了这本书，我一点也不会感到惊讶——毕竟，掌握HTML5画布而不能创建自己的视频游戏有什么乐趣呢？在这本书中的所有章节中，这一章无疑是我最喜欢的（下一章是紧随其后的）。我们可能实际上无法通过游戏开发拯救世界，但创建我们自己的虚拟世界并拯救它们确实很有趣。在这一章中，我们将把我们新学到的知识整合起来，创建Canvas
    Hero，一个以Canvas Hero为主角的横向卷轴动作游戏，他可以在一个充满邪恶坏人的未来世界中奔跑、跳跃、升空和出拳。以下是游戏的一些特点：
- en: The hero can run left, run right, jump, and punch to attack
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英雄可以向左跑，向右跑，跳跃和出拳攻击
- en: The level will look futuristic
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡将看起来很未来
- en: The level will be full of enemies running around looking for trouble
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡将充满四处奔跑寻找麻烦的敌人
- en: The level will have a foreground image that moves to the left and to the right
    as the player moves, and will also have a stationary background image to create
    depth
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡将有一个前景图像，随着玩家的移动而向左和向右移动，并且还将有一个静止的背景图像以创建深度
- en: The player can jump high enough to jump over bad guys and avoid getting punched
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家可以跳得足够高，以跳过坏人并避免被出拳
- en: When either the player or the enemies are hit, they will flash white to show
    that they have sustained damage
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家或敌人被击中时，它们会闪白色，以显示它们受到了伤害
- en: Gravity will act on the player at all times
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力将始终作用于玩家
- en: The player cannot fall through the floor, run through walls, or jump through
    the ceilin
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家不能穿过地板，穿过墙壁，或者跳过天花板
- en: Although the hero can jump very high, there will be strategically placed levitation
    pods throughout the level to give the player a vertical boost so that he can reach
    high-up platforms
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管英雄可以跳得很高，但关卡中会有策略性放置的升空舱，以给玩家垂直提升，使他能够到达高处的平台
- en: The game is over when the player's health drops to zero or if the player falls
    into a hole
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家的健康值降至零或玩家掉入洞中时，游戏结束
- en: The player wins the game when all of the bad guys have been defeated
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有坏人被打败时，玩家赢得游戏
- en: 'And here are a few screenshots to give you an idea of what the game will look
    like when we''re done:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些截图，让你了解游戏完成后会是什么样子：
- en: '![Introduction](img/1369_08_13.jpg)![Introduction](img/1369_08_01.jpg)![Introduction](img/1369_08_03.jpg)![Introduction](img/1369_08_11.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/1369_08_13.jpg)![介绍](img/1369_08_01.jpg)![介绍](img/1369_08_03.jpg)![介绍](img/1369_08_11.jpg)'
- en: The first two recipes of this chapter cover techniques for creating the sprite
    sheets for the hero and bad guys as well as the level image and boundary map image.
    The next three recipes cover steps for creating classes for the hero, bad guys,
    level, and health bar objects. Recipes after that cover the **MVC** (**model**,
    **view**, **controller**) architecture of the game, and the last recipe will cover
    the HTML markup. Let's get started!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前两个配方涵盖了为英雄和坏人创建精灵表以及关卡图像和边界地图图像的技术。接下来的三个配方涵盖了为英雄、坏人、关卡和生命条对象创建类的步骤。之后的配方涵盖了游戏的**MVC**（**模型**，**视图**，**控制器**）架构，最后一个配方将涵盖HTML标记。让我们开始吧！
- en: Creating sprite sheets for the heroes and enemies
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为英雄和敌人创建精灵表
- en: Sprite sheets are image files that contain snapshots of different motions for
    different players and enemies that will appear in the game. Sprite sheets are
    an alternative to working with dozens or hundreds of individual images which can
    impact the initial loading time and also become a nightmare for graphic artists
    to maintain. Canvas Hero contains a sprite sheet for the hero, a sprite sheet
    for the bad guys, and also a set of white sprite sheets used when either the hero
    or the bad guys sustain damage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵表是包含不同玩家和敌人不同动作的快照的图像文件。精灵表是与数十甚至数百个单独图像一起工作的替代方案，这些图像可能会影响初始加载时间，也会成为图形艺术家的噩梦。Canvas
    Hero包含一个英雄的精灵表，一个坏人的精灵表，以及当英雄或坏人受到伤害时使用的一组白色精灵表。
- en: Getting ready...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了...
- en: Before we get started, it's worth noting that even the most talented of game
    artists can spend more time creating game graphics than the time it takes to code
    a game, which is something that's often times overlooked. For Canvas Hero, we
    can make life easier for ourselves by downloading some sprites from my favorite
    sprite resource, [http://www.spriters-resource.com](http://www.spriters-resource.com),
    which is a free website containing a huge collection of sprite sheets and level
    images of classic old-school games.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，值得注意的是，即使是最有才华的游戏艺术家也可能花费比编写游戏代码更多的时间来创建游戏图形，这是经常被忽视的事情。对于Canvas Hero，我们可以通过从我最喜欢的精灵资源网站[http://www.spriters-resource.com](http://www.spriters-resource.com)下载一些精灵来简化我们的生活，这是一个包含大量经典老式游戏的精灵表和关卡图像的免费网站。
- en: How to do it
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Once we find suitable sprite sheets for the hero and the bad guys, we can crop
    out the sprites we need and then put together a sprite sheet using Adobe Photoshop,
    Gimp, or some other image editing software. Here''s the finished hero sprite sheet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了适合英雄和坏家伙的精灵表，我们可以裁剪出所需的精灵，然后使用Adobe Photoshop、Gimp或其他一些图像编辑软件制作精灵表。这是完成的英雄精灵表：
- en: '![How to do it](img/1369_08_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法](img/1369_08_04.jpg)'
- en: As you can see, the hero sprite sheet contains four motions, one for standing,
    one for jumping, one for running, and one for punching (from top to bottom). When
    creating a sprite sheet, it's important that all of the sprite images fit inside
    a defined sprite size. For Canvas Hero, each sprite image fits inside a square
    that's 144 x 144 px. We should also ensure that each sprite image is facing the
    same direction because we can programmatically flip these images horizontally
    when we want to render a sprite that's facing the other direction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，英雄的精灵表包含四种动作，站立、跳跃、奔跑和出拳（从上到下）。在创建精灵表时，重要的是所有精灵图像都适合于定义的精灵大小。对于Canvas
    Hero，每个精灵图像都适合于144 x 144像素的正方形。我们还应确保每个精灵图像面向同一方向，因为我们可以在需要渲染面向另一个方向的精灵时，在程序上水平翻转这些图像。
- en: 'Likewise, we can use this same process to create a sprite sheet for the bad
    guys as well:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以使用相同的过程为坏家伙创建精灵表：
- en: '![How to do it](img/1369_08_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法](img/1369_08_05.jpg)'
- en: You'll notice that the bad guy sprite sheet is much simpler than the hero sprite
    sheet, simply because their movements are limited to running around and fighting
    (they never stand still or jump). For consistency, we can make the bad guy sprites
    144 x 144 px as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到坏家伙的精灵表比英雄的精灵表简单得多，因为他们的动作局限于奔跑和战斗（他们从不站立或跳跃）。为了保持一致，我们也可以将坏家伙的精灵设为144
    x 144像素。
- en: Creating level images and boundary maps
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建级别图像和边界地图
- en: Now that we have sprite sheets for the hero and the bad guys, it's time to create
    a virtual world for them to live in. In Canvas Hero, our virtual world will be
    a single level that moves left and right as the player moves through it, which
    will contain walls, a ceiling, a floor, platforms, and holes. In this recipe,
    we'll go over the steps for making a level image as well as a boundary map image
    that graphically contains information about the bounds of the level and also identifies
    special zones with different colors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为英雄和坏家伙准备好了精灵表，是时候为他们创建一个虚拟世界了。在Canvas Hero中，我们的虚拟世界将是一个单一的级别，随着玩家的移动而向左右移动，其中包括墙壁、天花板、地板、平台和洞。在这个配方中，我们将介绍制作级别图像以及边界地图图像的步骤，这些图像以图形方式包含有关级别边界的信息，并用不同颜色标识特殊区域。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'To create the level image for Canvas Hero, we can use some prebuilt graphics
    downloaded from [http://www.spriters-resource.com](http://www.spriters-resource.com)
    and add in new platforms, holes, and levitators using Photoshop, Gimp, or some
    other image editor of your choice. To keep the level somewhat small in size, we
    can create a foreground level image that''s 6944 x 600 px. The canvas, which is
    900 x 600 px, will act as a viewing window to the level. Here''s a snapshot of
    a portion of the level which contains a transparent foreground and a couple of
    levitator pods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Canvas Hero创建级别图像，我们可以使用从[http://www.spriters-resource.com](http://www.spriters-resource.com)下载的一些预先构建的图形，并使用Photoshop、Gimp或您选择的其他图像编辑器添加新的平台、洞和悬浮器。为了保持级别的大小适中，我们可以创建一个6944
    x 600像素的前景级别图像。900 x 600像素的画布将作为级别的查看窗口。这是包含透明前景和几个悬浮器的级别部分的快照：
- en: '![How to do it...](img/1369_08_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](img/1369_08_06.jpg)'
- en: 'Next, we can create a background image to create the illusion of depth. Here''s
    the finished background image for Canvas Hero:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个背景图像，以营造深度的错觉。这是Canvas Hero的完成背景图像：
- en: '![How to do it...](img/1369_08_07.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](img/1369_08_07.jpg)'
- en: 'And here''s how the foreground and background images look together:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前景和背景图像在一起的样子：
- en: '![How to do it...](img/1369_08_08.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](img/1369_08_08.jpg)'
- en: Once we have the foreground and background images completed, our next step is
    to create a boundary map. A boundary map is a graphical way to bound the player
    inside certain areas and also define special zones.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了前景和背景图像，我们的下一步是创建边界地图。边界地图是一种图形方式，用于将玩家限制在某些区域内，并定义特殊区域。
- en: 'To create the boundary map for Canvas Hero, we can start with a black background
    juxtaposed on top of the level image, and then draw magenta rectangles where the
    actors can run freely, and also add cyan rectangles to represent levitation zones.
    Keeping the background image a solid color helps reduce the boundary map image
    size and cuts down on the image loading time. The following image is a section
    of the boundary map that corresponds to the preceding image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Canvas Hero创建边界地图，我们可以从黑色背景开始，将其与级别图像叠加在一起，然后在演员可以自由奔跑的地方绘制品红色矩形，并添加青色矩形来表示悬浮区域。保持背景图像为纯色有助于减小边界地图图像的大小，并减少图像加载时间。以下图像是与前面图像对应的边界地图的一部分：
- en: '![How to do it...](img/1369_08_10.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](img/1369_08_10.jpg)'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To better understand how boundary maps work, let''s walk through the player''s
    steps as he navigates through the preceding screen from left to right. Also keep
    in mind that the player''s x ,y position is in the center of the sprite image
    which is about level with the hero''s hip:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解边界地图的工作原理，让我们走一遍玩家在从左到右穿过前面屏幕时的步骤。还要记住，玩家的x，y位置位于精灵图像的中心，大约与英雄的臀部齐平：
- en: Starting from the left, notice that the magenta portion, RGB (255, 0, 255),
    of the boundary map is extremely thin (only about 10 px or so). This region corresponds
    to the small space that the player can reside beneath the low hanging ceiling
    above his head. If the player were to jump while in this region, his vertical
    ascent would be prevented.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从左边开始，注意品红色部分，RGB（255,0,255），边界地图非常薄（大约只有10像素左右）。这个区域对应于玩家可以在低悬的天花板上方的小空间内驻留。如果玩家在这个区域跳跃，他的垂直上升将被阻止。
- en: Once the hero walks past the low hanging ceiling, he'll come up to a levitation
    pod. Notice that there is plenty of vertical magenta space for him to jump upwards
    and into the levitation zone, which is cyan, RGB (0, 255, 255).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦英雄走过低悬的天花板，他就会来到一个升空舱。请注意，有足够的垂直品红色空间供他向上跳跃并进入青色的升空区域，RGB（0,255,255）。
- en: Once the player is inside of a cyan zone, he'll begin to float upwards until
    he can reach the platform in the middle of the screen.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦玩家进入青色区域，他就会开始向上飘，直到他能到达屏幕中间的平台。
- en: When the player is on the platform, the ceiling is right above his head which
    prevents him from jumping.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家站在平台上时，天花板就在他的头上，这阻止了他跳跃。
- en: The player can continue walking to the right and then fall off the platform
    towards the ground.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家可以继续向右走，然后从平台上掉下来。
- en: Once on the ground, the player can jump into a second levitation zone identified
    by the cyan rectangle, which boosts him up onto the next platform.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦着陆，玩家可以跳入由青色矩形标识的第二个升空区域，这将使他跳到下一个平台上。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's more to it!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多内容！
- en: Boundary map alternative
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界地图替代方案
- en: If you'd rather not use a boundary map to define the level boundaries, you might
    consider constructing a large array of boundary points that define zones in space
    where the player can reside. The downside of this approach is that as the levels
    become large and complex, maintenance of the array can be quite time consuming.
    Additionally, this method can incur a significant performance overhead by constantly
    looping through the array and performing boundary calculations for each animation
    frame.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用边界地图来定义级别边界，您可以考虑构建一个大的边界点数组，该数组定义了玩家可以驻留的空间区域。这种方法的缺点是，随着级别变得越来越大和复杂，数组的维护可能非常耗时。此外，这种方法可能会产生显着的性能开销，因为不断循环遍历数组并为每个动画帧执行边界计算。
- en: Level image alternatives
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级别图像替代方案
- en: 'To keep this chapter as simple as possible, we chose to create the level with
    one large image. This image, unfortunately, is the main bottleneck when loading
    the game. Although the other images are small in size, including the boundary
    map, the level image is about 1.6 MB and can take a few seconds to load. If your
    levels are large, or you''re simply trying to make the game load as fast as possible,
    you might consider one of these alternatives:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章尽可能简单，我们选择使用一个大图像创建级别。不幸的是，这个图像在加载游戏时是主要的瓶颈。尽管其他图像尺寸较小，包括边界地图，但级别图像约为1.6
    MB，可能需要几秒钟才能加载。如果您的级别很大，或者您只是想尽快加载游戏，您可能会考虑以下替代方案：
- en: '**Lazy Loader**—A lazy loader will request sections of the level based on the
    player''s location such that only the visible and surrounding blocks of a level
    are downloaded rather than downloading the entire level image at once. The upside
    of this approach is an improved initial loading time, and the downside of this
    approach is that you have to programmatically manage which sections of the level
    are downloaded at which times.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒加载器** - 懒加载器将根据玩家的位置请求级别的各个部分，因此只有可见的和周围的级别块被下载，而不是一次性下载整个级别图像。这种方法的好处是改进了初始加载时间，缺点是您必须以编程方式管理何时下载级别的哪些部分。'
- en: '**Tiled Layout**—A tiled layout is a level that''s constructed from tile images.
    In other words, you could create small tiled images (say 30 x 30 px) that make
    up the textures for the floor, the walls, the ceilings, the levitator pods, and
    so on, and then use those images to build the level. The upside of this approach
    is that there''s virtually no loading time since the images are so small, and
    the downside is that the levels can start to look a litte redundant and uninteresting
    .'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平铺布局** - 平铺布局是由平铺图像构建的级别。换句话说，您可以创建小的平铺图像（例如30 x 30像素），用于构建地板、墙壁、天花板、升空舱等的纹理，然后使用这些图像来构建级别。这种方法的好处是几乎没有加载时间，因为图像非常小，缺点是级别可能开始看起来有点重复和乏味。'
- en: Creating an Actor class for the hero and enemies
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为英雄和敌人创建一个Actor类
- en: Now that we have all the main images set up and ready to go, it's time for the
    fun part (at least in my opinion) as we bring our virtual world to life with JavaScript
    and HTML5 canvas. Our first order of business is to create an Actor class which
    contains properties and methods for both the hero and the bad guys. In other words,
    both the hero and the bad guys will be instances of the Actor class. The Actor
    class will be responsible for directing the actors with methods such as `moveRight()`
    and `moveLeft()` , and is also responsible for rendering the actors by animating
    them with sprite sheets.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了所有的主要图像，准备好了，是时候进行有趣的部分了（至少在我看来），我们将使用JavaScript和HTML5画布为我们的虚拟世界注入生命。我们的首要任务是创建一个Actor类，其中包含英雄和坏人的属性和方法。换句话说，英雄和坏人都将是Actor类的实例。Actor类将负责使用诸如`moveRight()`和`moveLeft()`等方法指导演员，并负责通过使用精灵表对演员进行动画渲染。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create an Actor class which can be used to instantiate
    the hero or the bad guys:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个Actor类，该类可用于实例化英雄或坏人：
- en: 'Define the `Actor` constructor:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Actor`构造函数：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define the `attack()` method which triggers an attack:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`attack()`方法触发攻击：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the `stop()` method which stops the actor from moving:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stop()`方法停止演员移动：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define the `isFacingRight()` method:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`isFacingRight()`方法：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the `moveRight()` method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`moveRight()`方法：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the `moveLeft()` method:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`moveLeft()`方法：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define the `jump()` method which triggers the actor to jump:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`jump()`方法，触发角色跳跃：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the `draw()` method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`draw()`方法：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the `fade()` method which fades the actor when he''s defeated:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`fade()`方法，当角色被击败时淡出：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define the `updateSpriteMotion()` method:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateSpriteMotion()`方法：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the `updateSpriteSeqNum()` method which increments or resets the sprite
    sequence number for each sprite interval:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateSpriteSeqNum()`方法，递增或重置每个精灵间隔的精灵序列号：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the `damage()` method which decrements the actor''s health and sets
    the sprite sheet to the hit sprite sheet, causing the actor to flash white for
    a brief moment:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`damage()`方法，减少角色的健康值，并将精灵表设置为被击中的精灵表，导致角色在短暂的时间内闪烁白色：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `getCenter()` method which returns the position of the center of
    the actor:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getCenter()`方法，返回角色中心的位置：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The idea of the `Actor` class is to create a class that can be used to instantiate
    both the hero and the bad guys. It includes methods for controlling the actor,
    such as `moveRight()`, `moveLeft()`, `jump()`, and `attack()`, that either the
    game engine can call or a human player can call. The game engine will use these
    methods to control the bad guys, and a human player will use these methods to
    control the hero by pressing keys on the keyboard.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Actor`类的想法是创建一个可以用于实例化英雄和坏人的类。它包括控制角色的方法，如`moveRight()`、`moveLeft()`、`jump()`和`attack()`，游戏引擎或人类玩家可以调用。游戏引擎将使用这些方法来控制坏人，人类玩家将使用这些方法通过键盘按键来控制英雄。'
- en: In addition to controls, the `Actor` class also manages the sprite animation
    by updating the sprite motion with the `updateSpriteMotion()` method and also
    increments or cycles the sprite sequence number with the `updateSpriteSeqNum()`
    method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了控件，`Actor`类还通过`updateSpriteMotion()`方法更新精灵动画，并通过`updateSpriteSeqNum()`方法递增或循环精灵序列号。
- en: Finally, the `draw()` method picks out the sprite image corresponding to the
    actor's motion, flips the image horizontally if the actor is facing to the right,
    and then draws the actor on the screen using the `drawImage()` method of the canvas
    context.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`draw()`方法挑选出与角色动作对应的精灵图像，如果角色面向右侧，则水平翻转图像，然后使用画布上下文的`drawImage()`方法在屏幕上绘制角色。
- en: See also...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Cropping an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html "第3章。处理图像和视频")中裁剪图像*'
- en: '*Translating the canvas context* in [Chapter 4](ch04.html "Chapter 4. Mastering
    Transformations")'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第4章](ch04.html "第4章。掌握变换")中翻译画布上下文*'
- en: '*Creating a mirror transform* in [Chapter 4](ch04.html "Chapter 4. Mastering
    Transformations")'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第4章](ch04.html "第4章。掌握变换")中创建镜像变换*'
- en: Creating a Level class
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Level类
- en: In this recipe, we'll create a Level class which will be used to render the
    level and provide an API to the bundary map.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个Level类，用于渲染关卡并提供对边界地图的API。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a Level class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个Level类：
- en: 'Define the `Level` constructor:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Level`构造函数：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the `setBoundsData()` method which extracts the zone data from the boundary
    map image:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setBoundsData()`方法，从边界地图图像中提取区域数据：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the `draw()` method which draws the background image and the level image:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`draw()`方法，绘制背景图像和关卡图像：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the `getZoneInfo()` method which returns zone information about a point
    in the boundary map:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getZoneInfo()`方法，返回边界地图中某一点的区域信息：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most of the heavy lifting in the `Level` class is done in the `setBoundsData()`
    method and the `getZoneInfo()` method. The `setBoundsData()` method takes the
    boundary map image and converts it into an array of pixel data using the `getImageData()`
    method of the canvas context. The `getZoneInfo()` method is used to access a point
    in the boundary map and then return the corresponding zone information.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Level`类中的大部分工作是在`setBoundsData()`方法和`getZoneInfo()`方法中完成的。`setBoundsData()`方法将边界地图图像转换为像素数据数组，使用画布上下文的`getImageData()`方法。`getZoneInfo()`方法用于访问边界地图中的点，然后返回相应的区域信息。'
- en: 'For Canvas Hero, the zone information object contains two flags: `inBounds`
    and `levitating`. If the corresponding pixel in the boundary map is cyan, then
    this point corresponds to a zone that''s in bounds and is also inside a levitation
    zone. If the corresponding pixel in the boundary map is magenta, then this point
    corresponds to a zone that''s in bounds but not in a levitation zone. Finally,
    if the corresponding pixel in the boundary map is black, this means that the point
    is not in bounds or in a levitation zone.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Canvas Hero，区域信息对象包含两个标志：`inBounds`和`levitating`。如果边界地图中对应的像素为青色，则该点对应于一个在边界内且也在悬浮区域内的区域。如果边界地图中对应的像素为品红色，则该点对应于一个在边界内但不在悬浮区域内的区域。最后，如果边界地图中对应的像素为黑色，则意味着该点不在边界内或悬浮区域内。
- en: See also...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html "第3章。处理图像和视频")中绘制图像*'
- en: '*Getting image data* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html "第3章。处理图像和视频")中获取图像数据*'
- en: Creating a Health Bar class
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Health Bar类
- en: In this recipe, we'll create a Health Bar class which is used to update and
    render the hero's health display.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个Health Bar类，用于更新和渲染英雄的健康显示。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a health bar class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个健康条类：
- en: 'Define the `HealthBar` constructor:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`HealthBar`构造函数：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define the `setHealth()` method which sets the health value:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setHealth()`方法，设置健康值：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the `draw()` method which draws the health bar:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`draw()`方法，绘制健康条：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `HealthBar` object has a simple constructor that initializes the position
    and size of the health bar, and it also contains two methods, `setHealth()` and
    `draw()`. The `setHealth()` method sets the `health` property of the `HealthBar`
    object, and the `draw()` method draws the health bar using the `rect()` method
    of the canvas context.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`HealthBar`对象有一个简单的构造函数，初始化了血条的位置和大小，并包含两个方法，`setHealth()`和`draw()`。`setHealth()`方法设置`HealthBar`对象的`health`属性，`draw()`方法使用画布上下文的`rect()`方法绘制血条。'
- en: Creating a Controller class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个控制器类
- en: Now that we have all of the images and classes for the objects in the game,
    our next order of business is to build the game engine. Canvas Hero is built with
    a standard MVC architecture, which separates the data, the presentation, and the
    control methods. In this recipe, we'll create a Controller class which is responsible
    for instantiating the model and view, initializing the game, controlling the game
    state, and managing keyboard events.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有游戏中对象的所有图像和类，我们下一个任务是构建游戏引擎。Canvas Hero采用标准的MVC架构构建，将数据、呈现和控制方法分离。在这个示例中，我们将创建一个控制器类，负责实例化模型和视图，初始化游戏，控制游戏状态和管理键盘事件。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create the controller for Canvas Hero:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为Canvas Hero创建控制器：
- en: 'Define the `Controller` constructor:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Controller`构造函数：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the `loadImages()` method which loads all of the game images and then
    calls `initGame()` when they''ve all loaded:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`loadImages()`方法，加载所有游戏图像，然后在它们全部加载完毕时调用`initGame()`：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the `addKeyboardListeners()` method which attaches keyboard event listeners
    to the game:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`addKeyboardListeners()`方法，将键盘事件监听器附加到游戏上：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the `handleKeyUp()` method which is fired when a key is released:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`handleKeyUp()`方法，当释放键时触发：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the `handleKeyDown()` method which is fired when a key is pressed down:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`handleKeyDown()`方法，当按键按下时触发：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define the `initGame()` method which initializes the game:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initGame()`方法，初始化游戏：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define the `resetGame()` method which resets the game by reinitializing the
    game objects:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`resetGame()`方法，通过重新初始化游戏对象重置游戏：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The most important role of a game controller is to control the flow of the game
    through game states. In Canvas Hero, the first game state is the loading state.
    This is the state where the player can read about how to play the game as the
    game loads. Once the game has finished loading, the controller is responsible
    for changing the game state to the ready state. While in this state, the game
    waits for the user to press enter to continue. Once the user presses enter, the
    controller now changes the game state to the play game state.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏控制器最重要的作用是通过游戏状态控制游戏的流程。在Canvas Hero中，第一个游戏状态是加载状态。这是玩家可以在游戏加载时阅读游戏玩法的状态。一旦游戏加载完成，控制器负责将游戏状态更改为准备状态。在这个状态下，游戏等待用户按Enter键继续。一旦用户按下Enter键，控制器现在将游戏状态更改为游戏状态。
- en: 'At this moment, the actual game begins and the user has full control over the
    hero. If the player''s health drops to zero, or if the player falls into a hole,
    the controller will change the game state to the game over state. If, on the other
    hand, the player succeeds in defeating all of the enemies, the controller changes
    the game state to the win state, congratulating the hero on his awesome feat.
    Take a look at the following state machine:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此刻，实际游戏开始，用户完全控制英雄。如果玩家的健康值降到零，或者玩家掉入洞中，控制器将把游戏状态更改为游戏结束状态。另一方面，如果玩家成功击败所有敌人，控制器将把游戏状态更改为胜利状态，并祝贺英雄取得了惊人的成就。看一下以下状态机：
- en: '![How it works...](img/1369_08_02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1369_08_02.jpg)'
- en: In addition to controlling the game state, the controller is also responsible
    for managing keyboard events. The keyboard events are attached with the `addKeyboardListeners()`
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了控制游戏状态，控制器还负责管理键盘事件。键盘事件通过`addKeyboardListeners()`方法附加。
- en: Creating a Model class
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模型类
- en: In this recipe, we'll create a Model class which is responsible for initializing
    and updating the hero, the bad guys, the level, and the health bar. These objects
    can be seen as the "data" of our game.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个模型类，负责初始化和更新英雄、坏人、关卡和血条。这些对象可以被视为游戏的“数据”。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create the model for Canvas Hero:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为Canvas Hero创建模型：
- en: 'Define the `Model` constructor:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Model`构造函数：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the `removeDefeatedBadGuys()` method which loops through the bad guy
    array and then removes the ones that are no longer alive:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`removeDefeatedBadGuys()`方法，循环遍历坏人数组，然后移除已经死亡的坏人：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the `updateBadGuys()` method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateBadGuys()`方法：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the `updateStage()` method which updates all of the game objects for
    each animation frame:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateStage()`方法，更新每个动画帧的所有游戏对象：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define the `initHealthBar()` method which initializes the health bar:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initHealthBar()`方法，初始化血条：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define the `initLevel()` method which initializes the level:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initLevel()`方法，初始化关卡：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the `initHero()` method which initializes the hero:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initHero()`方法，初始化英雄：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the `initBadGuys()` method which initializes an array of bad guys:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initBadGuys()`方法，初始化一个坏人数组：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the `moveBadGuys()` method which serves as a simple AI engine:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`moveBadGuys()`方法，作为简单的AI引擎：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define the `updateLevel()` method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateLevel()`方法：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Define the `updateHeroCanvasPos()` method which updates the position of the
    hero relative to the canvas:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateHeroCanvasPos()`方法，更新英雄相对于画布的位置：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define the `updateActor()` method:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateActor()`方法：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define the `updateActorVY()` method which uses the downward force of gravity
    and the upward force of the levitation pods to update the vertical velocity of
    an actor:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateActorVY()`方法，使用重力的向下力和升力舱的向上力来更新角色的垂直速度：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the `updateActorY()` method which updates the y position of the actor
    based on his vertical velocity:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateActorY()`方法，根据角色的垂直速度更新角色的y位置：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define the `updateActorX()` method which updates the actor''s x position:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateActorX()`方法，更新角色的x位置：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the `nearby()` method which determines whether or not two actors are
    near each other:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`nearby()`方法，确定两个角色是否彼此靠近：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In an MVC architecture, the model is considered to be the "meat" of the architecture,
    because it represents the data layer. As Canvas Hero is a game, our data consists
    of the hero, bad guys, the level, and the health bar objects. Each of these objects
    contain properties which must be updated and accessed during each animation frame.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC架构中，模型被认为是架构的“核心”，因为它代表数据层。由于Canvas Hero是一个游戏，我们的数据包括英雄、坏家伙、级别和血条对象。这些对象中的每一个都包含必须在每个动画帧期间更新和访问的属性。
- en: 'The model for Canvas Hero has three key responsibilities:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas Hero的模型有三个关键责任：
- en: Initializing the game objects
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化游戏对象
- en: Updating the game objects
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新游戏对象
- en: Handling the bad guy AI
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理坏家伙的人工智能
- en: Quite arguably, the most interesting method in our model is the `moveBadGuys()`
    method. This method can be thought of as the "AI" for our game engine. I've put
    the "AI" in quotes because in all honesty, the bad guys in Canvas Hero are pretty
    dumb. The `moveBadGuys()` method loops through all of the bad guy objects, determines
    whether they are close to a wall using the `getZoneInfo()` method of the `Level`
    object, and then changes their direction if they're about to run into one.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模型中，可以说最有趣的方法是`moveBadGuys()`方法。这个方法可以被认为是我们游戏引擎的“人工智能”。我加了引号是因为说实话，在Canvas
    Hero中，坏家伙们相当愚蠢。`moveBadGuys()`方法循环遍历所有坏家伙对象，使用`Level`对象的`getZoneInfo()`方法确定它们是否靠近墙壁，然后在它们即将撞到墙壁时改变它们的方向。
- en: There's more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you're wanting to create a more challenging game, you might consider beefing
    up the `moveBadGuys()` method by giving the bad guys an ability to jump or even
    use the levitation pods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个更具挑战性的游戏，你可以考虑通过让坏家伙们具有跳跃或使用升空舱的能力来加强`moveBadGuys()`方法。
- en: See also...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。用动画让画布生动起来")中创建一个动画类*'
- en: Creating a View class
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个View类
- en: In this recipe, we'll create the View class, which is the simplest of the three
    MVC classes. The View class is responsible for drawing state screen images and
    also renders each animation frame by calling the `draw()` method for the level,
    each of the bad guys, the hero, and the health bar. In addition, the View class
    also renders a handy FPS display in the top-right cornerof the screen so we can
    see how well the game is performing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建View类，这是三个MVC类中最简单的一个。View类负责绘制状态屏幕图像，并通过调用`draw()`方法为每个级别、每个坏家伙、英雄和血条渲染每个动画帧。此外，View类还在屏幕右上角渲染一个方便的FPS显示，以便我们可以看到游戏的表现如何。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create the view for Canvas Hero:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为Canvas Hero创建视图：
- en: 'Define the `View` constructor:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`View`构造函数：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define the `drawScreen()` method which draws the loading, ready, game over,
    or win state screen:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawScreen()`方法，绘制加载、就绪、游戏结束或胜利状态屏幕：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define the `drawBadGuys()` method which draws the bad guys:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawBadGuys()`方法，绘制坏家伙们：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define the `drawFps()` method which draws the FPS value of the game in the
    top-right corner of the screen so that we can see how well the game is performing:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawFps()`方法，绘制游戏右上角的FPS值，以便我们可以看到游戏的表现如何：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define the `stage()` method which draws all of the objects on the screen:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stage()`方法，绘制屏幕上的所有对象：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As mentioned earlier, the main responsibility of the `View` class is to draw
    state screens and draw the game screen. Canvas Hero has four different state screens:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`View`类的主要责任是绘制状态屏幕和游戏屏幕。Canvas Hero有四个不同的状态屏幕：
- en: Loading state
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载状态
- en: Ready state
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就绪状态
- en: Game over state
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束状态
- en: Win state
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜利状态
- en: 'Whenever the game state changes and a state screen is neede, the controller
    calls the `drawScreen()` method of the `View` object. Here''s a screenshot for
    eac of the game state screens:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每当游戏状态改变并且需要状态屏幕时，控制器调用`View`对象的`drawScreen()`方法。以下是每个游戏状态屏幕的截图：
- en: 'Loading state:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 加载状态：
- en: '![How it works...](img/1369_08_12.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1369_08_12.jpg)'
- en: 'Ready state:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪状态：
- en: '![How it works...](img/1369_08_13.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1369_08_13.jpg)'
- en: 'Game over state:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束状态：
- en: '![How it works...](img/1369_08_14.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1369_08_14.jpg)'
- en: 'Win state:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利状态：
- en: '![How it works...](img/1369_08_15.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1369_08_15.jpg)'
- en: See also...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Stressing the canvas and displaying the FPS* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强调画布并显示FPS*在[第5章](ch05.html "第5章。用动画让画布生动起来")中'
- en: Setting up the HTML document and starting the game
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置HTML文档并开始游戏
- en: Now that we have all of the pieces for our game, including the graphics, the
    classes for the actors, the level, the health bar, and a completed game engine,
    it's time to tie it all together by setting up the HTML document and starting
    the game.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有游戏的所有部分，包括图形、角色类、级别、血条和一个完整的游戏引擎，是时候通过设置HTML文档并开始游戏来将它们全部联系在一起了。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to set up the HTML document and start the game:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置HTML文档并开始游戏：
- en: 'Link to the JavaScript files:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到JavaScript文件：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Initialize the controller:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化控制器：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入HTML文档的主体内：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, the HTML markup is quite simple. It's purpose is purely to link
    to required JavaScript files, embed the canvas tag, and initialize the controller.
    The controller initializes the model and the view. The model initializes the hero,
    the bad guys, the level, and the health bar. Once the images have loaded and the
    game state is changed to the ready state, the player presses the enter key and
    the game begins.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，HTML标记非常简单。它的目的纯粹是链接到所需的JavaScript文件，嵌入画布标记，并初始化控制器。控制器初始化模型和视图。模型初始化英雄、坏人、关卡和生命条。一旦图像加载完成，游戏状态改变为准备状态，玩家按下回车键游戏开始。
- en: There's more...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You're now ready to play the game and save the world! If you initialized the
    hero and the bad guys with a health of three units as defined in the model recipe,
    the hero can take up to three hits before game over, and each of the bad guys
    require three hits to be defeated. I've found that it's easiest to defeat the
    bad guys by jumping over them and repeatedly hitting them in the back until they're
    toast (cheap I know, but it works). It's also really fun to jump into the levitator
    pods and float in the air for a while, wait for just the right moment, and attack
    a bad guy from above like a ninja.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经准备好玩游戏并拯救世界了！如果您按照模型配方中定义的方式初始化了英雄和坏人的健康值为三个单位，那么英雄在游戏结束之前最多可以承受三次打击，每个坏人需要三次打击才能被击败。我发现最容易击败坏人的方法是跳过他们并反复击打他们的背部，直到他们被击败（我知道这很便宜，但它有效）。跳进升降舱并在空中飘浮一段时间，等待合适的时机，像忍者一样从上方袭击坏人也非常有趣。
- en: 'If you use this chapter as a foundation for your own side-scroller game, here
    are some other features that you might consider adding:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将本章作为自己的横向卷轴游戏的基础，这里有一些其他功能可以考虑添加：
- en: Sound effects for jumping, landing, and punching using the HTML5 audio tag
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5音频标记进行跳跃、着陆和拳击的音效
- en: Pause feature that freezes the game until it's resumed
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停功能，可以冻结游戏直到恢复
- en: Timer and top scores
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器和最高分
- en: More levels, enemies, and bosses
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关卡、敌人和boss
- en: Power-ups
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强道具
- en: An option to save the game state with HTML5 local storage or by saving the state
    in an online database
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5本地存储保存游戏状态或通过在在线数据库中保存状态的选项
- en: Anything else you can imagine
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以想象的其他任何东西
- en: See also...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。使用动画让画布生动起来")中创建一个动画类*'
