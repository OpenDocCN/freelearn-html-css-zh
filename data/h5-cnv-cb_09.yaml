- en: Chapter 9. Introducing WebGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。介绍WebGL
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a WebGL wrapper to simplify the WebGL API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简化WebGL API的WebGL包装器
- en: Creating a triangular plane
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个三角形平面
- en: Rotating a triangular plane in 3D space
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3D空间中旋转一个三角形平面
- en: Creating a rotating cube
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个旋转的立方体
- en: Adding textures and lighting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加纹理和光照
- en: Creating a 3D world that you can explore
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可以探索的3D世界
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Originally, when I first started writing this book, I had intended on only covering
    the 2D context of the HTML5 canvas (I strongly believe that most people who use
    canvas will be working with this context). I had also originally intended on covering
    techniques for rendering 3D shapes in the 2D context using 3D projection methods
    and vector operations. People were already busy creating some pretty incredible
    3D JavaScript libraries for the 2D context, including Kevin Roast's K3D library
    (one of the reviewers of this book), and also Dean McNamee's Pre3d library.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，当我开始写这本书时，我原本打算只涵盖HTML5画布的2D上下文（我坚信大多数使用画布的人都会使用这个上下文）。我也原本打算覆盖在2D上下文中使用3D投影方法和矢量运算渲染3D形状的技术。人们已经忙着为2D上下文创建一些非常令人难以置信的3D
    JavaScript库，包括Kevin Roast的K3D库（本书的审阅者之一），以及Dean McNamee的Pre3d库。
- en: As I neared writing this chapter, WebGL—a true 3D context—began to dominate
    3D canvas demos across the Web. WebGL stands for **Web-Based Graphics Library**,
    and it's based on OpenGL ES 2.0 which provides an API for 3D graphics. Because
    WebGL leverages hardware acceleration by pushing buffers directly onto the graphics
    card to render 3D models, it performs much better than its 2D context, 3D projection
    library counterparts. Moreover, it exposes years of work already done with OpenGL.
    As you've probably already figured out by now, I decided to cover WebGL instead
    of covering 3D projection libraries with the 2D context because I very much believe
    that WebGL will be the standard for 3D applications in the near future. WebGL
    is of particular interest for people who want to create 3D games or 3D models
    on the Web.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我接近写这一章时，WebGL——一个真正的3D上下文——开始在Web上主导3D画布演示。WebGL代表**基于Web的图形库**，它基于OpenGL
    ES 2.0，提供了一个用于3D图形的API。因为WebGL通过直接将缓冲区推送到图形卡上来渲染3D模型，利用硬件加速，它的性能要比2D上下文、3D投影库的对手好得多。此外，它还暴露了OpenGL已经完成的多年工作。正如你现在可能已经想到的那样，我决定覆盖WebGL，而不是覆盖2D上下文的3D投影库，因为我非常相信WebGL将成为不久的将来3D应用的标准。WebGL对于想要在Web上创建3D游戏或3D模型的人来说特别有趣。
- en: This chapter will get you started with the basics of WebGL by covering concepts
    such as buffers, shaders, perspective and model-view matrices, normals, textures,
    lighting, camera handling, and much more. Let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过涵盖缓冲区、着色器、透视和模型视图矩阵、法线、纹理、光照、摄像机处理等概念，让你开始学习WebGL的基础知识。让我们开始吧！
- en: Creating a WebGL wrapper to simplify the WebGL API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简化WebGL API的WebGL包装器
- en: If you've already looked ahead and peeked at the code for this recipe, and you're
    not very familiar with OpenGL or WebGL, you're probably feeling pretty overwhelmed,
    and for good reason. WebGL, although extremely powerful, has quite a steep learning
    curve when diving into it for the first time. Frankly speaking, it takes many
    lines of code to perform simple tasks. Therefore, I've found it extremely convenient
    to work with a WebGL wrapper that essentially shrink wraps blocks of tedious code
    into simple methods. This recipe provides steps for creating a simple WebGL wrapper
    that will be used for all of the recipes in this chapter. Let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经提前查看了这个食谱的代码，并且对OpenGL或WebGL不是很熟悉，你可能会感到非常不知所措，这是有充分理由的。尽管WebGL非常强大，但初次接触时学习曲线相当陡峭。坦率地说，执行简单任务需要很多行代码。因此，我发现使用WebGL包装器非常方便，它可以将繁琐的代码块简化为简单的方法。这个食谱提供了创建一个简单的WebGL包装器的步骤，这个包装器将用于本章的所有食谱。让我们开始吧！
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As the WebGL wrapper is quite complex, you might consider grabbing the WebGL
    wrapper code from the online resources for this book at [http://www.html5canvastutorials.com/cookbook/](http://www.html5canvastutorials.com/cookbook/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WebGL包装器相当复杂，你可能会考虑从本书的在线资源中获取WebGL包装器代码[http://www.html5canvastutorials.com/cookbook/](http://www.html5canvastutorials.com/cookbook)。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to create a WebGL wrapper object to simplify the WebGL API,
    or go to [http://www.html5canvastutorials.com/cookbook](http://www.html5canvastutorials.com/cookbook)
    and download `WebGL.js` from the resources section:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个WebGL包装器对象来简化WebGL API，或者转到[http://www.html5canvastutorials.com/cookbook](http://www.html5canvastutorials.com/cookbook)并从资源部分下载`WebGL.js`：
- en: 'Begin defining the WebGL constructor by initializing the canvas context and
    defining the animation properties:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始定义WebGL构造函数，初始化画布上下文并定义动画属性：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use *Paul Irish''s* `requestAnimFrame` shim to create a cross-browser `requestAnimationFrame`
    function which enables the browser to handle the FPS for our animations:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Paul Irish*的`requestAnimFrame` shim来创建一个跨浏览器的`requestAnimationFrame`函数，它使浏览器能够处理我们动画的FPS：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As *Brandon Jones''s* `glMatrix` uses global variables, we can encapsulate
    them so that the variables can''t be altered outside of the wrapper:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于*Brandon Jones*的`glMatrix`使用全局变量，我们可以封装它们，这样这些变量就不能在包装器外部被改变：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define shader type constants and initialize the model-view matrix, the perspective
    matrix, and the viewport dimensions:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义着色器类型常量并初始化模型视图矩阵、透视矩阵和视口尺寸：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Enable the depth test:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用深度测试：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define getter methods for the context and canvas attributes:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为上下文和画布属性定义getter方法：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define a `clear()` method which clears the WebGL viewport:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`clear()`方法，清除WebGL视口：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the `setStage()` method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setStage()`方法：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the `isAnimating()` method which returns whether or not the animation
    is running:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`isAnimating()`方法，返回动画是否正在运行：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define the `getFrame()` method which returns the current frame number:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getFrame()`方法，它返回当前帧数：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the `start()` method which starts the animation:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`start()`方法，开始动画：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the `stopAnimation()` method which stops the animation:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stopAnimation()`方法，用于停止动画：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `getTimeInterval()` method which returns the time in milliseconds
    that has passed since the last frame was rendered:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getTimeInterval()`方法，返回自上一帧渲染以来经过的毫秒数：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define the `getTime()` method which returns the number of milliseconds that
    have passed since the animation was started:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getTime()`方法，返回自动画开始以来经过的毫秒数：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the `getFps()` method which returns the current FPS value determined
    by the browser:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getFps()`方法，返回浏览器确定的当前FPS值：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the `animationLoop()` method which is responsible for updating the animation
    properties, drawing the stage, and requesting a new animation frame:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`animationLoop()`方法，负责更新动画属性、绘制舞台并请求新的动画帧：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the `save()` method which saves the model-view matrix state by pushing
    the current state onto the model-view matrix stack:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`save()`方法，通过将当前状态推送到模型视图矩阵堆栈上保存模型视图矩阵状态：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the `restore()` method which restores the previous model-view state:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`restore()`方法，恢复先前的模型视图状态：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define the `getFragmentShaderGLSL()` method which gets **GLSL** (**GL Shader
    Language**) fragment code based on the shader type argument. Essentially, this
    method contains four different stand alone GLSL fragment shader programs that
    are selected with a `case` statement:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getFragmentShaderGLSL()`方法，根据着色器类型参数获取**GLSL**（**GL Shader Language**）片段代码。本质上，该方法包含四种不同的独立GLSL片段着色器程序，通过`case`语句进行选择：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the `getVertexShaderGLSL()` method which gets GLSL vertex code based
    on the shader type argument:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getVertexShaderGLSL()`方法，根据着色器类型参数获取GLSL顶点代码：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define the `initShaders()` method which initializes the appropriate shaders
    based on the shader type argument:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initShaders()`方法，根据着色器类型参数初始化适当的着色器：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the `setShaderProgram()` method which sets the shader program based
    on the shader type argument:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setShaderProgram()`方法，根据着色器类型参数设置着色器程序：
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the `perspective()` method which wraps the glMatrix `perspective()`
    method that operates on the perspective matrix:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`perspective()`方法，包装了glMatrix的`perspective()`方法，用于操作透视矩阵：
- en: '[PRE22]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the `identity()` method which wraps the glMatrix `identity()` method
    that operates on the model-view matrix:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`identity()`方法，包装了glMatrix的`identity()`方法，用于操作模型视图矩阵：
- en: '[PRE23]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the `translate()` method which wraps the glMatrix `translate()` method
    that operates on the model-view matrix:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`translate()`方法，包装了glMatrix的`translate()`方法，用于操作模型视图矩阵：
- en: '[PRE24]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define the `rotate()` method which wraps the glMatrix `rotate()` method that
    operates on the model-view matrix:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`rotate()`方法，包装了glMatrix的`rotate()`方法，用于操作模型视图矩阵：
- en: '[PRE25]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define the `initPositionShader()` method which initializes the position shader
    to be used with position buffers:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initPositionShader()`方法，初始化用于位置缓冲的位置着色器：
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define the `initColorShader()` method which initializes the color shader to
    be used with color buffers:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initColorShader()`方法，初始化用于颜色缓冲的颜色着色器：
- en: '[PRE27]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the `initTextureShader()` method which initializes the texture shader
    to be used with texture buffers:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initTextureShader()`方法，初始化用于纹理缓冲的纹理着色器：
- en: '[PRE28]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the `initNormalShader()` method which initializes the normal shader
    to be used with normal buffers:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initNormalShader()`方法，初始化用于法线缓冲的法线着色器：
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the `initLightingShader()` method which initializes ambient and directional
    lighting shaders:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initLightingShader()`方法，初始化环境光和定向光照着色器：
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define the `initTexture()` method which wraps the WebGL API code necessary
    to initialize a WebGL texture object:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initTexture()`方法，包装了初始化WebGL纹理对象所需的WebGL API代码：
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define the `createArrayBuffer()` method which wraps the WebGL API code necessary
    to create an array buffer:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`createArrayBuffer()`方法，包装了创建数组缓冲所需的WebGL API代码：
- en: '[PRE32]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the `createElementArrayBuffer()` method which wraps the WebGL API code
    necessary to create an element array buffer:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`createElementArrayBuffer()`方法，包装了创建元素数组缓冲所需的WebGL API代码：
- en: '[PRE33]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the `pushPositionBuffer()` method which pushes a position buffer onto
    the graphics card:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`pushPositionBuffer()`方法，将位置缓冲推送到显卡上：
- en: '[PRE34]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the `pushColorBuffer()` method which pushes a color buffer onto the
    graphics card:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`pushColorBuffer()`方法，将颜色缓冲推送到显卡上：
- en: '[PRE35]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define the `pushTextureBuffer()` method which pushes a texture buffer onto
    the graphics card:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`pushTextureBuffer()`方法，将纹理缓冲推送到显卡上：
- en: '[PRE36]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Define the `pushIndexBuffer()` method which pushes an index buffer onto the
    graphics card:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`pushIndexBuffer()`方法，将索引缓冲推送到显卡上：
- en: '[PRE37]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define the `pushNormalBuffer()` method which pushes a normal buffer onto the
    graphics card:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`pushNormalBuffer()`方法，将法线缓冲推送到显卡上：
- en: '[PRE38]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define the `setMatrixUniforms()` method which wraps the WebGL API code required
    to set the matrix uniforms:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setMatrixUniforms()`方法，包装了设置矩阵统一变量所需的WebGL API代码：
- en: '[PRE39]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the `drawElements()` method which wraps the WebGL API code that draws
    non-triangular position buffers based on the index buffer:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawElements()`方法，包装了根据索引缓冲绘制非三角形位置缓冲所需的WebGL API代码：
- en: '[PRE40]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define the `drawArrays()` method which wraps the WebGL API code required to
    draw triangular position buffers:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawArrays()`方法，包装了绘制三角形位置缓冲所需的WebGL API代码：
- en: '[PRE41]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the `enableLighting()` method which wraps the WebGL API code required
    to enable lighting:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`enableLighting()`方法，包装了启用光照所需的WebGL API代码：
- en: '[PRE42]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the `setAmbientLighting()` method which wraps the WebGL API code required
    for setting ambient lighting:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setAmbientLighting()`方法，该方法包装了设置环境光照所需的WebGL API代码：
- en: '[PRE43]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define the `setDirectionalLighting()` method which wraps the WebGL API code
    required for setting directional lighting:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setDirectionalLighting()`方法，该方法包装了设置定向光照所需的WebGL API代码：
- en: '[PRE44]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The idea of the WebGL wrapper object is to handle some of the things that the
    WebGL API doesn't provide and to wrap tedious blocks of code that are required
    to do straightforward things.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL包装器对象的想法是处理WebGL API没有提供的一些东西，并包装一些繁琐的代码块，这些代码块是执行简单事情所必需的。
- en: There are two major components of WebGL that aren't built into the API—matrix
    transformation math and shader programs. In this chapter, we'll be using a handy
    matrix library built specifically for WebGL by *Brandon Jones*, called glMatrix,
    to handle all of the vector operations. As for the missing support for shader
    programs, our WebGL wrapper object includes pre-built GLSL shader programs. Shader
    programs are written in GLSL, which is short for OpenGL Shading Language, and
    is used to programmatically define how vertices and fragments should be rendered.
    Vertex shaders operate on every vertex that makes up the shape of our 3D models,
    and fragment shaders operate on every fragment which is produced by rasterization.
    To use shader programs , we'll actually have to pass in strings of GLSL code into
    the WebGL API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL中有两个主要组件没有内置在API中——矩阵变换数学和着色器程序。在本章中，我们将使用由*Brandon Jones*专门为WebGL构建的一个方便的矩阵库glMatrix来处理所有的向量操作。至于缺少对着色器程序的支持，我们的WebGL包装器对象包括预先构建的GLSL着色器程序。着色器程序是用GLSL编写的，GLSL是OpenGL着色语言的缩写，用于以编程方式定义顶点和片段的渲染方式。顶点着色器操作构成我们的3D模型形状的每个顶点，片段着色器操作由光栅化产生的每个片段。要使用着色器程序，我们实际上需要将GLSL代码的字符串传递给WebGL
    API。
- en: In addition to the wrapper methods, the WebGL wrapper object also includes the
    animation methods that we put together in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation"), *Bringing the Canvas to Life with Animation*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包装器方法之外，WebGL包装器对象还包括我们在[第5章](ch05.html "第5章. 通过动画使画布生动起来")中组合的动画方法，*通过动画使画布生动起来*。
- en: The majority of the remaining methods in our WebGL wrapper object simply wrap
    blocks of code necessary to push buffers onto the graphics card and then draw
    the result. In the next five recipes, we'll dive deeper into each of these buffer
    types, including position buffers, color buffers, index buffers, texture buffers,
    and normal buffers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的WebGL包装器对象中剩余的大部分方法只是简单地包装了一些必要的代码块，用于将缓冲区推送到显卡，然后绘制结果。在接下来的五个示例中，我们将更深入地了解每种缓冲区类型，包括位置缓冲区、颜色缓冲区、索引缓冲区、纹理缓冲区和法线缓冲区。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'For a more in-depth exploration of WebGL and OpenGL, check out these two awesome
    resources:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地了解WebGL和OpenGL，请查看这两个很棒的资源：
- en: '[http://learningwebgl.com/](http://learningwebgl.com/)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://learningwebgl.com/](http://learningwebgl.com/)'
- en: '[http://nehe.gamedev.net/](http://nehe.gamedev.net/)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://nehe.gamedev.net/](http://nehe.gamedev.net/)'
- en: See also...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '[Appendix A](apa.html "Appendix A. Detecting Canvas Support"), *Detecting Canvas
    Support*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录A](apa.html "附录A. 检测Canvas支持"), *检测Canvas支持*'
- en: Creating a triangular plane
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建三角形平面
- en: Now that we have our WebGL wrapper set up, let's create our first WebGL application
    by drawing a simple triangle on the screen. It will serve as a good foundation
    for the typical steps that are required to create more complex 3D models. In this
    recipe, we'll introduce the concept of position buffers, which are simply arrays
    of vertices used to define the position and shape of a 3D model.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了WebGL包装器，让我们通过在屏幕上绘制一个简单的三角形来创建我们的第一个WebGL应用程序。这将为创建更复杂的3D模型所需的典型步骤奠定良好的基础。在这个示例中，我们将介绍位置缓冲区的概念，它们只是用于定义3D模型的位置和形状的顶点数组。
- en: '![Creating a triangular plane](img/1369_09_01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![创建三角形平面](img/1369_09_01.jpg)'
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to render a 2D triangle with WebGL:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用WebGL渲染2D三角形：
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`glMatrix`库和WebGL包装器：
- en: '[PRE45]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define the `initBuffers()` function which initializes the position buffers
    for our triangle:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initBuffers()`函数，用于初始化三角形的位置缓冲区：
- en: '[PRE46]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define the `stage()` function which sets the perspective matrix, sets the model-view
    matrix to the identity matrix, translates the model-view matrix back -5 units
    in the z direction, pushes the position buffer onto the graphics card, and then
    draws the triangle using `drawArrays()`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stage()`函数，设置透视矩阵，将模型视图矩阵设置为单位矩阵，将模型视图矩阵在z方向上平移-5个单位，将位置缓冲区推送到显卡，然后使用`drawArrays()`绘制三角形：
- en: '[PRE47]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the page loads, create a new instance of the WebGL wrapper object, set
    the shader program to `"BLUE_COLOR"`, initialize the triangle buffers, and then
    draw the stage:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面加载时，创建WebGL包装器对象的新实例，将着色器程序设置为`"BLUE_COLOR"`，初始化三角形缓冲区，然后绘制舞台：
- en: '[PRE48]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body内嵌入canvas标签：
- en: '[PRE49]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the loads, the first thing we need to do is to initialize the WebGL wrapper
    object using the `experimental-webgl` context. At the time of writing, the `experimental-webgl`
    context is the only canvas context that's supported across all of the major browsers
    that support WebGL, including Google Chrome, Firefox, and Safari.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，我们需要做的第一件事是使用`experimental-webgl`上下文初始化WebGL包装器对象。在撰写本文时，`experimental-webgl`上下文是唯一在所有主要支持WebGL的浏览器中支持的画布上下文，包括Google
    Chrome、Firefox和Safari。
- en: Next, we can set the shader program to `"BLUE_COLOR"`, which will use a pre-built
    GLSL program to render blue vertices and fragments. Once the shader program is
    set, we need to initialize our buffers. Buffers are an array of vertices that
    are used to define our 3D models. For this recipe, we'll only be using a position
    buffer, which defines the vertex positions of our triangle. In future recipes,
    we'll introduce other buffer types, including index buffers, texture buffers,
    and normal buffers. For this recipe, the position buffer contains nine elements
    which represent three vertices (each vertex has an x, y, and z component).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将着色器程序设置为`"BLUE_COLOR"`，这将使用一个预先构建的GLSL程序来渲染蓝色顶点和片段。一旦着色器程序设置好，我们需要初始化我们的缓冲区。缓冲区是用来定义我们的3D模型的顶点数组。对于这个教程，我们只会使用一个位置缓冲区，它定义了我们三角形的顶点位置。在以后的教程中，我们将介绍其他类型的缓冲区，包括索引缓冲区、纹理缓冲区和法线缓冲区。对于这个教程，位置缓冲区包含九个元素，代表三个顶点（每个顶点有x、y和z分量）。
- en: Once the triangle buffers have been initialized, we can draw the stage. The
    `stage()` function first clears the canvas and then sets the perspective matrix.
    The `perspective()` method of our WebGL wrapper object takes in three parameters,
    a viewing angle, a minimum visible distance, and a maximum visible distance. In
    this recipe, we've set the minimum visible distance to 0.1 units, and the maximum
    visible distance to 100 units. Any objects closer than 0.1 units will be invisible,
    and any objects further than 100 units will also be invisible. If our stage were
    to contain a lot of complex models spread throughout space, then having a large
    maximum visible distance could potentially cause performance problems because
    too much is being rendered on the screen at once.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦三角形缓冲区被初始化，我们可以绘制舞台。`stage()`函数首先清除画布，然后设置透视矩阵。我们的WebGL包装对象的`perspective()`方法接受三个参数，一个视角，一个最小可见距离和一个最大可见距离。在这个教程中，我们将最小可见距离设置为0.1个单位，最大可见距离设置为100个单位。任何距离小于0.1个单位的对象将是不可见的，任何距离大于100个单位的对象也将是不可见的。如果我们的舞台包含了许多复杂的模型分布在整个空间中，那么有一个很大的最大可见距离可能会导致性能问题，因为屏幕上渲染了太多东西。
- en: Next, we can set the model-view matrix to the identity matrix using the `identity()`
    function , and then translate the model-view matrix to (0, 0, -5). This means
    that we've simply moved our model -5 units in the z direction which is 5 units
    away from the user.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`identity()`函数将模型视图矩阵设置为单位矩阵，然后将模型视图矩阵平移至(0, 0, -5)。这意味着我们只是将我们的模型向z方向移动了-5个单位，即离用户5个单位。
- en: Finally, we can push the position buffer onto the graphics card using the `pushPositionBuffer()`
    method and then draw the triangle using `drawArrays()`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`pushPositionBuffer()`方法将位置缓冲区推送到显卡上，然后使用`drawArrays()`绘制三角形。
- en: Rotating a triangular plane in 3D space
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在3D空间中旋转一个三角形平面
- en: Now that we can draw a 2D triangle in 3D space, let's try spinning it about
    the y-axis using the animation methods we added to the WebGL wrapper object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在3D空间中绘制一个2D三角形，让我们尝试使用我们添加到WebGL包装对象的动画方法围绕y轴旋转它。
- en: '![Rotating a triangular plane in 3D space](img/1369_09_02.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![在3D空间中旋转三角形平面](img/1369_09_02.jpg)'
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to rotate a triangle about the y-axis with WebGL:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在WebGL中围绕y轴旋转一个三角形：
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`glMatrix`库和WebGL包装器：
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the `initBuffers()` function which initializes the position buffers
    for our triangle:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initBuffers()`函数，初始化我们三角形的位置缓冲区：
- en: '[PRE51]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define the `stage()` function which sets the perspective, sets the model-view
    matrix to the identity matrix, translates the triangle, rotates the triangle about
    the y-axis, pushes the position buffer onto the graphics card, and draws the triangle
    using `drawArrays()`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stage()`函数，设置透视，将模型视图矩阵设置为单位矩阵，平移三角形，围绕y轴旋转三角形，将位置缓冲区推送到显卡上，并使用`drawArrays()`绘制三角形：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When the page loads, initialize the WebGL wrapper object, set the shader program,
    initialize the buffers, set the `stage` function for the animation, and then start
    the animation:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面加载时，初始化WebGL包装对象，设置着色器程序，初始化缓冲区，为动画设置`stage`函数，然后开始动画：
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body内嵌入canvas标签：
- en: '[PRE54]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To rotate our triangle about the y-axis, we first need to set up an animation
    stage by setting the `stage()` function of the WebGL wrapper object (similar to
    what we did in [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas to Life with
    Animation") with the `Animation` object ), and then start the animation with `start()`.
    For each animation frame, we can increase the angle of the triangle about the
    y-axis by rotating the model-view matrix with the `rotate()` method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了围绕y轴旋转我们的三角形，我们首先需要通过设置WebGL包装对象的`stage()`函数（类似于我们在[第5章](ch05.html "第5章。通过动画使画布生动起来")中使用`Animation`对象所做的）来设置一个动画阶段，然后用`start()`开始动画。对于每一帧动画，我们可以通过使用`rotate()`方法来旋转模型视图矩阵来增加三角形围绕y轴的角度。
- en: See also...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布生动起来")中创建一个动画类*'
- en: Creating a rotating cube
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个旋转的立方体
- en: Okay, now the fun really begins. In this recipe, we'll create a rotating 3D
    cube with differently colored faces. To do so, we'll introduce two new kinds of
    buffers—color buffers and index buffers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在真正的乐趣开始了。在这个教程中，我们将创建一个旋转的3D立方体，其面颜色不同。为此，我们将引入两种新的缓冲区——颜色缓冲区和索引缓冲区。
- en: '![Creating a rotating cube](img/1369_09_03.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: 创建一个旋转的立方体
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a rotating cube with WebGL:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在WebGL中创建一个旋转的立方体：
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`glMatrix`库和WebGL包装器：
- en: '[PRE55]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define the `initBuffers()` function which initializes the position buffers,
    color buffers, and the index buffers for our cube:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initBuffers()`函数，初始化我们立方体的位置缓冲区、颜色缓冲区和索引缓冲区：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define the `stage()` function which sets the perspective, sets the model-view
    matrix to the identity matrix, translates the cube, rotates the cube, pushes the
    position buffer, the color buffer, and the index buffer onto the graphics card,
    and finally draws the cube using `drawElements()` since the faces of our model
    aren''t triangular:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stage()`函数，该函数设置透视，将模型视图矩阵设置为单位矩阵，平移立方体，旋转立方体，将位置缓冲、颜色缓冲和索引缓冲推送到图形卡上，最后使用`drawElements()`绘制立方体，因为我们的模型的面不是三角形的：
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When the page loads, initialize the WebGL wrapper object, set the shader program
    to `"VARYING_COLOR"` as the color of each face is variable and dependent on the
    color buffers, initialize the buffers, set the `stage` function for the animation,
    and then start the animation:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面加载时，初始化WebGL包装器对象，将着色器程序设置为`"VARYING_COLOR"`，因为每个面的颜色是可变的，并且依赖于颜色缓冲，初始化缓冲区，为动画设置`stage`函数，然后开始动画：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入到HTML文档的body中：
- en: '[PRE59]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe introduces the concept of index buffers and color buffers. In the
    previous two recipes, we created a triangular plane because models with triangular
    faces are the easiest to implement with WebGL because only one buffer is required—the
    position buffer. When we want to create a 3D model with non-triangular faces,
    such as a cube, it's a bit more complex because we need a way to represent the
    cube as a set of triangular faces. We can accomplish this by creating an index
    buffer that maps triangles to the vertices of the position buffer.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程介绍了索引缓冲和颜色缓冲的概念。在前两个教程中，我们创建了一个三角形平面，因为具有三角形面的模型在WebGL中最容易实现，因为只需要一个缓冲区——位置缓冲。当我们想要创建一个具有非三角形面的3D模型，比如立方体时，就会复杂一些，因为我们需要一种方法来将立方体表示为一组三角形面。我们可以通过创建一个索引缓冲来实现这一点，该缓冲将三角形映射到位置缓冲的顶点。
- en: Take a look at the index buffer vertices in the proceeding code. You'll notice
    that the first six elements are `[0, 1, 2, 0, 2, 3]`. The first three elements,
    `[0, 1, 2]` refer to the 0th, 1st, and 2nd vertices of the position buffer, which
    form a triangle that covers half of the front face of the cube. The second set
    of elements, `[0, 2, 3]` correspond to the 0th, 2nd, and 3rd vertices of the position
    buffer and form a second triangle that covers the other half of the front face
    of the cube. Together, these two triangles form a solid face for the front face
    of the cube. When the index buffer is complete, it will contain a mapping of position
    buffer vertices that form triangular faces that cover the six faces of the cube.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面代码中的索引缓冲顶点。您会注意到前六个元素是`[0, 1, 2, 0, 2, 3]`。前三个元素`[0, 1, 2]`指的是位置缓冲的第0、1、2个顶点，形成了一个覆盖立方体正面一半的三角形。第二组元素`[0,
    2, 3]`对应于位置缓冲的第0、2、3个顶点，形成了覆盖立方体正面另一半的第二个三角形。这两个三角形一起形成了立方体正面的实心面。当索引缓冲完成时，它将包含一个映射，该映射将位置缓冲顶点组成的三角形面覆盖立方体的六个面。
- en: In addition to index buffers, this recipe also requires the use of color buffers.
    Color buffers are used to define the colors of model faces. In this recipe, the
    color buffer will define six different colors for the six faces of our cube. Similar
    to index buffers, color buffers are used to map a color to each vertex in the
    position buffer. Each color is defined by four elements, [red, green, blue, alpha].
    As defined by the position buffer, our cube is made up of six faces, each with
    four vertices. Therefore, our color buffer array should contain (6 faces) * (4
    vertices per face) * (4 elements per color) = 96 elements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了索引缓冲，这个教程还需要使用颜色缓冲。颜色缓冲用于定义模型面的颜色。在这个教程中，颜色缓冲将为我们的立方体的六个面定义六种不同的颜色。与索引缓冲类似，颜色缓冲用于将颜色映射到位置缓冲中的每个顶点。每种颜色由四个元素定义，[红，绿，蓝，alpha]。根据位置缓冲的定义，我们的立方体由六个面组成，每个面有四个顶点。因此，我们的颜色缓冲数组应包含(6个面)
    * (每个面4个顶点) * (每种颜色4个元素) = 96个元素。
- en: Once we have our position buffer, color buffer, and index buffer defined, all
    that's left for us to do is to push each buffer onto the graphics card and render
    the model. Unlike the previous two recipes where we used the `drawArrays()` method
    to directly render the triangle, in this recipe we'll have to use the `drawElements()`
    method because our model is made up of non-triangular faces and requires an index
    buffer to map triangular faces to the square faces of our model.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了位置缓冲、颜色缓冲和索引缓冲，我们所要做的就是将每个缓冲推送到图形卡上并渲染模型。与前两个教程不同的是，我们使用`drawArrays()`方法直接渲染三角形，而在这个教程中，我们将不得不使用`drawElements()`方法，因为我们的模型由非三角形面组成，需要一个索引缓冲将三角形面映射到模型的方形面。
- en: See also...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。使用动画使画布生动起来")中创建一个动画类*'
- en: Adding textures and lighting
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加纹理和光照
- en: Now that we know how to create a simple 3D model using position buffers and
    index buffers, let's make a wooden crate by wrapping our model with a crate texture
    and then adding some ambient and directional lighting to create shaded surfaces.
    This recipe introduces texture buffers to create textures and normal buffers which
    are required to handle lighting effects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用位置缓冲和索引缓冲创建一个简单的3D模型，让我们通过使用一个箱子纹理包裹我们的模型，然后添加一些环境和定向光照来创建阴影表面。这个教程介绍了纹理缓冲来创建纹理和需要处理光照效果的法线缓冲。
- en: '![Adding textures and lighting](img/1369_09_05.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![添加纹理和光照](img/1369_09_05.jpg)'
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a rotating crate with lihting in WebGL:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在WebGL中创建一个旋转的带光照的箱子：
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`glMatrix`库和WebGL包装器：
- en: '[PRE60]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define the `initBuffers()` function which initializes the position buffer,
    normal buffer, texture buffer, and the index buffer for our cube:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initBuffers()`函数，该函数初始化了我们的立方体的位置缓冲、法线缓冲、纹理缓冲和索引缓冲：
- en: '[PRE61]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Define the `stage()` function which sets the perspective, sets the model-view
    matrix to the identity matrix, translates the cube, rotates the cube, enables
    lighting, sets the ambient lighting, sets the directional lighting, pushes the
    position buffer, the normal buffer, the texture buffer, and the index buffer onto
    the graphics card, and finally draws the cube using `drawElements()`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stage()`函数，该函数设置透视，将模型视图矩阵设置为单位矩阵，平移立方体，旋转立方体，启用光照，设置环境光，设置定向光，将位置缓冲区、法线缓冲区、纹理缓冲区和索引缓冲区推送到显卡上，并最终使用`drawElements()`绘制立方体：
- en: '[PRE62]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define the `init()` method which initializes the crate texture, sets the the
    `stage()` function, and starts the animation:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`init()`方法，该方法初始化板条箱纹理，设置`stage()`函数，并开始动画：
- en: '[PRE63]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define the `loadTexture()` function which creates a new texture object, creates
    a new image object, initializes the texture and starts the animation once the
    texture image has loaded:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`loadTexture()`函数，该函数创建一个新的纹理对象，创建一个新的图像对象，初始化纹理并在纹理图像加载后开始动画：
- en: '[PRE64]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When the page loads, initialize the WebGL wrapper object, set the shader program
    to `"TEXTURE_DIRECTIONAL_LIGHTING"`, and load the texture:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载时，初始化WebGL包装器对象，将着色器程序设置为`"TEXTURE_DIRECTIONAL_LIGHTING"`，并加载纹理：
- en: '[PRE65]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body中嵌入canvas标签：
- en: '[PRE66]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe introduces the concept of texture buffers and normal buffers. Texture
    buffers allow us to define the orientation and scale of a texture image for each
    face of a 3D model. To define the texture buffer of our wooden crate, we need
    to map the four corners of the texture image to the four corners of each face
    of the cube.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例介绍了纹理缓冲区和法线缓冲区的概念。纹理缓冲区允许我们为3D模型的每个面定义纹理图像的方向和比例。要定义木箱的纹理缓冲区，我们需要将纹理图像的四个角映射到立方体每个面的四个角。
- en: In order to handle lighting effects with WebGL, we need to define the normals
    of the faces that make up our cube with normal buffers. Normals are vectors that
    are perpendicular to a surface. For example, the normal of a floor points straight
    up, and the normal of the ceiling points straight down. Once our normals have
    been defined, we are now in a position to set up ambient and directional lighting.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理WebGL的光照效果，我们需要使用法线缓冲区定义立方体构成的面的法线。法线是垂直于表面的向量。例如，地板的法线指向正上方，天花板的法线指向正下方。一旦我们定义了法线，我们现在可以设置环境光和定向光。
- en: 'Although there are many other kinds of lighting effects that can be achieved
    with WebGL, this recipe focuses on the two most common—ambient and directional
    lighting , which can be used together or independently:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在WebGL中可以实现许多其他类型的光照效果，但本示例侧重于两种最常见的——环境光和定向光，它们可以一起使用或独立使用：
- en: '**Ambient lighting** refers to the general lighting of a room or world, and
    is defined with RGB. A room with an ambient lighting value of `[0,0,0]` would
    be completely dark, and a room with an ambient lighting value of `[1,1,1]` would
    be completely lit. Also, if we had a room with an ambient lighting value of `[1,0,0]`
    for example, the room would be illuminated with a red light.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境光**指的是房间或世界的一般照明，并用RGB定义。具有环境光值`[0,0,0]`的房间将完全黑暗，而具有环境光值`[1,1,1]`的房间将完全照亮。此外，例如，如果我们有一个环境光值为`[1,0,0]`的房间，那么房间将被红光照亮。'
- en: '**Directional lighting** causes the faces of 3D models that are facing towards
    the light to be lighter, and the faces of 3D models that are facing away from
    the light to be darker. Directional lighting is typically used to simulate very
    strong light sources hat are far away, such as the sun.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定向光**使得面向光源的3D模型的面更亮，而背对光源的3D模型的面更暗。定向光通常用于模拟远处非常强的光源，比如太阳。'
- en: To use both textures and directional lighting, we can set the shader program
    to `TEXTURE_DIRECTIONAL_LIGHTING` with the `setShaderProgram()` method and we
    can enable lighting with the `enableLighting()` method . Finally, we can set the
    ambient lighting of our world with the `setAmbientLighting()` method and set the
    directional lighting using the `setDirectionalLighting()` method .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时使用纹理和定向光，我们可以使用`setShaderProgram()`方法将着色器程序设置为`TEXTURE_DIRECTIONAL_LIGHTING`，并使用`enableLighting()`方法启用光照。最后，我们可以使用`setAmbientLighting()`方法设置世界的环境光，并使用`setDirectionalLighting()`方法设置定向光。
- en: See also...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。使用动画使画布生动起来")中创建一个动画类*'
- en: Creating a 3D world that you can explore
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可以探索的3D世界
- en: Now that we know how to create some basic 3D models with textures and lighting,
    we are now in a position to create our own 3D world. In this recipe, we'll create
    three sets of buffers—cube buffers, wall buffers, and floor buffers. We can use
    the cube buffers to render randomly placed crates throughout our world, the wall
    buffers to create four walls, and the floor buffers to create a floor and a ceiling
    (we can reuse the floor buffers for the ceiling buffers since they are the same
    shape). Next, we'll add keyboard event listeners to the document so that we can
    explore the world with the arrow keys and the mouse. Let's get started!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用纹理和光照创建一些基本的3D模型，我们现在可以创建自己的3D世界。在这个示例中，我们将创建三组缓冲区——立方体缓冲区、墙壁缓冲区和地板缓冲区。我们可以使用立方体缓冲区在世界各处随机放置板条箱，使用墙壁缓冲区创建四面墙，使用地板缓冲区创建地板和天花板（我们可以重用地板缓冲区作为天花板缓冲区，因为它们是相同的形状）。接下来，我们将在文档中添加键盘事件监听器，以便我们可以使用箭头键和鼠标探索世界。让我们开始吧！
- en: '![Creating a 3D world that you can explore](img/1369_09_06.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个可以探索的3D世界](img/1369_09_06.jpg)'
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to create a 3D world full of randomly placed crates that
    you can explore with the keyboard and mouse in WebGL:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在WebGL中创建一个充满随机放置的板条箱的3D世界，可以使用键盘和鼠标进行探索：
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`glMatrix`库和WebGL包装器：
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define the `Controller` constructor which initializes the view, the WebGL wrapper
    object, and the model, attaches keyboard event listeners, and loads the world
    textures:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Controller`构造函数，用于初始化视图、WebGL包装对象和模型，附加键盘事件侦听器，并加载世界纹理：
- en: '[PRE68]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define the `loadTextures()` method which loads the world textures:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`loadTextures()`方法，用于加载世界纹理：
- en: '[PRE69]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Define the `getMousePos()` method which gets the mouse position:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getMousePos()`方法，用于获取鼠标位置：
- en: '[PRE70]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define the `handleMouseDown()` method which captures the start mouse position,
    camera pitch, and camera yaw:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`handleMouseDown()`方法，用于捕获起始鼠标位置、摄像机俯仰和摄像机偏航：
- en: '[PRE71]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Define the `handleMouseMove()` method which updates the camera:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`handleMouseMove()`方法，用于更新摄像机：
- en: '[PRE72]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Define the `handleKeyDown()` method which controls the user movement through
    the world:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`handleKeyDown()`方法，用于控制用户在世界中的移动：
- en: '[PRE73]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define the `handleKeyUp()` method which sets the user side movement to `STILL`
    if the left or right arrow key has been released, and sets the user straight movement
    to `STILL` if the up or down arrow key has been released:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`handleKeyUp()`方法，如果释放了左右箭头键，则将用户侧向移动设置为`STILL`，如果释放了上下箭头键，则将用户直线移动设置为`STILL`：
- en: '[PRE74]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Define the `attachListeners()` method which attaches listeners to the canvas
    and document:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`attachListeners()`方法，用于将侦听器附加到画布和文档：
- en: '[PRE75]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Define the `Model` constructor which initializes the camera and the buffers
    for the crates, the floor, and the wall:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Model`构造函数，用于初始化摄像机和箱子、地板和墙壁的缓冲区：
- en: '[PRE76]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Define the `initCratePositions()` method which generates 20 crates with random
    positions in the world and also randomly stacks crates:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initCratePositions()`方法，用于在世界中生成20个具有随机位置的箱子，并随机堆叠箱子：
- en: '[PRE77]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Define the `initCubeBuffers()` method which initializes the cube buffers for
    the crates:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initCubeBuffers()`方法，用于初始化箱子的立方体缓冲区：
- en: '[PRE78]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Define the `initFloorBuffers()` method which initializes the floor buffers
    (these buffers will be used for the ceiling as well):'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initFloorBuffers()`方法，用于初始化地板缓冲区（这些缓冲区也将用于天花板）：
- en: '[PRE79]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define the `initWallBuffers()` method which initializes the wall buffers:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initWallBuffers()`方法，用于初始化墙壁缓冲区：
- en: '[PRE80]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Define the `initBuffers()` method which initializes the cube, floor, and wall
    buffers:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initBuffers()`方法，用于初始化立方体、地板和墙壁缓冲区：
- en: '[PRE81]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Define the `updateCameraPos()` method which is used to update the camera position
    for each animation frame:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateCameraPos()`方法，用于更新每个动画帧的摄像机位置：
- en: '[PRE82]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Define the `View` constructor which sets the canvas dimensions:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`View`构造函数，用于设置画布尺寸：
- en: '[PRE83]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Define the `drawFloor()` method which draws the floor:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawFloor()`方法，用于绘制地板：
- en: '[PRE84]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define the `drawCeiling()` method which draws the ceiling:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawCeiling()`方法，用于绘制天花板：
- en: '[PRE85]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Define the `drawCrates()` method which draws the crates:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawCrates()`方法，用于绘制箱子：
- en: '[PRE86]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Define the `drawWalls()` method which draws the walls:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawWalls()`方法，用于绘制墙壁：
- en: '[PRE87]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Define the `stage()` method which updates the camera position, clears the canvas,
    positions the world relative to the camera position, and then draws the floor,
    the walls, the ceiling, and the crates:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stage()`方法，用于更新摄像机位置，清除画布，将世界相对于摄像机位置定位，然后绘制地板、墙壁、天花板和箱子：
- en: '[PRE88]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When the page loads, initialize the `Controller`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载时，初始化`Controller`：
- en: '[PRE89]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入到HTML文档的body中：
- en: '[PRE90]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe uses an MVC (model, view, controller) design pattern to separate
    the drawing logic from the data logic.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用MVC（模型、视图、控制器）设计模式，将绘图逻辑与数据逻辑分离。
- en: The `Controller` class is responsible for directing the model and the view,
    and also manages user actions. It handles arrow key events with the `handleKeyDown()`
    and `handleKeyUp()` method s, and it also handles screen dragging with the `handleMouseDown()`
    and `handleMouseMove()` method s. In addition, the controller is also responsible
    for pre-loading all of the textures before the simulation begins.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller`类负责指导模型和视图，还管理用户操作。它使用`handleKeyDown()`和`handleKeyUp()`方法处理箭头键事件，并使用`handleMouseDown()`和`handleMouseMove()`方法处理屏幕拖动。此外，控制器还负责在模拟开始之前预加载所有纹理。'
- en: Next, the model is responsible for handling all of the data-setting logic. The
    data for our simulation includes the cube, floor, and wall buffers, the textures,
    the crate positions, the camera position, pitch, and yaw, and also the user movements.
    The crate positions are initialized with the `initCratePositions()` method , the
    buffers for the world are initialized with the `initCubeBuffers()` , `initFloorBuffers()`
    , and the `initWallBuffers()` methods , and the camera position, pitch, and yaw
    is updated with the `updateCameraPos()` method .
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，模型负责处理所有数据设置逻辑。我们模拟的数据包括立方体、地板和墙壁缓冲区、纹理、箱子位置、摄像机位置、俯仰和偏航，以及用户移动。箱子位置使用`initCratePositions()`方法初始化，世界的缓冲区使用`initCubeBuffers()`、`initFloorBuffers()`和`initWallBuffers()`方法初始化，摄像机位置、俯仰和偏航使用`updateCameraPos()`方法更新。
- en: Finally, the view is responsible for rendering the 3D world using the model
    data. Buffers are pushed to the graphics card and rendered with the `drawFloor()`
    , `drawCeiling()`, `drawCrates()` , and the `drawWalls()` method s. For each animation
    frame, the `stage()` method is called which updates the camera position, clears
    the canvas, sets the lighting, and draws the scene with the aforementioned drawing
    methods.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，视图负责使用模型数据渲染3D世界。缓冲区被推送到图形卡，并使用`drawFloor()`、`drawCeiling()`、`drawCrates()`和`drawWalls()`方法进行渲染。对于每个动画帧，调用`stage()`方法更新摄像机位置，清除画布，设置照明，并使用上述绘图方法绘制场景。
- en: There's more...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here are some more ideas if you want to extend this recipe:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想扩展此示例，以下是一些更多的想法：
- en: Add boundary conditions so that the player can't run through crates and walls
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加边界条件，使玩家无法穿过箱子和墙壁
- en: Enable the player to jump, and perhaps even jump on top of crates
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使玩家能够跳跃，甚至跳上箱子
- en: Create doorways to other rooms
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建通往其他房间的门
- en: Create staircases so that the player can explore other floors
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建楼梯，以便玩家可以探索其他楼层
- en: Add walking sounds with the HTML5 canvas audio tag
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5画布音频标签添加行走声音
- en: Now that you're able to create 3D models with textures and lighting and put
    them together to form segments of a 3D world, the only thing standing between
    you and a real-life Tron is your own imagination. Have fun!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你能够创建带有纹理和光照的3D模型，并将它们组合在一起形成3D世界的部分，你和真实的Tron之间唯一的障碍就是你自己的想象力。玩得开心！
- en: See also...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。使用动画让画布生动起来")中创建一个动画类
