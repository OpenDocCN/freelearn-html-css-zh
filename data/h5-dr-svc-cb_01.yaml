- en: Chapter 1. Display of Textual Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 文本数据的显示
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Rounding numbers for display
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 舍入数字以进行显示
- en: Padding numbers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充数字
- en: Displaying metric and imperial measurements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示公制和英制测量单位
- en: Displaying formatted dates in the user's time zone
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户的时区中显示格式化日期
- en: Displaying the dynamic time that has elapsed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示已经过去的动态时间
- en: Displaying Math
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示数学
- en: Creating an endless scrolling list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建无限滚动列表
- en: Creating a sortable paginated table
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可排序的分页表
- en: Creating multiple-choice filters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多选过滤器
- en: Creating range filters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建范围过滤器
- en: Creating combined complex filters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组合复杂过滤器
- en: Displaying code in HTML
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML中显示代码
- en: Rendering Markdown
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染Markdown
- en: Autoupdating fields
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动更新字段
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The most common task related to web application development is the displaying
    of text. This chapter will cover some of the issues programmers face when displaying
    data in browsers, and will explain how to tackle the problems in a simple yet
    effective way, giving several different options for the programmer from which
    to choose. These examples will contain the rendering of markup or the conversion
    of other datatypes into plain text.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web应用程序开发相关的最常见任务是显示文本。本章将涵盖程序员在浏览器中显示数据时面临的一些问题，并将解释如何以简单而有效的方式解决这些问题，为程序员提供几种不同的选择。这些示例将包含标记的渲染或其他数据类型转换为纯文本。
- en: Rounding numbers for display
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 舍入数字以进行显示
- en: The second, most common datatype used in applications after text is numbers.
    There are many different ways of working with numbers, and we will take a look
    at some of these ways when a given precision is required. The first obvious option
    is to use the JavaScript `Number` object wrapper to work with numerical values.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本之后，应用程序中使用的第二种最常见的数据类型是数字。有许多不同的处理数字的方式，当需要给定精度时，我们将看一些这些方式。第一个明显的选择是使用JavaScript的`Number`对象包装器来处理数值。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `Number` object contains the `toFixed([digits])` method that can be used
    to display numbers; here the `digits` parameter can have a value between 0 and
    20\. The number will either get rounded automatically if needed, or the number
    will get padded with additional zeros if necessary. Ok, so let's see it in action.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number`对象包含`toFixed([digits])`方法，可用于显示数字；这里的`digits`参数可以在0和20之间取值。如果需要，数字将自动舍入，或者如果需要，数字将填充额外的零。好的，让我们看看它的效果。'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps do demonstrate working with the `Number` object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来演示使用`Number`对象：
- en: 'First, we''ll create a list of numbers; note that the numbers have been picked
    intentionally to illustrate some of the characteristics of the functions:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个数字列表；请注意，这些数字是有意挑选的，以说明一些函数的特性：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Iterate the list and display numbers using the `.toFixed()` method with the
    `digits` parameter''s values 0, 1, and 2 accordingly:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代列表，并使用`.toFixed()`方法显示数字，分别使用`digits`参数的值0、1和2：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The result retrieved from executing the code will print out the numbers with
    their respective `toFixed` representation, which should be straightforward.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后得到的结果将打印出带有它们各自`toFixed`表示的数字，这应该很简单。
- en: 'Let''s take a look at some of the characteristic values:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些特征值：
- en: '`1.616.toFixed(2)` will return `1.62`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.616.toFixed(2)`将返回`1.62`'
- en: '`1.4.toFixed(2)` will return `1.40` as expected, adding a trailing zero'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.4.toFixed(2)`将返回`1.40`，如预期的那样，添加一个尾随零'
- en: '`1.5454.toFixed()` will return `2`, because the default value for `toFixed()`
    is `0`; this means that no decimal points, and additionally the `0.5` segment
    is rounded to `1` so the ceiling value is used here'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.5454.toFixed()`将返回`2`，因为`toFixed()`的默认值是`0`；这意味着没有小数点，另外`0.5`部分被舍入为`1`，所以这里使用了天花板值'
- en: '`1.615.toFixed(2)` will either return `1.61`, ignoring the `0.005` segment,
    or the floor value will be used'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.615.toFixed(2)`将返回`1.61`，忽略`0.005`部分，或者将使用地板值'
- en: The `toFixed()` method works mostly as expected so long as we don't need the
    higher precision or are only using it to display numbers where the type of rounding
    is not mission critical.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`toFixed()`方法在大多数情况下都能按预期工作，只要我们不需要更高的精度或仅用它来显示数字，其中舍入的类型并不是关键。'
- en: Additionally, we cannot rely on `toFixed()` when we need rounding in cases where
    we have numbers such as 1.446 and others that fall in the same category; calling
    `1.446.toFixed(1)` would result in inconsistent and unpredictable results.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们需要在有类似1.446的数字的情况下进行舍入时，我们不能依赖于`toFixed()`; 调用`1.446.toFixed(1)`将导致不一致和不可预测的结果。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are various ways to solve this. The quick and dirty solution would be
    to redefine the `Number.prototype.toFixed()` function, but we encourage you to
    not do so, as doing this may have side effects that are not apparent. Any redefinition
    of the functions from the built-in objects is considered an anti-pattern if it
    is not absolutely essential. The problem arises if another library or a piece
    of code is using the same function. The other library might expect our redefined
    function to work a certain way. These types of redefinitions are hard to track;
    even if we are to add a function instead of redefining it, someone else might
    do the same thing. For example, say we decided to add some function to the `Number`
    object:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法可以解决这个问题。快速而肮脏的解决方案是重新定义`Number.prototype.toFixed()`函数，但我们鼓励您不要这样做，因为这样做可能会产生不明显的副作用。如果不是绝对必要，对内置对象的函数进行重新定义被认为是一种反模式。问题在于如果另一个库或一段代码使用相同的函数。另一个库可能期望我们重新定义的函数以某种方式工作。这些类型的重新定义很难跟踪；即使我们添加一个函数而不是重新定义它，其他人可能会做同样的事情。例如，假设我们决定向`Number`对象添加一些函数：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are no guarantees that someone else has not already added `theFunction`
    to the `Number` object. We could do additional checks to verify if the function
    already exists, but we cannot be sure if it does what we want it to do.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保证其他人没有将`theFunction`添加到`Number`对象中。我们可以进行额外的检查来验证函数是否已经存在，但我们不能确定它是否会按我们希望的方式工作。
- en: Instead, using a utility function for achieving consistent data would be a better
    option.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用一个实用函数来实现一致的数据将是一个更好的选择。
- en: 'One way of tackling the problem is to first multiply the number with `10 ^
    digits` and then call the `Math.round(number)` method on the result, or you can
    call `Math.ceil(number)`. For example, if you need to have the value rounded upwards
    to the nearest integer, use the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的一种方法是首先将数字乘以`10 ^ digits`，然后在结果上调用`Math.round(number)`方法，或者您可以调用`Math.ceil(number)`。例如，如果您需要将值向上舍入到最接近的整数，使用以下方法：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, as the number gets multiplied with `10 ^ digits` and then gets rounded,
    we do not observe the problems with `toFixed()`. Note that this method has a different
    behavior from `toFixed()` not just in the way of how rounding is being handled,
    but also the addition of trailing zeroes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于数字乘以`10 ^ digits`，然后四舍五入，我们不会观察到`toFixed()`的问题。请注意，这种方法与`toFixed()`的行为不同，不仅在处理舍入的方式上有所不同，而且还会添加尾随零。
- en: A different option would be to use an arbitrary precision library such as Big.js
    if precision is crucial ([https://github.com/MikeMcl/big.js](https://github.com/MikeMcl/big.js)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用一个类似Big.js这样的任意精度库，如果精度很重要的话（[https://github.com/MikeMcl/big.js](https://github.com/MikeMcl/big.js)）。
- en: Padding numbers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充数字
- en: We are sometimes faced with the need to pad numbers to a certain range. For
    example, suppose we want to display a number in five possible digits, such as
    `00042`. One obvious solution would be to use the iterative approach and prepend
    characters, but there are a few cleaner solutions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要将数字填充到一定的范围。例如，假设我们想要以五位数字的形式显示一个数字，比如`00042`。一个明显的解决方案是使用迭代方法并在前面添加字符，但还有一些更简洁的解决方案。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we need to take a look at some of the functions that we are going to
    use. Let''s take a look at the `Array.join(separator)` method that can be applied
    to create joined text from a list of elements:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要看一下我们将要使用的一些函数。让我们看一下`Array.join(separator)`方法，它可以用来从元素列表创建连接的文本：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will result in `"life*is*life"` that shows fairly simple elements that
    are joined with a given separator. Another method that is of interest is `Array.slice(begin[,
    end])` that returns a copy of a portion of an array. For our use, we are only
    interested in the `begin` parameter that can have both positive and negative values.
    If we use a positive value, it means that this will be the starting index for
    the slice using zero-based indexing; for example, consider the following line
    of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致`"life*is*life"`，显示了用给定分隔符连接的相当简单的元素。另一个有趣的方法是`Array.slice(begin[, end])`，它返回数组的一部分的副本。对于我们的用途，我们只对`begin`参数感兴趣，它可以具有正值和负值。如果我们使用正值，这意味着这将是使用基于零的索引的切片的起始索引；例如，考虑以下代码行：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding line of code will return an array with the elements `'e'`,`'f'`,
    and `'g'`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将返回一个包含元素`'e'`、`'f'`和`'g'`的数组。
- en: 'If, on the other hand, using a negative value for the `begin` element indicates
    an offset from the end of the array, consider the same example using a negative
    value as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果对`begin`元素使用负值，则表示从数组末尾的偏移量，考虑以下使用负值的相同示例：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The result would be `'e','f','g'`, as we are slicing from the end.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是`'e'，'f'，'g'`，因为我们是从末尾切片。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s get back to our problem: how do we create a clean solution for prepending
    zeros to a number? For an iterative solution, we create a method that accepts
    the number, the size of the formatted result, and the character that will be used
    for padding; let''s take `''0''` for example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的问题：如何为数字添加前导零创建一个干净的解决方案？对于迭代解决方案，我们创建一个接受数字、格式化结果的大小和用于填充的字符的方法；例如，让我们以`'0'`为例：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we converted the number to a string in order to get the length of its representation;
    afterwards, we simply create `prefix` that will have the `size–len` characters
    of the `character` variable, and just return the resulting `prefix + strNumber`
    that is the string representation for that number.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将数字转换为字符串，以便获得其表示的长度；之后，我们简单地创建一个`prefix`，它将有`size-len`个字符的`character`变量，并返回结果`prefix
    + strNumber`，这是该数字的字符串表示。
- en: You may notice that in the case where `size` is smaller than `len`, the original
    number is returned, and this should probably be changed in order to have the function
    working for that corner case.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，如果`size`小于`len`，则会返回原始数字，这可能需要更改，以使该函数适用于这种特殊情况。
- en: 'Another way would be to use the `Array.slice()` method to achieve similar results:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`Array.slice()`方法来实现类似的结果：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will just prepend a prefix to a number and slice off the extra `''0''`
    counting from the end, making the solution a lot cleaner and, additionally, enabling
    us to be more flexible around what will be part of the prefix. The downside of
    this is that we are manually constructing the prefix that will be part of the
    method call `sliceExample(42,"00000")`. In order to make this process automatic,
    we can make use of `Array.join`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只是在数字前面添加一个前缀，并从末尾切掉多余的`'0'`，使解决方案更加简洁，并且还能够更灵活地确定前缀的内容。这样做的缺点是我们手动构造了将成为方法调用`sliceExample(42,"00000")`一部分的前缀。为了使这个过程自动化，我们可以使用`Array.join`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We create an array of the expected `size + 1` as on joining, we''ll get the
    total array `size-1 joined elements`. This will construct the prefix with the
    expected size, and the other part will remain the same:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个预期的`size + 1`的数组，因为在连接时，我们将得到总数组`size-1个连接的元素`。这将构造预期大小的前缀，而其他部分将保持不变：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A sample method call will be `padNumber(42,5,'0')`; this will not have the flexibility
    of the previous method, but it will be a lot simpler to use in larger numbers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例方法调用将是`padNumber(42,5,'0')`; 这将不具有以前方法的灵活性，但在处理更大的数字时会更简单。
- en: How it works…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The recipe is fairly straightforward, but an important thing to note is the
    functional approach. If there is one thing to take with you from this recipe,
    it is that the iterative solution is not always the best. When it comes to JavaScript,
    there are usually a few other ways to complete the task that you have; they are
    not always *that* straightforward and sometimes not even faster, but they can
    be much cleaner.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方相当简单，但需要注意的一点是功能性方法。如果有一件事可以从这个配方中带走的话，那就是迭代解决方案并不总是最好的。当涉及到JavaScript时，通常有几种其他完成任务的方法；它们并不总是*那么*直接，有时甚至不是更快，但它们可能更加干净。
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If, for some reason, we are padding numbers very often, it might make sense
    to add the function into the `Number` object and remove the `input` parameter
    number with the `this` keyword:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因我们经常填充数字，将函数添加到`Number`对象中并使用`this`关键字删除`input`参数数字可能是有意义的：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As the function is now part of every `Number` object, we can use it directly
    from any number; let''s take the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该函数现在是每个“Number”对象的一部分，我们可以直接从任何数字中使用它；让我们来看下面的例子：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Additionally, if the `'.'` character should not be included in the calculation
    of the padding, we could add an additional check that would reduce the size of
    the prefix.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果不应包括“。”字符在填充的计算中，我们可以添加一个额外的检查，以减少前缀的大小。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in the *Rounding numbers for display* recipe, we explained why adding
    functions to a standard object is a hack that can backfire at us.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在*舍入数字以进行显示*配方中，我们解释了为什么向标准对象添加函数是一种可能会对我们产生反作用的黑客行为。
- en: Displaying metric and imperial measurements
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示公制和英制测量
- en: Websites that deal with calculations and measurements often need to solve the
    problem of using both metric and imperial units of measurement. This recipe will
    demonstrate a data-driven approach to dealing with unit conversions. As this is
    an HTML5 book, the solution will be implemented on the client side rather than
    on the server side.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 处理计算和测量的网站通常需要解决同时使用公制和英制计量单位的问题。本教程将演示一种数据驱动的方法来处理单位转换。由于这是一本HTML5书籍，解决方案将在客户端而不是服务器端实现。
- en: We're going to implement a client-side, "ideal weight" calculator that supports
    metric and imperial measurements. This time, we're going to create a more general
    and elegant data-driven solution that utilizes modern HTML5 capabilities, such
    as data attributes. The goal is to abstract away the messy and error-prone conversion
    as much as possible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个客户端，“理想体重”计算器，支持公制和英制测量。这一次，我们将创建一个更通用和优雅的数据驱动解决方案，利用现代HTML5功能，如数据属性。目标是尽可能抽象出混乱和容易出错的转换。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The formula for calculating the body mass index (BMI) is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 计算体重指数（BMI）的公式如下：
- en: BMI = (Weight in kilograms / (height in meters x height in meters))
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: BMI =（千克中的体重/（米中的身高x米中的身高））
- en: We're going to use BMI = 22 to calculate the "ideal weight".
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用BMI = 22来计算“理想体重”。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the following HTML page:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下HTML页面：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This page looks very much like the regular page we would make for a BMI-based
    ideal weight calculator. The main differences are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面看起来非常像我们为基于BMI的理想体重计算器制作的常规页面。主要区别如下：
- en: We have an imperial/metric selection input
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个英制/公制选择输入
- en: We also have additional custom data attributes to give special meanings to the
    HTML fields
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有额外的自定义数据属性，为HTML字段赋予特殊含义
- en: We use `data-measurement` to denote the kind of measurement that the element
    will display (for example, either the weight or the height)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`data-measurement`来表示元素将显示的测量类型（例如，体重或身高）
- en: We use `data-display-unit` and `data-display-value` to denote fields that display
    unit strings and values of the measurement respectively
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`data-display-unit`和`data-display-value`来表示显示单位字符串和测量值的字段
- en: 'Create a file named `example.js` with the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example.js`的文件，其中包含以下代码：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first part of the code configures a jQuery plugin called `unitval`, with
    the conversion factors for the measurements and units that we are going to use
    (weight and height).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分配置了一个名为`unitval`的jQuery插件，其中包含我们将使用的测量和单位的转换因子（体重和身高）。
- en: 'The second part sets the measurement units for the document by reading the
    specification from the `select` field. It specifies an array of measurements,
    each having the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分通过从“select”字段中读取规范来设置文档的测量单位。它指定了一个测量数组，每个测量都有以下内容：
- en: A type string, for example `"height"`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型字符串，例如“身高”
- en: A list of units, for example `["ft", "inch"]`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位列表，例如`["ft", "inch"]`
- en: The number of decimals to use for the last unit
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于最后一个单位的小数位数
- en: The third part is a regular calculator that is written almost exactly as it
    would be written if there were no unit conversions. The only exception is that
    values are taken from the elements that have the `data-measurement` attribute
    using the jQuery plugin named `$.unitval`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分是一个常规计算器，几乎与没有单位转换时写的一样。唯一的例外是，值是使用名为`$.unitval`的jQuery插件从具有`data-measurement`属性的元素中获取的。
- en: 'We''re going to write a generic unit converter. It will need two functions:
    one that will convert user-displayed (input) data to standard international (SI)
    measurement units, and another to convert it back from SI units to user-friendly
    display units. Our converter will support using multiple units at the same time.
    When converting from input, the first argument is the measurement type (for example,
    distance), the second is an array of value-unit pairs (for example, `[[5, ''km''],
    [300,''m'']]`), a single pair (for example `[5,''km'']`), or simply the value
    (for example `5`).'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写一个通用的单位转换器。它将需要两个函数：一个将用户显示（输入）数据转换为标准国际（SI）测量单位的函数，另一个将其从SI单位转换回用户友好的显示单位。我们的转换器将支持同时使用多个单位。在从输入转换时，第一个参数是测量类型（例如，距离），第二个是值-单位对的数组（例如，`[[5，'km']，[300，'m']]`），单个对（例如`[5，'km']`），或者只是值（例如`5`）。
- en: If the second parameter is a simple value, we're going to accept a third one
    containing the unit (for example `'km'`). The output is always a simple SI value.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第二个参数是一个简单的值，我们将接受一个包含单位的第三个参数（例如`'km'`）。输出始终是一个简单的SI值。
- en: When converting a value to the desired output units, we specify the units as
    an array, for example, as either `['km', 'm']` or as a single unit. We also specify
    rounding decimals for the last unit. Our output is an array of converted values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在将值转换为所需的输出单位时，我们将单位指定为数组，例如，作为`['km', 'm']`或作为单个单位。我们还指定最后一个单位的小数位数。我们的输出是转换后的值数组。
- en: Conversion is done using the values in the `Factors` object. This object contains
    a property for every measurement name that we're going to use. Each such property
    is an object with the available units for that measurement as properties, and
    their SI factors as values. Look in the following in `example.js` for an example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 转换是使用`Factors`对象中的值完成的。该对象包含我们将要使用的每个测量名称的属性。每个这样的属性都是一个对象，其中包含该测量的可用单位作为属性，其SI因子作为值。在`example.js`中查看示例。
- en: 'The source code of the jQuery plugin, `unitval.js`, is as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: jQuery插件`unitval.js`的源代码如下：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our generic convertor is useful, but not very convenient or user friendly;
    we still have to do all the conversions manually. To avoid this, we''re going
    to put data attributes on our elements, denoting the measurements that they display.
    Inside them, we''re going to put separate elements for displaying the value(s)
    and unit(s). When we set the measurement units, the function `setMeasurementUnits`
    will set them on every element that has this data attribute. Furthermore, it will
    also adjust the inner value and unit elements accordingly:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的通用转换器很有用，但不太方便或用户友好；我们仍然必须手动进行所有转换。为了避免这种情况，我们将在元素上放置数据属性，表示它们显示的测量。在其中，我们将放置用于显示值和单位的单独元素。当我们设置测量单位时，函数`setMeasurementUnits`将在具有此数据属性的每个元素上设置它们。此外，它还将相应地调整内部值和单位元素：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As every element knows its measurement and units, we can now simply put SI
    values inside them and have them display converted values. To do this, we''ll
    write `unitval`. It allows us to set and get "united" values, or set unit options
    on elements that have the `data-measurement` property:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于每个元素都知道其测量和单位，因此我们现在可以简单地在其中放入SI值，并让它们显示转换后的值。为此，我们将编写`unitval`。它允许我们设置和获取“联合”值，或在具有`data-measurement`属性的元素上设置单位选项：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This plugin will be explained in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件将在下一节中解释。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: HTML elements have no notion of measurement units. To support unit conversion,
    we added our own data attributes. These allow us to give a special meaning to
    certain elements—the specifics of which are then decided by our own code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: HTML元素没有测量单位的概念。为了支持单位转换，我们添加了自己的数据属性。这些属性允许我们赋予某些元素特殊的含义，其具体内容由我们自己的代码决定。
- en: Our convention is that an element with a `data-measurement` attribute will be
    used to display values and units for the specified measurement. For example, a
    field with the `data-measurement="weight"` attribute will be used to display weight.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的约定是，具有`data-measurement`属性的元素将用于显示指定测量的值和单位。例如，具有`data-measurement="weight"`属性的字段将用于显示重量。
- en: This element contains two types of subelements. The first type has a `data-display-value`
    attribute, and displays the value of the measurement (always a number). The second
    type has a `data-display-unit` attribute, and displays the unit of the measurement
    (for example, `"kg"`). For measurements expressed in multiple units (for example,
    height can be expressed in the form of "5 ft 3 inch"), we can use multiple fields
    of both types.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素包含两种类型的子元素。第一种类型具有`data-display-value`属性，并显示测量的值（始终是一个数字）。第二种类型具有`data-display-unit`属性，并显示测量的单位（例如，`"kg"`）。对于用多个单位表示的测量（例如，高度可以以“5英尺3英寸”的形式表示），我们可以使用两种类型的多个字段。
- en: 'When we change our unit system, `setMeasurementUnits` adds additional data
    attributes to the following elements:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们改变我们的单位制度时，`setMeasurementUnits`会向以下元素添加附加的数据属性：
- en: '`data-round` attributes are attached to `data-measurement` elements'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-round`属性附加到`data-measurement`元素'
- en: '`data-unit attributes` containing the appropriate unit is added to the `data-display-value`
    elements'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向包含适当单位的`data-display-value`元素添加了`data-unit属性`
- en: '`data-display-unit` elements are filled with the appropriate units'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-display-unit`元素填充了适当的单位'
- en: As a result, `$.unitval()` knows both the values and units displayed on every
    measurement element on our page. The function reads and converts the measurement
    to SI before returning it. We do all our calculations using the SI units. Finally,
    when calling `$.unitval(si_value)`, our value is automatically converted to the
    appropriate units before display.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`$.unitval()`知道我们页面上每个测量元素上显示的值和单位。该函数在返回之前读取并将测量转换为SI。我们所有的计算都使用SI单位。最后，当调用`$.unitval(si_value)`时，我们的值会在显示之前自动转换为适当的单位。
- en: This system minimizes the amount of error-prone unit conversion code by recognizing
    that conversions are only really needed when reading user input and displaying
    output. Additionally, the data-driven approach allows us to omit conversions entirely
    from our code and focus on our application logic.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统通过识别只有在读取用户输入和显示输出时才真正需要转换时，最小化了容易出错的单位转换代码的数量。此外，数据驱动的方法允许我们完全从我们的代码中省略转换，并专注于我们的应用逻辑。
- en: Displaying formatted dates in the user's time zone
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在用户的时区中显示格式化的日期
- en: In this recipe, we will learn how to format the user's date in their local time
    zone and display it; additionally, we are going to see how dates are used and
    represented in JavaScript. The best way to do this is to have the user pick the
    time zone in which they would like the dates to be displayed, but unfortunately,
    this is rarely an option.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在用户的本地时区中格式化并显示日期；此外，我们还将看到JavaScript中如何使用和表示日期。最好的方法是让用户选择他们希望日期显示的时区，但不幸的是，这很少是一个选项。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Just like most programming languages, JavaScript uses Unix time. This is actually
    a system for representing a given instance of time, for how many seconds or, in
    JavaScript's case, milliseconds have passed since midnight January 1, 1970 in
    Universal Coordinated Time, commonly known as UTC.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数编程语言一样，JavaScript使用Unix时间。这实际上是一种表示给定时间实例的系统，即自1970年1月1日午夜以来经过了多少秒或在JavaScript的情况下是毫秒，通常称为协调世界时的时间。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some fun trivia regarding UTC: the abbreviation is a compromise between the
    French version Temps Universel Coordonné, which would be TUC, and the English
    version Coordinated Universal Time, which would be CUT ([http://en.wikipedia.org/wiki/Coordinated_Universal_Time#Abbreviation](http://en.wikipedia.org/wiki/Coordinated_Universal_Time#Abbreviation)).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关于UTC的一些有趣的小知识：缩写是法语版本Temps Universel Coordonné和英语版本协调世界时之间的妥协，法语版本将是TUC，英语版本将是CUT。
- en: This number is actually not fully compliant with UTC, nor does it account for
    the various atypical situations such as leap seconds, but this is acceptable in
    most cases.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字实际上并不完全符合UTC，也没有考虑到闰秒等各种非典型情况，但在大多数情况下这是可以接受的。
- en: 'In JavaScript, we have the `Date` object that can be constructed in different
    ways:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们有`Date`对象，可以以不同的方式构造：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that creating a date from a string representation can have different behaviors
    in various browsers, and that the same thing applies for the `Date.parse` method
    that parses a string into a date.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在各种浏览器中，从字符串表示创建日期可能会有不同的行为，`Date.parse`方法解析字符串为日期也是如此。
- en: During construction, if you supply some of the arguments and leave out the optional
    ones, they get defaulted to zero. And one other thing to note is that months in
    JavaScript are zero based while days are not.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造过程中，如果您提供了一些参数并省略了可选参数，它们将默认为零。还有一件事要注意的是，JavaScript中的月份是基于零的，而日期不是。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the JavaScript `Date` object as a function rather than as a constructor,
    with `new Date(...)`, will result in your getting a string representation of that
    date and not getting the `Date` object, like you would expect in most of the other
    JavaScript objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，将`Date`对象作为函数而不是构造函数使用，使用`new Date(...)`，将导致您获得该日期的字符串表示，而不是获得`Date`对象，这与大多数其他JavaScript对象的预期不同。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first thing you need to do is to create the `Date` object:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是创建`Date`对象：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, just use the localized date and time representation:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，只需使用本地化的日期和时间表示：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you need to know the offset in hours in the user''s time zone from UTC,
    you can use the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要知道用户时区与UTC之间的小时偏移量，可以使用以下代码：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This offset variable represents the number of hours from the local user's time
    zone to UTC. The minus sign here reverts the logic for the date; this means that
    the difference will be from date to UTC instead of the original from UTC to date.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此偏移变量表示本地用户时区到UTC的小时数。这里的减号将逻辑反转为日期；这意味着差异将从日期到UTC而不是从UTC到日期。
- en: How it works…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we can usually do is return the millisecond representation from the server
    side and have the number formatted in the local time zone. So let's say that our
    API returned us the milliseconds `1355270400000` that is actually 12.12.2012,
    which is also known as the end-of-the-world date.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以从服务器端返回毫秒表示，并在本地时区中格式化数字。因此，假设我们的API返回了毫秒`1355270400000`，实际上是2012年12月12日，也被称为世界末日日期。
- en: 'The creation of the date is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 日期的创建如下：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When printing in the local string, there are few available options; one of
    them is `toLocaleDateString`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地字符串中打印时，有一些可用的选项；其中之一是`toLocaleDateString`：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method uses the underlying operation system to get the formatting convention.
    For example, in the U.S. the format is month/day/year while in other countries
    it is day/month/year. For our case, the end of the world is on "Wednesday, December
    12, 2012". You could also manually construct the printed date using the appropriate
    `getX` methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用底层操作系统来获取格式约定。例如，在美国，格式为月/日/年，而在其他国家，格式为日/月/年。对于我们的情况，世界末日是在“2012年12月12日星期三”。您还可以使用适当的`getX`方法手动构造打印日期。
- en: There is also a method of printing out the local time called `toLocaleTimeString`
    that can be used on our end-of-the-world date. Because this method also uses the
    operating system's local time for us, it is 01:00:00, because we are in the UTC+1
    time zone. For us, this means that we have one extra hour to live; or maybe not?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种打印本地时间的方法叫做`toLocaleTimeString`，可以用在我们的世界末日日期上。因为这种方法也为我们使用操作系统的本地时间，所以它是01:00:00，因为我们处于UTC+1时区。对我们来说，这意味着我们有一个额外的小时可以活着；或者也许不是？
- en: In order to get the offset for the local user, there is a method in the `Date`
    object called `getTimezoneOffset()` that returns the time zone offset from the
    date to UTC in minutes. The problem is that there is no such method for hours
    and, additionally, it is contraintuitive as we usually want to know the difference
    from UTC to the given date.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取本地用户的偏移量，`Date`对象中有一个名为`getTimezoneOffset()`的方法，它返回日期到UTC的时区偏移量（以分钟为单位）。问题在于没有小时的方法，此外，它是反直觉的，因为我们通常想要知道从UTC到给定日期的差异。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If working with dates is something common that you need for your application,
    it makes sense to use a library, such as **Moment.js** ([http://momentjs.com/](http://momentjs.com/)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理日期是您的应用程序中常见的事情，那么使用一个库是有意义的，比如**Moment.js**（[http://momentjs.com/](http://momentjs.com/)）。
- en: 'Moment.js provides support for internationalization and the more advanced manipulation
    of dates. For example, removing 10 days from the current date can simply be accomplished
    with the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Moment.js提供了对国际化和更高级的日期操作的支持。例如，从当前日期减去10天只需使用以下代码即可完成：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For getting the time from today''s start of day, use the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要从今天的开始时间获取时间，请使用以下代码：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Displaying the dynamic time that has elapsed
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示经过的动态时间
- en: It is very common on every major site to have these great counters that display
    timestamps on various elements on the page. For example, this would be "you opened
    this page 3 hours ago" or "commented 2 minutes ago". That is why, this feature,
    besides the name "dynamic time elapsed", is also known as "time ago".
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个主要网站上，通常都会有这些很棒的计数器，显示页面上各种元素的时间戳。例如，这可能是“您在3小时前打开了此页面”或“2分钟前发表了评论”。这就是为什么，除了名称“动态经过的时间”，这个功能也被称为“时间过去”。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to use a jQuery plugin called **timeago** that has especially been
    designed for this purpose that can be retrieved from [http://timeago.yarp.com/](http://timeago.yarp.com/).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为**timeago**的jQuery插件，专门为此目的设计，可以从[http://timeago.yarp.com/](http://timeago.yarp.com/)获取。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will create a simple page where we will display the passed time by performing
    the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的页面，其中我们将通过执行以下步骤显示经过的时间：
- en: 'Because `timeago` is a jQuery plugin, we first need to include jQuery and then
    add the `timeago` plugin:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`timeago`是一个jQuery插件，我们首先需要包含jQuery，然后添加`timeago`插件：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just as an example, add the following HTML:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 举个例子，添加以下HTML：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will enable us to get an overview of the basic features provided by the
    `timeago` plugin. Afterwards, let''s add the following JavaScript:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将使我们能够对`timeago`插件提供的基本功能有一个概述。之后，让我们添加以下JavaScript：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And that is it; you now have a fully working time example that will calculate
    the time since a given date and update it, and additionally, the second part selected
    with `page-opened` will be autoupdated as the user spends more time on the page.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；现在您有一个完全工作的时间示例，它将计算自给定日期以来的时间并更新它，另外，与`page-opened`选择的第二部分将随着用户在页面上花费更多时间而自动更新。
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first thing you might be wondering is about the `abbr` and `time` tags.
    The first one, in actuality, is a representation of "abbreviation" and optionally
    provides a full description for it. If the full description is present, the `title`
    attribute must contain this full description and nothing else. The full description
    is usually presented as a tool tip in the browsers, but this is a noting standard.
    Why have we picked the `abbr` tag to display time? Well, there is the new HTML5
    time element named `time` that had some controversies surrounding it, as it was
    pulled from the spec but then gotten back. This element is more semantically correct
    and, additionally, represents the date in a machine-readable format that can be
    used by browsers to enable something like the "add to calendar" feature. The rationale
    for the use of the `abbr` element is only supported for older browsers, but this
    becomes more and more irrelevant as time passes. Currently, most modern browsers
    for desktops and mobiles provide support for the semantically correct `time` element—even
    IE 9+ has support for it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道的第一件事是关于`abbr`和`time`标签。实际上，第一个是“缩写”的表示，并且可以选择性地为其提供完整的描述。如果存在完整的描述，`title`属性必须包含此完整描述，而不包含其他内容。完整的描述通常在浏览器中显示为工具提示，但这是一个标准。为什么我们选择`abbr`标签来显示时间？嗯，有一个名为`time`的新的HTML5时间元素，围绕它有一些争议，因为它被从规范中删除，但后来又被重新添加。这个元素在语义上更正确，而且以机器可读的格式表示日期，可以被浏览器用来启用类似“添加到日历”的功能。使用`abbr`元素的理由只支持旧的浏览器，但随着时间的推移，这变得越来越不相关。目前，大多数现代桌面和移动浏览器都支持语义上正确的`time`元素，即使IE
    9+也支持它。
- en: The rest of the HTML consists of standard, well-known tags and a few markers,
    such as different CSS classes added in order to later select those elements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的HTML由标准的、众所周知的标签和一些标记组成，例如为了以后选择这些元素而添加的不同CSS类。
- en: 'Let''s take a look at the JavaScript; first we use the standard jQuery document-ready
    function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看JavaScript；首先我们使用标准的jQuery文档准备好函数：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Afterwards, we set the setting for `allowFuture` to `true` to enable the `timeago`
    plugin to work with future dates, as this has not been set by default:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将`allowFuture`的设置设置为`true`，以启用`timeago`插件与未来日期一起工作，因为这不是默认设置的：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If `timeago` is applied directly on the selected `abbr` or `time` elements,
    there is no need for us to do anything else as the calculations are done automatically:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`timeago`直接应用于选定的`abbr`或`time`元素，则我们无需做任何其他操作，因为计算是自动完成的：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also notice that we can get the text for a given date directly from
    JavaScript, and work with it in whatever way we see fit:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以注意到，我们可以直接从JavaScript中获取给定日期的文本，并以任何我们认为合适的方式处理它：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a few questions that come in mind when working on internationalized
    and localized applications. One of them is time zone support that `timeago` handles
    automatically. The only thing we need to make sure of is that our timestamps follow
    the **ISO 8601** ([http://en.wikipedia.org/wiki/ISO_8601](http://en.wikipedia.org/wiki/ISO_8601))
    time format and have a full time zone designator ([http://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators](http://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators)).
    The other issue that often comes up is language support, but we are mostly covered
    in that area as there are localized versions of the plugin for many languages,
    and you can even create your own version and contribute it to the community. To
    do this, you can use the code hosted on [https://github.com/rmm5t/jquery-timeago/tree/master/locales](https://github.com/rmm5t/jquery-timeago/tree/master/locales).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理国际化和本地化应用程序时，会有一些问题。其中之一是`timeago`自动处理的时区支持。我们唯一需要确保的是我们的时间戳遵循**ISO 8601**（[http://en.wikipedia.org/wiki/ISO_8601](http://en.wikipedia.org/wiki/ISO_8601)）时间格式，并具有完整的时区标识符（[http://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators](http://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators)）。另一个经常出现的问题是语言支持，但在这方面我们大多数都有覆盖，因为有许多语言的本地化版本的插件，甚至您可以创建自己的版本并贡献给社区。要做到这一点，您可以使用[https://github.com/rmm5t/jquery-timeago/tree/master/locales](https://github.com/rmm5t/jquery-timeago/tree/master/locales)上托管的代码。
- en: There are a few other implementations that perform a similar job, like for example,
    *pretty date* by *John Resig* available at his blog at [http://ejohn.org/blog/javascript-pretty-date/](http://ejohn.org/blog/javascript-pretty-date/).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他执行类似工作的实现，例如*John Resig*的*pretty date*，可以在他的博客[http://ejohn.org/blog/javascript-pretty-date/](http://ejohn.org/blog/javascript-pretty-date/)上找到。
- en: Displaying Math
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示数学
- en: When it comes to technical writing, we often want to display mathematical formulas
    inside the page. In the past, this was done by creating an image on the server
    from some kind of markup, or even manually creating an image with an external
    program. Since the introduction of MathML, this is no longer needed; this thereby
    saves us time, which was otherwise spent on sorting out layout issues, and enables
    native support from the browsers for the display of equations. At the time of
    writing this book, not all of the major browsers support MathML, even though the
    spec for most of the features has been available for a few years now.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术写作方面，我们经常希望在页面内显示数学公式。过去，这是通过在服务器上从某种标记创建图像来完成的，甚至是手动使用外部程序创建图像。自MathML引入以来，这就不再需要了；这样可以节省我们在解决布局问题上的时间，并使浏览器原生支持显示方程式。在撰写本书时，尽管大多数功能的规范已经可用了几年，但并非所有主要浏览器都支持MathML。
- en: '![Displaying Math](img/9282OT_01_01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: 显示数学
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '**Mathematical Markup Language** (**MathML**) is a standardized way for an
    application to describe a formula, and is intended not only to enable integration
    for the Web, but also to be used in other applications.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学标记语言**（**MathML**）是一种应用程序描述公式的标准化方式，不仅旨在实现Web集成，还可用于其他应用程序。'
- en: There is a list of software that uses MathML maintained by the W3C; it can be
    found at [http://www.w3.org/Math/Software/](http://www.w3.org/Math/Software/).
    Few revisions of the specification are done from the working group ([http://www.w3.org/Math/](http://www.w3.org/Math/)),
    with the latest being number 3 ([http://www.w3.org/TR/MathML3/](http://www.w3.org/TR/MathML3/)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: W3C维护了一个使用MathML的软件列表；可以在[http://www.w3.org/Math/Software/](http://www.w3.org/Math/Software/)找到。规范的几个修订是由工作组完成的（[http://www.w3.org/Math/](http://www.w3.org/Math/)），最新的是第3版（[http://www.w3.org/TR/MathML3/](http://www.w3.org/TR/MathML3/)）。
- en: HTML5 adds the support for embedding MathML documents inside HTML.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5增加了在HTML内嵌入MathML文档的支持。
- en: What we are going to do in this recipe is describe a formula, as shown in the
    previous continued fraction of Pi, with MathML where we have an example of a different
    representation of the number *π*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们要描述一个公式，如前面π的连分数，使用MathML，其中我们有一个不同表示*π*的示例。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will be using a library called `MathJax` that can either be retrieved from
    the author's CDN or downloaded separately and included in the project.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`MathJax`的库，可以从作者的CDN检索，也可以单独下载并包含在项目中。
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can proceed by adding the MathML example as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过添加以下MathML示例来继续：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The basics on what the elements mean will be explained later, but you can notice
    that the example becomes really big after very few nesting levels and is hard
    to read. This is because MathML was never intended to be created manually, but
    to be used instead as a format by some application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的基本含义将在后面解释，但您可以注意到，示例在很少的嵌套级别后变得非常庞大，很难阅读。这是因为MathML从未打算手动创建，而是作为某些应用程序的格式来使用。
- en: 'So what are the real simple options for us if we want to enable human-editable
    markup? Well, the simplest possible option is something called `ASCIIMath`; in
    order to enable it, we need to change the `config` parameter in the request:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，如果我们想启用可编辑的标记，对我们来说真正简单的选项是什么？嗯，最简单的选择是一种称为`ASCIIMath`的东西；为了启用它，我们需要改变请求中的`config`参数：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We generally use the version with all the possible input formats and rendering
    options, but that way we would have a problem with the size of the JavaScript
    file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们使用所有可能的输入格式和呈现选项的版本，但这样我们会遇到JavaScript文件大小的问题。
- en: 'So how much simpler is the use of `ASCIIMath`? Well, the expression we explained
    previously can be displayed with a single line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用`ASCIIMath`有多简单呢？嗯，我们之前解释的表达式可以用一行显示：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the the expression is encompassed in a [PRE37]" or the Grave accent
    character will get rendered to HTML and CSS or any other rendering method that
    has been configured.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，表达式包含在[P37]"中，否则重音字符将被呈现为HTML和CSS或任何其他已配置的呈现方法。
- en: There's more...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ASCIIMath` method is very simple and extremely popular with major websites
    such as Khan Academy ([https://www.khanacademy.org/](https://www.khanacademy.org/))
    and Math StackExchange ([http://math.stackexchange.com/](http://math.stackexchange.com/)).
    If you are interested to get more details on how `ASCIIMath` can be used, you
    can get more info on its official web page at [http://www1.chapman.edu/~jipsen/mathml/asciimath.html](http://www1.chapman.edu/~jipsen/mathml/asciimath.html).
    Using `MathJax` you can also render other markup format languages such as Tex
    and Latex.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ASCIIMath`方法非常简单，并且在Khan Academy（[https://www.khanacademy.org/](https://www.khanacademy.org/)）和Math
    StackExchange（[http://math.stackexchange.com/](http://math.stackexchange.com/)）等主要网站上非常受欢迎。如果您有兴趣了解如何使用`ASCIIMath`，可以在其官方网页[http://www1.chapman.edu/~jipsen/mathml/asciimath.html](http://www1.chapman.edu/~jipsen/mathml/asciimath.html)上获取更多信息。使用`MathJax`，您还可以呈现其他标记格式语言，如Tex和Latex。'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Tex is a typesetting format made by *Donald Knuth* for the purpose of helping
    him with the writing of his famous books. Latex, on the other hand, is a document
    markup that uses Tex as the typesetting format. More information on them can be
    found at [http://en.wikipedia.org/wiki/TeX](http://en.wikipedia.org/wiki/TeX)
    and [http://www.latex-project.org/](http://www.latex-project.org/).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Tex是由*Donald Knuth*制作的排版格式，目的是帮助他撰写他的著名书籍。另一方面，Latex是一种使用Tex作为排版格式的文档标记。有关它们的更多信息可以在[http://en.wikipedia.org/wiki/TeX](http://en.wikipedia.org/wiki/TeX)和[http://www.latex-project.org/](http://www.latex-project.org/)上找到。
- en: Creating an endless scrolling list
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个无限滚动列表
- en: Endless scrolling lists were popularized by social networking websites, such
    as Facebook and Twitter. Their goal is to create the illusion that the entire
    available content has already been loaded. Additionally, with this technique,
    interruptions to the normal scrolling that are caused by the user trying to find
    the button for the next page are avoided.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动列表是由社交网络网站（如Facebook和Twitter）推广的。它们的目标是营造整个可用内容已经加载的假象。此外，通过这种技术，用户试图找到下一页按钮而导致的正常滚动中断可以避免。
- en: At the same time, we would also want to avoid unnecessary waste of bandwidth;
    this means that loading the whole set of data at once is not an option.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们也希望避免不必要的带宽浪费；这意味着一次加载整套数据不是一个选择。
- en: The solution is to monitor the user's scrolling and detect the approach at the
    bottom of the page. When the user is sufficiently close to the bottom, we can
    automatically load the next page of content by appending it to the end of the
    currently shown content.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是监视用户的滚动并检测页面底部的接近。当用户足够接近底部时，我们可以通过将其附加到当前显示内容的末尾来自动加载下一页的内容。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must already have a service that provides the content on a page-by-page
    basis. This example works without such a service by default, but to make it fully
    functional, an actual HTTP server is needed in order for the Ajax requests for
    the next page to work.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须已经有一个按页面提供内容的服务。此示例默认情况下可以工作，但要使其完全功能，需要一个实际的HTTP服务器，以便Ajax请求下一页的工作。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the HTML page, CSS style, and JavaScript code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML页面、CSS样式和JavaScript代码。
- en: Create a file named `index.html` that will contain the full HTML, CSS, and JavaScript
    code of our example. We need to insert a DOCTYPE into our HTML document; otherwise,
    the browser will operate in "quirks mode" and the height measurement function
    `$(window).height()` will not work.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的文件，其中包含我们示例的完整HTML、CSS和JavaScript代码。我们需要在HTML文档中插入一个DOCTYPE；否则，浏览器将以“怪癖模式”运行，高度测量函数`$(window).height()`将无法工作。
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ll add a content placeholder element in the page:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在页面中添加一个内容占位符元素：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For demonstration purposes, we''ll add the following CSS code to make the pages
    visible. Feel free to skip this CSS:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将添加以下CSS代码以使页面可见。可以跳过这个CSS：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we add the JavaScript code. First we load jQuery:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加JavaScript代码。首先加载jQuery：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we can add our script:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以添加我们的脚本：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our page getter calls the callback with a null error argument and a simple string
    containing the page number as the content (for example, `Page 1`), but it can
    also perform an Ajax request. See the following code for more info on how to modify
    it to make an Ajax request.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面获取器使用null错误参数和一个简单的包含页面编号的字符串（例如`Page 1`）来调用回调函数，但它也可以执行Ajax请求。有关如何修改它以进行Ajax请求的更多信息，请参见以下代码。
- en: 'This function is artificially limited to 10 pages of content. After the tenth
    page, the callback function is called with an error, indicating that there are
    no more pages available:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数人为地限制了10页的内容。第十页后，回调函数将带有错误调用，表示没有更多可用页面：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We use `triggerPxFromBottom` to specify when to start loading the next page.
    When only `triggerPxFromBottom` pixels remain to be scrolled, the loading of the
    next page will begin. Its value is set to `0`; this means that the user must reach
    the end of the currently visible page to trigger the loading process:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`triggerPxFromBottom`来指定何时开始加载下一页。当只剩下`triggerPxFromBottom`像素要滚动时，将开始加载下一页。它的值设置为`0`；这意味着用户必须到达当前可见页面的末尾才能触发加载过程：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`loadNext` appends the next page into the `#content` div. However, if the callback
    function is called with an error, it will display `No more content` below the
    last part of the page. After an error event, no more pages will be loaded. This
    means that when `getPage` returns an error, our code will stop loading new pages.
    This is the desired behavior:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loadNext`将下一页附加到`#content` div中。但是，如果回调函数带有错误调用，它将在页面的最后部分下方显示`没有更多内容`。错误事件发生后，将不再加载更多页面。这意味着当`getPage`返回错误时，我们的代码将停止加载新页面。这是期望的行为：'
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This event handler is called when the page is scrolled in any way. It calculates
    the number of pixels of scrolling that remain below. If the number of the pixels
    is small enough and the code is not currently loading a page, it calls the page-loading
    function:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面以任何方式滚动时，将调用此事件处理程序。它计算剩余的滚动像素数。如果像素数足够小且代码当前未加载页面，则调用页面加载函数：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we call `loadNext()` for the first time to load the first page:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们第一次调用`loadNext()`来加载第一页：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The visible area of the browser (also called the viewport) has its own dimensions
    that can be fetched by calling jQuery's `$.fn.height()` function on the `$(window)`
    object. On the other hand, `$(document).height()` provides us with the height
    of the entire content of the page. Finally, `$(window).scrollTop()` gives us the
    scroll offset.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的可见区域（也称为视口）具有自己的尺寸，可以通过调用jQuery的`$.fn.height()`函数来获取`$(window)`对象的高度。另一方面，`$(document).height()`为我们提供页面整个内容的高度。最后，`$(window).scrollTop()`给出滚动偏移量。
- en: Using these functions, we can calculate the remaining pixels to be scrolled.
    Then we recalculate and check this value every time the user scrolls the page.
    If the value is sufficiently small, we call our loading function. At the same
    time, we make sure to stop loading new pages until the current loading process
    is finished. (Otherwise, the user's scrolling actions might load a couple of more
    pages while they wait for the content to load.)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，我们可以计算剩余需要滚动的像素。然后，我们在用户滚动页面时重新计算和检查这个值。如果值足够小，我们调用我们的加载函数。同时，我们确保在当前加载过程完成之前停止加载新页面。（否则，用户的滚动操作可能会在等待内容加载时加载更多页面。）
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a possible Ajax implementation of the `getPage` function. This function
    sends Ajax requests to a request handler hosted on the same domain at the path
    `/pages/<number>` to retrieve the HTML contents of the next page:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`getPage`函数的一个可能的Ajax实现。该函数向在相同域上托管的请求处理程序发送Ajax请求，路径为`/pages/<number>`，以检索下一页的HTML内容：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To make this version work, you will need to implement the request handler in
    your server-side code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此版本工作，您需要在服务器端代码中实现请求处理程序。
- en: Your server-side code can return an error, such as 404, to indicate that there
    is no more content available. As a result, jQuery will never call our success
    callback, and our code will stop loading new pages.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务器端代码可以返回错误，比如404，表示没有更多的内容可用。因此，jQuery永远不会调用我们的成功回调，我们的代码将停止加载新页面。
- en: The endless scrolling list recipe provides great user experience, but it has
    one significant drawback. We must make sure that we don't have any important page
    content below the `contents` element. This means that page elements placed at
    the bottom (usually the footer links and copyright messages) might become unreachable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动列表配方提供了很好的用户体验，但它有一个重大缺点。我们必须确保`contents`元素下面没有重要的页面内容。这意味着放在底部的页面元素（通常是页脚链接和版权信息）可能无法到达。
- en: Creating a sortable paginated table
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可排序的分页表
- en: One of the most common tasks we encounter when creating websites is displaying
    lists and tables. Most techniques focus on server-side sorting, paging, and the
    rendering of data. Our solution will be completely on the client side, suitable
    for small to medium amounts of data. The main benefit of a client-side solution
    is speed; sorting and switching pages will be nearly instantaneous.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建网站时，我们遇到的最常见任务之一是显示列表和表格。大多数技术都侧重于服务器端的排序、分页和数据呈现。我们的解决方案完全在客户端，适用于小到中等数量的数据。客户端解决方案的主要好处是速度；排序和切换页面将几乎是瞬间完成的。
- en: In this recipe, we're going to create a client-side, sortable paginated table.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个客户端可排序的分页表。
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We assume that a service provides the data in a JSON object, containing a `data`
    property that is an array of arrays:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设一个服务以JSON对象的形式提供数据，其中包含一个`data`属性，该属性是一个数组的数组：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In our example, we're going to display a list of people near us. Every person
    in the table will have their own ID number, name, age, distance from us, and transportation
    method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将显示附近的人员列表。表中的每个人都有自己的ID号码、姓名、年龄、与我们的距离和交通方式。
- en: We're going to display the distance in km, and would like to be able to sort
    the list of people by their last names.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以公里为单位显示距离，并希望能够按姓氏对人员列表进行排序。
- en: As table display problems quickly grow beyond the original simple problem, we're
    not going to build our own solution. Instead, we're going to use the excellent
    jQuery DataTables plugin available at [http://datatables.net/](http://datatables.net/).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 随着表格显示问题迅速超出最初的简单问题，我们不打算构建自己的解决方案。相反，我们将使用可在[http://datatables.net/](http://datatables.net/)上获得的出色的jQuery
    DataTables插件。
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the HTML page, CSS style, and JavaScript code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML页面、CSS样式和JavaScript代码。
- en: 'First, we''re going to create an HTML page containing an empty table. We''re
    also going to add some CSS to import a basic DataTables style for the table. The
    stylesheets are normally available with the DataTables distribution. Our `index.html`
    file is as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个包含空表的HTML页面。我们还将添加一些CSS来导入表的基本DataTables样式。样式表通常随DataTables分发。我们的`index.html`文件如下：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The example includes a link to the minified version of DataTables hosted on
    the official website.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括一个链接到官方网站上托管的DataTables的缩小版本。
- en: The DataTables plugin appends the `pager` and `info` elements below the table.
    Because of this, we need to wrap our table inside a `container` element.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: DataTables插件在表格下方附加了`pager`和`info`元素。因此，我们需要将表格包装在一个`container`元素内。
- en: 'And the `example.js` file is as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`example.js`文件如下：'
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The implementation of `fetchData` in the example provides hardcoded example
    data. You can easily replace it with a request to your service. The `setData`
    function is a convenient function to change the table data—we're going to use
    the same script, which will call this function to set its own data, for multiple
    recipes. Finally, the rest of the code is specific to DataTables and will be explained
    in the next section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中`fetchData`的实现提供了硬编码的示例数据。您可以轻松地将其替换为对您的服务的请求。`setData`函数是一个方便的函数，用于更改表数据——我们将使用相同的脚本，该脚本将调用此函数来设置其自己的数据，用于多个示例。最后，其余的代码是特定于DataTables，并将在下一节中进行解释。
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following image shows the resulting table:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了生成的表格：
- en: '![How it works...](img/9282OT_01_02.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_01_02.jpg)'
- en: To initialize the table we use the `dataTable` initialization function. We can
    pass multiple options to the function. For example, we can specify that we want
    10 items per page by setting the value of the `iDisplayLength` property to `10`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化表格，我们使用`dataTable`初始化函数。我们可以将多个选项传递给函数。例如，我们可以通过将`iDisplayLength`属性的值设置为`10`来指定每页10个项目。
- en: Because we're going to render the **Distance** column (column 3) slightly differently
    than just displaying it, we add an item to the `aoColumnDefs` option for target
    column 3 that sets a custom rendering function for that column. This is a function
    that simply appends the `km` string to our number; but we could also use a more
    elaborate function (involving custom date formatting, unit conversions, and so
    on).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要对**Distance**列（第3列）进行稍微不同于仅显示的渲染，所以我们在`aoColumnDefs`选项中为目标列3添加了一个项目，为该列设置了一个自定义渲染函数。这是一个简单地将`km`字符串附加到我们的数字的函数；但我们也可以使用更复杂的函数（涉及自定义日期格式化、单位转换等）。
- en: Paging works automatically with DataTables—the plugin appends a pager control
    that provides access to the previous/next page. Sorting also mostly works automatically.
    However, in our particular example, we need special sorting for the **Name** column
    (by last name) even though it's displayed in the format "firstname lastname".
    To do this, we specify a custom sort type for that column called `lastname-sort`.
    We also specify a special sort type for the **Distance** column called `unitnumber`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 分页在DataTables中自动工作——插件附加了一个分页控件，提供对上一页/下一页的访问。排序也大部分自动工作。然而，在我们的特定示例中，尽管**Name**列以"firstname
    lastname"的格式显示，但我们需要对其进行特殊排序（按姓氏）。为此，我们为该列指定了一个名为`lastname-sort`的自定义排序类型。我们还为**Distance**列指定了一个特殊的排序类型，称为`unitnumber`。
- en: 'DataTables allows us to define custom sort types as plugins. Custom sorters
    have the following properties:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: DataTables允许我们定义自定义排序类型作为插件。自定义排序器具有以下属性：
- en: A preprocessing function that pre-processes the column value before passing
    it to the sorter
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将其传递给排序器之前，对列值进行预处理的预处理函数
- en: 'An ascending sorting function that returns a value depending on the value of
    the two arguments that are passed: -1 if the first value is smaller, 0 if they
    are equal, or 1 if the first value is larger'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个升序排序函数，根据传递的两个参数的值返回一个值：如果第一个值较小，则返回-1，如果它们相等，则返回0，如果第一个值较大，则返回1
- en: A descending order sorting function that works similarly to the ascending sorting
    function
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与升序排序函数类似的降序排序函数
- en: These properties allow us to implement sorting by last name for the **Name**
    column, as well as by number for the **Distance** column.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性使我们能够按照**Name**列的姓氏进行排序，以及按照**Distance**列的数字进行排序。
- en: There's more...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a simple Ajax replacement of the `fetchData` function, sending an Ajax
    request to a request handler hosted on the same domain at the path `/people` to
    retrieve the array data:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`fetchData`函数的一个简单Ajax替代，向托管在同一域上路径为`/people`的请求处理程序发送一个Ajax请求以检索数组数据：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that this solution doesn't work very well for large datasets. While modern
    clients have the performance to manipulate a lot of data, bandwidth is also a
    consideration. A careful consideration of bandwidth requirements and the target
    clients (desktop or mobile) should be exercised before using this solution.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种解决方案对于大型数据集效果不佳。虽然现代客户端具有处理大量数据的性能，但带宽也是一个考虑因素。在使用此解决方案之前，应仔细考虑带宽要求和目标客户端（桌面或移动）。
- en: Creating multiple-choice filters
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多选过滤器
- en: One common task when displaying tables is to filter the data in the table to
    a subset that satisfies a certain criteria. Multiple-choice table filters work
    on columns with a finite number of values. For example, if we had a table containing
    data of some people where one column is the transportation method used by the
    person, the filter used on this column would be a multiple-choice filter. The
    user should be able to select one or more transportation methods, and the table
    view would display all the people that are using the selected methods.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示表格时的一个常见任务是将表格中的数据过滤为满足某些条件的子集。多选表格过滤器适用于具有有限数量值的列。例如，如果我们有一个包含某些人的数据的表，其中一列是人员使用的交通方式，则在该列上使用的过滤器将是多选过滤器。用户应该能够选择一个或多个交通方式，表视图将显示所有使用所选方式的人员。
- en: Getting ready
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We're going to assume that we're using the code and data from the previous recipe.
    We have a list of people with their transportation methods displayed in a sortable,
    paginated table using the DataTables jQuery plugin. We will copy the files from
    the previous recipe, and then add to them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设我们正在使用上一个示例中的代码和数据。我们有一个人员列表，他们的交通方式显示在一个可排序、分页的表中，使用DataTables jQuery插件。我们将复制上一个示例中的文件，然后对其进行补充。
- en: The data that we need to filter is already available in the `tableData` global
    variable; we can filter this data and then use the global `tableSetData` function
    to display the filtered table.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要过滤的数据已经在`tableData`全局变量中可用；我们可以过滤这些数据，然后使用全局的`tableSetData`函数来显示过滤后的表格。
- en: The filter is going to work on the **Transportation** field.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤将在**交通**字段上进行。
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s modify the previous code to add multiple-choice filters to our table:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一个代码，向我们的表格添加多选过滤器：
- en: 'In the `index.html` file from the previous recipe, add a multiple-choice select
    list after the opening `<body>` tag:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个配方的`index.html`文件中，在开头的`<body>`标签后添加一个多选选择列表：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add a script element for `filter.js` before the closing `</body>` tag:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭`</body>`标签之前为`filter.js`添加一个脚本元素：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''re also going to modify the `fetchData` call at the end of `example.js`
    to trigger a custom event notifying any observers that the data has been fetched
    and set:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将修改`example.js`末尾的`fetchData`调用，以触发自定义事件，通知任何观察者数据已经被获取并设置：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The code is wrapped to be executed after the page is loaded in order for event
    triggering to work. Before the page load, no events can be triggered.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被包装以在页面加载后执行，以便事件触发工作。在页面加载之前，无法触发任何事件。
- en: 'Create a file named `filter.js` and add the following code:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`filter.js`的文件，并添加以下代码：
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The easiest way to implement a user interface for a multiple-choice filter is
    to use a multiple-choice select element.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 实现多选过滤器的最简单方法是使用多选选择元素。
- en: We also need to populate the element when the data becomes available. To do
    this, we trigger our new custom event `table:data` after fetching the data (either
    from our server or otherwise). The listener extracts the unique values from the
    **Transportation** column of the data and populates the select list with options
    for the values.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据可用时，我们还需要填充元素。为此，我们在获取数据后触发我们的新自定义事件`table:data`。监听器从数据的**交通**列中提取唯一值，并用这些值为选择列表添加选项。
- en: When the selection changes, we extract the selected values (as an array) and
    create a new filter function using `choiceFilter`, a higher-order function. The
    higher-order function returns a new filtering function. This filtering function
    takes a table row argument and returns `true` if the value of the fourth column
    of that row is contained within the specified list.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择发生变化时，我们提取所选值（作为数组），并使用`choiceFilter`创建一个新的过滤函数，这是一个高阶函数。高阶函数返回一个新的过滤函数。这个过滤函数接受一个表行参数，并在该行的第四列的值包含在指定列表中时返回`true`。
- en: The filtering function is passed to `Array.filter`; it applies this function
    to every row and returns an array containing only the rows for which the filtering
    function returns `true`. The filtered data is then displayed instead of the original
    data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤函数被传递给`Array.filter`；它将此函数应用于每一行，并返回一个仅包含过滤函数返回`true`的行的数组。然后显示过滤后的数据，而不是原始数据。
- en: Creating range filters
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建范围过滤器
- en: Tables can also be filtered by their numerical columns. For example, given a
    table where each row is a person and one of the columns contain data about the
    person's age, we might need to filter this table by specifying the age range.
    To do this, we use range filters.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 表格也可以通过其数字列进行过滤。例如，给定一个表格，其中每一行都是一个人，其中一列包含有关该人年龄的数据，我们可能需要通过指定年龄范围来过滤该表格。为此，我们使用范围过滤器。
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We're going to assume that we're using the code and data from the *Creating
    a sortable paginated table* recipe. We have a list of people with their age displayed
    in a sortable, paginated table using the DataTables jQuery plugin. We will copy
    the files from the recipe and then add some extra filtering code.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设我们正在使用*创建可排序的分页表*配方中的代码和数据。我们有一个人员名单，他们的年龄显示在一个可排序的分页表中，使用DataTables jQuery插件。我们将从配方中复制文件，然后添加一些额外的过滤代码。
- en: The data that we need to filter is already available in the `tableData` global
    variable; we can filter this data and then use the `tableSetData` global function
    to display the filtered table.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要过滤的数据已经在`tableData`全局变量中可用；我们可以过滤这些数据，然后使用`tableSetData`全局函数来显示过滤后的表格。
- en: The filter is going to work on the **Age** field.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤将在**年龄**字段上进行。
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s modify the previous code to add range filters to our table:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一个代码，向我们的表格添加范围过滤器：
- en: 'In the `index.html` file from the previous recipe, add two input elements after
    the opening `<body>` tag:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个配方的`index.html`文件中，在开头的`<body>`标签后添加两个输入元素：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add a script element for `filter.js` before the closing `</body>` tag:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭`</body>`标签之前为`filter.js`添加一个脚本元素：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we create our `filter.js` script:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的`filter.js`脚本：
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The easiest way to filter array data is to use JavaScript's built-in `Array.filter`
    function. This is a higher-order function; its first argument is a function that
    takes a row argument and returns `true` if the row is to be added to the filtered
    array or `false` if the row is to be left out.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤数组数据的最简单方法是使用JavaScript内置的`Array.filter`函数。这是一个高阶函数；它的第一个参数是一个函数，它接受一个行参数，并在行应该添加到过滤后的数组时返回`true`，或者在行应该被排除时返回`false`。
- en: To provide such a function, we create our own higher-order function. It takes
    the start and end ranges and the specified column. The return result is a function
    that filters every row.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这样的功能，我们创建自己的高阶函数。它接受开始和结束范围以及指定的列。返回结果是一个过滤每一行的函数。
- en: To ignore empty or invalid values from the input, we use the number function.
    If the input field is empty or contains non-number data, a default value is provided
    (`-Infinity` for the start of the range and `+Infinity` for the end). This also
    enables us to do one-sided range filtering.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了忽略输入中的空值或无效值，我们使用`number`函数。如果输入字段为空或包含非数字数据，则提供默认值（范围的开始为`-Infinity`，结束为`+Infinity`）。这也使我们能够进行单侧范围过滤。
- en: The `Array.filter` function returns an array of all the elements that pass the
    filter. We display this array in our table.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.filter`函数返回通过过滤器的所有元素的数组。我们在表格中显示这个数组。'
- en: Creating combined complex filters
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组合复杂过滤器
- en: When displaying tables, we sometimes want to filter table elements using multiple
    criteria involving multiple columns. For example, given a table of people that
    contains information such as their name, age, and transportation method, we might
    only want to view the people older than 30 that use a bus for transportation.
    We might also want to filter people by name. To do this, we have to apply multiple
    filters, such as an age range filter, a multiple-choice filter, and a text filter,
    to the data at the same time. The easiest way to do this is to make a filter combination
    function.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示表格时，我们有时希望使用涉及多个列的多个条件来过滤表格元素。例如，给定一个包含人员信息的人员表，例如他们的姓名、年龄和交通方式，我们可能只想查看年龄大于30岁且使用公交车交通的人。我们可能还想按姓名过滤人员。为此，我们必须同时对数据应用多个过滤器，例如年龄范围过滤器、多选过滤器和文本过滤器。这样做的最简单方法是创建一个过滤器组合函数。
- en: Getting ready
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We're going to assume that we're using the code from the *Creating a sortable
    paginated table* recipe, and we're going to add our filters as described in the
    previous two recipes. This time we're going to allow for the combination of filters.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们正在使用*创建可排序的分页表*配方中的代码，并且我们将根据前两个配方中描述的方式添加我们的过滤器。这次我们将允许组合过滤器。
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s modify the previous code to add multiple filters to our table:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的代码，向我们的表格添加多个过滤器：
- en: 'We''re going to add filter-related inputs to our page after the opening `<body>`
    tag:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开头的`<body>`标签后，我们将在页面中添加与过滤相关的输入：
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add the `filter.js` script before the closing `</body>` tag:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭`</body>`标签之前添加`filter.js`脚本：
- en: '[PRE61]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We''re going to modify `example.js` to fetch data after the page is loaded
    and trigger a `table:data` event after displaying the data:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改`example.js`，在页面加载后获取数据并在显示数据后触发`table:data`事件：
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then we can create `filter.js` by combining the code from the previous two
    recipes:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以通过组合前两个配方中的代码来创建`filter.js`：
- en: '[PRE63]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Like in the previous recipes, we use the `Array.filter` function to filter the
    table. This time we apply multiple filters in succession. We store all of the
    filter functions in an array.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方一样，我们使用`Array.filter`函数来过滤表格。这次我们连续应用多个过滤器。我们将所有过滤函数存储在一个数组中。
- en: Whenever there is a change in the inputs, we update the appropriate filter function
    and rerun `filterAndShow()` to display the filtered data.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 每当输入发生变化时，我们更新适当的过滤函数，并重新运行`filterAndShow()`来显示过滤后的数据。
- en: There's more...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: DataTables is a highly flexible table library with many options and a rich API.
    More information and examples can be found on the official website at [http://www.datatables.net/](http://www.datatables.net/).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: DataTables是一个高度灵活的表格库，具有许多选项和丰富的API。更多信息和示例可以在官方网站[http://www.datatables.net/](http://www.datatables.net/)上找到。
- en: Displaying code in HTML
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTML中显示代码
- en: There is a common need to display code in HTML or even to display HTML code
    inside HTML, especially in technical documentation or blogs. This has been done
    far too many times by taking an image from a piece of formatted code and making
    it part of the page. The code in the image will probably not get picked up by
    search engines. Additionally, it can limit us to a specific page layout or even
    screen size, and with today's mobile revolution, that is just not an option.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中显示代码或甚至在HTML中显示HTML代码是一种常见需求，特别是在技术文档或博客中。这已经做过太多次，通过从格式化代码中获取图像并将其作为页面的一部分。图像中的代码可能不会被搜索引擎捕捉到。此外，它可能限制我们到特定的页面布局或屏幕尺寸，而在今天的移动革命中，这不是一个选择。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The only requirement for this recipe is that the data that will be displayed
    needs to be properly escaped; this means that `<p>awesome </p>` needs to be translated
    into `&lt;p&gt;awesome &lt;/p&gt;`. This can be done either on the server side
    or escaped before saving.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的唯一要求是要显示的数据需要被正确转义；这意味着`<p>awesome </p>`需要被转换为`&lt;p&gt;awesome &lt;/p&gt;`。这可以在服务器端完成，也可以在保存之前进行转义。
- en: How to do it...
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will be using **Google code prettify** because, at the time of speaking,
    this library is not available completely on any of the CDN's; you can get it from
    [http://code.google.com/p/google-code-prettify/](http://code.google.com/p/google-code-prettify/).
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用**Google代码美化**，因为在发言时，这个库在任何CDN上都不完全可用；你可以从[http://code.google.com/p/google-code-prettify/](http://code.google.com/p/google-code-prettify/)获取它。
- en: 'Afterwards, we can add the escaped code in the `<pre /> <code />` block:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以在`<pre /> <code />`块中添加转义代码：
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Either one of these two tags has to include the `prettyprint` CSS class. In
    addition to that, we need to include the `onload="prettyPrint()"` attribute.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个标签中的任何一个都必须包含`prettyprint` CSS类。除此之外，我们还需要包含`onload="prettyPrint()"`属性。
- en: 'There is also the option to call the `prettyPrint` function from other event
    listeners added in JavaScript:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个选项，可以从JavaScript中添加的其他事件监听器中调用`prettyPrint`函数：
- en: '[PRE65]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works…
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `prettyprint` class automatically selects all the blocks marked with the
    appropriate CSS class, and autodetects the programming language used, and does
    the highlighting afterwards.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`prettyprint`类会自动选择所有标记有适当CSS类的块，并自动检测所使用的编程语言，然后进行高亮显示。'
- en: The lexer should work on most languages; in the common languages there are custom
    scripts for specific languages, for example, for the lisp-based ones.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器应该适用于大多数语言；在常见语言中，有特定语言的自定义脚本，例如基于lisp的语言。
- en: There's more…
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Because `prettyprint` automatically detects the source language, we could additionally
    specify it ourselves if we want to get better results. For example, if we wanted
    to display XML, the code would be as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`prettyprint`自动检测源语言，如果我们想要获得更好的结果，我们可以自行指定。例如，如果我们想要显示XML，代码将如下所示：
- en: '[PRE66]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There are CSS classes for most of the common languages.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常见语言都有CSS类。
- en: '`prettyprint` is one of the older scripts available, and there are few alternatives
    that can offer many more customization options and better JavaScript APIs.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`prettyprint`是其中一个较旧的可用脚本，还有一些替代方案可以提供更多的自定义选项和更好的JavaScript API。'
- en: Some of them, such as **SyntaxHighliger** ([http://alexgorbatchev.com/SyntaxHighlighter/](http://alexgorbatchev.com/SyntaxHighlighter/)),
    **Rainbow** ([http://craig.is/making/rainbows](http://craig.is/making/rainbows)),
    and **Highlight.js** ([http://softwaremaniacs.org/soft/highlight/en/](http://softwaremaniacs.org/soft/highlight/en/)),
    are commonly found on most of the sites.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些，如**SyntaxHighliger** ([http://alexgorbatchev.com/SyntaxHighlighter/](http://alexgorbatchev.com/SyntaxHighlighter/))，**Rainbow**
    ([http://craig.is/making/rainbows](http://craig.is/making/rainbows))，和**Highlight.js**
    ([http://softwaremaniacs.org/soft/highlight/en/](http://softwaremaniacs.org/soft/highlight/en/))，通常可以在大多数网站上找到。
- en: Rendering Markdown
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染Markdown
- en: Markdown is a popular, lightweight markup language. The language is similar
    to Wiki markup (used on Wikipedia), with an emphasis on simplicity. Its main purpose
    is to enable users to write plain text and get stylized, formatted HTML output.
    As such, it is used by popular websites, such as Reddit, Stack Overflow, GitHub,
    as well as various forums as a replacement of the less intuitive BBCode format.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown是一种流行的轻量级标记语言。这种语言类似于维基标记（在维基百科上使用），强调简单性。它的主要目的是让用户编写纯文本并获得格式化的HTML输出。因此，它被流行的网站使用，如Reddit、Stack
    Overflow、GitHub，以及各种论坛，作为不太直观的BBCode格式的替代品。
- en: Markdown is the fastest way to enable formatted text input for our users without
    embedding a full-fledged HTML editor into the page. There are multiple libraries
    to render markdown; in this recipe, we're going to use the simple `markdown-js`
    script to render markdown in real time.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown是为我们的用户启用格式化文本输入的最快方式，而无需将完整的HTML编辑器嵌入页面。有多个库可以渲染markdown；在这个示例中，我们将使用简单的`markdown-js`脚本来实时渲染markdown。
- en: How to do it...
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Rendering markdown is very simple. A minimal example is as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染markdown非常简单。一个最简单的例子如下：
- en: '[PRE67]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the page is loaded, the markdown text in the `textarea` element is rendered
    into the #`render` element on the right-hand side. Every key press will also cause
    the script to update the rendered element.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，`textarea`元素中的markdown文本将被渲染到右侧的`#render`元素中。每次按键都会导致脚本更新渲染的元素。
- en: There's more...
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Find out more about the markdown format from its official website at [http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 从官方网站[http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)了解更多关于markdown格式的信息。
- en: Autoupdating fields
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动更新字段
- en: These days, it is common to have an autoupdate on fields where one section is
    either the result of given choices or it displays a given image or text block.
    One example of this is having a password strength calculation; for example, searching
    for "currency converter" on Google will result in a box where you can do currency
    conversion between USD and EUR. Linking fields in this way makes sense when we
    have two or more that are logically linked, or when one is a result form of the
    other.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，在字段上自动更新是很常见的，其中一个部分是给定选择的结果，或者显示给定的图像或文本块。其中一个例子是密码强度计算；例如，在谷歌上搜索“货币转换器”会在结果中显示一个框，你可以在其中进行美元和欧元之间的货币转换。以这种方式链接字段是有意义的，当我们有两个或更多逻辑上相关的字段，或者一个是另一个的结果形式时。
- en: To demonstrate this, we will create a converter for temperature where updating
    one of the fields will result in changes in the other, as the values are linked.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将创建一个温度转换器，其中更新一个字段将导致另一个字段的更改，因为这些值是相关的。
- en: Getting ready
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we only need a basic knowledge of jQuery and a simple formula
    to convert the temperatures between Celsius and Fahrenheit and vice versa:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们只需要对jQuery有基本的了解，并且有一个简单的公式来在摄氏度和华氏度之间进行转换：
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Or:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE69]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How to do it...
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we are going to create the HTML part and create two input fields that
    will get autoupdated and add the appropriate labels:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建HTML部分，并创建两个将自动更新并添加适当标签的输入字段：
- en: '[PRE70]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Afterwards, we have to make sure that we have included jQuery:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们必须确保已经包含了jQuery：
- en: '[PRE71]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Following this, we can add the script that will handle the binding between
    the fields:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加处理字段之间绑定的脚本：
- en: '[PRE72]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will connect and automatically calculate the temperature back and forward.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连接并自动计算温度的前后。
- en: How it works…
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's first take a look at the display part where there is nothing specific;
    here we use a simple input type text and add the appropriate labels for each field.
    Furthermore, we can use the escaped character `&deg;` that will show the degree
    character.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下显示部分，这里没有什么特别的；我们使用一个简单的文本输入类型，并为每个字段添加适当的标签。此外，我们可以使用转义字符`&deg;`来显示度字符。
- en: 'If we take a look at the jQuery `keyup` event, we can see that it''s executed
    when a user releases a key on the keyboard on a given element. This event can
    be attached on any HTML element, but it will only work when the element is in
    focus; so it mostly makes sense to use it on input elements. As the `keyup` event
    has an option to execute a function that will accept the event object, so for
    our case, it is as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下jQuery `keyup`事件，我们会发现它在用户释放键盘上的键时执行。这个事件可以附加在任何HTML元素上，但只有在元素处于焦点时才会起作用；因此，它在输入元素上使用起来更有意义。由于`keyup`事件有一个选项来执行一个将接受事件对象的函数，所以对于我们的情况，它如下所示：
- en: '[PRE73]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the `event` object, we can access the element that fired the event and access
    its value:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在`event`对象中，我们可以访问触发事件的元素并访问其值：
- en: '[PRE74]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'After that, we can do the calculation (*celsius *(9/5) + 32*) and set the result
    as a value to the other element that displays it in Fahrenheit:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以进行计算（*摄氏度*(9/5) + 32*）并将结果设置为另一个元素的值，以便在华氏度中显示：
- en: '[PRE75]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As we wanted the binding to work both ways, we can do the same on the input
    field for Fahrenheit:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望绑定可以双向工作，我们也可以在华氏度的输入字段上做同样的事情：
- en: '[PRE76]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: And of course, you need to use the appropriate formula (*fahrenheit-32)*(5/9)*)
    for returning back to Celsius.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要使用适当的公式（*华氏度-32）*（5/9)*）来返回到摄氏度。
- en: There's more...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While this recipe shows a simple use of jQuery `event` to make an instant update
    on input text, it can also be applied for creating autocomplete boxes or features,
    such as Google's instant search. The idea here is that we can and should use one-
    or two-way binding for various HTML elements, especially when we are talking about
    derived data or data that is a representation of the same source.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱展示了如何简单地使用jQuery `event`来实时更新输入文本，它也可以用于创建自动完成框或功能，比如谷歌的即时搜索。这里的想法是，我们可以并且应该为各种HTML元素使用单向或双向绑定，特别是当我们谈论派生数据或数据是同一来源的表示时。
