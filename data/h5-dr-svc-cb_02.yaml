- en: Chapter 2. Display of Graphical Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 图形数据的显示
- en: 'In this chapter, we are going to cover many common graphical tasks, such as
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖许多常见的图形任务，例如：
- en: Creating a line chart
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建折线图
- en: Creating a bar chart
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Creating a pie chart
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建饼图
- en: Creating an area chart
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建面积图
- en: Displaying combined charts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示组合图表
- en: Creating a bubble chart
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: Showing a map with a marked location
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示带有标记位置的地图
- en: Showing a map with a path
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示带有路径的地图
- en: Displaying gauges
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示仪表
- en: Displaying a tree
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示树
- en: LED scoreboard using web fonts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web字体的LED记分牌
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will take a look at displaying graphical data using various
    JavaScript libraries that are based on modern HTML5 standards. The main idea is
    to get you interested into various visual parts ranging from 2D graphics with
    canvas and SVG data-driven documents, with the help of problem-solving examples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用基于现代HTML5标准的各种JavaScript库显示图形数据。主要目的是让您对从2D图形到SVG数据驱动文档的各种视觉部分感兴趣，并通过解决问题的示例来帮助您。
- en: Creating a line chart
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建折线图
- en: Line charts are the most basic type of charts. They display a series of data
    points connected together by lines. Line charts are often used to visualize time
    series data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 线图是最基本的图表类型。它们通过线连接在一起显示一系列数据点。线图通常用于可视化时间序列数据。
- en: There are various libraries that implement this charting functionality, both
    paid and free. We're going to use the **Flot** chart library. It's free, simple,
    and easy to use and it has been in active development for the past 4 years. It
    also aims to produce aesthetically pleasing charts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种库实现这种图表功能，有付费的也有免费的。我们将使用**Flot**图表库。它是免费的，简单易用，过去4年来一直在积极开发。它还旨在产生美观的图表。
- en: In this recipe, we're going to make a time series chart that displays the outside
    temperature history for the past 24 hours.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将制作一个时间序列图表，显示过去24小时的室外温度历史。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to download Flot from the official website at [http://www.flotcharts.org/](http://www.flotcharts.org/),
    and extract the contents to a separate folder named `flot`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从官方网站[http://www.flotcharts.org/](http://www.flotcharts.org/)下载Flot，并将内容提取到一个名为`flot`的单独文件夹中。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Let's write the HTML and JavaScript code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML和JavaScript代码。
- en: 'Create a basic HTML page with a placeholder for our chart. We''re also going
    to include jQuery (needed by Flot) and Flot itself. Flot needs to draw the chart
    canvas a placeholder div, so we''re going to provide one. The chart placeholder
    needs to have its width and height specified, otherwise Flot will be unable to
    draw correctly:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含图表占位符的基本HTML页面。我们还将包括jQuery（Flot所需）和Flot本身。Flot需要在占位符div中绘制图表画布，因此我们将提供一个。图表占位符需要指定其宽度和高度，否则Flot将无法正确绘制：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add the code that draws our chart in `example.js`. The `getData` function generates
    some convincing-looking random data—you can easily replace it with a function
    that fetches data from the server. The data needs to be returned as an array of
    two-element arrays. The first (x axis) value in the pair is a standard UNIX timestamp
    in milliseconds as commonly used in JavaScript, while the second (y axis) value
    is the temperature.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`example.js`中添加绘制图表的代码。`getData`函数生成一些看起来很真实的随机数据，您可以轻松地用一个从服务器获取数据的函数替换它。数据需要以两个元素数组的形式返回。在这对中，第一个（x轴）值是标准的UNIX时间戳（以毫秒为单位），通常在JavaScript中使用，而第二个（y轴）值是温度。
- en: 'Drawing the chart is very simple. The `$.plot` function draws the chart in
    the specified placeholder containing the specified series with the specified chart
    options:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制图表非常简单。`$.plot`函数在指定的占位符中绘制包含指定图表选项的指定系列的图表：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That''s it! The following is how the end result looks like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！以下是最终的结果：
- en: '![How to do it...](img/9282OT_02_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/9282OT_02_01.jpg)'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `$.plot` function takes three arguments:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.plot`函数接受三个参数：'
- en: The placeholder selector. This is where Flot will draw the chart.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 占位符选择器。这是Flot将绘制图表的地方。
- en: The array of series to draw. Flot can simultaneously draw multiple series on
    the same chart. Every series is an object that must at least contain the `data`
    property. This property is an array of two-element arrays that are the x and y
    values of the series. Additional properties allow us to control the way the particular
    series is drawn—those will be explored in more detail in the next recipes. By
    default, Flot draws a regular line chart with a preset color.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要绘制的系列数组。Flot可以同时在同一图表上绘制多个系列。每个系列都是一个对象，至少必须包含`data`属性。该属性是一组两个元素数组，它们是系列的x和y值。其他属性允许我们控制特定系列的绘制方式-这些将在下一个示例中更详细地探讨。默认情况下，Flot使用预设颜色绘制常规线图。
- en: An `options` object that contains extensive chart drawing options for the chart
    labels, axes, legend, and grid. These options will also be explored in the next
    recipes.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含广泛的图表绘制选项的`options`对象，用于图表标签、轴、图例和网格。这些选项也将在下一个示例中探讨。
- en: In this recipe we've specified the "time" mode for the x axis. This causes Flot
    to appropriately label the hours, days, months, or years on our axis (depending
    on the timespan of the data).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们为x轴指定了“时间”模式。这会导致Flot在我们的轴上适当地标记小时、天、月或年（取决于数据的时间跨度）。
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following is a simple Ajax replacement of the `getData` function, sending
    an Ajax request to a request handler hosted on the same domain at the path `/chart`
    to retrieve the chart data:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`getData`函数的简单Ajax替代，发送一个Ajax请求到同一域上的路径`/chart`上托管的请求处理程序以检索图表数据：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating a bar chart
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: In contrast to a line chart, which is usually used to display averages or momentary
    values, bar charts are used to visualize data that belongs to discrete groups.
    Examples include daily, monthly, and weekly sales (the groups are days, months,
    and weeks respectively), page visits per user, fuel consumption for each car,
    and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常用于显示平均值或瞬时值的折线图不同，条形图用于可视化属于离散组的数据。例如每日、每月和每周的销售量（组是天、月和周），每个用户的页面访问量，每辆车的燃料消耗等。
- en: The Flot chart library can also draw bar charts. In this example, we're going
    to visualize the number of daily sales for the past seven days. We're also going
    to show the sales from separate products separately, stacked on top of each other.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Flot图表库还可以绘制条形图。在这个示例中，我们将可视化过去七天的每日销售量。我们还将分别显示来自不同产品的销售量，堆叠在彼此之上。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to download Flot from the official website at [http://www.flotcharts.org/](http://www.flotcharts.org/)
    and extract the contents to a separate folder named `flot`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从官方网站[http://www.flotcharts.org/](http://www.flotcharts.org/)下载Flot，并将内容提取到名为`flot`的单独文件夹中。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's modify the line chart code to make it draw our bar charts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改折线图代码，以绘制我们的柱状图。
- en: 'First, we''re going to copy the same HTML page from the previous line chart
    recipe, but we''ll make some changes. In order to draw stacking bars, we''re going
    to need the stacking plugin, which is located in the `jquery.flot.stack.js` file.
    The height of the chart placeholder is increased to get a better overview of the
    individual stacking bars:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将复制上一个折线图示例中的相同HTML页面，但是我们会做一些更改。为了绘制堆叠条形图，我们需要堆叠插件，它位于`jquery.flot.stack.js`文件中。图表占位符的高度增加以获得对各个堆叠条形图的更好概览：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we will create the `example.js` script:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将创建`example.js`脚本：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code is explained in the next section. The following is how the resulting
    chart appears:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在下一节中进行了解释。以下是生成的图表的外观：
- en: '![How to do it...](img/9282OT_02_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9282OT_02_02.jpg)'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Like in the previous recipe, the `$.plot` function takes three arguments. The
    first argument is the chart placeholder, the second is data, and the third is
    an object containing the chart options.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的示例一样，`$.plot`函数接受三个参数。第一个参数是图表占位符，第二个是数据，第三个是包含图表选项的对象。
- en: 'The following is a scheme of our input data:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们输入数据的方案：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The input data is an array of series. Each series represents the sales for a
    product. The series object has a `label` property denoting the product, and a
    `data` property, which is an array of data points. Every data point is a two-dimensional
    array. The first element of this array is the date represented as a UNIX timestamp
    in milliseconds—the exact beginning of the day. The second is the number of sales
    for that day.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据是一个系列的数组。每个系列代表一个产品的销售情况。系列对象有一个`label`属性表示产品，以及一个`data`属性，它是一个数据点的数组。每个数据点都是一个二维数组。此数组的第一个元素是日期，表示为以毫秒为单位的UNIX时间戳——即当天的确切开始。第二个元素是当天的销售数量。
- en: To manipulate the dates more easily, we define a variable representing the number
    of milliseconds in a day. Later, we use this variable to define the width of the
    bars in the chart.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更轻松地操作日期，我们定义一个表示一天中毫秒数的变量。稍后，我们将使用此变量来定义图表中条形的宽度。
- en: Flot automatically picks the series colors for us from a predefined list (however,
    it's also possible to specify the colors we need, as we will see in the following
    recipes).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Flot会自动从预定义列表中为我们选择系列颜色（但是，我们也可以指定我们需要的颜色，我们将在下面的示例中看到）。
- en: There are several series options specified in the code. We tell Flot to stack
    our series by setting the value of the `stack` property to `true`. We also make
    sure to hide the lines that would otherwise be shown by default.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中指定了几个系列选项。我们通过将`stack`属性的值设置为`true`来告诉Flot堆叠我们的系列。我们还确保隐藏了默认情况下会显示的线条。
- en: To get the bar centers to align with the x-axis ticks for the day, we set the
    value of the `align` property in the `bar` object to `center`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使柱形图的中心与日期的x轴刻度对齐，我们将`bar`对象中的`align`属性的值设置为`center`。
- en: Each series in our input data has a label. As a result, Flot automatically generates
    a legend placed in the upper-right corner.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入数据中的每个系列都有一个标签。因此，Flot会自动生成一个放置在右上角的图例。
- en: The boundaries of the axes are automatically picked by Flot, but it's possible
    to control them using the `options` object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Flot会自动选择轴的边界，但可以使用`options`对象来控制它们。
- en: Creating a pie chart
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建饼图
- en: When visualizing proportions or percentages as a whole, we usually use pie charts.
    Pie charts are simple enough to draw on our own; however, to get more flexibility
    and aesthetically pleasing results, we're going to use the Flot charting library
    with its pie plugin.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当可视化比例或百分比作为一个整体时，通常使用饼图。饼图足够简单，可以自己绘制；但是，为了获得更灵活和美观的结果，我们将使用Flot图表库及其饼图插件。
- en: Flot's pie plugin can show a pie with or without a legend, and has extensive
    options for controlling the position of the labels. It's also capable of rendering
    tilted pies and donuts. Support for interactive pies is also included.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Flot的饼图插件可以显示带有图例或不带图例的饼图，并具有广泛的选项来控制标签的位置。它还能够渲染倾斜的饼图和甜甜圈图。还包括交互式饼图的支持。
- en: In this recipe, we're going to make a pie chart of our visitor's browsers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将制作一个关于访问者浏览器的饼图。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to download Flot from the official website at [http://www.flotcharts.org/](http://www.flotcharts.org/)
    and extract the contents to a separate folder named `flot`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从官方网站[http://www.flotcharts.org/](http://www.flotcharts.org/)下载Flot，并将内容提取到名为`flot`的单独文件夹中。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the HTML and JavaScript code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML和JavaScript代码。
- en: 'Create the following HTML page in `index.html`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`中创建以下HTML页面：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The page has a placeholder element for our chart.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 页面中有一个图表的占位符元素。
- en: Flot depends on the jQuery library that is included. To draw pie charts, we
    need to add Flot's pie plugin.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Flot依赖于包含的jQuery库。要绘制饼图，我们需要添加Flot的饼图插件。
- en: 'Create the `example.js` script:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`脚本：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It produces the following pie chart:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成以下饼图：
- en: '![How to do it...](img/9282OT_02_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/9282OT_02_03.jpg)'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Flot requires that the pie slices data are provided as an array of objects.
    Every object contains the following two properties:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Flot要求饼图切片数据以对象数组的形式提供。每个对象包含以下两个属性：
- en: '`label`: This is the label of the slice'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这是切片的标签'
- en: '`data`: This is the number of the slice—a number which can be any value (doesn''t
    need to be a percentage)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是切片的编号——一个可以是任何值的数字（不需要是百分比）'
- en: When calling `$.plot`, the first argument is the placeholder element for the
    pie, the second is the array of pie slices, and the third contains the pie options.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`$.plot`时，第一个参数是饼图的占位符元素，第二个是饼图切片的数组，第三个包含饼图选项。
- en: 'In order to show a pie, a minimum `options` object is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示饼图，最小的`options`对象如下：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To customize the default pie, we use the following additions to the `pie` property:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义默认饼图，我们使用以下内容添加到`pie`属性中：
- en: '`radius`: This specifies the size of the pie as a percentage of the canvas.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radius`：指定饼图的大小，以画布的百分比表示。'
- en: '`label`: The `show` (Boolean) property is set to `true` to show the pie labels,
    and the `radius` property controls the distance of the labels from the center
    of the pie.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：`show`（布尔值）属性设置为`true`以显示饼图标签，`radius`属性控制标签与饼图中心的距离。'
- en: '`tilt`: This performs a 3D tilt of the pie. If omitted, Flot will render an
    untitled circle-shaped pie.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tilt`：这会对饼图进行3D倾斜。如果省略，Flot将渲染一个无标题的圆形饼图。'
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are more options available, such as the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多可用的选项，例如以下内容：
- en: '`innerRadius`: This is set to a value such as `0.5` to create a donut chart.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innerRadius`：将其设置为值，例如`0.5`，以创建一个圆环图。'
- en: '`combine`: This property is used to combine smaller slices into a single slice.
    It''s an object containing the following properties:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combine`：此属性用于将较小的切片合并为单个切片。它是一个包含以下属性的对象：'
- en: '`threshold`: This is set to a percentage of the whole, for example, `0.1`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threshold`：设置为整体的百分比，例如，`0.1`'
- en: '`color`: This is the color to use to render the "other" slice, for example,
    `#888`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：这是用于渲染“其他”部分的颜色，例如，`#888`'
- en: For more details, see the pie examples at [http://people.iola.dk/olau/flot/examples/pie.html](http://people.iola.dk/olau/flot/examples/pie.html).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅[http://people.iola.dk/olau/flot/examples/pie.html](http://people.iola.dk/olau/flot/examples/pie.html)上的饼图示例。
- en: Creating an area chart
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建面积图
- en: Area charts are usually used in place of line charts when we want to stack multiple
    results on top of each other. They can also be used to enhance the visual appeal
    of the chart in certain circumstances.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要在线图的位置上堆叠多个结果时，通常使用面积图。它们也可以在某些情况下用于增强图表的视觉吸引力。
- en: 'This recipe will present an example where the area chart is used for an enhanced
    visual appeal: displaying altitude data.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示一个使用面积图来增强视觉吸引力的例子：显示海拔数据。
- en: Let's say we need to visualize the altitude of a 8-km downhill hike succeeded
    by 12 km of flat walking. We would also like to mark the "mountain" portion of
    the chart. Finally, we would like the area below the altitude line to be filled
    in a way reminiscent of color relief maps with the color green for low, yellow
    for medium, and white for high-altitude.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要可视化一个8公里的下坡徒步旅行，然后是12公里的平地行走的海拔。我们还想标记图表的“山脉”部分。最后，我们希望海拔线下的区域以一种让人联想到颜色浮雕地图的方式填充，低海拔使用绿色，中等海拔使用黄色，高海拔使用白色。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll also use the Flot chart library in this example, so we will need to download
    Flot from the official website ta [http://www.flotcharts.org/](http://www.flotcharts.org/)
    and extract the content to a separate folder named `flot`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们还将使用Flot图表库，因此我们需要从官方网站[http://www.flotcharts.org/](http://www.flotcharts.org/)下载Flot并将内容提取到名为`flot`的单独文件夹中。
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Our HTML file needs a chart placeholder element and the necessary scripts included.
    The following is the content:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的HTML文件需要一个图表占位符元素和必要的脚本。以下是内容：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re going to draw the chart in our `example.js` script that contains the
    following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在包含以下代码的`example.js`脚本中绘制图表：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And the following is how our result looks like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的结果：
- en: '![How to do it...](img/9282OT_02_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/9282OT_02_04.jpg)'
- en: The area below the altitude line is filled in a way reminiscent of color relief.
    The mountain section is marked with a blue area, created by the `markings` object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 海拔线下的区域以一种让人联想到颜色浮雕的方式填充。山区部分由`markings`对象创建的蓝色区域标记。
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As in all of our examples, the `getData` function in `example.js` generates
    random data, and then calls the provided callback function with the data. We can
    easily write a replacement that fetches the data from a server instead, using
    jQuery.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们所有的示例一样，`example.js`中的`getData`函数生成随机数据，然后调用提供的回调函数以使用数据。我们可以很容易地编写一个替代函数，而不是从服务器获取数据，而是使用jQuery。
- en: A single call to `$.plot` will draw the area chart. The first argument is the
    target container. The second argument is an array of series to draw—in this case
    just one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 单次调用`$.plot`将绘制面积图。第一个参数是目标容器。第二个参数是要绘制的系列数组——在这种情况下只有一个。
- en: 'The third argument is more complex. It consists of the following parts:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数更复杂。它包括以下部分：
- en: The `xaxis` property specifies the behavior of our x axis. We override the default
    tick labels by providing our own tick formatter. This formatter adds the `"km"`
    string after the tick value.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xaxis`属性指定我们的x轴的行为。我们通过提供自己的刻度格式化程序来覆盖默认的刻度标签。此格式化程序在刻度值后添加`"km"`字符串。'
- en: 'The `lines` property specifies that we''ll be using a filled line chart. We
    want a mountain-like gradient fill effect, so we specify a gradient object that
    contains an array of CSS color strings, that is, `{color: [array of colors]}`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lines`属性指定我们将使用填充线图。我们希望有类似山的渐变填充效果，因此我们指定了一个包含CSS颜色字符串数组的渐变对象，即`{color: [颜色数组]}`。'
- en: The `grid` property is used to mark the mountain segment on our chart. We specify
    that it should contain a marking of the x axis segment spanning in the range 0
    to 8 km and having a light blue color.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid`属性用于在我们的图表上标记山脉段。我们指定它应该包含一个x轴段的标记，跨越0到8公里的范围，并具有浅蓝色。'
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Flot has more area chart options—they can be found in the API documentation
    that is included with the distribution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Flot有更多的面积图选项——它们可以在随分发的API文档中找到。
- en: 'To use this recipe, we would need to provide our own data array from the server.
    The following is a simple Ajax replacement of the `getData` function, sending
    an Ajax request to a request handler hosted on the same domain at the path `/areachart`
    to retrieve the chart data. It is very simple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个配方，我们需要从服务器提供我们自己的数据数组。以下是`getData`函数的一个简单Ajax替代，向托管在同一域上的请求处理程序发送Ajax请求，以检索图表数据的路径`/areachart`。这很简单：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Displaying combined charts
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示组合图表
- en: Combined charts are charts that have more than one x or y axis, and may have
    multiple types of series (lines, bars, and areas). Sometimes, we may want to present
    multiple heterogeneous types of data on a single chart, usually to visualize its
    correlation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 组合图表是具有多个x或y轴的图表，并且可能具有多种类型的系列（线条、条形和面积）。有时，我们可能希望在单个图表上呈现多种异构类型的数据，通常是为了可视化其相关性。
- en: In this recipe, we're going to try and visualize a mountain hike by presenting
    both temperature and altitude on a single chart. The altitude series will be an
    area chart with gradient colors reminiscent of relief maps, but the temperature
    series will be a line chart, which we would like to be red if above 19 degrees
    Celsius and blue if below that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将尝试通过在单个图表上呈现温度和海拔来可视化一次登山。高度系列将是一个具有渐变颜色的面积图，让人联想到地形图，但温度系列将是一条线状图，如果高于摄氏19度则为红色，如果低于摄氏19度则为蓝色。
- en: In order to do this, we're going to need a charting library that can handle
    two y axes. We're going to use the Flot charting library because it is capable
    of displaying charts with two or more x or y axes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要一个能够处理两个y轴的图表库。我们将使用Flot图表库，因为它能够显示具有两个或多个x或y轴的图表。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Like in the previous recipes, we need to download Flot from the official website
    at [http://www.flotcharts.org/](http://www.flotcharts.org/) and extract the contents
    to a separate folder named `flot`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在以前的配方中一样，我们需要从官方网站[http://www.flotcharts.org/](http://www.flotcharts.org/)下载Flot并将内容提取到名为`flot`的单独文件夹中。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the HTML and JavaScript code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML和JavaScript代码。
- en: 'Our HTML file needs a chart placeholder, jQuery, Flot, and our example script.
    This time we''re also going to need the `threshold` plugin in order to have two
    temperature colors. The following is the content:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的HTML文件需要一个图表占位符、jQuery、Flot和我们的示例脚本。这次我们还需要`threshold`插件，以便有两种温度颜色。以下是内容：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our chart is drawn in `example.js` using the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的图表是在`example.js`中使用以下代码绘制的：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot shows the end result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了最终结果：
- en: '![How to do it...](img/9282OT_02_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9282OT_02_05.jpg)'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With the `getData` function, we generate two series for the plot, one containing
    temperature and the other containing altitude.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getData`函数，我们为绘图生成了两个系列，一个包含温度，另一个包含海拔。
- en: When drawing the plot, we call the `getData` function first. In the provided
    callback, we take the data and pass it to the `$.plot` function, which takes the
    target container element, an array of series, and plot options.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制图表时，我们首先调用`getData`函数。在提供的回调中，我们将数据传递给`$.plot`函数，该函数接受目标容器元素、系列数组和绘图选项。
- en: The first series in the array contains altitude data. We have two y axes so
    we need to declare the y axis we're going to use for this series—the first y axis.
    The rest of the parameters declare the fill gradient; for more information see
    the *Creating an area chart* recipe.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的第一个系列包含高度数据。我们有两个y轴，所以我们需要声明我们将用于该系列的y轴——第一个y轴。其余的参数声明了填充渐变；有关更多信息，请参阅*创建面积图*配方。
- en: The second series uses the second y axis. What is new here is the `threshold`
    property. It specifies that for values below 19 degrees, the color of the line
    should be different (blue rather than red).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个系列使用第二个y轴。新的是`threshold`属性。它指定对于低于19度的值，线的颜色应该不同（蓝色而不是红色）。
- en: We're going to configure the second y axis in the `options` object by specifying
    the `yaxes` property (note the plural in the name). This property is an array
    containing y axis options. We're going to use the defaults for the first axis,
    hence the empty object. We will place the second axis on the right-hand side.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`options`对象中通过指定`yaxes`属性（注意名称中的复数形式）来配置第二个y轴。该属性是一个包含y轴选项的数组。我们将使用第一个轴的默认值，因此为空对象。我们将把第二个轴放在右侧。
- en: The unit of the x axis is kilometers and therefore our `tickformatter` function
    adds the string `" km"` to the number.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: x轴的单位是公里，因此我们的`tickformatter`函数在数字后添加字符串`" km"`。
- en: Finally, we mark the "mountain part" (from 0 to 8 km) in blue with the grid
    markings option.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用网格标记选项将“山脉部分”（从0到8公里）标记为蓝色。
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a simple Ajax replacement of the `getData` function, sending an Ajax
    request to a request handler hosted on the same domain at the `/charts` path to
    retrieve the chart data. This handler should return an object in the following
    format:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`getData`函数的一个简单Ajax替代，向托管在同一域上的请求处理程序发送Ajax请求，以检索图表数据的`/charts`路径。此处理程序应返回以下格式的对象：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Where `data1` and `data2` are two-dimensional arrays containing the data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`data1`和`data2`是包含数据的二维数组。
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating a bubble chart
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: Bubble charts can display sets of values as circles. They're usable for datasets
    with sizes in the range 10 through 100\. They're particularly useful for visualizing
    values that differ by orders of magnitude and can replace pie charts in those
    situations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡图可以将值集显示为圆圈。它们适用于大小在10到100之间的数据集。它们特别适用于可视化数量级差异的值，并且可以在这些情况下取代饼图。
- en: As bubble charts are more complex and slightly less common, we're going to need
    a flexible library to draw them. The excellent D3 library ([http://d3js.org/](http://d3js.org/))
    is a great fit; it provides a set of tools, (the core data-driven DOM API plus
    the "pack" data layout) that enables the creation of bubble charts.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于气泡图更复杂且稍微不太常见，我们需要一个灵活的库来绘制它们。优秀的D3库（[http://d3js.org/](http://d3js.org/)）非常适合；它提供了一组工具（核心数据驱动DOM
    API加上“pack”数据布局），可以实现气泡图的创建。
- en: We're going to draw a bubble chart displaying the numbers of visitors coming
    to our website from referring websites.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个气泡图，显示来自引荐网站的访问者数量。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: Let's write the HTML and JavaScript code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML和JavaScript代码。
- en: 'We''re going to create an HTML page containing our chart placeholder. We''re
    going to include the chart library D3, and the code that will draw the bubble
    chart from our `example.js` file:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个包含图表占位符的HTML页面。我们将包括图表库D3，以及将从我们的`example.js`文件绘制气泡图的代码：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we''re going to add the following code in `example.js`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将在`example.js`中添加以下代码：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the following section, we''re going to explain how D3 works and how we''re
    using it to create a bubble chart:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将解释D3的工作原理以及我们如何使用它来创建气泡图：
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Unlike most other chart libraries, D3 doesn't have any predefined chart types
    that it is capable of drawing. Instead, it comes with a set of modular tools that
    you can freely mix and match to create any kind of data-driven documents.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他图表库不同，D3没有任何预定义的图表类型，可以绘制。相反，它提供了一组模块化工具，您可以自由混合和匹配，以创建任何类型的数据驱动文档。
- en: However, D3 contains some very visualization-specific tools.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，D3包含一些非常特定于可视化的工具。
- en: For example, `d3.scale.category20c` creates an ordinal scale. An ordinal scale
    maps input values to a discrete set of output values. In this case, the discrete
    set of values is a set of 20 predefined output colors. The scale is a function—it
    maps the input values to the output. We can specify explicitly which input values
    map to which outputs, but if we don't, it's inferred from usage. In our case,
    it means that the first domain name will be mapped to the first color, the second
    to the second, and so on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`d3.scale.category20c`创建一个序数比例尺。序数比例尺将输入值映射到一组离散的输出值。在这种情况下，离散的值集是一组预定义的20种输出颜色。比例尺是一个函数——它将输入值映射到输出值。我们可以明确指定哪些输入值映射到哪些输出值，但如果我们不这样做，它会根据使用情况进行推断。在我们的情况下，这意味着第一个域名将映射到第一个颜色，第二个将映射到第二个，依此类推。
- en: Other tools include jQuery-like DOM selection tools, which, in our recipe, we
    use to add the SVG element to our chart placeholder.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具包括类似于jQuery的DOM选择工具，在我们的示例中，我们使用它们将SVG元素添加到我们的图表占位符中。
- en: Another example are D3 layouts. To draw a bubble chart we need a pack layout.
    Layouts map a set of objects with values to a set of output coordinates based
    on certain rules and constrains. A popular example is a **force layout**, which
    is a graph layout that arranges the objects by iteratively applying virtual forces
    between graph nodes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是D3布局。要绘制气泡图，我们需要一个包布局。布局根据某些规则和约束将一组具有值的对象映射到一组输出坐标。一个常见的例子是**力布局**，它是一种通过在图形节点之间迭代应用虚拟力来排列对象的图形布局。
- en: We're using the pack layout that produces hierarchical packing of objects into
    circles. Our data is flat, therefore the pack layout is only used to arrange our
    circles automatically. A pack layout is created and assigned to the `bubble` variable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是将对象层次化地打包成圆圈的包布局。我们的数据是平面的，因此包布局仅用于自动排列我们的圆圈。创建一个包布局并将其分配给`bubble`变量。
- en: 'The pack layout works by applying the `bubble.nodes` function to the input
    data. This function looks for the `value` property in each of the objects in the
    input data. Based on this property (which it treats as a relative radius) and
    the size of the layout, it adds the following properties into our data: x, y,
    and r and returns the resulting array of objects.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 包布局通过将`bubble.nodes`函数应用于输入数据来工作。此函数查找输入数据中每个对象中的`value`属性。基于这个属性（它将其视为相对半径）和布局的大小，它将以下属性添加到我们的数据中：x、y和r，并返回结果数组。
- en: 'At this point we have most of the data needed for our bubble chart: we have
    the positions and dimensions of our bubbles. All we need to do now is to turn
    them into the appropriate SVG elements. The tool we use to do this is D3''s `selectAll`
    function.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经有了绘制气泡图所需的大部分数据：我们有气泡的位置和尺寸。现在我们需要做的就是将它们转换为适当的SVG元素。我们用来做这个的工具是D3的`selectAll`函数。
- en: Unlike jQuery selectors, D3's `selectAll` can be used to maintain a two-way
    mapping between the document and a data object. We specify the data array mapped
    to our selection by using the selection's `.data` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与jQuery选择器不同，D3的`selectAll`可以用于在文档和数据对象之间维护双向映射。我们使用选择的`.data`函数指定映射到我们选择的数据数组。
- en: After we declare this mapping, we can decide what happens when an element is
    added to our data array using the `.enter` function. In our recipe, we declare
    that a new SVG graphic element is added to the SVG canvas, and assign that declaration
    to the `node` variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了这个映射之后，我们可以决定当一个元素被添加到我们的数据数组时会发生什么，使用`.enter`函数。在我们的示例中，我们声明一个新的SVG图形元素被添加到SVG画布中，并将该声明分配给`node`变量。
- en: It's important to note that our node variable is not holding the SVG element;
    rather, it's a selection of every graphics SVG element in the set of nodes that
    will be created in the future, whenever a new data element "enters" the selection.
    Therefore, operations on the node specify the operations that will be executed
    on every added SVG element.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们的节点变量并不持有SVG元素；相反，它是未来将创建的节点集合中每个图形SVG元素的选择，每当新的数据元素“进入”选择时，节点上的操作指定将在每个添加的SVG元素上执行的操作。
- en: We specify that every node will have a `title` attribute (which will appear
    on mouse over). The inner text of this title is dependent on the specific element
    in the data array. To describe this, we pass a function as the argument to the
    `.text()` call. The first argument of the passed function will be the data element
    of the particular node, and the returned value should be the text that will be
    set as the title.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定每个节点都将有一个`title`属性（将在鼠标悬停时显示）。此标题的内部文本取决于数据数组中的特定元素。为了描述这一点，我们将一个函数作为`.text()`调用的参数传递。传递函数的第一个参数将是特定节点的数据元素，返回的值应该是将设置为标题的文本。
- en: Similarly, we move our bubbles to the position calculated by the pack layout.
    Afterwards, we add the circle with a radius calculated by the pack layout for
    the circle and the colors scale to generate colors for the circle.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们将我们的气泡移动到由包布局计算的位置。之后，我们添加一个由包布局计算的半径的圆和颜色比例尺来生成圆的颜色。
- en: Finally, a text node is appended in the same way.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以相同的方式附加文本节点。
- en: 'The following is how the result looks like:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果的样子：
- en: '![How it works...](img/9282OT_02_06.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_02_06.jpg)'
- en: There's more...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This example used SVG (scalable vector graphics) markup to render the visualization.
    Most modern browsers support SVG, but Internet Explorer versions prior to IE9
    don't. However, D3 isn't limited to SVG—it is also able to generate HTML elements
    that could be used as a replacement in older versions of IE.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用SVG（可缩放矢量图形）标记来呈现可视化。大多数现代浏览器都支持SVG，但IE9之前的Internet Explorer版本不支持。但是，D3不仅限于SVG，它还能够生成HTML元素，这些元素可以用作IE旧版本的替代品。
- en: Showing a map with a marked location
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示带有标记位置的地图
- en: 'The rise of Google Maps and their excellent API popularized the embedding of
    maps on websites. Embedded maps have a variety of uses: displaying places that
    users have been to, displaying locations of events, displaying locations of stores
    owned by a business, and many others. Maps can be displayed along with every textual
    address displayed on our websites.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌地图的崛起和他们出色的API使地图嵌入网站变得流行起来。嵌入式地图有各种用途：显示用户去过的地方，显示事件的位置，显示商店的位置等等。地图可以与我们网站上显示的每个文本地址一起显示。
- en: In this recipe we're going to make a simple map with a single location marked
    on it. To do this, we're going to use the **Leaflet** library ([http://leafletjs.com/](http://leafletjs.com/)),
    which is a well known and widely library used by Flickr, FourSquare, Craigslist,
    Wikimedia, and other popular sites.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将制作一个简单的地图，并在上面标记一个位置。为此，我们将使用**Leaflet**库（[http://leafletjs.com/](http://leafletjs.com/)），这是一个广泛被Flickr、FourSquare、Craigslist、Wikimedia和其他流行网站使用的知名库。
- en: We're going to display an **OpenStreetMap** map layer. OpenStreetMap ([http://www.openstreetmap.org/](http://www.openstreetmap.org/))
    is a free Wikipedia-like collaboratively created street map with great coverage.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将显示一个**OpenStreetMap**地图图层。OpenStreetMap（[http://www.openstreetmap.org/](http://www.openstreetmap.org/)）是一个类似维基百科的免费协作创建的街道地图，覆盖范围广泛。
- en: We're also going to add a description balloon, which would be displayed when
    the placemark is clicked.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个描述气球，当点击标记时会显示。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the HTML and JavaScript code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML和JavaScript代码。
- en: 'Add Leaflet''s stylesheet in our HTML file, along with a conditional extra
    CSS required for IE8 and older:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的HTML文件中添加Leaflet的样式表，以及IE8和更旧版本所需的条件额外CSS：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Include the Leaflet library JS file in our scripts:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的脚本中包含Leaflet库JS文件：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Put a placeholder for the map on our page. We must also specify its height,
    otherwise Leaflet will not work properly:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的页面上放置地图的占位符。我们还必须指定它的高度，否则Leaflet将无法正常工作：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add our JS code by adding `example.js`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`example.js`来添加我们的JS代码：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, add the code to create the map in `example.js`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`example.js`中添加创建地图的代码：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most map libraries draw their maps by using a tile image layer. Tile image layers
    are grids of images with a predefined, fixed size. The images are sliced parts
    of the map, which has been pre-rendered and hosted on the tile servers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数地图库通过使用瓦片图像图层来绘制它们的地图。瓦片图像图层是具有预定义固定大小的图像网格。这些图像是地图的切片部分，已经预先渲染并托管在瓦片服务器上。
- en: The map uses discrete points of zoom called **zoom levels**. Different tile
    images are used at different zoom levels.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 地图使用称为**缩放级别**的离散缩放点。不同的缩放级别使用不同的瓦片图像。
- en: In some cases, especially at high zoom levels, the server renders the tiles
    on the fly as the space needed to cache the images exceeds reasonable storage
    space sizes. For example, OpenStreetMap uses 19 zoom levels. The first level uses
    a single tile, the second splits this tile into four tiles, the third uses 16,
    and so on. At the 19th zoom level, there are 48 billion tiles—assuming an average
    tile size of 10 KB, that would take 480 terabytes of storage.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，特别是在高缩放级别下，服务器会根据需要在空间超出合理存储空间大小的情况下动态渲染瓦片。例如，OpenStreetMap使用19个缩放级别。第一级使用单个瓦片，第二级将此瓦片分成四个瓦片，第三级使用16个瓦片，依此类推。在第19个缩放级别，有480亿个瓦片，假设平均瓦片大小为10KB，那将需要480TB的存储空间。
- en: When the user scrolls the map, tiles of previously unloaded areas are loaded
    on the fly and shown in the container. When the user changes a zoom level, tiles
    for the old zoom level are removed and new tiles are added.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户滚动地图时，以前未加载的区域的瓦片会动态加载并显示在容器中。当用户更改缩放级别时，旧缩放级别的瓦片将被移除，新的瓦片将被添加。
- en: In our `example.js` file, we use Leaflet's functions (found in the `L` namespace
    object) to create the map. The map is initialized with a center placed in London
    with the help of as array representing a `[latitude, longitude]` pair. The other
    parameter is the zoom level, which is set at `13`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`example.js`文件中，我们使用Leaflet的函数（在`L`命名空间对象中找到）来创建地图。地图初始化为位于伦敦的中心，使用代表`[纬度，经度]`对的数组。另一个参数是缩放级别，设置为`13`。
- en: 'Afterwards a tile layer is added. We specify the tile server pattern that OpenStreetMap
    uses as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 之后添加了一个瓦片图层。我们指定OpenStreetMap使用的瓦片服务器模式如下：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Where `s` is the server letter (`a`, `b`, or `c`), `z` is the zoom level and
    `x` and `y` are the discrete coordinates of the tile. For example, at zoom level
    1, each of `x` and `y` can be either `1` or `2`, while at zoom level 2 they can
    be in the range 1 to 4 and so on. We also specify the maximum zoom level available.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`s`是服务器字母（`a`，`b`或`c`），`z`是缩放级别，`x`和`y`是瓦片的离散坐标。例如，在缩放级别1时，`x`和`y`中的每一个可以是`1`或`2`，而在缩放级别2时，它们可以在1到4的范围内。我们还指定了可用的最大缩放级别。
- en: We add our own marker to the map. The initialization parameter is a `[latitude,
    longitude]` pair. Afterwards, we can add a pop up inside the marker showing text
    and/or arbitrary HTML. We open the pop up immediately.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向地图添加自己的标记。初始化参数是一个`[纬度，经度]`对。之后，我们可以在标记内部添加一个弹出窗口，显示文本和/或任意HTML。我们立即打开弹出窗口。
- en: '![How it works...](img/9282OT_02_07.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_02_07.jpg)'
- en: Map drawn with Leaflet
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Leaflet绘制的地图
- en: Showing a map with a path
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示带有路径的地图
- en: When displaying maps, sometimes we may want to show more than just locations.
    Besides markers, the other most common map overlays are paths and areas.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示地图时，有时我们可能希望显示的不仅仅是位置。除了标记，另一个最常见的地图叠加层是路径和区域。
- en: In this recipe, we're going to create a map showing a path and an area.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个显示路径和区域的地图。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the HTML and JavaScript code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML和JavaScript代码。
- en: 'Like in the *Showing a map with a marked location* recipe, we''ll need to include
    the appropriate CSS and scripts. The following is an example HTML file:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在*显示带有标记位置的地图*食谱中一样，我们需要包含适当的CSS和脚本。以下是一个示例HTML文件：
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we can add our code to `example.js`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以将我们的代码添加到`example.js`中：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create our map using the `L.map` function and set the map's position using
    `setView` at the specified `[latitude, longitude]` array and the zoom level. We
    also add the standard OpenStreetMap tile layer.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`L.map`函数创建地图，并使用`setView`在指定的`[纬度，经度]`数组和缩放级别上设置地图的位置。我们还添加了标准的OpenStreetMap瓦片图层。
- en: First we create and add a standard polyline. As we don't specify any options,
    Leaflet uses reasonable defaults for colors, opacity, borders, and so on. The
    polyline constructor takes an array of `[latitude, longitude]` pairs and draws
    a line with vertices that go through them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建并添加一个标准折线。由于我们没有指定任何选项，Leaflet对颜色、不透明度、边框等都使用了合理的默认值。折线构造函数采用`[纬度，经度]`对的数组，并绘制通过它们的顶点的线。
- en: '![How it works...](img/9282OT_02_08.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_02_08.jpg)'
- en: Afterwards, we create a slightly customized polygon. Like the polyline constructor,
    the polygon also takes an array of `[latitude, longitude]` pairs. Additionally,
    we customize the background color, remove the polygon's border, and specify the
    polygon's opacity to be 50 percent.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建一个稍微定制的多边形。与折线构造函数一样，多边形也采用`[纬度，经度]`对的数组。此外，我们自定义了背景颜色，删除了多边形的边框，并指定了多边形的不透明度为50%。
- en: Displaying gauges
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示表盘
- en: Analog gauges are useful for visualizing data with values bound between predefined
    minimums and maximums, which undergo changes over time. Examples include amount
    of fuel, current speed, disk space, process and memory usage, and so on.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟表盘对于可视化数值在预定义最小值和最大值之间并随时间变化的数据非常有用。示例包括燃料量，当前速度，磁盘空间，进程和内存使用等。
- en: 'In this recipe, we''re going to make a very flexible, data-driven gauge plugin
    for jQuery. Then we''re going to use this plugin to display an analog car speedometer.
    The following is how the speedometer will look:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将为jQuery制作一个非常灵活的、数据驱动的表盘插件。然后我们将使用这个插件来显示模拟汽车速度表。以下是速度表的外观：
- en: '![Displaying gauges](img/9282OT_02_09.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![显示表盘](img/9282OT_02_09.jpg)'
- en: The recipe makes extensive use of HTML5's canvas.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱广泛使用了HTML5的画布。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the HTML code for our example, the gauge plugin and the code that
    ties them together.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的示例编写HTML代码，表盘插件和将它们联系在一起的代码。
- en: 'Make a simple HTML file with a canvas for our gauge:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作一个简单的HTML文件，其中包含我们的表盘的画布：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then write our gauge plugin code in `example.js`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`example.js`中编写我们的表盘插件代码：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is a support function that replaces `Array.forEach` and works on both
    single items and arrays. Our gauge will support multiple stripes, needles, and
    ticks, but it should also be able to work when a single one is provided:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个支持函数，它替换了`Array.forEach`，可以在单个项目和数组上工作。我们的表盘将支持多个条纹、指针和刻度，但当提供单个条纹时，它也应该能够工作：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is a generic function that rotates the point `pt` around the
    center `c` (the angle amount is `a`). Direction is clockwise:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一个通用函数，它围绕中心`c`（角度量为`a`）旋转点`pt`。方向是顺时针的：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The following is our gauge plugin
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们的表盘插件
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By default, our gauge has the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的表盘具有以下特点：
- en: Is offset 20% from the top
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从顶部偏移20%
- en: Has a linear scale with a value range 1 to 200, angle range 0 to 180 degrees,
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有值范围1到200的线性刻度，角度范围0到180度，
- en: Has a single strip at 80% or total radius with a width of 5% of total radius
    colored with gray and going from 0 to 200.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有80%或总半径宽度为总半径5%的单条带，颜色为灰色，范围从0到200。
- en: Has a single `ticks` array going from 0 to 200 with `step` 10
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有一个从0到200的单个`ticks`数组，步长为10
- en: Has labels from 0 to 200 with step 20
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有从0到200的标签，步长为20
- en: Has a single needle set at value 67
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有单个指针设置为值67
- en: 'We allow the user to override options and to specify more than one of any of
    the components mentioned previously:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们允许用户覆盖选项，并指定之前提到的任何组件的多个：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We construct our `scale` function and replace our objects specifying ranges
    of values with actual arrays. Note that instead of a `range` object, you can also
    specify an actual array:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建我们的`scale`函数，并用实际数组替换指定值范围的对象。请注意，您可以指定实际数组，而不是`range`对象：
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the drawing code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是绘图代码：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will use the gauge center as a reference point and will clear the canvas:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用仪表中心作为参考点，并清除画布：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then we''ll draw all the strips (one or more) as arcs:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将绘制所有条带（一个或多个）作为弧线：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then draw all the ticks (we use very short, very thick arcs as ticks). Our
    `scale` function turns the values in `range` to angles:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后绘制所有刻度（我们使用非常短、非常粗的弧线作为刻度）。我们的`scale`函数将`range`中的值转换为角度：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then we draw the labels. We determine the position by placing it at the right-most
    vertically-centered position, then rotating it counter-clockwise by the amount
    scaled with the value:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们绘制标签。我们通过将其放在最右边的垂直居中位置来确定位置，然后按照与值缩放的量逆时针旋转它：
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we draw the needles. The needles are made of a circle centered at
    the central rotation point of the gauge and a triangle extending from there. We
    rotate all three triangle points the same way we rotate the label centers:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们绘制指针。指针由一个圆和一个三角形组成，圆心位于仪表的中心旋转点，三角形从那里延伸。我们旋转所有三角形点的方式与旋转标签中心的方式相同：
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After drawing the whole gauge, the `gauge` function returns a function that
    can be used to change the gauge needle value(s) and redraw it:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在绘制整个仪表之后，`gauge`函数返回一个函数，该函数可用于更改仪表指针值并重新绘制它：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'These are common helper functions. The `range` function creates an array of
    values, while `scale` creates a function that scales values from one range to
    another. Both support logarithmic scales:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是常见的辅助函数。`range`函数创建一个值数组，而`scale`创建一个将值从一个范围缩放到另一个范围的函数。两者都支持对数刻度：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The anonymous function is invoked with the jQuery object as a parameter that,
    in the scope of the function, becomes `$`. This is a typical way to construct
    jQuery plugins with their own private scope, and to make jQuery available as `$`
    within that scope regardless of whether `$` is the same as jQuery in the global
    namespace.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery对象作为参数调用匿名函数，在函数的范围内变为`$`。这是构建具有自己私有范围的jQuery插件的典型方式，并在该范围内使jQuery作为`$`可用，而不管全局命名空间中的`$`是否与jQuery相同。
- en: 'We will draw our gauge in `example.js`. The following is the content:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`example.js`中绘制我们的仪表。以下是内容：
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We specified a linear scale for the gauge with angles going slightly below
    the middle, and speed values in the range 0 to 220\. We created three strips,
    the green one in the range 0 to 140 km/h, a yellow one in the range 140 to 180
    km/h, and a red one in the range 180 to 220 km/h. We''re going to use two sets
    of strips: one larger every 20 km/h and one smaller on every 10 km/h, both semi-transparent.
    Finally, we add a needle with a bluish tint.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为仪表指定了一个线性刻度，角度略低于中间，并且速度值在0到220的范围内。我们创建了三个条带，绿色的范围是0到140公里/小时，黄色的范围是140到180公里/小时，红色的范围是180到220公里/小时。我们将使用两组条带：每20公里/小时一个较大的，每10公里/小时一个较小的，都是半透明的。最后，我们添加了一个带有蓝色色调的指针。
- en: At the end, we can set our gauge value with the returned function, which we
    use to set it at 25 km/h.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用返回的函数设置仪表值，我们将其设置为25公里/小时。
- en: Displaying a tree
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示树
- en: In this recipe, we will take a look into how to display data in a tree-like
    layout. We are going to visualize a small family tree of Linux represented via
    JSON file. Additionally, will be using the `D3.js` file for manipulating the DOM
    to display the data.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看如何以树状布局显示数据。我们将通过JSON文件来可视化Linux的一个小家族树。此外，我们将使用`D3.js`文件来操作DOM以显示数据。
- en: '![Displaying a tree](img/9282OT_02_10.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![显示树](img/9282OT_02_10.jpg)'
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, we need to have the data that is going to be used for the visualization.
    We need to get the `tree.json` file that is part of the examples for this recipe.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要有将用于可视化的数据。我们需要获取这个配方示例中的`tree.json`文件。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will write the HTML and the backing JavaScript code that should generate
    data from a JSON file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写HTML和支持JavaScript代码，应该从JSON文件生成数据：
- en: 'Let''s first take a look a the structure of the JSON data:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先看一下JSON数据的结构：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Each object has a `name` attribute representing the distribution name, a `url`
    attribute that has a link to the official web page, and the optional `children`
    attribute that can contain a list of other objects.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个`name`属性，表示分布名称，一个`url`属性，其中包含指向官方网页的链接，以及可选的`children`属性，其中包含其他对象的列表。
- en: 'Next step would be to create the page using the HTML5 doctype, and adding the
    dependency to `D3.js` and a CSS file called `tree.css`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将是使用HTML5文档类型创建页面，并添加对`D3.js`的依赖项和名为`tree.css`的CSS文件：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `body` section, we are going to add a `<div>` tag having an `id` called
    `location` that we are going to use as placeholder, and additionally include a
    JavaScript file called `tree.js` that will be used to include the logic for mapping
    the data:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`部分，我们将添加一个具有名为`location`的`id`的`<div>`标签，我们将用它作为占位符，并另外包含一个名为`tree.js`的JavaScript文件，该文件将用于包含映射数据的逻辑：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s start with creating the display area in the `tree.js` file. First, we
    create the anonymous function that provides private state of the variables used
    inside:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在`tree.js`文件中创建显示区域开始。首先，我们创建提供内部私有状态的匿名函数：
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then set up the size of the generated image with given `width` and `height`.
    For simplicity, we set them to fixed values:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置生成图像的大小，给定`width`和`height`。为简单起见，我们将它们设置为固定值：
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Afterwards, we set up a standard D3 layout tree:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置了一个标准的D3布局树：
- en: '[PRE47]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we need to designate and create the actual SVG, we pick the location using
    the `id` previously chosen in the HTML called `location`, and append SVG element:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要指定和创建实际的SVG，我们使用之前在HTML中选择的`id`来选择位置，然后附加SVG元素：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We also need to read out the data from `tree.json` and somehow create nodes
    and links with the given hierarchy:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从`tree.json`中读取数据，并以某种方式使用给定的层次结构创建节点和链接：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can style the page using CSS, picking color for the link background of the
    page and the circle:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用CSS样式页面，选择页面链接背景和圆圈的颜色：
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works…
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The line `d3.layout.tree()` creates a new tree layout with default settings,
    where it is assumed that each input in the data element has a child array.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.layout.tree()`创建一个具有默认设置的新树布局，其中假定数据元素中的每个输入都有一个子数组。'
- en: With `d3.svg.diagonal()`, we create a generator with default accessor functions.
    The returned function can generate the path data for a cubic Bézier connecting
    the nodes where we have tangents for smoothing the line.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`d3.svg.diagonal()`，我们创建了一个具有默认访问器函数的生成器。 返回的函数可以生成连接节点的立方贝塞尔路径数据，其中我们有用于平滑线条的切线。
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on Bézier curve can be found at [http://en.wikipedia.org/wiki/Bézier_curve](http://en.wikipedia.org/wiki/Bézier_curve).
    There is some mathematics behind it, but the simplest explanation would be that
    it is a line affected by certain points making it a good pick to define curvy
    lines.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有关贝塞尔曲线的更多信息，请访问[http://en.wikipedia.org/wiki/Bézier_curve](http://en.wikipedia.org/wiki/Bézier_curve)。
    它背后有一些数学知识，但最简单的解释是，它是一条受到某些点影响的线，使其成为定义曲线的不错选择。
- en: 'As we wanted to have the tree from left to right instead of the the default,
    which is from top to bottom, we need to change the default behavior by doing a
    projection:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望树从左到右而不是默认的从上到下，我们需要通过进行投影来改变默认行为：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The function will use `[d.y, d.x]` instead of the default `[d.x,d.y]`. One
    thing that you may have noticed is the `.append("g")` function that adds the SVG
    `g` element, which is a container element used for grouping together various related
    elements. We can have multiple nested elements inside, one within another, to
    an arbitrary depth, allowing us to create groups on various levels:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将使用`[d.y, d.x]`而不是默认的`[d.x,d.y]`。 你可能已经注意到了`.append("g")`函数，它添加了SVG `g`元素，这是一个用于将各种相关元素分组在一起的容器元素。
    我们可以在其中有多个嵌套元素，一个在另一个内部，到任意深度，允许我们在各个级别创建组：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To read the JSON data we''ve used the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取JSON数据，我们使用了以下内容：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That does an AJAX call to the `tree.json` resource.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对`tree.json`资源进行AJAX调用。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, by default, your browser will not allow cross-domain requests. This
    includes requests to your local filesystem. To overcome this, please use a local
    web server explained in [Appendix A](apa.html "Appendix A. Installing Node.js
    and Using npm"), *Installing Node.js and Using npm*. Another option is to use
    JSONP as a great workaround, because with this security restriction there are
    some shortcomings. In [Chapter 8](ch08.html "Chapter 8. Communicating with Servers"),
    *Communicating with Servers*, we cover the issues and the reasoning behind these
    restrictions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，您的浏览器不会允许跨域请求。 这包括对本地文件系统的请求。 要克服这一点，请使用附录A中解释的本地Web服务器，*安装Node.js和使用npm*。
    另一个选择是使用JSONP作为一个很好的解决方法，因为在这种安全限制下有一些缺点。 在[第8章](ch08.html "第8章。与服务器通信")中，*与服务器通信*，我们将介绍这些限制背后的问题和原因。
- en: For more information, take a look at the W3C page at [http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看W3C页面[http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/)。
- en: We then automatically map the data from the JSON file with `tree.nodes(json)`,
    where some assumptions are made on what we have inside the data; for example,
    we can have a parent node or children nodes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`tree.nodes(json)`自动映射来自JSON文件的数据，其中对我们在数据中有什么进行了一些假设； 例如，我们可以有一个父节点或子节点。
- en: 'After that, we selected all the `path.link` using W3C selectors that resemble
    a lot like the jQuery ones:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用类似于jQuery的W3C选择器选择了所有的`path.link`：
- en: '[PRE54]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Using `.data`, we bind them with link information that is returned by `tree.links`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.data`，我们将它们与`tree.links`返回的链接信息绑定：
- en: '[PRE55]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'What happens in the background is that D3''s tree layout has a `links` function
    that accepts an array of nodes, and returns an array of objects representing the
    links from parent to child for each of these nodes. Links for the leafs will not
    be created. The information stored in the returned object has a `source` or the
    parent node and `target` or the child node. Now, in the following part, there
    is the .`enter()` function that''s very much D3 magic. What happens is that, for
    every element in the array that is part of `.data([theArray])` and has no corresponding
    DOM element found in the selection, it simply "enters inside the data" allowing
    us to use `.append`, .`insert`, `.select`, or `.empty` operators. In our case,
    we want to create SVG path elements having a CSS class of `link` and a `d` attribute
    calculated using the diagonal function we previously defined:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: D3的树布局有一个`links`函数，它接受一个节点数组，并返回表示这些节点的父节点到子节点的链接的对象数组。 不会创建叶子节点的链接。 返回对象中存储的信息有一个`source`或父节点和`target`或子节点。
    现在，在接下来的部分中，有一个非常D3魔术的`.enter()`函数。 每个数组中的元素都是`.data([theArray])`的一部分，并且在选择中找不到相应的DOM元素时，它就会“进入数据”，从而允许我们使用`.append`、`.insert`、`.select`或`.empty`操作符。
    在我们的情况下，我们想要创建具有CSS类`link`和使用我们之前定义的对角线函数计算的`d`属性的SVG路径元素：
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So, for each data element, it will create `<path class='link' d='dataCalucatedByDiagonal'
    />`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个数据元素，它将创建`<path class='link' d='dataCalucatedByDiagonal' />`。
- en: The SVG path element is a concept used to represent a line drawing that we would
    do with a pen, for example, having various types of geometry and representation.
    The `d` attribute contains the path data designated with `moveto(M)`, `lineto(L)`,
    `curve( cubic and quadratic besiers)`, `arc(A)`, `closepath(Z)`, `vertical lineto
    (V)`, and so on.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: SVG路径元素是一个用于表示线条绘制的概念，例如，具有各种类型的几何和表示。`d`属性包含了用`moveto(M)`、`lineto(L)`、`curve(
    cubic and quadratic besiers)`、`arc(A)`、`closepath(Z)`、`vertical lineto (V)`等指定的路径数据。
- en: 'It''s good to know what is generated by D3 for us in order to understand more
    completely how it works. Let''s say we want to display a simple line:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 了解D3为我们生成了什么，以便更全面地了解它是如何工作的。比如说我们想要显示一个简单的线：
- en: '![How it works…](img/9282OT_02_11.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_02_11.jpg)'
- en: 'The SVG code would be as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: SVG代码如下：
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Examining the path data values, we can see that it means move `pen(M)` to `(10,30)`
    and draw `line(L)` to `(200,10)`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 检查路径数据值，我们可以看到它的意思是将`pen(M)`移动到`(10,30)`，并画`line(L)`到`(200,10)`。
- en: 'In our example with the tree, we have the lines drawn using paths, so the next
    step would be to draw the nodes. We apply the same procedure where we select all
    the old `g.node` elements and enter the node data, but instead of creating the
    `<path/>` element, we just append `"g"` and additionally add an `<a>` element
    with the `<xlink:href>` attribute:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的树的例子中，我们使用路径绘制线条，所以下一步是绘制节点。我们应用相同的过程，选择所有旧的`g.node`元素并输入节点数据，但是我们不是创建`<path/>`元素，而是只是附加`"g"`，并额外添加一个带有`<xlink:href>`属性的`<a>`元素：
- en: '[PRE58]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we are already automatically iterating all the data nodes, we can access
    `d.url`, retrieving the URL for each node and setting it as a link to all the
    inner elements that we are going to add later.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经自动迭代了所有数据节点，我们可以访问`d.url`，检索每个节点的URL，并将其设置为我们稍后要添加的所有内部元素的链接。
- en: 'Don''t forget that we need to rotate the coordinates, because we want the tree
    to be displayed from left to right:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们需要旋转坐标，因为我们希望树从左到右显示：
- en: '[PRE59]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After this, we can append other elements to each of the elements, so in order
    to create the circle, we add the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以向每个元素附加其他元素，为了创建圆，我们添加以下内容：
- en: '[PRE60]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'That creates an SVG circle with radius of 20px, also, we append the `<text/>`
    element that will display the distribution name:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就创建了一个半径为20px的SVG圆，另外，我们附加了将显示分布名称的`<text/>`元素：
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice that we are moving the text element with `(-19,-19)` in order to avoid
    overlapping with the circle and the lines, and that is it.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将文本元素移动了`(-19,-19)`，以避免与圆和线重叠，就是这样。
- en: There's more...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The first thing you must do is play around with the values that are constant,
    such as the image size or text offset. This will help you better understand how
    changes affect the layout. There are various different functions to generate the
    layout, you can create it in a radial fashion or make it dendrite-like.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先要做的事情是玩弄一下那些是常数的值，比如图像大小或文本偏移量。这将帮助你更好地理解变化如何影响布局。有各种不同的函数来生成布局，你可以以径向方式创建它，或者使它看起来像树突一样。
- en: There are various ways to add interaction where you can have updates on certain
    portion of the code, make some parts animated, or even include HTML inside the
    SVG.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法可以添加交互，你可以在代码的某些部分进行更新，使某些部分动画化，甚至在SVG内部包含HTML。
- en: LED scoreboard using web fonts
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络字体的LED记分牌
- en: In this recipe, we are going create an LED scoreboard similar to the ones used
    in basketball games by making a clever use of HTML web fonts. The main goal of
    the recipe is to get introduced to web fonts and the features they offer.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个LED记分牌，类似于篮球比赛中使用的记分牌，通过巧妙地使用HTML网络字体。该食谱的主要目标是介绍网络字体及其提供的功能。
- en: '![LED scoreboard using web fonts](img/9282OT_02_12.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![使用网络字体的LED记分牌](img/9282OT_02_12.jpg)'
- en: Tip
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The full specification on web fonts can be found on W3C at [http://www.w3.org/TR/css3-webfonts/](http://www.w3.org/TR/css3-webfonts/).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有关网络字体的完整规范可以在W3C上找到[http://www.w3.org/TR/css3-webfonts/](http://www.w3.org/TR/css3-webfonts/)。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作完成
- en: Before staring, you need to get the font we are going to use in this example.
    The files can be retrieved from the examples code, and they all have a `RADIOLAND`
    prefix.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你需要获取我们在这个例子中要使用的字体。这些文件可以从示例代码中检索，它们都有一个`RADIOLAND`前缀。
- en: How to do it...
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create the scoreboard, we will create an HTML page, a backing JavaScript
    code that will update the timers, and related data, as well as a CSS file that
    will use web fonts:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建记分牌，我们将创建一个HTML页面，一个支持JavaScript代码，用于更新计时器和相关数据，以及一个使用网络字体的CSS文件：
- en: First, we will start with creation of the HTML page; in the `head` section,
    include `stylesheet.css` and a dependency to jQuery
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从创建HTML页面开始；在`head`部分，包括`stylesheet.css`和对jQuery的依赖。
- en: '[PRE62]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the `body` part, add the `div` elements that we are going to use as placeholders
    for the scores and additionally include `scoreboard.js`:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`部分，添加我们将用作分数占位符的`div`元素，并另外包括`scoreboard.js`：
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can now create the `stylesheet.css` file, defining first the web font that
    has the LED look:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建`stylesheet.css`文件，首先定义具有LED外观的网络字体：
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As the font is now defined as `RadiolandRegular`, we can refer to it directly:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于字体现在被定义为`RadiolandRegular`，我们可以直接引用它：
- en: '[PRE65]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can proceed with the creation of the JavaScript that will be used and we''ll
    use a mock object called `game` that has the game information. This object, in
    general, should be retrieved from a server using an AJAX call, but for simplicity,
    we are using some predefined values:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以继续创建将要使用的JavaScript，并且我们将使用一个名为`game`的模拟对象，该对象具有游戏信息。一般来说，这个对象应该通过AJAX调用从服务器检索，但为了简单起见，我们使用了一些预定义的值：
- en: '[PRE66]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In order to have the logic for creation of our display object and for fetching
    the data separated, we can put it in a function:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的显示对象的创建逻辑和数据获取逻辑分离，我们可以将其放在一个函数中：
- en: '[PRE67]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We also create a `config` object where we can define game parameters, such
    as number of periods and minutes per period:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还创建了一个 `config` 对象，可以在其中定义游戏参数，例如周期数和每周期的分钟数：
- en: '[PRE68]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We then define the `updateCounter()` and `updateScore()` functions that will
    update the display and perform calculations for the timers. We are going to check
    if the current time is smaller that the start time of the game and set the timer
    to `00:00`. If current time is greater than the max possible, set the timer to
    max possible for a period:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义 `updateCounter()` 和 `updateScore()` 函数，它们将更新显示并执行计时器的计算。我们将检查当前时间是否小于游戏开始时间，并将计时器设置为
    `00:00`。如果当前时间大于最大可能时间，则将计时器设置为最大可能时间：
- en: '[PRE69]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Following that, we add a function that will update the score:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，我们添加一个将更新得分的函数：
- en: '[PRE70]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'At the end, we can call the `setInterval` function that will call the updates
    every 500 milliseconds:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以调用 `setInterval` 函数，该函数将每500毫秒调用更新：
- en: '[PRE71]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The HTML and JavaScript code are pretty straightforward in this recipe, but
    on the other hand, we are taking a deeper look at the CSS and the font files.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的HTML和JavaScript代码非常简单直接，但另一方面，我们正在深入研究CSS和字体文件。
- en: With the addition of the `@font-face` at-rule, we can specify online fonts to
    use in other other elements. By doing this, we allow the use of different fonts
    that are not available on the client machine.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `@font-face` at-rule，我们可以指定在其他元素中使用在线字体。通过这样做，我们允许使用客户端机器上不可用的不同字体。
- en: 'In the definition of `@font-face`, we add `font-family`—a name definition that
    we can afterwards apply on any element. For example, consider the following example
    where we call our font `someName`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@font-face` 的定义中，我们添加了 `font-family` ——一个我们随后可以应用在任何元素上的名称定义。例如，考虑以下示例，我们将我们的字体称为
    `someName`：
- en: '[PRE72]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can notice the format definition named `format("woff")` next to `url` in
    this example as well as in our `stylesheet.css`. The following formats can be
    applied there:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此示例中以及我们的 `stylesheet.css` 中的 `url` 旁边注意到名为 `format("woff")` 的格式定义。可以应用以下格式：
- en: '`.woff`: This stands for **Web Open Font Format** (**WOFF**), a format developed
    by Mozilla and is one of the newer standards around. The full specification is
    available on [http://www.w3.org/TR/WOFF/](http://www.w3.org/TR/WOFF/). The format''s
    goal is to provided alternative solutions to other formats that would be optimal
    for use in cases where we need a certain level of licensing. The format allows
    metadata to be attached to the file itself that can contain the license.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.woff`：这代表**Web开放字体格式**（**WOFF**），这是由Mozilla开发的一种较新的标准之一。完整规范可在 [http://www.w3.org/TR/WOFF/](http://www.w3.org/TR/WOFF/)
    上找到。该格式的目标是为其他格式提供替代解决方案，这些解决方案在需要一定级别的许可证时会更加优化。该格式允许将元数据附加到文件本身，其中可以包含许可证。'
- en: '`.ttf` and `.otf`: The **TrueType Font** (**TTF**) and the extended version
    **OpenType Font** (**OTF**) are some of the most widely used types. The standard
    for TrueType was developed by Apple Computers by the end of the 80s as a replacement
    of some of the PostScript standards. It provided the font developers with flexibility
    and control over how the fonts are shown to the user with many different sizes.
    Due to its popularity and features, it swiftly spreads over to other platforms
    such as Windows. OpenType is a successor to TrueType up on which it is based.
    The specification was developed by Microsoft with additions from Adobe Systems.
    The name OpenType is a registered trademark of Microsoft Corporation. Detailed
    specification can be found on [http://www.microsoft.com/typography/otspec/default.htm](http://www.microsoft.com/typography/otspec/default.htm).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.ttf` 和 `.otf`：**TrueType 字体**（**TTF**）和扩展版本**OpenType 字体**（**OTF**）是一些最广泛使用的类型。TrueType
    的标准是由苹果电脑在80年代末开发的，作为一些PostScript标准的替代品。它为字体开发人员提供了灵活性和对用户以多种不同大小显示字体的控制。由于其流行和功能，它迅速传播到其他平台，如Windows。OpenType
    是基于TrueType的后继版本。该规范由微软开发，并得到Adobe Systems的补充。OpenType 是微软公司的注册商标。详细规范可以在 [http://www.microsoft.com/typography/otspec/default.htm](http://www.microsoft.com/typography/otspec/default.htm)
    上找到。'
- en: '`.eot`: Embedded OpenType fonts are a form of OpenType fonts designed for use
    on web pages. The extensions done on the embedded versions are closely related
    to making copy protection. As the other fonts are easily copied, EOT gives only
    a subset of the available characters to the user, making it more difficult to
    copy the font fully. More information on EOT can be found on the W3C specification
    at [http://www.w3.org/Submission/EOT/](http://www.w3.org/Submission/EOT/).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.eot`：嵌入式OpenType字体是设计用于网页的OpenType字体的一种形式。对嵌入版本的扩展与制作版权保护密切相关。由于其他字体很容易被复制，EOT只向用户提供可用字符的子集，使得复制整个字体更加困难。有关EOT的更多信息，请参阅W3C规范
    [http://www.w3.org/Submission/EOT/](http://www.w3.org/Submission/EOT/)。'
- en: '`.svg` and `.svgz`: SVG and the gunziped version with extension `.svgz` can
    be used to represent fonts. The font definition is stored as SVG glyph allowing
    easy support. More on SVG fonts can be found on the specification at [http://www.w3.org/TR/SVG/fonts.html](http://www.w3.org/TR/SVG/fonts.html).
    Unfortunately, this format is not supported in IE and Firefox at the time of writing.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.svg` 和 `.svgz`：SVG 和带有扩展名 `.svgz` 的经过解压缩的版本可以用来表示字体。字体定义存储为 SVG 字形，可以轻松支持。有关
    SVG 字体的更多信息可以在规范 [http://www.w3.org/TR/SVG/fonts.html](http://www.w3.org/TR/SVG/fonts.html)
    中找到。不幸的是，目前写作时，这种格式在 IE 和 Firefox 中不受支持。'
- en: 'There are few other attributes that can be used on `@font-face`, such as `font-style`,
    `font-weight`, and `font-stretch`. Also, we can specify a range of the characters
    used in Unicode by setting a value for `unicode-range`. Some examples for this
    taken from the specification are as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`@font-face` 上还可以使用一些其他属性，例如 `font-style`、`font-weight` 和 `font-stretch`。此外，我们可以通过为
    `unicode-range` 设置值来指定Unicode中使用的字符范围。规范中的一些示例如下：'
- en: '`unicode-range: U+0-7F;`: This is a code range for basic ASCII characters'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unicode-range: U+0-7F;`：这是基本ASCII字符的代码范围'
- en: '`unicode-range: U+590-5ff;`: This is a code range for Hebrew characters'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unicode-range: U+590-5ff;`：这是希伯来字符的代码范围'
- en: One of the problems with web fonts is that no particular format is requested
    by the specification of CSS2\. This often means that we need to offer several
    different formats to get identical experience across browsers.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Web字体的一个问题是CSS2的规范没有要求特定的格式。这通常意味着我们需要提供几种不同的格式，以在各种浏览器中获得相同的体验。
- en: Note
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There a many `font-face` definition generators that simplify the creation of
    all of these possible options. One such is **FontSquirrel** ([http://www.fontsquirrel.com/tools/webfont-generator](http://www.fontsquirrel.com/tools/webfont-generator)).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多`font-face`定义生成器可以简化所有这些可能选项的创建。其中一个是**FontSquirrel**（[http://www.fontsquirrel.com/tools/webfont-generator](http://www.fontsquirrel.com/tools/webfont-generator)）。
- en: Web fonts are becoming one of the most common building blocks of the Web, and
    as such, they should be always considered when we are in a need of a great looking
    typography. Images, SVG, Coufons, and similar types just don't play well with
    text. We might get great looking text using those, but the text will not be accessible
    by search engines, most of the accessibility software will ignore it, and it might
    even get the page size larger. On the other hand, using text allows us to do various
    CSS tweaks on the data where we can use selectors, such as `:first-letter`, `:first-line`,
    and `:lang`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Web字体正在成为Web的最常见构建块之一，因此，当我们需要一个出色的排版时，它们应该始终被考虑。图像、SVG、Coufons和类似类型与文本不太兼容。我们可能会使用这些来获得出色的文本外观，但搜索引擎无法访问文本，大多数辅助功能软件将忽略它，甚至可能使页面大小变大。另一方面，使用文本允许我们对数据进行各种CSS调整，我们可以使用选择器，比如`:first-letter`、`:first-line`和`:lang`。
- en: There's more...
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Google has a good selection of fonts that we can use that are provided on [http://www.google.com/fonts/](http://www.google.com/fonts/).
    Besides the standard inclusion of fonts, they also have a JavaScript-based font
    loader. This loader solves the problem of seeing the fallback text rendering while
    the "real" font is loading, commonly known as **Flash of Unstyled Text** (**FOUT**).
    There, for example, we can do the following to include a font called `''Noto Sans''`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Google有许多我们可以使用的字体，这些字体可以在[http://www.google.com/fonts/](http://www.google.com/fonts/)上找到。除了标准的字体包含，他们还有一个基于JavaScript的字体加载器。这个加载器解决了在“真正”的字体加载时看到回退文本渲染的问题，通常被称为**未样式化文本的闪烁**（**FOUT**）。例如，我们可以这样做来包含一个名为`'Noto
    Sans'`的字体：
- en: '[PRE73]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Afterwards, we can simply include it in CSS using `font-family: ''Noto Sans'',
    sans-serif;`.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，我们可以简单地在CSS中使用`font-family: ''Noto Sans'', sans-serif;`来包含它。'
- en: Note
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More on the options for Google fonts can be found at [https://developers.google.com/fonts/](https://developers.google.com/fonts/).
    As for the so-called FOUT and some of the ways to fight it there is more on an
    article by *Paul Irish* at [http://paulirish.com/2009/fighting-the-font-face-fout/](http://paulirish.com/2009/fighting-the-font-face-fout/).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Google字体选项的更多信息，请访问[https://developers.google.com/fonts/](https://developers.google.com/fonts/)。至于所谓的FOUT以及一些对抗它的方法，*Paul
    Irish*在[http://paulirish.com/2009/fighting-the-font-face-fout/](http://paulirish.com/2009/fighting-the-font-face-fout/)的文章中有更多内容。
