- en: Chapter 6. Data Validation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。数据验证
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Validating text by length
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过长度验证文本
- en: Validating numbers by range
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过范围验证数字
- en: Using the built-in pattern validation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置模式验证
- en: Advanced use of built-in constraints and custom validations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置约束和自定义验证的高级用法
- en: Calculating password strength
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算密码强度
- en: Validating US zip codes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证美国邮政编码
- en: Using asynchronous server-side validation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步服务器端验证
- en: Combining client-side and server-side validation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合客户端和服务器端验证
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Forms usually expect the user to behave in a certain way and to insert data
    as requested. This is where data validations come in. Server-side validation is
    always a must to do and form validation at the client side should be considered.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表单通常希望用户以某种方式行为，并按要求插入数据。这就是数据验证的作用。服务器端验证始终是必须要做的，应该考虑在客户端进行表单验证。
- en: Validation makes the application user-friendly, saves time and bandwidth. Client-side
    and server-side validation complement each other and they should be used always.
    In this chapter, we are going to look at some new mechanisms provided mostly for
    client-side checks by HTML5 as well as how to tackle some common problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 验证使应用程序用户友好，节省时间和带宽。客户端和服务器端验证相辅相成，应始终使用。在本章中，我们将介绍一些主要用于HTML5客户端检查的新机制，以及如何解决一些常见问题。
- en: Validating text by length
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过长度验证文本
- en: One of the most basic checks at the client side is the length of the text being
    inserted or submitted with the form. This is often left out, but it is one of
    the checks that must be done and not just at the client side. Imagine if we had
    no restriction on any of our inputs, a few large texts could overload the server
    without making much effort.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端进行的最基本检查之一是插入或提交表单的文本长度。这经常被忽略，但这是必须要做的检查之一，不仅仅是在客户端。想象一下，如果我们的输入没有任何限制，一些大文本可能会轻松地使服务器超载。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create a simple HTML form that will contain a few different inputs on
    which we will apply some constrains:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的HTML表单，其中包含一些我们将应用一些约束的不同输入：
- en: 'Head of the page is a standard one, so we will directly go into creating the
    form, first adding the `name` input limited to `20` characters as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面头部是标准的，所以我们将直接进入创建表单，首先添加`name`输入，限制为`20`个字符，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that we will add another `input` field that initially has an invalid
    value, longer than the one specified for testing purpose, as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那之后，我们将添加另一个`input`字段，最初具有无效值，长于指定的测试目的，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, we will add the `textarea` tag that will have the `spellcheck`
    attribute added as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们将添加`textarea`标签，其中将添加`spellcheck`属性，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that we will add two buttons, one for submitting the form and another
    for enabling the JavaScript fallback validation as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那之后，我们将添加两个按钮，一个用于提交表单，另一个用于启用JavaScript备用验证，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since we are going to test out a fallback version using the jQuery Validate
    plugin, we will add the dependency for those two libraries and include our own
    `formValidate.js` file that will be defined later:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用jQuery Validate插件测试备用版本，因此我们将添加这两个库的依赖项，并包括我们自己的`formValidate.js`文件，稍后将对其进行定义：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also need to select the form that is to be submitted and add the JavaScript-based
    validations using the plugin, when the button for enabling the fallback is clicked:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要选择要提交的表单，并在单击启用备用按钮时使用插件添加基于JavaScript的验证：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we also add the messages that will be shown on validation errors.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还添加了将显示在验证错误上的消息。
- en: 'The button for enabling JavaScript is used only for demonstrative purpose,
    in a real application you are probably going to have it as a fallback or as the
    only approach. Since we are only checking for maximum length, validation should
    not be a problem unless we previously have rendered the HTML with incorrect values.
    As for the message for validation, at the time of writing it is supported in all
    of the modern browsers and IE 10, but none of the mobile browsers have added support
    for it yet. We can first check that if the browsers support the spellcheck attribute,
    and then act accordingly:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 启用JavaScript的按钮仅用于演示目的，在实际应用中，您可能会将其作为备用或作为唯一方法。由于我们只检查最大长度，除非我们先前使用不正确的值呈现了HTML，否则验证不应该是一个问题。至于验证消息，在撰写本文时，所有现代浏览器和IE
    10都支持，但尚未有移动浏览器添加支持。我们可以首先检查浏览器是否支持拼写检查属性，然后相应地采取行动：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Initially, we will take a look at the `maxlength` attribute. As you would expect
    the browsers do not allow this type of constraint to be broken by user input,
    they generally stop the input after the maximum has been inserted.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将查看`maxlength`属性。正如您所期望的那样，浏览器不允许用户输入违反此类型的约束，它们通常在插入最大值后停止输入。
- en: So the question is how can this constraint be violated?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题是如何违反此约束？
- en: 'Well, if the rendered HTML is invalid to start with or if the data was changed
    programmatically, then the form will be submitted without validation. This is
    actually the specified behavior; there is a dirty flag that designates if the
    input was from the user or not. In our case, as long as we don''t change anything
    in the input labeled **Initially invalid**, the form will get submitted successfully.
    On the other hand, when the user changes some of the data in that element the
    form fails with a validation error, as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，如果渲染的HTML一开始就是无效的，或者如果数据是以编程方式更改的，那么表单将在没有验证的情况下提交。这实际上是指定的行为；有一个脏标志，指示输入是否来自用户。在我们的情况下，只要我们不在标记为**最初无效**的输入中更改任何内容，表单就会成功提交。另一方面，当用户更改该元素中的一些数据时，表单将因验证错误而失败，如下面的屏幕截图所示：
- en: '![How it works...](img/9282OT_06_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_06_01.jpg)'
- en: validation pop up as shown on Chrome Version 28 development release
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome Version 28开发版本上显示的验证弹出窗口
- en: In the validation error pop up displayed beside the error message will have
    the contents of the `title` attribute, meaning that this attribute has another
    usage besides the standard hint. This message box looks differently on various
    browsers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证错误弹出窗口中显示的旁边的错误消息将具有`title`属性的内容，这意味着除了标准提示之外，此属性还有另一个用途。这个消息框在不同的浏览器上看起来不同。
- en: 'Even though the major control when enabling grammar and spellchecker on the
    browsers is up to the user, there is an attribute called `spellcheck`, that can
    be added to hint the browser to do spelling checks. In our example, the comment
    would look like the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在浏览器上启用语法和拼写检查的主要控制权在用户手中，但有一个名为`spellcheck`的属性，可以添加以提示浏览器进行拼写检查。在我们的例子中，注释将如下屏幕截图所示：
- en: '![How it works...](img/9282OT_06_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_06_02.jpg)'
- en: 'This attribute is inheritable and can be combined with the `lang` attribute.
    For example, if we have the following snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是可继承的，并且可以与`lang`属性结合使用。例如，如果我们有以下片段：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the example we have multiple different languages used. Since the page has
    the `lang="en"` attribute set, the English dictionary will be used for all elements
    that are nested inside. And because the `div` element has the `lang="fr"` attribute,
    all the nested elements (`textarea` and `input type = text`) will be checked against
    the French dictionary.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中使用了多种不同的语言。由于页面设置了`lang="en"`属性，因此嵌套在其中的所有元素都将使用英语词典。而因为`div`元素具有`lang="fr"`属性，所有嵌套的元素（`textarea`和`input
    type = text`）将根据法语词典进行检查。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More on the spellcheck can be found on the WHATWG page [http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#spelling-and-grammar-checking](http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#spelling-and-grammar-checking).
    One other thing to note is that the `spellcheck` attribute in the past had to
    be set to `true` or `false`, but with the latest changes it can be left to be
    empty [http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.spellcheck](http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.spellcheck).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有关拼写检查的更多信息可以在WHATWG页面上找到[http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#spelling-and-grammar-checking](http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#spelling-and-grammar-checking)。还有一件事要注意的是，过去`spellcheck`属性必须设置为`true`或`false`，但是最新更改后可以留空[http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.spellcheck](http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.spellcheck)。
- en: Why do we say that the user has the full control? Well, if the user had always
    picked spellcheck in the browser or never checked, that option overrides the behavior
    that comes with this tag. This attribute can be applied to text input related
    elements, as well as the elements whose content has been made editable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们说用户有完全控制权呢？嗯，如果用户一直在浏览器中选择拼写检查或从未检查过，那么该选项将覆盖此标签的行为。此属性可以应用于文本输入相关元素，以及其内容已被编辑的元素。
- en: Fallback or in a way different approach is to use JavaScript to validate for
    the text length. Because there is no `minlength` attribute in HTML5, there is
    no standard way of validation for minimal length. Therefore, we are going to use
    jQuery Validation plugin. There is a way to do this also by using the `pattern`
    attribute and regex, but that we are going to discuss in detail later in the *Using
    built-in pattern validation* recipe in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 备用或以不同的方式是使用JavaScript来验证文本长度。因为HTML5中没有`minlength`属性，所以没有标准的最小长度验证方式。因此，我们将使用jQuery验证插件。还有一种方法可以使用`pattern`属性和正则表达式来做到这一点，但我们将在本章的*使用内置模式验证*中详细讨论。
- en: 'To enable the validation, we select the form and set the rules by specifying
    the validation rule, where the keys are the form parameter names, and values are
    the applied validation checks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用验证，我们选择表单并通过指定验证规则来设置规则，其中键是表单参数名称，值是应用的验证检查：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After that, we add the message for each individual check, where again the keys
    are the form parameter names as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们为每个单独的检查添加消息，其中键再次是表单参数名称，如下所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The validation rules will also include the original attributes added to the
    form elements. In our case, the input labeled **Initially invalid** has the `maxlength`
    attribute, and this will be added as part of other rules that are part of the
    JavaScript configuration. Also, the rules that are defined in JavaScript can be
    moved to be a part of appropriate form elements. Finally, the result of the JavaScript
    version should look something like the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 验证规则还将包括添加到表单元素的原始属性。在我们的例子中，标记为**最初无效**的输入具有`maxlength`属性，这将作为JavaScript配置的其他规则的一部分添加。此外，JavaScript中定义的规则可以移动为适当的表单元素的一部分。最后，JavaScript版本的结果应该看起来像以下的屏幕截图：
- en: '![How it works...](img/9282OT_06_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_06_03.jpg)'
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The style of the side text displayed by the jQuery Validation plugin in our
    example is the same as labels. There is a simple CSS class named `.error` added
    when there are validation errors, also there is an option to execute function
    when validation problem happens or is removed. This can be done while configuring
    the validate element as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，jQuery验证插件显示的侧边文本的样式与标签相同。当存在验证错误时，会添加一个名为`.error`的简单CSS类，还有一个选项在发生验证问题时或被移除时执行函数。这可以在配置验证元素时完成，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As far the topic of styling validation messages and elements is concerned, they
    will be discussed later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就样式验证消息和元素而言，它们将在本章后面讨论。
- en: Validating numbers by range
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按范围验证数字
- en: When it comes down to numbers in forms, the basic validation is to check if
    the number is in a given range. For achieving this, there are the `min` and `max`
    attributes that should be applied to input types number, range, and date/time
    related inputs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到表单中的数字时，基本验证是检查数字是否在给定范围内。为了实现这一点，应该将`min`和`max`属性应用于数字、范围和日期/时间相关的输入。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We will create a form containing a few input elements that need to have a range
    restriction, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含几个输入元素的表单，这些元素需要进行范围限制，如下所示：
- en: 'First of all, we will start by creating the form with a number `input` field
    for age, limiting it to minimum of `18`, as given in the following code snippet:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过创建年龄为`18`的数字`input`字段来开始，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will add the `range` input for the `Bet` value the user would place as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加`range`输入，用于用户将下注的**Bet**值，如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, we include inputs limited with `min`, `max`, and `step` as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还包括以下限制为`min`、`max`和`step`的输入：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, we will add the dependency for jQuery, our `example.js`, and an
    input `submit` as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将添加jQuery的依赖项，我们的`example.js`，以及一个输入`submit`，如下所示：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will also just link the range input with the output field in order to have
    a simple display in the `example.js` script, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在`example.js`脚本中简单地将范围输入与输出字段链接起来，以便进行简单的显示，如下所示：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you might expect, the range for the age 18 to 140 is expected by the user,
    and if that input is not in that range we get an underflow constraint violationthat
    will display the appropriate (**The value must be greater than or equal to {min}**)
    message. Similarly, we get an overflow constraint violation with the message,
    **Value must be less than or equal to {max}**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，用户期望年龄在`18`到`140`之间，如果输入不在该范围内，我们将得到一个下溢约束违规，显示适当的（**值必须大于或等于{min}**）消息。同样，我们得到一个溢出约束违规，显示消息，**值必须小于或等于{max}**。
- en: 'For the input type `range`, there is no way for the user to get outside the
    range or even to trigger the step mismatch validation error. The step mismatch
    error should only be triggered if the initial value was not within the `min` value
    and some multiples of the `step` attribute:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入类型`range`，用户无法超出范围，甚至无法触发步骤不匹配的验证错误。步骤不匹配错误应该只在初始值不在`min`值内以及`step`属性的倍数时触发：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here `11` should not be valid, because the value of the `step` attribute is
    `3`, and there is no way of getting to `11` using a slider, but the value is initially
    as such, so we should get an validation error, but this is browser specific. Most
    of the current versions of the browsers just correct the initially selected value
    while rendering.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`11`不应该是有效的，因为`step`属性的值是`3`，并且没有办法使用滑块到达`11`，但是初始值就是这样，所以我们应该得到一个验证错误，但这取决于浏览器。大多数当前版本的浏览器在渲染时只是纠正了最初选择的值。
- en: 'If we try to submit the form for the **Doubles** input we should get a validation
    message, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试提交**双打**输入的表单，我们应该会收到一个验证消息，如下面的截图所示：
- en: '![How it works...](img/9282OT_06_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/9282OT_06_06.jpg)'
- en: Here we receive the message because the value is `4`, but the constrains are
    `min="0" step="5" max="10"`, meaning that the value entered must be a multiple
    of `5`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们收到消息，因为值是`4`，但约束是`min="0" step="5" max="10"`，这意味着输入的值必须是`5`的倍数。
- en: The user cannot get a validation message using the input type `range`, but this
    can happen using an input type `number`, since the user can manually Insert data
    here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用户无法使用输入类型`range`获得验证消息，但是使用输入类型`number`可以，因为用户可以在此手动插入数据。
- en: Using the built-in pattern validation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置的模式验证
- en: In order to create more complex validation, we need to use JavaScript. To ease
    the development, the `pattern` attribute was introduced for the `input` fields.
    This enables us to use regex for making validation checks, and in this recipe
    we will take a look at some of the elements that can be used in it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更复杂的验证，我们需要使用JavaScript。为了简化开发，引入了`input`字段的`pattern`属性。这使我们能够使用正则表达式进行验证检查，在本教程中，我们将看一些可以在其中使用的元素。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'In this example, we will create a form using simple HTML as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用简单的HTML创建一个表单，如下所示：
- en: 'First, we will add the form directly in the `body` section, starting with the
    **Username** field:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将直接在`body`部分添加表单，从**用户名**字段开始：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will add **Phone** as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加**电话**，如下所示：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will include `url` for **Webpage** as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将包括**网页**的`url`，如下所示：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will add the **Emails** and **Gmail** input as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加**电子邮件**和**Gmail**输入，如下所示：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `pattern` attribute, if specified, uses an earlier version of the JavaScript
    regex. Whole text must be matched against the given expression. For our example,
    we used loose validation, where, for example, for input type `tel`, we allow numbers
    and optional leading `+` specified by the pattern `[\+]?[1-9]+`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了`pattern`属性，则使用早期版本的JavaScript正则表达式。整个文本必须与给定的表达式匹配。对于我们的例子，我们使用了宽松的验证，例如对于输入类型`tel`，我们允许数字和可选的前导`+`，由模式`[\+]?[1-9]+`指定。
- en: 'Some of the other input types, such as `URL` and `email` use their built-in
    validation. All mails must match the following regex:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他输入类型，如`URL`和`email`，使用它们内置的验证。所有邮件必顶匹配以下正则表达式：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now this is very permissive so we can add additional validations as we added
    in the input labeled **Gmail**. Constrains can be combined, or if some attribute
    accepts multiple entries all of these will get validated according the constrains,
    as we did in the following e-mails example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是非常宽容的，所以我们可以添加额外的验证，就像我们在标记为**Gmail**的输入中添加的那样。约束可以组合，或者如果某个属性接受多个条目，所有这些条目都将根据约束进行验证，就像我们在以下电子邮件示例中所做的那样：
- en: '![How it works...](img/9282OT_06_07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/9282OT_06_07.jpg)'
- en: Also remember that we need to add a hint using title or placeholder or any other
    way, because the user will get the **Please match the requested format** message
    by default, and will not know what is he or she doing wrong.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，我们需要使用title或placeholder或其他方式添加提示，因为用户将默认收到**请匹配请求的格式**消息，并且不知道自己做错了什么。
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a site named [http://html5pattern.com/](http://html5pattern.com/) that
    is intended as the source of regularly used input patterns. It's definitely a
    good resource, and we encourage you to visit it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为[http://html5pattern.com/](http://html5pattern.com/)的网站，旨在作为常用输入模式的来源。这绝对是一个很好的资源，我们鼓励您访问它。
- en: Advanced use of built-in constraints and custom validations
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置约束和自定义验证的高级用法
- en: So far, we have already used some of the built-in validation mechanisms. Now
    we are going to take a deeper look at some of them, and how we can add our own
    customization. We will change the style and apply some more advanced checks as
    well, when we will see how we can disable validation on certain elements by creating
    a form that has most of these features.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了一些内置的验证机制。现在我们将更深入地研究其中一些，并了解如何添加自定义内容。当我们创建一个具有大多数这些功能的表单时，我们还将更改样式并应用一些更高级的检查，以及看到如何在某些元素上禁用验证。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The current working draft version for the form validation can be found at [http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation](http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表单验证的当前工作草案版本可以在[http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation](http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation)找到。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create a form that will have error messages styled using CSS, and custom
    validation using HTML and JavaScript as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个表单，其中将使用CSS样式的错误消息，并使用HTML和JavaScript进行自定义验证，如下所示：
- en: 'We will start off by creating the head section, where we will include `example.css`,
    where the CSS file will contain selectors for the `input` elements with valid,
    invalid, optional, and required state:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建头部部分，在其中包括`example.css`，其中CSS文件将包含具有有效、无效、可选和必需状态的`input`元素的选择器：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next step is to create the `example.css` file. The `valid.png` image can
    be found in the source examples. In real life, you would probably not use all
    of these states to style the look of the forms, but we added it here in order
    to show what can be done:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建`example.css`文件。`valid.png`图像可以在源示例中找到。在现实生活中，您可能不会使用所有这些状态来设计表单的外观，但我们在这里添加它是为了展示可以做什么：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CSS `box-shadow` is not fully supported in legacy browsers, for example IE 8\.
    The specification for `box-shadow` can be found at [http://www.w3.org/TR/css3-background/#box-shadow](http://www.w3.org/TR/css3-background/#box-shadow).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CSS `box-shadow`在旧版浏览器中并不完全支持，例如IE 8。`box-shadow`的规范可以在[http://www.w3.org/TR/css3-background/#box-shadow](http://www.w3.org/TR/css3-background/#box-shadow)找到。
- en: 'Following the `head` section, we will start with adding the form elements in
    the `body` section. First, we will add the `name` and `nickname` fields, making
    them `required`, and for which later we will ensure not to have the same value:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`head`部分之后，我们将开始在`body`部分中添加表单元素。首先，我们将添加`name`和`nickname`字段，使它们成为`required`，稍后我们将确保它们的值不相同：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also include two date/time related inputs, one for `week` and other
    for `month`, where we will limit the weeks from second week of 2013 to second
    week of 2014 and allow every other month to be selected:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以包括两个与日期/时间相关的输入，一个用于`week`，另一个用于`month`，我们将限制周数从2013年第二周到2014年第二周，并允许选择其他每个月：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, we will add three buttons: one for submitting the form, another for checking
    the validity using JavaScript, and one more for submitting without validation
    and constraint checks:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们将添加三个按钮：一个用于提交表单，另一个用于使用JavaScript检查有效性，另一个用于在没有验证和约束检查的情况下提交：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Outside the form, we will add one `div` element for displaying some log information:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单之外，我们将添加一个`div`元素来显示一些日志信息：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As for the JavaScript, we add the dependency for jQuery and include `example.js`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于JavaScript，我们添加了jQuery的依赖项并包括`example.js`：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `example.js` file, we will add an event for the check validity button,
    where we will print the `ValidityState` value to `validLog`, on the validation
    errors of each of the form elements:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`example.js`文件中，我们将为检查有效性按钮添加一个事件，在其中我们将打印每个表单元素的验证错误的`ValidityState`值到`validLog`：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To add custom validation, we will use the `.setCustomValidity()` method, so
    it will check if the `name` and `nickname` values are the same, and if so, we
    will add validation error, and if they are not, we will remove the custom check:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加自定义验证，我们将使用`.setCustomValidity()`方法，因此它将检查`name`和`nickname`的值是否相同，如果是，我们将添加验证错误，如果不是，我们将删除自定义检查：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `required` attribute marks the HTML element inside the form, required to
    have a value before the form can be submitted. The first field that will not have
    a value would get focused upon submission and a hint with a message would be shown
    to the user:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`required`属性标记了表单内的HTML元素，要求在提交表单之前必须有一个值。第一个没有值的字段将在提交时获得焦点，并向用户显示带有消息的提示：'
- en: '![How it works...](img/9282OT_06_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_06_04.jpg)'
- en: 'There are several ways to customize the message displayed to the user on Firefox;
    we can use the `x-moz-errormessage` attribute. In our case, this is `x-moz-errormessage="We
    need this."`, but this will only work there. On Chrome, the `title` attribute
    gets additionally displayed beside the standard message, but the original message
    stays. Another way for changing the message would be to set the value using JavaScript:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox上，有几种自定义显示给用户的消息的方法；我们可以使用`x-moz-errormessage`属性。在我们的情况下，这是`x-moz-errormessage="We
    need this."`，但这只在那里起作用。在Chrome上，`title`属性还会在标准消息旁边额外显示，但原始消息仍然存在。更改消息的另一种方法是使用JavaScript设置值：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As for styling the form elements, there are the CSS pseudo class selectors `:required`
    and `:optional`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 至于样式化表单元素，有CSS伪类选择器`:required`和`:optional`。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In WebKit, there are browser-specific CSS selectors that can be used to style
    the hint box, which are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebKit中，有特定于浏览器的CSS选择器，可以用来设置提示框的样式，如下所示：
- en: '`::-webkit-validation-bubble {…}`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`::-webkit-validation-bubble {…}`'
- en: '`::-webkit-validation-bubble-message {…}`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`::-webkit-validation-bubble-message {…}`'
- en: But because they are browser-specific, they are not very helpful in a practical
    use case.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是因为它们是特定于浏览器的，它们在实际使用中并不是非常有用。
- en: The `min`, `max`, and `step` attributes can be used on date-related input types
    and not just on numbers. The default step is one day for date type, one week for
    week types, and so on. If we set a different step than the default one, for example
    on the month input if we have the step with value two, the user will not be able
    to select every other month from the DatePicker control, but he or she can still
    enter the wrong date in text, triggering `stepMismatch`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`min`、`max`和`step`属性可以用于与日期相关的输入类型，而不仅仅是数字。日期类型的默认步长是一天，周类型是一周，依此类推。如果我们设置一个与默认步长不同的步长，例如在月份输入上，如果我们将步长设置为2，用户将无法从日期选择器控件中选择每隔一个月，但仍然可以在文本中输入错误的日期，触发`stepMismatch`。'
- en: 'Because validation is triggered before the form is submitted, and if the input
    is invalid, the `submit` event is never called. If we need to have a way of submitting
    data without validation, we can do that by using the `formnovalidate` attribute
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因为验证是在提交表单之前触发的，如果输入无效，`submit`事件将不会被调用。如果我们需要在不进行验证的情况下提交数据，可以使用`formnovalidate`属性，如下所示：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We may sometimes need to access the `validityState` value of an element from
    JavaScript; for that purpose there is a `checkValidity()` method executed on the
    form and the input elements in the form. As the name suggests, it checks the state
    of elements, and when it is called on the form, all the child elements are checked
    for validation and additionally, we can call the method on each individual element,
    for example `input`, `select`, or `textarea`. In our case for the form, it was
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要从JavaScript中访问元素的`validityState`值；为此，可以在表单和表单中的输入元素上执行`checkValidity()`方法。顾名思义，它检查元素的状态，当它在表单上调用时，所有子元素都会被检查验证，此外，我们还可以在每个单独的元素上调用该方法，例如`input`、`select`或`textarea`。在我们的情况下，对于表单，它是这样的：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `$(''form'')[0]` element gives us the wrapped DOM element of the selected
    jQuery''s object, this can also be done by calling `.get()` on the selected element.
    Each element has a `validitystate` value that we can read as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(''form'')[0]`元素给我们提供了所选jQuery对象的包装DOM元素，也可以通过在所选元素上调用`.get()`来完成。每个元素都有一个我们可以读取的`validitystate`值，如下所示：'
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are several built-in checks we can access at this point that are properties
    of the `validityState` object: `valueMissing`, `typeMismatch`, `patternMismatch`,
    `tooLong`, `rangeUnderflow`, `rangeOverflow`, `stepMismatch`, `badInput`, and
    `customError`. Each of these will return `true` if there is such constraint violation.
    In the example code for this recipe, we just print out the name of the constraint
    violation to the log.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以访问`validityState`对象的几个内置检查，例如：`valueMissing`、`typeMismatch`、`patternMismatch`、`tooLong`、`rangeUnderflow`、`rangeOverflow`、`stepMismatch`、`badInput`和`customError`。如果存在这样的约束违规，每个都将返回`true`。在本示例代码中，我们只是将约束违规的名称打印到日志中。
- en: 'What happens if we have fields that depend on each other or when we need to
    implement some custom validation logic? No problem there we are covered, we can
    use the `setCustomValidity()` method on each of the fields that depend. In our
    case, we wanted the input for the `name` and `nickname` variables to be different.
    So we added change listener and if they are the same we just set the message with
    `customValidity("your message here")` and when we need to remove the violation,
    we set the message to be an empty string:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有相互依赖的字段，或者需要实现一些自定义验证逻辑，会发生什么？没问题，我们可以在每个依赖字段上使用`setCustomValidity()`方法。在我们的情况下，我们希望`name`和`nickname`变量的输入不同。因此，我们添加了更改监听器，如果它们相同，我们只需使用`customValidity("your
    message here")`设置消息，当我们需要移除违规时，我们将消息设置为空字符串：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Additionally, there are two more CSS pseudo selectors for `:valid` and `:invalid`
    that we will be used to style elements, depending on their `validityState` value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个CSS伪选择器`:valid`和`:invalid`，我们将用它们来根据它们的`validityState`值来设置元素的样式。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The specification for client-side form validation can be found at: [http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation](http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation).
    As for the constraints API, more info is found at [http://www.whatwg.org/specs/web-apps/current-work/#the-constraint-validation-api](http://www.whatwg.org/specs/web-apps/current-work/#the-constraint-validation-api).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端表单验证的规范可以在以下网址找到：[http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation](http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation)。至于约束API，更多信息可以在[http://www.whatwg.org/specs/web-apps/current-work/#the-constraint-validation-api](http://www.whatwg.org/specs/web-apps/current-work/#the-constraint-validation-api)找到。
- en: One important thing to note is that all the browsers do not have full support
    for all the features. IE 9, for example, has no support for any of the constrains
    as well as none of the new input types. More on current browsers support can be
    found at [http://caniuse.com/#search=form%20vali](http://caniuse.com/#search=form%20vali)
    and [http://www.quirksmode.org/compatibility.html](http://www.quirksmode.org/compatibility.html).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，并非所有浏览器都完全支持所有功能。例如，IE 9没有对任何约束或新输入类型的支持。有关当前浏览器支持的更多信息，请访问[http://caniuse.com/#search=form%20vali](http://caniuse.com/#search=form%20vali)和[http://www.quirksmode.org/compatibility.html](http://www.quirksmode.org/compatibility.html)。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we want to use some of the attributes to disable the entire form from validating,
    we can set the form attribute called `novalidate`. For example, this will disable
    the checks, but allow use of `min` and `max` for input type range.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用一些属性来禁用整个表单的验证，我们可以设置表单属性称为`novalidate`。例如，这将禁用检查，但允许使用输入类型范围的`min`和`max`。
- en: 'There is an another way to disable the standard browser hint box and create
    a custom one:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法可以禁用标准浏览器提示框并创建自定义提示框：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Several questions should be thought through before using built-in constraints:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用内置约束之前，应该考虑几个问题：
- en: Do we need to know when the user has clicked on the **Submit** button?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要知道用户何时点击了**提交**按钮吗？
- en: Do we need client-side validation for browsers that don't support the Form Validation
    API yet?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否需要为不支持表单验证API的浏览器提供客户端验证？
- en: If we need to know when the user has tried to submit the form, we can attach
    event listener for click rather than submit. As for legacy browsers, we may choose
    to rely on server-side validation that must be present, but if we don't want to
    lose functionality at the client side, there are some ways of doing this by adding
    webshim, [http://afarkas.github.com/webshim/demos/index.html](http://afarkas.github.com/webshim/demos/index.html).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要知道用户何时尝试提交表单，我们可以附加点击事件监听器，而不是提交。至于旧版浏览器，我们可以选择依赖必须存在的服务器端验证，但如果我们不想在客户端失去功能，可以通过添加webshim的方式来做到这一点，[http://afarkas.github.com/webshim/demos/index.html](http://afarkas.github.com/webshim/demos/index.html)。
- en: '![There''s more...](img/9282OT_06_07.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/9282OT_06_07.jpg)'
- en: Calculating password strength
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算密码强度
- en: A lot of websites display the strength of the password chosen by the user on
    their registration forms. The goal of this practice is to help the user choose
    a better, stronger password which cannot be guessed or brute-forced easily.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站在其注册表单上显示用户选择的密码强度。这种做法的目标是帮助用户选择一个更好、更强的密码，这样就不容易被猜测或暴力破解。
- en: In this recipe, we're going to make a password strength calculator. It will
    determine the password strength by calculating the number of brute-force attempts
    that a potential attacker must make before guessing the password. It will also
    warn the user if his password is in a list of 500 commonly used passwords.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将制作一个密码强度计算器。它将通过计算潜在攻击者必须在猜测密码之前进行的暴力破解尝试的数量来确定密码强度。它还会警告用户，如果他的密码在500个常用密码列表中。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'Before we begin, its important to look at how we''re going to calculate the
    number of brute-force attempts that an attacker must make. We''re going to take
    a look at two factors: the length of the password and the size of the character
    set used by the user.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，重要的是要看一下我们将如何计算攻击者必须进行的暴力破解尝试的数量。我们将看两个因素：密码的长度和用户使用的字符集的大小。
- en: 'The size of the character set can be determined as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 字符集的大小可以通过以下方式确定：
- en: If the user adds a lowercase alphabet letter in his password, the size of the
    character set grows by 26 (the number of letters in the alphabet)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在密码中添加小写字母表字母，则字符集的大小将增加26（字母表中的字母数）
- en: Additional 26 are added if the user uses an uppercase letter anywhere except
    at the beginning of the password
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在密码中的任何位置使用大写字母，将添加额外的26个字符
- en: 10 characters are added if the user adds a number
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户添加一个数字，则添加10个字符
- en: 24 characters are added if the user adds a special character such as dot, comma,
    braces, ampersand, and so on
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户添加特殊字符，如句号、逗号、括号、和等，则添加24个字符
- en: 20 characters are added if the user uses a unicode character not found in other
    tables
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户使用其他表中找不到的Unicode字符，则添加20个字符
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write the HTML and JavaScript code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML和JavaScript代码：
- en: 'Create a simple HTML page with a `password` input, then add a `div` element,
    which we will update with the password strength result. Common passwords will
    be included via a script named `common-passwords.js`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的HTML页面，其中包含一个`password`输入，然后添加一个`div`元素，我们将使用密码强度结果进行更新。常见密码将通过名为`common-passwords.js`的脚本包含：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `common-passwords.js` script is not included here, but can be found in the
    supplementary code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`common-passwords.js`脚本没有包含在这里，但可以在附加代码中找到。'
- en: 'The code checking the logic is in `example.js`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查逻辑的代码在`example.js`中：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Update the `div` element indicating password strength when a key is pressed
    in the `password` field:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`password`字段中按下键时，更新指示密码强度的`div`元素：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The calculation is split into two parts: checking for password commonality
    and password complexity.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 计算分为两部分：检查密码的普遍性和密码的复杂性。
- en: We check if the password is common simply by checking if it can be found in
    the `commonPasswords` array provided by `common-password.js`. `Array#indexOf`
    returns 1 if the entry was not found. The bitwise not operator `~` turns that
    value into zero, which evaluates to false. All the other numbers greater than
    or equal to 0 will have negative values, which are true values. Thus, the entire
    expression returns true if the password is found in the array.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查密码是否可以在`commonPasswords`数组中找到来检查密码是否常见，该数组由`common-password.js`提供。如果未找到条目，`Array#indexOf`返回1。按位非运算符`~`将该值转换为零，这等于false。所有大于或等于0的其他数字将具有负值，这是true值。因此，如果在数组中找到密码，则整个表达式返回true。
- en: 'In the `bruteMagnitude` function we calculate the password''s brute-force order
    of magnitude using the `passwordLength` and character `setsize` methods:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bruteMagnitude`函数中，我们使用`passwordLength`和字符`setsize`方法计算密码的暴力破解数量级：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is an approximate order of magnitude of the number of passwords that a
    brute-force password attacker must try to guess the password.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是暴力破解密码攻击者必须尝试猜测密码的密码数量级的近似值。
- en: 'Based on this information, we can now give an actual password strength. If
    the password is among the top 500 common passwords, it will be classified as poor.
    Otherwise it will be classified according to its brute force magnitude using the
    following table:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，我们现在可以给出实际的密码强度。如果密码属于前500个常见密码之一，它将被分类为弱密码。否则，它将根据其暴力破解强度按照以下表进行分类：
- en: '| Magnitude | Number of passwords | Rating |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 数量级 | 密码数量 | 评级 |'
- en: '| --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Less than 7 | Less than 10 million | Very poor |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 少于7 | 少于1000万 | 非常差 |'
- en: '| 7 to 8 | 10 million to 1 billion | Poor |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 7到8 | 1000万到10亿 | 差 |'
- en: '| 9 to 10 | 1 billion to 100 billion | Passing |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 9到10 | 10亿到1000亿 | 通过 |'
- en: '| 11 to 12 | 100 billion to 10 trillion | Fair |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 11到12 | 1000亿到10万亿 | 公平 |'
- en: '| 13 to 14 | 10 trillion to 1 quadrillion | Good |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 13到14 | 10万亿到1千万亿 | 良好 |'
- en: '| 15 to 17 | 1 to 100 quadrillion | Very good |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 15到17 | 1到100万亿 | 非常好 |'
- en: '| Greater than 17 | Greater 100 quadrillion | Excellent |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 大于17 | 大于100万亿 | 优秀 |'
- en: The classification, along with the descriptive text will be updated on every
    key press and displayed to the user below the password field.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 分类，以及描述性文本将在每次按键时更新，并显示给用户在密码字段下方。
- en: Validating US zip codes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证美国邮政编码
- en: Validating zip codes at the client side can be useful on web pages with address
    forms.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上具有地址表单的情况下，在客户端验证邮政编码可能会很有用。
- en: Entering numbers is an error-prone process. It would be great for the user if
    we could provide some kind of basic immediate validation to inform them of a possible
    error in their data entry.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数字是一个容易出错的过程。如果我们能够提供一些基本的即时验证来告知用户可能在其数据输入中出现的错误，那对用户来说将会很好。
- en: On the other hand, a satisfyingly complete zip code database has a non-trivial
    size. Loading the complete database at the client side might be difficult and
    non-optimal.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个令人满意的完整邮政编码数据库具有非平凡的大小。在客户端加载完整数据库可能会很困难且不太理想。
- en: In this recipe, we're going to write a client-side zip code validation function.
    In the process, we're going to learn what it takes to convert a non-trivial zip
    code database to a smaller representation which can be loaded at the client side.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个客户端邮政编码验证函数。在这个过程中，我们将学习如何将一个非平凡的邮政编码数据库转换为可以在客户端加载的较小表示。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's download the zip code database file first. The [unitedstateszipcode.org](http://unitedstateszipcode.org)
    website provides a free zip code database in a CSV format ([http://www.unitedstateszipcodes.org/zip-code-database/](http://www.unitedstateszipcodes.org/zip-code-database/)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们下载邮政编码数据库文件。[unitedstateszipcode.org](http://unitedstateszipcode.org)网站提供了一个CSV格式的免费邮政编码数据库（[http://www.unitedstateszipcodes.org/zip-code-database/](http://www.unitedstateszipcodes.org/zip-code-database/)）。
- en: We're going to extract a smaller database from this file which can be loaded
    at the client side. To do this, we're going to write a Node.js script, so make
    sure you have Node.js installed. Download Node.js from [http://nodejs.org/](http://nodejs.org/),
    explained in [Appendix A](apa.html "Appendix A. Installing Node.js and Using npm"),
    *Installing Node.js and Using npm*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从该文件中提取一个较小的数据库，该数据库可以在客户端加载。为此，我们将编写一个Node.js脚本，请确保已安装Node.js。从[http://nodejs.org/](http://nodejs.org/)下载Node.js，在[附录A](apa.html
    "附录A. 安装Node.js和使用npm")中有解释，*安装Node.js和使用npm*。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Node.js` is a platform built on top of Chrome''s V8 JavaScript engine, meant
    for writing fast asynchronous network applications. It comes with a great module
    manager called `npm` and a registry containing tens and thousands of module libraries.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.js`是建立在Chrome的V8 JavaScript引擎之上的平台，用于编写快速的异步网络应用程序。它配备了一个名为`npm`的出色模块管理器，以及一个包含数以万计模块库的注册表。'
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the same directory with `zip_code_database.csv`, we're going to create a
    new Node.js script. To process a CSV file, we're going to use a CSV parsing library.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在与`zip_code_database.csv`相同的目录中，我们将创建一个新的Node.js脚本。为了处理CSV文件，我们将使用一个CSV解析库。
- en: 'From a command prompt in the same directory, let''s install the node module
    CSV by running the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从相同目录的命令提示符中，让我们通过运行以下命令来安装node模块CSV：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we''re going to make `createdb.js`, which will parse the CSV file and
    extract the minimum amount of data from it, US state, and zip code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将创建`createdb.js`，它将解析CSV文件并从中提取最少量的数据，即美国州和邮政编码：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, we have a usable array of zip codes. However, if we were to
    write them all directly, it would result in a fairly large 400 KB JSON array,
    150 KB when compressed with GZIP. Many of the valid zip code numbers are sequential.
    We can take advantage of this and represent them as ranges instead. By applying
    this technique we get a 115 KB file, 45 KB when compressed. This size seems a
    lot more acceptable:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们有一个可用的邮政编码数组。但是，如果我们直接写出所有这些邮政编码，将会得到一个相当大的400 KB的JSON数组，在使用GZIP压缩后为150
    KB。许多有效的邮政编码数字是连续的。我们可以利用这一点，将它们表示为范围。通过应用这种技术，我们得到一个115 KB的文件，在压缩后为45 KB。这个大小看起来更加可接受：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The final representation will be a JSON array sorted by the `state` name. Every
    element in this array represents a state and contains two attributes: state name
    and a list of valid zip codes represented as numbers, or zip code ranges represented
    as two-dimensional arrays:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终表示将是一个按“state”名称排序的JSON数组。数组中的每个元素表示一个州，包含两个属性：州名和表示为数字的有效邮政编码列表，或表示为二维数组的邮政编码范围：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Running this script in the command line from the same directory `node createdb.js
    > zipcodedb.js` will result with the `zipcodedb.js` file, which contains the database.
    Here is a sample of the database JSON:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同目录中从命令行中运行此脚本`node createdb.js > zipcodedb.js`将生成`zipcodedb.js`文件，其中包含数据库。以下是数据库JSON的示例：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can now use this database to create the basic validator by including it
    in our `index.html` page. The page will contain a simple state selection dropdown
    and a zip code field. Below the zip code field will be the validation message:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个数据库来创建基本的验证器，将其包含在我们的`index.html`页面中。页面将包含一个简单的州选择下拉菜单和一个邮政编码字段。在邮政编码字段下方将是验证消息：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we''re going to write a `lookup` function to check if a given zip
    code is in our database, which we''re going to use to validate the user input
    as they type. We will populate the states dropdown using the same database:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将编写一个`lookup`函数来检查给定的邮政编码是否在我们的数据库中，我们将在用户输入时用它来验证用户输入。我们将使用相同的数据库填充州下拉菜单：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To validate zip codes at the client side, we first had to convert our database
    to a smaller size.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在客户端验证邮政编码，我们首先需要将数据库转换为更小的大小。
- en: The downloaded database contained a lot of extra data such as city to zip code
    mappings, zip code types, time zone and geographic coordinates, as well as decommissioned
    zip codes. We removed the extra data, leaving only the US zip codes that are still
    in use along with their state.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下载的数据库包含了许多额外的数据，例如城市到邮政编码的映射，邮政编码类型，时区和地理坐标，以及已废弃的邮政编码。我们删除了额外的数据，只留下仍在使用中的美国邮政编码及其所在州。
- en: To reduce the database even further, we represented longer valid zip code ranges
    as arrays containing the first and the last number in the range. This helped to
    reduce the database size further to a reasonable size as compared to the size
    of a medium website image.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步减少数据库，我们将更长的有效邮政编码范围表示为包含范围内第一个和最后一个数字的数组。这有助于将数据库大小进一步减小到一个合理的大小，与中等网站图像的大小相比。
- en: To use the database, we wrote a simple `lookup` function that checks if the
    zip code is inside the list of values of `zipcode` and `ranges` in any of the
    states and returns the state if found.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用数据库，我们编写了一个简单的“lookup”函数，检查邮政编码是否在任何州的“zipcode”和“ranges”的值列表中，并在找到时返回州名。
- en: The validation information updates automatically while the user is entering
    the zip code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户输入邮政编码时，验证信息会自动更新。
- en: Using asynchronous server-side validation
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步服务器端验证
- en: 'Many validation checks can only be performed at the server side. The following
    are the examples:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 许多验证检查只能在服务器端执行。以下是示例：
- en: When validating a user registration form, we need to check if the entered username
    is available
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验证用户注册表单时，我们需要检查输入的用户名是否可用
- en: When the user enters a postal address, we might need to ask an external service
    to verify if the address is correct
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户输入邮政地址时，我们可能需要向外部服务询问地址是否正确
- en: The problem with server-side validation checks is that they need to be asynchronous.
    As a result, they cannot be written in JavaScript as functions that return validation
    results.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端验证检查的问题在于它们需要是异步的。因此，它们不能被写成JavaScript函数，返回验证结果。
- en: To solve this problem, in this recipe we're going to make a validator that uses
    the continuation-passing style. The example has a username input field that is
    validated against the server. The server checks if the username is available for
    registration or already occupied by another user.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在这个示例中，我们将制作一个使用续传风格的验证器。示例中有一个用户名输入字段，用于与服务器进行验证。服务器会检查用户名是否可用于注册或已被其他用户占用。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''re going to briefly look at the continuation-passing style. It''s a style
    used by most of the JavaScript libraries for asynchronous operations, for example,
    server communication. For example in jQuery, instead of writing the following
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍续传风格。这是大多数JavaScript库用于异步操作的风格，例如服务器通信。例如，在jQuery中，我们不是写以下代码：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We write as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写如下：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can apply the same transformation to a validation function as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相同的转换应用于验证函数，如下所示：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will become:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变成：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This means we also need to change the `validate` function. For example, if
    we had as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们还需要更改`validate`函数。例如，如果我们有如下所示：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After transforming it to the continuation-passing style we will have:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为续传风格后，我们将会有：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This enables us to use the server-side calls, for example, `$.getJSON` in our
    validation function as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在验证函数中使用服务器端调用，例如`$.getJSON`，如下所示：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we can use our server-side validator from the browser.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从浏览器中使用我们的服务器端验证器。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We're going to write the HTML page containing the form to be validated and the
    JavaScript code that implements the validation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写包含要验证的表单和实现验证的JavaScript代码的HTML页面。
- en: 'Let''s start with the HTML page. It must contain a form with a username input
    and a validation result with red text hidden by default:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从HTML页面开始。它必须包含一个带有用户名输入和默认情况下隐藏的红色文本验证结果的表单：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The validation code will be in `example.js` – it contains a function that simulates
    an `async` server call, a function that used to delay the execution of the `async`
    server call to prevent multiple calls, and a function that displays the validation
    result:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证代码将在`example.js`中 - 它包含一个模拟`async`服务器调用的函数，一个用于延迟执行`async`服务器调用以防止多次调用的函数，以及一个显示验证结果的函数：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The code in the `validate` function from `example.js` simulates a server call
    by using the `setTimeout` function. It would be easy to replace this code with
    a real call to the server validation API using something similar to `jQuery.getJSON`
    to get the validation results.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.js`中的`validate`函数中的代码通过使用`setTimeout`函数模拟了服务器调用。可以轻松地用真实的服务器验证API调用替换这段代码，类似于`jQuery.getJSON`来获取验证结果。'
- en: The `createDelayed` function creates a `delayer` object. The `delayer` object
    wraps the function to be delayed. It is different from `setInterval`, because
    if the `delayer` object is called again before the delay expires, the previous
    timeout will be canceled and restarted. This helps us to avoid overloading the
    server with requests on every single keystroke, instead the request is sent `1500ms`
    after the user stops typing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`createDelayed`函数创建一个`delayer`对象。`delayer`对象包装要延迟的函数。它不同于`setInterval`，因为如果在延迟到期之前再次调用`delayer`对象，先前的超时将被取消并重新启动。这有助于我们避免在每次按键时向服务器发送请求，而是在用户停止输入后`1500ms`发送请求。'
- en: We call the `delayer` object on every user keypress, binding "`this`" to `null`,
    the first argument to the current value of the input field, and the `callback`
    function to a function that shows the returned validation error if it exists.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每次用户按键时调用`delayer`对象，将"`this`"绑定到`null`，将第一个参数绑定到输入字段的当前值，将`callback`函数绑定到一个函数，如果存在返回的验证错误，则显示它。
- en: Combining client-side and server-side validation
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合客户端和服务器端验证
- en: When dealing with real web forms we usually need to do various kinds of validation
    on multiple fields. Some fields may only need checks that can be performed at
    the client side, while some might also require server-side validation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理真实的Web表单时，我们通常需要对多个字段进行各种验证。一些字段可能只需要在客户端执行的检查，而有些可能还需要服务器端验证。
- en: In this recipe, we're going to design and implement our own validation plugin
    that supports asynchronous validation. It will work similarly to jQuery Validate.
    We're also going to implement some basic validation methods such as `required`,
    `minLength`, and `remote`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将设计和实现自己的验证插件，支持异步验证。它将类似于jQuery Validate的工作。我们还将实现一些基本的验证方法，如`required`、`minLength`和`remote`。
- en: We're going to use these methods on a simple user registration form, which will
    be blocked from submission until the user enters valid data in all fields.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个简单的用户注册表单上使用这些方法，直到用户在所有字段中输入有效数据为止，该表单将被阻止提交。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step in our design process is to design the data structures that
    will be used in our validator. We''re going to make an API similar to jQuery Validate,
    which takes a configuration object as its parameter. However, we''re going to
    opt into a more modern, HTML5 approach where the validation rules are embedded
    into the HTML as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计过程的第一步是设计将在验证器中使用的数据结构。我们将创建一个类似于jQuery Validate的API，它以配置对象作为参数。但是，我们将选择更现代的HTML5方法，其中验证规则嵌入到HTML中，如下所示：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In order to support this rule and message structure, Validate will utilize validation
    plugins.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种规则和消息结构，Validate将利用验证插件。
- en: Each plugin will have a unique name.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插件都将有一个唯一的名称。
- en: 'The plugin will be a function that takes three parameters: the element being,
    the rule parameters object, and a `callback` function to call when the validation
    is complete. The `callback` function will take two arguments: the first will indicate
    if the field is valid and the second will contain the message parameters.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件将是一个接受三个参数的函数：正在进行验证的元素、规则参数对象和在验证完成时调用的`callback`函数。`callback`函数将有两个参数：第一个参数将指示字段是否有效，第二个参数将包含消息参数。
- en: The plugin will prevent the submission of the form unless it verifies the validity
    of all the fields.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件将阻止表单提交，除非验证所有字段的有效性。
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the HTML and JavaScript code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写HTML和JavaScript代码。
- en: 'The `index.html` page will contain the form with its validation rules embedded.
    Note that we can also mix in standard HTML form validation, for example via the
    `required` attribute as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`index.html`页面将包含嵌入其验证规则的表单。请注意，我们还可以混合使用标准的HTML表单验证，例如通过`required`属性，如下所示：'
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The interesting part about this HTML file is that there are no other scripts
    included besides `avalidate.js` and `avalidate-plugins.js`, yet they provide full
    validation to this form.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML文件的有趣之处在于除了`avalidate.js`和`avalidate-plugins.js`之外，没有包含其他脚本，但它们为这个表单提供了完整的验证。
- en: 'Let''s see the code that we need to add to `avalidate.js`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看需要添加到`avalidate.js`的代码：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To properly execute asynchronous validation we need to be able to the delay
    the request until the user stops typing. To do this we use `createDelayed` – it
    creates timeouts which reset themselves on each call:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确执行异步验证，我们需要能够延迟请求，直到用户停止输入。为此，我们使用`createDelayed` - 它创建超时，在每次调用时重置自身：
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`showError` displays the appropriate error besides the form, filling it with
    templated text. The first time it runs, it moves the template out of the `error`
    element inner text and adds into a new attribute:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`showError`在表单旁边显示适当的错误，并用模板文本填充它。第一次运行时，它将模板移出`error`元素的内部文本，并添加到一个新的属性中：'
- en: '[PRE61]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`elementVerifier` executes on an element. It looks up all verifier plugins
    specified by the `data-v-pluginName` attributes, reads the plugin options from
    the attribute, and then runs the async plugin.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`elementVerifier`在一个元素上执行。它查找由`data-v-pluginName`属性指定的所有验证器插件，从属性中读取插件选项，然后运行异步插件。'
- en: 'When all the plugins finish verifying, it marks the element as valid if no
    errors were found. Otherwise it displays the errors as they appear:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有插件完成验证时，如果没有找到错误，它将标记元素为有效。否则，它会显示错误，就像它们出现的那样：
- en: '[PRE62]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`setupFormVerifier` enables the validation process on a certain form by binding
    to all changes, keyboard and mouse events that happen in its fields. It creates
    a separate `delayer` variable for every element and runs the `elementVerifier`
    object with that `delayer`. Finally, it forbids the form submission unless all
    the fields are marked as valid by the `elementVerifier` object:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setupFormVerifier`通过绑定到其字段中发生的所有更改、键盘和鼠标事件，启用了对特定表单的验证过程。它为每个元素创建一个单独的`delayer`变量，并使用该`delayer`运行`elementVerifier`对象。最后，它禁止表单提交，除非`elementVerifier`对象标记所有字段为有效：'
- en: '[PRE63]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following is the part that makes everything work without manual intervention.
    We listen to all the events arriving on the document `body` object, and if an
    event arrives at a form that is supposed to have validation enabled but doesn''t,
    we run `setupFormVerifier` on it (once):'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是使一切无需手动干预的部分。我们监听文档`body`对象上到达的所有事件，如果一个事件到达一个应该启用验证但没有启用的表单，我们就会在其上运行`setupFormVerifier`（一次）：
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The plugins are much easier to write. Here is `avalidate-plugins.js`. Note
    that the server plugin is simulated with `setTimeout`. The same principles apply
    when making an AJAX call:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件更容易编写。这是`avalidate-plugins.js`。请注意，服务器插件是用`setTimeout`模拟的。在进行AJAX调用时，同样的原则也适用：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This validator takes advantage of the new HTML5 data attribute features. HTML5
    does include some great new validation options by adding input element attributes
    and types, but they're not enough. To solve this, we follow the HTML5 model and
    add our own data attributes for validation methods and validation error messages.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个验证器利用了新的HTML5数据属性功能。HTML5通过添加输入元素属性和类型确实包含了一些很棒的新验证选项，但这还不够。为了解决这个问题，我们遵循HTML5模型，并为验证方法和验证错误消息添加了自己的数据属性。
- en: To make these new data attributes work we need to load JavaScript code. One
    of the pitfalls of JavaScript-initialized elements is the need to call the initialization
    functions whenever we add a new element on the page. This plugin successfully
    avoids the pitfall by using the new jQuery binding APIs. Instead of binding to
    the forms directly, the listener is attached to the document `body` object. As
    such, it works with all the form elements including the newly added ones.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些新的数据属性起作用，我们需要加载JavaScript代码。JavaScript初始化元素的一个缺点是，每当我们在页面上添加新元素时，都需要调用初始化函数。这个插件成功地避免了这个缺点，它使用了新的jQuery绑定API。与直接绑定到表单不同，监听器附加到了文档`body`对象上。因此，它可以与所有表单元素一起工作，包括新添加的元素。
- en: The flexible plugins enable easy extension of the validator without modifications
    to the core. Adding a new validation rule is as simple as adding a new function.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活的插件使验证器能够轻松扩展，而无需修改核心。添加新的验证规则就像添加一个新函数一样简单。
- en: Finally, our error messages can have user-friendly templates filled with optional
    message strings provided by the validators.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的错误消息可以包含由验证器提供的可选消息字符串填充的用户友好模板。
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that the JavaScript files start with a semicolon character
    (`;`). This makes them safer for concatenation and minification. If we prepend
    a script that ends with a value (treated as a function call while the entire contents
    of the script without a semicolon) to another that is wrapped within parenthesis,
    the value will be will be treated as an argument to that function call. To avoid
    this, we prepend a semicolon before the parenthesis, terminating any previous
    statements that may be missing a semicolon.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，JavaScript文件以分号字符（`;`）开头。这使它们更安全，可以进行连接和缩小。如果我们在另一个用括号括起来的脚本之前添加一个以值结尾的脚本（在没有分号的情况下将整个脚本内容视为函数调用），那么该值将被视为该函数调用的参数。为了避免这种情况，我们在括号之前添加一个分号，终止可能缺少分号的任何先前语句。
