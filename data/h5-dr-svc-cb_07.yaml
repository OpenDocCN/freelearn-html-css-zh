- en: Chapter 7. Data Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 数据序列化
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Deserializing JSON to JavaScript objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JSON反序列化为JavaScript对象
- en: Serializing objects to JSON strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象序列化为JSON字符串
- en: Decoding base64 encoded binary data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码base64编码的二进制数据
- en: Encoding binary data or text to base64
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制数据或文本编码为base64
- en: Serialization of binary data into JSON
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制数据序列化为JSON
- en: Serializing and deserializing cookies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化和反序列化cookie
- en: Serializing form into request strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表单序列化为请求字符串
- en: Reading XML documents with DOMParser
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DOMParser读取XML文档
- en: Serializing of XML document at the client side
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端对XML文档进行序列化
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One of the basic concepts of data storage and transmission is serialization.
    We are going to go through some of the ways to prepare the data for either sending
    to another environment or saving it permanently. Besides that we will see the
    ways for reading some of the data serialized by another computer environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储和传输的基本概念之一是序列化。我们将介绍一些准备数据以便发送到另一个环境或永久保存的方法。除此之外，我们还将看到一些读取另一个计算机环境序列化的数据的方法。
- en: Deserializing JSON to JavaScript objects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JSON反序列化为JavaScript对象
- en: The simplest of all cases is reading JSON data into JavaScript objects. Data
    formatted in this way is of lightweight and additionally it is a subset of JavaScript.
    There are several ways to read this data and we will take a look at how this can
    be done by creating a simple JSON snippet and then converting it to JavaScript
    objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是将JSON数据读入JavaScript对象。以这种方式格式化的数据是轻量级的，此外它是JavaScript的一个子集。有几种方法可以读取这些数据，我们将看看如何通过创建一个简单的JSON片段，然后将其转换为JavaScript对象来实现这一点。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This example will be simple enough to be a script in an HTML file or even executed
    on a firebug or developer tools console:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子足够简单，可以作为HTML文件中的脚本，甚至可以在firebug或开发者工具控制台上执行：
- en: 'We first need the following serialized JSON string:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要以下序列化的JSON字符串：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are few different ways to do this without adding external JavaScript
    dependency, one is through the use of `eval`, the other is through the use of
    `json`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种不需要添加外部JavaScript依赖项的方法来实现这一点，一种是通过使用`eval`，另一种是通过使用`json`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this we will try to access some of the attributes form the deserialized
    object:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将尝试访问反序列化对象的一些属性：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Upon execution, the first `document.writeln` method should return `undefined`,
    because we are trying to access property on a JSON string that is not yet deserialized,
    while on the other two we should get the value you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，第一个`document.writeln`方法应该返回`undefined`，因为我们正在尝试访问尚未反序列化的JSON字符串上的属性，而在另外两个方法中，我们应该得到值`you`。
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: JSON is language independent format but at the same time JSON is JavaScript,
    meaning that we can use the `eval` function. Now that it is very simple since
    this is a top level function, and it accepts string as input that will get evaluated.
    If the string passed as an argument has JavaScript statements `eval` will perform
    those. This can be a dangerous thing just because it executes the code passed
    to it. If it is used on a code you don't trust, then you might get exploits from
    potentially malicious third party. For most use cases of `eval`, there are good
    alternatives already there. Debugging also can be very hard when we use `eval`,
    so it's something we should avoid in most cases.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种与语言无关的格式，但与此同时JSON是JavaScript，这意味着我们可以使用`eval`函数。现在这非常简单，因为这是一个顶级函数，它接受字符串作为输入进行评估。如果作为参数传递的字符串具有JavaScript语句，`eval`将执行这些语句。这可能是一个危险的事情，因为它执行传递给它的代码。如果它用于您不信任的代码，那么您可能会从潜在恶意的第三方那里获得利用。对于`eval`的大多数用例，已经有很好的替代方案。当我们使用`eval`时，调试也可能非常困难，因此在大多数情况下我们应该避免使用它。
- en: 'When it comes to JSON parsing, on most of the modern browsers we can use the
    `JSON.parse(text[, reviver])` statement that has been added to JavaScript 1.7\.
    This function parses a string as JSON and has the optional argument for having
    a `reviver`, a function that can transform the value being produced by parsing.
    For example, if we wanted to append `"a?"` to each on the values, we can define
    something as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行JSON解析时，在大多数现代浏览器上，我们可以使用已添加到JavaScript 1.7的`JSON.parse(text[, reviver])`语句。该函数解析一个字符串作为JSON，并具有可选参数`reviver`，它是一个可以转换解析产生的值的函数。例如，如果我们想要在每个值上附加`"a?"`，我们可以定义如下内容：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if we try to access `transformed.who` we will get `"you a?"`. The final
    object will contain the following information:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试访问`transformed.who`，我们将得到`"you a?"`。最终对象将包含以下信息：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Meaning that each of the values of the original string that was parsed had the
    value `'a?'` appended to it and the key at given iteration took the values `comment`
    and `who`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着解析的原始字符串的每个值都附加了值`'a?'`，并且在给定迭代中的键取了值`comment`和`who`。
- en: If the `reviver` function returns `undefined` or `null` for a given value, that
    property will get deleted, so it can be used as a filtering mechanism.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`reviver`函数对于给定值返回`undefined`或`null`，那么该属性将被删除，因此它可以用作过滤机制。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What will happen in case of older browsers that don''t support JSON natively.
    There are two simple options, we can just include JSON 2 or JSON 3:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持本地JSON的旧浏览器中会发生什么。有两个简单的选择，我们可以只包含JSON 2或JSON 3：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JSON 3 is a polyfill that is compatible with almost all of the JavaScript platforms
    and in a way, it's the newer implementation of JSON 2 and this is what we should
    use. There are several inconsistencies and special cases that were not handled
    correctly by JSON 2, although at the time of writing the older version was more
    widespread. Additionally, JSON 3 parser does not use `eval` or `regex`, making
    it more secure and giving it performance benefits in mobile were this can be significant.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 3是一个兼容几乎所有JavaScript平台的polyfill，从某种意义上说，它是JSON 2的更新实现，这是我们应该使用的。 JSON 2没有正确处理的几个不一致性和特殊情况，尽管在撰写本文时，旧版本更为普遍。此外，JSON
    3解析器不使用`eval`或`regex`，这使其在移动设备上更安全，并带来性能优势，这在移动设备上可能非常重要。
- en: If you already have jQuery in your project that you can use `jQuery.parseJSON(
    json )` similarity Prototype JS has it's own implementation, `String#evalJSON()`
    .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目中已经有jQuery，您可以使用`jQuery.parseJSON(json)`，类似地，Prototype JS有自己的实现，`String#evalJSON()`。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'One common error is the use of single quotes instead of double quotes. Most
    implementation of JSON do not allow the use of single quote, this was probably
    done for simplicity. To quote Douglas Crockford: JSON''s design goals were to
    be minimal, portable, textual, and a subset of JavaScript. The less we need to
    agree on in order to interoperate, the more easily we can interoperate.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是使用单引号而不是双引号。大多数JSON实现不允许使用单引号，这可能是为了简单起见。引用Douglas Crockford的话：JSON的设计目标是最小化、可移植、文本化，并且是JavaScript的子集。我们在互操作方面需要达成的共识越少，我们就越容易进行互操作。
- en: Serializing objects to a JSON string
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象序列化为JSON字符串
- en: The reverse of the previous recipe is to serialize JavaScript objects into JSON
    string. Similarly the same rules about having browser support for JSON applies
    but again this is not a problem in most of the browsers. One way would be to manually
    create the string, but that is just a way to error-prone and messy browsers, so
    we will try out some of the methods available out there.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个配方的反向操作是将JavaScript对象序列化为JSON字符串。同样，对于浏览器是否支持JSON的规则也适用，但在大多数浏览器中这不是问题。一种方法是手动创建字符串，但这只是一种容易出错和混乱的浏览器方式，因此我们将尝试一些现有的方法。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In the following example we use only JavaScript, so we can place it inside
    a simple script tag in an HTML file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们仅使用JavaScript，因此可以将其放在HTML文件中的简单脚本标记中：
- en: 'First need data in order to serialize it to string, so we will create a simple
    JavaScript object:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先需要数据以便将其序列化为字符串，因此我们将创建一个简单的JavaScript对象：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We create another object where we are going to have the `toJSON()` function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建另一个对象，其中我们将拥有`toJSON()`函数：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to convert the JavaScript object to a string we will use the `JSON.stringify(value
    [, replacer [, space]])` function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将JavaScript对象转换为字符串，我们将使用`JSON.stringify(value [, replacer [, space]])`函数：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After that we will try out the other arguments for that same function where,
    for the `replacer`, we will create a list of allowed properties and for the third
    argument, we will try two different options:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将尝试该函数的其他参数，对于`replacer`，我们将创建一个允许属性的列表，对于第三个参数，我们将尝试两种不同的选项：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can than simply write the output to the document object:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以简单地将输出写入文档对象：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The JSON `stringify` method accepts three arguments, where the last two are
    optional. When used with only one argument it will return a JSON string form the
    JavaScript object, where if some of the properties are undefined inside an object,
    then it is omitted or censored to null when found in array. If there is a `toJSON()`
    function defined inside the object than that function is used to select the object
    that will get converted. This allows the objects to define their own JSON representation.
    In our case, the evaluated version of `JSON.stringify(customToJSON)` will be as
    follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JSON `stringify`方法接受三个参数，最后两个是可选的。当只使用一个参数时，它将返回JavaScript对象的JSON字符串形式，如果对象中的某些属性未定义，则在数组中找到时将被省略或替换为null。如果对象内定义了`toJSON()`函数，则将使用该函数来选择要转换的对象。这允许对象定义其自己的JSON表示。在我们的情况下，`JSON.stringify(customToJSON)`的评估版本将如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The full function definition of `stringify` is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringify`的完整函数定义如下：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can use `replacer` to filter attributes that will get white listed. The `replacer`
    can be an array of `String` and `Number` objects that will serve as an allowed
    list of parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`replacer`来过滤将被列入白名单的属性。`replacer`可以是一个`String`和`Number`对象的数组，它们将作为允许的参数列表。
- en: The `space` argument can be added and have a value of type `String` or a `Number`.
    If it is a `Number`, it indicates the number of space characters to use as white
    spaces. In our examples this can be seen if you open the generated HTML in the
    browser. If the `space` argument is a `String`, then the first 10 characters of
    the value passed are used as white spaces for creation of the JSON.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`space`参数可以添加并具有`String`或`Number`类型的值。如果是`Number`，它表示要用作空格的空格字符数。在我们的示例中，如果您在浏览器中打开生成的HTML，可以看到这一点。如果`space`参数是`String`，则使用传递的值的前10个字符作为JSON的空格。'
- en: One thing to note is that the order of the serialized attributes is not guaranteed
    for non-array objects. You must not rely on ordering of properties within the
    object after the object is serialized. Now serialization might not be the most
    accurate definition of the process because of this, so that is why this is called
    as stringification commonly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，对于非数组对象，序列化属性的顺序不能保证。在对象序列化后，您不应依赖属性的顺序。现在，由于这一点，序列化可能不是该过程的最准确定义，因此通常被称为字符串化。
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Again we have the similar problems for older user agents that don''t support
    JSON. For that use we would recommend JSON 3:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持JSON的旧用户代理，我们再次遇到类似的问题。对于这种情况，我们建议使用JSON 3：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also you should not use the `stringify` function for debugging purposes since
    as we previously mentioned it converts undefined objects in a specific way, so
    you might get a wrong conclusion by doing so. This wrong conclusion is only related
    to the order and JSON compatibly, but it is fully valid to use it for general
    debugging of objects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，出于调试目的，您不应使用`stringify`函数，因为正如我们之前提到的，它以特定方式转换未定义的对象，因此通过这样做可能会得出错误的结论。这种错误的结论只与顺序和JSON兼容性有关，但对于对象的一般调试来说，它是完全有效的。
- en: Decoding base64 encoded binary data
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码base64编码的二进制数据
- en: Until very recently, JavaScript didn't have any native support for storing binary
    data types. Most binary data was handled as strings. Binary data that could not
    be handled using strings (for example, images) was handled as base64 encoded strings.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，JavaScript没有任何原生支持存储二进制数据类型的功能。大多数二进制数据都被处理为字符串。无法使用字符串处理的二进制数据（例如图像）被处理为base64编码的字符串。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Base64 is a method to encode binary data by converting groups of bytes into
    groups of base64 numbers. The goal is to avoid data loss by safely representing
    binary data using only printable characters which will not be interpreted in a
    special way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Base64是一种将二进制数据编码的方法，它将字节组转换为base64数字组。其目标是通过安全地使用仅以可打印字符表示的二进制数据来避免数据丢失，这些字符不会以特殊方式解释。
- en: HTML5 has much better support for binary data, it can be stored and manipulated
    using the `ArrayBuffer` class and the typed array classes. However, legacy libraries
    and API may still use base64 data. In order to do more efficient binary processing
    in modern browsers, we might want to convert this data into array buffers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5对二进制数据有更好的支持，可以使用`ArrayBuffer`类和类型化数组类进行存储和操作。然而，传统的库和API可能仍然使用base64数据。为了在现代浏览器中进行更有效的二进制处理，我们可能希望将这些数据转换为数组缓冲区。
- en: In this recipe, we're going to write a conversion function that converts base64
    encoded strings to array buffers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个转换函数，将base64编码的字符串转换为数组缓冲区。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To write this function, first we need to understand how base64 encoding works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写此函数，首先我们需要了解base64编码的工作原理。
- en: The usual way to access binary data is one byte at a time. A byte has 8 bits.
    If we try to assign a digit interpretation to a byte, it would be capable of representing
    2 ^ 8 = 256 different digits. In other words, a byte could represent a single
    base 256 digit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 访问二进制数据的通常方法是一次一个字节。一个字节有8位。如果我们尝试为一个字节分配数字解释，它将能够表示2 ^ 8 = 256个不同的数字。换句话说，一个字节可以表示一个单个的基数256位数。
- en: We need to represent binary data as base64 digits. They are represented by the
    letters `A-Z`, `a-z`, `0-9`, `+`, and `/` – a total of 64 characters, enough to
    store 6 bits of data per character. To do this, we will have to take groups of
    6 bits from the binary data. The lowest common denominator of 6 bits and 8 bits
    are 24 bits, which means that every group of 3 bytes are represented by a group
    of 4 base64 digits.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将二进制数据表示为base64数字。它们由字母`A-Z`、`a-z`、`0-9`、`+`和`/`表示-共64个字符，足以每个字符存储6位数据。为此，我们将从二进制数据中取出6位的组。6位和8位的最小公倍数是24位，这意味着每组3个字节由一组4个base64数字表示。
- en: We can conclude that the decoding process will take all four groups of base64
    encoded digits and produce 3 bytes from each group.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，解码过程将取出所有四组base64编码的数字，并从每组中产生3个字节。
- en: But what happens if the total number of bytes isn't divisible by 3? Base64 uses
    an additional character "`=`" (the equal sign) to denote the number of bytes missing
    from the last group. A single character is added at the end of the string to indicate
    that the last group has 1 byte less (only two in the last group). Two of them
    are added when there are 2 bytes less (only one byte in the last group).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果总字节数不能被3整除会发生什么？Base64使用附加字符"`=`"（等号）来表示最后一组缺少的字节数。在字符串末尾添加一个字符来指示最后一组少1个字节（最后一组只有两个字节）；当最后一组少2个字节时，添加两个字符（最后一组只有一个字节）。
- en: Now that we have understood how base64 works, we're ready to write a base64
    decoder.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了base64的工作原理，我们准备编写一个base64解码器。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create an `index.html` page containing a text field to input `text` and two
    `div` elements. One of the elements will be used to display the base64 string
    , while the other will be used to display the decimal values of the converted
    bytes:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含文本字段以输入`text`和两个`div`元素的`index.html`页面。其中一个元素将用于显示base64字符串，另一个将用于显示转换后字节的十进制值：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create `example.js` and put the code that will apply the changes on the page
    as the user types the text:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`并放置代码，以便在用户输入文本时应用更改：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create `atobuf.js`, which exports a function taking a base64 string and returns
    an ArrayBuffer object with the decoded bytes:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`atobuf.js`，导出一个函数，该函数接受一个base64字符串并返回一个包含解码字节的ArrayBuffer对象：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The code in `index.html` and `example.js` is fairly straightforward we set up
    a page to easily preview and test the results of our conversion function. To store
    the bytes, we create a `Uint8Array` object over the passed buffer. This is a new
    kind of array type introduced in HTML5, which enables us to read the individual
    bytes in the `ArrayBuffer` object as unsigned 8 bit integers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`和`example.js`中的代码非常简单，我们设置了一个页面，以便轻松预览和测试我们的转换函数的结果。为了存储字节，我们在传递的缓冲区上创建了一个`Uint8Array`对象。这是HTML5中引入的一种新类型的数组，它使我们能够将`ArrayBuffer`对象中的单个字节读取为无符号8位整数。'
- en: A point worth noting is that a `Uint8Array` object doesn't have the `join` method.
    This is why we "borrow" the method from an empty array by writing `[].join.call(bytes,
    ' ')`, which calls the `join` method (ordinarily belonging to the empty array)
    as if it were a method of the object bytes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Uint8Array`对象没有`join`方法。这就是为什么我们通过编写`[].join.call(bytes, ' ')`从空数组中“借用”该方法，该方法调用`join`方法（通常属于空数组）就像它是对象bytes的方法一样。
- en: Inside `atobuf.js` we export the `atobuf` function either as a CommonJS module
    (done by attaching to the `exports` object) or as a function attached to the global
    object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`atobuf.js`内部，我们将`atobuf`函数导出为CommonJS模块（通过附加到`exports`对象）或作为附加到全局对象的函数。
- en: To make the conversion faster, we predefine a conversion dictionary that maps
    the characters to their appropriate numeric values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快转换速度，我们预先定义一个转换字典，将字符映射到其适当的数值。
- en: '![How it works...](img/9282OT_07_05.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_07_05.jpg)'
- en: Let's see how the bit manipulation code works. The encoded values have 6 bits,
    while the decoded values have 8 bits. While reading the explanation, note that
    the bits are enumerated from right to left, with bit 0 being the right-most bit,
    bit 1 the second-right-most bit, and so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看位操作代码是如何工作的。编码值有6位，而解码值有8位。在阅读解释时，请注意位是从右到左枚举的，其中位0是最右边的位，位1是第二右边的位，依此类推。
- en: For the first decoded byte, we need the 6 bits stored in the first encoded value
    positioned as bits 2 to 7 in the decoded value. That's why we shift them two places
    to the left. We also need bits 4 and 5 from the second encoded value for the first
    decoded value, positioned as bits 0 and 1\. This means we need to shift them to
    the right by four places.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个解码字节，我们需要将存储在第一个编码值中的6位定位为解码值中的位2到7。这就是为什么我们将它们向左移动两个位置。我们还需要从第二个编码值中获取位4和5作为第一个解码值的位0和1。这意味着我们需要将它们向右移动四个位置。
- en: For the second byte, we need bits 0 to 3 from the second encoded value positioned
    as bits 4 to7 in the decoded value. To do this, we zero out bits 4 and 5 using
    a binary AND operation and shift the rest four places to the left. We also need
    bits 2 to 5 from the third encoded value as bits 0 to 3, so we need to shift them
    two places to the right.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个字节，我们需要从第二个编码值中获取位0到3的位，将其定位为解码值中的位4到7。为了做到这一点，我们使用二进制AND操作将位4和5清零，并将其余四位左移。我们还需要从第三个编码值中获取位2到5作为位0到3，因此我们需要将它们向右移动两个位置。
- en: For the third byte, we need bits 0 to1 from the third encoded value at places
    6 to7, which means using AND to zero out the rest and shifting six places to the
    left. The bits on the last encoded value are all in the right place at the third
    byte, so we take them as they are.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个字节，我们需要从第三个编码值中获取位0到1，位于6到7的位置，这意味着使用AND将其余部分清零，并将其左移六个位置。最后一个编码值的位都在第三个字节的正确位置上，因此我们将它们原样取出。
- en: Encoding binary data or text into base64
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将二进制数据或文本编码为base64
- en: HTML5 support for binary data is through an `ArrayBuffer` object, the related
    type arrays. When it comes to transmitting that data, usually the way to do this
    is via base64\. This is used mostly for dealing with textual data but with the
    rise of the usage of Data URI, base64 becomes more and more relevant. In this
    recipe, will see how to encode data using this scheme.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5对二进制数据的支持是通过`ArrayBuffer`对象，相关类型数组。当涉及到传输数据时，通常的做法是通过base64。这主要用于处理文本数据，但随着Data
    URI的使用增加，base64变得越来越相关。在这个示例中，我们将看到如何使用这种方案来编码数据。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an HTML file where we will use a `canvas` element, which will
    generate some data that will get encoded into base64:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个HTML文件，其中我们将使用`canvas`元素，该元素将生成一些数据，然后将其编码为base64：
- en: 'In order to have binary data, we will create an image using canvas, so we add
    a `canvas` element:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了拥有二进制数据，我们将使用canvas创建一个图像，因此我们添加一个`canvas`元素：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can have some input field that could be used to show the text encoding:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以有一些输入字段，用于显示文本编码：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Following that element we can place two output elements, one for the encoded
    binary data from the image and one for the encoded text:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该元素之后，我们可以放置两个输出元素，一个用于来自图像的编码二进制数据，另一个用于编码文本：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then include the dependency to jQuery and `example.js`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们包括对jQuery和`example.js`的依赖：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since we have included the `example.js` file, we can then proceed to creating
    logic for encoding the data. In order to have some binary data, we will create
    an image of a square with canvas:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经包含了`example.js`文件，因此我们可以继续创建编码数据的逻辑。为了拥有一些二进制数据，我们将使用canvas创建一个正方形的图像：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The current method definitions for `CanvasRenderingContext2D` can be found
    at WHATWG: [http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanvasRenderingContext2D`的当前方法定义可以在WHATWG找到：[http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d)。'
- en: 'In order to create base64 encoded data, we are going to convert the array to
    string, so that we can define a function as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建base64编码的数据，我们将把数组转换为字符串，以便我们可以定义一个函数如下：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can call that function and use the internal `btoa()` method that accepts
    string that will get encoded:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以调用该函数并使用内部的`btoa()`方法来接受将要编码的字符串：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To demonstrate that we can go back now, we will use `atob` to decode the base64
    encoded string data:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了证明我们现在可以返回，我们将使用`atob`来解码base64编码的字符串数据：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now in order to get back from the decoded string data to the original binary
    array we need to define a function as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了从解码后的字符串数据返回到原始二进制数组，我们需要定义一个函数如下：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After that we can call that function on our decoded data:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后我们可以在我们的解码数据上调用该函数：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will just print the base64 encoded string on to the page:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在页面上打印base64编码的字符串：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Due to certain assumptions made by the base64 algorithm, UTF is not initially
    supported. There is a workaround for this, created by Johan Sundström that takes
    advantage of standard functions and makes UTF possible:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于base64算法做出了某些假设，因此最初不支持UTF。Johan Sundström创建了一个解决方法，利用标准函数并使UTF成为可能：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is only of interest to us for textual data, so we can try it out by connecting
    the input field with the output tag where we will have a base64 encoded text:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这只对我们的文本数据感兴趣，因此我们可以通过将输入字段与输出标签连接来尝试它，我们将得到一个base64编码的文本：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The modern browsers have support for `atob("base64encoded")` and `btoa("stringToBeEncoded")`.
    These methods allow encoding and decoding of base64 strings. We use `btoa()` to
    encode string data and we get result that has ASCII character `A-Z,a-z,0-9`, and
    the symbols `(/,+,=)` making the data convenient for transport. The data range
    restriction comes at a price, the encoded data is now larger than the original
    binary stream with about 33 percent of overhead. On the other hand, the encoded
    data is usually more compressible, so the gzip will more or less even up the size.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器支持`atob("base64encoded")`和`btoa("stringToBeEncoded")`。这些方法允许对base64字符串进行编码和解码。我们使用`btoa()`对字符串数据进行编码，得到的结果具有ASCII字符`A-Z,a-z,0-9`和符号`(/,+,=)`，使数据便于传输。数据范围限制是有代价的，编码后的数据现在比原始二进制流大约33%。另一方面，编码后的数据通常更易压缩，因此gzip将使大小更或多或少相等。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'JavaScript typed arrays provide a way for accessing raw binary data much more
    efficiently than using the standard types. They are supported in all of the modern
    browsers and IE 10\. More on typed arrays can be found on MDN: [https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays](https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript类型化数组提供了一种比使用标准类型更高效地访问原始二进制数据的方式。它们受到所有现代浏览器和IE 10的支持。有关类型化数组的更多信息可以在MDN上找到：[https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays](https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays)。
- en: 'To the test binary data encoding, we took array generated from HTML canvas.
    To retrieve the binary array representation there, we used the following statement:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试二进制数据编码，我们使用了从HTML画布生成的数组。为了在那里检索二进制数组表示，我们使用了以下语句：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This returns `ImageData` object that contains properties width, height, and
    data. The data attributes is represented as an `Uint8ClampedArray` object. These
    type of arrays are similar to the standard `Array` object, where each of the items
    is an 8 bit (1 byte) unsigned integer. All the values stored in this array are
    in the range 0 to 255, which is perfect for colors. In our case, we can see the
    values stored in the array by logging with `console.log()`, and we get values
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个包含属性宽度、高度和数据的`ImageData`对象。数据属性表示为一个`Uint8ClampedArray`对象。这种类型的数组类似于标准的`Array`对象，其中每个项目都是一个8位（1字节）无符号整数。存储在此数组中的所有值都在0到255的范围内，非常适合颜色。在我们的情况下，我们可以通过使用`console.log()`记录数组中存储的值，并获得以下值：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The 0 is for red, 128 is for green, and the third 0 is for blue, the 255 value
    on the other hand is for the opacity level. Since we want to encode the data of
    the array to base64 we cannot simply call `btoa(theArray)`, since we only store
    the `toString` value and not the whole array:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 0代表红色，128代表绿色，第三个0代表蓝色，另一方面255代表不透明度级别。由于我们想要将数组的数据编码为base64，我们不能简单地调用`btoa(theArray)`，因为我们只存储`toString`值而不是整个数组：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we are to compare `Uint8array` with `Uint8ClampedArray` the main difference
    is the first uses modulo shortening when inserted value that is out of range and
    the clamped one well clamps the values. For example, if we were to to set the
    value 300 to a 255 limited it will become 255 for `Uint8ClampedArray` but 45 for
    the other. Similarly the value -1 will be clamped to 0\. More info about `Uint8ClampedArray`
    can be found at:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较`Uint8array`和`Uint8ClampedArray`，主要区别在于前者在插入超出范围的值时使用模数缩短，而后者则将值夹紧。例如，如果我们将值300设置为255限制，对于`Uint8ClampedArray`将变为255，而对于另一个将变为45。同样，值-1将被夹紧为0。有关`Uint8ClampedArray`的更多信息可以在以下找到：
- en: '[http://www.khronos.org/registry/typedarray/specs/latest/#7.1](http://www.khronos.org/registry/typedarray/specs/latest/#7.1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.khronos.org/registry/typedarray/specs/latest/#7.1](http://www.khronos.org/registry/typedarray/specs/latest/#7.1)'
- en: The main reason why we added `arrayToString` is to create a string for us that
    we can latter use in `btoa`. Similarly we would need `stringToArray` that will
    revert the transformation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加`arrayToString`的主要原因是为我们创建一个字符串，以便我们以后可以在`btoa`中使用。同样，我们需要`stringToArray`来恢复转换。
- en: 'When it comes to text the core functions `btoa()/atob()` don''t have support
    for Unicode. If we try to convert characters with a value larger than `"\u0100"`
    we will get:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文本时，核心函数`btoa()/atob()`不支持Unicode。如果我们尝试转换值大于`"\u0100"`的字符，我们将得到：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As a fix for this we added methods `utf8ToB64()` and `b64ToUtf8()`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对此的修复，我们添加了`utf8ToB64()`和`b64ToUtf8()`方法。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These two are clever hacks done by Johan Sundström and is a recommended fix
    by MDN. More info can be obtained from [http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html](http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是Johan Sundström的聪明技巧，是MDN推荐的修复方法。更多信息可以从[http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html](http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html)获取。
- en: The hack takes advantage of standard function pairs `encodeURIComponent()/decodeURIComponent()`
    and `escape()/unescape()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧利用了标准函数对`encodeURIComponent()/decodeURIComponent()`和`escape()/unescape()`。
- en: How does this combination of `encodeURICompoenent` and `unescape` work?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURICompoenent`和`unescape`的组合是如何工作的？'
- en: 'Here is an example of how this method works:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这种方法的一个示例：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result we are getting is a percent-encodedstring, where the UTF-8 characters
    are replaced with the appropriate percent representation. Now we could use just
    `encodeURIComponent`, since percent encoding uses only ASCII characters:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果是一个百分比编码的字符串，其中UTF-8字符被替换为适当的百分比表示。现在我们可以只使用`encodeURIComponent`，因为百分比编码只使用ASCII字符：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But there is a drawback with this approach and that is the resulting percent-encoded
    string is lot bigger the initial one, and since base64 adds additional overhead
    it can easily become huge.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种方法的一个缺点是，结果的百分比编码字符串比初始字符串大得多，而由于base64增加了额外的开销，它很容易变得非常庞大。
- en: The `escape` and `unescape` functions are deprecated, since they don't work
    for non ASCII characters but in our case the input is valid, and as such, they
    can be used. As for future versions they are not a part of the standards but they
    will probably stay. The `unescape` function returns the ASCII string for the specified
    hexadecimal encoded value. The benefit of using this is now we have representation
    that is a smaller string. Another great thing about this hack is it uses multiple
    encoding functions available by the browser to extend standard functionality.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`escape`和`unescape`函数已经被弃用，因为它们对非ASCII字符不起作用，但在我们的情况下，输入是有效的，因此它们可以被使用。至于未来版本，它们不是标准的一部分，但它们可能会保留下来。`unescape`函数返回指定十六进制编码值的ASCII字符串。使用这个的好处是现在我们有一个更小的字符串表示。这个黑客的另一个好处是它使用了浏览器可用的多个编码函数来扩展标准功能。'
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When it comes to user agent support, IE is the only current browser that has
    not yet included `btoa()` and `atob()`, but this was only valid for versions older
    than IE 10\. In order to enable it on unsupported user agents we can use a polyfill.
    There are several different polyfills for this, but we can use the one called
    `base64.js`, ([https://bitbucket.org/davidchambers/base64.js)](https://bitbucket.org/davidchambers/base64.js)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户代理支持方面，IE是目前唯一尚未包含`btoa()`和`atob()`的浏览器，但这仅适用于早于IE 10的版本。为了在不受支持的用户代理上启用它，我们可以使用一个polyfill。有几种不同的polyfill，但我们可以使用一个叫做`base64.js`的。
- en: There is an interesting async resource loader called `yenope.js`, that is very
    fast and allows custom checks. If we want to include `base64.js` we can test for
    the existence of the needed functions and if it's not then it will automatically
    include it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有趣的异步资源加载器叫做`yenope.js`，它非常快速，并允许自定义检查。如果我们想要包含`base64.js`，我们可以测试所需函数的存在，如果不存在，它将自动包含它。
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Yepnope is one of the many conditional resource loaders, but it is one of the
    simple ones. The `yepnope` function is the core of the entire loader. As such
    it is very small and integrated in Modernizer; more info can be found at [http://yepnopejs.com/](http://yepnopejs.com/).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Yepnope是许多条件资源加载器之一，但它是其中一个简单的。`yepnope`函数是整个加载器的核心。因此它非常小并且集成在Modernizer中；更多信息可以在[http://yepnopejs.com/](http://yepnopejs.com/)找到。
- en: Serializing binary data into JSON
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将二进制数据序列化为JSON
- en: When working with REST API's if you need to include binary data as part of the
    JSON, then one of the simplest ways is to use base64\. Images and similar resources
    should most likely exist as separate resources but they can also be part of the
    JSON document as well. In this recipe, we are going to cover a simple example
    of including image in JSON document.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用REST API时，如果需要将二进制数据包含在JSON中，最简单的方法之一是使用base64。图像和类似的资源很可能应该存在为单独的资源，但它们也可以作为JSON文档的一部分。在这个配方中，我们将介绍在JSON文档中包含图像的一个简单例子。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will generate some binary data from a `canvas` element and serialize it
    to JSON:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`canvas`元素生成一些二进制数据，并将其序列化为JSON：
- en: 'We start by creating an HTML file, where we can place a simple `canvas`, a
    `div` element for output, and includes jQuery together with the script will be
    created afterwards:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个HTML文件，在其中放置一个简单的`canvas`，一个用于输出的`div`元素，并包括jQuery，然后创建脚本：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `example.js` script we can create a simple circle on the `canvas` element:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`example.js`脚本中，我们可以在`canvas`元素上创建一个简单的圆：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then we define the same `arrayToString` function we used in the *Serializing
    binary data or text in base64* section:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了与*将二进制数据或文本编码为base64*部分中使用的相同的`arrayToString`函数：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then encode the data and create a JavaScript object while also creating
    two data URI form the `canvas` element, one `jpeg`, and the other `png`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们对数据进行编码，并创建一个JavaScript对象，同时创建两个数据URI形式的`canvas`元素，一个是`jpeg`，另一个是`png`：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In order to create the JSON object we can use `JSON.stringify` and then print
    the result to the `generatedJson` div:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建JSON对象，我们可以使用`JSON.stringify`，然后将结果打印到`generatedJson` div中：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The code is very similar to the previous recipe, we created a simple circle
    using 2D context for canvas:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一个配方非常相似，我们使用2D上下文为canvas创建了一个简单的圆：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Then we got the binary data from the image and applied the same logic like in
    the*Encoding binary data or text into base64* recipe. One specific feature is
    the use of Data URI that simply create a base64 encoded rendering of the image
    in the specified format. In our case we created a rending in `jpeg` and `png`.
    If you copy out the data contained in
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从图像中获取了二进制数据，并应用了与*将二进制数据或文本编码为base64*配方中相同的逻辑。一个特定的特性是使用Data URI，它简单地在指定的格式中创建图像的base64编码渲染。在我们的例子中，我们创建了`jpeg`和`png`的渲染。如果你复制出数据包含在
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: and paste it into the browsers URL selection, it will render the image. Data
    URI will be looked into in great details in chapter titled *Data storage*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其粘贴到浏览器的URL选择中，它将呈现图像。数据URI将在标题为*数据存储*的章节中详细讨论。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The base 64 encoding can be used with XML to store more complex or binary data.
    Because the character base of the encoding does not interfere with the parsing,
    no CDATA sections are needed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: base64编码可以与XML一起使用来存储更复杂或二进制数据。由于编码的字符基不会干扰解析，因此不需要CDATA部分。
- en: There are plenty of other format for exchange of binary data with the server
    such as BSON, Base32 or Hessian. Base64 is most commonly used since it's very
    simple and it easy to integrate.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器交换二进制数据的其他格式有很多，例如BSON、Base32或Hessian。Base64是最常用的，因为它非常简单且易于集成。
- en: One great usage of base64 is to store the text into a URL parameter making the
    text easy to get represented and reconstructed, you can see that on [http://hashify.me](http://hashify.me).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'base64的一个很好的用途是将文本存储到URL参数中，使文本易于表示和重建，你可以在[http://hashify.me](http://hashify.me)上看到。 '
- en: Serializing and deserializing cookies
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化和反序列化cookies
- en: Despite all the advances made in HTML5, browsers still have a very strange cookie
    API. The way it works is error-prone and inconsistent with the normal semantics
    of JavaScript.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HTML5取得了很多进展，但浏览器仍然具有非常奇怪的Cookie API。它的工作方式容易出错，并且与JavaScript的正常语义不一致。
- en: The global `document` object has a `cookie` property, if a string is assigned
    to it, it magically adds the specified cookie to the list of cookies. When an
    attempt to read the cookie is made, a different value containing all the cookies
    is returned.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 全局的`document`对象有一个`cookie`属性，如果给它赋一个字符串，它会神奇地将指定的Cookie添加到Cookie列表中。当尝试读取Cookie时，会返回一个包含所有Cookie的不同值。
- en: This API is not very useful without a wrapper. In this recipe, we're going to
    wrap this API in a wrapper that actually makes sense. We're going to test this
    wrapper by making a form page that saves itself on every modification (preserving
    the data after a page reload) for two minutes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API如果没有包装器就不太有用。在这个教程中，我们将用一个实际有意义的包装器来包装这个API。我们将通过制作一个表单页面来测试这个包装器，该页面在每次修改后保存自身（在页面重新加载后保留数据）两分钟。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s find out how `document.cookie` works. We can set a cookie as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出`document.cookie`的工作原理。我们可以设置Cookie如下：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This sets a cookie for the whole domain of the current website called test,
    expiring on January 18 2023\. Now if we try to read from `document.cookie` we
    will get "`name=test`", which means that all the extra data has been stripped
    out. If we continue by adding another cookie:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这为当前网站的整个域设置了一个名为test的Cookie，到2023年1月18日过期。现在，如果我们尝试从`document.cookie`读取，我们将得到`"name=test"`，这意味着所有额外的数据已被剥离。如果我们继续添加另一个Cookie：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And then try to access `document.cookie`, we get both cookies:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试访问`document.cookie`，我们会得到两个Cookie：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To actually clear the cookie we will need to set the `expires` date in the
    path as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际清除Cookie，我们需要按以下方式设置`expires`日期和路径：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And then we're back to `document.cookie` containing `"name=test"`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们回到包含`"name=test"`的`document.cookie`。
- en: 'Finally, if we omit the `expires` date, we''re going to get a cookie that lasts
    until the user closes the browser or until we clear it by setting its expire date
    in the past:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们省略`expires`日期，我们将得到一个持续到用户关闭浏览器或我们通过将其过期日期设置为过去来清除它的Cookie：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: But what happens if the value contains the character `;`? The cookie value will
    be cut off at this character and the next parameter (expire date or path) will
    be ignored. Fortunately, we can work around this by using `encodeURIComponent`
    to encode the value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果值包含字符`;`会发生什么？Cookie值将在此字符处被截断，并且下一个参数（过期日期或路径）将被忽略。幸运的是，我们可以通过使用`encodeURIComponent`来编码值来解决这个问题。
- en: Now we have enough information to write our cookie handling library.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的信息来编写我们的Cookie处理库。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write the code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写代码：
- en: 'Create the form page in `index.html`, it will contain three text fields and
    include our cookie wrapper script and formsaving script:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`中创建表单页面，其中包含三个文本字段，并包括我们的Cookie包装器脚本和表单保存脚本：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create `cookie.js`, which implements and exports the cookie API. It will have
    the following function:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`cookie.js`，实现并导出Cookie API。它将具有以下功能：
- en: '`cookie.set`(`name, value, options`): This function sets the value of a cookie.
    The value can be an arbitrary object as long as it can be serialized by `JSON.stringify`.
    Available options are `expires`, `duration`, and `path`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie.set`(`name, value, options`)：此函数设置Cookie的值。该值可以是任意对象，只要它可以被`JSON.stringify`序列化。可用的选项包括`expires`、`duration`和`path`。'
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create `example.js` to test the new cookie API. It loads the form data when
    the document loads and saves it when it''s changed:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`来测试新的Cookie API。它在文档加载时加载表单数据，并在更改时保存它：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our API implements several convenient functions to deal with cookies.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API实现了几个方便处理Cookie的函数。
- en: 'The `cookie.set` function allows us to set a cookie. It takes three parameters:
    name, value, and options.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookie.set`函数允许我们设置Cookie。它接受三个参数：名称、值和选项。'
- en: The value is serialized with `JSON.stringify`, and then encoded using `encodeURIComponent`.
    As a result we can store any object that can be serialized with `JSON.stringify`
    (there are however size limits which vary between browsers).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该值使用`JSON.stringify`进行序列化，然后使用`encodeURIComponent`进行编码。因此，我们可以存储任何可以使用`JSON.stringify`进行序列化的对象（但是不同浏览器之间存在大小限制）。
- en: 'The options parameter is an object which can contain three properties: expires,
    duration, and path. The `expires` property is the date when the cookie should
    expire. Alternatively, `duration` can be provided – it is the duration that the
    cookie should last in seconds. If both of these are omitted, the cookie will last
    until the end of the current browser session. Finally, the `path` property is
    a string specifying the path where the cookie is available. The default is the
    current path.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 选项参数是一个对象，可以包含三个属性：expires、duration和path。`expires`属性是Cookie应该过期的日期。或者，可以提供`duration`，它是Cookie应该持续的秒数。如果这两者都被省略，Cookie将持续到当前浏览器会话结束。最后，`path`属性是一个指定Cookie可用路径的字符串。默认是当前路径。
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Cookies should not be used to store large amount of data. Most browsers limit
    the cookie size at 4 KB per cookie. Some browsers limit the total size of all
    cookies to 4 KB. Data stored inside cookies is transferred with every request
    made to the server, increasing the total use of bandwidth.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该使用Cookie来存储大量数据。大多数浏览器将每个Cookie的大小限制在4KB。有些浏览器将所有Cookie的总大小限制在4KB。存储在Cookie中的数据会随着每次向服务器发出的请求而传输，增加带宽的总使用量。
- en: For larger data we can use local storage instead. More information can be found
    in [Chapter 10](ch10.html "Chapter 10. Data Binding Frameworks"), *Data Binding
    Frameworks*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的数据，我们可以使用本地存储。更多信息可以在[第10章](ch10.html "第10章。数据绑定框架")中找到，*数据绑定框架*。
- en: Note that this example doesn't work when opened on a local filesystem. To make
    it work, a local HTTP server must be run. See appendix for more information on
    how to run a simple HTTP server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此示例在本地文件系统上打开时不起作用。要使其起作用，必须运行本地HTTP服务器。有关如何运行简单HTTP服务器的更多信息，请参见附录。
- en: Serializing a form into request strings
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表单序列化为请求字符串
- en: A common task when working with forms is the need to create the actual request
    string. There are several different ways to do this, the first thing that comes
    to mind is just to select each individual form element and get it's value, and
    then create the string by appending the name attributes with the values. This
    is very error prone, so we are going to take a look at a better solution using
    `jQuery.serialize()`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理表单时的一个常见任务是创建实际的请求字符串。有几种不同的方法可以做到这一点，首先想到的是只选择每个单独的表单元素并获取它的值，然后通过附加名称属性和值来创建字符串。这种方法非常容易出错，因此我们将看一下使用`jQuery.serialize()`的更好的解决方案。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As usual we can start with the HTML:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可以从HTML开始：
- en: 'First we add basic the `head` section and an output element where the generated
    request string will be shown:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们添加基本的`head`部分和一个输出元素，显示生成的请求字符串：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then we can proceed with creating a simple form, where we add input for full
    name, e-mail, and percentage of awesomeness:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以继续创建一个简单的表单，其中包括全名、电子邮件和令人惊叹的百分比的输入：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Following that we can include the needed JavaScript dependencies to jQuery
    and our `example.js` script:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以包含所需的JavaScript依赖项到jQuery和我们的`example.js`脚本中：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can then proceed to creating the `example.js` file, where on every update
    of the form elements the form is serialized:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以继续创建`example.js`文件，在表单元素的每次更新时对表单进行序列化：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `.serialize()` function converts form elements and their values into a percent-encoded
    string. Percent-encoding is often called URL encoding and is a way to represent
    information in a URI-friendly way. As such, it is a core part in most of the forms
    that are used and it has an MIME type of `application/x-www-form-urlencoded`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`.serialize()`函数将表单元素及其值转换为百分比编码的字符串。百分比编码通常称为URL编码，是一种以URI友好的方式表示信息的方法。因此，它是大多数使用的表单的核心部分，它具有`application/x-www-form-urlencoded`的MIME类型。'
- en: If we have a button in the form it will not be considered as part of the generated
    string, because that button was not clicked in order to submit the form. Additionally,
    values from the checkboxes and radio buttons are only part of the generated string
    if they are checked.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单中有一个按钮，它不会被视为生成的字符串的一部分，因为该按钮未被点击以提交表单。此外，仅当复选框和单选按钮被选中时，它们才是生成的字符串的一部分。
- en: On the other hand if we need some JSON representation then we can use `.serializeArray()`,
    a function that will create a JavaScript array. After having this array of elements
    we can create a JSON using `JSON.stringify()`. The default JSON representation
    may not be very useful in most cases but we can easily restructure and filter
    the elements.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们需要一些JSON表示，那么我们可以使用`.serializeArray()`，这个函数将创建一个JavaScript数组。在获得这个元素数组之后，我们可以使用`JSON.stringify()`创建一个JSON。默认的JSON表示在大多数情况下可能不是很有用，但我们可以很容易地重组和过滤这些元素。
- en: The `.serializeArray()` and `.serialize()` functions save only "successful controls"
    as defined by the W3C ([http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2)),
    where you will get same behavior as if the form was submitted regularly with a
    button click.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`.serializeArray()`和`.serialize()`函数只保存W3C定义的“成功控件”（[http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2)），在这里，您将获得与通过按钮点击正常提交表单相同的行为。'
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The first thing to note is that data from file select elements is not serialized
    using these two methods. For this purpose and other similar use cases, the `FormData`
    object was introduced in `XMLHttpRequest Level 2`. This object allows the creation
    of a set of key/value pairs in order to be sent using `XMLHttpRequest`. The data
    that will be created using this method gets sent in the same way as standard submit,
    where the encoding was set to `"multipart/form-data"`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，使用这两种方法不会序列化文件选择元素中的数据。为此和其他类似用例，`FormData`对象在`XMLHttpRequest Level
    2`中被引入。该对象允许创建一组键/值对，以便使用`XMLHttpRequest`发送。使用此方法创建的数据以与标准提交相同的方式发送，其中编码设置为`"multipart/form-data"`。
- en: 'We saw in our example the creation of JSON objects from the form elements can
    get messy even with using `.serializeArray()`. In order to simplify things and
    enable easy creation of more complex JSON directly from the elements `form2js`,
    [https://github.com/maxatwork/form2js](https://github.com/maxatwork/form2js) was
    created. A small example on how this works would be to create a simple person
    object:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中看到，即使使用`.serializeArray()`，从表单元素创建JSON对象也可能变得混乱。为了简化事情并使更复杂的JSON直接从元素创建，创建了`form2js`，[https://github.com/maxatwork/form2js](https://github.com/maxatwork/form2js)。一个简单的示例是创建一个简单的人对象：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To achieve this we only create the definition in the `name` attribute and the
    script handles everything else:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们只需在`name`属性中创建定义，脚本会处理其他所有事情：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There is a standard JavaScript version and a jQuery plugin for this library.
    It also has other features such as having array of objects or custom field handlers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此库有标准的JavaScript版本和jQuery插件。它还具有其他功能，例如具有对象数组或自定义字段处理程序。
- en: Reading XML documents with DOMParser
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DOMParser读取XML文档
- en: While `XMLHttpRequest` allows us to both download and parse XML documents, sometimes
    we might want to parse XML data documents manually. For example, manual parsing
    would enable us to include arbitrary XML data (for example, XML-based templates)
    inside the page in a `script` tag. This can help to reduce the number of requests
    sent to the browser.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`XMLHttpRequest`允许我们下载和解析XML文档，但有时我们可能希望手动解析XML数据文档。例如，手动解析可以使我们在`script`标签中包含任意XML数据（例如，基于XML的模板）在页面中。这可以帮助减少发送到浏览器的请求数量。
- en: In this recipe, we are going to read a simple XML document from a `textarea`
    input and parse it using `DOMParser`, and then display the result as a tree.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将从`textarea`输入中读取一个简单的XML文档，并使用`DOMParser`解析它，然后将结果显示为树。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write the test HTML page and the parser:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写测试HTML页面和解析器：
- en: 'Create `index.html`, it should contain a `textarea` element to input XML (a
    sample XML document is included), a placeholder for the document `body` object,
    and some CSS styles for the document tree:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`，它应包含一个`textarea`元素用于输入XML（包含一个示例XML文档），一个文档`body`对象的占位符，以及一些文档树的CSS样式：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create `example.js`, and add the code that parses the document and converts
    it into an HTML tree:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`，并添加解析文档并将其转换为HTML树的代码：
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To parse an XML document, we create a new `DOMParser` object and call the `parseFromString`
    method. We specify the document type as application/xml – the parser can also
    parse `text/html` and return an `HTMLDocument` element, or `image/svg+xml` returning
    an `SVGDocument` element.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析XML文档，我们创建一个新的`DOMParser`对象并调用`parseFromString`方法。我们将文档类型指定为application/xml
    - 解析器还可以解析`text/html`并返回`HTMLDocument`元素，或解析`image/svg+xml`并返回`SVGDocument`元素。
- en: 'The resulting document has a very similar API to the one found in `window.document`
    (the same DOM API is available). We create a recursive function that iterates
    all the children of the root element and generates HTML. It constructs headers
    for the element names, span elements for the attribute names and values, div elements
    for the text nodes, and calls itself to generate HTML to display element nodes.
    The result is a DOM tree:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文档具有与`window.document`中找到的非常相似的API（相同的DOM API可用）。我们创建一个递归函数，迭代根元素的所有子元素并生成HTML。它为元素名称构造标题，为属性名称和值创建span元素，为文本节点创建div元素，并调用自身生成HTML以显示元素节点。结果是一个DOM树：
- en: '![How it works...](img/9282OT_07_10.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_07_10.jpg)'
- en: Serialization of XML document at the client side
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端对XML文档进行序列化
- en: JSON is extremely simple to use than JavaScript; there are lot of REST services
    already out there that use XML. In this recipe we are going to create a simple
    form that will construct an XML document using the DOM API for XML.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: JSON比JavaScript更简单易用；已经有很多REST服务使用XML。在这个示例中，我们将创建一个简单的表单，使用DOM API for XML构建XML文档。
- en: How to do it...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'First we create a simple HTML document:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们创建一个简单的HTML文档：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After this we are going to include a KML document inside the text, in a real
    life application this will probably get loaded by AJAX, but for simplicity we
    will add the data directly:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们将在文本中包含一个KML文档，在实际应用中，这可能会通过AJAX加载，但为简单起见，我们将直接添加数据：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may have noticed the use of **KML** (**Keyhole Markup Language**) in this
    recipe. Originally this was a format developed by a company acquired by Google,
    but now its is an international open standard. This format is widely used for
    describing placemarks and locations. More info can be found at:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在这个示例中使用了**KML**（**Keyhole Markup Language**）。最初这是由Google收购的一家公司开发的格式，但现在它是一个国际开放标准。这种格式广泛用于描述地标和位置。更多信息可以在以下网址找到：
- en: '[https://developers.google.com/kml/documentation/](https://developers.google.com/kml/documentation/)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/kml/documentation/](https://developers.google.com/kml/documentation/)'
- en: 'Following this block we can just include the JavaScript `example.js`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个块之后，我们只需包含JavaScript `example.js`：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We will create a simple XML document form scratch and serialize it to a string.
    The code will simply retrieve a section of the HTML document where we have the
    KML data serializing it to a string, and then displaying the data in the text
    area:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从头开始创建一个简单的XML文档，并将其序列化为字符串。该代码将简单地检索HTML文档的一个部分，其中包含KML数据，将其序列化为字符串，然后在文本区域中显示数据：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The core of this example is the `XMLSerializer()` method, that can be used
    to convert DOM subtree or the entire document into text. The object is supported
    by most of the modern browsers and IE 9+, but for older versions, you need to
    use some fallback similar to the following one:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的核心是`XMLSerializer()`方法，它可以用于将DOM子树或整个文档转换为文本。这个对象受大多数现代浏览器和IE 9+的支持，但对于旧版本，您需要使用类似以下的一些回退：
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Standard DOM manipulation can be used to create an XML document. The same thing
    applies for jQuery where we have out-of-the-box functionality for the creation
    of documents. Things only get more complicated if we need to work with larger
    documents or do extensive work with XML. Most of the REST services these days
    have some sort of content negotiation, so usual JSON is an available and a better
    option.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的DOM操作可以用于创建XML文档。对于jQuery也是一样，我们可以直接使用其功能来创建文档。只有当我们需要处理更大的文档或对XML进行大量工作时，情况才会变得更加复杂。如今大多数REST服务都有某种内容协商，所以通常JSON是一种可用且更好的选择。
- en: There's more...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is also a functionality called JXON([https://developer.mozilla.org/en-US/docs/JXON](https://developer.mozilla.org/en-US/docs/JXON)),
    which stands for JavaScript XML Object Notation is a generic name for the API
    related to creation and use of XML documents in JavaScript. This basically defines
    a convention for a two-way conversion between JSON and XML.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为JXON（[https://developer.mozilla.org/en-US/docs/JXON](https://developer.mozilla.org/en-US/docs/JXON)）的功能，它代表JavaScript
    XML对象表示法，是与JavaScript中XML文档的创建和使用相关的API的通用名称。这基本上定义了JSON和XML之间的双向转换的约定。
- en: While working extensively with XML, XPath can be your best friend. It enables
    a very flexible way of accessing specific parts of the documents that match certain
    pattern.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在与XML密切相关的工作中，XPath可能是您最好的朋友。它可以非常灵活地访问与特定模式匹配的文档的特定部分。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**XPath** **(XML Path Language**) is a query language for selecting nodes in
    an XML document. Much like SQL, it provides certain calculation functions. There
    is an extensive documentation on MDN at [https://developer.mozilla.org/en-US/docs/XPath](https://developer.mozilla.org/en-US/docs/XPath)
    as well as the specification documents at [http://www.w3.org/TR/xpath20/](http://www.w3.org/TR/xpath20/).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: XPath（XML路径语言）是一种用于选择XML文档中节点的查询语言。与SQL类似，它提供了某些计算函数。在MDN上有详尽的文档，网址为[https://developer.mozilla.org/en-US/docs/XPath](https://developer.mozilla.org/en-US/docs/XPath)，同时也有规范文档，网址为[http://www.w3.org/TR/xpath20/](http://www.w3.org/TR/xpath20/)。
