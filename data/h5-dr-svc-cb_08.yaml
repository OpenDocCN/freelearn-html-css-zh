- en: Chapter 8. Communicating with Servers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。与服务器通信
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating an HTTP GET request to fetch JSON
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个HTTP GET请求来获取JSON
- en: Creating a request with custom headers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有自定义头部的请求
- en: Versioning your API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的API进行版本控制
- en: Fetching JSON data with JSONP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSONP获取JSON数据
- en: Reading XML data from the server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器读取XML数据
- en: Using the FormData interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FormData接口
- en: Posting a binary file to the server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制文件发布到服务器
- en: Creating an SSL connection with Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js创建SSL连接
- en: Making real-time updates with Ajax Push
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ajax Push进行实时更新
- en: Exchanging real-time messages using WebSockets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebSockets交换实时消息
- en: Creating an HTTP GET request to fetch JSON
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个HTTP GET请求来获取JSON
- en: One of the basic means of retrieving information from the server is using HTTP
    GET. This type of method in a RESTful manner should be only used for reading data.
    So, GET calls should never change server state. Now, this may not be true for
    every possible case, for example, if we have a view counter on a certain resource,
    is that a real change? Well, if we follow the definition literally then yes, this
    is a change, but it's far from significant to be taken into account.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器检索信息的基本方法之一是使用HTTP GET。在RESTful方式中，这种方法应该仅用于读取数据。因此，GET调用不应该改变服务器状态。现在，这对于每种可能的情况可能并不正确，例如，如果我们在某个资源上有一个视图计数器，那么这是一个真正的改变吗？如果我们严格遵循定义，那么是的，这是一个改变，但这远非重要到足以被考虑。
- en: Opening a web page in a browser does a GET request, but often we want to have
    a scripted way of retrieving data. This is usually to achieve **Asynchronous JavaScript
    and XML** (**AJAX**), allowing reloading of data without doing a complete page
    reload. Despite the name, the use of XML is not required, and these days, JSON
    is the format of choice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开一个网页会发出一个GET请求，但通常我们希望以一种脚本化的方式来检索数据。这通常是为了实现**异步JavaScript和XML**（**AJAX**），允许重新加载数据而不进行完整的页面重新加载。尽管名称中包含XML，但并不是必需的，如今，JSON是首选的格式。
- en: A combination of JavaScript and the `XMLHttpRequest` object provides a method
    for exchanging data asynchronously, and in this recipe, we are going to see how
    to read JSON for the server using plain JavaScript and jQuery. Why use plain JavaScript
    rather than using jQuery directly? We strongly believe that jQuery simplifies
    the DOM API, but it is not always available to us, and additionally, we need have
    to know the underlying code behind asynchronous data transfer in order to fully
    grasp how applications work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript和`XMLHttpRequest`对象的组合提供了一种异步交换数据的方法，在这个示例中，我们将看到如何使用纯JavaScript和jQuery从服务器读取JSON。为什么使用纯JavaScript而不直接使用jQuery？我们坚信jQuery简化了DOM
    API，但它并不总是可用，此外，我们需要了解异步数据传输背后的基础代码，以充分理解应用程序的工作原理。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The server will be implemented using Node.js. Please refer to [Appendix A](apa.html
    "Appendix A. Installing Node.js and Using npm"), *Installing Node.js and Using
    npm*, on how to install Node.js on your machine, and how to use npm. In this example,
    for simplicity, we will use **restify** ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/)),
    a Node.js module for creation of correct REST web services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将使用Node.js实现。请参考[附录A](apa.html "附录A。安装Node.js和使用npm")中关于如何在您的计算机上安装Node.js以及如何使用npm的内容。在这个示例中，为了简单起见，我们将使用**restify**（[http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/)），这是一个用于创建正确的REST
    web服务的Node.js模块。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let's perform the following steps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤。
- en: 'In order to include `restify` to our project in the root directory of our server
    side scripts, use the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在服务器端脚本的根目录中包含`restify`到我们的项目中，使用以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After adding the dependency, we can proceed to creating the server code. We
    create a `server.js` file that will be run by Node.js, and at the beginning of
    it we add `restify`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加依赖项后，我们可以继续创建服务器代码。我们创建一个`server.js`文件，它将由Node.js运行，在其开头我们添加`restify`：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With this `restify` object, we can now create a server object and add handlers
    for `get` methods:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个`restify`对象，我们现在可以创建一个服务器对象，并为`get`方法添加处理程序：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `get` handlers do a callback to a function called `respond`, so we can
    now define this function that will return the JSON data. We will create a sample
    JavaScript object called `hello`, and in case the function was called having a
    parameter index part of the request it was called from the `"hi/:index"` handler:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get`处理程序回调到一个名为`respond`的函数，因此我们现在可以定义这个函数，它将返回JSON数据。我们将创建一个名为`hello`的示例JavaScript对象，并且如果函数被调用时具有请求的参数索引部分，则在`"hi/:index"`处理程序中调用它：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following `addHeaders` function that we call at the beginning is adding
    headers to enable access to the resources served from a different domain or a
    different server port:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在开始时调用的`addHeaders`函数是为了添加头部，以便访问来自不同域或不同服务器端口的资源：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The definition of headers and what they mean will be discussed later on in
    the chapter. For now, let''s just say they enable accesses to the resources from
    a browser using AJAX. At the end, we add a block of code that will set the server
    to listen on port 8080:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头部的定义和它们的含义将在本章后面讨论。现在，让我们说它们使得浏览器可以使用AJAX访问资源。最后，我们添加一段代码，将服务器设置为监听8080端口：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To start the sever using command line, we type the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用命令行启动服务器，我们输入以下命令：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If everything went as it should, we will get a message in the log:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将在日志中收到一条消息：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can then test it by accessing directly from the browser on the URL we defined
    `http://localhost:8080/hi` or see the communication using some of the tools discussed
    in [Appendix A](apa.html "Appendix A. Installing Node.js and Using npm"), *Installing
    Node.js and Using npm*.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以通过直接从浏览器访问我们定义的URL `http://localhost:8080/hi`来测试它，或者使用[附录A](apa.html "附录A。安装Node.js和使用npm")中讨论的一些工具来查看通信，*安装Node.js和使用npm*。
- en: Now we can proceed with the client-side HTML and JavaScript. We will implement
    two ways for reading data from the server, one using standard `XMLHttpRequest`
    and the other using `jQuery.get()`. Note that not all features are fully compatible
    with all browsers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行客户端HTML和JavaScript。我们将实现两种从服务器读取数据的方式，一种使用标准的`XMLHttpRequest`，另一种使用`jQuery.get()`。请注意，并非所有功能都与所有浏览器完全兼容。
- en: 'We create a simple page where we have two `div` elements, one with the ID `data`
    and another with the ID `say`. These elements will be used as placeholders to
    load data form the server into them:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的页面，其中有两个`div`元素，一个带有ID`data`，另一个带有ID`say`。这些元素将用作从服务器加载数据的占位符：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `example.js` file, we define a function called `getData` that will create
    a AJAX call to a given `url` and do a callback if the request went successfully:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`example.js`文件中，我们定义了一个名为`getData`的函数，它将创建一个AJAX调用到给定的`url`，并在请求成功时进行回调：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that, we can call the function directly, but in order to demonstrate
    that the call happens after the page is loaded, we will call it after a timeout
    of three seconds:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以直接调用该函数，但为了演示调用发生在页面加载后，我们将在三秒后调用它：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The jQuery version is a lot cleaner, as the complexity that comes with the
    standard DOM API and the event handling is reduced substantially:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: jQuery版本更加简洁，因为标准DOM API和事件处理带来的复杂性大大减少：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'At the beginning, we installed the dependency using `npm install restify`;
    this is sufficient to have it working, but in order to define dependencies in
    a more expressive way, npm has a way of specifying it. We can add a file called
    `package.json`, a packaging format that is mainly used for for publishing details
    for Node.js applications. In our case, we can define `package.json` with the flowing
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们使用`npm install restify`安装了依赖项；这足以使其工作，但为了更加明确地定义依赖关系，npm有一种指定的方法。我们可以添加一个名为`package.json`的文件，这是一个主要用于发布Node.js应用程序的打包格式。在我们的情况下，我们可以使用以下代码定义`package.json`：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we have a file like this, npm will automatically handle the installation
    of dependencies after calling `npm install` from the command line in the directory
    where the `package.json` file is placed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个像这样的文件，npm将在调用`npm install`时自动处理依赖项的安装，该命令是在放置`package.json`文件的目录中从命令行中调用的。
- en: '`Restify` has a simple routing where functions are mapped to appropriate methods
    for a given URL. The HTTP GET request for `''/hi''` is mapped with `server.get(''hi'',
    theCallback)`, where `theCallback` is executed, and a response should be returned.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Restify`有一个简单的路由，其中函数被映射到给定URL的适当方法。`''/hi''`的HTTP GET请求与`server.get(''hi'',
    theCallback)`映射，其中执行`theCallback`，并应返回一个响应。'
- en: When we have a parameterized resource, for example in `'hi/:index'`, the value
    associated with `:index` will be available under `req.params`. For example, in
    a request to `'/hi/john'` to access the `john` value, we simple have `req.params.index`.
    Additionally, the value for index will automatically get URL-decoded before it
    is passed to our handler. One other notable part of the request handlers in `restify`
    is the `next()` function that we called at the end. In our case, it mostly does
    not makes much sense, but in general, we are responsible for calling it if we
    want the next handler function in the chain to be called. For exceptional circumstances,
    there is also an option to call `next()` with an `error` object triggering custom
    responses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个参数化的资源时，例如在`'hi/:index'`中，与`:index`相关联的值将在`req.params`下可用。例如，在对`'/hi/john'`的请求中，要访问`john`值，我们只需使用`req.params.index`。此外，index的值在传递给我们的处理程序之前将自动进行URL解码。在`restify`中请求处理程序的另一个值得注意的部分是我们在最后调用的`next()`函数。在我们的情况下，这大多数情况下并没有太多意义，但一般来说，如果我们希望调用链中的下一个处理程序函数被调用，我们负责调用它。在特殊情况下，还有一种使用`error`对象触发自定义响应的方法来调用`next()`。
- en: When it comes to the client-side code, `XMLHttpRequest` is the mechanism behind
    the async calls, and on calling `request.open("GET", url, true)` with the last
    parameter value as `true`, we get a truly asynchronous execution. Now you might
    be wondering why is this parameter here, isn't the call already done after loading
    the page? That is true, the call is done after loading the page, but if, for example,
    the parameter was set to `false`, the execution of the request will be a blocking
    method, or to put it in layman's terms, the script will pause until we get a response.
    This might look like a small detail, but it can have a huge impact on performance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端代码方面，`XMLHttpRequest`是异步调用背后的机制，当调用`request.open("GET", url, true)`并将最后一个参数值设置为`true`时，我们获得了真正的异步执行。现在你可能会想为什么这个参数在这里，难道不是在加载页面后已经完成了调用吗？这是真的，调用是在加载页面后完成的，但是，例如，如果参数设置为`false`，请求的执行将是一个阻塞方法，或者用通俗的话来说，脚本将暂停，直到我们得到一个响应。这可能看起来是一个小细节，但它对性能有很大的影响。
- en: 'The jQuery part is pretty straightforward; there is function that accepts a
    URL value of the resource, the data handler function, and a `success` function
    that gets called after successfully getting a response:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery部分非常简单；有一个函数接受资源的URL值，数据处理函数，以及一个`success`函数，在成功获取响应后调用：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we open `index.htm`, the server should log something like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开`index.htm`时，服务器应该记录类似以下的内容：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here one is from the jQuery request and the other from the plain JavaScript.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个来自jQuery请求，另一个来自纯JavaScript。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**XMLHttpRequest Level 2** is one of the new improvements being added to the
    browsers, although not part of HTML5 it is still a significant change. There are
    several features with the Level 2 changes, mostly to enable working with files
    and data streams, but there is one simplification we already used. Earlier we
    would have to use `onreadystatechange` and go through all of the states, and if
    the `readyState` was `4`, which is equal to `DONE`, we could read the data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**XMLHttpRequest Level 2**是添加到浏览器中的新改进之一，尽管它不是HTML5的一部分，但仍然是一个重大变化。Level 2的变化中有几个功能，主要是为了使其能够处理文件和数据流，但也有一个我们已经使用的简化。以前，我们必须使用`onreadystatechange`并遍历所有状态，如果`readyState`是`4`，即等于`DONE`，我们才能读取数据：'
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In a Level 2 request however, we can use `request.onload = function() {}` directly
    without checking states. Possible states can be seen in the table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Level 2请求中，我们可以直接使用`request.onload = function() {}`而不必检查状态。表中可以看到可能的状态：
- en: '| State name | Numeric value | Description |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 状态名称 | 数值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `UNSENT` | `0` | Object created |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `UNSENT` | `0` | 对象已创建 |'
- en: '| `OPENED` | `1` | The `open` method was called |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `OPENED` | `1` | 调用了`open`方法 |'
- en: '| `HEADERS_RECEIVED` | `2` | All redirects have been followed and all headers
    of the final object are now available |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `HEADERS_RECEIVED` | `2` | 已经跟踪了所有重定向，并且最终对象的所有标头现在都可用 |'
- en: '| `LOADING` | `3` | The response is being revived |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `LOADING` | `3` | 响应正在被恢复 |'
- en: '| `DONE` | `4` | Data has been received or something went wrong during transfer,
    for example infinite redirects |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `DONE` | `4` | 已接收数据或在传输过程中出现问题，例如无限重定向 |'
- en: One other thing to note is that `XMLHttpRequest` Level 2 is supported in all
    major browsers and IE 10; the older `XMLHttpRequest` has a different way of instantiation
    on older versions of IE (older than IE 7), where we can access it through an ActiveX
    object via new `ActiveXObject("Msxml2.XMLHTTP.6.0");`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要注意的是，`XMLHttpRequest` Level 2在所有主要浏览器和IE 10中都受支持；旧版`XMLHttpRequest`在较旧版本的IE（早于IE
    7）中实例化的方式不同，我们可以通过新的`ActiveXObject("Msxml2.XMLHTTP.6.0")`通过ActiveX对象访问它。
- en: Creating a request with custom headers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义标头创建请求
- en: The HTTP headers are a part of the `request` object being sent to the server.
    Many of them give information about the client's user agent setup and configuration,
    as that is sometimes the basis of making description for the resources being fetched
    from the server. Several of them such as `Etag`, `Expires`, and `If-Modified-Since`
    are closely related to caching, while others such as `DNT` that stands for "Do
    Not Track" ([http://www.w3.org/2011/tracking-protection/drafts/tracking-dnt.html](http://www.w3.org/2011/tracking-protection/drafts/tracking-dnt.html))
    can be quite controversial. In this recipe, we will take a look at a way for using
    the custom `X-Myapp` header in our server and client-side code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头是发送到服务器的`request`对象的一部分。其中许多提供有关客户端用户代理设置和配置的信息，因为这有时是制作从服务器获取的资源的描述的基础。其中一些，如`Etag`、`Expires`和`If-Modified-Since`与缓存密切相关，而其他一些，如`DNT`代表“不要跟踪”（[http://www.w3.org/2011/tracking-protection/drafts/tracking-dnt.html](http://www.w3.org/2011/tracking-protection/drafts/tracking-dnt.html)）可能是相当有争议的。在这个示例中，我们将看一种在服务器和客户端代码中使用自定义`X-Myapp`头的方法。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The server will be implemented using Node.js, so you can refer to [Appendix
    A](apa.html "Appendix A. Installing Node.js and Using npm"), *Installing Node.js
    and Using npm* on how to install Node.js on your machine, and how to use npm.
    In this example, again for simplicity, we will use restify ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/)).
    Also, monitoring the console in your browser and server is crucial in order to
    understand what happens in the background.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将使用Node.js实现，因此您可以参考[附录A](apa.html "附录A. 安装Node.js和使用npm")，*安装Node.js和使用npm*，了解如何在您的计算机上安装Node.js以及如何使用npm。在这个例子中，为了简单起见，我们将使用restify
    ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/))。此外，在浏览器和服务器中监视控制台对于理解后台发生的事情至关重要。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can start by defining the dependencies for the server side in `package.json`
    file:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从`package.json`文件中定义服务器端的依赖项开始：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After that, we can call `npm install` from the command line that will automatically
    retrieve `restify` and place it in a `node_modules` folder created in the root
    directory of the project. After this part, we can proceed to creating the server-side
    code in a `server.js` file where we set the server to listen on port 8080 and
    add a route handler for `''hi''` and for every other path when the request method
    is `HTTP OPTIONS`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以从命令行调用`npm install`，这将自动检索`restify`并将其放置在项目根目录中创建的`node_modules`文件夹中。在这部分之后，我们可以继续在`server.js`文件中创建服务器端代码，在那里我们将服务器设置为侦听端口8080，并为`'hi'`和其他路径添加一个路由处理程序，当请求方法为`HTTP
    OPTIONS`时：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In most cases, the documentation should be enough when we write the application's
    build onto Restify, but sometimes, it is a good idea to take a look a the source
    code as well. It can be found on [https://github.com/mcavage/node-restify/](https://github.com/mcavage/node-restify/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当我们将应用程序的构建写入Restify时，文档应该足够了，但有时，查看源代码也是一个好主意。它可以在[https://github.com/mcavage/node-restify/](https://github.com/mcavage/node-restify/)上找到。
- en: 'One thing to notice is that we can have multiple chained handlers; in this
    case, we have `addHeaders` before the others. In order for every handler to be
    propagated, `next()` should be called:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得注意的一件事是，我们可以有多个链接的处理程序；在这种情况下，我们在其他处理程序之前有`addHeaders`。为了使每个处理程序都能传播，应该调用`next()`：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `addHeaders` adds access control options in order to enable cross-origin
    resource sharing. **Cross-origin resource sharing** (**CORS**) defines a way in
    which the browser and server can interact to determine if the request should be
    allowed. It is more secure than allowing all cross-origin requests, but is more
    powerful than simply allowing all of them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`addHeaders`添加了访问控制选项，以启用跨源资源共享。**跨源资源共享**（**CORS**）定义了浏览器和服务器可以相互交互以确定是否应该允许请求的方式。它比允许所有跨源请求更安全，但比简单地允许所有跨源请求更强大。'
- en: 'After this, we can create the handler function that will return a JSON response
    with the headers the server received and a hello world kind of object:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以创建处理程序函数，该函数将返回服务器接收到的标题和一个hello world类型的JSON响应：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We additionally log the request and response headers to the sever console log
    in order to see what happens in the background.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将请求和响应头记录到服务器控制台日志中，以便查看后台发生了什么。
- en: 'For the client-side code, we need a plain "vanilla" JavaScript approach and
    jQuery method, so in order to do that, include `example.js` and `exampleJquery.js`
    as well as a few `div` elements that we will use for displaying data retrieved
    from the server:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于客户端代码，我们需要一个简单的"纯净"JavaScript方法和jQuery方法，因此为了做到这一点，包括`example.js`和`exampleJquery.js`以及一些`div`元素，我们将用它们来显示从服务器检索到的数据：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A simple way to add the headers is to call `setRequestHeader` on a `XMLHttpRequest`
    object after the call of `open()`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加标题的一个简单方法是在`open()`调用之后在`XMLHttpRequest`对象上调用`setRequestHeader`：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `XMLHttpRequest` automatically sets headers, such as `"Content-Length"`,`"Referer"`,
    and `"User-Agent"`, and does not allow you to change them using JavaScript.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XMLHttpRequest会自动设置标题，比如"Content-Length"，"Referer"和"User-Agent"，并且不允许你使用JavaScript更改它们。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A more complete list of headers and the reasoning behind this can be found in
    the W3C documentation at [http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点的更完整的标题列表和背后的原因可以在W3C文档中找到，网址是[http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method)。
- en: 'To print out the results, we add a function that will add each of the header
    keys and values to an unordered list:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了打印结果，我们添加一个函数，该函数将把每个标题键和值添加到无序列表中：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When this gets executed. a list of all the request headers should be displayed
    on a page, and our custom `x-myapp` should be shown:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这个被执行时，所有请求头的列表应该显示在页面上，我们自定义的`x-myapp`应该显示出来：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The jQuery approach is far simpler, we can use the `beforeSend` hook to call
    a function that will set the `''x-myapp''` header. When we receive the response,
    write it down to the element with the ID `dataRecived`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: jQuery方法更简单，我们可以使用`beforeSend`钩子调用一个函数来设置`'x-myapp'`标题。当我们收到响应时，将其写入到ID为`dataRecived`的元素中：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Output from the jQuery example will be the data contained in `x-myapp` header:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: jQuery示例的输出将是包含在`x-myapp`标题中的数据：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'You may have noticed that on the server side, we added a route that has a handler
    for `HTTP OPTIONS` method, but we never explicitly did a call there. If we take
    a look at the server log, there should be something like the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在服务器端，我们添加了一个处理`HTTP OPTIONS`方法的路由，但我们从未明确地在那里调用过。如果我们查看服务器日志，应该会有类似以下输出的内容：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This happens because the browser first issues a **preflight request** , which
    in a way is the browser's question whether or not there is a permission to make
    the "real" request. Once the permission has been received, the original GET request
    happens. If the `OPTIONS` response is cached, the browser will not issue any extra
    preflight calls for subsequent requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为浏览器首先发出一个**预检请求**，这在某种程度上是浏览器询问是否有权限发出"真正"请求。一旦获得了许可，原始的GET请求就会发生。如果`OPTIONS`响应被缓存，浏览器将不会为后续请求发出任何额外的预检请求。
- en: 'The `setRequestHeader` function of `XMLHttpRequest` actually appends each value
    as a comma-separated list of values. As we called the function two times, the
    value for the header is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest`的`setRequestHeader`函数实际上将每个值附加为逗号分隔的值列表。由于我们调用了两次该函数，标题的值如下：'
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For most use cases, we do not need custom headers to be part of our logic, but
    there are plenty of API's that make good use of them. For example, many server-side
    technologies add the `X-Powered-By` header that contains some meta information,
    such as `JBoss 6` or `PHP/5.3.0`. Another example is Google Cloud Storage, where
    among other headers there are `x-goog-meta`-prefixed headers such as `x-goog-meta-project-name`
    and `x-goog-meta-project-manager`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用例，我们不需要自定义标题成为我们逻辑的一部分，但有很多API会充分利用它们。例如，许多服务器端技术会添加包含一些元信息的`X-Powered-By`标题，比如`JBoss
    6`或`PHP/5.3.0`。另一个例子是Google Cloud Storage，其中除了其他标题之外，还有以`x-goog-meta`为前缀的标题，比如`x-goog-meta-project-name`和`x-goog-meta-project-manager`。
- en: Versioning your API
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对API进行版本控制
- en: We do not always have the best solution while doing the first implementation.
    The API can be extended up to a certain point, but afterwards needs to undergo
    some structural changes. But we might already have users that depend on the current
    version, so we need a way to have different representation versions of the same
    resource. Once a module has users, the API cannot be changed at our own will.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行第一次实现时，我们并不总是有最佳解决方案。API可以扩展到一定程度，但之后需要进行一些结构性的更改。但我们可能已经有依赖于当前版本的用户，因此我们需要一种方式来拥有同一资源的不同表示版本。一旦一个模块有了用户，API就不能随我们的意愿改变。
- en: One way to resolve this issue is to use a so-called URL versioning, where we
    simply add a prefix. For example, if the old URL was `http://example.com/rest/employees`,
    the new one could be `http://example.com/rest/v1/employees`, or under a subdomain
    it could be [http://v1.example.com/rest/employee](http://v1.example.com/rest/employee).
    This approach only works if you have direct control over all the servers and clients.
    Otherwise, you need to have a way of handling fallback to older versions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是使用所谓的URL版本控制，我们只需添加一个前缀。例如，如果旧的URL是`http://example.com/rest/employees`，新的URL可以是`http://example.com/rest/v1/employees`，或者在子域下可以是[http://v1.example.com/rest/employee](http://v1.example.com/rest/employee)。只有在您对所有服务器和客户端都有直接控制权时，此方法才有效。否则，您需要有一种处理回退到旧版本的方法。
- en: In this recipe, we are going implement a so-called "Semantic versioning", [http://semver.org/](http://semver.org/),
    using HTTP headers to specify accepted versions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将实现所谓的"语义版本"，[http://semver.org/](http://semver.org/)，使用HTTP头来指定接受的版本。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The server will be implemented using Node.js, so you can refer to [Appendix
    A](apa.html "Appendix A. Installing Node.js and Using npm"), *Installing Node.js
    and Using npm* on how to install Node.js on your machine and how to use npm. In
    this example, we will use restify ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/))
    for the server-side logic to monitor the requests to understand what is sent.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将使用Node.js实现，因此您可以参考[附录A](apa.html "附录 A. 安装Node.js和使用npm")，*安装Node.js和使用npm*，了解如何在您的计算机上安装Node.js以及如何使用npm。在本例中，我们将使用restify
    ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/))
    作为服务器端逻辑来监视请求以了解发送了什么。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's perform the following steps.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤。
- en: 'We need to define the dependencies first, and after installing `restify`, we
    can proceed to the creation of the server code. The main difference with the previous
    examples is the definition of the `"Accept-version"` header. restify has built-in
    handling for this header using **versioned routes**. After creating the server
    object, we can set which methods will get called for what version:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要首先定义依赖关系，然后安装`restify`，然后我们可以继续创建服务器代码。与之前的示例的主要区别是定义`"Accept-version"`头。restify具有内置处理此头的功能，使用**版本化路由**。创建服务器对象后，我们可以设置哪些方法将在哪个版本上调用：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also need the handler for the `HTTP OPTIONS`, as we are using cross-origin
    resource sharing and the browser needs to do the additional request in order to
    get permissions:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要处理`HTTP OPTIONS`，因为我们使用跨域资源共享，浏览器需要进行额外的请求以获取权限：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The handlers for Version 1 and Version 2 will return different objects in order
    for us to easily notice the difference between the API calls. In the general case,
    the resource should be the same, but can have different structural changes. For
    Version 1, we can have the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 版本1和版本2的处理程序将返回不同的对象，以便我们可以轻松地注意到API调用之间的差异。在一般情况下，资源应该是相同的，但可能有不同的结构变化。对于版本1，我们可以有以下内容：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As for Version 2, we have the following:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于版本2，我们有以下内容：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'One other thing we must do is add the CORS headers in order to enable the `accept-version`
    header, so in the route we included the `addHeaders` that should be something
    like the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须做的另一件事是添加CORS头，以启用`accept-version`头，因此在路由中包含了`addHeaders`，应该类似于以下内容：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you should not forget to the call to `next()` in order to call the
    next function in the route chain.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不应忘记调用`next()`，以便在路由链中调用下一个函数。
- en: 'For simplicity, we will only implement the client side in jQuery, so we create
    a simple HTML document, where we include the necessary JavaScript dependencies:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们只会在jQuery中实现客户端，因此我们创建一个简单的HTML文档，其中包括必要的JavaScript依赖项：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `example.js` file, we do two AJAX calls to our REST API, one is set
    to use the Version 1 and other to use Version 2:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`example.js`文件中，我们对我们的REST API进行了两次AJAX调用，一次设置为使用版本1，另一次设置为使用版本2：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice that the `accept-version` header contains values `~1` and `~2`. These
    designate that all the semantic versions such as 1.1.0 and 1.1.1 1.2.1 will get
    matched by `~1` and similarly for `~2`. At the end, we should get an output like
    the following text:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`accept-version`头包含值`~1`和`~2`。这表示所有语义版本，例如1.1.0和1.1.1 1.2.1，都将被`~1`匹配，类似地对于`~2`。最后，我们应该得到如下文本的输出：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Versioned routes are a built-in feature of restify that work through the use
    of `accept-version`. In our example, we used Versions `~1` and `~2`, but what
    happens if we don''t specify a version? restify will do the choice for us, as
    the the request will be treated in the same manner as if the client has sent a
    `*` version. The first defined matching route in our code will be used. There
    is also an option to set up the routes to match multiple versions by adding a
    list of versions for a certain handler:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 版本化路由是restify的内置功能，通过使用`accept-version`来工作。在我们的示例中，我们使用了版本`~1`和`~2`，但是如果我们不指定版本会发生什么呢？restify将为我们做出选择，因为请求将被视为客户端发送了`*`版本的方式进行处理。我们的代码中定义的第一个匹配路由将被使用。还有一个选项，可以设置路由以匹配多个版本，通过为某个处理程序添加版本列表：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The reason why this type of versioning is very suitable for use in constantly
    growing applications is because as the API changes, the client can stick with
    their version of the API without any additional effort or changes needed in the
    client-side development. Meaning that we don't have to do updates on the application.
    On the other hand, if the client is sure that their application will work on newer
    API versions, they can simply change the request headers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的版本控制非常适合在不断增长的应用程序中使用，因为随着API的变化，客户端可以保持其API版本而无需在客户端开发中进行任何额外的努力或更改。这意味着我们不必对应用程序进行更新。另一方面，如果客户端确信他们的应用程序将在更新的API版本上运行，他们可以简单地更改请求头。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Versioning can be implemented by using custom content types prefixed with `vnd`
    for example, `application/vnd.mycompany.user-v1`. An example of this is Google
    Earth's content type KML where it is defined as `application/vnd.google-earth.kml+xml`.
    Notice that the content type can be in two parts; we could have `application/vnd.mycompany-v1+json`
    where the second part will be the format of the response.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制可以通过使用自定义内容类型来实现，前缀为`vnd`，例如，`application/vnd.mycompany.user-v1`。一个例子是谷歌地球的内容类型KML，其中定义为`application/vnd.google-earth.kml+xml`。注意内容类型可以有两部分；我们可以有`application/vnd.mycompany-v1+json`，其中第二部分将是响应的格式。
- en: Fetching JSON data with JSONP
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSONP获取JSON数据
- en: JSONP or JSON with padding is a mechanism of making cross-domain requests by
    taking advantage of the `<script>` tag. AJAX transport is done by simply setting
    the `src` attribute on a `script` element or adding the element itself if not
    present. The browser will do an HTTP request to download the URL specified, and
    that is not subject to the same origin policy, meaning that we can use it to get
    data from servers that are not under our control. In this recipe, we will create
    a simple JSONP request, and a simple server to back that up.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JSONP或带填充的JSON是一种利用`<script>`标签进行跨域请求的机制。通过简单地在`script`元素上设置`src`属性或添加元素本身来执行AJAX传输。浏览器将执行HTTP请求以下载指定的URL，这不受同源策略的限制，这意味着我们可以使用它从不受我们控制的服务器获取数据。在本示例中，我们将创建一个简单的JSONP请求和一个简单的服务器来支持它。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will make a simplified implementation of the server we used in previous examples,
    so we need Node.js and restify ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/))
    installed either via definition of `package.json` or a simple install. For working
    with Node.js, please refer to [Appendix A](apa.html "Appendix A. Installing Node.js
    and Using npm"), *Installing Node.js and Using npm*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简化的服务器实现，该服务器在之前的示例中使用过，因此我们需要安装Node.js和restify（[http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/)），可以通过定义`package.json`或简单安装来安装。有关使用Node.js，请参阅[附录A](apa.html
    "附录 A. 安装 Node.js 和使用 npm")，*安装 Node.js 和使用 npm*。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we will create a simple route handler that will return a JSON object:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的路由处理程序，它将返回一个JSON对象：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We could roll our own version that will wrap the response into a JavaScript
    function with the given name, but in order to enable JSONP when using restify,
    we can simply enable the bundled plugin. This is done by specifying what plugin
    to be used:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以自己编写一个版本，将响应包装成具有给定名称的JavaScript函数，但是为了在使用restify时启用JSONP，我们可以简单地启用捆绑的插件。这是通过指定要使用的插件来完成的：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After this, we just set the server to listen on port 8080:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们只需将服务器设置为监听端口8080：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The built-in plugin checks the request string for parameters called `callback`
    or `jsonp`, and if those are found, the result will be JSONP with the function
    name of the one passed as value to one of these parameters. For example, in our
    case, if we open the browser on `http://localhost:8080/hi`, we get the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置插件会检查请求字符串中是否有名为`callback`或`jsonp`的参数，如果找到，结果将是带有作为这些参数之一的值传递的函数名的JSONP。例如，在我们的情况下，如果我们在`http://localhost:8080/hi`上打开浏览器，我们会得到以下结果：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we access the same URL with the `callback` parameter or a JSONP set, such
    as `http://localhost:8080/hi?callback=great`, we should receive the same data
    wrapped with that function name:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用`callback`参数或设置了JSONP的相同URL，例如`http://localhost:8080/hi?callback=great`，我们应该收到用该函数名包装的相同数据：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is where the P in JSONP, which stands for padded, comes into the picture.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JSONP中的P，表示填充的地方。
- en: 'So, what we need to do next is create an HTML file where we would show the
    data from the server and include two scripts, one for the pure JavaScript approach
    and another for the jQuery way:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们接下来需要创建一个HTML文件，其中我们将显示来自服务器的数据，并包括两个脚本，一个用于纯JavaScript方法，另一个用于jQuery方法：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can proceed with the creation of `example.js`, where we create two functions;
    one will create a `script` element and set the value of `src` to `http://localhost:8080/?callback=cool.run`,
    and the other will serve as a callback upon receiving the data:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以继续创建`example.js`，在其中创建两个函数；一个将创建一个`script`元素，并将`src`的值设置为`http://localhost:8080/?callback=cool.run`，另一个将在接收到数据时作为回调服务：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Afterwards we only need the function that adds the element:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们只需要添加元素的函数：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This should read the data from the server and show a result similar to the
    following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该从服务器读取数据并显示类似以下的结果：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: From the `cool` object, we can run the `addElement` function directly as we
    defined it as self-executable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从`cool`对象中，我们可以直接运行`addElement`函数，因为我们将其定义为自执行。
- en: 'The jQuery example is a lot simpler; We can set the datatype to JSONP and everything
    else is the same as any other AJAX call, at least from the API point of view:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: jQuery示例要简单得多；我们可以将数据类型设置为JSONP，其他一切都与任何其他AJAX调用一样，至少从API的角度来看：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can now use the standard `success` callback to handle the data received from
    the server, and we don't have to specify the parameter in the request. jQuery
    will automatically append a `callback` parameter to the URL and delegate the call
    to the `success` callback.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用标准的`success`回调来处理从服务器接收到的数据，而且我们不必在请求中指定参数。jQuery将自动将`callback`参数附加到URL，并将调用委托给`success`回调。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first large leap we are doing here is trusting the source of the data. Results
    from the server is evaluated after the data is downloaded from the server. There
    has been some efforts to define a safer JSONP on [http://json-p.org/](http://json-p.org/),
    but it is far from being widespread.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的第一个重大飞跃是信任数据的来源。从服务器返回的结果在从服务器下载数据后进行评估。已经有一些努力在[http://json-p.org/](http://json-p.org/)上定义更安全的JSONP，但它远未普及。
- en: The download itself is a `HTTP GET` method adding another major limitation to
    usability. **Hypermedia as the Engine of Application State** (**HATEOAS**), among
    other things, defines the use of HTTP methods for the create, update, and delete
    operations, making JSONP very unstable for those use cases.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下载本身是通过添加另一个主要限制到可用性的`HTTP GET`方法。**超媒体作为应用程序状态的引擎**（**HATEOAS**），等等，定义了使用HTTP方法进行创建、更新和删除操作，使得JSONP对于这些用例非常不稳定。
- en: 'Another interesting point is how jQuery delegates the call to the `success`
    callback. In order to achieve this, a unique function name is created and is sent
    to the `callback` parameter, for example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的地方是jQuery如何将调用委托给`success`回调。为了实现这一点，会创建一个唯一的函数名，并将其发送到`callback`参数，例如：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function later does a callback to the appropriate handler of `jQuey.ajax`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数稍后会回调到`jQuey.ajax`的适当处理程序。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With jQuery, we can also use a custom function if the server parameter that
    should handle `jsonp` is not called `callback`. This is done using the flowing
    config:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery，如果应该处理`jsonp`的服务器参数不叫`callback`，我们也可以使用自定义函数。这是通过以下配置完成的：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As with JSONP, we don't do `XMLHttpRequest` and expect any of the functions
    that are used with AJAX call to be executed or have their parameters filled as
    such call. It is a very common mistake to expect just that. More on this can be
    found in the jQuery documentation at [http://api.jquery.com/category/ajax/](http://api.jquery.com/category/ajax/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSONP一样，我们不使用`XMLHttpRequest`，也不期望任何与AJAX调用一起使用的函数被执行或者参数被填充。期望这样做是一个非常常见的错误。关于这一点可以在jQuery文档中找到更多信息：[http://api.jquery.com/category/ajax/](http://api.jquery.com/category/ajax/)。
- en: Reading XML data from server
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器读取XML数据
- en: Another common data format for REST services is XML. If we have the option to
    choose a format, there are very small number of cases where JSON is not a better
    choice. XML is a better option if we need strict message validation using multiple
    namespaces and schemas, or for some reason, we use **Extensible Stylesheet Language
    Transformations** (**XSTL**). The biggest reason of all is the need to work with
    and support legacy environments that don't use JSON. Most of the modern server-side
    frameworks have a built-in support for content negotiation, meaning that depending
    on the client's request, they can serve up the same resource in different formats.
    In this recipe, we are going to create a simple XML server and use it from the
    client side.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务的另一种常见数据格式是XML。如果我们有选择格式的选项，那么几乎没有情况下JSON不是更好的选择。如果我们需要使用多个命名空间和模式进行严格消息验证，或者出于某种原因，我们使用**可扩展样式表语言转换**（**XSTL**），那么XML是更好的选择。最重要的原因是需要处理和支持不使用JSON的传统环境。大多数现代服务器端框架都内置了内容协商支持，这意味着根据客户端的请求，它们可以以不同的格式提供相同的资源。在这个示例中，我们将创建一个简单的XML服务器，并从客户端使用它。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For the server side, we will use Node.js with restify ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/))
    for the REST services, and xmlbuilder ([https://github.com/oozcitak/xmlbuilder-js](https://github.com/oozcitak/xmlbuilder-js))
    for creating simple XML documents. To do this, we can use npm to install the dependencies
    or define a simple `package.json` file, such as the one available in the example
    files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器端，我们将使用Node.js和restify（[http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/)）进行REST服务，并使用xmlbuilder（[https://github.com/oozcitak/xmlbuilder-js](https://github.com/oozcitak/xmlbuilder-js)）创建简单的XML文档。为此，我们可以使用npm安装依赖项，或者定义一个简单的`package.json`文件，例如示例文件中提供的文件。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's follow these steps to demonstrate the use of XML.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤演示XML的使用。
- en: 'The server code is similar to other restify-based examples that we created
    previously. As we just want to demonstrate the use of XML, we can create a simple
    structure with xmlbuilder:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端代码与我们之前创建的其他基于restify的示例类似。由于我们只是想演示XML的使用，我们可以使用xmlbuilder创建一个简单的结构：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The use of it is very straightforward; the `doc.begin('root')` statement creates
    the root of the document and the `ele()` and `att()` statements create an element
    and attribute accordingly. As we are always adding new parts on the level of nesting
    where we added the last one, in order to move the cursor on level up, we just
    call the `up()` function.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用起来非常简单；`doc.begin('root')`语句创建了文档的根，`ele()`和`att()`语句分别创建了元素和属性。由于我们总是在上次添加的嵌套级别上添加新的部分，为了将光标移动到上一个级别，我们只需调用`up()`函数。
- en: 'In our case, the document that will be generated is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，将生成的文档如下：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To create the route for the resource, we can create `server.get(''hi'', addHeaders,
    respond)`, where the `add` headers are the ones for CORS and the response will
    return the XML document we created as a string:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了为资源创建路由，我们可以创建`server.get('hi', addHeaders, respond)`，其中`add` headers是CORS的头部，响应将返回我们创建的XML文档作为字符串：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'restify does not have a direct support for `application/xml`; if we leave it
    like this, the server''s response will be of type `application/octet-stream`.
    In order to add support, we will create the `restify` object and add a formatter
    that will accept XML:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: restify不直接支持`application/xml`；如果我们保持这样，服务器的响应将是`application/octet-stream`类型。为了添加支持，我们将创建`restify`对象，并添加一个接受XML的格式化程序：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The server should be returning correct `content-type` and CORS headers together
    with the response data:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应该返回正确的`content-type`和CORS头部，以及响应数据：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As we have the server ready, we can proceed with the client side by creating
    a basic HTML file in which we will include jQuery and a simple script:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于服务器已经准备好，我们可以继续在客户端创建一个基本的HTML文件，其中我们将包含jQuery和一个简单的脚本：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For simplicity, we use `jQuery.ajax()`, where the value of `dataType` will
    be `xml`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为简单起见，我们使用`jQuery.ajax()`，其中`dataType`的值将是`xml`：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While most of the example code should be straightforward, the first thing you
    might be wondering is what is `application/octet-stream`? Well, it is an internet
    media type of a generic binary data stream. If we were to open the resource with
    a browser, it will ask us where to save it or with what application it should
    be opened.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数示例代码应该很简单，但你可能会想知道`application/octet-stream`是什么？嗯，它是一种通用二进制数据流的互联网媒体类型。如果我们用浏览器打开资源，它会要求我们保存它或者用什么应用程序打开它。
- en: The `formatter` we added in the `restify` implementation accepts a function
    with the request, response, and the body. It is the `body` object that is of most
    interest to us; we check if it is an instance of `Error` in order to somehow handle
    it. The other check that needs to be done is if the `body` is an instance of `Buffer`.
    JavaScript does not play very well with binary data, so a `Buffer` object was
    created to store raw data. In our case, we just return the body, as we already
    have constructed the XML. If we do a lot of processing like this, it might make
    sense to add formatting for JavaScript objects directly rather manually creating
    a string with XML data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`restify`实现中添加的`formatter`接受一个带有请求、响应和主体的函数。对我们来说，最感兴趣的是`body`对象；我们检查它是否是`Error`的实例，以便以某种方式处理它。需要进行的另一个检查是`body`是否是`Buffer`的实例。JavaScript与二进制数据的处理不太好，因此创建了一个`Buffer`对象来存储原始数据。在我们的情况下，我们只返回主体，因为我们已经构建了XML。如果我们经常进行这样的处理，直接为JavaScript对象添加格式化可能是有意义的，而不是手动创建包含XML数据的字符串。
- en: 'On the client side, we used `jQuery.ajax()` to get the XML, and when that happens,
    the `success` callback does not just receive text, but also accepts a DOM element
    that we can traverse using standard jQuery selectors. In our case, with `"root>
    human"`, we select all the `human` elements, and for the text inside, each of
    them appends a paragraph to `"#humans"`, just like working with HTML:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们使用`jQuery.ajax()`来获取XML，当这种情况发生时，`success`回调不仅接收文本，还接受一个DOM元素，我们可以使用标准的jQuery选择器来遍历。在我们的情况下，使用`"root>
    human"`，我们选择所有的`human`元素，并且对其中的文本，每个元素都向`"#humans"`添加一个段落，就像处理HTML一样：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: JXON ([https://developer.mozilla.org/en-US/docs/JXON](https://developer.mozilla.org/en-US/docs/JXON))
    is one good alternative when we have to support XML. Without standardization,
    it follows a simple convention to transform XML to JSON. Another good option for
    working with XML is to use XPath—the XML Path Language ([http://www.w3.org/TR/xpath/](http://www.w3.org/TR/xpath/)),
    a query language that can be used to retrieve values from certain nodes or to
    select them for other manipulation. XPath is the simplest option in most of the
    use cases and as such, it should often be our first option.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: JXON ([https://developer.mozilla.org/en-US/docs/JXON](https://developer.mozilla.org/en-US/docs/JXON))是在我们必须支持XML时的一个很好的选择。没有标准化，它遵循一个简单的约定，将XML转换为JSON。在处理XML时，另一个很好的选择是使用XPath——XML
    Path Language ([http://www.w3.org/TR/xpath/](http://www.w3.org/TR/xpath/))，这是一种查询语言，可用于从某些节点中检索值或选择它们进行其他操作。XPath在大多数情况下是最简单的选择，因此通常应该是我们的首选。
- en: Older versions of jQuery (before Version 1.1.2) had support of XPath out of
    the box but was later removed as the standard selectors are lot more powerful
    when doing HTML transformations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的jQuery（1.1.2版本之前）默认支持XPath，但后来被移除，因为标准选择器在进行HTML转换时更加强大。
- en: ECMAScript for XML or commonly known as E4X is a programming language extension
    to enable native support for XML. Although it has several implementations available
    in the newest version of Firefox, it's getting removed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript for XML或通常称为E4X是一种编程语言扩展，用于原生支持XML。虽然最新版本的Firefox中有几种实现可用，但它正在被移除。
- en: Using the FormData interface
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FormData接口
- en: One of the new features added to `XMLHttpRequest` Level 2 ([http://www.w3.org/TR/XMLHttpRequest2/](http://www.w3.org/TR/XMLHttpRequest2/))
    is the `FormData` object. This enables us to use a set of key-value pairs that
    can be sent using AJAX. The most common use is in sending binary files or any
    other large amount of data. In this recipe, we will create two scripts that will
    send `FormData`, one with a plain JavaScript and the other with jQuery, as well
    as the server-side code to support it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`XMLHttpRequest` Level 2 ([http://www.w3.org/TR/XMLHttpRequest2/](http://www.w3.org/TR/XMLHttpRequest2/))中的新功能之一是`FormData`对象。这使我们能够使用一组可以使用AJAX发送的键值对。最常见的用途是发送二进制文件或任何其他大量的数据。在这个示例中，我们将创建两个脚本，一个将发送`FormData`，一个使用纯JavaScript，另一个使用jQuery，以及支持它的服务器端代码。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The server will be done in Nodejs using restify ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/)).
    In order to install the dependencies, a `package.json` file can be created where
    restify will be added.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将在Nodejs中使用restify ([http://mcavage.github.io/node-restify/](http://mcavage.github.io/node-restify/))完成。为了安装依赖项，可以创建一个`package.json`文件，其中将添加restify。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The server should be able to accept `HTTP POST` with type `multipart/form-data`;
    that is why there is a built-in plugin for `restify` called `BodyParser`. This
    will block the parsing of the HTTP request body:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器应该能够接受`HTTP POST`，类型为`multipart/form-data`；这就是为什么`restify`有一个内置的名为`BodyParser`的插件。这将阻止解析HTTP请求体：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This switches the content type, and depending on it, does the appropriate logic
    for `application/json`, `application/x-ww-form-urlencoded`, and `mutipart/form-data`.
    The `addHeaders` parameter will be the same as we added in the other examples
    that enables CORS. For simplicity in our `doPost` handler, we just log the request
    body and return HTTP 200:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将切换内容类型，并根据内容类型执行适当的逻辑，如`application/json`，`application/x-ww-form-urlencoded`和`mutipart/form-data`。`addHeaders`参数将与我们在其他示例中添加的相同，以启用CORS。为了简化我们的`doPost`处理程序，我们只记录请求体并返回HTTP
    200：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the client side, we create an HTML file that will have a simple script:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于客户端，我们创建一个简单的脚本的HTML文件：
- en: '[PRE59]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `jQuery` way is a lot simpler; we can set `FormData` as part of the `data`
    attribute in `jQuery.ajax()` where additionally we need to disable data processing
    before we send and leave the original content type:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jQuery`的方式要简单得多；我们可以将`FormData`设置为`jQuery.ajax()`中的`data`属性的一部分，此外，在发送之前我们需要禁用数据处理并保留原始内容类型：'
- en: '[PRE60]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The transmitted data will have the same format as it would if we submitted a
    form that has the `multipart/form-data` encoding type. The need for this type
    of encoding comes from sending mixed data together with files. This encoding is
    supported by most of the web browsers and web servers. The encoding can be used
    for forms that are not HTML or even part of the browser.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 传输的数据将具有与提交具有`multipart/form-data`编码类型的表单相同的格式。这种编码的需求来自于将混合数据与文件一起发送。大多数Web浏览器和Web服务器都支持这种编码。这种编码可以用于不是HTML甚至不是浏览器的表单。
- en: 'If we take a look at request being sent, we can see that it has the following
    data:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看发送的请求，我们可以看到它包含以下数据：
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The payload will be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 负载将如下所示：
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You may notice that each of these parts contain a `Content-Disposition` section
    with the name of the control that is an origin of the data or, in our case, the
    key we set in every append to the `FormData` object. There is also an option to
    set the content type on each individual part, for example, if we had an image
    from some control named `profileImage` then that part can be as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，每个部分都包含一个`Content-Disposition`部分，其中包含数据的来源或者在我们的情况下，我们在每个附加到`FormData`对象的键中设置的名称。还有一个选项可以在每个单独的部分上设置内容类型，例如，如果我们有一个来自名为`profileImage`的控件的图像，那么该部分可以如下所示：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The last call to `xhr.sent()` in `example.js` sets the content type automatically
    when we are sending an object of type `FormData`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.js`中对`xhr.sent()`的最后一次调用在发送`FormData`类型的对象时会自动设置内容类型。'
- en: 'And if we need to support older legacy browsers that don''t have `XMLHttpRequest`
    level 2, we can check if `FormData` is there and handle that case accordingly:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要支持旧的不支持`XMLHttpRequest`级别2的传统浏览器，我们可以检查`FormData`是否存在，并相应地处理该情况：
- en: '[PRE64]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The method we use as a fallback cannot be an AJAX call, but this should not
    be a problem as all the modern browsers IE<10 version don't have support for it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为后备使用的方法不能是一个AJAX调用，但这不应该是一个问题，因为所有现代浏览器IE<10版本都不支持它。
- en: Posting a binary file to the server
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向服务器发送二进制文件
- en: Posting text, XML, or JSON to the server is relatively easy, and most JavaScript
    libraries are optimized for that scenario.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 向服务器发送文本、XML或JSON相对容易，大多数JavaScript库都针对这种情况进行了优化。
- en: Posting binary data is slightly trickier. Modern applications may need to be
    able to upload the generated binary files; examples include images drawn on an
    HTML5 canvas, ZIP files created with JSZip, and so on.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 发送二进制数据稍微棘手。现代应用程序可能需要能够上传生成的二进制文件；例如，在HTML5画布上绘制的图像、使用JSZip创建的ZIP文件等。
- en: Additionally, it's convenient to be able to upload files selected using the
    HTML5 file API. We can do some interesting things with it, such as resumable file
    uploads by splitting the file into smaller parts and uploading every part separately
    to the server.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，能够上传使用HTML5文件API选择的文件是非常方便的。我们可以做一些有趣的事情，比如通过将文件分割成较小的部分，并将每个部分单独上传到服务器来实现可恢复的文件上传。
- en: In this recipe, we're going to upload files selected by the user using a file
    input.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用文件输入来上传用户选择的文件。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The server will be implemented using Node.js—you can download and install Node.js
    from [http://nodejs.org/](http://nodejs.org/). The server will be implemented
    with the Node.js framework **Connec** **t** ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将使用Node.js实现-您可以从[http://nodejs.org/](http://nodejs.org/)下载并安装Node.js。服务器将使用Node.js框架**Connec**
    **t** ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/))实现。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Let's write the client and server code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写客户端和服务器代码。
- en: 'Create a file named `index.html`—the file upload page that includes a file
    input, upload button, a progress bar, and a message container:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的文件，包括文件输入、上传按钮、进度条和消息容器的文件上传页面：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create a file named `uploader.js` that implements a binary file uploader. It
    posts the file to a specified URL and returns an object that enables the binding
    of progress events:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`uploader.js`的文件，实现一个二进制文件上传器。它将文件发送到指定的URL，并返回一个对象，用于绑定进度事件：
- en: '[PRE66]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a file named `example.js` that uses the API provided by `uploader.js`
    to add the upload functionality to the upload form:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example.js`的文件，使用`uploader.js`提供的API为上传表单添加上传功能：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a file named `server.js`—a Node.js server based on the Node.js Connect
    framework that handles the file uploads and serves the static files:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`server.js`的文件，这是一个基于Node.js Connect框架的Node.js服务器，用于处理文件上传和提供静态文件：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Open a command prompt from the directory where `server.js` is located and type
    the following commands to create a directory for the uploads, install the connect
    library, and start the server:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存放`server.js`的目录打开命令提示符，并输入以下命令来创建一个用于上传的目录，安装connect库，并启动服务器：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Navigate your browser to `http://localhost:8080` to test the example. All the
    created files (including `server.js`) should be in the same directory.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器导航到`http://localhost:8080`以测试示例。所有创建的文件（包括`server.js`）应该在同一个目录中。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The new `XMLHttpRequest` object in HTML5 has a `send` method that supports more
    types of data. It can accept `File`, `Blob`, and `ArrayBuffer` objects. We use
    this new functionality together with the HTML5 File API to upload the file selected
    by the user. You can find out more about this API in the *Using file inputs on
    the client side* recipe of [Chapter 4](ch04.html "Chapter 4. Using HTML5 Input
    Components"), *Using HTML5 Input Components*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5中的新`XMLHttpRequest`对象具有支持更多类型数据的`send`方法。它可以接受`File`、`Blob`和`ArrayBuffer`对象。我们将这种新功能与HTML5文件API一起使用，以上传用户选择的文件。您可以在[第4章](ch04.html
    "第4章。使用HTML5输入组件")的*在客户端使用文件输入*配方中找到有关此API的更多信息，*使用HTML5输入组件*。
- en: The new API also provides an `upload` object, which is of type `XMLHttpRequestUpload`.
    It allows us to attach event listeners to monitor the upload progress. We use
    this functionality to show a progress bar for the upload.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 新API还提供了一个`upload`对象，类型为`XMLHttpRequestUpload`。它允许我们附加事件监听器来监视上传进度。我们使用这个功能来显示上传的进度条。
- en: The server accepts the uploads at `'/upload'` and saves the files to the `uploads`
    directory. Additionally, it serves the static files in the example directory.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接受`'/upload'`处的上传，并将文件保存到`uploads`目录。此外，它还提供示例目录中的静态文件。
- en: There's more…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The new XHR API is only available in Internet Explorer 10 and up.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 新的XHR API仅适用于Internet Explorer 10及以上版本。
- en: Some browsers may fail to fire upload progress events.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有些浏览器可能无法触发上传进度事件。
- en: Creating an SSL connection with Node.js
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js创建SSL连接
- en: Common security problems are so-called man-in-the-middle attacks, a form of
    eavesdropping in which the attacker makes independent connections to the victim
    and forwards the messages to the desired locations. The attacker must be able
    to intercept messages and change them on his own. This is only possible if the
    attacker can successfully impersonate the two involved parties. **Secure Socket
    Layer** (**SSL**) and it's successor **Transport Layer Security** (**TSL**) prevent
    these type of attacks by encrypting the data. In this recipe, we create a Node.js
    server using restify that has support for HTTPS.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的安全问题是所谓的中间人攻击，这是一种窃听的形式，攻击者会独立连接到受害者并将消息转发到所需的位置。攻击者必须能够拦截消息并自行更改。只有在攻击者能够成功冒充两个涉及方时，这才有可能。**安全套接字层**（**SSL**）及其后继者**传输层安全**（**TSL**）通过加密数据来防止这种类型的攻击。在这个示例中，我们创建一个使用restify的Node.js服务器，该服务器支持HTTPS。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will use a certificate and a server private key in order to enable HTTPS.
    To generate this, we need OpenSSL ([http://www.openssl.org/](http://www.openssl.org/)),
    a fully featured open source toolkit implementing SSL and TLS, as well as a general
    purpose cryptography library.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用HTTPS，我们将使用证书和服务器私钥。为了生成这个，我们需要OpenSSL（[http://www.openssl.org/](http://www.openssl.org/)），这是一个完整的开源工具包，实现SSL和TLS，以及一个通用的密码库。
- en: 'First, on the command line, generate an RSA ([http://en.wikipedia.org/wiki/RSA_(algorithm)](http://en.wikipedia.org/wiki/RSA_(algorithm)))
    private key:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在命令行上，生成一个RSA（[http://en.wikipedia.org/wiki/RSA_(algorithm)](http://en.wikipedia.org/wiki/RSA_(algorithm)）私钥：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![Getting ready](img/9282OT_08_01.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/9282OT_08_01.jpg)'
- en: 'The actual key that will get generated should be something like the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的实际密钥应该类似于以下内容：
- en: '![Getting ready](img/9282OT_08_02.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/9282OT_08_02.jpg)'
- en: The one you generated should be substantially longer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你生成的应该要长得多。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the private key is called *private* for a reason, you should not have
    it in any version control system or have it accessible for everyone. This should
    be kept safe, as it is your real identification.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，私钥之所以称为*私钥*是有原因的，你不应该将其放在任何版本控制系统中，也不应该让所有人都可以访问。这应该保持安全，因为这是你的真实身份证明。
- en: 'Next we will create a **Certificate Signing Request** (**CSR**) file using
    the private key that we just created with some additional information that will
    be prompted to enter:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用刚刚创建的私钥创建一个**证书签名请求**（**CSR**）文件，并输入一些额外的信息：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After filling out the form, we get a CSR file generated, which is intended
    for asking a Certificate Authority to sign your certificate. This file could be
    sent to them for processing and they would give us a certificate. As we are only
    creating a simple example, we will self-sign the file using our private key:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表格后，我们生成了一个CSR文件，用于向证书颁发机构请求签署您的证书。这个文件可以发送给他们进行处理，他们会给我们一个证书。由于我们只是创建一个简单的示例，我们将使用我们的私钥自签名文件：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `publiccert.pem` file is the one that we will use as a certificate in our
    server.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`publiccert.pem`文件是我们将在服务器上用作证书的文件。'
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First we add the dependencies, and then we create an `options` object where
    we read out the key and the certificate that we generated:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加依赖项，然后创建一个`options`对象，从中读取我们生成的密钥和证书：
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: File IO in Node.js is provided using the `fs` module. This is a wrapper to the
    standard POSIX functionality. The documentation on it can be found at [http://nodejs.org/api/fs.html](http://nodejs.org/api/fs.html).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的文件IO是使用`fs`模块提供的。这是标准POSIX功能的包装器。可以在[http://nodejs.org/api/fs.html](http://nodejs.org/api/fs.html)上找到有关它的文档。
- en: 'We continue with the creation of the routes and handlers, and in order not
    to duplicate the logic for the two server instances, we create a common `serverCreate`
    function:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续创建路由和处理程序，并为了不重复两个服务器实例的逻辑，我们创建一个通用的`serverCreate`函数：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then we can use this function to create instances of the two servers:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以使用这个函数来创建两个服务器的实例：
- en: '[PRE75]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can set the standard server to listen to port `80` and the HTTPS version
    to port `443`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将标准服务器设置为监听端口`80`，HTTPS版本设置为端口`443`：
- en: '[PRE76]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we can call `node server.js` to start the servers and try to access the
    following pages from the browser:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以调用`node server.js`来启动服务器，并尝试从浏览器访问以下页面：
- en: '`http://localhost:80/hi/John`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:80/hi/John`'
- en: '`http://localhost:443/hi/UncleSam`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:443/hi/UncleSam`'
- en: How it works...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The first thing you might encounter when running the server is an error similar
    to the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行服务器时，你可能会遇到以下类似的错误：
- en: '[PRE77]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The problem here is that the server itself cannot bind to a port smaller than
    1024 unless it has root or administrative privileges(as commonly known).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于服务器本身无法绑定到小于1024的端口，除非具有root或管理员权限（众所周知）。
- en: 'The HTTPS server we just created uses public key cryptography. Each peer has
    two keys: one public and one private.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的HTTPS服务器使用了公钥密码学。每个对等方都有两个密钥：一个公钥和一个私钥。
- en: Note
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In cryptography, commonly the involved parties are called Alice and Bob, so
    we will use the same names. More on the topic can be found on Wikipedia at [http://en.wikipedia.org/wiki/Alice_and_Bob](http://en.wikipedia.org/wiki/Alice_and_Bob).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，通常涉及的各方被称为Alice和Bob，因此我们将使用相同的名称。关于这个主题的更多信息可以在维基百科上找到[http://en.wikipedia.org/wiki/Alice_and_Bob](http://en.wikipedia.org/wiki/Alice_and_Bob)。
- en: Alice and Bob's public keys are shared with everyone, and their private keys
    are kept secret. In order for Alice to encrypt a message that she needs to sent
    to Bob, she needs Bob's public key and her private key. On the other hand, if
    Bob needs to decrypt the same message that he received from Alice, he needs her
    public key and his private key.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob的公钥与所有人共享，而他们的私钥则保密。为了让Alice加密她需要发送给Bob的消息，她需要Bob的公钥和她自己的私钥。另一方面，如果Bob需要解密他从Alice那里收到的相同消息，他需要她的公钥和他自己的私钥。
- en: In TLS connections, the public key is the certificate. This is because it is
    signed to prove that the real owner is the person they are claiming to be; for
    example Bob. TSL certificates can be signed by a Certificate Authority that actuality
    confirms that Bob is who it claims to be. Firefox, Chrome, and other browsers
    have a list of root CA's that are trusted for issuing a certificate. This root
    CA may issue certificates to other signing authorities that sell them to the general
    public; very interesting business don't you think?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在TLS连接中，公钥是证书。这是因为它是签名的，以证明真正的所有者是他们声称的人；例如Bob。TSL证书可以由一个实际确认Bob是他所声称的人的证书颁发机构签名。Firefox、Chrome和其他浏览器有一个受信任的用于签发证书的根CA列表。这个根CA可能会向其他签名机构签发证书，然后将它们出售给普通公众；这是一个非常有趣的业务，你不觉得吗？
- en: 'In our case, we self-signed our certificate so it is not trusted by the browsers,
    when we open it, we get the following lovely little page:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们自签了我们的证书，所以它不被浏览器信任，当我们打开它时，我们会得到以下可爱的小页面：
- en: '![How it works...](img/9282OT_08_03.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_08_03.jpg)'
- en: This message will not appear when we use a CA-signed certificate, as we would
    have an authority recognized by our browser as a trusted one.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用CA签名的证书时，这条消息将不会出现，因为我们将拥有一个被我们的浏览器认可为受信任的权威。
- en: There's more...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Open Web Application Security Project, or OWASP ([https://www.owasp.org/](https://www.owasp.org/)),
    has a comprehensive database of procedures of common security problems and pitfalls
    when creating web application. There you can find a great cheat sheet for security
    about HTML5 applications ([https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet](https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet)).
    When it comes to HTTPS, one common problem is having mixed content that does not
    always come from same protocol. One simple way to increase security is to have
    every request sent over TLS/SSL.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 开放Web应用安全项目，或OWASP ([https://www.owasp.org/](https://www.owasp.org/))，在创建Web应用程序时，有一个关于常见安全问题和陷阱的全面数据库。在那里，您可以找到有关HTML5应用程序安全的很棒的安全速查表([https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet](https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet))。在涉及HTTPS时，一个常见的问题是存在不总是来自相同协议的混合内容。增加安全性的一个简单方法是将每个请求都发送到TLS/SSL。
- en: Making real-time updates with Ajax Push
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ajax Push进行实时更新
- en: '**Comet** is a web model in which a long-held HTTP request allows the server
    to "push" data from the server to the browser without the need for the browser
    to make a request explicitly. Comet is known in many different names, Ajax Push,
    Server Push, Reverse Ajax two-way-web, and so on. In this recipe, we are going
    to create a simple server that sends or "pushes" its current time to client.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Comet是一种Web模型，其中长时间保持的HTTP请求允许服务器向浏览器“推送”数据，而无需浏览器明确发出请求。Comet以许多不同的名称而闻名，如Ajax
    Push，Server Push，Reverse Ajax双向Web等。在这个示例中，我们将创建一个简单的服务器，向客户端发送或“推送”当前时间。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this example, we will use Node.js and a library called **Socket.IO** ([http://socket.io/](http://socket.io/)).
    The dependency can be included in the `package.json` file or directly installed
    from npm.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Node.js和一个名为**Socket.IO**的库([http://socket.io/](http://socket.io/))。这个依赖项可以包含在`package.json`文件中，也可以直接从npm安装。
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: Let's get started.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'First, we will start with the server side, where we will add the needed `require`
    statements for Socket.IO, HTTP, and filesystem:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从服务器端开始，我们将添加所需的Socket.IO、HTTP和文件系统的`require`语句：
- en: '[PRE78]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The server is initialized with `requestHandler`, where we will just serve an
    `index.html` file placed in the same directory that we will create a bit later:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器初始化为`requestHandler`，我们将在其中提供一个位于同一目录中的`index.html`文件，稍后我们将创建：
- en: '[PRE79]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If the file cannot be read, it returns HTTP 500, and if everything is fine,
    it just returns the data, a very simplified handler. We set the server to listen
    on port 80 with `app.listen(80)` and afterwards we can continue with the Socket.IO-related
    configuration:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果无法读取文件，它将返回HTTP 500，如果一切正常，它将返回数据，这是一个非常简化的处理程序。我们将服务器设置为侦听端口80，然后我们可以继续进行与Socket.IO相关的配置：
- en: '[PRE80]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here we set the only allowed transport to be `xhr-polling` for the purpose of
    the example. Socket.IO has support for multiple different ways of sending server-side
    events to the client, so we disabled everything else.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将唯一允许的传输设置为`xhr-polling`，以便进行示例。Socket.IO支持多种不同的向客户端发送服务器端事件的方式，因此我们禁用了其他所有内容。
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in a real-life application, you probably will want to leave the other
    transport methods as they might be a better option for the given client or act
    as a fallback mechanism.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在实际应用中，您可能会希望保留其他传输方法，因为它们可能是给定客户端的更好选择，或者作为备用机制。
- en: 'Afterwards, we can continue with the events. On every connection we get, we
    emit a `ping` event with some JSON data towards the client the first time, and
    on every received `pong` event, we wait for 15 seconds and then again send some
    JSON data with the current server time:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以继续进行事件。在每次连接时，我们向客户端发出一个带有一些JSON数据的`ping`事件，第一次，每当收到`pong`事件时，我们等待15秒，然后再次发送一些带有当前服务器时间的JSON数据：
- en: '[PRE81]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now on the client side, we will include the `socket.io.js` file, and as we
    are serving our `index.html` file from node, it will be added with the following
    default path:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在客户端，我们将包含`socket.io.js`文件，由于我们正在从node提供我们的`index.html`文件，它将被添加到以下默认路径：
- en: '[PRE82]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'After that, we connect to `localhost` and wait for a `ping` event, and on every
    such event, we append a `p` element with the server time. We then emit a `pong`
    event to the server:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们连接到`localhost`并等待`ping`事件，每次收到这样的事件时，我们都会附加一个带有服务器时间的`p`元素。然后我们向服务器发出`pong`事件：
- en: '[PRE83]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now when we start the server and access `index.html` by opening `http://localhost`,
    we should be getting server updates without explicitly asking for them:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们启动服务器并通过打开`http://localhost`访问`index.html`时，我们应该可以在没有明确请求的情况下获得服务器更新：
- en: '[PRE84]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If we don''t set the only transport method to be Ajax pooling or xhr-polling,
    Socket.IO will attempt to use the best method available. Currently, there are
    several transports supported: WebSocket, Adobe Flash Socket, AJAX long polling,
    AJAX multipart streaming, Forever IFrame, and JSONP Polling.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不将唯一的传输方法设置为Ajax轮询或xhr-polling，Socket.IO将尝试使用最佳可用方法。目前，支持几种传输：WebSocket、Adobe
    Flash Socket、AJAX长轮询、AJAX多部分流式传输、Forever IFrame和JSONP轮询。
- en: Depending on the browser used, different methods might be better, worse, or
    not available, but it's safe to say that WebSockets are the future. Long polling
    is easier to implement on the browser side and works with every browser that supports
    `XMLHttpRequest`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的浏览器，不同的方法可能更好、更差或不可用，但可以肯定的是WebSockets是未来。长轮询在浏览器端更容易实现，并且适用于支持`XMLHttpRequest`的每个浏览器。
- en: As the name suggests, long polling works with the client requesting the server
    for an event. This request is left open until the server has sent some new data
    to the browser or has closed the connection.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，长轮询是指客户端请求服务器事件。这个请求保持打开状态，直到服务器向浏览器发送了一些新数据或关闭了连接。
- en: 'If we open up a console in our example, we can see that a request is done towards
    the server, but it is not closed as the response is not finished:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在我们的示例中打开控制台，我们可以看到向服务器发送了一个请求，但由于响应尚未完成，它没有关闭：
- en: '| hOC6eXNTrdIhwO9aHcqX?t=1360049439710/socket.io/1/xhr-polling | GET | (pending)
    |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| hOC6eXNTrdIhwO9aHcqX?t=1360049439710/socket.io/1/xhr-polling | GET | (pending)
    |'
- en: As we configured the server-pulling duration to 10 seconds with `io.set("polling
    duration", 10)`, this connection will be closed and another is reopened. The first
    thing you might be wondering is why do we ever need to close the connections?
    Well, if we don't, the resources on the server will easy get depleted.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将服务器轮询持续时间设置为10秒，使用`io.set("polling duration", 10)`，这个连接将被关闭，然后重新打开。您可能会想知道为什么我们需要关闭连接？如果不关闭，服务器上的资源将很容易被耗尽。
- en: 'You may notice the closing and sending of the data in the server console:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到服务器控制台中的关闭和数据发送：
- en: '[PRE85]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: One additional thing to note is that as soon as the connection is closed, either
    due to a response received or due to a timeout on the server side, a new one is
    created. The newly created request usually has a connection for the server waiting
    for it, resulting in a significant reduction of latency.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要注意的是，一旦连接关闭，无论是因为收到响应还是因为服务器端超时，都会创建一个新连接。新创建的请求通常会有一个等待它的服务器连接，从而显著减少延迟。
- en: There's more...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Socket.IO has plenty of other features that we did not cover. One of them is
    the broadcasting of messages to all the connected clients. For example, to let
    everyone know that a new user connected, we can do the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO还有许多其他功能，我们没有涉及。其中之一是向所有连接的客户端广播消息。例如，为了让每个人都知道有新用户连接，我们可以这样做：
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Even if we don't use Node.js, the comet technologies or "hacks" are available
    in most of the programming languages, and are a great way to improve the user
    experience.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不使用Node.js，大多数编程语言都可以使用彗星技术或“黑客技术”，这是改善用户体验的好方法。
- en: Exchanging real-time messages using WebSockets
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebSockets交换实时消息
- en: Before HTML5 Web Sockets, web applications that needed to implement real-time
    updates, such as chat messages and game moves, had to resort to inefficient methods.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5 Web Sockets之前，需要实现实时更新的Web应用程序，如聊天消息和游戏移动，必须采用低效的方法。
- en: The most popular method was to use long polling, where a connection to the server
    is kept open until an event arrives. Another popular method was streaming chunked
    blocks of JavaScript to an `iframe` element, also known as **comet streaming**
    .
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的方法是使用长轮询，即保持与服务器的连接直到事件到达。另一种流行的方法是将JavaScript的分块流式传输到`iframe`元素，也被称为**彗星流**。
- en: HTML5 WebSockets enable the exchange of real-time messages with the web server.
    The API is much cleaner and easier to use, less error-prone, and provides lower
    message latency.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 WebSockets使得可以与Web服务器交换实时消息。该API更清洁、更易于使用，错误更少，并且提供更低的消息延迟。
- en: 'In this recipe, we''re going to implement a simple chat system based on WebSockets.
    To make the system easier to extend, we''re going to use dnode on top of the underlying
    WebSockets. The dnode library provides full callback-based RPC for multiple languages
    and platforms: Node.js, Ruby, Java, and Perl. Essentially, it enables us to call
    server-side code as if it were executing on the client side.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将实现一个基于WebSockets的简单聊天系统。为了使系统更易于扩展，我们将在底层WebSockets上使用dnode。dnode库为多种语言和平台提供了完整的基于回调的RPC：Node.js、Ruby、Java和Perl。基本上，它使我们能够调用服务器端代码，就好像它在客户端执行一样。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The server will be implemented using Node.js—you can download and install Node.js
    from [http://nodejs.org/](http://nodejs.org/).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将使用Node.js实现——您可以从[http://nodejs.org/](http://nodejs.org/)下载并安装Node.js。
- en: 'To prepare yourself, you will also need to install some node modules. Create
    a new directory for the recipe and type in the following commands to install node
    modules:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做好准备，您还需要安装一些node模块。为该示例创建一个新目录，并输入以下命令以安装node模块：
- en: '[PRE87]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's write the client and the server.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来编写客户端和服务器。
- en: Create the main chat page containing a list of messages, a list of users, and
    a text input box in `index.html`. The chat page is styled to fill the whole browser
    viewport.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`中创建包含消息列表、用户列表和文本输入框的主要聊天页面。聊天页面的样式填满整个浏览器视口。
- en: '[PRE88]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Create a file named `chat.js`—a chat room implementation in JavaScript. The
    `chat()` function creates a chat room and returns the public API of the `chatroom`,
    consisting of the `join`, `leave`, `msg`, `ping`, and `listen` functions.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`chat.js`的文件——JavaScript中的聊天室实现。`chat()`函数创建一个聊天室，并返回`chatroom`的公共API，包括`join`、`leave`、`msg`、`ping`和`listen`函数。
- en: '[PRE89]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let''s create the Node.js script named `server.js`, implementing the web server:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建名为`server.js`的Node.js脚本，实现web服务器：
- en: '[PRE90]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create a file named `example.js` to implement the chat client:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example.js`的文件来实现聊天客户端：
- en: '[PRE91]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Use `browserify` to create `example.min.js`:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`browserify`创建`example.min.js`：
- en: '[PRE92]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Start the node server:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动node服务器：
- en: '[PRE93]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Navigate your browser to [http://localhost:8080](http://localhost:8080) to test
    the example.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器导航到[http://localhost:8080](http://localhost:8080)来测试示例。
- en: How it works...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We're not using the WebSockets API directly here. The reason for that is, it's
    not very easy to send responses to messages using the raw WebSockets—they don't
    support a request-response cycle. Because of that, it would be much harder to
    implement some of the RPC calls, such as asking the server if the name is available.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有直接使用WebSockets API。原因是，使用原始的WebSockets发送响应消息并不是很容易——它们不支持请求-响应循环。因此，要实现一些RPC调用，比如询问服务器名称是否可用，将会更加困难。
- en: On the other hand, the dnode protocol supports passing local callbacks to remote
    functions, which in turn can pass callbacks of their own to the callbacks received
    and so on—resulting in a very powerful, full RPC implementation. This allows us
    to extend our application to meet new demands as they arise. As a bonus, the resulting
    API is much clearer and more expressive.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，dnode协议支持将本地回调传递给远程函数，远程函数反过来可以将自己的回调传递给接收到的回调，依此类推——从而实现一个非常强大的完整RPC。这使我们能够扩展我们的应用程序，以满足新的需求。作为一个奖励，结果API更加清晰和表达力更强。
- en: 'Here is what we did to implement a chatroom with dnode:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用dnode实现聊天室的步骤：
- en: We created a simple object that uses continuation-passing style to return errors
    and values for all functions. This is our chatroom object and defines the RPC
    API for our application.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的对象，使用延续传递风格来返回所有函数的错误和值。这是我们的聊天室对象，定义了应用程序的RPC API。
- en: We defined a WebSockets server based on the `shoe` library that creates a new
    Node.js stream for every connected client. Then we installed it to the regular
    HTTP server at the `/chat` route.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个基于`shoe`库的WebSockets服务器，为每个连接的客户端创建一个新的Node.js流。然后将其安装到`/chat`路由的常规HTTP服务器上。
- en: We connected the two by piping every connected client stream to a newly created
    dnode stream based on the chatroom object.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将每个连接的客户端流传输到基于聊天室对象的新创建的dnode流来连接这两者。
- en: 'That''s all! Then, to use the API on the client, do the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！然后，在客户端使用API，做如下操作：
- en: We defined a WebSockets client based on the `shoe` library that connects to
    the HTTP server at the `/chat` route and creates a new Node.js stream when the
    connection is established.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个基于`shoe`库的WebSockets客户端，它连接到`/chat`路由的HTTP服务器，并在建立连接时创建一个新的Node.js流。
- en: We piped that stream to a newly created dnode client.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将该流传输到一个新创建的dnode客户端。
- en: After establishing a connection, the dnode client received an object containing
    the API defined in step 1—all the functions are available.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立连接后，dnode客户端接收到一个包含第1步中定义的API的对象——所有函数都可用。
- en: Note
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Find out more about dnode at [https://github.com/substack/dnode](https://github.com/substack/dnode).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/substack/dnode](https://github.com/substack/dnode)了解更多关于dnode的信息。
- en: IE versions up to IE 9 don't support the WebSockets API. As of February 2013,
    the built-in browser in the latest version of Android (v 4.2) doesn't support
    the WebSockets API either.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2013年2月，IE 9及以下版本不支持WebSockets API。最新版本的Android（v 4.2）内置浏览器也不支持WebSockets
    API。
