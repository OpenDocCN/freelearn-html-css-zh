- en: Chapter 10. Data Binding Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。数据绑定框架
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a basic Angular view with data binding
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有数据绑定的基本Angular视图
- en: Rendering lists and using Angular controllers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染列表和使用Angular控制器
- en: Routing, filters, and backend services in Angular
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的路由、过滤器和后端服务
- en: Using Angular's client-side validation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular的客户端验证
- en: Making a chart component with Angular directives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular指令制作图表组件
- en: Structuring applications for Meteor.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Meteor.js构建应用程序结构
- en: Reactive programming and data in Meteor.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meteor.js中的响应式编程和数据
- en: Live HTML and user-specific data in Meteor.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meteor.js中的实时HTML和用户特定数据
- en: Security mechanisms in Meteor.js
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meteor.js中的安全机制
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Within modern web applications, a lot of code is gradually moving from the server
    to the browser. As a result, new possibilities and challenges are emerging.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web应用程序中，很多代码逐渐从服务器移动到浏览器。因此，出现了新的可能性和挑战。
- en: One such possibility is instant automated data binding. Client-side code enables
    us to bind model objects to parts of the web page. This means that changes in
    the model are automatically and instantly reflected in the view element displaying
    that model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种可能性是即时自动数据绑定。客户端代码使我们能够将模型对象绑定到网页的部分。这意味着模型中的更改会自动且立即反映在显示该模型的视图元素中。
- en: Additionally, a challenge in code organization also emerges. JavaScript does
    not provide adequate module facilities or code organization models that are needed
    in larger browser applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，代码组织方面也出现了挑战。JavaScript没有提供足够的模块设施或代码组织模型，这在较大的浏览器应用程序中是必需的。
- en: In this chapter, we're going to cover two complete frameworks that attempt to
    provide solutions to both challenges. These frameworks support a declarative,
    data-binding approach to writing web applications. At the same time, they provide
    modularization and organization facilities, allowing us to give a clear structure
    to our code—to separate it into models, views, controllers, or view-models and
    components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖两个试图提供解决方案的完整框架。这些框架支持声明性的、数据绑定的方法来编写Web应用程序。同时，它们提供了模块化和组织设施，使我们能够为我们的代码提供清晰的结构，将其分离为模型、视图、控制器或视图模型和组件。
- en: 'The first half of the chapter will cover Angular—a framework coming from Google
    that provides client-side bindings, and can work with any server-side stack (Rails,
    Node.js, Django, and so on). It provides data binding+ and organizational facilities.
    We''ll do the following in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前半部分将涵盖Angular——这是来自Google的一个框架，提供客户端绑定，并可以与任何服务器端堆栈（Rails、Node.js、Django等）一起使用。它提供了数据绑定和组织设施。在本章中，我们将做以下工作：
- en: Create basic Angular views with data binding
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据绑定创建基本的Angular视图
- en: Use Angular controllers to write a small list editing application
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular控制器编写一个小型列表编辑应用程序
- en: Add validation to our application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序添加验证
- en: Create a simple markdown wiki using the Angular router and filters and define
    a local storage service
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular路由和过滤器创建一个简单的Markdown维基，并定义一个本地存储服务
- en: Use directives to create a component that displays a chart
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指令创建显示图表的组件
- en: 'The second half will cover Meteor—a complete framework and platform that covers
    both the client and the server side, and also provides data binding and organizational
    facilities. Meteor is more of a truly different way of building web applications,
    and we will cover some of the following basics for it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分将涵盖Meteor——一个完整的框架和平台，涵盖了客户端和服务器端，还提供了数据绑定和组织设施。Meteor更多地是一种真正不同的构建Web应用程序的方式，我们将为其基础知识进行一些介绍：
- en: Structuring your application Meteor style
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照Meteor的风格构建应用程序
- en: Basics of reactive programming, and how to work with data in Meteor
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程的基础知识，以及如何在Meteor中处理数据
- en: Live HTML and user data
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时HTML和用户数据
- en: Security and authentication
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全和认证
- en: Creating a basic Angular view with data binding
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有数据绑定的基本Angular视图
- en: Angular.js allows us to create views with automated data binding. This means
    that we can specify model objects whose properties will bind to element properties
    or content.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Angular.js允许我们创建具有自动数据绑定的视图。这意味着我们可以指定模型对象，其属性将绑定到元素属性或内容。
- en: Automated data binding simplifies programming. Instead of adding event listeners
    to watch for changes inside our elements and then manually updating elements by
    adding classes, changing attributes, or modifying their content, we can simply
    change the model objects, and the elements will get updated automatically.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 自动数据绑定简化了编程。我们不需要添加事件监听器来监视元素内部的更改，然后通过添加类、更改属性或修改它们的内容来手动更新元素，我们只需简单地更改模型对象，元素将自动更新。
- en: In this recipe, we're going to create a simple currency converter that converts
    USD to GBP using a fixed conversion rate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个简单的货币转换器，使用固定的汇率将美元转换为英镑。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Angular is available via CDN, so no downloading is necessary. We can simply
    include it to our page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Angular可以通过CDN获得，因此无需下载。我们只需将其包含到我们的页面中。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the Angular template.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写Angular模板。
- en: 'Create a file named `index.html` that contains the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的文件，其中包含以下代码：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our HTML page is not written in pure, standard HTML. There are a lot of new
    attributes added, and we're going to explain them in the following paragraphs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML页面不是用纯粹的标准HTML编写的。有很多新的属性添加进来，我们将在接下来的段落中解释它们。
- en: The `ng-app` attribute tells Angular which part of our page should be managed
    by it. In our case, it's the only `div` element on the page. We could also put
    this tag on the HTML element, in which case the entire page will be controlled
    by Angular.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-app`属性告诉Angular我们页面的哪一部分应该由它管理。在我们的情况下，这是页面上唯一的`div`元素。我们也可以将这个标签放在HTML元素上，这样整个页面将由Angular控制。'
- en: Inside the `div`, we have an input element with an `ng-model` attribute with
    the value `usdValue`. This attribute causes Angular to add a new property into
    the view's model called `usdValue`. The value of this property will automatically
    update to the value of the input field when the content changes. This property
    now becomes globally available inside the view.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`div`内部，我们有一个带有`ng-model`属性的输入元素，其值为`usdValue`。这个属性会导致Angular在视图模型中添加一个名为`usdValue`的新属性。当内容发生变化时，该属性的值将自动更新为输入字段的值。这个属性现在在视图中变为全局可用。
- en: Our `span` element contains an `ng-show` attribute with the value `usdValue`.
    This attribute will cause the `span` element to be shown only if `usdValue` has
    a non-falsy value. Examples of "falsy" values are null, empty string, undefined,
    and zero—for those values, the `span` element will be hidden.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`span`元素包含一个值为`usdValue`的`ng-show`属性。这个属性将导致`span`元素只在`usdValue`有一个非假值时显示。空值、空字符串、未定义和零是“假值”的例子，对于这些值，`span`元素将被隐藏。
- en: Finally, inside the span we have both the currency and an expression placed
    within double curly braces. As this expression depends on the value of the `usdValue`
    variable, the contents of the `span` element will be automatically updated whenever
    that value changes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`span`内部，我们既有货币，又有放置在双大括号内的表达式。由于这个表达式取决于`usdValue`变量的值，所以`span`元素的内容将在该值发生变化时自动更新。
- en: The resulting binding connects the `span` element with the input field. Whenever
    the input field is changed, the model `usdValue` variable is automatically updated.
    This in turn causes both the visibility and the content of the `span` element
    to update automatically.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结果绑定将`span`元素与输入字段连接起来。每当输入字段发生变化时，模型`usdValue`变量会自动更新。这反过来会导致`span`元素的可见性和内容自动更新。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ng` attributes are called **attribute directives** in Angular. Angular
    also allows you to write your own attribute directives.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng`属性在Angular中被称为**属性指令**。Angular还允许你编写自己的属性指令。'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ng` attributes are non-standard, and HTML validators will complain when
    encountering them. To work around this, you can prefix them with the `data` prefix.
    For example, `data-ng-model` will validate fine, as custom attributes with the
    `data` prefix are standards-compliant.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng`属性是非标准的，HTML验证器在遇到它们时会抱怨。为了解决这个问题，你可以在它们前面加上`data`前缀。例如，`data-ng-model`将会验证通过，因为带有`data`前缀的自定义属性是符合标准的。'
- en: Rendering lists and using Angular controllers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染列表和使用Angular控制器
- en: Angular allows us to interact with our view through code by letting us set a
    controller for the view. The controller can modify the view scope (the model)
    and call other operations, such as background services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Angular允许我们通过代码与视图进行交互，让我们为视图设置一个控制器。控制器可以修改视图作用域（模型）并调用其他操作，比如后台服务。
- en: In this recipe, we're going to use a controller to write a simple to-do list.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个控制器来编写一个简单的待办事项列表。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create a file named `index.html` that will display a list of tasks, the form
    to add a new task, and the button to hide all the tasks:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的文件，用于显示任务列表、添加新任务的表单和隐藏所有任务的按钮：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a file named `example.js` to define the controller for our to-do list:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example.js`的文件来定义我们待办事项列表的控制器：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we declare that the Angular app is going to be our entire page
    by setting the `ng-app` attribute to the root element of the page.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明Angular应用将成为我们整个页面，通过将`ng-app`属性设置为页面的根元素。
- en: The `div` element represents our view. This element has an `ng-controller` attribute
    that specifies the controller for the view. The controller is a function defined
    in the global scope of the window.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`div`元素代表我们的视图。这个元素有一个`ng-controller`属性，指定了视图的控制器。控制器是在窗口的全局作用域中定义的一个函数。'
- en: Inside this view, we use the `ng-repeat` directive to display our list of tasks
    inside list elements. Inside this list, there is a checkbox denoting the task
    completion state and the text of the task.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们使用`ng-repeat`指令来显示我们的任务列表。在这个列表中，有一个复选框表示任务的完成状态和任务的文本。
- en: The `tasks` variable belongs to the view's scope. We expect the variable to
    contain an array of tasks, each having a `text` description, completion status
    in the `complete` field (bound to the checkbox of the task), and a `hidden` flag.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasks`变量属于视图的作用域。我们期望这个变量包含一个任务数组，每个任务都有一个`text`描述，在`complete`字段中有完成状态（与任务的复选框绑定），以及一个`hidden`标志。'
- en: At the bottom of the page is the form used to add tasks to the list. Using the
    `ng-submit` attribute, we declare that this form should execute the `addTask()`
    function when submitted. In order to do this, we expect the scope to contain the
    `addTask()` function. The `text` field in this form is bound to the `taskToAdd`
    variable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 页面底部是用于向列表添加任务的表单。使用`ng-submit`属性，我们声明该表单在提交时应执行`addTask()`函数。为了做到这一点，我们期望作用域包含`addTask()`函数。该表单中的`text`字段绑定到`taskToAdd`变量。
- en: Finally, to hide the completed tasks, we have added a button to the page. By
    setting the value of its `ng-click` attribute to `hideCompleted()`, we tell the
    button to execute the `hideCompleted()` function when the button is clicked. For
    this, we expect that the scope of the view contains a `hideCompleted()` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了隐藏已完成的任务，我们在页面上添加了一个按钮。通过将其`ng-click`属性的值设置为`hideCompleted()`，我们告诉按钮在点击时执行`hideCompleted()`函数。为此，我们期望视图的作用域包含一个`hideCompleted()`函数。
- en: How can we attach the necessary function and some data to the view?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将必要的函数和一些数据附加到视图上？
- en: To do this, we can use our controller function defined in `example.js`. The
    controller function is invoked when the view is loaded.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以使用在`example.js`中定义的控制器函数。当视图加载时，控制器函数被调用。
- en: Inside this controller, there is no DOM manipulation code or DOM event bindings.
    Instead, what we have is a `$scope` parameter passed to the controller by Angular.
    This parameter represents the variable scope of the view. The controller simply
    attaches variables such as the `tasks` array to that scope, and the variable immediately
    becomes available to the view.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器中，没有DOM操作代码或DOM事件绑定。相反，我们有一个由Angular传递给控制器的`$scope`参数。这个参数表示视图的变量作用域。控制器只是将变量（如`tasks`数组）附加到该作用域，变量立即对视图可用。
- en: 'We also attach the `addTask()` and `hideCompleted()` functions to the scope.
    The code inside is fairly straightforward:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`addTask()`和`hideCompleted()`函数附加到作用域上。内部的代码非常简单：
- en: '`addTask` pushes a new task from the list with the content of the `taskToAdd`
    scope variable and then resets its value to an empty string. This will cause Angular
    to update the list of tasks and to reset the content of the `input` field bound
    to `taskToAdd`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addTask`从`taskToAdd`作用域变量的内容中推送一个新任务到列表中，然后将其值重置为空字符串。这将导致Angular更新任务列表并重置与`taskToAdd`绑定的`input`字段的内容。'
- en: '`hideCompleted` goes through the list of tasks and sets the `hidden` flag to
    every completed task. As a result, the `ng-show` directive automatically causes
    the tasks marked as `hidden` to be hidden from the view.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hideCompleted`遍历任务列表并为每个已完成的任务设置`hidden`标志。结果，`ng-show`指令会自动导致标记为`hidden`的任务在视图中被隐藏。'
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This example highlights the main differences when working with an automatic
    data binding framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了使用自动数据绑定框架时的主要区别。
- en: Without automated data binding, we would need to manually pass data to the template
    render function, then set up event bindings for actions. The actions would manually
    pull data from the view, do the actual model manipulation, then call the render
    function again. This is an imperative approach to templating.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没有自动数据绑定，我们需要手动将数据传递给模板渲染函数，然后为操作设置事件绑定。操作将手动从视图中提取数据，进行实际的模型操作，然后再次调用渲染函数。这是一种命令式的模板方法。
- en: With automated data binding frameworks, inside the template we specify how its
    parts are connected with the model object. Then, to update the view, we simply
    manipulate or change the model and the view updates automatically to reflect those
    changes. This is a declarative approach to templating.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动数据绑定框架，在模板中指定其部分与模型对象的连接方式。然后，要更新视图，我们只需简单地操纵或更改模型，视图会自动更新以反映这些变化。这是一种声明式的模板方法。
- en: The only downside in this recipe is that our controller must be declared in
    the global variable scope. We're going to show how to avoid this in the next recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中唯一的缺点是我们的控制器必须在全局变量作用域中声明。我们将在下一个配方中展示如何避免这种情况。
- en: Routing, filters, and backend services in Angular
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的路由、过滤器和后端服务
- en: To better utilize the browser's Back button functionality, as well as allow
    users to copy and paste links, Angular provides a router module. The router functions
    similarly to a server-side router, with the path appended in the URL after the
    hash along with query string parameters. It will redirect the user to the appropriate
    pair of controller and view.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地利用浏览器的后退按钮功能，以及允许用户复制和粘贴链接，Angular提供了一个路由器模块。路由器的功能类似于服务器端的路由器，在URL的哈希后附加路径以及查询字符串参数。它将重定向用户到适当的控制器和视图对。
- en: Additionally, to share data between views and the server, we need to define
    a module for the backend storage. We're going to use HTML5 `localStorage` instead—the
    resulting code will be very similar.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了在视图和服务器之间共享数据，我们需要为后端存储定义一个模块。我们将使用HTML5的`localStorage`——结果代码将非常相似。
- en: In this recipe, we're going to build a simple markdown-based wiki that stores
    pages in local storage. Angular also supports filters, so we're going to write
    a markdown filter module.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将构建一个简单的基于markdown的维基，它将页面存储在本地存储中。Angular还支持过滤器，因此我们将编写一个markdown过滤器模块。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write our Angular app:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的Angular应用程序：
- en: 'Create a file named `index.html` that will host the Angular application. It
    includes all the necessary scripts and sets up the `div` element that will host
    the views:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的文件，用于托管Angular应用程序。它包括所有必要的脚本，并设置将托管视图的`div`元素：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To display markdown, we''re going to need a `markdown` filter. Define the Angular
    filter inside an Angular module called `markdown`, within `markdown-filter.js`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示markdown，我们需要一个`markdown`过滤器。在名为`markdown-filter.js`的Angular模块`markdown`中定义Angular过滤器：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To store the wiki pages, we''re going to need a storage module. Define a factory
    that creates `Storage` objects inside the module called `storage` in `storage.js`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了存储维基页面，我们需要一个存储模块。在`storage.js`中定义一个工厂，用于在名为`storage`的模块内创建`Storage`对象：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s define our wiki application inside `app.js`. Besides the `storage`
    and `markdown` modules, we''re also going to use `ngSanitize` to display unsafe
    HTML. We''re going to define two routes, one for editing and another for viewing
    pages:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`app.js`中定义我们的维基应用。除了`storage`和`markdown`模块，我们还将使用`ngSanitize`来显示不安全的HTML。我们将定义两个路由，一个用于编辑，另一个用于查看页面：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s define our viewing template in `view.html`. Besides displaying the article,
    it should also provide an edit link as well as a link to return to the main page:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`view.html`中定义我们的查看模板。除了显示文章，它还应该提供一个编辑链接以及返回主页的链接：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now let's define the viewing controller inside `view-controller.js`. It should
    load the displayed article from storage.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`view-controller.js`中定义查看控制器。它应该从存储中加载显示的文章。
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the editing template inside `edit.html`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`edit.html`中添加编辑模板：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then define the editing controller inside `edit-controller.js`; it should load
    the page from `storage` and define the `savePage()` method to save a page:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`edit-controller.js`中定义编辑控制器；它应该从`storage`中加载页面，并定义`savePage()`方法来保存页面：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, let''s style things up by adding some CSS in `style.css`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过在`style.css`中添加一些CSS来为事物增添一些样式：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To run the application, run an HTTP server for the directory. Assuming you
    have Node.js installed (see [Appendix A](apa.html "Appendix A. Installing Node.js
    and Using npm"), *Installing Node.js and Using npm*), install `http-server`, and
    then run it in the `app` directory:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行应用程序，为该目录运行一个HTTP服务器。假设您已安装了Node.js（参见[附录A](apa.html "附录A. 安装Node.js和使用npm")，“安装Node.js和使用npm”），安装`http-server`，然后在`app`目录中运行它：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Point your browser to `http://localhost:8080/` to see the result.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器指向`http://localhost:8080/`以查看结果。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The previous recipe defined a simple, single-controller application and as such,
    it had no real need for routing and modularization. This recipe, on the other
    hand, implements a more complex application with multiple views and controllers,
    as well as storage and filter modules.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例定义了一个简单的单控制器应用程序，因此它没有真正需要路由和模块化。另一方面，这个示例实现了一个更复杂的应用程序，具有多个视图和控制器，以及存储和过滤器模块。
- en: Our Angular app begins in `app.js`—defined as a module called `wiki`, the same
    as the `ng-app` attribute of the `html` tag inside our `index.html` file. It contains
    the main glue code that loads our custom `markdown` and `storage` modules and
    sets up the controllers and views.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Angular应用程序始于`app.js`—定义为一个名为`wiki`的模块，与我们`index.html`文件中的`html`标签的`ng-app`属性相同。它包含了加载我们自定义的`markdown`和`storage`模块并设置控制器和视图的主要粘合代码。
- en: 'To configure our app, we load two objects: `$locationProvider` and `$routeProvider`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的应用程序，我们加载两个对象：`$locationProvider`和`$routeProvider`：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding loading syntax is the array syntax, where we define the module
    names to load as elements of the array; then we define the function taking these
    modules as arguments at the end of the array and the executing the code that uses
    them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的加载语法是数组语法，我们在数组的元素中定义要加载的模块名称；然后我们在数组的末尾定义接受这些模块作为参数的函数，并执行使用它们的代码。
- en: We use the `locationProvider` module to enable `html5mode`, where every URL
    looks as if it has been loaded as a separate page, containing no hashes. This
    mode requires the HTML5 browser history API. As a fallback, we define a prefix
    `!` to use after the hash and before the URL.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`locationProvider`模块来启用`html5mode`，在这种模式下，每个URL看起来都像是作为单独的页面加载的，不包含任何哈希。这种模式需要HTML5浏览器历史API。作为备用，我们定义了一个前缀`!`，在哈希之后和URL之前使用。
- en: To define our routes, we use `routeProvider`. We declare that any `/edit/:page`
    URL will be handled by `EditController` and displayed with the `edit.html` template.
    The `:page` part of the URL is a `URL` parameter and matches any text—it will
    be accessible in the controller. We also define a `/:page` route used to view
    pages, which is handled by `ViewController` and is using the `view.html` template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义我们的路由，我们使用`routeProvider`。我们声明任何`/edit/:page` URL将由`EditController`处理，并使用`edit.html`模板显示。URL的`:page`部分是一个`URL`参数，匹配任何文本—它将在控制器中可访问。我们还定义了一个`/:page`路由用于查看页面，由`ViewController`处理，并使用`view.html`模板。
- en: The `view` template contains a `div` element that is shown only if the page
    text is defined. The way we do this is using the `ng-bind-html-unsafe` directive.
    This directive allows us to bind an expression, which is evaluating to arbitrary
    HTML, to the element, which is exactly what we need for the `markdown` filter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`view`模板包含一个`div`元素，仅当页面文本被定义时才显示。我们使用`ng-bind-html-unsafe`指令来实现这一点。该指令允许我们将一个表达式绑定到元素，该表达式评估为任意HTML，这正是我们需要`markdown`过滤器的地方。'
- en: 'To use the filter we use the pipe character:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用过滤器，我们使用管道字符：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The editing link for the page is located at the bottom of the link, taking us
    to the editing view for this page. Similarly, on the edit page, we bind both the
    markdown text and the generated HTML to different elements. As a result, changing
    the textarea results with instant updates to the displayed HTML, giving us a live
    preview of the generated page.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的编辑链接位于页面底部，将我们带到该页面的编辑视图。同样，在编辑页面上，我们将markdown文本和生成的HTML绑定到不同的元素。结果是，更改文本区域会立即更新显示的HTML，为我们提供生成页面的实时预览。
- en: 'Both the view and the edit controllers are fairly simple: the first controller
    loads the article from storage, while the second controller defines a `save()`
    function that saves the article back to the storage.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 查看和编辑控制器都非常简单：第一个控制器从存储加载文章，而第二个控制器定义了一个`save()`函数，将文章保存回存储。
- en: 'What is new in our controllers are the extra parameters they receive:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制器中的新参数是它们接收的额外参数：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These parameters cause Angular to inject the requested objects by passing them
    as parameters to the controllers. In this case, the `Storage` object is requested
    (defined in the `storage` module) and the `$routeParams` built-in object is requested.
    The order of the parameters doesn''t matter, what matters is their names. We can
    avoid this behavior by using the array syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数导致Angular通过将它们作为控制器的参数传递来注入所请求的对象。在这种情况下，请求了`Storage`对象（在`storage`模块中定义），以及请求了内置的`$routeParams`对象。参数的顺序并不重要，重要的是它们的名称。我们可以通过使用数组语法来避免这种行为：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the preceding syntax, Angular will inject the objects in the order specified
    by the array.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述语法，Angular将按照数组中指定的顺序注入对象。
- en: Defining a filter is simple. Inside `markdown-filter.js`, we define a new module
    called `markdown`. Then we declare that the module will provide a filter called
    `markdown`. To define a filter, we define a function that constructs and returns
    the filter. The returned filter should be a function taking a single input argument
    and returning the filtered output. Our `markdown` filter simply calls `markdown.toHTML`
    on the input argument.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义过滤器很简单。在`markdown-filter.js`中，我们定义了一个名为`markdown`的新模块。然后我们声明该模块将提供一个名为`markdown`的过滤器。要定义过滤器，我们定义一个构造并返回过滤器的函数。返回的过滤器应该是一个接受单个输入参数并返回过滤输出的函数。我们的`markdown`过滤器只是在输入参数上调用`markdown.toHTML`。
- en: The `storage` object is defined in a similar way in `storage.js`. Here we define
    a new module called `storage`. In this module, we define a constructor for a `Storage`
    object, which provides the `get()` and `save()` functions. Then we can inject
    our storage in any controller by adding an argument called `Storage`. In Angular,
    these injectable objects created by factories are usually called **services**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage`对象在`storage.js`中以类似的方式定义。在这里，我们定义了一个名为`storage`的新模块。在这个模块中，我们为`Storage`对象定义了一个构造函数，提供了`get()`和`save()`函数。然后我们可以通过添加一个名为`Storage`的参数在任何控制器中注入我们的存储。在Angular中，这些由工厂创建的可注入对象通常被称为**服务**。'
- en: There's more…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using `ng-bind-html-unsafe` is not secure and may allow an attacker to write
    a page that injects arbitrary scripts that steal personal information or perform
    other actions on behalf of the user. To avoid this, the `$sanitize` service from
    the `ngSanitize` module should be used to process HTML whenever possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng-bind-html-unsafe`是不安全的，可能允许攻击者编写一个页面，注入窃取个人信息或代表用户执行其他操作的任意脚本。为了避免这种情况，应尽可能使用`ngSanitize`模块中的`$sanitize`服务来处理HTML。
- en: Using Angular's client-side validation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular的客户端验证
- en: Angular extends the new HTML5 validation attributes on its own, and allows the
    users to add error conditions to the template. With these capabilities of Angular,
    we can add custom error messages and styles to our forms.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自己扩展了新的HTML5验证属性，并允许用户向模板添加错误条件。借助Angular的这些功能，我们可以向表单添加自定义错误消息和样式。
- en: In this recipe, we're going to create a simple user registration form in Angular
    and then we'll add some validation rules to the form.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将在Angular中创建一个简单的用户注册表单，然后我们将向表单添加一些验证规则。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Create a file named `index.html` that contains the registration form and the
    validation rules:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的文件，其中包含注册表单和验证规则：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Angular adds validation support by extending the built-in HTML5 validation
    rules with newly added rules and properties. Let''s look at the ones we''re using
    inside our form:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过扩展内置的HTML5验证规则和新添加的规则和属性来添加验证支持。让我们看看我们在表单中使用的这些规则：
- en: 'Our first field is the user''s username. Besides the HTML5 `required` attribute,
    we''re also using two validation directives: `ng-minlength` and `ng-maxlength`
    to specify minimum and maximum username length.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个字段是用户的用户名。除了HTML5的`required`属性外，我们还使用了两个验证指令：`ng-minlength`和`ng-maxlength`来指定用户名的最小和最大长度。
- en: Another addition by Angular is the ability to access the current validation
    state in the template from other separate elements. The error spans display the
    validation errors. However, they're only shown if the respective validation error
    has occurred.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的另一个增强是能够从其他独立元素中访问模板中的当前验证状态。错误跨度显示验证错误。但是，只有在发生相应的验证错误时才会显示它们。
- en: 'To access the validation state, we can use the following format:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问验证状态，我们可以使用以下格式：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, to check if the `user` field in the `register` form has a `minlength`
    error, we can use the following attribute:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要检查`register`表单中的`user`字段是否有`minlength`错误，我们可以使用以下属性：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similarly, we can use a `number` input field and check if the number is within
    the specified range with the `min` and `max` attributes. The appropriate `$error`
    fields have the names `$error.min` and `$error.max` respectively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`number`输入字段，并使用`min`和`max`属性检查数字是否在指定范围内。相应的`$error`字段分别为`$error.min`和`$error.max`。
- en: For the e-mail and the URL inputs, we can use the `$error.email` and `$error.url`
    fields respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电子邮件和URL输入，我们可以分别使用`$error.email`和`$error.url`字段。
- en: 'Finally, at the end of the form, in our Submit button, we use `ng-disable`
    to disable the submission of the form if there is an error in one of the fields.
    To check for errors, we can simply use the following syntax:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在表单的末尾，在我们的提交按钮中，如果一个字段中有错误，我们使用`ng-disable`来禁用表单的提交。要检查错误，我们可以简单地使用以下语法：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our case is, it is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code will return `true` if any of the validation rules in any
    field generates an error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何字段中的任何验证规则生成错误，则上述代码将返回`true`。
- en: Making a chart component with Angular directives
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular指令制作图表组件
- en: 'Angular directives allow us to extend the HTML syntax in a very powerful way—by
    adding new attributes and elements. This allows us to create components that feel
    native: from date and time pickers to data grids, charts, and visualizations.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Angular指令允许我们以非常强大的方式扩展HTML语法，通过添加新的属性和元素。这使我们能够创建感觉本地的组件：从日期和时间选择器到数据网格、图表和可视化。
- en: Such components can then be reused without adding initialization code to our
    controllers. We simply tell the component what model it should bind to and it
    will automatically update its appearance to reflect any changes in the model.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的组件可以在不向我们的控制器添加初始化代码的情况下重复使用。我们只需告诉组件它应该绑定到哪个模型，它将自动更新其外观以反映模型中的任何更改。
- en: In this recipe, we're going to make a chart directive using Flot to draw our
    chart. In the process, we will learn about some of the many powerful features
    of Angular directives.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用Flot制作一个图表指令来绘制我们的图表。在这个过程中，我们将了解一些Angular指令的强大功能。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download Flot from [http://www.flotcharts.org/](http://www.flotcharts.org/)
    and extract the ZIP archive into our recipe directory, creating a sub-directory
    called `flot`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[http://www.flotcharts.org/](http://www.flotcharts.org/)下载Flot并将ZIP存档解压缩到我们的配方目录中，创建一个名为`flot`的子目录。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写代码。
- en: Create a file named `index.html`. It will include all the necessary scripts
    and a view that displays a chart using our `chart` directive.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的文件。它将包括所有必要的脚本和一个使用我们的`chart`指令显示图表的视图。
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To implement the controller, create a file named `controller.js`—it will set
    up the chart data and options. Additionally, it will update the chart data with
    randomly generated points every 50 milliseconds:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现控制器，创建一个名为`controller.js`的文件，它将设置图表数据和选项。此外，它将每50毫秒使用随机生成的点更新图表数据：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To create a random data generation function, create a file named `random.js`
    and add the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个随机数据生成函数，创建一个名为`random.js`的文件，并添加以下代码：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, write the `chart` directive in a file named `chart.js`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在名为`chart.js`的文件中编写`chart`指令：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This is a fairly regular Angular app with a `div` element that has a controller.
    The controller sets up a new object in the scope.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当常规的Angular应用，其中有一个带有控制器的`div`元素。控制器在作用域中设置了一个新对象。
- en: The `setInterval` call in the controller deserves a special mention. We're trying
    to modify a scope object outside of the usual functions called from the browser
    event loop by Angular.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器中的`setInterval`调用值得特别一提。我们试图在Angular的浏览器事件循环之外修改作用域对象。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The browser event loop is a programming construct that waits for and dispatches
    events. Such events include mouse and keyboard events, timeouts and intervals
    set up by `setTimeout` and `setInterval`, script loading, image loading or `xmlhttprequest`
    completion, and so on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器事件循环是一种等待和分发事件的编程构造。此类事件包括鼠标和键盘事件，由`setTimeout`和`setInterval`设置的超时和间隔，脚本加载，图像加载或`xmlhttprequest`完成等。
- en: All functions registered on the event loop by Angular are wrapped inside a scope
    application wrapper that notifies the scope that it should check itself for updates
    after execution. However, functions outside Angular, such as `setTimeout` and
    `setInterval`, don't do this wrapping, and we have to do it manually using the
    `$apply` function on the angular `$scope` object (`$scope.$apply`).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Angular注册在事件循环中的所有函数都被包装在一个作用域应用包装器中，通知作用域在执行后应检查自身更新。然而，Angular之外的函数，如`setTimeout`和`setInterval`，不会进行此包装，我们必须使用Angular
    `$scope`对象上的`$apply`函数手动进行包装（`$scope.$apply`）。
- en: 'The `chart` directive factory is defined inside the `chart` module. The factory
    creates the directive, which is an object. Let''s explain the properties of this
    object:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`chart`指令工厂定义在`chart`模块内。该工厂创建指令，这是一个对象。让我们解释一下这个对象的属性：'
- en: '`directive.restrict`: This restricts the directive to certain types. `E` means
    that the directive is restricted to elements. Additionally, three more possibilities
    are available: `A` for attributes, `C` for CSS classes, and `M` for a special
    comment form.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directive.restrict`：这将指令限制为特定类型。`E`表示指令限制为元素。此外，还有三种可能性可用：`A`表示属性，`C`表示CSS类，`M`表示特殊注释形式。'
- en: '`directive.scope`: This allows us to configure the attributes that define the
    local (isolate) scope of our directive. We can use the following different special
    characters for different kind of imports:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directive.scope`：这允许我们配置定义指令本地（隔离）范围的属性。我们可以使用不同的特殊字符来导入不同类型的内容：'
- en: The `&` character means to interpret the attribute as an expression. It allows
    us to set up arbitrary one-way bindings and watch the expression for updates.
    To get the expression value, we need to call the imported scope variable as a
    function.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&`字符表示将属性解释为表达式。它允许我们设置任意单向绑定，并监视表达式进行更新。要获取表达式的值，我们需要将导入的作用域变量作为函数调用。'
- en: The `=` character means to interpret the attribute as a variable of another
    scope. This allows us to set up two-way data bindings.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`字符表示将属性解释为另一个作用域的变量。这允许我们设置双向数据绑定。'
- en: The `@` character means to interpret the attribute as a string value. The string
    value of the attribute is returned.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@`字符表示将属性解释为字符串值。返回属性的字符串值。'
- en: '`directive.link`: This is called to link the directive with a new element.
    This is done once for every instance of the directive (in our case, every element).
    It allows us to define the code executed to render the new chart, as well as to
    set up scope watches to update the chart. It''s called with the `scope`, `element`,
    and `attribute` parameters.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directive.link`：这用于将指令与新元素链接。对于指令的每个实例（在我们的例子中是每个元素），这只会执行一次。它允许我们定义执行渲染新图表的代码，以及设置范围观察以更新图表。它使用`scope`、`element`和`attribute`参数进行调用。'
- en: In our example, the `chart` directive is restricted to elements. Because we
    don't need two-way data bindings, using `&`, we interpret both the `data` and
    the `options` attributes as expressions. This allows the use of filters and other
    operations, which is very useful and not provided by the `=` interpretation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`chart`指令被限制为元素。因为我们不需要双向数据绑定，使用`&`，我们将`data`和`options`属性都解释为表达式。这允许使用过滤器和其他操作，这非常有用，而且`=`解释不提供这个功能。
- en: Inside the `link` function, we render the initial chart. Because we interpreted
    both attributes as expressions, we need to invoke them as functions to get the
    values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`link`函数内，我们渲染初始图表。因为我们将两个属性都解释为表达式，所以需要将它们作为函数调用以获取值。
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Unlike in Angular controllers, the order of the parameters of our `link` function
    does matter and is always: `scope`, `element`, and `attributes`. This is because
    they are not processed by the Angular dependency injection system.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与Angular控制器不同，我们的`link`函数的参数顺序很重要，总是：`scope`、`element`和`attributes`。这是因为它们不是由Angular依赖注入系统处理的。
- en: Setting up watches for expressions is also done slightly differently—the watch
    string is a function call.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为表达式设置观察也略有不同——观察字符串是一个函数调用。
- en: Both `data` and `options` are complex objects whose content can be modified
    without changing the object itself. Because of this, we need to pass a third parameter
    to the `watch` function that specifies that object equality should be used when
    comparing the values of the watched expression. The default is to check the object
    reference, and it will not work for our chart.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`和`options`都是复杂对象，其内容可以在不改变对象本身的情况下进行修改。因此，我们需要向`watch`函数传递第三个参数，该参数指定在比较监视表达式的值时应使用对象相等性。默认值是检查对象引用，这对我们的图表不起作用。'
- en: When `data` or `options` are modified, we re-render our chart. Our `chart` element
    is now fully dynamic, as can be seen from the example that updates the data points
    every 50 milliseconds. Those updates immediately reflect on the chart.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当`data`或`options`被修改时，我们重新渲染我们的图表。我们的`chart`元素现在是完全动态的，可以从每50毫秒更新一次数据点的示例中看出。这些更新立即反映在图表上。
- en: There's more…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Besides the `directive.link` property, there is also `directive.compile`. It's
    only invoked once per directive, even if there are multiple instances. It allows
    us to transform a template inside our element and to include the content inside
    the directive. More properties are also available—detailed documentation can be
    found in the Angular guide on the official website at [http://angularjs.org/](http://angularjs.org/).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`directive.link`属性之外，还有`directive.compile`。即使有多个实例，它也只被调用一次。它允许我们在元素内部转换模板并在指令内部包含内容。还有更多属性可用-详细文档可以在官方网站的Angular指南中找到[http://angularjs.org/](http://angularjs.org/)。
- en: Structuring applications for Meteor.js
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Meteor.js构建应用程序的结构
- en: The first promise made by Meteor.js is that it's a faster way of building web
    applications. Most of the web frameworks that are used today have a web server
    and a database on the same rack and send rendered HTML to the browsers. They all
    use standard request and response based development.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor.js的第一个承诺是它是构建Web应用程序的更快方式。今天使用的大多数Web框架都在同一机架上拥有Web服务器和数据库，并将渲染的HTML发送到浏览器。它们都使用标准的请求和响应式开发。
- en: 'Nowadays, we also have a lot of smart clients: JavaScript-powered applications
    that run in the browser or native clients in Android or iOS. All of these are
    connected with the cloud; they all are aligned with either Google, Facebook, Twitter,
    or Amazon in one way or another.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，我们还有很多智能客户端：在浏览器中运行的JavaScript应用程序或Android或iOS中的本机客户端。所有这些都与云连接；它们都以某种方式与Google、Facebook、Twitter或Amazon对齐。
- en: Meteor provides a new way to have a code built around **Smart Packages**, code
    modules that can be executed on the client or server side or even both. Developers
    can pick the Smart Packages that they will use in their app. Meteor will create
    a bundle that is ready to be part of the cloud. In this recipe, we will construct
    a very basic Meteor application in order to see what is the Meteor's way of doing
    pretty much everything. One important thing to note about Meteor is that it is
    still work in progress, and should be treated as such.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor提供了一种围绕**智能包**构建代码的新方法，这些代码模块可以在客户端或服务器端执行，甚至两者兼而有之。开发人员可以选择他们将在应用程序中使用的智能包。Meteor将创建一个准备好成为云一部分的捆绑包。在这个示例中，我们将构建一个非常基本的Meteor应用程序，以了解Meteor的几乎所有功能。关于Meteor的一个重要事项是，它仍在不断发展中，应该作为这样对待。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: At the time of writing, the officially-supported platforms are Mac OS and GNU/Linux.
    There is a preview installation for Windows available as an MSI installer package
    at [http://win.meteor.com/](http://win.meteor.com/) where it should have the same
    functionality, but with a few more bugs and an uncomfortable shell. Official support
    for Windows is planned in the future, so that should not be a big problem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，官方支持的平台是Mac OS和GNU/Linux。有一个Windows的预览安装程序可用作MSI安装程序包，网址为[http://win.meteor.com/](http://win.meteor.com/)，它应该具有相同的功能，但有一些更多的错误和一个不舒服的shell。官方对Windows的支持计划在未来实现，所以这不应该是一个大问题。
- en: 'For Linux and Mac, installation is done using command line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux和Mac，安装是通过命令行完成的：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command will run and install Meteor to your machine, but it only works
    for Debian-and RedHat-based distribution. If your OS is not in one of these categories,
    there is no need for worries, there is probably a package for Meteor that would
    be already part of your distribution repository, but it might be a few versions
    behind.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将运行并将Meteor安装到您的计算机上，但它只适用于Debian和RedHat类别的发行版。如果您的操作系统不属于这些类别，就没有必要担心，可能已经有一个Meteor的软件包已经包含在您的发行版存储库中，但它可能会落后几个版本。
- en: Meteor is built on top of Node.js and uses it's own system for managing packages.
    By default, it also uses MongoDB as a database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor是建立在Node.js之上的，并使用它自己的系统来管理包。默认情况下，它还使用MongoDB作为数据库。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'After having Meteor installed, we can start by creating an application titled
    `simple`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了Meteor后，我们可以开始创建一个名为`simple`的应用程序：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will create a folder called `simple`, and in it we should have files called
    `simple.html`, `simple.js`, `simple.css`, and a sub folder called `.meteor`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`simple`的文件夹，在其中我们应该有名为`simple.html`、`simple.js`、`simple.css`的文件，以及一个名为`.meteor`的子文件夹。
- en: 'To start the application, just type `meteor` in the folder:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动应用程序，只需在文件夹中键入`meteor`：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before digging into the code, we will take a look at some of the ideas behind
    Meteor. The creators promote the framework with their seven principles that mostly
    live up to your expectations:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们将看一些Meteor背后的想法。创建者用他们的七大原则来推广这个框架，这些原则大多符合您的期望：
- en: Seven Principles of Meteor
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Meteor的七大原则
- en: '>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Data on the Wire. Don't send HTML over the network. Send data and let the client
    decide how to render it.
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据传输。不要通过网络发送HTML。发送数据，让客户端决定如何呈现它。
- en: '>'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: One Language. Write both the client and the server parts of your interface in
    JavaScript.
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种语言。在JavaScript中编写接口的客户端和服务器部分。
- en: '>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Database Everywhere. Use the same transparent API to access your database from
    the client or the server.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据库无处不在。使用相同的透明API从客户端或服务器访问数据库。
- en: '>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Latency Compensation. On the client, use prefetching and model simulation to
    make it look like you have a zero-latency connection to the database.
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 延迟补偿。在客户端，使用预取和模型模拟，使其看起来就像您与数据库有零延迟的连接。
- en: '>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Full Stack Reactivity. Make realtime the default. All layers, from database
    to template, should make an event-driven interface available.
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 全栈响应性。使实时成为默认。从数据库到模板的所有层都应该提供事件驱动的接口。
- en: '>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Embrace the Ecosystem. Meteor is open source and integrates, rather than replaces,
    existing open source tools and frameworks.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拥抱生态系统。Meteor是开源的，集成而不是替代现有的开源工具和框架。
- en: '>'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Simplicity Equals Productivity. The best way to make something seem simple is
    to have it actually be simple. Accomplish this through clean, classically beautiful
    APIs.
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简单等于高效。使某物看起来简单的最好方法是使其实际上变得简单。通过干净、经典美观的API来实现这一点。
- en: Some of these principles are overblown but nonetheless, Meteor is certainly
    a new way of building web applications.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些原则被夸大了，但尽管如此，Meteor肯定是构建Web应用程序的一种新方式。
- en: 'Let''s get back to the generated code and start with `simple.js`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到生成的代码，并从`simple.js`开始：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The variables `Meteor.isServer` and `Meteor.isClient` are provided so that we
    can change the behavior depending on whether the code is running on the client
    or the server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 提供`Meteor.isServer`和`Meteor.isClient`变量，以便根据代码是在客户端还是服务器上运行来更改行为。
- en: 'If we add `console.log("I''m running")` in the `server` section of `simple.js`,
    we can notice the server console reloading the server:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`simple.js`的`server`部分添加`console.log("I'm running")`，我们可以注意到服务器控制台重新加载服务器：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is basically how we create server code in Meteor, where we can choose if
    we would like to have a singe file or a whole bunch of other files. Meteor collects
    all the files we have in our project tree, with the exception for the `server`
    and `public` subdirectories. It minifies them, and they get served to each client.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们在Meteor中创建服务器代码的方式，我们可以选择是要一个单个文件还是一堆其他文件。Meteor收集我们项目树中的所有文件，除了`server`和`public`子目录。它们被最小化，并且被提供给每个客户端。
- en: Unlike Node.js' way of creating an asynchronous callback, Meteor uses a single
    thread per request, meaning that it should lead to somewhat more maintainable
    code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与Node.js创建异步回调的方式不同，Meteor使用单个线程处理每个请求，这意味着它应该会导致更易维护的代码。
- en: 'If we take a look at `simple.html`, we have a simple template that uses the
    client code that is part of `simple.js`, where the appropriate `Template.hello.events`
    event and the data in `Template.hello.greeting` are used:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`simple.html`，我们有一个简单的模板，使用了`simple.js`中的客户端代码，其中使用了适当的`Template.hello.events`事件和`Template.hello.greeting`中的数据：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We won't get into the details behind templates just yet, but this basic example
    should be straightforward. If we open up the browser on an already-started application
    on `http://localhost:3000`, we can see that the data got loaded into the template.
    When we click on the button, a `console.log("You pressed the button")` function
    is called, and the message should be displayed in the console. Note that this
    should be the console of the browser, not the server console, as that part is
    set to run on the client side.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不会深入讨论模板背后的细节，但这个基本示例应该很简单。如果我们在`http://localhost:3000`上已启动的应用程序中打开浏览器，我们可以看到数据加载到模板中。当我们点击按钮时，将调用`console.log("You
    pressed the button")`函数，并且消息应该显示在控制台中。请注意，这应该是浏览器的控制台，而不是服务器控制台，因为该部分设置为在客户端运行。
- en: The part of the code that deals with sensitive data, such as tokens or passwords
    should be only part of the server, and this can be done easily by placing that
    code in a folder named `server`. When the server is in the production mode, CSS
    files and JavaScript are served to the client, packed and bundled. While development,
    they are sent individually to make debugging simpler.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 处理敏感数据的代码部分，例如令牌或密码，应该只是服务器的一部分，这可以通过将该代码放在名为`server`的文件夹中轻松实现。在生产模式下，CSS文件和JavaScript被打包并捆绑后提供给客户端。在开发过程中，它们被单独发送以简化调试。
- en: You may have noticed that the HTML file that got served to the client is a bit
    different and larger than the one we have in our application folder. This is because
    Meteor scans the HTML files for top-level elements `<head>`, `<body>`, and `<template>`.
    The `template` sections are converted into JavaScript functions that can be called
    from the `Template.*` namespace. As for the `<head>` and `<body>` elements, they
    get joined together separately, and the additional parts, such as the DOCTYPE
    and CSS, are included for us automatically.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，向客户端提供的HTML文件与我们在应用程序文件夹中的文件有些不同且更大。这是因为Meteor扫描HTML文件以查找顶级元素`<head>`、`<body>`和`<template>`。`template`部分被转换为可以从`Template.*`命名空间调用的JavaScript函数。至于`<head>`和`<body>`元素，它们分别被连接在一起，并且自动包括了DOCTYPE和CSS等其他部分。
- en: There's more...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we need Meteor to serve some static files such as `icons`, `images`, `pdf's`,
    or, for example, `robots.txt`, we use the `public` directory for that purpose.
    The root of the application is the root of the `public` folder; for example, if
    we have a file called `meme.png`, it will be accessible via `http://localhost:3000/meme.png`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要Meteor提供一些静态文件，例如`图标`、`图片`、`pdf`文件，或者例如`robots.txt`，我们可以使用`public`目录。应用程序的根目录是`public`文件夹的根目录；例如，如果我们有一个名为`meme.png`的文件，它将可以通过`http://localhost:3000/meme.png`访问。
- en: 'The following is a simple directory structure:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的目录结构：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Reactive programming and data in Meteor.js
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Meteor.js中的响应式编程和数据
- en: Meteor uses NoSQL document-oriented storage and it comes by default with Mongo
    DB. The name comes form the word "humongous", meaning extremely large. The database
    is part of a NoSQL database family, meaning, it does not store the data as traditional
    relational databases. Mongo DB persists the date in a JSON-like document format,
    making the integration with JavaScript-based frameworks a lot easier. In this
    recipe, we are going to see how to use the database from Meteor, and how data
    access is orchestrated.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor使用NoSQL文档导向存储，默认使用Mongo DB。名称来自单词"humongous"，意思是非常大。该数据库是NoSQL数据库家族的一部分，这意味着它不像传统关系数据库那样存储数据。Mongo
    DB以类似JSON的文档格式持久化数据，使得与基于JavaScript的框架集成变得更加容易。在这个示例中，我们将看到如何从Meteor中使用数据库，以及数据访问是如何被编排的。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is an `icon.png` image in the example files; besides that, only Meteor
    is needed to be installed on your machine and to have an open command line.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例文件中有一个`icon.png`图像；除此之外，只需要在您的计算机上安装Meteor并打开命令行。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First we can start by creating the application named `movies` from the command
    line:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以从命令行开始创建名为`movies`的应用程序：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To simplify the generated structure, we will create two folders: one called
    `server` and another called `client`. The `movies.css`, `movies.js`, and `movies.html`
    files can be placed in the `client` directory, as we will putting client-related
    code there.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化生成的结构，我们将创建两个文件夹：一个名为`server`，另一个名为`client`。`movies.css`、`movies.js`和`movies.html`文件可以放在`client`目录中，因为我们将在那里放置与客户端相关的代码。
- en: 'In the `server` directory, we create a file called `bootstrap.js` that will
    initialize the database with the few objects that we will define:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server`目录中，我们创建一个名为`bootstrap.js`的文件，它将使用我们定义的少量对象来初始化数据库：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first thing you might be wondering is, what is this `Movies` object? It
    is a collection that we will define in a different file that can be called `publish.js`,
    as in it we are going to publish the collection from the server. This file will
    include the following:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会想知道的第一件事是，这个`Movies`对象是什么？这是一个我们将在不同文件中定义的集合，可以称为`publish.js`，因为我们将从服务器上发布该集合。该文件将包括以下内容：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As for the client side, we have the generated files, so we start creating a
    simple HTML and a handlebar template to go with it. Inside the template, we will
    just iterate over Movies and print out a list of elements with the movie name
    and score. Additionally, in the template, we place button that will contain reference
    to an image:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于客户端，我们已经生成了文件，所以我们开始创建一个简单的HTML和一个handlebar模板。在模板内部，我们将遍历电影并打印出一个包含电影名称和评分的元素列表。此外，在模板中，我们放置一个包含对图像的引用的按钮：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In order to make the `icon.png` image available as a static file, we need to
    create a folder named `public` and place the image there. This follows the principle
    of *convention over configuration*, and there is no real need why you should not
    follow it, at least most of the time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`icon.png`图像作为静态文件可用，我们需要创建一个名为`public`的文件夹，并将图像放在其中。这遵循*约定优于配置*的原则，大多数情况下，你没有真正需要不遵循它。
- en: 'As for the client side, in the previously generated `movies.js` file, we should
    automatically subscribe to the `servers` collection of movies. Also, we will add
    a functionality to fill the `movies` variable and add an event also for the button
    that will trigger a save of a random new movie:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于客户端，在之前生成的`movies.js`文件中，我们应该自动订阅电影的`servers`集合。此外，我们将添加一个功能来填充`movies`变量，并为按钮添加一个事件，该事件将触发保存一个随机的新电影：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now everything should be working. After starting the application with `meteor`,
    we can access it in the browser on the default port `http://localhost:3000/`.
    If we want to change the port on which the application runs, for example on port
    `3333`, we can use the following command:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一切应该都正常工作了。在使用`meteor`启动应用程序后，我们可以在默认端口`http://localhost:3000/`上在浏览器中访问它。如果我们想要更改应用程序运行的端口，例如在端口`3333`上，我们可以使用以下命令：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can first start with the data, if we have the server running, we can open
    up another console, where we can access the same directory. Then, after opening
    the same folder in the console, we run the following command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以从数据开始，如果服务器正在运行，我们可以打开另一个控制台，在那里我们可以访问相同的目录。然后，在控制台中打开相同的文件夹后，我们运行以下命令：
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That opens up a simple console on which we can query our database. Mongo stores
    the data as collections, and in order to get the names of all of our available
    movies, we can use the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这打开了一个简单的控制台，我们可以在其中查询我们的数据库。Mongo将数据存储为集合，为了获取所有可用电影的名称，我们可以使用以下命令：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `movies` collection is the one we defined in our `bootstrap.js` initialization;
    as for `system.indexes`, it is a collection contains all the indexes of the database.
    To manipulate data with this collection, we can use `ensureIndex()` and `dropIndex()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`movies`集合是我们在`bootstrap.js`初始化中定义的集合；至于`system.indexes`，它是一个包含数据库所有索引的集合。要使用该集合操作数据，我们可以使用`ensureIndex()`和`dropIndex()`。'
- en: 'In the console, we can assign the following variables:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，我们可以分配以下变量：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Collections can be queried with `find()`; if we try to call it without arguments,
    it returns all the elements:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`find()`查询集合；如果我们尝试在没有参数的情况下调用它，它将返回所有元素：
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The data is basic JSON, making it easy to manipulate with JavaScript. If you
    take a look at the objects, you can notice the `"_id" : "08633d22-aa0b-454f-a6d8-aa2aaad2fbb1"`
    key-value pair. This is a unique key generated by Mongo and we use it to reference
    and manipulate that object, commonly referred to as **document**.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '数据是基本的JSON，易于使用JavaScript进行操作。如果你看一下对象，你会注意到`"_id" : "08633d22-aa0b-454f-a6d8-aa2aaad2fbb1"`键值对。这是由Mongo生成的唯一键，我们用它来引用和操作该对象，通常称为**文档**。'
- en: 'If we wanted to delete the record with an ID of `beef20a3-c66d-474b-af32-aa3e6503f0de`,
    we can use the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想删除ID为`beef20a3-c66d-474b-af32-aa3e6503f0de`的记录，我们可以使用以下命令：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After that, we can call `db.movies.find()` to see to notice that one is now
    missing. There are plenty of other commands used for data manipulation, but most
    of them are intuitive, and you can easily guess by their names. As a quick reminder
    and a learning tool, there is a `help` function that can be called:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以调用`db.movies.find()`来查看一个现在缺失了。还有很多其他用于数据操作的命令，但大多数都很直观，你可以根据它们的名称轻松猜到。作为一个快速提醒和学习工具，有一个可以调用的`help`函数：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These two bring up a list of commands and a short explanation of what each does.
    You should not get overwhelmed by the number of commands, as we will not use most
    of them, but it still makes a good reference.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令会列出命令列表，并简要解释每个命令的作用。你不应该被命令的数量所压倒，因为我们不会使用大部分命令，但它仍然是一个很好的参考。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more detailed tutorial on MongoDB commands, visit [http://mongodb.org](http://mongodb.org)
    and click on **TRY IT OUT** to try the online shell. There are tones of resources
    for NoSQL on the Web, but one great introduction done by *Martin Flower* is available
    at [http://www.youtube.com/watch?v=qI_g07C_Q5I](http://www.youtube.com/watch?v=qI_g07C_Q5I).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MongoDB命令的更详细的教程，请访问[http://mongodb.org](http://mongodb.org)并单击**TRY IT OUT**以尝试在线shell。网络上有大量关于NoSQL的资源，但*Martin
    Flower*做的一个很好的介绍可以在[http://www.youtube.com/watch?v=qI_g07C_Q5I](http://www.youtube.com/watch?v=qI_g07C_Q5I)上找到。
- en: If we open a browser, we may notice that on every click on the Random button,
    a new record is added instantly. This looks extremely fast and it is not just
    because the server is running locally. Every time a client issues a write to the
    server, it instantly updates the local cache without response from the server
    if the write went successful. When the server receives the request and accepts
    the update, then the client does not have to do anything on the screen. This should
    happen most of the time and it saves the round trip waiting time, making the screen
    more responsive. On the other hand, if the server rejects the update, the client's
    cache gets updated with the correct result.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开浏览器，我们可能会注意到每次点击“随机”按钮时，都会立即添加一条新记录。这看起来非常快，不仅仅是因为服务器在本地运行。每当客户端向服务器发出写入请求时，它会立即更新本地缓存，而无需等待服务器的响应。当服务器接收到请求并接受更新时，客户端在屏幕上不需要做任何事情。这应该是大多数情况下发生的，它节省了往返等待时间，使屏幕更具响应性。另一方面，如果服务器拒绝更新，客户端的缓存将被更新为正确的结果。
- en: In Meteor, the same API is used for the client and the server in order to access
    the database. Emphasis is given to reducing the time for round trips to the server
    for every design decision in the framework. Requests and responses, as well as
    message invalidation, are orchestrated to do this.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在Meteor中，为了访问数据库，客户端和服务器使用相同的API。在框架的每个设计决策中，都强调减少往返服务器的时间。请求和响应以及消息失效都被编排为这样做。
- en: 'We used `autorun` to automatically get updates from the server in our `movies.js`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`movies.js`中使用`autorun`自动从服务器获取更新：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The block of code in the `autorun` function is a so-called **reactive context**,
    enabling us to write code in an imperative style, but get a reactive behavior.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`autorun`函数中的代码块是所谓的**响应上下文**，使我们能够以命令式风格编写代码，但获得响应式行为。'
- en: '**Reactive programming** is one of the programming paradigms that are oriented
    around propagation of change. In imperative programming, if we have an expression
    such as `z = x + y`, this means that the result of the evaluation of `x + y` will
    be assigned to `z` as expected. For example, if we have `x = 42` and `y = 13`,
    then `z = 42 + 13` or `z = 55`. The values of `x` and `y` can be changed later,
    for example, they can be changed to `x=4` and `y=4`, but this will not affect
    `z` in any way, it will still be `55`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式编程**是围绕变化传播的编程范式之一。在命令式编程中，如果我们有一个表达式，比如`z = x + y`，这意味着`x + y`的计算结果将被分配给`z`，如预期的那样。例如，如果我们有`x
    = 42`和`y = 13`，那么`z = 42 + 13`或`z = 55`。`x`和`y`的值以后可以更改，例如，它们可以更改为`x=4`和`y=4`，但这不会以任何方式影响`z`，它仍然是`55`。'
- en: The simplest example for this is a modern spreadsheet program, such as Microsoft
    Excel or Google docs spreadsheet. Spreadsheet cells commonly contain literal values
    such as number for example, or can contain formulas that have derived values from
    some other cells. In our cell `C3` we could have the formula `"=A1+B1"` meaning
    when we change some of the values in `A1` or `B1`, `C3` will get autoupdated.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的最简单的例子是现代的电子表格程序，比如Microsoft Excel或Google文档电子表格。电子表格单元格通常包含文字值，例如数字，或者包含从其他单元格派生值的公式。在我们的单元格`C3`中，我们可以有公式`"=A1+B1"`，这意味着当我们更改`A1`或`B1`中的一些值时，`C3`将自动更新。
- en: In MVC architecture, a simplification can be made using reactive programming,
    where we automatically propagate the changes from the view towards the model and
    back that can be very beneficial in real-time systems.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC架构中，可以使用响应式编程进行简化，从视图自动传播变化到模型，然后返回，这在实时系统中非常有益。
- en: The use of reactive contexts saves us from writing a whole class of calls. In
    our example, we would first need to unsubscribe when something has changed and
    then again resubscribe to get the data back from the server. This reduces a substantial
    amount of code that could end up being error-prone and add more complexity in
    the maintenance phase.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应上下文可以避免我们编写一整套调用。在我们的例子中，我们首先需要取消订阅当有变化发生，然后再次订阅以从服务器获取数据。这减少了大量可能会出现错误的代码，并增加了维护阶段的复杂性。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Besides `Meteor.autorun`, reactive context is applied in `Templates` and in
    the `Meteor.render` and `Meteor.renderList` functions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Meteor.autorun`，响应上下文还应用于`Templates`以及`Meteor.render`和`Meteor.renderList`函数。
- en: As for the data sources that can trigger changes, we can use database `collections`
    and `session` variables, and a few other functions related to authentication and
    authorization. You can find more details about it in the documentation of Meteor
    about reactivity at [http://docs.meteor.com/#reactivity](http://docs.meteor.com/#reactivity).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 至于可以触发更改的数据源，我们可以使用数据库 `collections` 和 `session` 变量，以及与身份验证和授权相关的一些其他函数。您可以在
    Meteor 关于响应性的文档中找到更多详细信息 [http://docs.meteor.com/#reactivity](http://docs.meteor.com/#reactivity)。
- en: If you open up two different browsers side by side, you may notice that the
    same data is shown even if the sessions are different. In order to have user-specific
    data, we will create an example in the next recipe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您同时打开两个不同的浏览器，您可能会注意到即使会话不同，也会显示相同的数据。为了拥有特定于用户的数据，我们将在下一个示例中创建一个示例。
- en: You might wish to send the entire collection to the client, but first think
    thoroughly if that is what the client actually needs. Often, it might be a lot
    wiser to send only certain fields rather than entire documents. In order to lower
    the network traffic, certain parts of the client can have subscription turned
    off and the documents for those parts will be removed from the local cache unless
    used in other active subscription.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将整个集合发送到客户端，但首先要仔细考虑客户端实际需要的是什么。通常，只发送特定字段而不是整个文档可能更明智。为了降低网络流量，客户端的某些部分可以关闭订阅，对于这些部分的文档将从本地缓存中删除，除非在其他活动订阅中使用。
- en: There's more...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Because the data we used is stored in the database, if we changed the data there
    using some external application, it will also trigger changes to the client. In
    the next recipe, we will see how we can allow multiple users to have their own
    favorite list for each of them instead of a single global list.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用的数据存储在数据库中，如果我们使用某些外部应用程序更改了那里的数据，它也会触发对客户端的更改。在下一个示例中，我们将看到如何允许多个用户为每个用户拥有自己的收藏列表，而不是一个单一的全局列表。
- en: Live HTML and user-specific data in Meteor.js
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Meteor.js 中的实时 HTML 和特定于用户的数据
- en: You may have noticed in the previous recipe that the data we used was global
    and not user-specific. In this recipe, we will see how we can create session data
    and take a deeper look into the templates as well as the data associated with
    them. In order to demonstrate this, we will create a small image-voting application,
    where the user will be prompted for the name, and after that they are given 50
    points that they can spend for votes on the images.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在上一个示例中，我们使用的数据是全局的，而不是特定于用户的。在这个示例中，我们将看到如何创建会话数据，并深入研究模板以及与其关联的数据。为了演示这一点，我们将创建一个小型的图像投票应用程序，用户将被提示输入名称，然后他们将获得50点，可以用于对图像进行投票。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make the recipe simpler, we will serve the images statically from our `public`
    directory so you can download the sample images that are part of the example code
    or use your own ones.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例更简单，我们将从我们的 `public` 目录静态提供图像，这样您就可以下载示例代码中的样本图像，或者使用您自己的图像。
- en: How to do it...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start as any other normal Meteor application:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像任何其他普通的 Meteor 应用程序一样开始：
- en: '[PRE46]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because we will use a little bit more code in this recipe, it makes sense to
    create a structure with a `public` folder for the static files, and the `server`
    and `client` folders for the server and client code respectively. After that,
    we can move the generated gallery files to the `client` folder and add the images
    to the `public` folder. The images, for simplicity, will be named `1.jpg`, `2.jpg`,
    `3.jpg`, and guess what, `4.jpg`. Then we proceed with creating a `bootstrap.js`
    file in the `server` folder:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为在这个示例中我们将使用更多的代码，所以创建一个带有 `public` 文件夹用于静态文件，以及 `server` 和 `client` 文件夹用于服务器和客户端代码是有意义的。之后，我们可以将生成的画廊文件移动到
    `client` 文件夹，并将图像添加到 `public` 文件夹中。为了简单起见，图像将被命名为 `1.jpg`、`2.jpg`、`3.jpg`，以及猜猜看，`4.jpg`。然后我们继续在
    `server` 文件夹中创建一个 `bootstrap.js` 文件：
- en: '[PRE47]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will initialize the database with a simple user and add some data about
    the images, as well as add a condition that this should happen only when there
    are less than four images in the database.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将使用一个简单的用户初始化数据库，并添加一些关于图像的数据，还添加一个条件，只有在数据库中少于四张图像时才会发生这种情况。
- en: Note
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may notice that we are using a `for` loop to insert the data, but since
    Version 2.2 of MongoDB, the `db.collection.insert()` function can accept an array
    of elements and do a bulk insert of them into the collection, but we are not using
    the method like that, as it will result in a slightly more complex structure,
    and we want to go with the simplest case. You can read more about the `db.collecton.insert()`
    on [http://docs.mongodb.org/manual/reference/method/db.collection.insert/](http://docs.mongodb.org/manual/reference/method/db.collection.insert/).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们使用 `for` 循环来插入数据，但自 MongoDB 2.2 版本以来，`db.collection.insert()` 函数可以接受一个元素数组，并将它们批量插入到集合中，但我们没有使用这种方法，因为它会导致稍微复杂的结构，我们希望选择最简单的情况。您可以在
    [http://docs.mongodb.org/manual/reference/method/db.collection.insert/](http://docs.mongodb.org/manual/reference/method/db.collection.insert/)
    上阅读更多关于 `db.collecton.insert()` 的信息。
- en: 'After this, we can proceed with the definition and the publishing of the collections,
    making the collections available to the client side:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以继续定义和发布集合，使集合在客户端可用：
- en: '[PRE48]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can continue with the template code in `gallery.html`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以继续在 `gallery.html` 中编写模板代码：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `main` template will check whether there is a user currently present. If
    present, it will display the voting, otherwise, it will display a simple form
    to enter a name:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 模板将检查当前是否有用户。如果有，它将显示投票，否则，它将显示一个简单的表单以输入名称：'
- en: '[PRE50]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `votes` template will show how many votes are there left for the user,
    and the gallery will display the images together with the info about current number
    of votes, as well as add a button that will be used for voting:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`votes` 模板将显示用户剩余的投票数，画廊将显示图像以及当前投票数的信息，还会添加一个用于投票的按钮：'
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can start up the application and see if everything turned up as expected.
    If you open up the application on two browser sessions side by side, and enter
    two different names, you can notice that when we vote on the images, the number
    of votes gets updated instantly on the other browser session.![How to do it...](img/9282OT_10_01.jpg)
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以启动应用程序，看看是否一切都如预期那样。如果您在两个浏览器会话中同时打开应用程序，并输入两个不同的名称，您会注意到当我们对图像进行投票时，另一个浏览器会话上的投票数会立即更新。![如何做...](img/9282OT_10_01.jpg)
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing you might want to see is what is the state in the database.
    While having the server up, you can start the `meteor mongo` console and list
    the collections with `db.getCollectionNames()`, where you should have the following
    result:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要看的第一件事是数据库中的状态。在服务器启动的同时，您可以启动`meteor mongo`控制台，并使用`db.getCollectionNames()`列出集合，您应该会得到以下结果：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The collection names are the ones we defined in our `publish.js` file. As for
    the data contained in the database, we decided on having URL to the images in
    the `public` folder for the image collection, because that is simpler for this
    case.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 集合名称是我们在`publish.js`文件中定义的。至于数据库中包含的数据，我们决定在图像集合中使用`public`文件夹中的图像的URL，因为这对于这种情况更简单。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you need to store or manipulate binary data such as images, you can do that
    in MongoDB, and it plays very well with Meteor. There we can use EJSON, where
    the E stands for extended. Basically, it supports all JSON types while adding
    additional Data via the JavaScript `Date()` object and Binary data via `Uint8Array`.
    You can also define your own custom datatypes and use the EJSON object similarly
    to the regulator JSON. There are a few other methods such as `EJSON.newBinary(size)`
    and `EJSON.addType(name,factory)`, and you can read more about them on [http://docs.meteor.com/#ejson](http://docs.meteor.com/#ejson).
    There is also the option to configure your own already existing MongoDB instance.
    This is done by defining an environment variable before starting meteor:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要存储或操作诸如图像之类的二进制数据，您可以在MongoDB中进行操作，并且它与Meteor非常兼容。在那里，我们可以使用EJSON，其中E代表扩展。基本上，它支持所有JSON类型，同时通过JavaScript的`Date()`对象和`Uint8Array`添加额外的数据。您还可以定义自己的自定义数据类型，并类似于常规JSON使用EJSON对象。还有一些其他方法，如`EJSON.newBinary(size)`和`EJSON.addType(name,factory)`，您可以在[http://docs.meteor.com/#ejson](http://docs.meteor.com/#ejson)上阅读更多关于它们的信息。还有配置自己已经存在的MongoDB实例的选项。这是在启动meteor之前定义一个环境变量来完成的：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This makes it convenient to have a same MongoDB server that is used by non-Meteor
    applications.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以方便地拥有一个非Meteor应用程序使用的相同的MongoDB服务器。
- en: In the `gallery.js` file, in order to have some data in the client side, we
    used `Session` variables. This is actuality a global object that can be used on
    the client side to store any key-value pairs. Just like you are used to in other
    frameworks and languages, we have `Session.set("theKey", someValue)` that stores
    `someValue` for `theKey` and `Session.get("theKey")` is used to retrieve the data.
    As for initialization, there is the `Session.setDefault("theKey", initalValue)`,
    making it handy to avoid reinitialization of the variable every time a new version
    of your application is loaded.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gallery.js`文件中，为了在客户端有一些数据，我们使用了`Session`变量。这实际上是一个全局对象，可以在客户端上用来存储任何键值对。就像你在其他框架和语言中习惯的那样，我们有`Session.set("theKey",
    someValue)`来存储`theKey`的`someValue`，并且使用`Session.get("theKey")`来检索数据。至于初始化，有`Session.setDefault("theKey",
    initalValue)`，这样可以方便地避免在加载应用程序的新版本时重新初始化变量。
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the Session object in the Meteor specification at [http://docs.meteor.com/#session](http://docs.meteor.com/#session).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Meteor规范的[http://docs.meteor.com/#session](http://docs.meteor.com/#session)中阅读更多关于Session对象的信息。
- en: 'As you have probably noticed so far, we can nest templates. This is a standard
    handlebar behavior, and in our case, we use it to simplify the view logic. In
    the real-life scenario, it not only makes more sense to separate only the parts
    that can be reused in some other sections of the application, but also at the
    same time, you don''t want to have huge templates that make your code hard to
    read. In order to have events, we can use standard CSS selectors to add them to
    our template, so if we want to attach a callback on the `click` event of an element
    using the `.name` CSS class in the `main` template, we can use the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的那样，我们可以嵌套模板。这是标准的handlebar行为，在我们的情况下，我们使用它来简化视图逻辑。在现实生活中，不仅将只能在应用程序的其他部分中重用的部分分开是更有意义的，而且同时，你也不希望有使你的代码难以阅读的庞大模板。为了有事件，我们可以使用标准的CSS选择器将它们添加到我们的模板中，因此，如果我们想要在`main`模板中使用`.name`
    CSS类的元素的`click`事件上附加一个回调，我们可以使用以下代码：
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the event callback, we can access several objects that are of use to us.
    We used some of them in `Template.gallery.events`, where `onclick` callback accepts
    two arguments; we can see that in this object, and we have access to the related
    document. Having the data context of where the element was triggered allows easy
    manipulation of that section:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件回调中，我们可以访问一些对我们有用的对象。我们在`Template.gallery.events`中使用了其中一些，在`onclick`回调中接受两个参数；我们可以在这个对象中看到这一点，并且我们可以访问相关的文档。具有触发元素的数据上下文允许轻松地操纵该部分：
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The two arguments that are passed in the callback allow access to the event
    type as well as the `DOMElement` of the current target.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给回调的两个参数允许访问事件类型以及当前目标的`DOMElement`。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More about how event maps and selectors are used as well as what else is accessible
    in the event callback can be found at [http://docs.meteor.com/#eventmaps](http://docs.meteor.com/#eventmaps).
    You can also attach callbacks that would be called after the template is rendered,
    [http://docs.meteor.com/#template_rendered](http://docs.meteor.com/#template_rendered).
    There is also an option to use other template engines instead of handlebars, such
    as Jade, for example, [http://docs.meteor.com/#templates](http://docs.meteor.com/#templates).
    This can be done as the reactive context for the templates is not dependent on
    the engine; you can even construct the HTML manually by appending string and it
    will still work.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有关事件映射和选择器的更多信息，以及事件回调中可访问的其他内容，可以在[http://docs.meteor.com/#eventmaps](http://docs.meteor.com/#eventmaps)找到。您还可以附加在模板呈现后调用的回调，[http://docs.meteor.com/#template_rendered](http://docs.meteor.com/#template_rendered)。还有一个选项可以使用其他模板引擎，而不是handlebars，例如Jade，[http://docs.meteor.com/#templates](http://docs.meteor.com/#templates)。这可以做到，因为模板的响应上下文不依赖于引擎；甚至可以通过附加字符串手动构建HTML，它仍然可以工作。
- en: In the `main` template besides `Users.insert`, we used the `db.collection.findOne`
    function that returns the first object that is found. This is done by matching
    the query that we specify with the database and retrieving the first result in
    natural order if found.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`模板中，除了`Users.insert`，我们还使用了`db.collection.findOne`函数，该函数返回找到的第一个对象。这是通过将我们指定的查询与数据库匹配，并在自然顺序中检索找到的第一个结果来完成的。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More detailed explanation of `findOne` is available in the MongoDB documentation
    at [http://docs.mongodb.org/manual/reference/method/db.collection.findOne/](http://docs.mongodb.org/manual/reference/method/db.collection.findOne/).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`findOne`的更详细解释，请参阅MongoDB文档[http://docs.mongodb.org/manual/reference/method/db.collection.findOne/](http://docs.mongodb.org/manual/reference/method/db.collection.findOne/)。
- en: 'As for the update of the elements, the collection accepts two arguments, first
    being the selection query where, for example in `voteForImage`, we used the MongoDB-generated
    `_id` for matching the element, and the second is the new update using the `$set`
    modifier to update the `pointsLeft` property of the selected documents:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 至于元素的更新，集合接受两个参数，第一个是选择查询，例如在`voteForImage`中，我们使用了MongoDB生成的`_id`来匹配元素，第二个是使用`$set`修饰符更新所选文档的`pointsLeft`属性：
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are several different update modifiers that can be used, and you can read
    about them in great detail in the documentation, but to get you up to speed with
    the basics,, you can use some of the reference cards provided by 10gen, the company
    behind MongoDB. More details can be found at [http://www.10gen.com/reference](http://www.10gen.com/reference).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的更新修饰符可以使用，您可以在文档中详细了解它们，但为了让您快速掌握基础知识，您可以使用10gen提供的一些参考卡。更多细节可以在[http://www.10gen.com/reference](http://www.10gen.com/reference)找到。
- en: In our case, we could have used the `$inc` modifier that increments the value
    we want for a given amount, but for simplicity, we picked the more general `$set`
    modifier. Also, one other additional improvement that can be done is to move the
    collection declarations, such as `Images = new Meteor.Collection('images')`, into
    a common file for the server and the client that is not in the respective folders
    so that we can reduce the code duplication.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以使用`$inc`修饰符来增加给定数量的值，但为了简单起见，我们选择了更通用的`$set`修饰符。另外，可以进行的另一个额外改进是将集合声明（例如`Images
    = new Meteor.Collection('images')`）移动到一个通用文件中，用于服务器和客户端，而不是在各自的文件夹中，以减少代码重复。
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: At some point of time, you may want to have some kind of timer based on the
    standard JavaScript `setTimeout` or `setInterval` functions. You will get an error
    if you try to do so, but the same functionality is provided by `Meteor.setTimeout`
    and `Meteor.setInterval` functions ([http://docs.meteor.com/#timers](http://docs.meteor.com/#timers)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时间点，您可能希望基于标准JavaScript的`setTimeout`或`setInterval`函数进行一些定时器。如果您尝试这样做，将会收到错误提示，但`Meteor.setTimeout`和`Meteor.setInterval`函数提供了相同的功能([http://docs.meteor.com/#timers](http://docs.meteor.com/#timers))。
- en: When it comes to the view, you may have seen so far that it is entirely handled
    with JavaScript. This is one of the problems with Meteor, because the content
    generated like this is hard to get indexed by search engines such as Google. In
    order to help you out with this problem, there is a package called **spiderable**
    ([http://docs.meteor.com/#spiderable](http://docs.meteor.com/#spiderable)) that
    can be used as a temporary fix.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到视图时，到目前为止，您可能已经看到它完全由JavaScript处理。这是Meteor的一个问题，因为像这样生成的内容很难被搜索引擎（如Google）索引。为了帮助您解决这个问题，有一个名为**spiderable**的包([http://docs.meteor.com/#spiderable](http://docs.meteor.com/#spiderable))，可以用作临时修复。
- en: Security mechanisms in Meteor.js
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Meteor.js中的安全机制
- en: 'There has been a lot of controversy around the security in Meteor. Database
    everywhere does not scream security. We are using the same API for the client-
    and server-side code, and it does not take a genius to tell that we can also delete
    collections. After playing around for a while with the JavaScript console, we
    could easily delete all the `Users` in our previous example. You can always roll
    your own implementation for the security; for example, you can override the default
    server method handlers, making the `Users` and `Images` collections accessible
    from the client:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor的安全性一直存在很多争议。到处都是数据库并不代表安全。我们在客户端和服务器端代码中使用相同的API，毫无疑问，我们也可以删除集合。在JavaScript控制台玩耍一段时间后，我们很容易删除我们之前示例中的所有`Users`。您可以随时为安全性编写自己的实现；例如，您可以覆盖默认的服务器方法处理程序，使`Users`和`Images`集合可以从客户端访问：
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this recipe, we will take a look at what is the Meteor's way of securing
    the applications, and some of the mechanisms for authentication and authorization.
    To do this, we will create a simple list-entering application.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看一下Meteor保护应用程序的方式，以及身份验证和授权的一些机制。为此，我们将创建一个简单的列表输入应用程序。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: There are no special preparations required for this recipe; you only need command
    line and an installed version of Meteor.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，不需要特殊的准备工作；你只需要命令行和安装了Meteor的版本。
- en: How to do it...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started with it.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create an application named `secure` using `meteor create secure`. In the generated
    `secure.html` file, we will define a small template that will contain an input
    element, a button, and a list of already available list entries:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`secure`的应用程序，使用`meteor create secure`。在生成的`secure.html`文件中，我们将定义一个小模板，其中包含一个输入元素、一个按钮和一个已有列表条目的列表：
- en: '[PRE58]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The accompanied code in `secure.js` will initialize one element of the list
    and add the date for the rendering of the templates:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`secure.js`中的附带代码将初始化列表的一个元素，并添加模板的渲染日期：'
- en: '[PRE59]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Start the application and play around with it to check if it is working. If
    you open up the browser''s console at this point, we can directly access `Notes.remove()`,
    and this is one of the things that we usually want to forbid. We can remove one
    of the default smart packages that is part of the generated application with the
    following command:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试一下，看看它是否工作。如果此时打开浏览器的控制台，我们可以直接访问`Notes.remove()`，这通常是我们想要禁止的事情之一。我们可以使用以下命令删除生成的应用程序中的一个默认智能软件包：
- en: '[PRE60]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The same thing can be achieved by manually editing `.meteor/packages`. This
    will make our application "secure", even too much secure, if there is such a thing.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手动编辑`.meteor/packages`也可以实现同样的效果。这将使我们的应用程序变得“安全”，甚至过于安全，如果这样的话。
- en: 'Now if we try to toy with the browser''s console, we''ll get the following
    message:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试在浏览器的控制台中玩耍，我们会得到以下消息：
- en: '[PRE61]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The same message appears if we just click on the **Add** button that previously
    worked. This is because all the requests to the DB are now treated as anonymous,
    and we only get what is published from the server.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是点击之前有效的**添加**按钮，将会出现相同的消息。这是因为现在所有对数据库的请求都被视为匿名的，我们只能得到服务器发布的内容。
- en: 'We can always roll our own authentication, but there is a great one built in;
    to add it in our project, we can use the following code:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们总是可以自己编写身份验证，但内置的身份验证非常好；要将其添加到我们的项目中，我们可以使用以下代码：
- en: '[PRE62]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As previously mentioned, we can add these packages directly in our `packages`
    file; it is a good idea to check often what you have there in the example applications
    you try out so that you won't be surprised.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们可以直接在`packages`文件中添加这些软件包；最好经常检查一下你在尝试的示例应用程序中有什么，这样你就不会感到惊讶。
- en: Note
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A variety of packages and third-party libraries extend the core Meteor functionality.
    There are packages for D3, underscore, backbone, and plenty more added each day.
    Those and some basic supporting logic can be found at [http://docs.meteor.com/#packages](http://docs.meteor.com/#packages).
    There is also a way to create your own extension and common logic for your applications.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 各种软件包和第三方库扩展了核心Meteor功能。有用于D3、underscore、backbone等的软件包，每天都会添加更多。这些以及一些基本的支持逻辑可以在[http://docs.meteor.com/#packages](http://docs.meteor.com/#packages)找到。还有一种方法可以为您的应用程序创建自己的扩展和通用逻辑。
- en: 'The packages we included are a set of helpers that make the authentication
    user management logic automatic. Accounts-UI even enable us to have great user
    interface to log in with negligible effort. So what efforts do we need to make
    to enable it? First, we''ll add a small block of code in the place where we what
    the login UI to appear:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含的软件包是一组辅助程序，使身份验证用户管理逻辑自动化。Accounts-UI甚至使我们能够轻松拥有出色的用户界面进行登录。那么我们需要做些什么来启用它呢？首先，我们将在希望登录UI出现的地方添加一小段代码：
- en: '[PRE63]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Also we need to configure the type of login we want, so in our case, we use
    a simple username and password type, where optionally an e-mail can be entered.
    We add this config in the `secure.js` file:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们需要配置我们想要的登录类型，所以在我们的情况下，我们使用了一个简单的用户名和密码类型，可以选择输入电子邮件。我们将这个配置添加到`secure.js`文件中：
- en: '[PRE64]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: One other thing you might want to add is a simple CSS style to position the
    login box:![How to do it...](img/9282OT_10_02.jpg)
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还想添加的另一件事是一个简单的CSS样式来定位登录框：![如何做...](img/9282OT_10_02.jpg)
- en: After a simple signup and login to the account, we should notice a user link
    with our username. We could use this in order to sign out. As you can notice,
    this was as effortless as it gets.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 简单注册并登录到帐户后，我们应该注意到一个带有我们用户名的用户链接。我们可以使用这个来注销。正如你所注意到的，这是尽可能轻松的。
- en: There are plenty of other configuration options for the Accounts-UI, as well
    as extensions for connecting with Twitter, Facebook, Google, and GitHub accounts.
    More information can be found on [http://docs.meteor.com/#accounts_ui_config](http://docs.meteor.com/#accounts_ui_config),
    and the package documentation can be found at [http://docs.meteor.com/#accountsui](http://docs.meteor.com/#accountsui).
    Also, you can use features such as sending a verification e-mail or confirmation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Accounts-UI还有许多其他配置选项，以及用于连接Twitter、Facebook、Google和GitHub帐户的扩展。更多信息可以在[http://docs.meteor.com/#accounts_ui_config](http://docs.meteor.com/#accounts_ui_config)找到，软件包文档可以在[http://docs.meteor.com/#accountsui](http://docs.meteor.com/#accountsui)找到。此外，您还可以使用诸如发送验证电子邮件或确认之类的功能。
- en: How it works...
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'After login, if we try to add text using our button, we will notice that we
    still don''t have access, as our user is not authorized to do inserts. To allow
    inserts for specific users, use the following code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，如果我们尝试使用按钮添加文本，我们会注意到我们仍然没有访问权限，因为我们的用户没有被授权进行插入。要允许特定用户进行插入，使用以下代码：
- en: '[PRE65]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this insert callback, we can allow or deny access to the user with `userId`
    for the given document. For our case, the document is the `Notes` object that
    we are trying to insert and the `userId` is the ID of the currently logged user.
    Besides `collection.allow`, there is also its counterpart `collection.deny` that
    we can use to forbid access for certain methods even if there is an `allow` rule.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个插入回调中，我们可以允许或拒绝对给定文档的`userId`用户的访问。对于我们的情况，文档是我们正在尝试插入的`Notes`对象，而`userId`是当前登录用户的ID。除了`collection.allow`，还有它的对应物`collection.deny`，我们可以使用它来禁止对某些方法的访问，即使有`allow`规则。
- en: Now, it is very easy to create an advanced authorization system where we specify
    access rights programmatically. There are programmers who argue that this causes
    a lot of overhead, and it might be the case for certain applications, but for
    most of them, it should be very simple to set up access rights like this.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很容易创建一个高级授权系统，我们可以以编程方式指定访问权限。有程序员认为这会导致很多开销，对于某些应用程序可能是这样，但对于大多数应用程序来说，设置访问权限应该非常简单。
- en: In general, we should never, ever trust data that is coming from the client.
    Access should only be given to the parts that they must use and the input should
    be filtered. Having credit card data sent to the client is an easy way to destroy
    your business. Just because Meteor does so many things for us, that does not mean
    that we should forget about other common practices, such as data validation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们绝对不应该信任来自客户端的数据。只有他们必须使用的部分才能被访问，输入应该经过过滤。将信用卡数据发送到客户端是摧毁你的业务的一种简单方式。仅仅因为Meteor为我们做了这么多事情，这并不意味着我们应该忘记其他常见的做法，比如数据验证。
- en: 'You might be wondering where the user data, which we used for signup, is stored.
    If we access the Mongo console with `meteor mongo`, there is a `users` collection
    that should contain something like the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们用于注册的用户数据存储在哪里。如果我们使用`meteor mongo`访问Mongo控制台，应该会包含类似以下内容的`users`集合：
- en: '[PRE66]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can notice, it's more or less a standard data of what you might expect
    to be stored in the database. The passwords are stored hashed with salting to
    prevent some common attacks.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，这更多或多少是你可能期望存储在数据库中的标准数据。密码经过哈希处理并加盐，以防止一些常见的攻击。
- en: And that is it; we have a very simple yet secure application. The data of the
    list is of course not user-specific but that could be easily extended by adding
    an owner field of each of the created documents.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；我们有一个非常简单但安全的应用程序。列表的数据当然不是用户特定的，但可以通过为每个创建的文档添加一个所有者字段来轻松扩展。
- en: There's more...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One thing you should accept is that Meteor is still not completely finished.
    There are a lot of changes being done with every version until it gets fully stable.
    Most of the stuff that the users requested is being added, as well as other significant
    architecture improvements are being implemented, so you need to update parts of
    the code with every version.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事你应该接受的是，Meteor仍然没有完全完成。每个版本都在进行大量的更改，直到它变得完全稳定。大部分用户请求的功能都在被添加，同时还有其他重要的架构改进正在实施，所以你需要随着每个版本更新部分代码。
- en: One great resource for information are the example apps; you can list them by
    calling example apps using the `meteor create –list` command; as for getting the
    code again, you can use `meteor create -example nameofexample`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的信息资源是示例应用程序；你可以通过调用`meteor create –list`命令列出它们；至于再次获取代码，你可以使用`meteor create
    -example nameofexample`。
- en: 'When it comes down to deployment, we can freely use the server that is provided
    as our own, but there is an option to have it deployed on [www.meteor.com](http://www.meteor.com).
    This is a service provided by a startup company behind this fun framework. The
    deployment there is just one command:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署方面，我们可以自由地使用提供的服务器，但也有一个选项可以将其部署在[www.meteor.com](http://www.meteor.com)上。这是由这个有趣框架背后的初创公司提供的服务。在那里部署只需要一个命令：
- en: '[PRE67]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: More information about the cloud solution can be found at [http://docs.meteor.com/#meteordeploy](http://docs.meteor.com/#meteordeploy).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有关云解决方案的更多信息，请访问[http://docs.meteor.com/#meteordeploy](http://docs.meteor.com/#meteordeploy)。
- en: 'There is also the option to generate a fully contained Node.jsapplication from
    our Meteor app and use some other cloud service. This can be done using the following
    command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选项，可以从我们的Meteor应用程序生成一个完全独立的Node.js应用程序，并使用其他云服务。可以使用以下命令完成：
- en: '[PRE68]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As for the running of the unpacked file use the following command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 至于运行解压文件，请使用以下命令：
- en: '[PRE69]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is possible as Meteor, behind the scenes, is a Node.js framework with different
    kind of packaging.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为Meteor在幕后是一个具有不同类型打包的Node.js框架。
