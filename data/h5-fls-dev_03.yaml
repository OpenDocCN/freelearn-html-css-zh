- en: Chapter 3. Scalability, Limitations, and Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 可扩展性、限制和效果
- en: With our media assets ready for HTML5 integration, let's continue this journey
    by looking over some of the new and exciting object manipulation features within
    CSS3 and JavaScript and how they relate to what you are familiar with as a Flash
    Developer. During the course of this chapter, we will review many of the specific
    features of HTML5 that have allowed it to gain extensive usage and popularity,
    becoming more like typical Flash development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好用于HTML5集成的媒体资产后，让我们继续这个旅程，通过查看CSS3和JavaScript中一些新的和令人兴奋的对象操作功能，以及它们与Flash开发人员熟悉的内容的关系。在本章的过程中，我们将回顾HTML5的许多特定功能，这些功能使其获得了广泛的使用和受欢迎程度，变得更像典型的Flash开发。
- en: 'What we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Initial development limitations and ways to avoid them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始开发限制及避免它们的方法
- en: Some of the new and exciting CSS3 additions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些新的和令人兴奋的CSS3新增功能
- en: Developing responsive layouts for mobile and desktop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动和桌面开发响应式布局
- en: Targeting CSS styles for specific displays with CSS Media Queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS媒体查询为特定显示目标CSS样式
- en: Controlling and streaming audio and video, and the limitations compared to Flash
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制和流式传输音频和视频，以及与Flash相比的限制
- en: Client-side file integration and manipulation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端文件集成和操作
- en: Sending heavy processes to the background with HTML5 Web Workers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5 Web Workers将繁重的进程发送到后台
- en: Introduction to server-side communication with WebSockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍使用WebSockets进行服务器端通信
- en: Understanding what the Canvas element is and why it's important
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Canvas元素是什么以及它的重要性
- en: Introduction to WebGL and its relation to Stage3D
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL简介及其与Stage3D的关系
- en: HTML5 limitations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5的限制
- en: If you haven't noticed by now, many of the HTML5 features you will use either
    have failsafes, multiple versions, or special syntax to enable your code to cover
    the entire spectrum of browsers and supported HTML5 feature sets within them.
    As time passes and standards become solidified, one can assume that many of these
    failsafes and other content display measures will mature into a single standard
    that all browsers will share. However, in reality this process may take a while
    and even at its best, developers may still have to utilize many of these failsafe
    features indefinitely. Therefore, a solid understanding of when, where, and why
    to use these failsafe measures will enable you develop your HTML5 web pages in
    a way that can be viewed as intended on all modern browsers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在还没有注意到，您将使用的许多HTML5功能都具有故障保护、多个版本或特殊语法，以使您的代码覆盖整个浏览器范围和其中支持的HTML5功能集。随着时间的推移和标准的巩固，人们可以假设许多这些故障保护和其他内容显示措施将成熟为所有浏览器共享的单一标准。然而，实际上，这个过程可能需要一段时间，即使在最好的情况下，开发人员仍然可能不得不无限期地利用许多这些故障保护功能。因此，对何时、何地以及为什么使用这些故障保护措施有坚实的理解，将使您能够以一种方式开发您的HTML5网页，以便在所有现代浏览器上都能按照预期查看。
- en: To aid developers in overcoming these previously stated issues, many frameworks
    and external scripts have been created and open sourced, allowing for a more universal
    development environment saving developers countless hours when starting each new
    project. Modernizr ([http://modernizr.com](http://modernizr.com)) has quickly
    become a must-have addition for many HTML5 developers as it contains many of the
    conditions and verifications needed to allow developers to write less code and
    cover more browsers. Modernizr does all this by checking for a large majority
    (more then 40) of the new features available in HTML5 in the clients browser and
    reporting back if they are available or not in a matter of milliseconds. This
    will allow you as the developer to determine if you should display an alternate
    version of your content or a warning to the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发人员克服先前提到的这些问题，许多框架和外部脚本已经被创建并开源，使得在开始每个新项目时，可以拥有更普遍的开发环境，从而节省了开发人员无数的时间。Modernizr（[http://modernizr.com](http://modernizr.com)）已经迅速成为许多HTML5开发人员必不可少的补充，因为它包含了许多条件和验证，使得开发人员可以编写更少的代码并覆盖更多的浏览器。Modernizr通过检查客户端浏览器中HTML5中可用的大多数新功能（超过40个）并在几毫秒内报告它们是否可用来实现所有这些。这将使您作为开发人员能够确定是否应该显示内容的备用版本或向用户发出警告。
- en: Getting your web content to display properly in all browsers is and always has
    been the biggest challenge for any web developer and when it comes to creating
    cutting edge interesting content, the challenge usually becomes harder. This chapter
    will not only cover many of the new HTML5 content manipulation features, but demonstrate
    them in code examples as well. To allow you to better understand how these features
    look without the use of third-party integration, we will avoid using external
    libraries for the time being. It is worth noting how each of these features and
    others look in all browsers. Therefore make sure to test the examples as well
    as your own work in not just your favorite browser, but many of the other popular
    choices as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让您的网络内容在所有浏览器中正确显示一直是任何网络开发人员面临的最大挑战，当涉及创建尖端有趣的内容时，挑战通常变得更加艰巨。本章不仅将涵盖许多新的HTML5内容操作功能，还将在代码示例中进行演示。为了让您更好地了解这些功能在没有使用第三方集成的情况下是什么样子，我们将暂时避免使用外部库。值得注意的是，这些功能和其他功能在所有浏览器中的外观。因此，请确保在不仅是您喜欢的浏览器中，而且在许多其他流行的选择中测试示例以及您自己的工作。
- en: Object manipulation with CSS3
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS3进行对象操作
- en: Prior to the advent of CSS3, web developers used a laundry list of content manipulation,
    asset preparation, and asset presentation techniques in order to get their web
    page layout the way they wanted in every browser. Most of these techniques would
    be considered "hacks" as they would pretty much be a work around to enable the
    browser to do something it normally wouldn't. Features such as rounded corners,
    drop shadows, and transforms were all absent from a web developer's arsenal and
    the process of getting things the way you want could get mind numbing. Understandably,
    the excitement level surrounding CSS3 for all web developers is very high as it
    enables developers to perform more content manipulation techniques then ever before
    without the need for prior preparation or special browser hacks. Although the
    list of available properties in CSS3 is massive, let's cover some of the newest
    and most exciting of the lot.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS3出现之前，Web开发人员使用了一长串的内容操作、资源准备和资源呈现技术，以便在每个浏览器中获得他们想要的网页布局。其中大部分技术都被认为是“黑客”技术，因为它们基本上都是一种解决方案，使浏览器能够执行通常不会执行的操作。诸如圆角、投影阴影和变换等功能都不在Web开发人员的工具库中，而且要达到想要的效果的过程可能会让人感到无聊。可以理解的是，CSS3对所有Web开发人员的兴奋程度都非常高，因为它使开发人员能够执行比以往更多的内容操作技术，而无需事先准备或特殊的浏览器黑客技术。尽管CSS3中可用属性的列表很庞大，但让我们来介绍一些最新和最令人兴奋的属性。
- en: box-shadow
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: box-shadow
- en: It's true that some designers and developers say drop shadows are a part of
    the past, but the usage of shadowing HTML elements is still a popular design choice
    for many. In the past, web developers needed to perform tricks such as stretching
    small gradient images or creating the shadow directly into their background image
    to achieve this effect in their HTML documents. CSS3 has solved this issue by
    creating the `box-shadow` property to allow for drop shadow like effects on your
    HTML elements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设计师和开发人员说投影阴影已经过时，但在HTML元素中使用阴影仍然是许多人的流行设计选择。在过去，Web开发人员需要进行一些技巧，比如拉伸小的渐变图像或直接在背景图像中创建阴影，以在其HTML文档中实现这种效果。CSS3通过创建`box-shadow`属性来解决了这个问题，允许在HTML元素上实现类似投影阴影的效果。
- en: 'To remind us how this effect was accomplished in ActionScript 3, let''s review
    this code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提醒我们ActionScript 3中是如何实现这种效果的，让我们回顾一下这段代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As mentioned before, the new `box-shadow` property in CSS3 allows you to append
    these shadowing effects with relative ease and many of the same configuration
    properties:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CSS3中的新`box-shadow`属性允许您相对轻松地附加这些阴影效果，并且具有许多相同的配置属性：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Despite the lack of property names on each of the values applied to this style,
    you can see that many of the value types coincide with what was appended to the
    drop shadow we created in ActionScript 3.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在此样式中应用的每个值都没有属性名称，但您可以看到许多值类型与我们在ActionScript 3中创建的投影阴影所附加的值相符。
- en: 'This `box-shadow` property is assigned to the`.box-shadow-example` class and
    therefore will be applied to any element that has that classname appended to it.
    By creating a `div` element with the `box-shadow-example` class, we can alter
    our content to look something like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`box-shadow`属性被赋予了`.box-shadow-example`类，因此将被应用到任何具有该类名的元素上。通过创建一个带有`box-shadow-example`类的`div`元素，我们可以改变我们的内容，使其看起来像下面这样：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![box-shadow](img/3325OT_03_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![box-shadow](img/3325OT_03_01.jpg)'
- en: 'As straightforward as this CSS property is to add to your project, it declares
    a lot of values all in a single line. Let''s review each of these values in order
    that we can understand them better for future usage. To simplify the identification
    of each of the variables in the property, each of these have been updated to be
    different:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个CSS属性很容易添加到您的项目中，但它在一行中声明了很多值。让我们按顺序回顾每个值，以便我们更好地理解它们以备将来使用。为了简化属性中每个变量的识别，这些变量已经被更新为不同的值：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These variables are explained as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的解释如下：
- en: The initial value (`1px`) is the shadow's **horizontal offset** or if the shadow
    is going to the left or to the right. A positive value would place the shadow
    on the right of the element, a negative offset will put the shadow on the left.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始值（`1px`）是阴影的**水平偏移**，或者阴影是向左还是向右。正值将把阴影放在元素的右侧，负偏移将把阴影放在左侧。
- en: The second value (`2px`) is the **vertical offset**, and just like the horizontal
    offset value, a negative number would generate a shadow going up and a positive
    value would generate the shadow going down.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值（`2px`）是**垂直偏移**，与水平偏移值一样，负数将生成向上的阴影，正数将生成向下的阴影。
- en: The third value (`3px`) is the **blur radius** that controls how much blur effect
    will be added to the shadow. Declaring a value, for example, `0` would create
    no blur and display a very sharp looking shadow. Negative values placed into the
    blur radius will be ignored and render no different then using 0.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个值（`3px`）是**模糊半径**，控制阴影的模糊程度。声明一个值，例如`0`，将不会产生模糊，显示出一个非常锐利的阴影。放入模糊半径的负值将被忽略，与使用0没有任何不同。
- en: The fourth value (`4px`) and last of the numerical properties is the **spread
    radius**. The spread radius controls how far the drop shadow blur will spread
    past the initial shadow size declaration. If a value `0` is used, the shadow will
    display with the default blur radius set and apply no changes. Positive numerical
    values will yield a shadow that blurs further and negative value will make the
    shadow blur smaller.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个值（`4px`）也是数字属性的最后一个，是**扩展半径**。扩展半径控制了投影阴影模糊超出初始阴影大小声明的距离。如果使用值`0`，阴影将显示默认的模糊半径并且不会应用任何更改。正数值将产生更模糊的阴影，负值将使阴影模糊变小。
- en: The final value is the hexadecimal color value, which states the color that
    the shadow will be in.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个值是十六进制颜色值，表示阴影的颜色。
- en: 'Alternatively, you could use `box-shadow` to apply the shadow effect to the
    interior of your element rather then the exterior. With ActionScript 3, this was
    accomplished by appending `dropShadow.inner = true;` to the list of parameters
    in your `DropShadowFiler` object. The CSS3 syntax to apply `box-shadow` properties
    in this manner is very similar as all that is required is the addition of the
    `inset` keyword. Consider the following code snippet, for example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`box-shadow`将阴影效果应用于元素的内部而不是外部。使用ActionScript 3，可以通过在`DropShadowFiler`对象的参数列表中附加`dropShadow.inner
    = true;`来实现这一点。在CSS3中应用`box-shadow`属性的语法方式非常相似，只需要添加`inset`关键字。例如，考虑以下代码片段：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This would produce a shadow that would look like the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个看起来像下面截图的阴影：
- en: '![box-shadow](img/3325OT_03_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![box-shadow](img/3325OT_03_02.jpg)'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Included in the code examples for this chapter is a box-shadow tool that will
    allow you to better understand the affect each of the properties will have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例中包含了一个box-shadow工具，它将帮助您更好地理解每个属性的影响。
- en: text-shadow
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: text-shadow
- en: 'Just like the `box-shadow` property, `text-shadow` lives up to its name by
    creating the same drop-shadowing effect, specifically for text:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`box-shadow`属性一样，`text-shadow`通过为文本创建相同的投影效果，实现了其名字的含义。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Like `box-shadow`, the initial two values for `text-shadow` are the horizontal
    and vertical offsets for the shadow placement. The third value, which is optional
    is the blur size and the fourth value is the hexadecimal color:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与`box-shadow`一样，`text-shadow`的初始两个值是阴影放置的水平和垂直偏移量。第三个值是可选的模糊大小，第四个值是十六进制颜色：
- en: '![text-shadow](img/3325OT_03_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![text-shadow](img/3325OT_03_03.jpg)'
- en: border-radius
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: border-radius
- en: Just like element or text shadowing, adding rounded corners to your elements
    prior to CSS3 was a chore. Developers would usually append separate images or
    use other object manipulation techniques to achieve this effect on the typically
    square or rectangle shaped elements. With the addition of the `border-radius`
    setting in CSS3, developers can easily and dynamically set element corner roundness
    with only a couple of line of CSS all without the usage of vector 9 slicing like
    in Flash.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像元素或文本阴影一样，在CSS3之前为元素添加圆角是一件苦差事。开发人员通常会附加单独的图像或使用其他对象操作技术来实现这种效果，通常是在典型的正方形或矩形形状元素上。通过在CSS3中添加`border-radius`设置，开发人员可以轻松动态地设置元素的角落圆度，只需几行CSS代码，而无需像Flash中那样使用矢量9切片。
- en: 'Since HTML elements have four corners, when appending the `border-radius` styling,
    we can either target each corner individually, or all the corners at once. In
    order to easily append a border radius setting to all the corners at once, we
    would create our CSS properties as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTML元素有四个角，当附加`border-radius`样式时，我们可以单独针对每个角落，或者一次性针对所有角落。为了轻松地一次性附加边框半径设置到所有角落，我们将创建我们的CSS属性如下：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding CSS not only appends a 10px border radius to all of the corners
    of the `#example` element, by using all the properties, which the modern browsers
    use, we can be assured that the effect will be visible to all users attempting
    to view this content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的CSS不仅将10px的边框半径附加到`#example`元素的所有角落，还使用了现代浏览器使用的所有属性，我们可以确保这种效果对所有试图查看此内容的用户都是可见的：
- en: '![border-radius](img/3325OT_03_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![border-radius](img/3325OT_03_04.jpg)'
- en: 'As mentioned above, each of the individual corners of the element can be targeted
    to only append the radius to a specific part of the element:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，可以针对元素的每个单独角落，只附加半径到元素的特定部分：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding CSS now removes our `#example` element''s left border radius
    by setting it to `0px` and sets a specific radius to each of the other corners.
    It''s worth noting here that setting a border radius equal to `0` is no different
    than leaving that property completely out of the CSS styles:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的CSS现在通过将左边框半径设置为`0px`来移除我们的`#example`元素，并为其他每个角落设置了特定的半径。值得注意的是，在这里将边框半径设置为`0`与完全不在CSS样式中留下该属性没有任何区别：
- en: '![border-radius](img/3325OT_03_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![border-radius](img/3325OT_03_05.jpg)'
- en: Fonts
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体
- en: Dealing with customized fonts in Flash has had its ups and downs over the years.
    Any Flash developer who has needed to incorporate and use customized fonts in
    their Flash applications probably knows the pain that comes with choosing a font
    embedding method as well as making sure it works properly for users who don't
    have the font installed on their computer viewing the Flash application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，在Flash中处理自定义字体一直有着起伏。任何需要在其Flash应用程序中合并和使用自定义字体的Flash开发人员可能都知道选择字体嵌入方法以及确保它对没有在其计算机上安装字体的用户正常工作的痛苦。
- en: 'CSS3 font embedding has implemented a "no fuss" way to include custom fonts
    into your HTML5 documents with the addition of the `@font-face` declaration:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3字体嵌入已经实现了一种“无忧无虑”的方式，可以通过`@font-face`声明将自定义字体包含到HTML5文档中：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'CSS can now directly reference your TTF, OTF, or EOT font which can be placed
    on your web server for accessibility. With the font source declared in our CSS
    document and a unique `font-family` identification applied to it, we can start
    using it on specific elements by using the `font-family` property:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CSS现在可以直接引用您的TTF、OTF或EOT字体，这些字体可以放在您的Web服务器上以实现可访问性。在我们的CSS文档中声明了字体源，并为其应用了唯一的`font-family`标识后，我们可以通过使用`font-family`属性在特定元素上开始使用它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we declared a specific font family name in the `@font-face` property,
    we can use that custom name on pretty much any element henceforth. Custom fonts
    can be applied to almost anything that contains text in your HTML document. Form
    elements such as button labels and text inputs also can be styled to used your
    custom fonts. You can even remake assets such as website logos in pure HTML and
    CSS with the same custom fonts used in the original asset creation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`@font-face`属性中声明了特定的字体系列名称，因此以后几乎可以在任何元素上使用该自定义名称。自定义字体可以应用于HTML文档中几乎包含文本的任何内容。表单元素，如按钮标签和文本输入，也可以被设计为使用您的自定义字体。您甚至可以使用纯HTML和CSS重新制作网站标志等资产，并使用原始资产创建时使用的相同自定义字体。
- en: Acceptable font formats
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可接受的字体格式
- en: Like many of the other embedding methods for assets online, fonts needs to be
    converted into multiple formats to enable all common modern browsers to display
    them properly. Almost all of the available browsers will be able to handle the
    common True Type Fonts (`.ttf` file types) or Open Type Fonts (`.otf` file types),
    so embedding one of those two formats will be all that is needed. Unfortunately
    Internet Explorer 9 does not have support built in for either of those two popular
    formats and requires fonts to be saved in the EOT file format.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与在线资产的许多其他嵌入方法一样，字体需要转换为多种格式，以使所有常见的现代浏览器能够正确显示它们。几乎所有可用的浏览器都能够处理常见的True Type字体（.ttf文件类型）或Open
    Type字体（.otf文件类型），因此嵌入其中一种格式就足够了。不幸的是，Internet Explorer 9没有内置对这两种流行格式的支持，需要将字体保存为EOT文件格式。
- en: External font libraries
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部字体库
- en: Many great services have appeared online in the last couple of years allowing
    web developers to painlessly prepare and embed fonts into their websites. Google's
    Web Fonts archive available at [http://www.google.com/webfonts](http://www.google.com/webfonts)
    hosts a large set of open source fonts which can be added to your project without
    the need to worry about licensing or payment issues. Simply add a couple of extras
    lines of code into your HTML document and you are ready to go.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，出现了许多优秀的在线服务，使Web开发人员可以轻松地准备和嵌入字体到他们的网站中。Google的Web字体存档可在[http://www.google.com/webfonts](http://www.google.com/webfonts)找到，其中托管了一大批开源字体，可以添加到您的项目中，而无需担心许可或付款问题。只需在HTML文档中添加几行额外的代码，您就可以开始使用了。
- en: Another great site that is worth checking out is Font Squirrel, which can be
    found at [http://www.fontsquirrel.com](http://www.fontsquirrel.com). Like Google
    Web Fonts, Font Squirrel hosts a large archive of web-ready fonts with the copy-and-paste-ready
    code snippets to add them to your document. Another great feature on this site
    is the `@font-face` generator which give you the ability to convert your preexisting
    fonts into all the web compatible formats.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的另一个很棒的网站是Font Squirrel，可以在[http://www.fontsquirrel.com](http://www.fontsquirrel.com)找到。与Google
    Web Fonts一样，Font Squirrel托管了一个大型的网页可用字体存档，并提供了复制粘贴就绪的代码片段，以将它们添加到您的文档中。该网站上的另一个很棒的功能是`@font-face`生成器，它可以让您将现有字体转换为所有网页兼容格式。
- en: Before getting carried away and converting all your favorite fonts into web
    ready formats and integrating them into your work, it is worth noting the End
    User License Agreement or EULA that came with the font to begin with. Converting
    many available fonts for use on the web will break license agreements and could
    cause legal issues for you down the road.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在沉迷于将所有喜爱的字体转换为网页可用格式并将它们整合到您的工作中之前，值得注意的是最初随字体附带的最终用户许可协议或EULA。将许多可用字体转换为网页使用将违反许可协议，并可能在未来给您带来法律问题。
- en: Opacity
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不透明度
- en: 'More commonly known as "alpha" to the Flash developer, setting the opacity
    of an element not only allows you to change the look and feel of your designs,
    but allows you to add features like content that fades in and out. As simple as
    this concept seems, it is relatively new to the available list of CSS properties
    available to web developers. Setting the opacity of an element is extremely easy
    and looks something like the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Flash开发人员来说，更常见的是“alpha”，设置元素的不透明度不仅可以改变设计的外观和感觉，还可以添加诸如淡入淡出的内容等功能。尽管这个概念看起来很简单，但它相对于Web开发人员可用的CSS属性列表是相对较新的。设置元素的不透明度非常容易，看起来像下面这样：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see from the preceding example, like ActionScript 3, the opacity
    value is a numerical value between 0 and 1\. The preceding example would display
    a element at 50 percent transparency. The opacity property in CSS3 is now supported
    in all the major browsers, so there is no need to worry about using alternative
    property syntax when declaring it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从上面的示例中看到的那样，与ActionScript 3一样，不透明度值是介于0和1之间的数值。上面的示例将以50%的透明度显示一个元素。CSS3中的不透明度属性现在在所有主要浏览器中都得到支持，因此在声明时无需担心使用替代属性语法。
- en: RGB and RGBA coloring
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RGB和RGBA着色
- en: When dealing with color values in CSS, many developers would typically use hexadecimal
    values, which would resemble something like `#000000` to declare the usage of
    the color black. Colors can also be implemented in their RGB representation in
    CSS by utilizing the `rgb()` or `rgba()` calls in place of the hexadecimal value.
    As you can see by the method name, the `rgba` color lookup in CSS also requires
    a forth parameter which declares the colors alpha transparency or opacity amount.
    Using RGBA in CSS3 rather than hexadecimal colors can be beneficial for a couple
    of reasons. Consider you have just created a `div` element which will be displayed
    on top of existing content within your web page layout.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理CSS中的颜色值时，许多开发人员通常会使用十六进制值，类似于`#000000`来声明使用黑色。颜色也可以在CSS中以RGB表示法实现，通过使用`rgb()`或`rgba()`调用来代替十六进制值。通过方法名称，您可以看到CSS中的`rgba`颜色查找还需要第四个参数，它声明颜色的alpha透明度或不透明度量。在CSS3中使用RGBA而不是十六进制颜色有几个好处。假设您刚刚创建了一个`div`元素，它将显示在网页布局中现有内容的顶部。
- en: 'If you ever wanted to set a background color to the `div` as a specific color
    but wish for only that background to be semi transparent and not the interior
    content, the RGBA color declaration now allows you to do this easily as you can
    set the colors transparency:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经想要将`div`的背景颜色设置为特定颜色，但希望只有该背景是半透明的，而不是内部内容，那么RGBA颜色声明现在可以轻松实现这一点，因为您可以设置颜色的透明度：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding example, you can freely use RGB and RGBA values
    rather than hexadecimal anywhere color values are required in CSS syntax.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在前面的示例中所看到的，您可以在CSS语法中的任何需要颜色值的地方自由使用RGB和RGBA值，而不是十六进制。
- en: Element transforms
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素变换
- en: Personally, I find CSS3 transforms to be one of the most exciting and fun new
    features in CSS. Transforming assets in the Flash IDE as well as with ActionScript
    has always been easily accessible and easy to implement. Transforming HTML elements
    is a relatively new feature to CSS and is still gaining full support by all the
    modern browsers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我发现CSS3变换是CSS中最令人兴奋和有趣的新功能之一。在Flash IDE中以及使用ActionScript转换资产一直是非常容易访问和易于实现的。在CSS中转换HTML元素是CSS的一个相对较新的功能，并且仍在逐渐得到所有现代浏览器的全面支持。
- en: Transforming an element allows you to manipulate its shape and size by opening
    up a ton of possibilities for animations and visual effects to assets without
    the need to prepare the source before hand. When we refer to "transforming an
    element", we are actually describing a number of properties that can be applied
    to the transformation to give it different characteristics. If you have transformed
    objects in Flash or possibly in Photoshop before, these properties may be familiar
    to you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 变换元素允许您通过打开大量动画和视觉效果的可能性来操纵其形状和大小，而无需事先准备源。当我们提到“变换元素”时，实际上是在描述可以应用于变换的一系列属性，以赋予它不同的特性。如果您以前在Flash或可能在Photoshop中转换过对象，这些属性可能对您来说很熟悉。
- en: Translate
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 翻译
- en: 'As a Flash developer used to primarily dealing with X and Y coordinates when
    positioning elements, the CSS3 Translate Transform property is a very handy way
    of placing elements and it works on the same principal. The `translate` property
    takes two parameters which are the X and the Y values to translate, or effectively
    move the element:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名主要处理X和Y坐标来定位元素的Flash开发人员，CSS3 Translate Transform属性是放置元素的一种非常方便的方法，它的工作原理与Flash相同。`translate`属性接受两个参数，即X和Y值，用于平移或有效地移动元素：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unfortunately, to get your transforms to work in all browsers, you will need
    to target each of them when you append transform styles. Therefore, the standard
    transform style and property would now look something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，为了使您的变换在所有浏览器中都能正常工作，您需要在附加变换样式时针对每个浏览器进行定位。因此，标准的变换样式和属性现在看起来会像这样：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rotate
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转
- en: 'Rotation is pretty self-explanatory and extremely easy to implement. The `rotate`
    properties take a single parameter to specify the amount of rotation, in degrees,
    to apply to the specific element:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转是相当不言自明的，而且非常容易实现。`rotate`属性接受一个参数，用于指定要应用于特定元素的旋转量（以度为单位）：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is worth noting that regardless of the fact that the supplied value is always
    intended to be a value in degrees, the value must always have **deg** appended
    for the value to be properly recognized.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管提供的值始终意味着度数值，但值必须始终附加**deg**以便正确识别该值。
- en: Scale
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比例
- en: 'Just like `rotate` transforms, scaling is pretty straightforward. The `scale`
    property requires two parameters, which declare the scale amount for both X and
    Y:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`rotate`变换一样，缩放也非常简单。`scale`属性需要两个参数，分别声明X和Y的缩放量：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Skew
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 倾斜
- en: 'Skewing a element will result in the angling of the X and Y axes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜元素将导致X和Y轴的倾斜：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following illustration is a representation of skewing an image with the
    preceding properties:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图是对使用前述属性倾斜图像的表示：
- en: '![Skew](img/3325OT_03_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![倾斜](img/3325OT_03_06.jpg)'
- en: Matrix
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵
- en: 'The `matrix` properties combine all of the preceding transforms into a single
    property and can easily eliminate many extra lines of CSS in your source:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix`属性将所有前述变换组合成一个属性，并且可以轻松消除源代码中的许多额外CSS行：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example utilizes the CSS transform matrix property to apply multiple
    transform styles in a single call. The `matrix` property requires six parameters
    to rotate, scale, move, and skew the element. Using the matrix property is only
    really useful when you actually need to implement all of the transform properties
    at once. If you only need to utilize one aspect of element transforms, you will
    be better off using just that CSS style property.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例利用了CSS变换矩阵属性来在单个调用中应用多个变换样式。`matrix`属性需要六个参数来旋转、缩放、移动和倾斜元素。只有当您实际上需要一次实现所有变换属性时，使用矩阵属性才真正有用。如果您只需要利用元素变换的一个方面，最好只使用该CSS样式属性。
- en: 3D transforms
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3D变换
- en: Up until now, all of the transform properties we have reviewed have been two
    dimensional transformations. CSS3 now also supports 3D as well as 2D transforms.
    One of the best parts of CSS3 3D transforms is the fact that many devices and
    browsers support hardware acceleration allowing this complex graphical processing
    to be done on your video cards GPU. At the time of writing this book, only Chrome,
    Safari, and Firefox have support for CSS 3D transforms.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们审查过的所有变换属性都是二维变换。CSS3现在还支持3D和2D变换。CSS3 3D变换最好的部分之一是许多设备和浏览器支持硬件加速，从而允许在您的视频卡GPU上进行复杂的图形处理。在撰写本书时，只有Chrome、Safari和Firefox支持CSS
    3D变换。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Interested in what browsers will support all these great HTML5 features before
    you start developing? Check out [http://caniuse.com](http://caniuse.com) to see
    what popular browsers support in a simple, easy-to-use website.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发之前，想知道哪些浏览器将支持所有这些出色的HTML5功能吗？请访问[http://caniuse.com](http://caniuse.com)查看流行浏览器在一个简单易用的网站上支持哪些功能。
- en: When dealing with elements in a 3D world, we make use of the Z coordinate, which
    allows the use of some new transform properties.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理3D世界中的元素时，我们使用Z坐标，这允许使用一些新的变换属性。
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s create a 3D cube from HTML elements to put all of these properties into
    a working example. To start creating our 3D cube, we will begin by writing the
    HTML elements which will contain the cube as well as the elements which will be
    making up the cube itself:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从HTML元素创建一个3D立方体，将所有这些属性放入一个工作示例中。要开始创建我们的3D立方体，我们将首先编写包含立方体的HTML元素，以及构成立方体本身的元素：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This HTML creates a simple layout for our cube by not only creating each of
    the six sides, which makes up a cube with specific class names, but the container
    for the entire cube as well as the main container to display all of our page content.
    Of course, since there is no internal content in these containers and no styling
    yet, opening this HTML file in your browser would yield an empty page. So let''s
    start writing our CSS to make all of these elements visible and position each
    to form our three dimensional cube. We will start by setting up our main containers
    which will position our content and contain our cubes sides:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML通过创建每个具有特定类名的六个面的元素，以及整个立方体的容器以及显示所有页面内容的主容器，为我们的立方体创建了一个简单的布局。当然，由于这些容器中没有内部内容，也没有样式，将此HTML文件在浏览器中打开将得到一个空白页面。因此，让我们开始编写CSS，使所有这些元素可见，并将每个元素定位以形成我们的三维立方体。我们将首先设置我们的主容器，这将定位我们的内容并包含我们的立方体面：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `container` class is our main element, which contains all of the other
    elements within this example. After appending a width and height, we set the top
    margin to `200px` to push the display down the page a bit for better viewing and
    the left and right margins to auto which will align this element in the center
    of the page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “container”类是我们的主要元素，它包含此示例中的所有其他元素。在附加了宽度和高度后，我们将顶部边距设置为“200px”，以将显示向下推移一点，以便更好地查看页面，并将左右边距设置为自动，这将使该元素在页面中居中对齐。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By defining properties to the `#cube div`, we set the styles to every `div`
    element within the `#cube` element. We are also kind of cheating the system of
    cube by setting the width and height to rectangular proportions as the intention
    is to add videos to each of the cube sides once we structure and position it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为“#cube div”定义属性，我们为“#cube”元素内的每个“div”元素设置样式。我们还通过将宽度和高度设置为矩形比例来欺骗立方体系统，因为我们的意图是在结构和位置确定后向立方体的每一面添加视频。
- en: 'With the basic cube-side styles appended, its time to start transforming each
    of the sides to form the three-dimensional cube. We will start with the front
    of the cube by translating it on the Z axis, bringing it closer to the perspective:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 附加了基本的立方体面样式后，现在是时候开始变换每个面，形成三维立方体了。我们将从立方体的前面开始，通过在Z轴上进行平移，使其靠近视角：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to append this style to our element in all modern browsers, we will
    need to specify the property in multiple syntaxes for each browser that doesn''t
    support the default `transform` property:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这种样式附加到所有现代浏览器中的元素上，我们需要为每个不支持默认“transform”属性的浏览器指定多种语法的属性：
- en: '![3D transforms](img/3325OT_03_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![3D transforms](img/3325OT_03_07.jpg)'
- en: 'The preceding screenshot shows what has happened to the `.front` div after
    appending a Z translation of 320px. The larger rectangle is the `.front` div,
    which is now 320px closer to our perspective. For simplicity''s sake, let''s do
    the same to the `.back` div and push it 320px away from the perspective:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在附加了Z轴平移320px后，前面的屏幕截图显示了“.front” div发生的变化。较大的矩形是“.front” div，现在离我们的视角近了320px。为了简单起见，让我们对“.back”
    div执行相同的操作，将其推离视角320px：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see from the preceding code, to properly move the `.back` element
    into place without placing it upside down, we flip the element by 180 degrees
    on the X axis and then translate Z by 320px just like we did for `.front`. Note
    that we didn''t set a negative value on the translate Z because the element was
    flipped. With the `.back` CSS styles in place, our cube should look like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，为了正确将“.back”元素移动到位而不使其倒置，我们在X轴上将元素翻转180度，然后像“.front”一样将Z平移320px。请注意，我们没有在translate
    Z上设置负值，因为元素被翻转了。有了“.back” CSS样式，我们的立方体应该看起来像下面这样：
- en: '![3D transforms](img/3325OT_03_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![3D transforms](img/3325OT_03_08.jpg)'
- en: Now the smallest rectangle visible is the element with the classname `.back`,
    the largest is our `.front` element, and the middle rectangle is the remaining
    elements to be transformed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可见的最小矩形是具有类名“.back”的元素，最大的是我们的“.front”元素，中间的矩形是剩下的要变换的元素。
- en: 'To position the sides of our cubes we will need to rotate the side elements
    on the Y axis to get them to face the proper direction. Once they are rotated
    into place, we can translate the position on the Z axis to push it out from the
    center as we did with the front and back faces:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定位立方体的各个面，我们需要绕Y轴旋转侧面元素，使其面向正确的方向。一旦它们旋转到位，我们可以在Z轴上平移位置，使其从中心推出，就像我们对前面和后面的面做的那样：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![3D transforms](img/3325OT_03_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![3D transforms](img/3325OT_03_09.jpg)'
- en: 'With the right side in place, we can do the same to the left side but rotate
    it in the opposite direction to get it facing the other way:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧就位后，我们可以对左侧执行相同的操作，但是将其朝相反方向旋转，使其面向另一侧：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![3D transforms](img/3325OT_03_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![3D transforms](img/3325OT_03_10.jpg)'
- en: 'Now that we have all four sides of our cube aligned properly, we can finalize
    the cube positioning by aligning the top and bottom sides. To properly size the
    top and bottom we will set their own width and height to override the initial
    values set in the `#cube` div styles:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确对齐了立方体的四个面，我们可以通过对齐顶部和底部来最终确定立方体的位置。为了正确设置顶部和底部的大小，我们将设置它们自己的宽度和高度，以覆盖“#cube”
    div样式中设置的初始值：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To properly position the top and bottom sides, we rotate the `.top` and `.bottom`
    elements +-90 degrees on the X axis to get them to face up and down, and only
    need to translate the top on the Z axis to raise it to the proper height to connect
    with all of the other sides.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确定位顶部和底部，我们需要在X轴上将`.top`和`.bottom`元素旋转+-90度，使它们朝上和朝下，只需要在Z轴上将顶部平移到正确的高度，以连接所有其他面。
- en: 'With all of those transforms appended to our layout, the resulting cube should
    look like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的布局中添加了所有这些变换后，生成的立方体应该如下所示：
- en: '![3D transforms](img/3325OT_03_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![3D变换](img/3325OT_03_11.jpg)'
- en: 'Although it looks 3D, since there is nothing in the containers, the perspective
    isn''t really showing off our cube very well. So let''s add some content such
    as a video in each of the sides of the cube to get a better visualization of our
    work. Within each of the sides, let''s add the same HTML5 video element code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来是3D的，但由于容器中没有内容，透视并没有很好地展示我们的立方体。因此，让我们在立方体的每一面添加一些内容，比如视频，以更好地可视化我们的工作。在每一面中，让我们添加相同的HTML5视频元素代码：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since we have not added the element playback controls in order to display more
    visible area of the cube, our video element is set to *autoplay* the video as
    well as *loop* the playback on completion. Now we get a result that properly demonstrates
    what 3D transforms can do and is a little more visually appealing:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未添加元素播放控件以显示立方体的更多可见区域，我们的视频元素被设置为在完成后*自动播放*视频以及*循环*播放。现在我们得到了一个正确展示3D变换能做什么并且更具视觉吸引力的结果：
- en: '![3D transforms](img/3325OT_03_12.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![3D变换](img/3325OT_03_12.jpg)'
- en: Since we set the opacity of each of the cube sides, we can now see all four
    videos playing on each side, pretty cool! Since we are already here, why not kick
    it up one more notch and add user interaction to this cube so we can spin it around
    and see the video on each side.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们设置了每个立方体面的不透明度，现在我们可以看到所有四个视频在每一面播放，非常酷！既然我们已经在这里，为什么不再加一点，为这个立方体添加用户交互，这样我们就可以把它转过来，看到每一面的视频。
- en: 'To perform this user interaction, we need to use JavaScript to translate the
    mouse coordinates on the page document to the X and Y 3D rotation of our cube.
    So let''s start by creating the JavaScript to listen for mouse events:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这种用户交互，我们需要使用JavaScript将页面文档上的鼠标坐标转换为立方体的X和Y 3D旋转。因此，让我们开始创建JavaScript来监听鼠标事件：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see from the preceding code example, when the `mousemove` event fires
    and calls the `onMouseMove` function, we need to run some conditionals to properly
    parse the proper mouse position. Since, like so many other parts of web development,
    retrieving the mouse coordinates differs from browser to browser, we have added
    a simple condition to attempt to gather the mouse X and Y in a couple of different
    ways.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码示例中可以看出，当`mousemove`事件触发并调用`onMouseMove`函数时，我们需要运行一些条件语句来正确解析鼠标位置。由于像网页开发的许多其他部分一样，从浏览器中检索鼠标坐标各不相同，我们添加了一个简单的条件来尝试以几种不同的方式收集鼠标X和Y。
- en: 'With the mouse position ready to be translated into the transform rotation
    of our cube, there is one final bit of preparation we need to complete prior to
    setting the CSS style updates. Since different browsers support the application
    of CSS transforms in different syntaxes, we need to figure out, in JavaScript,
    which syntax to use during runtime to allow our script to run on all browsers.
    The following code example does just that. By setting a predefined array of the
    possible property values and attempting to check the type of each as an element
    style property, we can find which element is not undefined and know it can be
    used for CSS transform styles:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标位置准备好被转换为立方体的变换旋转后，我们需要在设置CSS样式更新之前完成最后一点准备工作。由于不同的浏览器支持不同语法的CSS变换应用，我们需要在JavaScript中找出在运行时使用哪种语法，以允许我们的脚本在所有浏览器上运行。以下代码示例就是这样做的。通过设置可能属性值的预定义数组，并尝试检查每个属性的类型作为元素样式属性，我们可以找到哪个元素不是未定义的，并知道它可以用于CSS变换样式：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have the user''s mouse position and the proper syntax for CSS transform
    updates for our cube, we can put it all together and finally have 3D rotational
    control of our video cube:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了用户的鼠标位置和立方体的CSS变换更新的正确语法，我们可以把它们放在一起，最终实现对我们的视频立方体的3D旋转控制：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Regardless of the fact we have attempted to allow for multi browser use of
    this example, it is worth opening it up in each to see how something like 3D transforms
    with heavy internal content run. During the time of writing this book, all WebKit
    browsers were the easy choice when viewing content like this, as browsers such
    as Firefox and Internet Explorer render this example at a much slower and lower
    quality output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经尝试允许多浏览器使用此示例，但最好在每个浏览器中打开它，看看类似3D变换的重型内部内容是如何运行的。在撰写本书时，所有WebKit浏览器都是查看此类内容的简单选择，因为诸如Firefox和Internet
    Explorer之类的浏览器以更慢和更低质量的输出渲染此示例：
- en: '![3D transforms](img/3325OT_03_13.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![3D变换](img/3325OT_03_13.jpg)'
- en: Transitions
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过渡
- en: 'With CSS3, we can add an effect when changing from one style to another, without
    using Flash animations or JavaScripts:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS3，我们可以在从一种样式更改到另一种样式时添加效果，而无需使用Flash动画或JavaScript：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the duration is not specified, the transition will have no effect, because
    the default value is 0:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定持续时间，过渡将不会产生任何效果，因为默认值为0：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It should be worth noting that Internet Explorer currently does not have support
    for CSS3 transitions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，目前Internet Explorer不支持CSS3过渡。
- en: Browser compatibility
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器兼容性
- en: If you haven't noticed yet, the battle of browser compatibility is one of the
    biggest aspects of a web developer's job. Over time, many great services and applications
    have been created to help developers overcome these hurdles in a much simpler
    manner than trial-and-error techniques. Websites such as [http://css3test.com](http://css3test.com),
    [http://caniuse.com](http://caniuse.com), and [http://html5readiness.com](http://html5readiness.com)
    are all great resources to keep on top of HTML5 specification developer and browser
    support for all the features within.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有注意到，浏览器兼容性的斗争是网页开发人员工作的最重要方面之一。随着时间的推移，许多出色的服务和应用程序已经被创建，以帮助开发人员以比试错技术更简单的方式克服这些障碍。网站，如[http://css3test.com](http://css3test.com)、[http://caniuse.com](http://caniuse.com)和[http://html5readiness.com](http://html5readiness.com)都是保持HTML5规范开发人员和浏览器对所有功能的支持的重要资源。
- en: Frame rate
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧速率
- en: One would assume since you, the reader, are coming from a Flash development
    background, a moment should be taken to talk about frame rates or frames per second
    when developing HTML5 applications. Since every asset in Flash applications is
    based on the timeline model, calculating how many frames of that timeline are
    displayed every second is a pretty simple calculation. However, all the technologies
    that make up HTML5 development do not rely on the use of a timeline during runtime.
    Therefore calculating the frames per second or FPS value of a webpage is not always
    an accurate measure of performance of your HTML5 projects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人会假设，因为你，读者，来自Flash开发背景，当开发HTML5应用程序时，应该花点时间谈论帧速率或每秒帧数。由于Flash应用程序中的每个资源都是基于时间轴模型的，计算每秒显示多少帧时间轴的帧是一个相当简单的计算。然而，组成HTML5开发的所有技术在运行时都不依赖于时间轴的使用。因此，计算网页的每秒帧数或FPS值并不总是衡量HTML5项目性能的准确指标。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Our CSS 3D Transform example found in the chapter code examples includes the
    use of a great piece of JavaScript called **Stats.js** to monitor the frames per
    second as well as the ms. Stats.js is a open source project that can be found
    at [https://github.com/mrdoob/stats.js](https://github.com/mrdoob/stats.js).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节代码示例中找到的CSS 3D变换示例包括使用一个名为**Stats.js**的优秀JavaScript代码，用于监视每秒帧数以及毫秒数。Stats.js是一个开源项目，可以在[https://github.com/mrdoob/stats.js](https://github.com/mrdoob/stats.js)找到。
- en: Developing for mobile
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为移动设备开发
- en: Another one of the driving forces behind the popularity of HTML5 is the overwhelming
    support for it on most of the modern mobile browsers ([http://mobilehtml5.org](http://mobilehtml5.org)).
    With the loss of Flash Player on all mobile platforms now, the use of HTML5 to
    deliver content is at an all time high and the usage is growing daily. Applications,
    frameworks, and templates such as jQuery Mobile ([http://jquerymobile.com](http://jquerymobile.com)),
    Phone Gap ([http://phonegap.com](http://phonegap.com)), Appcelerator ([http://www.appcelerator.com](http://www.appcelerator.com))
    and the Mobile Boilerplate ([http://html5boilerplate.com/html5boilerplate.com/dist/mobile](http://html5boilerplate.com/html5boilerplate.com/dist/mobile))
    all of which will be covered in detail in [Chapter 5](ch05.html "Chapter 5. Code
    Once, Release Everywhere"), *Code Once, Release Everywhere*, are all specifically
    built to aid web developers for building web content that is specifically targeted
    for mobile viewing. CSS can be set up in a responsive manner to allow the same
    page content to be displayed in an optimized format depending on the device and
    viewport configuration a user is viewing your content with.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5受到现代移动浏览器的全面支持，这是HTML5流行的另一个推动力。随着Flash Player在所有移动平台上的失去，使用HTML5传递内容的使用率达到了历史最高水平，并且每天都在增长。应用程序、框架和模板，如jQuery
    Mobile ([http://jquerymobile.com](http://jquerymobile.com))、Phone Gap ([http://phonegap.com](http://phonegap.com))、Appcelerator
    ([http://www.appcelerator.com](http://www.appcelerator.com))和Mobile Boilerplate
    ([http://html5boilerplate.com/html5boilerplate.com/dist/mobile](http://html5boilerplate.com/html5boilerplate.com/dist/mobile))，所有这些都将在[第5章](ch05.html
    "第5章。一次编码，到处发布")中详细介绍，*一次编码，到处发布*，都是专门为帮助网页开发人员构建专门针对移动视图的网页内容而构建的。CSS可以以响应的方式设置，以便根据用户查看内容的设备和视口配置以优化的格式显示相同的页面内容。
- en: Responsive layouts
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式布局
- en: The term "responsive layout" seems to get used on a more frequent basis as HTML5
    development has grown in popularity. It has, to some, become a keyword to define
    one of the key features of good HTML5 development. Regardless of how the term
    is used, at the end of the day when we refer to "responsive layouts" in web development,
    we are referring to the usage of modern web development techniques to enable the
    same page content to transition its layout and content within it to adjust for
    the users device and viewing resolution. In other words, making sure your page
    content is set up in an optimized manner for all viewing resolutions and is able
    to transition between any one of the layouts without the need for content of page
    refreshing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: “响应式布局”这个术语似乎在HTML5开发日益普及的情况下被更频繁地使用。对一些人来说，它已经成为定义良好的HTML5开发的关键特性之一的关键词。无论术语如何使用，归根结底，当我们在网页开发中提到“响应式布局”时，我们指的是使用现代网页开发技术来使同一页面内容能够在用户设备和视图分辨率上进行布局和内容的过渡调整。换句话说，确保您的页面内容以优化的方式设置，适用于所有视图分辨率，并且能够在任何一个布局之间进行过渡，而无需刷新页面内容。
- en: CSS Media Queries
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS媒体查询
- en: 'One of the most important assets when creating responsive layouts is the use
    of CSS Media Queries. Media Queries allow you to target specific CSS styles depending
    on your user''s device, resolution, rotation, and more. Knowing as much as possible
    about the device and software loading your HTML documents will allow you to not
    only specify how specific devices and browsers are to display your content, but
    it can also allow your code to monitor real-time changes to the viewing methods
    as well. For instance, the following Media Query example changes the background
    color depending on device rotation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建响应式布局时最重要的资产之一是使用CSS媒体查询。媒体查询允许您根据用户的设备、分辨率、旋转等目标特定的CSS样式。尽可能了解加载HTML文档的设备和软件将使您不仅能够指定特定设备和浏览器如何显示内容，还可以使您的代码监视查看方法的实时更改。例如，以下媒体查询示例根据设备旋转更改背景颜色：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The list of CSS Media Queries properties is short but it is important to understand
    what is available to you when creating your conditions. Therefore, let''s quickly
    review what properties you have at your disposal when writing your Media Queries:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: CSS媒体查询属性列表很短，但在创建条件时了解可用的内容非常重要。因此，让我们快速回顾一下在编写媒体查询时可以使用的属性：
- en: '`width`: Describes the width of the targeted display area.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：描述目标显示区域的宽度。'
- en: '`height`: Describes the height of the targeted display area.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`：描述目标显示区域的高度。'
- en: '`device-width`: Describes the width of the rendering display of the output
    device.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device-width`：描述输出设备的渲染显示的宽度。'
- en: '`device-height`: Describes the height of the rendering display of the output
    device.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device-height`：描述输出设备的渲染显示的高度。'
- en: '`orientation`: Is `portrait` when the value of the height media feature is
    greater than or equal to the value of the width media feature. Otherwise the orientation
    is `landscape`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orientation`：当高度媒体特征的值大于或等于宽度媒体特征的值时，为`portrait`。否则，方向为`landscape`。'
- en: '`aspect-ratio`: Defined as the ratio of the value of the `width` media feature
    to the value of the `height` media feature.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aspect-ratio`：定义为`width`媒体特征值与`height`媒体特征值的比率。'
- en: '`device-aspect-ratio`: Defined as the ratio of the value of the `device-width`
    media feature to the value of the `device-height` media feature.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device-aspect-ratio`：定义为`device-width`媒体特征值与`device-height`媒体特征值的比率。'
- en: '`color`: Describes the number of bits per color component of the output device.
    If the device is not a color device, the value is zero.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：描述输出设备颜色组件的每位数。如果设备不是彩色设备，则该值为零。'
- en: '`color-index`: Describes the number of entries in the color look up table of
    the output device. If the device does not use a color look up table, the value
    is zero.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color-index`：描述输出设备颜色查找表中的条目数。如果设备不使用颜色查找表，则该值为零。'
- en: '`monochrome`: Describes the number of bits per pixel in a monochrome frame
    buffer. If the device is not a monochrome device, the output device value will
    be `0`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monochrome`：描述单色帧缓冲区中每像素的位数。如果设备不是单色设备，则输出设备值将为`0`。'
- en: '`resolution`: Describes the resolution of the output device, that is, the density
    of the pixels. When querying devices with non-square pixels, in `min-resolution`
    queries the least-dense dimension must be compared to the specified value and
    in `max-resolution` queries the most-dense dimensions must be compared instead.
    A `resolution` (without a "min-" or "max-" prefix) query never matches a device
    with non-square pixels.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolution`：描述输出设备的分辨率，即像素的密度。在查询具有非方形像素的设备时，在`min-resolution`查询中，最不密集的维度必须与指定值进行比较，在`max-resolution`查询中，最密集的维度必须进行比较。没有“min-”或“max-”前缀的`resolution`查询永远不匹配具有非方形像素的设备。'
- en: '**scan**: Describes the scanning process of "tv" output devices.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scan**：描述“tv”输出设备的扫描过程。'
- en: '**grid**: Used to query whether the output device is grid or bitmap. If the
    output device is grid-based (for example, a "tty" terminal, or a phone display
    with only one fixed font), the value will be `1`. Otherwise, the value will be
    `0`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**grid**：用于查询输出设备是否为网格或位图。如果输出设备是基于网格的（例如“tty”终端或仅具有一个固定字体的手机显示器），则值将为`1`。否则，值将为`0`。'
- en: Audio and video playback control
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频和视频播放控制
- en: As we saw in the last chapter, integrating audio and video assets with basic
    controls into and HTML5 document is extremely easy. But if you intend to use your
    multimedia in other forms than just a straightforward video playback element,
    you will need to understand the properties available for custom playback code
    integration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，将音频和视频资产与基本控件集成到HTML5文档中非常容易。但是，如果您打算以除了直接视频播放元素之外的其他形式使用多媒体，您需要了解用于自定义播放代码集成的可用属性。
- en: Preloading
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载
- en: By default, when an audio or video element is displayed in a HTML5 document,
    the source asset declared within it will be preloaded to allow for instantaneous
    playback when the user initiates the player. Assets will be preloaded only as
    far as the browsers deems necessary to enable fluid uninterrupted playback. To
    override this setting, we can use the `preload` parameter within the audio element
    to declare what we would like to be preloaded when a user views our page.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在 HTML5 文档中显示音频或视频元素时，其中声明的源资产将被预加载，以便在用户启动播放器时进行即时播放。资产将仅在浏览器认为必要的情况下进行预加载，以实现流畅的不间断播放。要覆盖此设置，我们可以在音频元素中使用`preload`参数来声明用户查看页面时希望预加载的内容。
- en: 'Setting the preload parameter to `auto` will preload the entire audio upon
    page load and could be a useful addition to any audio you are almost certain a
    user will watch at some point after the page loads. With the `preload` parameter
    set, our audio element would look something like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将`preload`参数设置为`auto`将在页面加载时预加载整个音频，并且可能是用户在页面加载后某个时刻几乎肯定会观看的任何音频的有用补充。使用设置了`preload`参数后，我们的音频元素将如下所示：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Aside from preloading everything, we can also preload absolutely nothing by
    setting `preload="none"` rather than `auto`. Removing preloading from audio will
    allow users to surf your pages without the need for unnecessary audio downloads
    but will result in longer loading times for audio to player once the user initiates
    the audio playback. Finally we can also just load audio metadata when preloading
    by setting `preload="metatdata"`. This will allow the audio element to view what
    data it is about to load, which can be very useful when dynamically adding audio
    into an audio element and requiring the need to verify if it is fit for playback
    before attempting to do so.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预加载所有内容，我们还可以通过设置`preload="none"`而不是`auto`来完全不预加载任何内容。从音频中删除预加载将允许用户在不需要进行不必要的音频下载的情况下浏览您的页面，但会导致用户启动音频播放后加载时间更长。最后，我们还可以通过设置`preload="metadata"`在预加载时仅加载音频元数据。这将允许音频元素查看它即将加载的数据，这在动态添加音频到音频元素并在尝试播放之前需要验证其是否适合播放时非常有用。
- en: Autoplay
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动播放
- en: As described in [Chapter 2](ch02.html "Chapter 2. Preparing for the Battle"),
    *Preparing for the Battle*, with the `autoplay` setting appended to a video element,
    the video will begin to play the moment it is able to do so without the need to
    stop the video for further buffering. Unlike many of the other element parameters
    in HTML, the `autoplay` parameter does not require a value. So just appending
    `autoplay` to the element will be enough to do the job. It is worth keeping in
    mind that the `autoplay` setting will be ignored when loaded on almost all mobile
    browsers. Mobile browsers tend to ignore this setting in an attempt to conserve
    bandwidth on a wireless connection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](ch02.html "第2章。准备战斗")*准备战斗*中所述，将`autoplay`设置附加到视频元素后，视频将在能够播放而无需停止视频进行进一步缓冲时开始播放。与HTML中许多其他元素参数不同，`autoplay`参数不需要值。因此，只需将`autoplay`附加到元素即可完成任务。值得注意的是，几乎所有移动浏览器加载时都会忽略`autoplay`设置。移动浏览器倾向于忽略此设置，以节省无线连接的带宽。
- en: Looping
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: With the loop setting appended to the audio element, the video will restart
    every time is finishes. Like the `autoplay` parameter, the `loop` parameter does
    not require a value. If you only wanted a video to loop a specific number of times,
    you can either watch how many times its loops with the `loop` parameter set and
    then remove it when necessary, or control the entire playback from JavaScript
    to control the loop count without the loop parameter in the video element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将循环设置附加到音频元素后，视频将在每次完成时重新开始。与`autoplay`参数一样，`loop`参数不需要值。如果您只想让视频循环播放特定次数，可以使用设置`loop`参数并在必要时删除它，或者从JavaScript控制整个播放以控制视频元素中的循环计数而不使用循环参数。
- en: Sound effects
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音效
- en: 'Playing a sound effect at a specific moment can be accomplished in a number
    of ways with the use of the HTML5 audio element and JavaScript. In its simplest
    form, playing sound effects can be implemented as done the following code example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定时刻播放音效可以通过使用HTML5音频元素和JavaScript的多种方式来实现。在其最简单的形式中，播放音效可以实现为以下代码示例所示的方式。
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the audio element is created inside the HTML document body, we set the
    `preload="auto"` which will make sure the audio is preloaded completely as soon
    as possible. We do this so there is no latency when the sound is needed during
    the effect event. The audio element is also given an ID to enable referencing
    in JavaScript a couple line down. With the window load event listener, we wait
    for page load then apply an event listener to any `mousedown` event anywhere in
    the browser window. When this fires, we select our audio element by ID and call
    the built in `play()` method resulting in the audio playback on every click of
    the browser window.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当音频元素在HTML文档主体内创建时，我们设置`preload="auto"`，这将确保音频尽快完全预加载。我们这样做是为了在需要音效时没有延迟。音频元素还被赋予一个ID，以便在JavaScript中引用。通过窗口加载事件监听器，我们等待页面加载，然后对浏览器窗口中的任何`mousedown`事件应用事件监听器。当这发生时，我们通过ID选择我们的音频元素，并调用内置的`play()`方法，从而在每次单击浏览器窗口时播放音频。
- en: Media playback manipulation
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体播放操作
- en: 'Aside from the `play(`) method in the preceding example, JavaScript has the
    accessibility to control much more of the audio and video element directly. Audio
    volume can be set as a value between `0` and `1` as shown in the following example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面示例中的`play()`方法外，JavaScript还可以直接控制音频和视频元素的许多其他方面。如下例所示，音频音量可以设置为`0`到`1`之间的值。
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also gather all the stats on the element by utilizing the following
    exposed objects within it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用其中的以下公开对象来收集元素的所有统计信息：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Reading local files with the File API
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件API读取本地文件
- en: Another feature that brings HTML5 content into a more application-like feature
    set is the addition of the File API. Users can now interact with their local content
    on a much more in depth level than ever before. Users can import files in the
    traditional HTML form manner or now just drag the file into specified drop zones
    in your HTML5 layouts. Once a file has been submitted to the web page by the user,
    your JavaScript File API usage can allow you to view, edit, and manipulate the
    file data prior to ever submitting it to the server. We will dig deeper into the
    the File API in many of the examples in chapters to come.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将HTML5内容带入更类似应用程序的功能集的另一个功能是添加文件API。用户现在可以以比以往更深入的方式与本地内容进行交互。用户可以以传统的HTML表单方式导入文件，或者现在只需将文件拖放到HTML5布局中指定的拖放区域。一旦用户向网页提交了文件，您的JavaScript文件API使用可以允许您在将文件提交到服务器之前查看、编辑和操作文件数据。我们将在接下来的章节中深入探讨文件API的许多示例中。
- en: Web Workers
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Workers
- en: In the past when executing processor intensive JavaScript, browsers would often
    tend to freeze until the processing had been completed and the results were returned.
    With the advent of HTML5 Web Workers, you can now execute your processor intensive
    JavaScript code as a background process that will not affect the performance of
    the active document. Users will be able to continue using the site as intended
    as they wait for the Web Worker to complete its jobs in the background.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当执行处理器密集型JavaScript时，浏览器经常会在处理完成并返回结果之前冻结。随着HTML5 Web Workers的出现，您现在可以将处理器密集型的JavaScript代码作为后台进程来执行，这不会影响活动文档的性能。用户将能够在等待Web
    Worker在后台完成其工作时继续使用网站。
- en: 'To easily check if a user''s browser has support for HTML5 Web Workers, we
    can check if the type of the `Worker` object is undefined or not:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要轻松检查用户的浏览器是否支持HTML5 Web Workers，我们可以检查`Worker`对象的类型是否未定义或不是：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Depending on whether the browser supports the usage of Web Workers, we can
    easily create a new worker at anytime by instantiating a new `Worker` object and
    a reference to its JavaScript source:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据浏览器是否支持Web Workers的使用，我们可以随时通过实例化一个新的`Worker`对象和其JavaScript源的引用来轻松创建一个新的worker：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding example, we created a new worker and referenced it to the
    source within the `worker.js` file. The next step is to create the event listener
    for when the worker posts an update. To create this listener, we create a function
    on the `onmessage` property and retrieve the message from the `event.data` property:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个新的worker，并将其引用到`worker.js`文件中的源代码。下一步是为当worker发布更新时创建事件侦听器。为了创建这个侦听器，我们在`onmessage`属性上创建一个函数，并从`event.data`属性中检索消息：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The code within the worker can be anything, although it makes the most sense
    for it to be something that would normally freeze the browser for a short period
    of time. Regardless of what your worker is doing, to enable the callback to your
    code you will use the `postMessage` built-in function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: worker中的代码可以是任何内容，尽管最合理的做法是使其成为通常会在短时间内冻结浏览器的内容。无论您的worker正在做什么，为了使回调到您的代码生效，您将使用内置的`postMessage`函数：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since your Web Worker code is located in external files, it will not have access
    to the window, document or parent object in its JavaScript source.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的Web Worker代码位于外部文件中，因此它将无法访问其JavaScript源中的window、document或parent对象。
- en: You will find more usage of Web Workers in this chapter's example files as well
    as some of the examples in chapters to come when we start building bigger JavaScript
    projects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例文件中，以及在我们开始构建更大的JavaScript项目时，您将在即将到来的章节中找到更多Web Workers的用法。
- en: WebSockets
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSockets
- en: Adding server-side communication to your web pages to enable features such as
    multiuser interactivity or push notifications is becoming more and more popular
    with the advent of WebSockets. To put it in a nutshell, WebSockets fill the void
    when you need a server to communicate with the client without requiring the client's
    request.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 向您的网页添加服务器端通信以启用诸如多用户交互或推送通知等功能，随着WebSockets的出现越来越受欢迎。简而言之，当您需要服务器与客户端进行通信而不需要客户端的请求时，WebSockets填补了这一空白。
- en: When building Flash applications, typically one would use technologies and frameworks
    such as **Real-Time Media Flow Protocol** (**RTMFP**) or SmartFoxServer ([http://www.smartfoxserver.com](http://www.smartfoxserver.com))
    to allow for server-based multiuser applications. This concept is now available
    with the use of WebSockets and is a true testament to how far the development
    of the HTML specification has come.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Flash应用程序时，通常会使用诸如**实时媒体流协议**（**RTMFP**）或SmartFoxServer（[http://www.smartfoxserver.com](http://www.smartfoxserver.com)）等技术和框架，以实现基于服务器的多用户应用程序。现在，通过使用WebSockets，这个概念已经可以实现，这真正证明了HTML规范的发展已经走了很远。
- en: In the upcoming chapters, we will continue to look into more thorough examples
    of WebSockets in action, as well as some other interesting methods for connecting
    users viewing your HTML5 content, such as Socket.io ([http://socket.io](http://socket.io)),
    Node.js ([http://nodejs.org](http://nodejs.org)), and Google V8 ([http://code.google.com/p/v8](http://code.google.com/p/v8)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的章节中，我们将继续深入研究WebSockets的更多示例，以及一些其他有趣的方法，用于连接查看您的HTML5内容的用户，例如Socket.io（[http://socket.io](http://socket.io)）、Node.js（[http://nodejs.org](http://nodejs.org)）和Google
    V8（[http://code.google.com/p/v8](http://code.google.com/p/v8)）。
- en: The Canvas element
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas元素
- en: We can't finish this chapter without at least beginning to make mention of the
    HTML5 Canvas element. The Canvas allows developers to use the Canvas 2D Drawing
    API to draw graphics on the fly into an empty controllable area. From the perspective
    of a Flash developer, the easiest way to understand the Canvas elements feature
    set is that it uses similar features to the ActionScript 3 Drawing and Graphics
    API within an empty area in the HTML layout which is very similar to the Flash
    Stage.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有至少提及HTML5 Canvas元素的情况下，我们无法完成本章。Canvas允许开发人员使用Canvas 2D绘图API将图形实时绘制到一个可控制的空白区域中。从Flash开发人员的角度来看，理解Canvas元素的功能集最简单的方法是，它使用类似于ActionScript
    3绘图和图形API的功能，在HTML布局中的一个空白区域中，这与Flash舞台非常相似。
- en: 'To better understand what all the fuss is about, let''s create a simple drawing
    application with the use of the Canvas. To begin, we need to append the Canvas
    element into the body of our HTML document. There is no content required to be
    inside the element''s tags, as it will only be viewable when the user is attempting
    to view this content from a browser without the support for the Canvas element:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一切的意义，让我们使用Canvas创建一个简单的绘图应用程序。首先，我们需要将Canvas元素附加到HTML文档的主体中。元素标签内不需要包含任何内容，因为只有在用户尝试从不支持Canvas元素的浏览器中查看此内容时才能看到它：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Two important additions have been appended to the Canvas in this example and
    they are the element ID, which will be used in JavaScript in the following steps,
    as well as the width and height declaration. Without the width and height set
    in the element, most browsers will render the Canvas at 300px x 150px. To aid
    us in the development of this application, a 1px border has been added to the
    Canvas to allow us to see exactly where its boundaries are within the browser
    window. Finally as mentioned, the internal content within the Canvas element will
    only display if the element is not supported within the browser rendering it.
    If the application has been also written as a Flash application, the object embed
    for the Flash SWF could be used in place of the text warning we are using in this
    example.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Canvas中添加了两个重要的内容，它们是元素ID，将在接下来的步骤中在JavaScript中使用，以及宽度和高度声明。如果没有在元素中设置宽度和高度，大多数浏览器将以300px
    x 150px渲染Canvas。为了帮助我们开发这个应用程序，在Canvas中添加了1px的边框，以便我们准确地看到它在浏览器窗口中的边界。最后，正如前面提到的，Canvas元素内部的内容只有在浏览器中不支持该元素时才会显示。如果应用程序也被编写为Flash应用程序，Flash
    SWF的对象嵌入可以用来替代我们在这个例子中使用的文本警告。
- en: 'The next step is to set up the reference to our Canvas and its 2D context within
    JavaScript, and since we set an ID on our element, we can easily reference it
    to a variable within our code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在JavaScript中设置对我们的Canvas及其2D上下文的引用，由于我们在元素上设置了一个ID，我们可以在我们的代码中轻松地引用它到一个变量中：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With our Canvas referenced and mouse event listeners set up to watch for when
    the user has the mouse button down, let us finalize this example by writing our
    `onMouseMove` function to draw a line when the `isDrawing` variable is `true`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用我们的Canvas并设置鼠标事件监听器来监视用户何时按下鼠标按钮，让我们通过编写我们的`onMouseMove`函数来完成这个例子，以在`isDrawing`变量为`true`时画一条线：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you notice, the initial code in our `onMouseMove` function is taken from
    our 3D Transforms example and allows us to read the mouse X and Y position on
    the different modern browsers. The condition following the mouse position lookup
    should look semi-familiar if you had used the Drawing API in ActionScript 3\.
    Assuming the mouse is down, we draw a line to the current mouse position and set
    the default stroke on it. In this case, the default stroke is a 1px black solid
    line. When the mouse is not down, we simply move the context to the mouse position
    but do not draw any lines. This allows us to constantly reset and wait for a new
    line to be started. When tested in the browser, this example will look something
    like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，我们`onMouseMove`函数中的初始代码取自我们的3D变换示例，并允许我们在不同的现代浏览器上读取鼠标X和Y位置。如果您曾在ActionScript
    3中使用过绘图API，那么跟随鼠标位置查找的条件应该看起来有点熟悉。假设鼠标按下，我们会画一条线到当前鼠标位置，并设置默认的描边。在这种情况下，默认的描边是1px的黑色实线。当鼠标未按下时，我们只是将上下文移动到鼠标位置，但不画任何线条。这样可以让我们不断重置并等待开始新的线条。在浏览器中测试时，这个例子会看起来像这样：
- en: '![The Canvas element](img/3325OT_03_14.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas元素](img/3325OT_03_14.jpg)'
- en: This example really is only the start of what is available to developers but
    hopefully gives you an idea of how it works. We will continue to look into the
    Canvas element in the next chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只是开发人员可以使用的开始，但希望能让您了解它是如何工作的。我们将在下一章继续研究Canvas元素。
- en: Stage3D versus WebGL
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stage3D与WebGL
- en: Before we end this chapter, some mention should be made about the availability
    of WebGL and its similarities and differences to Stage3D in Adobe Flash. WebGL
    is a cross-platform web standard which allows developers to create and manipulate
    low-level 3D graphics, bringing plugin-free 3D development to the Web. WebGL can
    be implemented and viewed in all modern browsers, an exception is Internet Explorer.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，应该提到一些关于WebGL的可用性以及它与Adobe Flash中的Stage3D的相似之处和不同之处。WebGL是一个跨平台的Web标准，允许开发人员创建和操作低级3D图形，将无插件的3D开发带到Web上。WebGL可以在所有现代浏览器中实现和查看，唯一的例外是Internet
    Explorer。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Take note that it seems Microsoft is planning to release Internet Explorer 11
    with WebGL support.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，微软似乎计划发布支持WebGL的Internet Explorer 11。
- en: The key aspects of WebGL and Stage 3D are that they both support the use of
    hardware acceleration. This can drastically increase the performance of graphical
    processing loads when viewing content on devices and browsers with proper support.
    Although this book doesn't contain the room to dive too deep into the use of WebGL,
    we will look at a couple of frameworks and libraries which support and use it
    in [Chapter 6](ch06.html "Chapter 6. HTML5 Frameworks and Libraries"), *HTML5
    Frameworks and Libraries*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL和Stage 3D的关键方面是它们都支持使用硬件加速。这可以在设备和浏览器上查看内容时大大提高图形处理负载的性能，前提是有适当的支持。尽管本书没有足够的空间深入研究WebGL的使用，但我们将在[第6章](ch06.html
    "第6章。HTML5框架和库")中查看一些支持和使用它的框架和库，*HTML5框架和库*。
- en: Tip
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information and to see if your current web browser supports the use
    of WebGL, head over to [http://get.webgl.org,](http://get.webgl.org, ) the WebGL
    public wiki ([http://www.khronos.org/webgl/wiki](http://www.khronos.org/webgl/wiki)),
    or view some intriguing examples at [http://www.khronos.org/webgl/wiki/Demo_Repository](http://www.khronos.org/webgl/wiki/Demo_Repository).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息并查看您当前的网络浏览器是否支持使用WebGL，请访问[http://get.webgl.org](http://get.webgl.org)，WebGL公共维基([http://www.khronos.org/webgl/wiki](http://www.khronos.org/webgl/wiki))，或在[http://www.khronos.org/webgl/wiki/Demo_Repository](http://www.khronos.org/webgl/wiki/Demo_Repository)上查看一些有趣的示例。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Although we have covered a ton of interesting features during the course of
    this chapter, there are still many very cool additions to HTML5 we will be looking
    at in the upcoming chapters. The key thought to take away from what we have covered
    so far is how the relationships between features in Flash and HTML5 are similar
    yet different at the same time. Understanding what technology will be able to
    allow you to develop your applications in the best possible manner is a key trait
    for any good developer. In the next chapter, we will dig deeper into the use of
    JavaScript and how it relates to ActionScript 3 when programming in an object-oriented
    manner.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本章的课程中我们已经涵盖了许多有趣的功能，但在接下来的章节中，我们还将看到许多非常酷的HTML5新增功能。到目前为止，我们所涵盖的关键思想是Flash和HTML5之间的特性关系在某种程度上是相似的，但又有所不同。了解什么样的技术能够让你以最佳方式开发应用程序是任何优秀开发者的关键特质。在下一章中，我们将深入探讨JavaScript的使用以及在面向对象编程时与ActionScript
    3的关系。
