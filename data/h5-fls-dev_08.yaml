- en: Chapter 8. Exporting to HTML5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。导出到HTML5
- en: In [Chapter 5](ch05.html "Chapter 5. Code Once, Release Everywhere"), *Code
    Once, Release Everywhere,* we spent some time learning about the CreateJS JavaScript
    framework as well as the CreateJS Toolkit plugin for Flash Professional CS6 ([http://www.adobe.com/ca/products/flash/flash-to-html5.html](http://www.adobe.com/ca/products/flash/flash-to-html5.html))
    and how they can easily integrate your pre-existing knowledge of Flash development
    directly into HTML5 projects. Over the last year, Adobe has adopted this framework
    to be the official way to work with Flash-based assets in your HTML5 projects.
    That being said, there are actually a number of other ways that you can achieve
    somewhat of the same effect when attempting to directly move your Flash-based
    applications and games into pure HTML5\. In this chapter, we will continue to
    look at some of the third-party tools and applications that may aid you in your
    asset and code development flow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。一次编码，到处发布")中，*一次编码，到处发布*，我们花了一些时间学习了CreateJS JavaScript框架以及Flash
    Professional CS6的CreateJS Toolkit插件（[http://www.adobe.com/ca/products/flash/flash-to-html5.html](http://www.adobe.com/ca/products/flash/flash-to-html5.html)），以及它们如何可以轻松地将您对Flash开发的现有知识直接整合到HTML5项目中。在过去的一年里，Adobe已经采用了这个框架作为在HTML5项目中处理基于Flash的资产的官方方式。也就是说，实际上有许多其他方法可以在尝试直接将基于Flash的应用程序和游戏移植到纯HTML5时实现类似的效果。在本章中，我们将继续探讨一些可能帮助您进行资产和代码开发流程的第三方工具和应用程序。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Automatically generating HTML5 projects from a Flash SWF with Google's Swiffy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google的Swiffy从Flash SWF自动生成HTML5项目
- en: Manually converting animated assets to HTML5-ready sprite sheets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动将动画资产转换为HTML5准备的精灵表
- en: Writing your JavaScript libraries and frameworks in ActionScript 3 with Jangaroo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jangaroo在ActionScript 3中编写您的JavaScript库和框架
- en: Targeting all of your platform development needs in a single language source
    with Haxe
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Haxe在单一语言源中定位您所有的平台开发需求
- en: Building robust web applications using Google's Dart programming language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google的Dart编程语言构建强大的Web应用程序
- en: Google Swiffy
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Swiffy
- en: The Swiffy project created by Google ([https://www.google.com/doubleclick/studio/swiffy](https://www.google.com/doubleclick/studio/swiffy))
    is one of the easiest ways to port your pre-existing Flash applications into HTML5
    projects. The aim of the project is to take in the already compiled Flash SWF
    files, and convert the data within into a JSON object with SVG vector animation
    data. The resulting Swiffy compiled JavaScript, can then be run directly within
    a modern web browser with the aid of the Google Swiffy Runtime.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由Google创建的Swiffy项目（[https://www.google.com/doubleclick/studio/swiffy](https://www.google.com/doubleclick/studio/swiffy)）是将您现有的Flash应用程序移植到HTML5项目中的最简单的方法之一。该项目的目标是接收已经编译的Flash
    SWF文件，并将其中的数据转换为带有SVG矢量动画数据的JSON对象。然后，生成的Swiffy编译的JavaScript可以在现代Web浏览器中直接运行，借助Google
    Swiffy Runtime的帮助。
- en: 'Although this project is still in Beta and has many limitations, Swiffy supports
    Flash projects written in both ActionScript 2 and ActionScript 3 allowing you
    to possibly avoid having to ever think about manually converting your AS2 to AS3
    projects manually. The support for more complex Flash assets within your projects
    is growing at a steady rate, however, it will be worth your time to check out
    the current browser and feature-support lists on the project website prior to
    usage as it may not fully cover the application you intend to convert ([https://www.google.com/doubleclick/studio/swiffy/gettingstarted.html](https://www.google.com/doubleclick/studio/swiffy/gettingstarted.html)).
    ActionScript 3 support within Swiffy is limited to using specific methods within
    specific classes to be sure the conversion can properly take place. At the time
    of writing this book, the ActionScript 3 support within Swiffy contains the following
    limitations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该项目仍处于Beta阶段，并且有许多限制，但Swiffy支持用ActionScript 2和ActionScript 3编写的Flash项目，使您有可能避免手动将AS2转换为AS3项目。对于项目中更复杂的Flash资产的支持正在稳步增长，但是在使用之前，最好花时间查看项目网站上的当前浏览器和功能支持列表，因为它可能无法完全覆盖您打算转换的应用程序（[https://www.google.com/doubleclick/studio/swiffy/gettingstarted.html](https://www.google.com/doubleclick/studio/swiffy/gettingstarted.html)）。Swiffy中的ActionScript
    3支持仅限于在特定类中使用特定方法，以确保转换可以正确进行。在撰写本书时，Swiffy中的ActionScript 3支持包括以下限制：
- en: Exception handling is not supported
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持异常处理
- en: Optional arguments are not supported
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持可选参数
- en: XML handling is not supported
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持XML处理
- en: The order of object initialization and construction is not constant
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象初始化和构造的顺序不是恒定的
- en: You can find the full, up-to-date documentation for current ActionScript 3 support
    on the Swiffy ActionScript 3 Support page on the project website (https://www.google.com/doubleclick/studio/swiffy/actionscript3.html).
    If you head over to the ActionScript Support page, you can get a better sense
    of what classes and methods can be used within your Flash applications. If your
    application exceeds the supported properties listed in the project support page,
    there is a very high likelihood of your application not converting properly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目网站的Swiffy ActionScript 3支持页面上找到当前ActionScript 3支持的完整和最新文档（https://www.google.com/doubleclick/studio/swiffy/actionscript3.html）。如果您转到ActionScript支持页面，您可以更好地了解哪些类和方法可以在您的Flash应用程序中使用。如果您的应用程序超出了项目支持页面中列出的支持属性，那么您的应用程序很可能无法正确转换。
- en: How does Swiffy work?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swiffy是如何工作的？
- en: 'To get an idea of how Swiffy works and to see the output and limitations first
    hand, let''s create a simple Flash application and convert it to HTML5 and view
    what happens. We will start with what is possibly the best case scenario for Swiffy
    conversions. Our Flash project will contain assets and animations completely created
    from within the Flash Professional IDE and avoid the use of any ActionScript for
    the time being. To make this example a little closer to a real-world example,
    we can pretend this Flash application is a pre-existing banner ad or other simple
    Flash movie which we would like to display on mobile devices or any other devices
    that don''t have access to the Adobe Flash Player:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解Swiffy的工作原理，并亲自看到输出和限制，让我们创建一个简单的Flash应用程序，将其转换为HTML5并查看结果。我们将从可能是Swiffy转换的最佳案例开始。我们的Flash项目将包含完全在Flash
    Professional IDE内创建的资产和动画，并暂时避免使用任何ActionScript。为了使这个示例更接近真实世界的情况，我们可以假装这个Flash应用程序是一个现有的横幅广告或其他简单的Flash电影，我们希望在移动设备或其他没有访问Adobe
    Flash Player的设备上显示。
- en: '![How does Swiffy work?](img/3325OT_08_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Swiffy是如何工作的？](img/3325OT_08_01.jpg)'
- en: 'As ugly as the preceding example is, it actually represents some important
    factors to test. First off, we have a circle which has been motion tweened around
    the stage. Second, we have a rectangle filled with a gradient background color,
    again in the vector format. Finally, we have two lines of text: one is a simple
    use of the **Times New Roman** font and the other is a test of a more complex
    font such as **Wingdings**. Just like the two shapes, the text will be animated
    across the stage upon playback. The idea with this test is to see how well Swiffy
    deals with the extremely common SWF setup of just timeline modified elements.
    To make this test less complicated, we will also leave out any ActionScript and
    assume the timeline will loop infinitely.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子很丑陋，但它实际上代表了一些重要的测试因素。首先，我们有一个在舞台上运动的圆。其次，我们有一个填充有渐变背景颜色的矩形，同样是矢量格式。最后，我们有两行文本：一行是对**Times
    New Roman**字体的简单使用，另一行是对更复杂字体如**Wingdings**的测试。就像两个形状一样，文本在播放时将在舞台上进行动画。这个测试的想法是看看Swiffy如何处理只有时间轴修改元素的极为常见的SWF设置。为了使这个测试不那么复杂，我们还将省略任何ActionScript，并假设时间轴将无限循环。
- en: With the timeline created, we can go ahead and output a SWF of this movie into
    our project directory. All Swiffy requires to generate its Web-ready output is
    the single SWF created from your Flash project, so open up a web browser and head
    over to the Swiffy project website ([https://www.google.com/doubleclick/studio/swiffy](https://www.google.com/doubleclick/studio/swiffy)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了时间轴后，我们可以将这部电影的SWF输出到我们的项目目录中。Swiffy生成Web准备好的输出所需的唯一SWF来自于你的Flash项目创建的单个SWF，所以打开一个Web浏览器，前往Swiffy项目网站（[https://www.google.com/doubleclick/studio/swiffy](https://www.google.com/doubleclick/studio/swiffy)）。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At the time of writing this book, Swiffy will allow you to upload any SWF file
    that equals or is less than 1 MB in size.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Swiffy允许你上传任何大小等于或小于1MB的SWF文件。
- en: 'When you are all ready to convert your SWF, use the form on the front page
    of the project website to upload your SWF to the Swiffy servers. It should only
    take a moment or two for the results to appear, as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好转换你的SWF时，使用项目网站首页上的表单将你的SWF上传到Swiffy服务器。结果应该很快就会出现，就像下面的截图所示：
- en: '![How does Swiffy work?](img/3325OT_08_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Swiffy是如何工作的？](img/3325OT_08_02.jpg)'
- en: The results should display something like the preceding screenshot. A preview
    of the converted SWF will appear in Web-ready display as well as all of the output
    messages and links to download the output. The supplied QR code on every SWF conversion
    page will allow you to easily test the generated source on a mobile device to
    verify it is working properly. As displayed on the output page, you can easily
    download the HTML document along with all the other data by right-clicking on
    the link to the external output example (in this case, `Banner-Test.html`) and
    save the referenced page that way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该显示类似于前面的截图。转换后的SWF的预览将显示在Web准备好的显示中，以及所有的输出消息和下载输出的链接。每个SWF转换页面上提供的QR码将允许您轻松地在移动设备上测试生成的源代码，以验证它是否正常工作。如输出页面所示，您可以通过右键单击外部输出示例的链接（在本例中为`Banner-Test.html`）轻松下载HTML文档以及所有其他数据，并以这种方式保存引用页面。
- en: Examining Swiffy-generated code
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查Swiffy生成的代码
- en: 'With the content saved onto your local machine, let''s take a quick moment
    to review exactly what has been done, and how we could transplant this asset into
    a pre-existing website. After opening up the HTML file, the first thing to take
    note of is the use of external libraries:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将内容保存到本地计算机后，让我们花点时间来审查究竟做了什么，以及我们如何将这个资产移植到现有的网站中。打开HTML文件后，首先要注意的是使用外部库：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This JavaScript call is importing the Google Swiffy runtime from the Google
    file server and is required to properly display the data following it. Just like
    CreateJS, the code that has been created is a hybrid of JavaScript and needs a
    final interpreter in order to properly function. This is a critically important
    thing to note about Swiffy. Including the `runtime.js` file is an absolute requirement
    to your project provided any assets generated from Swiffy were added.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JavaScript调用是从Google文件服务器导入Google Swiffy运行时，并且需要正确显示其后的数据。就像CreateJS一样，已创建的代码是JavaScript和需要最终解释器才能正常运行的混合体。这是关于Swiffy的一个非常重要的事情。包括`runtime.js`文件是项目的绝对要求，只要添加了从Swiffy生成的任何资产。
- en: 'Directly after the Swiffy runtime inclusion, you will notice a huge blob of
    text contained in more HTML `<script>` tags. The following is a snippet of what
    it looks like:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swiffy运行时包含之后，你会注意到更多HTML `<script>`标签中包含了大量文本。以下是它的一部分：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This data is the JavaScript object which represents all of the data from your
    assets and animations included in the original SWF. Since our example contained
    no Bitmap images, and everything within it was vector based, the entire application
    has been compiled down to 100 percent code and can be displayed with a couple
    lines of further JavaScript:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据是JavaScript对象，代表了原始SWF中包含的所有资产和动画的数据。由于我们的例子中没有包含任何位图图像，而且其中的一切都是基于矢量的，整个应用程序已经被编译为100%的代码，并且可以用几行进一步的JavaScript来显示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finding Swiffy's limits
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现Swiffy的限制
- en: 'All of this is fine and dandy until we start to make things a little more complicated.
    In the next example, I have created a very simple game in ActionScript 3\. The
    idea of the game is to control the position of the box on the stage by moving
    your mouse around the visible stage. As time passes, your box will begin to grow
    and take up more space on the stage. The goal of the game is to go as long as
    possible without letting your box touch any of the randomly moving black dots.
    For simplicity, I have not included any user interface in this game. All of the
    results and output will just be sent to the web browser developer console for
    the time being. As always, you can check out the example in the working form as
    it is contained in the downloadable chapter example files:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好，直到我们开始让事情变得更加复杂。在下一个例子中，我创建了一个非常简单的ActionScript 3游戏。游戏的想法是通过移动鼠标来控制舞台上方框的位置。随着时间的推移，你的方框会开始增长并占据舞台上更多的空间。游戏的目标是尽可能长时间地让你的方框不要碰到任意移动的黑点。为简单起见，我在这个游戏中没有包含任何用户界面。所有的结果和输出都将暂时发送到Web浏览器的开发者控制台。你可以在可下载的章节示例文件中找到这个例子的工作形式。
- en: '![Finding Swiffy''s limits](img/3325OT_08_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![发现Swiffy的限制](img/3325OT_08_03.jpg)'
- en: 'Yes, it is extremely crude, but it covers many common aspects of Flash applications
    in a manageable number of lines of code, which is perfect for our purposes of
    demonstration. As mentioned, there is no user interface in the game as any of
    the game output will just be sent to the Flash output debug window. Let''s take
    a look at the code before going any further so you can take note of the specific
    features, classes, and variable types that have been utilized:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这非常粗糙，但它涵盖了Flash应用程序中许多常见的方面，并且用可管理的代码行数，非常适合我们的演示目的。如前所述，游戏中没有用户界面，任何游戏输出都将被发送到Flash输出调试窗口。在继续之前，让我们先看一下代码，这样你就可以注意到已经使用的特定功能、类和变量类型。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you are interested in actually compiling the source of this application,
    you can find all of the files to open it within Flash Builder as an ActionScript
    project. Compile the application to a SWF and test the application locally to
    confirm it is working. If all is well, let''s attempt to send this file to Swiffy
    and see what happens:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣实际编译这个应用程序的源代码，你可以找到所有的文件，在Flash Builder中打开它作为一个ActionScript项目。将应用程序编译为SWF并在本地测试应用程序以确认它是否正常工作。如果一切顺利，让我们尝试将这个文件发送给Swiffy，看看会发生什么：
- en: '![Finding Swiffy''s limits](img/3325OT_08_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![发现Swiffy的限制](img/3325OT_08_04.jpg)'
- en: Provided you followed the steps properly, Swiffy will fail when attempting to
    convert this SWF and generate the error list in the previous screenshot. Let take
    a quick look at what went wrong, the limitations, and workarounds that could be
    put into place to correct the issue. To begin, the first error listed the notice
    that arrays are not supported by the Swiffy compiler. In our application's case,
    we used an array to contain all of the bad-guy instances in a single global variable.
    Without the use of arrays in this or any application, the requirement to manage
    data in a more primitive manner is required. This issue alone can be the deciding
    factor when deciding to use Swiffy to do your conversion. Although there are many
    ways to get around this issue, the fact of the matter is, if you have an application
    that is littered with arrays, chances are the current version of Swiffy will not
    be able to help you. Regardless of all that bad news, let's move on to the second
    issue. Not surprisingly, the `hitTestObject` method, which is common in ActionScript
    3 development, is not supported by the compiler either.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你正确地按照步骤操作，当尝试转换这个SWF并生成前一个截图中的错误列表时，Swiffy会失败。让我们快速看一下出了什么问题，限制以及可以采取的解决方法。首先，第一个错误列出了数组不受Swiffy编译器支持的通知。在我们的应用程序中，我们使用数组来包含所有坏人实例在一个全局变量中。在这个或任何应用程序中，如果不使用数组来管理数据，就需要以更原始的方式来管理数据。这个问题本身可以成为决定是否使用Swiffy进行转换的关键因素。尽管有许多方法可以解决这个问题，事实是，如果你的应用程序中到处都是数组，那么当前版本的Swiffy很可能无法帮助你。不管有多少坏消息，让我们继续看第二个问题。毫不奇怪，常见的ActionScript
    3开发中的`hitTestObject`方法也不被编译器支持。
- en: 'This easy-to-use method can be a life saver when simple collision detection
    is required in Flash development, but since there is no direct JavaScript equivalent
    to convert it to. Again, this can be compensated for but the resulting code would
    be far larger then calling a single method as one is used to in typical ActionScript
    3 development. So this can be considered an issue, but not a dead end provided
    your collision detection is only using the supported methods and properties. The
    final error listed in our conversion attempt was the use of the `Sprite.graphics`
    class. If you recall, the code example specifically used MovieClips rather than
    Sprites, as Sprites are not supported by the Swiffy compiler. However, unlike
    the `Player` object, which was originally created within the Flash Professional
    IDE and saved into a SWC, the bad guy objects were created within the code with
    the use of the internal ActionScript 3 Graphics API:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种易于使用的方法在Flash开发中需要简单的碰撞检测时可以成为救命稻草，但由于没有直接的JavaScript等效方法来转换它。再次弥补这一点是可以的，但结果代码会比在典型的ActionScript
    3开发中调用单个方法要大得多。因此，这可能被视为一个问题，但并不是一个死胡同，只要你的碰撞检测只使用支持的方法和属性。我们转换尝试中列出的最终错误是使用`Sprite.graphics`类。如果你还记得，代码示例明确使用了MovieClips而不是Sprites，因为Sprites不受Swiffy编译器支持。然而，与最初在Flash
    Professional IDE中创建并保存到SWC中的`Player`对象不同，坏人对象是在代码中使用内部ActionScript 3 Graphics
    API创建的。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These three lines are the reason for the final error. Since the `MovieClip`
    object in Flash is built on top of the `Sprite` class, the resulting error follows
    suit. Since the SWC deals with the creation of the `Player` object, no errors
    are passed for that object. However, it is worth noting that even with these errors
    fixed by removing all of the bad guys and only having a box moving around, the
    successfully converted result still displays nothing on the HTML version of the
    game. At the moment, it seems Swiffy doesn't support the use of SWC's in the ActionScript
    3 project, it is more comfortable using the old school pure Flash IDE development
    style of application development.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行是最终错误的原因。由于Flash中的`MovieClip`对象是建立在`Sprite`类之上的，所以结果错误也是如此。由于SWC处理了`Player`对象的创建，因此该对象不会出现错误。然而，值得注意的是，即使通过移除所有坏人并只让一个方块在周围移动来修复这些错误，成功转换的结果在游戏的HTML版本中仍然没有显示任何内容。目前看来，Swiffy不支持在ActionScript
    3项目中使用SWC，它更倾向于使用旧式的纯Flash IDE开发风格的应用程序开发。
- en: All of this being said, the reality is that the majority of the work Swiffy
    can reliably do for you is simple Flash applications and movie conversions, not
    your typical Flash game or application. Despite the lack for many features that
    have commonly been used in Flash development for years, Swiffy can still be a
    very handy tool for assets such as integrated website animations or advertisement
    banners.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Swiffy缺乏多年来在Flash开发中常用的许多功能，但它仍然可以成为集成网站动画或广告横幅等资产的非常方便的工具。实际上，Swiffy可靠地为你做的大部分工作是简单的Flash应用程序和电影转换，而不是你典型的Flash游戏或应用程序。
- en: Generating sprite sheets in Flash Professional CS6
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flash Professional CS6中生成精灵表
- en: If you ever intend to port or copy some of your pre-existing Flash-based timeline
    animations to a HTML5 project, you are going to have to do some conversion of
    your own. As you have seen in the examples in this book, timeline animations just
    don't exist in the HTML5 stack. Therefore, you will need to convert the animation
    sequence into a new format that can be displayed properly on the Web. One of the
    easiest options is converting the animation into a video file and using the `<video>`
    tag element to play it back. Unfortunately, converting bitmap or vector assets
    into a video file that can properly be played back on the Web will result in a
    ton of quality loss. To top that off, the video playback will be very heavy resulting
    in slower application load times. Finally, videos in HTML5 lack many important
    features such as support of alpha transparency, resulting in all of your assets
    contained in a fully visible rectangular container. To get around all of these
    issues, many web developers are turning to the tried and true method of sprite
    sheets. The concept behind sprite sheets is pretty simple. Take all of the frames
    in your animation sequence, place them all side by side on the same image (with
    a transparent background), and save the image as an uncompressed PNG file. This
    way, when loaded by a client over the Web, downloading a single file is all that
    is needed to have the entire animation sequence in memory ready for playback.
    Converting your Flash-based timeline animations into sprite sheets manually, by
    copy and pasting each frame into a PNG document, is a long a tedious undertaking.
    Thankfully, it is one undertaking you will not need to deal with as Flash Professional
    CS6 has incorporated a sprite sheet generator right in the IDE.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算将一些现有的基于Flash的时间轴动画移植或复制到HTML5项目中，你将不得不进行一些自己的转换。正如你在本书的示例中所看到的，时间轴动画在HTML5堆栈中根本不存在。因此，你需要将动画序列转换为一种新的格式，以便在Web上正确显示。最简单的选项之一是将动画转换为视频文件，并使用`<video>`标签元素进行播放。不幸的是，将位图或矢量资产转换为可以在Web上正确播放的视频文件将导致大量的质量损失。更糟糕的是，视频播放将非常沉重，导致应用加载时间变慢。最后，HTML5中的视频缺少许多重要功能，比如不支持alpha透明度，导致所有资产都包含在一个完全可见的矩形容器中。为了解决所有这些问题，许多网页开发人员正在转向经过验证的精灵表方法。精灵表背后的概念非常简单。将动画序列中的所有帧放在同一张图像上（带有透明背景），并将图像保存为未压缩的PNG文件。这样，当客户端在Web上加载时，只需下载一个文件就可以将整个动画序列加载到内存中准备播放。将基于Flash的时间轴动画手动转换为精灵表，通过将每一帧复制并粘贴到PNG文档中，是一项漫长而繁琐的工作。幸运的是，这是一项你不需要处理的工作，因为Flash
    Professional CS6在IDE中已经集成了精灵表生成器。
- en: Using the sprite sheet generator in Flash CS6 is painfully simple. The good
    folks at Adobe have managed to create a tool that will easily have you using your
    Flash animations in your HTML5 projects in minutes. Though simple to use, the
    feature can be a little hidden, so let's quickly take a look at the sprite sheet
    generator in action and place some of the results in a working HTML5 document
    to test.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash CS6中使用精灵表生成器非常简单。Adobe的工程师们成功地创建了一个工具，可以让您在几分钟内轻松地在HTML5项目中使用Flash动画。虽然使用简单，但该功能可能有点隐藏，因此让我们快速看一下精灵表生成器的操作，并将一些结果放入工作中的HTML5文档进行测试。
- en: 'For example purposes, I have created a very simple example of a Flash animation
    on the timeline which includes only three different shapes. Each shape is displayed
    for only 5 frames for a total of 15 frames of animation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，我创建了一个非常简单的Flash动画示例，时间轴上只包括三种不同的形状。每种形状仅显示5帧，总共有15帧动画：
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As always, you can find all the example files in the downloadable chapter examples.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，您可以在可下载的章节示例中找到所有示例文件。
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![在Flash Professional CS6中生成精灵表](img/3325OT_08_05.jpg)'
- en: 'Locate the MovieClip within the library of the Flash project and right-click
    on it. Reviewing the context menu displayed when right-clicking on any MovieClip,
    you will find a **Generate Sprite Sheet** option. Select this option and you will
    be presented with the new, feature rich, **Generate** **Sprite Sheet** window:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash项目的库中找到MovieClip，右键单击它。在右键单击任何MovieClip时显示的上下文菜单中，您将找到**生成精灵表**选项。选择此选项，将会出现新的、功能丰富的**生成精灵表**窗口：
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_06.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![在Flash Professional CS6中生成精灵表](img/3325OT_08_06.jpg)'
- en: Upon initial inspection, you can see every frame in your animation has automatically
    been appended to the same document and lined up in a grid format. As mentioned,
    this animation contains 15 frames, therefore, every frame has been appended to
    the sprite sheet **Preview** window and is displayed with the default configuration.
    Before saving this output, let's check out some of the options available to see
    if we can optimize this sprite sheet any further.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 初步检查时，您会看到动画中的每一帧都自动添加到同一文档中，并以网格格式排列。如前所述，该动画包含15帧，因此每帧都已添加到精灵表**预览**窗口中，并显示默认配置。在保存此输出之前，让我们查看一些可用的选项，看看是否可以进一步优化这个精灵表。
- en: We can start by getting a general overview of what we are about to export. At
    the bottom-left corner of the **Generate Sprite Sheet** window, you will find
    the details of the current MovieClip containing the frame count and duration based
    on a specific frame rate. On the right side of the window, you can see an easy-to-view
    preview of what the sprite sheet will look like when generated under the current
    configuration. Selecting the second **Preview** tab will display the animation
    running in its native form.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从对即将导出的内容进行概述开始。在**生成精灵表**窗口的左下角，您将找到当前MovieClip的详细信息，包括基于特定帧速率的帧数和持续时间。在窗口的右侧，您可以看到一个易于查看的预览，显示了在当前配置下生成的精灵表的外观。选择第二个**预览**选项卡将显示以其原生形式运行的动画。
- en: 'Below the preview window is all of the configuration properties available to
    you when exporting the animation assets and dataset. The dimensions of the exported
    image can be automatically sized by Flash or configured manually to set the available
    area where your animation frame can be placed. The image format can also be configured
    as PNG or JPG formats to allow for further compression on the exported image.
    It is recommended that you set this as PNG with no background unless required
    to allow for proper image background transparency:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览窗口下方是在导出动画资产和数据集时可用的所有配置属性。导出图像的尺寸可以由Flash自动调整，也可以手动配置以设置动画帧的可用区域。图像格式也可以配置为PNG或JPG格式，以便对导出图像进行进一步压缩。建议将其设置为PNG格式，无背景，除非需要允许正确的图像背景透明度：
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![在Flash Professional CS6中生成精灵表](img/3325OT_08_07.jpg)'
- en: 'The right size of the configuration properties contains the settings for the
    dataset export. Since the image exported for the sprite sheet will only contain
    the frame assets and no animation data, the sprite sheet will require some form
    of data in order to properly playback. You will usually have no issue when using
    the basic algorithm from the available slicing algorithms. With the basic setting,
    sprites are arranged in nice uniform rows in an easy-to-use grid layout. This
    is the optimal output setting when dealing with any simple animation. The other
    current option for algorithms is the **MaxRects** option. This option is used
    to attempt to pack the frames as tightly together as possible. The reason one
    would do this is to minimize the exported image filesize to allow for faster download
    times over an Internet connection. Once an algorithm has been selected, we can
    move on to probably the most important setting in this export window. The **Data
    format** selection allows you to set the data export format to specifically work
    with how ever you are developing your HTML5 application. Support for **The Sparrow
    Framework** for iOS development ([http://gamua.com/sparrow](http://gamua.com/sparrow)),
    **The Starling Framework** for ActionScript 3 ([http://gamua.com/starling/](http://gamua.com/starling/)),
    as well as **Cocos2D** ([http://cocos2d.org/](http://cocos2d.org/)) have been
    included. As a HTML5 developer, the three main export settings you will probably
    be most interested in are the **JSON**, **JSON-Array**, and **easeljs** options.
    Exporting the dataset as a simple JSON export will allow you to use the data universally
    as JSON in the open standard for human-readable data storage. The **JSON-Array**
    setting is extremely similar with the difference of storing the data in JSON arrays
    rather than direct objects. The difference between the two will really only affect
    how you interpret the data within your code. Finally, the **easlejs** export setting
    allows you to automatically prepare the exported animation for inclusion in your
    CreateJS, or EaselJS project. This export setting is handy when you are attempting
    to include an external asset within another Flash project into a pre-existing
    CreateJS toolkit-based project:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 配置属性的正确大小包含了数据集导出的设置。由于为精灵表导出的图像将只包含帧资产而没有动画数据，因此精灵表将需要某种形式的数据才能正确播放。当使用可用的切片算法中的基本算法时，通常不会出现问题。使用基本设置时，精灵以漂亮的统一行排列在易于使用的网格布局中。这是处理任何简单动画时的最佳输出设置。目前算法的另一个选项是**MaxRects**选项。此选项用于尝试尽可能紧密地打包帧。这样做的原因是为了最小化导出图像文件大小，以便在互联网连接上实现更快的下载时间。选择算法后，我们可以继续进行此导出窗口中可能最重要的设置。**数据格式**选择允许您将数据导出格式设置为特定于您正在开发的HTML5应用程序的工作方式。已包括对iOS开发的**The
    Sparrow Framework**（[http://gamua.com/sparrow](http://gamua.com/sparrow)）、用于ActionScript
    3的**The Starling Framework**（[http://gamua.com/starling/](http://gamua.com/starling/)）以及**Cocos2D**（[http://cocos2d.org/](http://cocos2d.org/)）的支持。作为HTML5开发人员，您可能最感兴趣的三个主要导出设置是**JSON**、**JSON-Array**和**easeljs**选项。将数据集导出为简单的JSON导出将允许您将数据通用地用作JSON，这是人类可读的数据存储的开放标准。**JSON-Array**设置非常相似，不同之处在于将数据存储在JSON数组中而不是直接对象中。这两者之间的区别实际上只会影响您在代码中如何解释数据。最后，**easlejs**导出设置允许您自动准备导出的动画以包含在您的CreateJS或EaselJS项目中。当您尝试将外部资产包含到现有的基于CreateJS工具包的项目中时，这种导出设置非常方便：
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_08.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![在Flash Professional CS6中生成精灵表](img/3325OT_08_08.jpg)'
- en: The final settings in the configuration are the **Trim** and **Stack frames**
    options. Trimming the frames in the sprite sheet will remove any unused empty
    space between each of the elements within. This will again optimize your end result
    by minimizing the exported image filesize. Finally, the **Stack frames** option
    allows you to further optimize your animation by removing or stacking any frames
    that are identical in your animation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中的最终设置是**修剪**和**堆叠帧**选项。修剪精灵表中的帧将删除每个元素之间的未使用空白空间。这将通过最小化导出图像文件大小再次优化您的最终结果。最后，**堆叠帧**选项允许您通过删除或堆叠动画中相同的帧来进一步优化您的动画。
- en: 'Since there will be no need to store the same image twice since the exported
    dataset will contain the timeline information, these assets can be removed without
    issue:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于导出的数据集将包含时间轴信息，因此无需存储相同的图像两次，因此可以毫无问题地删除这些资产：
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_09.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![在Flash Professional CS6中生成精灵表](img/3325OT_08_09.jpg)'
- en: 'With all of these settings covered, let''s export this animation with the settings
    in the previous screenshot to see what we get for an output. When the **Export**
    button is clicked, the window will close when completed, and you will be able
    to find the exported material in the root of your project directory. With the
    **JSON** setting appended to the **Data format** option, two files are exported.
    The first file is the sprite sheet image in the PNG format:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设置都已覆盖，让我们使用前面截图中的设置导出这个动画，看看我们得到了什么输出。当单击**导出**按钮时，窗口完成后将关闭，您将能够在项目目录的根目录中找到导出的材料。在**数据格式**选项中附加**JSON**设置后，将导出两个文件。第一个文件是PNG格式的精灵表图像：
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_10.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![在Flash Professional CS6中生成精灵表](img/3325OT_08_10.jpg)'
- en: 'The second file is our JSON output containing all of the frame positions and
    sizes of the animation. The following is a snippet from the exported JSON containing
    the animation data for the first three frame of animation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件是我们的JSON输出，其中包含动画的前三帧的所有帧位置和大小的数据。以下是导出的JSON中包含的动画数据的片段：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The data is extremely simple to read and understand which is good, as from
    this point out without the use of a game development framework or CreateJS, we
    have to interpret and display this data and assets ourselves:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据非常简单易懂，这很好，因为从这一点开始，如果没有使用游戏开发框架或CreateJS，我们必须自己解释和显示这些数据和资产：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Due to the tremendous support for CreateJS in Flash Professional CS6, the export
    and usage of the EaselJS setting for sprite sheets is definitely the easiest way
    to go. However, as demonstrated in the previous code snippet, with the standardized
    JSON export methods, you can implement any Flash animation as a sprite sheet into
    your HTML5 projects with relative ease.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flash Professional CS6对CreateJS的巨大支持，使用EaselJS设置来导出和使用精灵表绝对是最简单的方法。然而，正如前面的代码片段所示，通过标准化的JSON导出方法，你可以相对容易地将任何Flash动画实现为精灵表，用于你的HTML5项目。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are interested in learning more about sprite sheets but you don't want
    to spend time creating all of the assets, head over to Google images and search
    for sprite sheets. You will find an endless resource of great sprite sheets to
    test your applications with. Of course, you should always be sure to have permission
    or ownership of any asset when used on a public facing website.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对精灵表感兴趣，但又不想花时间创建所有的资源，可以前往Google图片搜索精灵表。你会发现无穷无尽的精灵表资源，可以用来测试你的应用程序。当然，在公共网站上使用任何资产时，你应该确保拥有权限或所有权。
- en: Jangaroo
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jangaroo
- en: 'The story behind the development of Jangaroo ([http://www.jangaroo.net](http://www.jangaroo.net))
    is actually pretty interesting. Created by the development team at CoreMedia ([http://www.coremedia.com](http://www.coremedia.com)),
    Jangaroo was built out of the frustrations the internal development team had with
    the current JavaScript development capabilities. Rather than dealing with many
    of the common syntax issues that JavaScript possess, the development team at CoreMedia
    set about to create a ActionScript 3 to JavaScript compiler written in Java. As
    absurd as that may sound, the actuality is that Flash developers can easily continue
    writing in a familiar syntax while specifically targeting HTML5-based web development.
    Jangaroo aims to allow developers to write high quality JavaScript frameworks
    and applications with the power of ActionScript 3\. In a nutshell, it will take
    in ActionScript 3 files, and with the use of its compiler written in Java, convert
    them into ready to use JavaScript:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Jangaroo（[http://www.jangaroo.net](http://www.jangaroo.net)）的开发背后实际上非常有趣。Jangaroo是由CoreMedia（[http://www.coremedia.com](http://www.coremedia.com)）的开发团队创建的，它是由内部开发团队对当前JavaScript开发能力的挫折而构建的。CoreMedia的开发团队并没有处理JavaScript所具有的许多常见语法问题，而是着手创建了一个用Java编写的ActionScript
    3到JavaScript编译器。尽管这听起来可能很荒谬，但实际情况是，Flash开发人员可以轻松地继续使用熟悉的语法，同时专门针对基于HTML5的Web开发。Jangaroo旨在允许开发人员使用ActionScript
    3的强大功能编写高质量的JavaScript框架和应用程序。简而言之，它将接收ActionScript 3文件，并借助其用Java编写的编译器将它们转换为可用的JavaScript：
- en: '![Jangaroo](img/3325OT_08_11.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Jangaroo](img/3325OT_08_11.jpg)'
- en: So why would anyone want to avoid writing native JavaScript and begin writing
    ActionScript 3 for the next HTML5 project? Well, as a developer with previous
    experience writing ActionScript 3, you can probably already answer this question
    from all of the examples and overviews so far in this book. When it comes to writing
    large robust applications in HTML5, the lack of packages, classes, and proper
    inheritance in JavaScript can begin to create a minefield of code which can be
    tricky to manage. By allowing yourself to continue developing your applications
    in a language that you are not only used to, but allows for easier management
    of the classes in your project, you can surpass many common hurdles that would
    have arisen during a pure JavaScript development cycle.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么有人想要避免编写原生JavaScript，开始为下一个HTML5项目编写ActionScript 3呢？嗯，作为一个有过编写ActionScript
    3经验的开发者，你可能已经可以从本书中到目前为止的所有示例和概述中回答这个问题。在编写大型强大的HTML5应用程序时，JavaScript中缺少包、类和适当的继承可能会开始创建一堆代码的雷区，这些代码可能很难管理。通过允许自己继续使用一种你不仅习惯了的语言来开发应用程序，而且可以更容易地管理项目中的类，你可以克服许多在纯JavaScript开发周期中可能出现的常见障碍。
- en: The heart of the Jangaroo project is the Jangaroo ActionScript 3 to JavaScript
    compiler called `jooc`. The compiler will take in your ActionScript `.as` files
    and export them as compiled JavaScript `.js` files. To install and run Jangaroo,
    you will need to begin by making sure you have installed an up-to-date version
    of the Java Runtime Environment ([http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html))
    as well as Maven ([http://maven.apache.org](http://maven.apache.org)). The installation
    and setup of these two pieces of software may seem intimidating, but be sure the
    process is extremely straightforward and well-documented, so I will leave that
    process up to you.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Jangaroo项目的核心是名为`jooc`的Jangaroo ActionScript 3到JavaScript编译器。编译器将接收你的ActionScript
    `.as`文件，并将它们导出为编译后的JavaScript `.js`文件。要安装和运行Jangaroo，你需要首先确保已安装最新版本的Java运行环境（[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)）以及Maven（[http://maven.apache.org](http://maven.apache.org)）。安装和设置这两个软件可能看起来令人生畏，但请放心，这个过程非常简单直接，并且有很好的文档记录，所以我会把这个过程留给你自己。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One note worth making when dealing with installing the Java Runtime Environment
    on your computer is to be sure the `JAVA_HOME` environment variable is properly
    set. If you encounter any issue during the installation of testing process of
    Jangaroo, this will be a good place to start debugging.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Java运行环境时，值得注意的一点是要确保`JAVA_HOME`环境变量已正确设置。如果在安装或测试Jangaroo过程中遇到任何问题，这将是一个很好的调试起点。
- en: 'To give you an example of a simplified development cycle of a JavaScript-driven
    application created with ActionScript 3 and compiled with Jangaroo, let''s use
    the HelloWorld example that can be found on the project website ([http://www.jangaroo.net/tutorial](http://www.jangaroo.net/tutorial)):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个用ActionScript 3创建并使用Jangaroo编译的JavaScript驱动应用程序的简化开发周期的例子，让我们使用可以在项目网站上找到的HelloWorld示例（[http://www.jangaroo.net/tutorial](http://www.jangaroo.net/tutorial)）。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the code example, the syntax available to your ActionScript
    classes is a hybrid of common ActionScript 3 as well as some special window and
    document object references to allow you to integrate your application into the
    browser properly. If you are interested in learning more about the language and
    code syntax options when preparing ActionScript 3 for the Jangaroo compiler, head
    over to the **Writing Code** page in the official Jangaroo documentation ([http://www.jangaroo.net/tutorial/writing_code](http://www.jangaroo.net/tutorial/writing_code)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在代码示例中所看到的，您的ActionScript类可用的语法是常见的ActionScript 3和一些特殊的窗口和文档对象引用的混合，以便您可以正确地将应用程序集成到浏览器中。如果您对准备将ActionScript
    3编译为Jangaroo编译器感兴趣，可以前往官方Jangaroo文档的**编写代码**页面了解有关语言和代码语法选项的更多信息（[http://www.jangaroo.net/tutorial/writing_code](http://www.jangaroo.net/tutorial/writing_code)）。
- en: The bulk of Jangaroo is open source and the project code and assets can be found
    on the CoreMedia Github page ([https://github.com/CoreMedia](https://github.com/CoreMedia)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Jangaroo的大部分是开源的，项目代码和资产可以在CoreMedia的Github页面上找到（[https://github.com/CoreMedia](https://github.com/CoreMedia)）。
- en: Haxe
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Haxe
- en: 'Keeping on the topic of compiling applications and other programming languages
    directly to JavaScript, I should take a moment and cover some of the exciting
    features in the world of Haxe development:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论将应用程序和其他编程语言直接编译为JavaScript的话题，我应该花点时间介绍一下Haxe开发世界中一些令人兴奋的功能：
- en: '![Haxe](img/3325OT_08_12.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Haxe](img/3325OT_08_12.jpg)'
- en: '**Haxe** ([http://haxe.org](http://haxe.org)) is its own standalone open source
    programming language. Where most programming languages are built for a specific
    application type in mind, JavaScript for the Web, ActionScript for Flash, Haxe
    can be compiled and run on a variety of platforms and devices all from the same
    source code. Haxe source can selectively be compiled into JavaScript, Flash, PHP,
    C++, C#, and Java and with your prior experience with ActionScript 3 and new skills
    you have learned in JavaScript, learning the Haxe language syntax is a breeze.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Haxe**（[http://haxe.org](http://haxe.org)）是一种独立的开源编程语言。大多数编程语言都是为特定的应用类型而构建的，JavaScript用于Web，ActionScript用于Flash，而Haxe可以从相同的源代码编译和运行在各种平台和设备上。Haxe源代码可以有选择地编译成JavaScript、Flash、PHP、C++、C#和Java，结合您之前对ActionScript
    3的经验和您在JavaScript中学到的新技能，学习Haxe语法是轻而易举的。'
- en: 'Although cross-platform development may not be of interest to you right now,
    having at least a basic understanding of what languages such as Haxe offer may
    allow you to fill some more gaps in your development skill set. Just for some
    final clarity before we move on, let''s take a quick peek at an example snippet
    of Haxe code which can be found on the **Code Snippets** page on the Haxe project
    website ([http://haxe.org/doc/snip](http://haxe.org/doc/snip)). The following
    code is an example of implementing the popular sorting method, Quicksort ([http://en.wikipedia.org/wiki/Quicksort](http://en.wikipedia.org/wiki/Quicksort)).
    Since we already have an idea of what this sorting algorithm is attempting to
    accomplish, let''s review this code to mainly get an idea of class, method, and
    variable syntax in the Haxe programming language:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管跨平台开发现在可能不是您的兴趣所在，但至少对诸如Haxe等语言提供的基本了解可能会让您填补开发技能中的一些空白。在我们继续之前，让我们快速看一下Haxe项目网站的**代码片段**页面上可以找到的Haxe代码示例。以下代码是实现流行排序方法Quicksort的示例（[http://en.wikipedia.org/wiki/Quicksort](http://en.wikipedia.org/wiki/Quicksort)）。由于我们已经了解了这个排序算法试图实现的目标，让我们主要审查这段代码，以了解Haxe编程语言中的类、方法和变量语法：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see directly in the first line, Haxe has full class support unlike
    JavaScript. This concept alone may be a selling point as ActionScript developers
    moving over into Haxe will find many more similarities which are unavailable in
    JavaScript. Other features such as static functions, strict variable typing, and
    common debug methods such as `trace()` are just a couple more of the great features
    within Haxe that specifically let a developer with previous ActionScript 3 development
    experience shine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以直接在第一行看到的那样，Haxe具有完整的类支持，不像JavaScript。这个概念本身可能是一个卖点，因为从ActionScript转到Haxe的开发人员会发现许多在JavaScript中不可用的相似之处。其他功能，如静态函数、严格的变量类型和常见的调试方法，比如`trace()`，只是Haxe中让具有先前ActionScript
    3开发经验的开发人员脱颖而出的众多出色功能之一。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are interested in learning more about the exciting world of Haxe development,
    checkout the book *Haxe 2 Beginners Guide*, *Packt Publishing* ([http://www.packtpub.com/haxe-2-beginners-guide/book](http://www.packtpub.com/haxe-2-beginners-guide/book)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对了解Haxe开发的激动人心世界感兴趣，请查看《Haxe 2初学者指南》，*Packt Publishing*（[http://www.packtpub.com/haxe-2-beginners-guide/book](http://www.packtpub.com/haxe-2-beginners-guide/book)）。
- en: Haxe itself is a beast of a project. The ability to cross compile your application
    source code directly to almost every modern platform available is an extremely
    valuable asset when you are developing a project with very specific platform requirements.
    Even if you intend to target only HTML5 web projects with your Haxe source code,
    having the ability to move your application to another platform with only a couple
    clicks of the mouse is pretty amazing. Also, as with many of the other platforms
    and compilers we have reviewed in this chapter, Haxe can alleviate many of the
    common complaints web developers have with JavaScript syntax. The project is still
    relatively new although many developers have already jumped on the bandwagon.
    If developing your next application in Haxe sounds like an interesting challenge,
    I highly recommend looking into it some more.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Haxe本身是一个庞大的项目。直接将应用程序源代码交叉编译到几乎所有现代平台上的能力是一个非常宝贵的资产，尤其是当您开发具有非常特定平台要求的项目时。即使您只打算使用Haxe源代码针对HTML5
    Web项目，只需点击几下鼠标即可将应用程序移植到另一个平台的能力是非常惊人的。此外，就像我们在本章中审查的许多其他平台和编译器一样，Haxe可以减轻许多Web开发人员对JavaScript语法的常见抱怨。该项目仍然相对较新，尽管许多开发人员已经加入了这一行列。如果在Haxe中开发您的下一个应用程序听起来像一个有趣的挑战，我强烈建议您进一步了解一下。
- en: Google Dart
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Dart
- en: 'With the goal of helping developers from all platforms build complex, high-performance
    client apps for the modern Web, Google''s Dart ([https://code.google.com/p/dart/](https://code.google.com/p/dart/))
    is another great example of pushing web development, more specifically JavaScript
    development, to the limit. Just like Haxe, Dart is an open-source project that
    uses its own specific programming language to compile into Web-ready JavaScript
    documents and just like Jangaroo, Dart was built out of the frustrations with
    the limits of the current web development platforms. In an attempt to bring a
    new structured, single language workflow Google has released a *Technology Preview*
    of the Dart project for early testing and feedback from the web development community:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助来自各个平台的开发人员构建现代Web的复杂、高性能客户端应用程序，谷歌的Dart（[https://code.google.com/p/dart/](https://code.google.com/p/dart/)）是推动Web开发的又一个很好的例子，更具体地说是JavaScript开发。就像Haxe一样，Dart是一个开源项目，使用自己特定的编程语言编译成Web-ready
    JavaScript文档，就像Jangaroo一样，Dart是基于对当前Web开发平台限制的不满而构建的。为了引入新的结构化、单一语言工作流程，谷歌发布了Dart项目的*技术预览*，以便早期测试和来自Web开发社区的反馈：
- en: '![Google Dart](img/3325OT_08_13.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Google Dart](img/3325OT_08_13.jpg)'
- en: Of course, since Dart is built on its own language syntax, there will be a learning
    curve involved when first starting out. To aid in the strain of learning a new
    language, I highly recommend checking out the official Dart Editor. The Dart Editor
    ([http://www.dartlang.org/docs/editor/](http://www.dartlang.org/docs/editor/))
    is probably the easiest way to get up and running with Dart development.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于Dart是基于自己的语法构建的，刚开始时会有一个学习曲线。为了帮助减轻学习新语言的压力，我强烈建议查看官方的Dart Editor。Dart
    Editor（[http://www.dartlang.org/docs/editor/](http://www.dartlang.org/docs/editor/)）可能是最简单的开始和运行Dart开发的方法。
- en: 'It supports features such as real-time error and syntax checking to alert you
    of any issues before you compile, as well as code completion to help you understand
    what can be done with each method and property:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持实时错误和语法检查功能，以在编译之前提醒您任何问题，同时还支持代码完成功能，以帮助您了解每个方法和属性可以做什么。
- en: '![Google Dart](img/3325OT_08_14.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Google Dart](img/3325OT_08_14.jpg)'
- en: The Dart Editor, like many others, is built on the popular Eclipse IDE. As simplified
    as the code editor is, this can be considered another win for anyone with Flash
    Builder experience as the interface will be extremely familiar. I say this editor
    is simplified because the editor does not come as a plugin for Eclipse, instead
    it comes packaged as its own standalone Eclipse-based editor with all of the unnecessary
    elements removed from it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Dart Editor，就像许多其他编辑器一样，是基于流行的Eclipse IDE构建的。尽管代码编辑器简化了，但对于有Flash Builder经验的人来说，这可以被认为是又一个胜利，因为界面会非常熟悉。我说这个编辑器简化了，因为这个编辑器不是作为Eclipse的插件提供的，而是作为自己独立的基于Eclipse的编辑器打包，删除了所有不必要的元素。
- en: Like the overview of Haxe, I will keep this brief as Dart is still a very new
    project and I have yet to personally meet anyone who has developed a popular web
    application with it. That being said, there is absolutely no reason to discredit
    a language such as Dart. As the JavaScript specification evolves and browser support
    follow suit, the need for these projects may become less. However, as any Flash
    developer knows, the ability to compile projects with a proper debug and output
    flow can allow them to find and fix issues faster than many traditional methods
    of writing client-side scripts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Haxe的概述一样，我会保持简短，因为Dart仍然是一个非常新的项目，我还没有亲自遇到任何使用它开发流行Web应用程序的人。也就是说，绝对没有理由贬低Dart这样的语言。随着JavaScript规范的发展和浏览器支持的跟进，对这些项目的需求可能会减少。然而，就像任何Flash开发人员知道的，使用适当的调试和输出流编译项目可以让他们比许多传统的客户端脚本编写方法更快地找到和修复问题。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: During the course of this chapter, we spent some time looking at some projects
    that are pushing the limits of web application development from websites and libraries
    such as Google's Swiffy project that easily allow you to convert simple Flash
    SWF files directly to a Web-friendly HTML and JavaScript configuration, to familiar
    methods of exporting Flash vector and bitmap animations into Web-ready sprite
    sheets right from within the Flash Professional IDE. Projects such as Haxe, Dart,
    and Jangaroo give developers new options when attempting to create their HTML5
    projects. The native JavaScript that will drive their application can actually
    be written in a completely different language altogether. Extending the capabilities
    of JavaScript into other languages may seem backwards at first, but the reasons
    for creating these projects generally all come down to the lack of common language
    syntax and development flow issues developers have when writing JavaScript. As
    mentioned earlier, none of the projects or features within specific applications
    mentioned in this chapter are required when developing you next HTML5 project.
    Arming yourself with the knowledge of what projects and platforms web developers
    have available to them right now will allow you to come to better conclusions
    as to the best way for you to tackle your next HTML5 project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们花了一些时间研究了一些正在推动网页应用程序开发极限的项目，例如谷歌的Swiffy项目，它可以轻松地将简单的Flash SWF文件直接转换为Web友好的HTML和JavaScript配置，以及从Flash
    Professional IDE中直接导出Flash矢量和位图动画到Web准备好的精灵表。诸如Haxe、Dart和Jangaroo之类的项目为开发人员在尝试创建他们的HTML5项目时提供了新的选择。驱动他们应用程序的本机JavaScript实际上可以用完全不同的语言编写。最初，将JavaScript的能力扩展到其他语言可能看起来有些反向，但创建这些项目的原因通常都归结为在编写JavaScript时缺乏通用语法和开发流程问题。正如前面提到的，开发下一个HTML5项目时，并不需要使用本章中提到的特定应用程序中的项目或功能。了解当前网页开发人员可以使用的项目和平台的知识将使您能够更好地得出结论，找到最佳的方式来处理下一个HTML5项目。
- en: I have to stress, the list of applications, features, and compilers mentioned
    in this chapter is only a small fraction of what is available to you when working
    with JavaScript. If you are interested in seeing more projects that can compile
    to and or extend JavaScript, head over to [http://altjs.org](http://altjs.org)
    to get a start. There you will find a listing of projects that target beginner
    to advanced developer styles, so I am sure there will be something there to interest
    you. Many of these projects are based off of CoffeeScript ([http://coffeescript.org](http://coffeescript.org)),
    yet another dedicated language that compiles directly to JavaScript, which is
    yet another great project I recommend checking out. The number of projects related
    to extending JavaScript's development flow and abilities seems endless, and growing
    every day. No one can ever expect you to know all of them, but having a general
    understanding of what is out there and what many of these platforms can do will
    allow you to make faster and better decisions when setting out to develop your
    next project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须强调，本章提到的应用程序、功能和编译器列表只是在使用JavaScript时可用的一小部分。如果您有兴趣了解更多可以编译到JavaScript或扩展JavaScript的项目，请访问[http://altjs.org](http://altjs.org)。在那里，您将找到针对初学者到高级开发人员风格的项目列表，所以我相信那里一定会有一些能够吸引您的东西。许多这些项目都是基于CoffeeScript（[http://coffeescript.org](http://coffeescript.org)）开发的，这是另一种直接编译为JavaScript的专用语言，也是我推荐您了解的另一个很棒的项目。与扩展JavaScript的开发流程和能力相关的项目数量似乎是无穷无尽的，并且每天都在增长。没有人能指望您了解所有这些项目，但是对现有项目以及许多这些平台能做什么有一个基本的了解，将使您在着手开发下一个项目时能够做出更快更好的决策。
- en: In the next two chapters, we will begin taking everything we have covered up
    to this point into an actual HTML5 application development flow. We will cover
    many of the important aspects every developer should be aware of when developing
    for the Web as well as a way to properly test your application as you develop.
    Finally to wrap everything up, we will take that application to the Internet and
    cover some ways to publish and maintain your project once it is live.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将开始将我们到目前为止所涵盖的所有内容融入到实际的HTML5应用程序开发流程中。我们将涵盖每个开发人员在为Web开发时应该注意的许多重要方面，以及在开发过程中正确测试应用程序的方法。最后，为了总结一切，我们将把该应用程序发布到互联网，并介绍一些在应用程序上线后发布和维护项目的方法。
