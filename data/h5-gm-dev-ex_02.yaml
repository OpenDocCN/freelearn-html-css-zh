- en: Chapter 2. Getting Started with DOM-based Game Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。开始使用基于DOM的游戏开发
- en: We have had an idea about what we are going to learn in the whole book in Chapter
    1, Introducing HTML5 Games. From this chapter, we will go through a lot of learning-by-doing
    sections and we will focus on one topic in each section. Before digging deeply
    into the cutting edge CSS3 animations and HTML5 Canvas game, let's start with
    traditional DOM-based game development. We will warm up with some basic techniques
    in this chapter.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在第1章“介绍HTML5游戏”中，我们已经对整本书要学习的内容有了一个概念。从本章开始，我们将经历许多通过实践学习的部分，并且我们将在每个部分专注于一个主题。在深入研究尖端的CSS3动画和HTML5
    Canvas游戏之前，让我们从传统的基于DOM的游戏开发开始。在本章中，我们将用一些基本技术热身。
- en: 'In this chapter, we will be:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Preparing the development tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备开发工具
- en: Setting up our first game—Ping Pong
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的第一个游戏-乒乓球
- en: Learning basic positioning with the jQuery JavaScript library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery JavaScript库学习基本定位
- en: Getting keyboard inputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取键盘输入
- en: Creating the Ping Pong game with scoring
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记分的乒乓球游戏
- en: 'The following screenshot shows the game we will get after this chapter. It
    is a Ping Pong game played by two players with one keyboard simultaneously:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了本章结束后我们将获得的游戏。这是一个由两名玩家同时使用一个键盘玩的乒乓球游戏：
- en: '![Getting Started with DOM-based Game Development](img/1260_02_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用基于DOM的游戏开发](img/1260_02_01.jpg)'
- en: So, let's get on with making our Ping Pong.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始制作我们的乒乓球。
- en: Preparing the development environment
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: The environment for developing HTML5 games is similar to designing websites.
    We need web browsers with the required plugin and a good text editor. Which text
    editor is good is a never-ending debate. Each text editor comes with its own strength,
    so just pick your favorite one. For the browser, we will need a modern browser
    that supports the latest HTML5, CSS3 spec, and provides us with handy tools for
    debugging.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开发HTML5游戏的环境类似于设计网站。我们需要具有所需插件的Web浏览器和一个好的文本编辑器。哪个文本编辑器好是一个永无止境的争论。每个文本编辑器都有其自身的优势，所以只需选择您喜欢的即可。对于浏览器，我们将需要一个支持最新HTML5、CSS3规范并为我们提供方便的调试工具的现代浏览器。
- en: There are several modern browser choices on the Internet now. They are Apple
    Safari ([http://apple.com/safari/](http://apple.com/safari/)), Google Chrome ([http://www.google.com/chrome/](http://www.google.com/chrome/)),
    Mozilla Firefox ([http://mozilla.com/firefox/](http://mozilla.com/firefox/)),
    and Opera ([http://opera.com](http://opera.com)). These browsers support most
    features we discuss in the examples in the whole book. We will use Google Chrome
    to demonstrate most examples in the book because it runs fast and smooth with
    CSS3 transition and Canvas.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在互联网上有几种现代浏览器选择。它们是苹果Safari（[http://apple.com/safari/](http://apple.com/safari/)）、Google
    Chrome（[http://www.google.com/chrome/](http://www.google.com/chrome/)）、Mozilla
    Firefox（[http://mozilla.com/firefox/](http://mozilla.com/firefox/)）和Opera（[http://opera.com](http://opera.com)）。这些浏览器支持我们在整本书中讨论的大多数功能。我们将使用Google
    Chrome来演示本书中的大多数示例，因为它在CSS3过渡和Canvas上运行速度快且流畅。
- en: Preparing the HTML documents for a DOM-based game
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为基于DOM的游戏准备HTML文档
- en: Every website, web page, and HTML5 game starts with a default HTML document.
    Moreover, the document starts with a basic HTML code. We will start our HTML5
    game development journey from `index.html`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网站、网页和HTML5游戏都以默认的HTML文档开始。此外，文档以基本的HTML代码开始。我们将从`index.html`开始我们的HTML5游戏开发之旅。
- en: Time for action Installing the jQuery library
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装jQuery库的操作时间
- en: 'We will create our HTML5 Ping Pong game from scratch. It may sound as if we
    are going to be preparing all the things ourselves. Luckily, at least we can use
    a JavaScript library to help us. **jQuery** is the **JavaScript library** we will
    be using in the whole book. It will help us in simplifying our JavaScript logic:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从头开始创建我们的HTML5乒乓球游戏。这可能听起来好像我们要自己准备所有的东西。幸运的是，至少我们可以使用一个JavaScript库来帮助我们。**jQuery**是我们将在整本书中使用的**JavaScript库**。它将帮助我们简化我们的JavaScript逻辑：
- en: Create a new folder named `pingpong`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pingpong`的新文件夹。
- en: Create a new folder named `js` inside the `pingpong` directory.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pingpong`目录中创建一个名为`js`的新文件夹。
- en: Now it's time to download the jQuery library. Go to [http://jquery.com/](http://jquery.com/).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候下载jQuery库了。转到[http://jquery.com/](http://jquery.com/)。
- en: Select **Production** and click on **Download jQuery**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**生产**并单击**下载jQuery**。
- en: Save `jquery-1.4.4.min.js` in the `js` folder we created in step 2.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`jquery-1.4.4.min.js`保存在我们在步骤2中创建的`js`文件夹中。
- en: Create a new document named `index.html` and save it in the first game folder.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的新文档，并将其保存在第一个游戏文件夹中。
- en: 'Open `index.html` in text editor and insert an empty HTML template:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`index.html`并插入一个空的HTML模板：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Include the jQuery JavaScript file by adding the following line before the
    closing of the body tag:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在body标签关闭之前添加以下行来包含jQuery JavaScript文件：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we have to ensure that jQuery is loaded successfully. We place the
    following code before the close of the body tag and after the jQuery:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须确保jQuery已成功加载。我们将在body标签关闭之前并在jQuery之后放置以下代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save the `index.html` and open it in the browser. We should see the following
    alert window showing our text. This means our jQuery is correctly set up:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`index.html`并在浏览器中打开它。我们应该看到以下警报窗口显示我们的文本。这意味着我们的jQuery已正确设置：
- en: '![Time for action Installing the jQuery library](img/1260_02_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![安装jQuery库的操作时间](img/1260_02_02.jpg)'
- en: What just happened?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just created a basic HTML5 page with jQuery and ensured that the jQuery is
    loaded correctly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个基本的带有jQuery的HTML5页面，并确保jQuery已正确加载。
- en: New HTML5 doctype
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的HTML5 doctype
- en: The `DOCTYPE` and `meta` tags are simplified in HTML5.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5中，`DOCTYPE`和`meta`标签被简化了。
- en: 'In HTML4.01, we declare doctype as the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML4.01中，我们声明doctype的代码如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is a long line of code, right? While in HTML5, the doctype declaration cannot
    be simpler:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一行很长的代码，对吧？在HTML5中，doctype声明不能更简单：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We even do not have the HTML version in the declaration. This implies that HTML5
    will support all existing content of previous HTML versions. Future HTML versions
    will also support the existing content of HTML5.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至没有在声明中使用HTML版本。这意味着HTML5将支持以前HTML版本的所有现有内容。未来的HTML版本也将支持HTML5的现有内容。
- en: 'The simplification also comes to `meta` tag. We define the charset of the HTML
    by using the following short line now:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 简化也适用于`meta`标签。现在我们可以使用以下简短的行来定义HTML的字符集：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Header and footer
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页眉和页脚
- en: HTML5 comes with many new features and improvements, one of them is semantics.
    HTML5 adds new elements to improve the **semantics**. We just used two, `header`
    and `footer`. Header gives a heading introduction to the section or the entire
    page. Therefore, we put the `h1` title inside header. Footer, same as its name,
    contains the footer information of the section or the page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5带来了许多新功能和改进，其中之一就是语义。HTML5添加了新元素来改进**语义**。我们刚刚使用了两个，`header`和`footer`。Header为部分或整个页面提供了标题介绍。因此，我们将`h1`标题放在header内。Footer与其名称相同，包含了部分或整个页面的页脚信息。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A semantic HTML means that the markup itself provides meaningful information
    to the content instead of only defining the visual outlook.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 语义HTML意味着标记本身提供了有意义的信息，而不仅仅定义了视觉外观。
- en: Best practice to place the JavaScript code
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放置JavaScript代码的最佳实践
- en: We put the JavaScript code right before the closing`</body>` tag and after all
    the content in the page. There is a reason for putting the code there instead
    of putting it inside the`<head></head>` section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将JavaScript代码放在所有页面内容之后和`</body>`标签之前。之所以将代码放在那里而不是放在`<head></head>`部分内，是有原因的。
- en: Normally, browsers load content and render them from top to bottom. If the JavaScript
    code is put in the `head` section, then the content of document will not be loaded
    until all JavaScript code is loaded. Actually, all rendering and loading will
    be blocked if the browsers load a JavaScript code in the middle of the page. This
    is the reason why we want to put the JavaScript code at the bottom when possible.
    In this way, we can deliver the content with higher performance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，浏览器会从顶部到底部加载内容并呈现它们。如果将JavaScript代码放在`head`部分，那么直到所有JavaScript代码加载完毕，文档的内容才会被加载。实际上，如果浏览器在页面中间加载JavaScript代码，所有呈现和加载都将被阻塞。这就是为什么我们希望尽可能将JavaScript代码放在底部的原因。这样，我们可以以更高的性能提供内容。
- en: At the time of writing this book, the latest jQuery version is 1.4.4\. That
    is why the jQuery file in our code examples is named `jquery-1.4.4.min.js`. This
    version number will be different, but the usage should be the same unless there
    is a big change in jQuery without backward compatibility.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新的jQuery版本是1.4.4。这就是为什么我们代码示例中的jQuery文件被命名为`jquery-1.4.4.min.js`。这个版本号会有所不同，但使用方式应该是相同的，除非jQuery发生了没有向后兼容的重大变化。
- en: Running our code after the page is ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在页面准备就绪后运行我们的代码
- en: 'We need to ensure that the page is ready before our JavaScript code is executed.
    Otherwise, we may get an error when we try to access an element that is not yet
    loaded. jQuery provides us with a way to execute the code after the page is ready.
    It is the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保页面在执行我们的JavaScript代码之前已经准备就绪。否则，当我们尝试访问尚未加载的元素时，可能会出现错误。jQuery为我们提供了一种在页面准备就绪后执行代码的方法。以下是代码：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Actually, what we just used is the following codes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们刚刚使用的是以下代码：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `$` sign is a shortcut for jQuery. When we are calling `$(something)`, we
    are actually calling `jQuery(something)`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`符号是jQuery的快捷方式。当我们调用`$(something)`时，实际上是在调用`jQuery(something)`。'
- en: '`$(function_callback)` is another shortcut for the `ready` event.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(function_callback)`是`ready`事件的另一个快捷方式。'
- en: 'It is identical to the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容相同：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, identical to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与以下内容相同：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Pop quiz
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验
- en: Which is the best place to put JavaScript code?
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪里是放置JavaScript代码的最佳位置？
- en: a. Before the`<head>` tag
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: a. 在`<head>`标签之前
- en: b. Inside the`<head></head>` elements
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在`<head></head>`元素内
- en: c. Right after the`<body>` tag
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: c. 在`<body>`标签之后
- en: d. Right before the`</body>` tag
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: d. 在`</body>`标签之前
- en: Setting up the Ping Pong game elements
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置乒乓球游戏元素
- en: We have the preparation ready and it is time to set up the Ping Pong game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了准备工作，现在是设置乒乓球游戏的时候了。
- en: Time for action Placing Ping Pong game elements in DOM
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 将乒乓球游戏元素放入DOM
- en: We will continue from our jQuery installation example. Open the `index.html`
    in a text editor.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从jQuery安装示例继续。在文本编辑器中打开`index.html`。
- en: 'Then, create the following playground and game objects with DIV nodes in the
    body. There are two paddles and one ball inside the playground. Moreover, the
    playground is inside the game:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在body中创建以下游乐场和DIV节点中的游戏对象。游乐场内有两个挡板和一个球。此外，游乐场位于游戏内：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now have the game objects'' structure ready and it is time to apply styles
    to them. Put the following styles inside the `head` element:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了游戏对象的结构，现在是给它们应用样式的时候了。将以下样式放在`head`元素内：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the last section, we put our JavaScript logic right after the jQuery inclusion.
    We will put it in a separate file as our code is getting large. Therefore, create
    a file named `html5games.pingpong.js` inside the `js` folder.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将我们的JavaScript逻辑放在了jQuery包含之后。随着代码的不断增长，我们将把它放在一个单独的文件中。因此，在`js`文件夹中创建一个名为`html5games.pingpong.js`的文件。
- en: 'We prepared the JavaScript file. Now it is time to link them to our HTML file.
    Put the following code in `index.html` before the`</body>` tag:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备了JavaScript文件。现在是将它们链接到我们的HTML文件的时候了。在`index.html`中的`</body>`标签之前放入以下代码：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will place the game logic inside the `html5games.pingpong.js`. Our only
    logic now is the following paddle''s initialization code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把游戏逻辑放在`html5games.pingpong.js`中。我们现在唯一的逻辑是以下挡板的初始化代码：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will test the setup in a browser. Open the `index.html` file in a browser
    and we should see a screen similar to the one shown in the following screenshot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在浏览器中测试设置。在浏览器中打开`index.html`文件，我们应该看到与以下截图类似的屏幕：
- en: '![Time for action Placing Ping Pong game elements in DOM](img/1260_02_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![进行操作将乒乓球游戏元素放置在DOM中](img/1260_02_03.jpg)'
- en: What just happened?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have put two paddles and a ball in the Ping Pong game. We also used jQuery
    to initialize the position of the two paddles.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在乒乓球比赛中放了两个球拍和一个球。我们还使用jQuery来初始化两个球拍的位置。
- en: Introducing jQuery
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍jQuery
- en: jQuery is a JavaScript library that is designed for easily navigating the DOM
    elements, manipulating them, handling events, and creating an asynchronies remote
    call.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个为了轻松浏览DOM元素、操作它们、处理事件和创建异步远程调用而设计的JavaScript库。
- en: 'It contains two major parts: **selection** and **modification**. Selection
    uses CSS selector syntax to select all matched elements in the web page. Modification
    actions modify the selected elements, such as add, remove children, or style.
    Using jQuery often means chaining selection and modifications actions together.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含两个主要部分：**选择**和**修改**。选择使用CSS选择器语法在网页中选择所有匹配的元素。修改操作修改所选元素，例如添加、删除子元素或样式。使用jQuery通常意味着将选择和修改操作链接在一起。
- en: 'It contains two major parts: **selection** and **modification**. Selection
    uses CSS selector syntax to select all matched elements in the web page. Modification
    actions modify the selected elements, such as add, remove children, or style.
    Using jQuery often means chaining selection and modifications actions together.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含两个主要部分：**选择**和**修改**。选择使用CSS选择器语法在网页中选择所有匹配的元素。修改操作修改所选元素，例如添加、删除子元素或样式。使用jQuery通常意味着将选择和修改操作链接在一起。
- en: 'For example, the following code selects all elements with `box` class and sets
    the CSS properties:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码选择所有具有`box`类的元素并设置CSS属性：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Understanding basic jQuery selectors
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解基本的jQuery选择器
- en: 'jQuery is about selecting elements and performing actions on them. We need
    a method to select our required elements in the entire DOM tree. jQuery borrows
    the selectors from CSS. The selector provides a set of patterns to match elements.
    The following table lists the most common and useful selectors that we will use
    in this book:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是关于选择元素并对其执行操作。我们需要一种方法来在整个DOM树中选择我们需要的元素。jQuery借用了CSS的选择器。选择器提供一组模式来匹配元素。以下表列出了我们在本书中将使用的最常见和有用的选择器：
- en: '| Selector pattern | Meaning | Examples |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 选择器模式 | 含义 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| $("Element") | Selects all elements with the given tag name | `$("p")` selects
    all the p tags.`$("body")` selects the body tag. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| $("Element") | 选择具有给定标签名称的所有元素 | `$("p")`选择所有的p标签。`$("body")`选择body标签。 |'
- en: '| $("#id") | Selects the element with the given ID of the attribute | Provides
    the following code:**<div id="box1"></div>**<div id="box2"></div>`$("#box1")`
    selects the highlighted element. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| $("#id") | 选择具有给定属性ID的元素 | 提供以下代码：**<div id="box1"></div>**<div id="box2"></div>`$("#box1")`选择突出显示的元素。
    |'
- en: '| $(".className") | Selects all elements with the given class attribute | Provides
    the following code:**<div class="apple"></div>****<div class="apple"></div>**<div
    class="orange"></div><div class="banana"></div>`$(".apple")` selects the highlighted
    elements with class set to apple. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| $(".className") | 选择具有给定类属性的所有元素 | 提供以下代码：**<div class="apple"></div>****<div
    class="apple"></div>**<div class="orange"></div><div class="banana"></div>`$(".apple")`选择具有设置为apple的类的突出显示的元素。
    |'
- en: '| $("selector1, selector2, selectorN") | Selects all elements that match the
    given selector | Provides the following code:**<div class="apple"></div>****<div
    class="apple"></div>****<div class="orange"></div>**<div class="banana"></div>`$(".apple,
    .orange")` selects the highlighted elements that class is set to, either apple
    or orange. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| $("selector1, selector2, selectorN") | 选择与给定选择器匹配的所有元素 | 提供以下代码：**<div class="apple"></div>****<div
    class="apple"></div>****<div class="orange"></div>**<div class="banana"></div>`$(".apple,
    .orange")`选择设置为apple或orange的突出显示的元素。 |'
- en: Understanding the jQuery CSS function
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解jQuery CSS函数
- en: The jQuery `css` is a function to get and set the CSS properties of the selected
    elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery `css`是一个用于获取和设置所选元素的CSS属性的函数。
- en: 'Here is a general definition of how to use the `css` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`css`函数的一般定义：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `css` function accepts several types of arguments as listed in the following
    table:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`css`函数接受以下表中列出的几种类型的参数：'
- en: '| Function type | Arguments definitions | Discussion |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 函数类型 | 参数定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `.css(propertyName)` | `propertyName` is a CSS property | The function returns
    the value of the given CSS property of the selected element.For example, the following
    code returns the value of the `background-color` property of the `body` element:`$("body").css("background-color")`It
    will only read the value and not modify the property value. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `.css(propertyName)` | `propertyName`是CSS属性 | 该函数返回所选元素的给定CSS属性的值。例如，以下代码返回`body`元素的`background-color`属性的值：`$("body").css("background-color")`它只会读取值，而不会修改属性值。
    |'
- en: '| `.css(propertyName, value)` | `propertyName` is a CSS property,`value` is
    a value to set for the property | The function modifies the given CSS property
    to the given value.For example, the following code sets the background color to
    red of all elements with `box` class:`$(".box").css("background-color","#ff0000")`
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `.css(propertyName, value)` | `propertyName`是CSS属性，`value`是要设置的值 | 该函数将给定的CSS属性修改为给定的值。例如，以下代码将所有具有`box`类的元素的背景颜色设置为红色：`$(".box").css("background-color","#ff0000")`
    |'
- en: '| `.css(map)` | `map` is a set of property-value pairs to update | This function
    is useful for setting multiple CSS properties to the same selected elements at
    the same time.For example, the following code sets both left and top CSS properties
    to the selected element with ID `box1:``$("#box1").css({``"left" : "40px"`,`"top"
    : "100px"``})` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `.css(map)` | `map`是要更新的属性-值对集合 | 此函数用于同时将多个CSS属性设置为相同的选定元素。例如，以下代码将ID为`box1`的选定元素的左侧和顶部CSS属性都设置为：`$("#box1").css({"left"
    : "40px","top" : "100px"})` |'
- en: Benefits of using jQuery
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery的好处
- en: 'There are several advantages of using jQuery over pure JavaScript, which are
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery而不是纯JavaScript有几个优点，如下所示：
- en: Using jQuery requires shorter code to select DOM nodes and modify them
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery需要更短的代码来选择DOM节点并修改它们
- en: Shorter code results in more clear code for reading, it is important in game
    development that usually contains a lot of code
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更短的代码导致更清晰的代码阅读，这在通常包含大量代码的游戏开发中非常重要
- en: Writing shorter code increases the development speed
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写更短的代码可以提高开发速度
- en: Using the jQuery library enables the code to support all major browsers without
    extra tweaks; jQuery wraps the pure JavaScript code and deals with cross browser
    capability by itself
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery库使得代码能够支持所有主要浏览器，无需额外的调整；jQuery包装了纯JavaScript代码，并且自己处理跨浏览器的能力
- en: Manipulating game elements in DOM with jQuery
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery在DOM中操作游戏元素
- en: We initialized the paddles game elements with jQuery. We will do an experiment
    on how we use jQuery to place the game elements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用jQuery初始化了球拍游戏元素。我们将进行一个实验，看看如何使用jQuery来放置游戏元素。
- en: Time for action Changing position of elements with jQuery
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 使用jQuery改变元素的位置
- en: 'Let''s inspect our Ping Pong game element with a grid background:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用网格背景检查一下我们的乒乓球游戏元素：
- en: We will continue with our Ping Pong example.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续我们的乒乓球示例。
- en: 'I have prepared a grid image. Download the `pixel_grid.jpg` image from the
    following URL:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我准备了一个网格图像。从以下URL下载`pixel_grid.jpg`图像：
- en: '[http://gamedesign.cc/html5games/pixel_grid.jpg](http://gamedesign.cc/html5games/pixel_grid.jpg
    )'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://gamedesign.cc/html5games/pixel_grid.jpg](http://gamedesign.cc/html5games/pixel_grid.jpg
    )'
- en: Create a folder named `images` in the example directory.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例目录中创建一个名为`images`的文件夹。
- en: Place the `pixel_grid.jpg` into the images folder. This image helps us inspect
    the pixel displacement later.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`pixel_grid.jpg`放入images文件夹中。这个图像可以帮助我们稍后检查像素位移。
- en: Next, open the `index.html` file in a text editor.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在文本编辑器中打开`index.html`文件。
- en: 'Modify the `background` property of the `playground` DIV to include the pixel
    grid image like the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`playground` DIV的`background`属性，包括像下面这样的像素网格图像：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now on opening the `index.html` in web browser we should have the following
    screenshot. The game elements are overlaid on top of a grid image so we can see
    where the elements are placed:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在web浏览器中打开`index.html`，我们应该有以下的截图。游戏元素叠加在网格图像的顶部，所以我们可以看到元素的放置位置：
- en: '![Time for action Changing position of elements with jQuery](img/1260_02_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 使用jQuery改变元素的位置](img/1260_02_04.jpg)'
- en: What just happened?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We began the example by placing an image called `pixel_grid.jpg`. This is an
    image I created for easy debugging purposes. The image is divided into small grids.
    Every 10 x 10 grid forms a big block with 100 x 100 pixels. By placing this image
    as background of the DIV, we put a ruler that enables us to measure the position
    of its children DIVs on the screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过放置一个名为`pixel_grid.jpg`的图像来开始示例。这是我为了方便调试而创建的图像。图像被分成小网格。每个10 x 10的网格形成一个100
    x 100像素的大块。通过将这个图像作为DIV的背景，我们放置了一个标尺，使我们能够测量其子DIV在屏幕上的位置。
- en: Understanding the behavior of absolute position
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解绝对位置的行为
- en: 'When a DOM node is set to be the `absolute` position, the left and top properties
    can be treated as a **coordinate**. We can treat the left/top properties into
    X/Y coordinates with Y positive pointing down. The following graphs show the relationship.
    The left side is the actual CSS value and the right side is the coordinate system
    in our mind when programming the game:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个DOM节点被设置为`absolute`位置时，left和top属性可以被视为**坐标**。我们可以将left/top属性视为X/Y坐标，Y正方向向下。以下图表显示了它们之间的关系。左侧是实际的CSS值，右侧是我们在编程游戏时的坐标系：
- en: '![Understanding the behavior of absolute position](img/1260_02_05.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![理解绝对位置的行为](img/1260_02_05.jpg)'
- en: By default, the left and top properties refer to the top left edge of the web
    page. This reference point is different when any parent of this DOM node has a
    `position` style set explicitly. The reference point of the left and top properties
    becomes the top left edge of that parent.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，left和top属性是指网页的左上角。当这个DOM节点的任何父节点都显式设置了`position`样式时，这个参考点就会不同。left和top属性的参考点变成了那个父节点的左上角。
- en: 'This is why we need to set the playground with relative position and all game
    elements inside with absolute position. The following code snippet from our example
    shows their position values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要将游乐场设置为相对位置，所有游戏元素都在绝对位置内。我们示例中的以下代码片段显示了它们的位置值：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Pop quiz
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: Which jQuery selector is to be used if you want to select all header elements?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用哪个jQuery选择器，如果你想选择所有的标题元素？
- en: a. $("#header")
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: a. $("#header")
- en: b. $(".header")
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: b. $(".header")
- en: c. $("header")
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: c. $("header")
- en: d. $(header)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: d. $(header)
- en: Getting a keyboard input from players
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从玩家那里获取键盘输入
- en: 'This book is about game development. We can think about game development as
    the following loop:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于游戏开发的。我们可以将游戏开发看作是以下循环：
- en: A game state is visually displayed.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏状态被可视化显示。
- en: Players input their commands.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家输入他们的命令。
- en: The game runs according to the players' input under the designed game mechanics.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏根据玩家的输入在设计好的游戏机制下运行。
- en: Loop the process again from step 1.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次从步骤1开始循环该过程。
- en: We learned how to display game objects with CSS and jQuery in previous sections.
    The next thing we need to create in the game is getting input from the players.
    We will discuss the keyboard input in this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学会了如何用CSS和jQuery显示游戏对象。接下来我们需要在游戏中获取玩家的输入。在本章中我们将讨论键盘输入。
- en: Time for action Moving DOM objects by a keyboard input
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 通过键盘输入移动DOM对象
- en: 'We are going to create a traditional ping pong game. There are two paddles
    on the left and right side. A ball is placed in the middle of the playground.
    Players can control the left paddle and move it up and down by using *w* and *s*
    keys, and use *arrow-up* and *down* keys for the right paddle. We will focus on
    the keyboard input and leave the ball movement for the later section:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个传统的乒乓球游戏。左右两侧有两个球拍。球放在操场的中间。玩家可以通过使用*w*和*s*键来控制左球拍的上下移动，使用*箭头上*和*下*键来控制右球拍。我们将专注于键盘输入，将球的移动留到后面的部分：
- en: Let's continue with our `pingpong` directory.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续进行`pingpong`目录。
- en: 'Open the `html5games.pingpong.js` file which will contain our game logic. Our
    only logic now is to listen to the key down event and move the corresponding paddles
    up or down. Replace the content in the file with the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.pingpong.js`文件，其中包含我们的游戏逻辑。我们现在唯一的逻辑是监听按键按下事件并移动相应的球拍上下。用以下代码替换文件中的内容：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's test the paddle control of the game. Open the `index.html` in Google Chrome.
    Try pressing the *w* key, the *s* key, and *arrow-up* and *down*. The two paddles
    should be able to move up or down according to the input, but they cannot move
    at the same time now.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试游戏的球拍控制。在Google Chrome中打开`index.html`。尝试按下*w*键、*s*键和*箭头上*和*下*。两个球拍应该能够根据输入向上或向下移动，但现在它们不能同时移动。
- en: '![Time for action Moving DOM objects by a keyboard input](img/1260_02_06.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 通过键盘输入移动DOM对象](img/1260_02_06.jpg)'
- en: What just happened?
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: Let's take a look at the HTML code we just used. The HTML page contains header,
    footer information, and a DIV with ID `game`. The game node contains a child named
    playground. The playground contains three children, two paddles, and the ball.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚使用的HTML代码。HTML页面包含页眉、页脚信息和一个ID为`game`的DIV。游戏节点包含一个名为playground的子节点。playground包含三个子节点，两个球拍和一个球。
- en: We often start the HTML5 game development by preparing a well-structured HTML
    hierarchy. The HTML hierarchy helps us group similar game objects (which are some
    DIVs) together. It is a little like grouping assets into a movie clip in Adobe
    Flash if you have ever made animations with it. We may also consider it as layers
    of game objects for us to select and style them easily.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过准备一个结构良好的HTML层次结构来开始HTML5游戏开发。HTML层次结构帮助我们将类似的游戏对象（即一些DIV）分组在一起。这有点像在Adobe
    Flash中将资产分组到电影剪辑中，如果你以前用过它制作动画的话。我们也可以将其视为游戏对象的图层，以便我们可以轻松地选择和样式化它们。
- en: Understanding a key code
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解键码
- en: Every key on the keyboard is assigned a number. By getting that number, we can
    find out which key is pressed. We listen to the jQuery `keydown` event listener.
    The event fires with the `event` object containing the **key code**. We can obtain
    the key code by calling the `which` function to the key down `event` object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘上的每个键都被分配一个数字。通过获取该数字，我们可以找出按下了哪个键。我们监听jQuery的`keydown`事件监听器。事件触发时，`event`对象包含**键码**。我们可以通过调用`which`函数来获取按下键的键码。
- en: 'You can try adding a console log function inside the `keydown` event listener
    and observe the representing integer of each key:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试在`keydown`事件监听器中添加一个控制台日志函数，并观察每个键的表示整数：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Making constants more readable
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使常量更易读
- en: 'In our example, we use the key code to check whether the player hits the keys
    we are interested in. Take the arrow-up key as an example. Its key code is 38\.
    We can simply compare the key code with the number directly, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用键码来检查玩家是否按下我们感兴趣的键。以箭头上键为例。它的键码是38。我们可以简单地将键码与数字直接进行比较，如下所示：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, this is not a recommended practice because it makes the game code
    more difficult to maintain. Imagine later if we want to map the action from the
    arrow-up key to another key. We may not be sure whether 38 means the arrow-up.
    Instead, we can give the constant a meaningful name with the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一种推荐的做法，因为它使游戏代码更难以维护。想象一下，如果以后我们想要将动作从箭头上键映射到另一个键。我们可能不确定38是否表示箭头上。相反，我们可以使用以下代码为常量赋予一个有意义的名称：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By giving 38 a name `KEY.UP`, we can be sure that the block of code is mapped
    to the arrow-up key and so we can modify it without doubt when maintaining the
    game.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给38命名为`KEY.UP`，我们可以确保代码块与箭头上键相关联，因此在维护游戏时我们可以毫无疑问地进行修改。
- en: Converting strings to numbers with parseInt function
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用parseInt函数将字符串转换为数字
- en: In most cases, we apply the left and top CSS styles to DOM elements by using
    the format such as **100px**. We specify the unit when setting the property. It
    is the same when we get the value of the property. When we call `$("#paddleA").css("top")`,
    we get the value of **100px** instead of **100**. This gives us a problem when
    we want to perform an arithmetic operation on the value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们通过使用格式如**100px**来将左侧和顶部的CSS样式应用于DOM元素。在设置属性时，我们指定单位。当获取属性的值时也是一样的。当我们调用`$("#paddleA").css("top")`时，我们得到的值是**100px**而不是**100**。这在我们想要对该值进行算术运算时会给我们带来问题。
- en: In most cases, we apply the left and top CSS styles to DOM elements by using
    the format such as **100px**. We specify the unit when setting the property. It
    is the same when we get the value of the property. When we call `$("#paddleA").css("top")`,
    we get the value of **100px** instead of **100**. This gives us a problem when
    we want to perform an arithmetic operation on the value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们通过使用格式如**100px**来将左侧和顶部的CSS样式应用于DOM元素。在设置属性时，我们指定单位。当获取属性的值时也是一样的。当我们调用`$("#paddleA").css("top")`时，我们得到的值是**100px**而不是**100**。这在我们想要对该值进行算术运算时会给我们带来问题。
- en: In the example, we want to move up the paddle by setting the paddle `top` property
    to its current position minus five pixels. Let us assume paddle A has the `top`
    property set to 100px now. If we use the following expression to add five pixels,
    it fails and returns `100px5:`
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想通过将球拍的`top`属性设置为其当前位置减去五个像素来将球拍移动到上方。假设球拍A现在的`top`属性设置为100px。如果我们使用以下表达式来添加五个像素，它会失败并返回`100px5`：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is because JavaScript executes the `css` function and gets "100px". Then
    it appends "5" to the "100px" string.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为JavaScript执行了`css`函数并得到了"100px"。然后它将"5"附加到"100px"字符串上。
- en: We need a method to convert the "100px" string before doing any mathematical
    operation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何数学运算之前，我们需要一种方法来转换"100px"字符串。
- en: JavaScript provides us with the `parseInt` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript为我们提供了`parseInt`函数。
- en: 'Here is a general definition of how to use the `parseInt` function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`parseInt`函数的一般定义：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `parseInt` function takes one required argument and one option:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt`函数需要一个必需参数和一个可选参数：'
- en: '| Argument | Definition | Discussion |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| String | The string to be parsed | The function parses the first number of
    the string. It will return `NaN`, Not a Number, if the given string cannot be
    converted into a number.It will parse the string starting with "0x" in hexadecimal
    by default.Take the following code as examples:`parseInt("100px")` returns 100.`parseInt("5cm")`
    returns 5.`parseInt("0xF")` returns 15. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 要解析的字符串 | 该函数解析字符串的第一个数字。如果给定的字符串无法转换为数字，则返回`NaN`，即非数字。它将默认以十六进制解析以"0x"开头的字符串。以下代码是例子：`parseInt("100px")`返回100。`parseInt("5cm")`返回5。`parseInt("0xF")`返回15。
    |'
- en: '| Radix | Optional. A number to indicate which number system to be used | The
    second argument forces the `parseInt` function to parse the string in a given
    number system.For example:`parseInt("0x10")` returns 16`parseInt("0x10",10)` returns
    0`parseInt("FF",16)` returns 255 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 基数 | 可选。用于指示要使用的数字系统的数字 | 第二个参数强制`parseInt`函数解析给定数字系统中的字符串。例如：`parseInt("0x10")`返回16`parseInt("0x10",10)`返回0`parseInt("FF",16)`返回255
    |'
- en: Executing JavaScript expressions directly in the Console panel
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制台面板中直接执行JavaScript表达式
- en: You should also know that you can execute JavaScript expressions by directly
    typing it into the console window. The console window is a tool from the Developer
    Tool in Google Chrome. (There are also other similar tools in other web browsers).
    We can open the console by clicking on **Wrench Icon | Tools | Developer tools
    | Console**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该知道，你可以通过直接在控制台窗口中输入JavaScript表达式来执行JavaScript表达式。控制台窗口是Google Chrome开发者工具中的一个工具。(其他浏览器中也有类似的工具)。我们可以通过点击**扳手图标
    | 工具 | 开发者工具 | 控制台**来打开控制台。
- en: 'It is a handy way to quickly test a simple expression when you are not sure
    whether it works during development. The following screenshot tests the return
    value of the two `parseInt` expressions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方便的方法，在开发过程中，当你不确定一个简单表达式是否有效时，可以快速测试一下。以下截图测试了两个`parseInt`表达式的返回值：
- en: '![Executing JavaScript expressions directly in the Console panel](img/1260_02_07.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: 在控制台面板中直接执行JavaScript表达式
- en: Have a go hero
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试吧
- en: Converting strings to integers can be tricky sometimes. Do you know what is
    the `parseInt` result of *10 seconds 20?* How about *10x10* and *$20.5?*
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将字符串转换为整数可能会很棘手。你知道*10秒20*的`parseInt`结果是什么吗？*10x10*和*$20.5*呢？
- en: It is time to open the console panel and try converting some strings into numbers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候打开控制台面板，尝试将一些字符串转换为数字。
- en: Checking the console window
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查控制台窗口
- en: We are writing more complicated logic code now. It is good practice to keep
    an eye on the console of the Developers Tools. If the code contains any error
    or warning, the error message will appear there. It reports any error found and
    the line of code that contains the error. It is very useful and important to have
    the console window open when testing the HTML5 games. I have seen many times that
    people get stuck and have no idea as to why the code is not working. The reason
    is that they have a typo or syntax error and they did not check the console window
    until fighting with the code for hours.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在编写更复杂的逻辑代码。在开发者工具的控制台上保持警惕是一个好习惯。如果代码中包含任何错误或警告，错误消息将会出现在那里。它报告发现的任何错误以及包含错误的代码行。在测试HTML5游戏时，保持控制台窗口打开非常有用和重要。我曾经看到很多人因为代码不起作用而束手无策。原因是他们有拼写错误或语法错误，而他们在与代码搏斗数小时后才检查控制台窗口。
- en: 'The following screenshot shows that there is an error in line 25 of the `html5games.pingpong.js`
    file. The error message is **Invalid left-hand side in assignment**. After inspecting
    the code, I found that I wrongly used an equal sign (=) when setting the CSS `top`
    property in jQuery:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`html5games.pingpong.js`文件的第25行存在错误。错误消息是**赋值中的无效左侧**。检查代码后，我发现我在设置jQuery中的CSS
    `top`属性时错误地使用了等号(=)：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Checking the console window](img/1260_02_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![检查控制台窗口](img/1260_02_08.jpg)'
- en: Supporting multiple keyboard input from players
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持多个玩家的键盘输入
- en: The previous input method only allows one input at a time. The keyboard input
    is also not so smooth. Imagine now that two players are playing the Ping Pong
    game together. They cannot control the paddle well because their inputs interrupt
    the others. In this section, we are going to modify our code to make it support
    multiple keyboard inputs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的输入方法只允许一次输入。键盘输入也不太顺畅。现在想象一下，两个玩家一起玩乒乓球游戏。他们无法很好地控制球拍，因为他们的输入会干扰对方。在本节中，我们将修改我们的代码，使其支持多个键盘输入。
- en: Time for action Listening to keyboard input with another approach
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 使用另一种方法监听键盘输入
- en: 'We will use another approach to handle the key down event. This approach will
    be a lot smoother and supports multiple inputs at the same time:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用另一种方法来处理按键按下事件。这种方法会更加顺畅，并支持同时进行多个输入：
- en: Open the `html5games.pingpong.js` we used in the last section.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在上一节中使用的`html5games.pingpong.js`。
- en: Delete all the code we coded there. It is simpler to start from scratch.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除我们在那里编写的所有代码。从头开始会更简单。
- en: 'We will need a global variable of array to store the key pressed status. Enter
    the following code in the opened JavaScript file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个全局变量数组来存储按键的状态。在打开的JavaScript文件中输入以下代码：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next thing is the code is executed once the page is loaded and ready. It
    will listen and mark the pressed key. Put the following code in the JavaScript
    file after the two lines we just coded there:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的事情是页面加载并准备就绪后执行代码。它将监听并标记按下的键。将以下代码放在我们刚刚编写的两行代码之后的JavaScript文件中：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have stored the key which is pressed. What we are missing is actually moving
    the paddles. We set a timer to continuously call a function to move the paddles.
    Paste the following code in the `html5games.pingpong.js` file:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经存储了按下的键。我们缺少的是实际移动挡板。我们设置了一个定时器来连续调用一个移动挡板的函数。将以下代码粘贴到`html5games.pingpong.js`文件中：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's test what we just coded. Save all the files and open `index.html` in the
    web browser.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试一下我们刚刚编写的代码。保存所有文件，然后在Web浏览器中打开`index.html`。
- en: Try pressing the keys to control both paddles. The two paddles should move smoothly
    and respond at the same time without interruption.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试按键控制两个挡板。两个挡板应该平稳移动，并且同时响应，没有中断。
- en: What just happened?
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have used another approach to capture the keyboard input. Instead of doing
    the action once after the key press is detected, we store which keys are pressed
    and which are not. Afterwards, we use a JavaScript interval to check the pressed
    keys every 30 milliseconds. This approach enables us to know all the keys pressed
    at the time and so we can move both paddles at the same time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了另一种方法来捕获键盘输入。我们不是在检测到按键按下后立即执行动作，而是存储哪些键被按下，哪些没有。然后，我们使用JavaScript间隔每30毫秒检查按下的键。这种方法使我们能够同时知道当时按下的所有键，因此我们可以同时移动两个挡板。
- en: Declaring global variables in a better way
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好地声明全局变量
- en: '**Global variables** are variables that can be accessed globally in the entire
    document. Any variable that is declared outside any function is a global variable.
    For instance, in the following example code snippets, `a` and `b` are global variables
    while `c` is a **local variable** that only exists inside the function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局变量**是可以在整个文档中全局访问的变量。在任何函数外声明的变量都是全局变量。例如，在以下示例代码片段中，`a`和`b`是全局变量，而`c`是一个**局部变量**，只存在于函数内部：'
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since global variables are available in the entire document, it may increase
    the change of variable name conflicts if we integrate different JavaScript libraries
    into the web page. As good practice, we should put all global variables we use
    into an object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于全局变量在整个文档中都可用，如果我们将不同的JavaScript库集成到网页中，可能会增加变量名冲突的可能性。作为良好的实践，我们应该将所有使用的全局变量放入一个对象中。
- en: 'In the *Time for action* section, we have a global array to store all pressed
    keys. Instead of just putting this array in global scope, we created a global
    object named `pingpong` and put the array inside it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在*行动时间*部分，我们有一个全局数组来存储所有按下的键。我们不仅将这个数组放在全局范围内，而是创建了一个名为`pingpong`的全局对象，并将数组放在其中：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the future, we may need more global variables and we will put them all inside
    the `pingpong` object. This reduces the chance of name confliction to only one
    name, `pingpong`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，我们可能需要更多的全局变量，我们将把它们全部放在`pingpong`对象中。这样可以将名称冲突的机会减少到只有一个名称，`pingpong`。
- en: Creating a JavaScript timer with setInterval function
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用setInterval函数创建JavaScript定时器
- en: The pressed keys are stored in the array and we have a timer to loop and check
    the array periodically. This can be done by the `setInterval` function in JavaScript.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 按下的键存储在数组中，我们有一个定时器定期循环和检查数组。这可以通过JavaScript中的`setInterval`函数来实现。
- en: 'Here is the general definition of the `setInterval` function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`setInterval`函数的一般定义：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `setInterval` takes two required arguments:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval`接受两个必需的参数：'
- en: '| Argument | Definition | Discussion |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| expression | The function call back or code expression to be executed | The
    expression can be a reference of function call back or an inline code expression.
    The inline code expression is quoted and reference of function call back is not.For
    example, the following code calls the `hello` function 100 milliseconds:setInterval(hello,100);The
    following code calls the `hi` function with parameters every 100 milliseconds:setInterval("hi(''Makzan'')",100);
    |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 要执行的函数回调或代码表达式 | 表达式可以是函数回调的引用或内联代码表达式。内联代码表达式需要引号，而函数回调的引用则不需要。例如，以下代码每100毫秒调用`hello`函数：setInterval(hello,100);以下代码每100毫秒调用带参数的`hi`函数：setInterval("hi(''Makzan'')",100);
    |'
- en: '| milliseconds | The duration between every execution of the expression, in
    milliseconds | The unit of the interval is in milliseconds. Therefore, setting
    it to 1000 means running the expression every second. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 毫秒 | 表达式每次执行之间的持续时间，以毫秒为单位 | 时间间隔的单位是毫秒。因此，将其设置为1000意味着每秒运行一次表达式。 |'
- en: Understanding Game Loop
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解游戏循环
- en: We have a timer to execute some game-related code every 30 milliseconds, so
    this code is executed 33.3 times per second. In game development, this is called
    **Game Loop.**
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个定时器，每30毫秒执行一些与游戏相关的代码，因此这段代码每秒执行33.3次。在游戏开发中，这称为**游戏循环**。
- en: 'There are several common things we will execute inside a game loop:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环中，我们将执行几个常见的事情：
- en: Processing user input, which we just did
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入，我们刚刚做了
- en: Updating game objects' status, including position and appearance
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新游戏对象的状态，包括位置和外观
- en: Checking game over
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查游戏结束
- en: What is actually executing in the game loop differs in different types of games
    but the purpose is the same. The game loop is executed periodically to help run
    the game smoothly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环中实际执行的内容因不同类型的游戏而异，但目的是相同的。游戏循环定期执行，以帮助游戏平稳运行。
- en: Moving a DOM object with JavaScript Interval
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript间隔移动DOM对象
- en: Imagine now we can make the little red ball move around in the playground. The
    ball will bounce away when it hits the paddles. The player will lose a score when
    the ball passes the paddle and hits the playground edge behind the paddle. All
    these actions are manipulating the position of the DIVs inside the HTML page by
    jQuery. To complete this Ping Pong game, our next step is to move the ball.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们可以使小红球在操场上移动。当它击中球拍时，球会弹开。当球通过球拍并击中球拍后面的操场边缘时，玩家将失去得分。所有这些操作都是通过jQuery在HTML页面中操纵DIV的位置。要完成这个乒乓球游戏，我们的下一步是移动球。
- en: Time for action Moving the ball with JavaScript Interval
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用JavaScript间隔移动球的时间
- en: 'We just learnt and used the `setInterval` function to create a timer. We will
    use the timer to move the ball a little bit every 30 milliseconds. We are going
    to also change the direction of the ball movement once it hits the playground
    edge. Let''s make the ball move now:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习并使用了`setInterval`函数来创建一个定时器。我们将使用定时器每30毫秒移动球一点。当球击中操场边缘时，我们还将改变球运动的方向。现在让球动起来：
- en: We will use our last example, listening to multiple keyboard inputs, as the
    starting point.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们上一个示例，监听多个键盘输入，作为起点。
- en: Open the `html5games.pingpong.js` file in the text editor.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`html5games.pingpong.js`文件。
- en: 'We are now moving the ball and we need to store the ball status globally. We
    will put the ball-related variable inside the `pingpong` object:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在正在移动球，我们需要全局存储球的状态。我们将把与球相关的变量放在`pingpong`对象中：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In every game loop, we used to move the paddles. Now we will move the ball
    as well. Add a `moveBall` function call to the `gameloop` function:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个游戏循环中，我们都会移动球拍。现在我们也会移动球。在`gameloop`函数中添加一个`moveBall`函数调用：
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It is time to define the `moveBall` function. The function is divided into
    four parts, it gets the current ball position, checks the boundaries of the playground,
    changes the direction of the ball when hitting the boundaries and actually moves
    the ball after all these calculations. Let''s put the following `moveBall` function
    definition in the JavaScript file:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候定义`moveBall`函数了。该函数分为四个部分，它获取当前球的位置，检查操场的边界，在击中边界时改变球的方向，并在所有这些计算之后实际移动球。让我们把以下`moveBall`函数定义放在JavaScript文件中：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have prepared the code to move the ball every 30 milliseconds. Save all files
    and open `index.html` in Google Chrome to test it.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好了每30毫秒移动一次球的代码。保存所有文件并在Google Chrome中打开`index.html`进行测试。
- en: The paddles work just as in the last example and the ball should be moving around
    the playground.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 球拍的工作方式与上一个示例中的相同，球应该在操场上移动。
- en: What just happened?
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just successfully made the ball move around the playground. We have a loop
    to run routine game logic every 30 milliseconds. Inside that game loop, we move
    the ball five pixels at a time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚成功地使球在操场上移动。我们有一个循环，每30毫秒运行一次常规游戏逻辑。在游戏循环中，我们每次移动球五个像素。
- en: 'There are three properties of the ball, speed, and direction X/Y. The speed
    defines how many pixels the ball moves in each step. The direction X/Y is either
    1 or -1\. We move the ball with the following equation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 球的三个属性是速度和方向X/Y。速度定义了球在每一步中移动多少像素。方向X/Y要么是1，要么是-1。我们用以下方程移动球：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The direction value is multiplied by the movement. When the direction is 1,
    the ball moves to the positive direction of the axis. When the direction is -1,
    the ball moves to the negative direction. By toggling the X and Y directions,
    we can move the ball in four directions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 方向值乘以移动。当方向为1时，球向轴的正方向移动。当方向为-1时，球向负方向移动。通过切换X和Y方向，我们可以使球在四个方向上移动。
- en: We compare the ball's X and Y with the four edges of the playground DIV element.
    This checks whether the ball's next position is beyond the boundary and then we
    toggle the direction between 1 and -1 to create the bouncing effect.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将球的X和Y与操场DIV元素的四个边缘进行比较。这将检查球的下一个位置是否超出边界，然后我们在1和-1之间切换方向以创建弹跳效果。
- en: Beginning collision detection
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始碰撞检测
- en: We have checked the boundary of the playground when moving the ball in the previous
    section. Now we can control the paddles with the keyboard and watch the ball moving
    around the playground. What is missing now? We cannot interact with the ball.
    We control the paddles but the ball just passes through them as if they are not
    there. It is because we missed the collision detection between the paddles and
    the moving ball.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中移动球时，我们已经检查了操场的边界。现在我们可以用键盘控制球拍并观察球在操场上移动。现在还缺少什么？我们无法与球互动。我们可以控制球拍，但球却像它们不存在一样穿过它们。这是因为我们错过了球拍和移动球之间的碰撞检测。
- en: Time for action Hitting the ball with the paddles
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与球拍击球的时间
- en: 'We will use a similar approach of checking the boundary to check the collision:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似的方法来检查碰撞的边界：
- en: Open the `html5games.pingpong.js` file we used in the previous section.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在上一节中使用的`html5games.pingpong.js`文件。
- en: In the `moveball` function, we have already reserved the place to put the collision
    detection code there. Find the line with `// check moving paddle here`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`moveball`函数中，我们已经预留了放置碰撞检测代码的位置。找到带有`// check moving paddle here`的行。
- en: 'Let''s put the following code there. The code checks whether the ball is overlapping
    with either paddle and bounces the ball away when they overlap:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把以下代码放在那里。该代码检查球是否与任一球拍重叠，并在它们重叠时将球弹开：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will also need to reset the ball in the middle area after the ball hits
    the left or right edge of the playground. Remove the bouncing ball code in the
    `check right` and `check left` code section and paste the following code there:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当球击中操场的左侧或右侧边缘后，我们还需要将球重置在中间区域。删除`check right`和`check left`代码部分中的弹球代码，并粘贴以下代码：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Test the game in a browser and the ball will now bounce away after hitting the
    left or right paddle. It will also reset to the center of the playground when
    hitting the left or right edge.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中测试游戏，现在球在击中左右球拍后会弹开。当击中左右边缘时，它也会重置到操场的中心。
- en: '![Time for action Hitting the ball with the paddles](img/1260_02_09.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![进行操作，用球拍击球](img/1260_02_09.jpg)'
- en: What just happened?
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have modified the ball checking to make it bounce away when overlapping with
    the paddles. Moreover, we reposition the ball in the center of the playground
    when hitting the left and right edge.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修改了球的检查，使其在与球拍重叠时弹开。此外，当击中左右边缘时，我们将球重新定位到操场的中心。
- en: Let's see how we check the collision between the ball and the left paddle.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何检查球和左球拍之间的碰撞。
- en: At first, we check whether the ball's X position is less than the left paddle's
    right edge. The right edge is the `left` value plus the `width` of the paddle.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查球的X位置是否小于左球拍的右边缘。右边缘是`left`值加上球拍的`width`。
- en: '![What just happened?](img/1260_02_10.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_02_10.jpg)'
- en: Then we check whether the ball's Y position is between the top edge and bottom
    edge of the paddle. The top edge is the `top` value and the bottom edge is the
    `top` value plus the `height` of the paddle.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查球的Y位置是否在球拍的顶部边缘和底部边缘之间。顶部边缘是`top`值，底部边缘是`top`值加上球拍的`height`。
- en: '![What just happened?](img/1260_02_11.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_02_11.jpg)'
- en: We bounce the ball away if the ball's position passes both checks. This is how
    we check it and it is just a basic collision detection.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球的位置通过了两个检查，我们就会将球弹开。这就是我们检查它的方式，这只是一个基本的碰撞检测。
- en: We determine that the two objects are overlapped by checking their position
    and width/height. This type of collision detection works well in rectangle objects
    but is not good for circles and other shapes. The following screenshot illustrates
    the issue. The collision areas shown in the following graph are false positive.
    Their bounding box collides but the actual shapes do not overlap each other.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查它们的位置和宽度/高度来确定这两个对象是否重叠。这种类型的碰撞检测对于矩形对象效果很好，但对于圆形和其他形状则不太好。以下截图说明了问题。以下图中显示的碰撞区域是误报。它们的边界框碰撞了，但实际形状并没有重叠。
- en: '![What just happened?](img/1260_02_12.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_02_12.jpg)'
- en: For special shapes, we will need more advanced collision detection techniques
    that we will discuss later.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特殊形状，我们将需要更高级的碰撞检测技术，我们将在后面讨论。
- en: Have a go hero
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试吧
- en: We check three edges of the paddles to determine whether the ball overlaps with
    them. If you play the game and observe the ball bouncing carefully, you will find
    that it is not perfect now. The ball may bounce while behind the paddles. Think
    about the reason and modify the code to make a better collision detection with
    the ball and the paddles.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查球拍的三个边缘，以确定球是否与它们重叠。如果你玩游戏并仔细观察球的弹跳，你会发现现在它并不完美。球可能会在球拍后面弹跳。思考原因，并修改代码以实现更好的球和球拍的碰撞检测。
- en: Showing text dynamically in HTML
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTML中动态显示文本
- en: We have the basic game mechanics implemented in the previous sections. Our Ping
    Pong game is missing a scoring board now showing both players' scores. We discussed
    how to use jQuery to modify the CSS styles of the selected elements. Can we also
    alter the content of the selected elements with jQuery? Yes, we can.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分实现了基本的游戏机制。我们的乒乓球游戏现在缺少一个计分板，可以显示两名玩家的得分。我们讨论了如何使用jQuery来修改所选元素的CSS样式。我们是否也可以用jQuery来改变所选元素的内容？是的，我们可以。
- en: Time for action Showing the score of both players
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行操作，显示两名玩家的得分
- en: 'We are going to create a text-based scoreboard and update the scores when either
    player scores a goal:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基于文本的计分板，并在任一玩家得分时更新得分：
- en: We are making improvements on our existing game so we use the last example as
    the starting point.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在改进我们现有的游戏，所以我们将上一个示例作为起点。
- en: Open the `index.html` in the text editor. We are going to add the scoreboard
    DOM elements.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`index.html`。我们将添加计分板的DOM元素。
- en: Add the following HTML code before the `game` DIV inside `index.html:`
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`的`game` DIV内部之前添加以下HTML代码：
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let's move onto the JavaScript part. Open the `html5games.pingpong.js` file.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到JavaScript部分。打开`html5games.pingpong.js`文件。
- en: 'We need two more global variables to store the players'' scores. Add their
    score variables inside the `pingpong` global object:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个全局变量来存储玩家的得分。在`pingpong`全局对象内添加他们的得分变量：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We had a place to check if player B lost. We incremented the player A''s score
    there and updated the scoreboard with the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个地方来检查玩家B是否输掉了比赛。我们在那里增加了玩家A的得分，并用以下代码更新了计分板：
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have similar code as in step 6 to update player B''s score when player A
    lost:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在第6步中有类似的代码，用于在玩家A输掉比赛时更新玩家B的得分：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is time to test our latest code. Open the `index.html` in a web browser.
    Try playing by controlling both paddles and lose some points. The scoreboard should
    be counting the scores correctly:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是测试我们最新代码的时候了。在Web浏览器中打开`index.html`。尝试通过控制两个球拍来玩游戏，并失去一些分数。计分板应该正确计分：
- en: '![Time for action Showing the score of both players](img/1260_02_13.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![进行操作，显示两名玩家的得分](img/1260_02_13.jpg)'
- en: What just happened?
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We just used another common jQuery function: `html()` to alter the content
    of the game on the fly.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用了另一个常见的jQuery函数：`html()`来动态改变游戏内容。
- en: 'The `html()` function gets or updates the HTML content of the selected element.
    Here is a general definition of the `html()` function:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`html()`函数获取或更新所选元素的HTML内容。以下是`html()`函数的一般定义：'
- en: '[PRE41]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When we use the html ( ) function without an argument, it returns the HTML content
    of the first match element. When we use it with an argument, it sets the HTML
    content to all matched elements with the given HTML string.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`html()`函数时，如果没有参数，它会返回第一个匹配元素的HTML内容。如果带有参数使用，它会将HTML内容设置为所有匹配元素的给定HTML字符串。
- en: 'For example, provide the following HTML structure:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，提供以下HTML结构：
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Both the following jQuery calls return Makzan:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个jQuery调用都返回Makzan：
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, in the following jQuery call, it sets all matched elements to the
    given HTML content:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下面的jQuery调用中，它将所有匹配的元素设置为给定的HTML内容：
- en: '[PRE44]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Executing the jQuery command makes the following HTML result:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 执行jQuery命令会产生以下HTML结果：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Have a go hero Winning the game
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试赢得比赛
- en: We have the scoring now. See whether you can modify the game to make it stop
    after any player gets 10 points. Then show a win message.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了得分。看看你是否可以修改游戏，使其在任何玩家得到10分后停止。然后显示一个获胜消息。
- en: You might also want to try styling the game to make it more appealing. How about
    giving the scoreboard and playground some image backgrounds? Replacing the paddles
    with two goalkeeper characters?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想尝试对游戏进行样式设置，使其更具吸引力。给记分牌和游乐场添加一些图像背景怎么样？用两个守门员角色替换球拍？
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about basic techniques of creating a simple
    Ping Pong game with HTML5 and JavaScript.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了许多关于使用HTML5和JavaScript创建简单乒乓球游戏的基本技术。
- en: 'Specifically, we covered:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: Creating our first HTML5 game—Ping Pong
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个HTML5游戏——乒乓球
- en: Using jQuery to manipulate DOM objects
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery操作DOM对象
- en: Getting keyboard inputs with multiple keys down support
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取支持多个按键按下的键盘输入
- en: Detecting collisions with the bounding box
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测与边界框的碰撞
- en: We also discussed how to create a game loop and move the ball and paddles.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何创建游戏循环并移动球和球拍。
- en: Now that we've warmed up by creating a simple DOM-based game, we are ready to
    create more advanced DOM-based games with new features from CSS3\. In the next
    chapter, we will create games with CSS3 animation, transition, and transformation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过创建一个简单的基于DOM的游戏来热身，我们准备使用CSS3的新功能创建更高级的基于DOM的游戏。在下一章中，我们将创建具有CSS3动画、过渡和变换的游戏。
