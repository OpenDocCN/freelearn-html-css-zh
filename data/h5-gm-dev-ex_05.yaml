- en: Chapter 5. Building a Canvas Games Masterclass
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。构建Canvas游戏大师班
- en: In the previous chapter, we explored some basic canvas context drawing APIs
    and created a game named Untangle. In this chapter, we are going to enhance the
    game by using some other context drawing APIs.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在上一章中，我们探索了一些基本的画布上下文绘图API，并创建了一个名为Untangle的游戏。在本章中，我们将通过使用其他一些上下文绘图API来增强游戏。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Fill our game objects with gradient color
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用渐变颜色填充我们的游戏对象
- en: Fill text in the canvas with custom webfont
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布中使用自定义网络字体填充文本
- en: Draw images in Canvas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Canvas中绘制图像
- en: Animate a sprite sheet image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画精灵表图像
- en: And build multiple canvas layers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并构建多个画布层
- en: 'The following screenshot is a preview to the final result that we are going
    to build through this chapter. It is a canvas-based Untangle game with an animated
    game guideline and several subtle details:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是我们将通过本章构建的最终结果的预览。它是一个基于Canvas的Untangle游戏，带有动画游戏指南和一些细微的细节：
- en: '![Building a Canvas Games Masterclass](img/1260_05_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![构建Canvas游戏大师班](img/1260_05_01.jpg)'
- en: So let's get on with it...
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始吧...
- en: Filling shapes with gradient color
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用渐变颜色填充形状
- en: We covered filling solid color in the last chapter. Canvas can do far more when
    filling shapes. We can fill the shape with both linear and radial gradient.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了填充纯色。Canvas在填充形状时可以做得更多。我们可以用线性渐变和径向渐变填充形状。
- en: Time for action Drawing a gradient color background to the Untangle game
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 给Untangle游戏绘制渐变颜色背景
- en: Let's improve the black solid background we have now. How about drawing a gradient
    from top to bottom?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进一下我们现在的纯黑色背景。如何从上到下绘制一个渐变呢？
- en: We will use the Untangle game we created in the last chapter as a starting point.
    Open the `html5games.untangle.js` JavaScript file in the text editor.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用上一章中创建的Untangle游戏作为起点。在文本编辑器中打开`html5games.untangle.js` JavaScript文件。
- en: 'Add the following code in the `gameloop` function after clearing the canvas
    to draw the **gradient** background:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameloop`函数中清除画布后，添加以下代码以绘制**渐变**背景：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the files and preview the `index.html` in the browser. The background should
    be a linear gradient with black on top which gradually becomes grey at the bottom.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中预览`index.html`。背景应该是一个线性渐变，顶部是黑色，逐渐变成底部的灰色。
- en: '![Time for action Drawing a gradient color background to the Untangle game](img/1260_05_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 给Untangle游戏绘制渐变颜色背景](img/1260_05_02.jpg)'
- en: What just happened?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just filled a rectangle with a **linear gradient** color. To fill linear
    gradient color, all we need to do is set the starting point and ending point of
    the gradient. Then we add several color stops between them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚用**线性渐变**颜色填充了一个矩形。要填充线性渐变颜色，我们只需要设置渐变的起点和终点。然后在它们之间添加几个颜色停止。
- en: 'Here is how we use the linear gradient function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用线性渐变函数的方式：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| Argument | Definition |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| x1 | The starting point of the gradient. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| x1 | 渐变的起点。 |'
- en: '| y1 |   |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| y1 |   |'
- en: '| x2 | The ending point of the gradient. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| x2 | 渐变的终点。 |'
- en: '| y2 |   |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| y2 |   |'
- en: Adding color stops in the gradient color
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在渐变颜色中添加颜色停止
- en: 'It is not enough to just have the starting and ending point. We also need to
    define what color we use and how it is applied to the gradient. It is called a
    **color stop** in gradient. We can add a color stop to the gradient by using the
    following `gradient` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅拥有起点和终点是不够的。我们还需要定义我们使用的颜色以及它如何应用到渐变中。这在渐变中被称为**颜色停止**。我们可以使用以下`gradient`函数向渐变中添加一个颜色停止：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| Argument | Definition | Discussion |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| position | A floating number between 0 and 1. | Position 0 means the color
    stops at the starting point and 1 means it stops at the ending point. Any number
    between 0 and 1 means it stops in between the starting and ending point.For example,
    0.5 means a half and 0.33 means 30 percent away from the starting point. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | 0到1之间的浮点数。 | 位置0表示颜色停在起点，1表示它停在终点。0到1之间的任何数字表示它停在起点和终点之间。例如，0.5表示一半，0.33表示离起点30%。
    |'
- en: '| color | The color style of that color stop. | The color style shares the
    same syntax from the CSS color styling. We may use the HEX expression, such as
    #FFDDAA. Or other color styles such as RGBA color name. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 颜色 | 那个颜色停止的颜色样式。 | 颜色样式与CSS颜色样式的语法相同。我们可以使用HEX表达式，如#FFDDAA。或其他颜色样式，如RGBA颜色名称。
    |'
- en: 'The follow screenshot shows a side-by-side comparison between a linear gradient
    setting and the result drawing. The starting point and ending point defines the
    scope and the angle of the gradient. The color stops define how the color mixes
    between the gradient scopes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了线性渐变设置和结果绘制之间的并排比较。起点和终点定义了渐变的范围和角度。颜色停止定义了颜色在渐变范围之间的混合方式：
- en: '![Adding color stops in the gradient color](img/1260_05_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![在渐变颜色中添加颜色停止](img/1260_05_03.jpg)'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Adding color stop with opacity**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加带不透明度的颜色停止**'
- en: 'We can set an opacity value to the color stop by using the RGBA function. The
    following code tells the gradient to start by using red color with half opacity:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用RGBA函数为颜色停止设置不透明度值。以下代码告诉渐变从红色开始，不透明度为一半：
- en: '`gradient.addColorStop(0, "rgba(255, 0, 0, 0.5)")`;'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`gradient.addColorStop(0, "rgba(255, 0, 0, 0.5)")`;'
- en: Filling radial gradient color
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充径向渐变颜色
- en: There are two types of gradients in the Canvas drawing API. The one we just
    used is called linear gradient. The other one is **radial gradient**. The radial
    gradient fills the gradient from one circle to another circle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas绘图API中有两种渐变类型。我们刚刚使用的是线性渐变。另一种是**径向渐变**。径向渐变从一个圆到另一个圆填充渐变。
- en: Time for action Filling the circles with radial gradient color
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 用径向渐变颜色填充圆
- en: 'Imagine that we now fill our dragging circles to radial gradient. We will change
    the solid yellow circles to white-yellow gradient:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们现在将我们拖动的圆填充为径向渐变。我们将把实心黄色圆改为白黄渐变：
- en: Open the `html5game.untangle.js` JavaScript file. We are going to modify the
    code we used to draw the circle in the game.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5game.untangle.js` JavaScript文件。我们将修改用于在游戏中绘制圆的代码。
- en: 'After we draw the circle path with the `arc` function and before we fill it
    we replace the original solid color style setting to the following radial gradient
    color:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`arc`函数绘制圆形路径后，填充之前，我们将原始的实色样式设置替换为以下径向渐变颜色：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the modified file and preview the `index.html` in a web browser. The circles
    are now filled with radial gradient color.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存修改后的文件，并在Web浏览器中预览`index.html`。现在圆形填充了径向渐变颜色。
- en: 'In the following screenshot I''ve scaled up the drawing to 200 percent to better
    demonstrate the radial gradient in the circle:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我将绘图放大到200％，以更好地演示圆形中的径向渐变：
- en: '![Time for action Filling the circles with radial gradient color](img/1260_05_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 填充圆形与径向渐变颜色](img/1260_05_04.jpg)'
- en: What just happened?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just made the dragging circles look more realistic by filling a radial gradient.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过填充径向渐变使拖动圆看起来更真实。
- en: 'Here is how we create a radial gradient:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们创建径向渐变的方法：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| Argument | Definition |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| x1, y1 | The center of the starting circle in x and y in the canvas coordinate.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| x1, y1 | 画布坐标中起始圆的中心x和y。 |'
- en: '| r1 | The radius of the starting circle. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| r1 | 起始圆的半径。 |'
- en: '| x2, y2 | The center of the ending circle in x and y in the canvas coordinate.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| x2, y2 | 画布坐标中结束圆的中心x和y。 |'
- en: '| r2 | The radius of the ending circle. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| r2 | 结束圆的半径。 |'
- en: 'The following screenshot shows a side-by-side comparison between a radial gradient
    setting and the final result drawing in canvas:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了径向渐变设置和画布中的最终结果之间的并排比较：
- en: '![What just happened?](img/1260_05_05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_05_05.jpg)'
- en: The radial gradient blends the color from the starting circle to the ending
    circle. In this gradient circle, the starting circle is a small circle in the
    center and the ending circle is the outermost circle. There are three color stops.
    A white color stops at both the starting and ending circle; another dark color
    stops 90 percent away from the starting circle.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 径向渐变将颜色从起始圆到结束圆进行混合。在这个渐变圆中，起始圆是中心的小圆，结束圆是最外面的圆。有三个颜色停止点。白色在起始和结束圆处停止；另一种深色在离起始圆90％的地方停止。
- en: Have a go hero Filling gradients
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄填充渐变
- en: We add color stops to the gradients to define how the colors blend. What happens
    if we forget to add any color stops to the gradient and fill a rectangle? What
    if we only define one color stop? Try experimenting with the color stop settings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向渐变中添加颜色停止点来定义颜色的混合方式。如果我们忘记向渐变中添加任何颜色停止点并填充一个矩形会发生什么？如果我们只定义一个颜色停止点会怎样？尝试实验颜色停止点设置。
- en: In the radial gradient example, the small starting circle is inside the bigger
    ending circle. What happens if the starting circle is bigger than the ending one?
    How about if the starting circle is not inside the ending circle? That is, what
    happens if the two circles do not overlap?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在径向渐变示例中，小的起始圆在较大的结束圆内。如果起始圆比结束圆大会发生什么？如果起始圆不在结束圆内会怎么样？也就是说，如果两个圆不重叠会发生什么？
- en: Drawing text in canvas
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布中绘制文本
- en: Imagine now we want to show the progress level directly inside the canvas. Canvas
    provides us with methods to draw text inside canvas.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们想直接在画布内显示进度级别。画布为我们提供了在画布内绘制文本的方法。
- en: Time for action Displaying the progress level text inside the canvas element
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 在画布元素内显示进度级别文本
- en: We will continue using our Untangle game. Open the `html5games.untangle.js`
    JavaScript file in text editor.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的Untangle游戏。在文本编辑器中打开`html5games.untangle.js` JavaScript文件。
- en: 'First, let''s make the level progress percentage a global variable so we can
    use it in different places:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将级别进度百分比设为全局变量，这样我们可以在不同的地方使用它：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following code after the canvas drawing code in the `gameloop` function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameloop`函数中的画布绘制代码之后添加以下代码：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the file and preview the `index.html` in a web browser. We will see that
    the text is now drawn inside the canvas.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在Web浏览器中预览`index.html`。我们会看到文本现在绘制在画布内。
- en: '![Time for action Displaying the progress level text inside the canvas element](img/1260_05_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 在画布元素内显示进度级别文本](img/1260_05_06.jpg)'
- en: What just happened?
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We have just drawn the title and the level progress text in our canvas-based
    game. We draw text in canvas by using the **fillText** function. The following
    table shows how we use the function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在基于画布的游戏中绘制了标题和级别进度文本。我们使用**fillText**函数在画布中绘制文本。以下表格显示了我们如何使用该函数：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Argument | Definition |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| string | The text that we are going to draw. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| string | 我们要绘制的文本。 |'
- en: '| x | The x coordinate that the text draws. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| x | 文本绘制的x坐标。 |'
- en: '| y | The y coordinate that the text draws. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| y | 文本绘制的y坐标。 |'
- en: This is the basic setting to draw a text. There are several more drawing context
    properties to set up the text drawing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是绘制文本的基本设置。还有几个绘图上下文属性需要设置文本绘制。
- en: '| Context properties | Definition | Discussion |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 上下文属性 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `context.font` | The font style of the text. | It shares the same syntax
    we used to declare font style in CSS. For example, the following code sets the
    font style to 20 pixels bold with Arial typeface:ctx.font = "bold 20px Arial";
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `context.font` | 文本的字体样式。 | 它与我们在CSS中声明字体样式所使用的语法相同。例如，以下代码将字体样式设置为20像素的Arial粗体：ctx.font
    = "bold 20px Arial"; |'
- en: '| `context.textAlign` | The text alignment. | The **alignment** defines how
    the text aligns. It can be one of the following values:startendleftrightcenterFor
    instance, if we are going to place a text on the right edge of the canvas. Using
    `left` alignment means we need to calculate text width in order to know the x
    coordinate of the text.When using right alignment in this case, all we need to
    do is set the x position directly to the canvas width. The text will then automatically
    be placed on the right edge of the canvas. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `context.textAlign` | 文本对齐。 | **对齐**定义了文本的对齐方式。可以是以下值之一：startendleftrightcenter例如，如果我们要将文本放在画布的右边缘。使用`left`对齐意味着我们需要计算文本宽度以知道文本的x坐标。在这种情况下使用右对齐，我们只需要将x位置直接设置为画布宽度。文本将自动放置在画布的右边缘。|'
- en: '| `context.textBaseline` | The text baseline. | The following lists the common
    value of a **textBaseline:**topmiddlebottomalphabetSimilar to the text alignment,
    the `bottom` **baseline** is useful when we want to place our text at the bottom
    of the canvas. The y position of the `fillText` function is based on the bottom
    baseline of the text instead of the top.The `alphabet` baseline aligns the y position
    based on the lower case alphabet. The following screenshot shows our text drawing
    with **alphabet** baseline. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `context.textBaseline` | 文本基线。 | 以下列出了**textBaseline**的常见值：topmiddlebottomalphabet与文本对齐类似，当我们想要将文本放在画布底部时，`bottom`
    **基线**是有用的。`fillText`函数的y位置是基于文本的底部基线而不是顶部。`alphabet`基线根据小写字母表对齐y位置。以下截图显示了我们使用**alphabet**基线的文本绘制。|'
- en: '![What just happened?](img/1260_05_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_05_07.jpg)'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please beware that the text drawing in canvas is treated as bitmap image data.
    That means visitors cannot select the text; search engines cannot index the text;
    we cannot search them. For this reason, we should think carefully whether we want
    to draw the text inside a canvas or just place them directly in the DOM.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，画布中的文本绘制被视为位图图像数据。这意味着访问者无法选择文本；搜索引擎无法索引文本；我们无法搜索它们。因此，我们应该仔细考虑是否要在画布中绘制文本，还是直接将它们放在DOM中。
- en: Pop quiz Drawing text in canvas
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验在画布中绘制文本
- en: If we are going to draw a text close to the bottom rightcorner of the canvas
    which alignment and baseline setting is better?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们要在画布的右下角附近绘制文本，哪种对齐和基线设置更好？
- en: a. Left alignment, bottom baseline.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: a. 左对齐，底部基线。
- en: b. Center alignment, alphabet baseline.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: b. 居中对齐，字母基线。
- en: c. Right alignment, bottom baseline.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: c. 右对齐，底部基线。
- en: d. Center alignment, middle baseline.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: d. 居中对齐，中间基线。
- en: We are going to make a realistic book with a flipping effect with the latest
    open web standard. Which of the following settings is better?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用最新的开放网络标准制作一个具有翻页效果的逼真书籍。以下哪种设置更好？
- en: a. Draw the realistic book in canvas, including all the text and the flipping
    effect.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: a. 在画布中绘制逼真的书籍，包括所有文本和翻页效果。
- en: b. Put all text and content in DOM and draw the realistic page-flipping effect
    in canvas.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: b. 将所有文本和内容放在DOM中，并在画布中绘制逼真的翻页效果。
- en: Using embedded web font inside canvas
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布中使用嵌入的Web字体
- en: We used custom font in our memory matching game in the previous chapter. The
    custom font embedding also worked in the canvas. Let's conduct an experiment on
    drawing a custom font in our Untangle game in canvas.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的记忆匹配游戏中，我们使用了自定义字体。自定义字体嵌入也适用于画布。让我们在画布中的Untangle游戏中进行一个绘制自定义字体的实验。
- en: Time for action Embedding Google Web Font into the canvas element
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行嵌入Google Web字体到画布元素的时间
- en: 'Let''s draw the canvas texts with a handwriting style font:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用手写风格字体绘制画布文本：
- en: 'First, go to the Google Font Directory and choose a handwriting style font.
    I used the font **Rock Salt** and you can get it from the following URL:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到Google字体目录，选择手写风格字体。我使用了字体**Rock Salt**，你可以从以下URL获取：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Google font directory provides a CSS link code that we can add to our game
    in order to embed the font. Add the following CSS link to the head of `index.html:`
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google字体目录提供了一个CSS链接代码，我们可以将其添加到游戏中以嵌入字体。将以下CSS链接添加到`index.html`的头部：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next thing is to use the font. We open the `html5games.untangle.js` JavaScript
    file and modify the context `font` property to the following:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要做的是使用字体。我们打开`html5games.untangle.js` JavaScript文件，并将上下文`font`属性修改为以下内容：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is time to open our game in the web browser to test the result. The text
    drawn in the canvas now is using the font we choose in the Google font directory.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候在网络浏览器中打开我们的游戏来测试结果了。现在在画布中绘制的文本使用了我们在Google字体目录中选择的字体。
- en: '![Time for action Embedding Google Web Font into the canvas element](img/1260_05_08.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![执行嵌入Google Web字体到画布元素的时间](img/1260_05_08.jpg)'
- en: What just happened?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just chose a web font and embedded it into the canvas when drawing text.
    It shows that we can style the font family of the filled text in canvas just like
    other DOM elements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚选择了一个网络字体，并将其嵌入到画布中绘制文本时。这表明我们可以像其他DOM元素一样为画布中填充的文本设置字体系列。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Sometimes the width of the text varies in different font families although
    they have the same word count. In this case, we can use the `measureText` function
    to get the width of the text we draw. The following link to the Mozilla Developer
    Network explains how we can use the function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，不同字体系列的文本宽度会有所不同，尽管它们具有相同的字数。在这种情况下，我们可以使用`measureText`函数来获取我们绘制的文本的宽度。以下链接到Mozilla开发者网络解释了我们如何使用该函数：
- en: '[https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText()](http://https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText())'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText()](http://https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText())'
- en: Drawing images in canvas
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布中绘制图像
- en: We have drawn some text inside canvas. What about drawing an image? Yes. Drawing
    images and image manipulation is one big feature that canvas has.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在画布内绘制了一些文本。那么绘制图像呢？是的。在画布中绘制图像和图像处理是画布具有的一个重要功能。
- en: Time for action Adding graphics to the game
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行添加图形到游戏的时间
- en: 'We are going to draw a blackboard background to the game:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在游戏中绘制一个黑板背景：
- en: 'Download the graphic files from the code example bundle or the following URL.
    The graphics files include all graphics that we need in this chapter:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码示例包或以下URL下载图形文件。图形文件包括我们在本章中需要的所有图形：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Put the newly downloaded graphics files into a folder named `images`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新下载的图形文件放入名为`images`的文件夹中。
- en: 'We will load an image and loading means it may take a while until the image
    is loaded. Ideally, we should not start the game until all game assets are loaded.
    In this case, we can prepare a splash screen with loading words to let the player
    know the game is going to start later. Add the following code in the jQuery `ready`
    function after clearing the canvas context:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将加载一幅图像，加载意味着可能需要一段时间直到图像加载完成。理想情况下，我们不应该在所有游戏资源加载完成之前开始游戏。在这种情况下，我们可以准备一个带有加载文字的启动画面，让玩家知道游戏将在稍后开始。在jQuery的`ready`函数中清除画布上下文后，添加以下代码：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then it is time to really load the image. There is a `board.png` in the graphics
    file we just downloaded. It is a blackboard graphics we will draw to the canvas
    as background. Add the following code after the code we just added in the previous
    step:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是真正加载图像的时候了。我们刚刚下载了一个名为`board.png`的图形文件。这是一个我们将绘制到画布上的黑板图形背景。在我们刚刚添加的代码之后添加以下代码：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `gameloop` function, we draw the image into the canvas after clearing
    the context and before drawing anything else. Since the image loading takes time,
    we also need to ensure it is loaded before drawing it:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameloop`函数中，我们在清除上下文并在绘制任何其他内容之前将图像绘制到画布中。由于图像加载需要时间，我们还需要确保在绘制之前加载它：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We had set up a `levels` array to store the level data including the initial
    circles position. Some circles are now overlapped with the border of the background
    image so we may want to alter the circles position. Update the circles array of
    level 2 with the following new values:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一个`levels`数组来存储包括初始圆位置在内的级别数据。现在一些圆与背景图像的边框重叠，所以我们可能需要改变圆的位置。使用以下新值更新级别2的圆数组：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also we need to adjust the position of the level progress text. Modify the
    `fill text` function calling as the following code with a different position value:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要调整级别进度文本的位置。修改`fill text`函数调用为以下代码，使用不同的位置值：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we do not want a background color set to the canvas now because we have
    a PNG background with a transparent border. Open the `untangle.css` file and remove
    the background property in canvas.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们不希望为画布设置背景颜色，因为我们有一个带有透明边框的PNG背景。打开`untangle.css`文件并删除画布中的背景属性。
- en: Now save all files and open the `index.html` in the web browser. The background
    should be there and the handwritten fonts should match our blackboard theme.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存所有文件并在Web浏览器中打开`index.html`。背景应该在那里，手写字体应该与我们的黑板主题相匹配。
- en: '![Time for action Adding graphics to the game](img/1260_05_09.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![执行操作添加图形到游戏](img/1260_05_09.jpg)'
- en: What just happened?
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just drew an image inside the canvas element.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在画布元素内绘制了一幅图像。
- en: There are two common ways to draw an image on canvas. We can either reference
    an existing `img` tag or load the image on the fly in JavaScript.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制图像有两种常见的方法。我们可以引用现有的`img`标签，也可以在JavaScript中动态加载图像。
- en: Here is how we reference the existing image tag in canvas.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在画布中引用现有图像标签的方式。
- en: 'Assuming that we have the following `img` tag in HTML:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在HTML中有以下`img`标签：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can draw the image in canvas by using the following JavaScript code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下JavaScript代码在画布中绘制图像：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is another code snippet to load the image without attaching the `img`
    tag into DOM. If we load the image inside JavaScript, we need to make sure the
    image is loaded before drawing it on canvas. Therefore, we draw the image after
    the `onload` event of the image:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个加载图像的代码片段，而不将`img`标签附加到DOM中。如果我们在JavaScript中加载图像，我们需要确保图像在绘制到画布上之前已加载。因此，我们在图像的`onload`事件之后绘制图像：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The order meters when setting the onload event handler and assigning the
    image src**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置onload事件处理程序和分配图像src时的顺序很重要**'
- en: When we assign the `src` property to the image and if the image is cached by
    the browser, some browsers fire the `onload` event immediately. If we place the
    `onload` event handler after assigning the `src` property, we may miss it because
    it is fired before we set the event handler.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`src`属性分配给图像并且如果图像被浏览器缓存，一些浏览器会立即触发`onload`事件。如果我们在分配`src`属性后放置`onload`事件处理程序，我们可能会错过它，因为它是在我们设置事件处理程序之前触发的。
- en: In our example, we used the latter approach. We create an Image object and load
    the background. When the image is loaded, we start the game loop and thus start
    the game.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了后一种方法。我们创建了一个Image对象并加载了背景。当图像加载完成时，我们启动游戏循环，从而开始游戏。
- en: 'Another event that we should handle when loading the image is the `onerror`
    event. It is especially useful when we are accessing extra network data. We have
    the following code snippet to check the error in our example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像时我们还应该处理的另一个事件是`onerror`事件。当我们访问额外的网络数据时，这是特别有用的。我们有以下代码片段来检查我们示例中的错误：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Have a go hero
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试一试
- en: The error loading now only displays a message in the console. The console is
    normally not viewed by players. How about designing an alert dialog or some other
    approaches to tell players that the game failed to load the game assets?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载错误只在控制台中显示消息。玩家通常不会查看控制台。设计一个警报对话框或其他方法来告诉玩家游戏未能加载游戏资源，如何？
- en: Using the drawImage function
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用drawImage函数
- en: There are three behaviors to draw an image in the canvas. We can draw the image
    without any modification on a given coordinate, we can also draw the image with
    a scaling factor on a given coordinate, or we can even crop the image and draw
    only the clipping region.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种在画布中绘制图像的行为。我们可以在给定的坐标上绘制图像而不进行任何修改，我们还可以在给定的坐标上绘制具有缩放因子的图像，或者我们甚至可以裁剪图像并仅绘制裁剪区域。
- en: 'The `drawImage` function accepts several arguments:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawImage`函数接受几个参数：'
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| Argument | Definition | Discussion |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| image | The image reference that we are going to draw. | We either get the
    image reference by getting an existing `img` element or creating a JavaScript
    `Image` object. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 图像 | 我们要绘制的图像引用。 | 我们可以通过获取现有的`img`元素或创建JavaScript`Image`对象来获取图像引用。 |'
- en: '| x | The x position to place the image in canvas coordinate. | The x and y
    coordinate is where we place the image with respect to its top-left corner. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| x | 在画布坐标中放置图像的x位置。 | x和y坐标是我们放置图像的位置，相对于其左上角。 |'
- en: '| y | The y position to place the image in canvas coordinate. |   |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| y | 在画布坐标中放置图像的y位置。 |   |'
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| Argument | Definition | Discussion |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| image | The image reference that we are going to draw. | We either get the
    image reference by getting an existing `img` element or creating a JavaScript
    `Image` object. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 图像 | 我们要绘制的图像引用。 | 我们可以通过获取现有的`img`元素或创建JavaScript`Image`对象来获取图像引用。 |'
- en: '| x | The x position to place the image in canvas coordinate. | The x and y
    coordinate is where we place the image with respect to its top-left corner. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| x | 在画布坐标中放置图像的x位置。 | x和y坐标是我们放置图像的位置，相对于其左上角。 |'
- en: '| y | The y position to place the image in canvas coordinate. |   |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| y | 在画布坐标中放置图像的y位置。 |   |'
- en: '| width | The width of the final drawn image. | We are applying scale to the
    image if the width and height is not the same as the original image. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 宽度 | 最终绘制图像的宽度。 | 如果宽度和高度与原始图像不同，我们会对图像应用比例。 |'
- en: '| height | The height of the final drawn image. |   |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 高度 | 最终绘制图像的高度。 |   |'
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| Argument | Definition | Discussion |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| image | The image reference that we are going to draw. | We either get the
    image reference by getting an existing `img` element or creating a JavaScript
    `Image` object. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 图像 | 我们要绘制的图像引用。 | 我们可以通过获取现有的`img`元素或创建JavaScript`Image`对象来获取图像引用。 |'
- en: '| sx | The x coordinate of the top-left corner of the clipping region. | The
    clipping x, y, width, height together defines a rectangular clipping area. The
    given image is clipped by this rectangle. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| sx | 裁剪区域左上角的x坐标。 | 裁剪x、y、宽度、高度一起定义了一个矩形裁剪区域。给定的图像将被此矩形裁剪。 |'
- en: '| sy | The y coordinate of the top-left corner of the clipping region. |  
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| sy | 裁剪区域左上角的y坐标。 |   |'
- en: '| sWidth | The width of the clipping region. |   |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| sWidth | 裁剪区域的宽度。 |   |'
- en: '| sHeight | The height of the clipping region. |   |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| sHeight | 裁剪区域的高度。 |   |'
- en: '| Argument | Definition | Discussion |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| dx | The x position to place the image in canvas coordinate. | The x and
    y coordinate is where we place the image with respect to its top-left corner.
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| dx | 在画布坐标中放置图像的x位置。 | x和y坐标是我们放置图像的位置，相对于其左上角。 |'
- en: '| dy | The y position to place the image in canvas coordinate. |   |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| dy | 在画布坐标中放置图像的y位置。 |   |'
- en: '| width | The width of the final drawn image. | We are applying scale to the
    clipped image if the width and height is not the same as the clipping dimension.
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 宽度 | 最终绘制图像的宽度。 | 如果宽度和高度与裁剪尺寸不同，我们会对裁剪后的图像应用比例。 |'
- en: '| height | The height of the final drawn image. |   |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 高度 | 最终绘制图像的高度。 |   |'
- en: Have a go hero Optimizing the background image
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看英雄 优化背景图像
- en: In the example, we draw the blackboard image as background in every call of
    the `gameloop` function. Since our background is static and does not change along
    the time, clearing it and redrawing it again and again is wasting CPU resources.
    How can we optimize this performance issue?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们在每次调用`gameloop`函数时将黑板图像作为背景绘制。由于我们的背景是静态的，不会随时间变化，所以一遍又一遍地清除并重新绘制会浪费CPU资源。我们如何优化这个性能问题？
- en: Decorating the canvas-based game
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰基于画布的游戏
- en: We have enhanced the canvas game with gradients and images. Before moving forward,
    let's decorate the web page of our canvas game.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用渐变和图像增强了画布游戏。在继续之前，让我们装饰一下画布游戏的网页。
- en: Time for action Adding CSS styles and images decoration to the game
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间为游戏添加CSS样式和图像装饰
- en: 'We are going to build a center-aligned layout with a game title:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将建立一个居中对齐的布局，带有一个游戏标题：
- en: We embed another font from the Google font directory to style the normal body
    text. Add the following CSS link within the `head` in `index.html:`
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从Google字体目录嵌入了另一种字体来为正常的正文文本设置样式。在`index.html`的`head`中添加以下CSS链接：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is easier for us to style the layout with one grouping DOM element. We put
    all the elements inside the body into a section with `id` page:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个分组DOM元素来为布局设置样式更容易。我们将所有元素放入一个带有`id`页面的部分中：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s apply CSS to the page layout. Replace existing content in the `untangle.css`
    file with the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对页面布局应用CSS。用以下代码替换`untangle.css`文件中的现有内容：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have the header text in the ribbon. Showing the title again in canvas
    seems redundant. Let''s remove the following line of code which draws the title:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在带上有标题的带子中有了标题文本。在画布中再次显示标题似乎是多余的。让我们删除以下绘制标题的代码行：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is time to save all the files and preview it in the web browser. We should
    see a title ribbon and a well-styled layout that is center-aligned. The following
    screenshot shows the result:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候保存所有文件并在Web浏览器中预览了。我们应该看到一个居中对齐的标题带和精心设计的布局。以下截图显示了结果：
- en: '![Time for action Adding CSS styles and images decoration to the game](img/1260_05_10.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间为游戏添加CSS样式和图像装饰](img/1260_05_10.jpg)'
- en: What just happened?
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just decorated the web page that contains our canvas-based game. Although
    our game is based on canvas drawing, it does not restrict us from decorating the
    whole web page with graphics and CSS styles.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚装饰了包含基于画布的游戏的网页。虽然我们的游戏是基于画布绘制的，但这并不限制我们用图形和CSS样式装饰整个网页。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Default background of the canvas element
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 画布元素的默认背景
- en: The default background of the canvas element is transparent. If we do not set
    any background CSS style of the canvas, it will be transparent. It is useful when
    our drawing is not a rectangle. In this example, the textured layout background
    shows within the canvas region.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 画布元素的默认背景是透明的。如果我们不设置画布的任何背景CSS样式，它将是透明的。当我们的绘图不是矩形时，这是有用的。在这个例子中，纹理布局背景显示在画布区域内。
- en: Pop quiz Styling a canvas background
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验 设置画布背景
- en: How can we set the canvas background to be transparent?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将画布背景设置为透明？
- en: 'a. Set the background color to #ffffff.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: a. 将背景颜色设置为#ffffff。
- en: b. Do nothing. It is transparent by default.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: b. 什么也不做。默认情况下是透明的。
- en: Animating a sprite sheet in canvas
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在canvas中制作精灵表动画
- en: We first used **sprite sheet** images in Chapter 3, *Building a Memory Matching
    Game in CSS3*, when displaying a deck of playing cards.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第3章“在CSS3中构建记忆匹配游戏”中首次使用了**精灵表**图像，用于显示一副扑克牌。
- en: Time for action Making a game guide animation
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 制作游戏指南动画
- en: There is a graphics file named `guide_sprite.png` in the images folder. It is
    a game guideline graphic that contains each step of the animation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在images文件夹中有一个名为`guide_sprite.png`的图形文件。这是一个包含动画每一步的游戏指南图形。
- en: '![Time for action Making a game guide animation](img/1260_05_11.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 制作游戏指南动画](img/1260_05_11.jpg)'
- en: Let's draw this guide into our game with **animations:**
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用**动画**将这个指南画到我们的游戏中：
- en: Open the `html5games.untangle.js` JavaScript file in the text editor.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`html5games.untangle.js` JavaScript文件。
- en: 'In the jQuery `ready` function add the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery的`ready`函数中添加以下代码：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We add the following function to move the current frame to the next frame every
    500 meters:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加以下函数，以便每500米将当前帧移动到下一帧：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `gameloop` function, we draw the guide animation according to the current
    frame.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameloop`函数中，我们根据当前帧绘制指南动画。
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s watch the animation in the web browser by opening the `index.html`.
    The following screenshot demonstrates the animation of the game guideline. The
    guideline animation will play and loop until the player levels up:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开`index.html`在Web浏览器中观看动画。以下截图演示了游戏指南动画的动画。指南动画将播放并循环，直到玩家升级：
- en: '![Time for action Making a game guide animation](img/1260_05_12.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 制作游戏指南动画](img/1260_05_12.jpg)'
- en: What just happened?
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We can draw only a region of an image when using the `drawImage` context function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`drawImage`上下文函数时，我们可以只绘制图像的一部分区域。
- en: 'The following screenshot demonstrates the process of the animation step by
    step. The rectangle is the clipping region. We used a variable named `guideFrame`
    to control which frame to show. The width of each frame is 80\. Therefore, we
    get the x position of the clipping region by multiplying the width and the current
    frame number:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图逐步演示了动画的过程。矩形是裁剪区域。我们使用一个名为`guideFrame`的变量来控制显示哪一帧。每帧的宽度为80。因此，我们通过将宽度和当前帧数相乘来获得裁剪区域的x位置：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `guideFrame` variable is updated every 500 meters by the following `guideNextFrame`
    function:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`guideFrame`变量每500米通过以下`guideNextFrame`函数进行更新：'
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![What just happened?](img/1260_05_13.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_05_13.jpg)'
- en: 'Animating a sprite is a commonly used technique when developing games. There
    are some benefits of using sprite animation when developing games in traditional
    video games. The reasons may not apply to the web game development but we have
    other benefits of using sprite sheet animation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发游戏时，制作精灵动画是一种常用的技术。在传统视频游戏中使用精灵动画有一些好处。这些原因可能不适用于网页游戏开发，但我们在使用精灵表动画时有其他好处：
- en: All frames are loaded as one file so the whole animation is ready once the sprite
    file is loaded.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有帧都加载为一个文件，因此一旦精灵文件加载完毕，整个动画就准备就绪。
- en: Putting all frames into one file means we can reduce the HTTP request from the
    web browser to the server. If each frame is a file, the browser requests the file
    many times while now it just requests one file and uses one HTTP request.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有帧放入一个文件中意味着我们可以减少Web浏览器向服务器的HTTP请求。如果每一帧都是一个文件，那么浏览器会多次请求文件，而现在它只请求一个文件并使用一个HTTP请求。
- en: Putting different images into one file also helps reduce the duplicate file's
    header, footer, and meta data.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不同的图像放入一个文件中还有助于减少重复文件的页眉、页脚和元数据。
- en: Putting all frames into one image means we can easily clip the image to display
    any frame without the complex code to change the image source.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有帧放入一张图像中意味着我们可以轻松裁剪图像以显示任何帧，而无需复杂的代码来更改图像源。
- en: 'It is usually used in character animation. The following screenshot is a **sprite
    animation** of an angry cat that I used in an HTML5 game named Neighbours ([http://gamedesign.cc/html5games/neighbours/](http://gamedesign.cc/html5games/neighbours/)):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常用于角色动画。以下截图是我在名为邻居的HTML5游戏中使用的愤怒猫的**精灵动画**：
- en: '![What just happened?](img/1260_05_14.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_05_14.jpg)'
- en: We built the sprite sheet animation by clipping the frame and setting up the
    timer ourselves in this example. When working with a lot of animations, we may
    want to use some third party sprite animation plugin or create our own canvas
    sprite animation to better reuse and manage the logic code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过裁剪帧并自行设置定时器来构建精灵表动画。当处理大量动画时，我们可能希望使用一些第三方精灵动画插件或创建自己的画布精灵动画，以更好地重用和管理逻辑代码。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Sprite animation** is an important topic in HTML5 games development and there
    are many online resources discussing this topic. The following links are some
    of them:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵动画**是HTML5游戏开发中的重要主题，有许多在线资源讨论这个主题。以下链接是其中一些：'
- en: The sprite animation tutorial ([http://codeutopia.net/blog/2009/08/21/using-canvas-to-do-bitmap-sprite-animation-in-javascript/](http://codeutopia.net/blog/2009/08/21/using-canvas-to-do-bitmap-sprite-animation-in-javascript/))
    from CodeUtopia discusses how we can make a sprite object from scratch and use
    it to animate a sprite.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: CodeUtopia的精灵动画教程（[http://codeutopia.net/blog/2009/08/21/using-canvas-to-do-bitmap-sprite-animation-in-javascript/](http://codeutopia.net/blog/2009/08/21/using-canvas-to-do-bitmap-sprite-animation-in-javascript/)）讨论了如何从头开始制作精灵对象并使用它来动画显示精灵。
- en: The sprite animation demo ([http://www.johnegraham2.com/web-technology/html-5-canvas-tag-sprite-animation-demo/](http://www.johnegraham2.com/web-technology/html-5-canvas-tag-sprite-animation-demo/))
    by John Graham provides another sprite object to animate a sprite in canvas.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: John Graham的精灵动画演示（[http://www.johnegraham2.com/web-technology/html-5-canvas-tag-sprite-animation-demo/](http://www.johnegraham2.com/web-technology/html-5-canvas-tag-sprite-animation-demo/)）提供了另一个精灵对象，用于在画布中动画显示精灵。
- en: The Spritely ([http://www.spritely.net/](http://www.spritely.net/)), on the
    other hand, provides sprite animation over the DOM element with CSS. It is useful
    when we want to animate a sprite without using canvas.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Spritely（[http://www.spritely.net/](http://www.spritely.net/)）提供了在DOM元素上使用CSS进行精灵动画。当我们想要在不使用画布的情况下动画显示精灵时，这是很有用的。
- en: Creating a multi-layers canvas game
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多层画布游戏
- en: Now all things are drawn into the context and it has no other state to distinguish
    the drawn items. We may split the canvas game into different layers and code the
    logic to control and draw each layer at a time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的东西都绘制到上下文中，它没有其他状态来区分已绘制的项目。我们可以将画布游戏分成不同的图层，并编写逻辑来控制和绘制每个图层。
- en: Time for action Dividing the game into four layers
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间将游戏分成四个图层
- en: 'We are going to separate our Untangle game into four layers:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把Untangle游戏分成四个图层：
- en: 'In `index.htm`, we changed the canvas HTML to the following code. It contains
    several canvases within a section:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.htm`中，我们将画布HTML更改为以下代码。它包含一个部分内的几个画布：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We also need to apply some styles to the canvas so they overlap with each other
    to create the multiple layers effect. Also we have to prepare a `fadeout` class
    and `dim` class to make the target transparent. Add the following code into the
    `untangle.css` file:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要对画布应用一些样式，使它们重叠在一起，以创建多层效果。此外，我们还需要准备一个`fadeout`类和`dim`类，使目标变得透明。将以下代码添加到`untangle.css`文件中：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `html5games.untangle.js` JavaScript file, we modify the code to support
    the layers feature. First, we add an array to store the context reference of each
    canvas:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`html5games.untangle.js` JavaScript文件中，我们修改代码以支持图层功能。首先，我们添加一个数组来存储每个画布的上下文引用：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we get the context reference and store them in the array:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取上下文引用并将它们存储在数组中：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since now the game canvas are overlapped together, the mouse event listener
    we had in the `game` canvas does not fire anymore. We can listen to the event
    from the parent `layers` DIV which has the same position and dimension of the
    canvas:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现在游戏画布重叠在一起，我们在`game`画布中的鼠标事件监听器不再起作用。我们可以从父`layers` DIV中监听事件，该DIV具有与画布相同的位置和尺寸：
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are going to separate the drawing part into different functions for different
    layers. In the following `drawLayerBG` function, it is only in charge of drawing
    the background:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将绘图部分分成不同的函数，用于不同的图层。在以下的`drawLayerBG`函数中，它只负责绘制背景：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We draw the background layer when the background image is loaded. Add the following
    highlighted code into the `onload` event of the background:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当背景图像加载时，我们绘制背景层。将以下突出显示的代码添加到背景的`onload`事件中：
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We divide the game loop into three different functions for the specified layer:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将游戏循环分成三个不同的函数，用于指定的图层：
- en: '[PRE40]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We put the guideline animation into a dedicated canvas now so we can easily
    apply CSS style to fade out the guideline later:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将指导线动画放入一个专用画布中，这样我们就可以轻松地应用CSS样式来淡出指导线：
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following `drawLayerGame` keeps all the drawing code we used in the gameplay.
    Most of the code is from the original `gameloop` function:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下的`drawLayerGame`保留了我们在游戏中使用的所有绘图代码。大部分代码来自原始的`gameloop`函数：
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The level progress text is now placed in the UI layer and drawn by the `drawLayerUI`
    function. It uses a dedicated layer so we can easily dim the opacity when the
    text is overlapped with the game objects, such as circles:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 级别进度文本现在放置在UI层中，并由`drawLayerUI`函数绘制。它使用一个专用层，因此当文本与游戏对象（如圆圈）重叠时，我们可以轻松地降低不透明度：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Save all the files and check our big code changes in the web browser. The game
    should be displayed as if we haven''t changed anything. Try dragging the circle
    down close to the bottom edge of the blackboard. The level progress text should
    dim to a low opacity. When you finish the first level, the guideline animation
    will fade out gracefully. The following screenshot shows the level progress in
    half opacity:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，并在Web浏览器中检查我们的大量代码更改。游戏应该显示得好像我们什么都没改变一样。尝试将圆圈拖动到靠近黑板的底部边缘。级别进度文本应该变得不透明。完成第一级时，指导线动画将优雅地淡出。以下截图显示了半透明的级别进度：
- en: '![Time for action Dividing the game into four layers](img/1260_05_15.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间将游戏分成四个图层](img/1260_05_15.jpg)'
- en: What just happened?
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: There are four canvases in total now. Each canvas is in charge of one layer.
    The layers are divided into background, game guideline, game itself, and the user
    interface showing the level progress.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在总共有四个画布。每个画布负责一个图层。图层分为背景、游戏指导线、游戏本身和显示级别进度的用户界面。
- en: By default, the canvases, like other elements, are placed one after the other.
    In order to overlap all canvases to construct the layer effect, we applied the
    `absolute` position to them.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，画布和其他元素一样，是依次排列的。为了重叠所有画布以构建图层效果，我们对它们应用了`absolute`位置。
- en: 'The following screenshots show the four layers setting now in our game. By
    default, the later added DOM is on top of the one added before. Therefore, `bg`
    canvas is at the bottom and `ui` is on the top:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们游戏中现在设置的四个层。默认情况下，后添加的DOM位于之前添加的DOM之上。因此，`bg`画布位于底部，`ui`位于顶部：
- en: '![What just happened?](img/1260_05_16.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_05_16.jpg)'
- en: Mixing CSS technique with Canvas drawing
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将CSS技术与画布绘制混合
- en: We are creating a canvas-based game but we are not restricted to use only a
    canvas drawing API. The level progress information is now in another canvas with
    ID `ui`. In this example, we mixed the CSS technique we discussed in Chapter 3,
    *Building a Memory Matching Game in CSS3.*
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个基于画布的游戏，但我们并不局限于只使用画布绘图API。级别进度信息现在在另一个ID为`ui`的画布中。在这个示例中，我们混合了我们在第3章中讨论的CSS技术，*在CSS3中构建记忆匹配游戏*。
- en: When we drag the circles around the canvas, they may overlap the level information.
    When drawing the UI canvas layer, we check whether any circle's coordinate is
    too low and is overlapping the text. We then fade the UI canvas CSS opacity so
    it does not distract the player from the circles.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在画布上拖动圆圈时，它们可能会重叠在级别信息上。在绘制UI画布层时，我们会检查是否有任何圆圈的坐标过低并且重叠在文本上。然后我们会淡化UI画布的CSS不透明度，这样就不会分散玩家对圆圈的注意力。
- en: 'We also fade out the guideline animation after the player levels up. This is
    done by fading out the whole `guide` canvas with CSS transition easing to 0 opacity.
    Since the `guide` canvas is only in charge of that animation, hiding that canvas
    does not affect other elements:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家升级后，我们还会淡出指南动画。这是通过将整个`guide`画布淡出到CSS过渡缓和为0不透明度来实现的。由于`guide`画布只负责该动画，隐藏该画布不会影响其他元素：
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Clearing only the changed region to boost canvas performance**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**只清除改变的区域以提高画布性能**'
- en: We can use the `clear` function to only clear part of the canvas context. This
    will give the performance some boost because it avoids redrawing the entire canvas
    context every time. This is achieved by marking the 'dirty' region of the context
    which has changed state since last drawn.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`clear`函数来清除画布上下文的一部分。这将提高性能，因为它避免了每次重新绘制整个画布上下文。这是通过标记自上次绘制以来状态发生变化的上下文的“脏”区域来实现的。
- en: In the guide canvas layer in our example, we may consider clearing only the
    region of the sprite sheet image drawing instead of the whole canvas.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中的指南画布层，我们可以考虑只清除精灵表图像绘制的区域，而不是整个画布。
- en: We may not see significant differences in simple canvas examples but it helps
    boost the performance when we have a complex canvas game that includes many sprite
    images animations and complex shape drawings.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的画布示例中，我们可能看不到明显的差异，但是当我们有一个包含许多精灵图像动画和复杂形状绘制的复杂画布游戏时，它有助于提高性能。
- en: Have a go hero
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试吧
- en: We fade out the guide when the players advance to level 2\. How about we fade
    out the guide animation once the player drags any circles? How can we do that?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入第2级时，我们会淡出指南。当玩家拖动任何圆圈时，我们如何淡出指南动画？我们怎么做？
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We learned a lot in this chapter about drawing gradients, text, and images in
    canvas.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于在画布中绘制渐变、文本和图像的知识。
- en: 'Specifically, we covered:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: Filling shapes with either linear or radial gradient
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用线性或径向渐变填充形状
- en: Filling text in canvas with font-face embedding and other text styles
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用字体嵌入和其他文本样式在画布中填充文本
- en: Drawing images into canvas
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像绘制到画布中
- en: Animating a sprite sheet by the `clipping` function when drawing images
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`clipping`函数在绘制图像时对精灵表进行动画处理
- en: Dividing the game into several layers by stacking several canvas elements
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过堆叠多个画布元素将游戏分成几个层
- en: Mixing the CSS transition animation in a canvas-based game
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于画布的游戏中混合CSS过渡动画
- en: One thing we haven't mentioned in this book is the bitmap manipulation in canvas.
    Canvas context is a bitmap data where we can apply an operation on each pixel.
    For instance, we may draw an image in the canvas and apply Photoshop-like filters
    to the image. We will not cover that in the book because image manipulation is
    an advanced topic and the application may not relate to game development.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中我们没有提到的一件事是画布中的位图操作。画布上下文是一个位图数据，我们可以在每个像素上应用操作。例如，我们可以在画布上绘制图像并对图像应用类似于Photoshop的滤镜。我们不会在书中涵盖这个内容，因为图像处理是一个高级话题，而且应用可能与游戏开发无关。
- en: There are some good canvas games examples on the Internet. The Canvas Demo ([http://www.canvasdemos.com/type/games/](http://www.canvasdemos.com/type/games/))
    links the latest canvas games from other websites. The Game On 2010 gallery ([https://gaming.mozillalabs.com/games/](https://gaming.mozillalabs.com/games/))
    from Mozilla lists a bundle of game entries for their gaming development competition.
    Some of them are made in canvas.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上有一些很好的画布游戏示例。Canvas Demo ([http://www.canvasdemos.com/type/games/](http://www.canvasdemos.com/type/games/))链接了其他网站上最新的画布游戏。Mozilla的Game
    On 2010画廊([https://gaming.mozillalabs.com/games/](https://gaming.mozillalabs.com/games/))列出了他们游戏开发竞赛的一系列游戏条目。其中一些是用画布制作的。
- en: Now that we've learned about building games in canvas and making animation for
    game objects, such as game character, we are ready to add audio components and
    sound effects to our games in the next chapter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了在画布中构建游戏并为游戏对象制作动画，比如游戏角色，我们准备在下一章为我们的游戏添加音频组件和音效。
- en: We will get back to canvas-based games in [Chapter 9](ch09.html "Chapter 9. Building
    a Physics Car Game with Box2D and Canvas"),
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](ch09.html "第9章。使用Box2D和画布构建物理汽车游戏")中回到基于画布的游戏，
