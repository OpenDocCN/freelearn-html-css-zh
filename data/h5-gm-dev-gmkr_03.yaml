- en: 'Chapter 3. Shoot ''em Up: Creating a Side-scrolling Shooter'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。射击游戏：创建横向卷轴射击游戏
- en: In this chapter, we will create a very simple side-scrolling shooter that will
    introduce us to the basics of making a complete game utilizing GML code. We will
    have a player character that can move around the play area and fire weapons. If
    they collide into an enemy or enemy bullet, they will be destroyed and can respawn
    if they have any remaining lives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个非常简单的横向卷轴射击游戏，这将使我们了解使用GML代码制作完整游戏的基础知识。我们将有一个玩家角色，可以在游戏区域内移动并发射武器。如果他们与敌人或敌人的子弹相撞，他们将被摧毁，并且如果他们还有剩余生命，可以重新生成。
- en: 'We will create three different types of enemies that fly across the screen:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三种不同类型的飞越屏幕的敌人：
- en: '**FloatBot**: It has no weapons but is hard to hit, because it floats up and
    down as it moves.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FloatBot**：它没有武器，但很难击中，因为它在移动时上下浮动。'
- en: '**SpaceMine**: It is the slowest enemy and will fire a ring of bullets if the
    player gets too close.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SpaceMine**：它是最慢的敌人，如果玩家靠得太近，它会发射一圈子弹。'
- en: '**Strafer**: It is the fastest enemy that flies in a straight line and fires
    bullets directly at the player''s location.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Strafer**：它是飞行速度最快的敌人，直线飞行并直接朝玩家位置发射子弹。'
- en: 'We will polish the game by displaying the score and player lives, scroll the
    background to create the illusion of movement, play music, and add explosions.
    Finally, we will restart the game by implementing a win/lose condition. The game
    will look as shown in the following screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过显示得分和玩家生命，滚动背景以营造移动的错觉，播放音乐并添加爆炸效果来完善游戏。最后，我们将通过实现胜利/失败条件来重新开始游戏。游戏将如下截图所示：
- en: '![Shoot ''em Up: Creating a Side-scrolling Shooter](img/4100OT_03_22.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![射击游戏：创建横向卷轴射击游戏](img/4100OT_03_22.jpg)'
- en: Coding conventions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码约定
- en: In order to write effective code, regardless of programming language, it is
    important to follow the recommended coding conventions. This will help ensure
    that other people can read and understand what the code is attempting to do and
    debug it. There is no universal standard for programming practices, though many
    languages follow similar guidelines. The **GameMaker Language** (**GML**) does
    not have an official recommended set of conventions, partially due to the fact
    that it was developed to be a learning tool and is very forgiving as a result.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写有效的代码，无论编程语言如何，遵循推荐的编码约定是很重要的。这将有助于确保其他人可以阅读和理解代码尝试做什么并对其进行调试。虽然许多语言遵循类似的指南，但编程实践没有通用标准。**GameMaker语言**（**GML**）没有官方推荐的约定集，部分原因是它被开发为学习工具，因此非常宽容。
- en: For this book, we will define our own conventions based on common practices
    and ease of learning.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我们将根据常见做法和学习的便利性来定义自己的约定。
- en: 'All assets, except Rooms, will start with a simple type signifier and an underscore.
    For example:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了房间外，所有资产都将以简单的类型标识符和下划线开头。例如：
- en: '**Sprites**: `spr_`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精灵**：`spr_`'
- en: '**Objects**: `obj_`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：`obj_`'
- en: '**Scripts**: `scr_`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本**：`scr_`'
- en: Even though it is possible to use the Execute Code DnD to write code directly
    on an event, all code will be placed into Scripts and the naming convention will
    indicate the Object it is attached to and the Event it is applied to. This will
    make it easier to find later for debugging purposes. For example, code placed
    onto the player object's **Create** event would have a Script named `scr_Player_Create`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使可以使用执行代码DnD直接在事件上编写代码，所有代码都将放置在脚本中，并且命名约定将指示其附加到的对象和应用的事件。这将使以后更容易找到以进行调试。例如，放置在玩家对象的**创建**事件上的代码将具有名为`scr_Player_Create`的脚本。
- en: 'If a Script is intended to be used by multiple objects, the name should use
    a clear description of what it is doing. For example: for removing an object after
    it goes offscreen, the Script would be named `scr_OffScreenRemoval`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果脚本打算由多个对象使用，则名称应使用清晰描述其功能的名称。例如：要在物体离开屏幕后移除物体，脚本将被命名为`scr_OffScreenRemoval`。
- en: 'Variables will be written using CamelCase wherever multiple words are used;
    the first word starts with a lowercase letter, and each following word starts
    with an uppercase letter, for example: `variableWithManyWords`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量将使用驼峰命名法编写，其中使用多个单词；第一个单词以小写字母开头，每个后续单词以大写字母开头，例如：`variableWithManyWords`。
- en: 'Boolean variables should be posed as a question, for example: `canShoot`, `isPlaying`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔变量应该以问题的形式提出，例如：`canShoot`，`isPlaying`。
- en: 'Constants are written using all uppercase letters and underscores to separate
    words, for example: `LEFT`, `MAX_GRAVITY`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量使用全大写字母和下划线来分隔单词，例如：`LEFT`，`MAX_GRAVITY`。
- en: 'Expressions in `if` statements are always enclosed in parentheses. GameMaker
    does not require this, but it does make it easier to read the code; for example:
    `if (x > 320)`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句中的表达式始终用括号括起来。GameMaker不要求这样做，但这样做可以更容易阅读代码；例如：`if (x > 320)`。'
- en: Building the player
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造玩家
- en: We are going to start by building our player object. We have briefly described
    the design already, but we have not broken the design down into something that
    we can start creating. First, we should bullet point each feature and what it
    entails to ensure we have all the **Variables** and **Events** we will need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建我们的玩家对象开始。我们已经简要描述了设计，但我们还没有将设计分解为可以开始创建的内容。首先，我们应该列出每个功能及其包含的内容，以确保我们拥有所有我们需要的**变量**和**事件**。
- en: Arrow keys will move the player around the play area
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头键将使玩家在游戏区域内移动
- en: Must remain in play area
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须保持在游戏区域内
- en: Spacebar will fire weapon
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格键将发射武器
- en: A single bullet fired with each button press
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次按下按钮都会发射一颗子弹
- en: Colliding with bullets or enemies causes damage
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与子弹或敌人碰撞会造成伤害
- en: Should be different values based on type
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该根据类型有不同的值
- en: Setting up the player sprite
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置玩家精灵
- en: 'Let''s create the player sprite and prepare it for the game:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建玩家精灵并为游戏做好准备：
- en: Create a new project and call it `Chapter_03`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目并将其命名为`Chapter_03`。
- en: Create a new Sprite and name it `spr_Player`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵并命名为`spr_Player`。
- en: Click on **Load Sprite** and load `Chapter 3/Sprites/Player.gif`, with **Remove
    Background** checked. This `.art` file has a spaceship with transparency and several
    frames of animation.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**加载精灵**，加载`Chapter 3/Sprites/Player.gif`，勾选**移除背景**。这个`.art`文件有一个带有透明度和几帧动画的太空飞船。
- en: Next, we want to adjust the collision area of the spaceship. The default collision
    is a rectangle covering the entire area of the Sprite that has pixel data. This
    means that the ship will take damage even though it has not visually come into
    contact with anything. What we want is to have a really small collision area.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要调整太空飞船的碰撞区域。默认的碰撞是一个覆盖具有像素数据的精灵整个区域的矩形。这意味着即使外观上没有接触任何东西，飞船也会受到伤害。我们希望的是有一个非常小的碰撞区域。
- en: Click on **Modify Mask**. This will open the **Mask Properties** editor as shown
    in the following screenshot:![Setting up the player sprite](img/4100OT_03_01.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**修改遮罩**。这将打开**遮罩属性**编辑器，如下截图所示：![设置玩家精灵](img/4100OT_03_01.jpg)
- en: In the **Mask Properties** editor, we are able to control the size, shape, and
    placement of the collision mask, the area of a sprite where collision detection
    will occur. Some games require pixel perfect collision, where collision is determined
    on an individual pixel basis. This is the most precise collision possible, but
    it is also computationally expensive. The majority of games, however, can get
    away with a much simpler shape, such as a rectangle. This method is much more
    efficient, but limits the visual accuracy of the collision. The choice of which
    one to choose is dependent on the game's design and how much control is necessary
    to achieve the desired results.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在**遮罩属性**编辑器中，我们可以控制碰撞遮罩的大小、形状和位置，即精灵中进行碰撞检测的区域。一些游戏需要像素级的碰撞检测，即根据单个像素确定碰撞。这是最精确的碰撞检测，但也需要大量计算。然而，大多数游戏可以使用简单得多的形状，比如矩形。这种方法更有效，但限制了碰撞的视觉准确性。选择哪种方法取决于游戏的设计以及为实现期望的结果需要多少控制。
- en: We want full control of the collision area, so set the **Bounding Box** to **Manual**
    and leave **Shape** as **Rectangle**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望完全控制碰撞区域，所以将**边界框**设置为**手动**，并将**形状**保留为**矩形**。
- en: There are two ways to adjust the parameters of the **Bounding Box**. We can
    either enter exact positions for the corners of the box, or we can draw the box
    directly on the image of the Sprite. Left mouse drag a small box roughly in the
    center of the spaceship as shown in the previous screenshot.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整**边界框**参数有两种方法。我们可以输入框的角落的确切位置，或者直接在精灵图像上绘制框。用鼠标左键拖动一个小框，大致位于太空飞船的中心，如前一个截图所示。
- en: Click on **OK**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: We are now back in the **Sprite Properties** editor and we can see that **Collision
    Checking** now states that it has been **Modified**. The last thing we will do
    to this Sprite is to move the origin to the tip of the spaceship's gun. By doing
    this we won't have to worry about offsetting the bullets upon creation through
    code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到**精灵属性**编辑器，可以看到**碰撞检测**现在显示为**已修改**。我们要做的最后一件事是将原点移动到太空飞船枪的尖端。这样做，我们就不必担心通过代码在创建时偏移子弹。
- en: '![Setting up the player sprite](img/4100OT_03_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![设置玩家精灵](img/4100OT_03_02.jpg)'
- en: 'Set **Origin** to **X**: `28`, **Y**: `24`, and then click on **OK**.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**原点**设置为**X**:`28`，**Y**:`24`，然后点击**确定**。
- en: Controlling the player object
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制玩家对象
- en: Let's create the player object and get it moving around the world.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建玩家对象，并让它在世界中移动。
- en: Create a new Object and name it `obj_Player`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Player`。
- en: Assign `spr_Player` as its Sprite.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`spr_Player`指定为其精灵。
- en: We need to initialize a variable for the speed we want the player to move at.
    This will make it easier to change the value later and have all scripts in `obj_Player`
    refer to it. Create a new Script and name it `scr_Player_Create`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要初始化一个变量，用于控制玩家移动的速度。这样以后更改数值会更容易，并且`obj_Player`中的所有脚本都可以引用它。创建一个新的脚本，命名为`scr_Player_Create`。
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In `obj_Player`, add a **Create** event.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，添加一个**创建**事件。
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply the `scr_Player_Create` to the script option. Click on **OK**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**控制**中拖动一个执行脚本图标到**操作：**区域，并将`scr_Player_Create`应用到脚本选项。点击**确定**。
- en: Create a new Script and name it `scr_Player_Key_Left`. This script will have
    the code for the left arrow key.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`scr_Player_Key_Left`。这个脚本将包含左箭头键的代码。
- en: 'While we want the player to be able to move left, we also want to prevent the
    player from going offscreen. Write the following code into the script:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们希望玩家能向左移动，但我们也希望防止玩家离开屏幕。将以下代码写入脚本：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start with a conditional `if` statement that queries whether the player's
    current `x` position is greater than or equal to the width of the sprite. In this
    case, it would mean that the origin of the player is greater than the image's
    width of 48 pixels. If it is greater, we place the object eight pixels to the
    left of the current position.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用条件`if`语句查询玩家当前的`x`位置是否大于或等于精灵的宽度。在这种情况下，这意味着玩家的原点大于48像素的图像宽度。如果大于，我们将对象放在当前位置的左侧八个像素处。
- en: The method of movement we are using here is not movement in the traditional
    sense. There is no velocity being applied to the object, but rather we are teleporting
    the object from one position to the next. The benefit of using this method is
    that if the key isn't being pressed, the Object won't move. This is necessary
    in this game, because we cannot use a **No Key** event due to having to shoot
    weapons.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的移动方法不是传统意义上的移动。对象没有施加速度，而是我们将对象从一个位置瞬间传送到另一个位置。使用这种方法的好处是，如果没有按键，对象就不会移动。这在这个游戏中是必要的，因为我们不能使用**无按键**事件来射击武器。
- en: In `obj_Player`, add a **Left** event under **Keyboard**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，在**键盘**下添加一个**左**事件。
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply the scr`_Player_Key_Left` to the **Script** option. Click on **OK**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**控制**中拖动一个执行脚本图标到**操作：**区域，并将scr`_Player_Key_Left`应用到**脚本**选项中。点击**确定**。
- en: Before we move on to all the other keys and their scripts, it is always good
    to check to see if the Object works as intended.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理所有其他键及其脚本之前，最好检查对象是否按预期工作。
- en: Create a new Room.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的房间。
- en: In the **settings** tab, change the name to `TheGame` and **Width** to `800`.
    Making the Room wider will give the player more area to maneuver around and recognize
    enemies easier.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**选项卡中，将名称更改为`TheGame`，**宽度**更改为`800`。使房间变宽将为玩家提供更多的操纵空间，并更容易识别敌人。
- en: In the **objects** tab, select `obj_Player` and place a single instance near
    the center of the room as seen in the following screenshot:![Controlling the player
    object](img/4100OT_03_03.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象**选项卡中，选择`obj_Player`并在房间中心附近放置一个单个实例，如下截屏所示：![控制玩家对象](img/4100OT_03_03.jpg)
- en: Run the game.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。
- en: If everything is set up properly, the player should move to the left only when
    the left arrow is pressed down and should remain in the play area. We can now
    move onto the other controls.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，玩家应该只在按下左箭头时向左移动，并且应该保持在游戏区域内。现在我们可以继续处理其他控制。
- en: Create a new Script and name it `scr_Player_Key_Right`. This will be for the
    right arrow key.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`scr_Player_Key_Right`。这将用于右箭头键。
- en: 'The script will be similar to the left, except we need to also take into consideration
    the width of the room. Write the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本将类似于左侧，只是我们还需要考虑房间的宽度。编写以下代码：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we are testing whether the player's current `x` position is less than the
    width of the room minus the width of the sprite. If it is less than that, we add
    `mySpeed` to the current location. This will ensure the player stays on-screen
    when moving to the right.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在测试玩家当前的`x`位置是否小于房间宽度减去精灵的宽度。如果小于这个值，我们将`mySpeed`添加到当前位置。这将确保玩家在向右移动时保持在屏幕上。
- en: In `obj_Player`, add a **Right** event under **Keyboard**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，在**键盘**下添加一个**右**事件。
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply `scr_Player_Key_Right`. Click on **OK**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**控制**中拖动一个执行脚本图标到**操作：**区域，并应用`scr_Player_Key_Right`。点击**确定**。
- en: We now have our horizontal controls and need to add the vertical movement. We
    will go over the code for the up key and down key scripts, but by now you should
    be able to implement them into the object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了水平控制，并且需要添加垂直移动。我们将介绍上键和下键脚本的代码，但现在您应该能够将它们实现到对象中。
- en: 'For the up arrow key, create a new Script and name it `scr_Player_Key_Up`,
    and write the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于上箭头键，创建一个新的脚本，并将其命名为`scr_Player_Key_Up`，并编写以下代码：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is similar to the horizontal code except now we are looking at the `y` position
    and the height of the Sprite.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这与水平代码类似，只是现在我们要考虑`y`位置和精灵的高度。
- en: 'For the down arrow key, create a new Script and name it `scr_Player_Key_Down`,
    and write the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下箭头键，创建一个新的脚本，并将其命名为`scr_Player_Key_Down`，并编写以下代码：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, here we are looking at the height of the room minus the height of the
    sprite as being the furthest point we can move downwards. The movement controls
    are now complete and the Object properties should look like the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在这里，我们要考虑的是房间的高度减去精灵的高度作为我们可以向下移动的最远点。移动控制现在已经完成，对象属性应该如下截屏所示：
- en: '![Controlling the player object](img/4100OT_03_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![控制玩家对象](img/4100OT_03_04.jpg)'
- en: Run the game.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。
- en: The player should be able to move around the entire screen, but never off of
    it. The only remaining control we have left is the button for firing the gun.
    However, before we can implement that we need a bullet!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家应该能够在整个屏幕上移动，但永远不会离开屏幕。我们剩下的唯一控制是开枪的按钮。然而，在实现这一点之前，我们需要一颗子弹！
- en: Building the bullet
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子弹
- en: Bullets are easy to make, as they generally just move along in a straight line
    once they have been fired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 制作子弹很容易，因为它们通常一旦被发射就沿着直线移动。
- en: Create a new Sprite and name it `spr_Bullet_Player`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，并将其命名为`spr_Bullet_Player`。
- en: Click on **Load Sprite** and load `Chapter 3/Sprites /Bullet_Player.gif`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**加载精灵**，加载`Chapter 3/Sprites /Bullet_Player.gif`。
- en: 'As we currently have the origin of the player object set to the tip of the
    gun, we will want **Origin** of the bullet to be at the front. This will help
    make the bullet appear to come out of the gun without having to code it directly.
    Set the values to **X**: `17`, **Y**: `4`.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们当前将玩家对象的原点设置为枪口，我们希望子弹的**原点**在前面。这将有助于使子弹看起来是从枪口射出，而无需直接编码。将值设置为**X**：`17`，**Y**：`4`。
- en: We can leave everything else as it is, so click on **OK**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他所有内容保持不变，然后点击**确定**。
- en: Bullets should also make a sound when they are fired so let's bring in a sound.
    The first thing we need to do is to switch back to the Legacy Sound engine, so
    that we ensure the audio is heard in all browsers. Navigate to **Resources** |
    **Change Global Game Settings** and under the **General** tab, uncheck the box
    for **Use New Audio Engine**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子弹发射时也应该发出声音，所以让我们加入一个声音。我们需要切换回传统声音引擎，以确保在所有浏览器中都能听到音频。导航到**资源** | **更改全局游戏设置**，在**常规**选项卡下，取消**使用新音频引擎**的复选框。
- en: Create a new Sound and name it `snd_Bullet_Player`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的声音，并将其命名为`snd_Bullet_Player`。
- en: Click on **Load Sound** and load `Chapter 3/Sounds/Bullet_Player.wav`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**加载声音**，加载`Chapter 3/Sounds/Bullet_Player.wav`。
- en: Make sure **Kind** is set to **Normal Sound**. Then click on **OK**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**类型**设置为**普通声音**。然后点击**确定**。
- en: Now it is time to make the bullet move on its own. Create a new Script and name
    it `scr_Bullet_Player_Create`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候让子弹自行移动了。创建一个新的脚本，并将其命名为`scr_Bullet_Player_Create`。
- en: 'We want the bullet to move horizontally to the right. This is easy to do with
    the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望子弹向右水平移动。使用以下代码很容易实现：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Hspeed** is a property representing the horizontal velocity of an object
    in GameMaker: Studio. We need to apply this code the moment the bullet is instantiated
    in the world. We also play the sound of the bullet a single time.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hspeed**是GameMaker: Studio中表示对象水平速度的属性。我们需要在子弹实例化到世界中的那一刻应用这段代码。我们还会播放子弹的声音一次。'
- en: Create a new Object and name it `obj_Bullet_Player`, and set the Sprite to `spr_Bullet_Player`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Bullet_Player`，并将精灵设置为`spr_Bullet_Player`。
- en: Add a **Create** event. The **Create** event is only ever executed once, upon
    creation.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Create**事件。**Create**事件只在创建时执行一次。
- en: Apply the `scr_Bullet_Player_Create` and click on **OK**.![Building the bullet](img/4100OT_03_05.jpg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用`scr_Bullet_Player_Create`并点击**OK**。![构建子弹](img/4100OT_03_05.jpg)
- en: As shown in the preceding screenshot, the bullet is now complete and ready to
    be fired. Let's go back to the spaceship!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，子弹现在已经完成，准备好发射。让我们回到太空船！
- en: Firing the bullet
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发射子弹
- en: A bullet is only dangerous to enemies if it has been fired. The player ship
    will handle this code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹只有在被发射后才对敌人构成威胁。玩家飞船将处理这段代码。
- en: Create a new Script and name it `scr_Player_KeyPress_Space`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`scr_Player_KeyPress_Space`。
- en: 'Write the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下代码：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this code, we are simply creating an instance of a bullet where the current
    position of the player ship is, or more specifically, where the origin of the
    player ship Sprite is. This will make the bullet appear to be shot from the ship's
    gun.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们只是在玩家飞船当前位置，或者更具体地说，玩家飞船精灵的原点处创建一个子弹实例。这将使子弹看起来是从飞船的枪中射出的。
- en: In `obj_Player`, add a **Space** event from **Key Press** and apply `scr_Player_KeyPress_Space`.
    The **Key Press** event checks if the indicated key has been pushed down. This
    will run once and requires the key to be released before being able to run again.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，添加一个**Space**事件从**Key Press**并应用`scr_Player_KeyPress_Space`。**Key
    Press**事件检查指定的键是否被按下。这将运行一次，并需要释放键才能再次运行。
- en: Run the game.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。
- en: If everything is working properly, we should be able to move around the screen
    and fire bullets as fast as we can hit the spacebar, as shown in the following
    screenshot. We are almost ready to start adding in gameplay, but before we do,
    we have a little bit of cleanup to do.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们应该能够在屏幕上四处移动并尽可能快地射击子弹，如下图所示。我们几乎可以开始添加游戏玩法了，但在这之前，我们还有一点清理工作要做。
- en: '![Firing the bullet](img/4100OT_03_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![发射子弹](img/4100OT_03_06.jpg)'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If everything appears to be correct, but you are still unable to see the intended
    result, try refreshing your browser. Occasionally, browsers will keep the game
    in memory and won't load the updated version immediately.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切看起来正确，但仍然无法看到预期的结果，请尝试刷新您的浏览器。偶尔，浏览器会将游戏保存在内存中，并不会立即加载更新的版本。
- en: Removing bullets from the world
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从世界中移除子弹
- en: Every time we create an instance of an object, it needs to be placed into the
    memory and the computer will need to keep a track of it. We have all these bullets
    that are going offscreen never to be seen again, but the computer sees them. This
    means that over time the computer could be trying to watch millions of wasted
    bullets, which in turn means that the game will start to slow down. As we don't
    want that to happen, we need to get rid of all these offscreen bullets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个对象实例，都需要将其放入内存，并且计算机需要跟踪它。我们有所有这些子弹离开屏幕再也看不到了，但计算机看到了。这意味着随着时间的推移，计算机可能会试图观察数百万个浪费的子弹，这反过来意味着游戏会开始变慢。由于我们不希望发生这种情况，我们需要摆脱所有这些离开屏幕的子弹。
- en: Create a new Script and name it `scr_OffScreenRemoval`. This Script can be applied
    to any object in the game that goes offscreen and that we want to get rid of.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`scr_OffScreenRemoval`。这个脚本可以应用于游戏中任何离开屏幕并且我们想要摆脱的对象。
- en: 'To remove an instance from the world, write the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从世界中移除一个实例，写下以下代码：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In `obj_Bullet_Player`, add an **Outside Room** event from **Other** and apply
    the script. The **Outside Room** event is a special event that checks if the entire
    sprite of an instanced object is completely outside the room.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Bullet_Player`中，添加一个**Outside Room**事件从**Other**并应用脚本。**Outside Room**事件是一个特殊事件，检查实例化对象的整个精灵是否完全在房间外。
- en: There we go! We now have a spaceship that moves around the screen, shoots bullets,
    and we keep the memory usage low. Let's make some enemies!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！现在我们有一个在屏幕上移动、射击子弹并且内存使用率低的太空船。让我们制作一些敌人！
- en: Constructing three little enemies
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建三个小敌人
- en: 'In this game we are going to have three unique types of enemies for the player
    to fight against: the FloatBot, the SpaceMine, and the Strafer. Each of these
    enemies will move differently and have a distinct attack. However, there are some
    common elements that they share, such as they will all have collision with bullets
    and the player, but not with each other.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们将有三种独特类型的敌人供玩家对抗：FloatBot，SpaceMine和Strafer。这些敌人每个都会以不同的方式移动并具有独特的攻击。然而，它们也有一些共同的元素，比如它们都会与子弹和玩家发生碰撞，但彼此之间不会发生碰撞。
- en: It is always useful to think about the commonalities of the various objects
    as there may be ways to simplify and reduce the amount of work needed. In this
    case, as we are dealing with collision, we can use a **parent** object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑各种对象的共同点总是有用的，因为可能有简化和减少所需工作量的方法。在这种情况下，由于我们正在处理碰撞，我们可以使用一个**父**对象。
- en: Making the enemy parent
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作敌人父对象
- en: 'Parenting object is an incredibly useful ability in GameMaker: Studio. It allows
    for one object, the **parent**, to pass its attributes down to other objects called
    **child** objects in what is generally known as **inheritance** . The best way
    to think of this relationship is that parents are a group and children are individuals.
    This means we can tell a group to do something and every individual will do it.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '父对象是GameMaker: Studio中非常有用的功能。它允许一个对象，**父对象**，将其属性传递给其他对象，称为**子对象**，通常被称为**继承**。最好的理解这种关系的方式是，父对象是一个群体，子对象是个体。这意味着我们可以告诉一个群体做某事，每个个体都会去做。'
- en: We will create a parent object and use it for all the common collision events.
    This way we don't have to apply a new collision event for each different enemy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个父对象，并将其用于所有常见的碰撞事件。这样我们就不必为每个不同的敌人应用新的碰撞事件。
- en: Create a new Object and name it `obj_Enemy_Parent`. We do not need a Sprite
    for this Object, as it will never be seen in the game.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Enemy_Parent`。我们不需要为这个对象添加精灵，因为它在游戏中永远不会被看到。
- en: Create a new Script and name it `scr_Enemy_Collision_Player`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，命名为`scr_Enemy_Collision_Player`。
- en: 'Write the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we are using a `with` statement which allows us to apply code to another
    object. In this case, we are also able to use a special variable called `other`
    which is only available in collision events. This is because there are always
    two instances involved and only one collision between the two. Whoever has the
    code is identified as `self` and then there is the other. When there is a collision
    between `obj_Enemy_Parent` or any child of it with `obj_Player`, we will remove
    the player, and then remove the instance it collided with.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个`with`语句，它允许我们对另一个对象应用代码。在这种情况下，我们还可以使用一个特殊的变量叫做`other`，它只在碰撞事件中可用。这是因为总是涉及两个实例，两者之间只有一个碰撞。谁拥有代码被标识为`self`，然后是另一个。当`obj_Enemy_Parent`或其任何子对象与`obj_Player`发生碰撞时，我们将移除玩家，然后移除它碰撞的实例。
- en: In `obj_Enemy_Parent`, add an `obj_Player` event from **Collision** and apply
    this collision script.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Enemy_Parent`中，从**碰撞**中添加一个`obj_Player`事件，并应用此碰撞脚本。
- en: Player collision now works, but currently nothing happens when bullets collide.
    We could use the same script if all the instances were going to be removed. In
    this case, we want to do something different if an enemy is hit by the player
    bullet. We want to award points.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家碰撞现在可以工作了，但是当子弹碰撞时目前什么也不会发生。如果所有实例都将被移除，我们可以使用相同的脚本。在这种情况下，如果敌人被玩家子弹击中，我们希望做一些不同的事情。我们想要奖励分数。
- en: Rather than creating a new script, let's just duplicate the collision Script
    we just created. In the Resource tree, hold right-click on `scr_Enemy_Collision_Player`
    and select **Duplicate**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其创建一个新脚本，不如直接复制我们刚刚创建的碰撞脚本。在资源树中，右键单击`scr_Enemy_Collision_Player`，然后选择**复制**。
- en: 'Name this script `scr_Enemy_Collision_Bullet`, and add the following line of
    code at the top of the script:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此脚本命名为`scr_Enemy_Collision_Bullet`，并在脚本顶部添加以下代码行：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will add 20 points to the total score of the game. Just to make sure everything
    is set up correctly, the entire code for this script should look like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为游戏的总分数增加20分。为了确保一切设置正确，此脚本的整个代码应该如下所示：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Back in `obj_Enemy_Parent`, add an `obj_Bullet` event from **Collision** and
    apply `scr_Enemy_Collision_Bullet`. Enemies will now be destroyed and points will
    be awarded when they collide with bullets!
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Enemy_Parent`中，从**碰撞**中添加一个`obj_Bullet`事件，并应用`scr_Enemy_Collision_Bullet`。当敌人与子弹碰撞时，敌人现在将被摧毁并奖励分数！
- en: The final event we need the parent object to watch over is to remove enemies
    if they go offscreen. We can't use the same script as our bullet cleanup script,
    because we will be spawning enemies offscreen to the right. Therefore, we need
    to make sure they are only removed when they go off the left-hand side.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要父对象监视的最后一个事件是，如果敌人离开屏幕，将其移除。我们不能使用与我们的子弹清理脚本相同的脚本，因为我们将在屏幕右侧生成敌人。因此，我们需要确保它们只在离开左侧时被移除。
- en: Create a new Script and name it `scr_Enemy_Removal`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，命名为`scr_Enemy_Removal`。
- en: 'Write the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we check to see if the `x` position of the instance is less than `0`,
    or offscreen to the left. If it is, we remove it from the game.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查实例的`x`位置是否小于`0`，或者在屏幕左侧。如果是，我们将其从游戏中移除。
- en: In `obj_Enemy_Parent`, add an **Outside Room** event from **Other** and apply
    this script. We are done with the parent object and it should look like the following
    screenshot:![Making the enemy parent](img/4100OT_03_07.jpg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Enemy_Parent`中，从**其他**中添加一个**外部房间**事件，并应用此脚本。我们已经完成了父对象，它应该看起来像下面的截图：![制作敌人父对象](img/4100OT_03_07.jpg)
- en: We now have a parent object that will deal with the bullet collision and remove
    the enemies when they go offscreen. Let's test it out by making some children.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个父对象，它将处理子弹碰撞并在敌人离开屏幕时移除它们。让我们通过创建一些子对象来测试它。
- en: Building the FloatBot
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建FloatBot
- en: The FloatBot is the most basic enemy in the game. It will not fire a weapon,
    which makes it more of an obstacle to be avoided. The FloatBot will move across
    the screen to the left, bobbing up and down as it goes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: FloatBot是游戏中最基本的敌人。它不会发射武器，这使它更像是要避开的障碍物。FloatBot将横穿屏幕向左移动，同时上下浮动。
- en: Create a new Sprite and name it `spr_FloatBot`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新精灵，命名为`spr_FloatBot`。
- en: Load the Sprite `Chapter 3/Sprites/FloatBot.gif` with **Remove Background**
    checked.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载精灵`Chapter 3/Sprites/FloatBot.gif`，勾选**删除背景**。
- en: This is an animated Sprite whose shape changes on each frame. Therefore, we
    want to make sure the collision changes accordingly. In **Collision Checking**,
    check the box for **Precise Collision Checking**.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个动画精灵，每一帧形状都会改变。因此，我们希望确保碰撞相应地改变。在**碰撞检查**中，勾选**精确碰撞检查**。
- en: 'We want the origin to be in the center of this Sprite, so that it moves correctly
    when we add the bobbing motion. Set **Origin** to **X**: `16`, **Y**: `16`. Click
    on **OK**.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将原点设置在此精灵的中心，这样当我们添加摆动运动时，它就会正确移动。将**原点**设置为**X**:`16`，**Y**:`16`。然后单击**确定**。
- en: We need two scripts to make the FloatBot fly the way we intend. On creation
    we will apply the horizontal movement, and then at every step after that we will
    adjust the vertical bobbing motion.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个脚本来使FloatBot以我们想要的方式飞行。在创建时，我们将应用水平移动，然后在每一步之后我们将调整垂直摆动运动。
- en: Create a new Script and name it `scr_FloatBot_Create`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`scr_FloatBot_Create`。
- en: 'Write the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The negative value of the horizontal speed means that it will move to the left.
    `angle` is a variable we will be using in the next script for the bobbing motion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 水平速度的负值意味着它将向左移动。`angle`是我们将在下一个脚本中使用的变量，用于摆动运动。
- en: Create a new Script and name it `scr_FloatBot_Step`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，并将其命名为`scr_FloatBot_Step`。
- en: 'To get the vertical motion we desire, we are going to use some simple trigonometry.
    Write the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获得我们想要的垂直运动，我们将使用一些简单的三角学。编写以下代码：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we are changing the vertical speed based on the sine value of the variable
    angle in radians, multiplied by a base speed of `8`. We also increase the value
    of `angle` every step, which is necessary to have it follow the sine wave.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据变量角的正弦值（以弧度为单位）乘以基本速度`8`来改变垂直速度。我们还每一步增加`angle`的值，这是必要的，以便它遵循正弦波。
- en: Create a new Object, name it `obj_FloatBot`, and set `spr_FloatBot` as the Sprite.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_FloatBot`，并将`spr_FloatBot`设置为精灵。
- en: We want to make this object a child, so in the **Parent** drop-down box, select
    `obj_Enemy Parent`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将此对象设置为子对象，因此在**父对象**下拉框中，选择`obj_Enemy Parent`。
- en: Add a **Create** event and apply the `scr_FloatBot_Create` script.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**创建**事件并应用`scr_FloatBot_Create`脚本。
- en: Add a **Step** event and apply the `scr_FloatBot_Step` script. The FloatBot
    is now ready for testing and should look like the following screenshot:![Building
    the FloatBot](img/4100OT_03_08.jpg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**步骤**事件并应用`scr_FloatBot_Step`脚本。FloatBot现在已经准备好测试，应该看起来像下面的截图：![构建FloatBot](img/4100OT_03_08.jpg)
- en: Reopen the room `TheGame` and place an instance of `obj_FloatBot` somewhere
    on the right-hand side of the screen.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开房间`TheGame`，并在屏幕右侧的某个地方放置一个`obj_FloatBot`的实例。
- en: Run the game.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。
- en: If everything is working correctly the FloatBot should move across the screen
    to the left and have a bob up and down around 240 pixels in height in a similar
    pattern as shown in the next screenshot. If we hit the FloatBot with a bullet,
    both the bullet and the FloatBot will disappear. We have also successfully created
    a parent-child relationship. Let's create another!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，FloatBot应该沿着屏幕向左移动，并在大约240像素的高度上上下摆动，模式与下一个截图中显示的类似。如果我们用子弹击中FloatBot，子弹和FloatBot都将消失。我们还成功创建了父子关系。让我们再创建一个！
- en: '![Building the FloatBot](img/4100OT_03_09.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![构建FloatBot](img/4100OT_03_09.jpg)'
- en: Creating the SpaceMine
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SpaceMine
- en: The SpaceMine is going to be a slow moving object that will shoot a ring of
    bullets if the player gets too close. As this is going to require two objects,
    we should always start with the simplest one, the bullet.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: SpaceMine将是一个缓慢移动的对象，如果玩家靠近，它将发射一圈子弹。由于这将需要两个对象，我们应该始终从最简单的对象开始，即子弹。
- en: Create a new Sprite and name it `spr_Bullet_SpaceMine`. Load `Chapter 3/Sprites/Bullet_SpaceMine.gif`
    with **Remove Background** checked.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新精灵，命名为`spr_Bullet_SpaceMine`。加载`Chapter 3/Sprites/Bullet_SpaceMine.gif`，勾选**删除背景**。
- en: Center the origin. We don't need to change **Collision Checking**, as a square
    will work fine for this object.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点居中。我们不需要改变**碰撞检查**，因为正方形对于这个对象来说效果很好。
- en: Create a new Object, name it `obj_Bullet_SpaceMine`, and set the Sprite to `spr_Bullet_SpaceMine`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Bullet_SpaceMine`，并将精灵设置为`spr_Bullet_SpaceMine`。
- en: Create a new Script and name it `scr_Bullet_SpaceMine_Create`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，并将其命名为`scr_Bullet_SpaceMine_Create`。
- en: 'This time we want to use the instance properties of `speed` and `direction`,
    as we will require the direction to be set later. Write the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们希望使用`speed`和`direction`的实例属性，因为我们稍后需要设置方向。编写以下代码：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In `obj_Bullet_SpaceMine`, add a **Create** event and apply this script.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Bullet_SpaceMine`中，添加一个**创建**事件并应用此脚本。
- en: We need to add collision to the bullet and to do this quickly, we can reuse
    the `scr_Enemy_Collision_Player` script. Add an `obj_Player` event from **Collision**
    and apply the script. We are done with the bullet for now, as can be seen in the
    following screenshot:![Creating the SpaceMine](img/4100OT_03_10.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为子弹添加碰撞，为了快速完成这个过程，我们可以重用`scr_Enemy_Collision_Player`脚本。从**碰撞**中添加一个`obj_Player`事件并应用脚本。目前我们已经完成了子弹，如下截图所示：![创建SpaceMine](img/4100OT_03_10.jpg)
- en: Time to build the SpaceMine itself. Create a new Sprite, name it `spr_SpaceMine`,
    and load `Chapter 3/Sprites/SpaceMine.gif` with **Remove Background** checked.
    As you can see, the SpaceMine has animated blinking lights.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候建立SpaceMine本身了。创建一个新精灵，命名为`spr_SpaceMine`，并加载`Chapter 3/Sprites/SpaceMine.gif`，勾选**删除背景**。正如你所看到的，SpaceMine有动画闪烁的灯光。
- en: Center the origin and check **Precise Collision Checking**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点居中并检查**精确碰撞检查**。
- en: We want a shooting sound when the SpaceMine fires, so create a new Sound, `snd_Bullet_SpaceMine`
    and load `Chapter 3/Sounds/Bullet_SpaceMine.wav`. We won't be attaching this to
    the bullets themselves as we will be creating eight bullets, but we only need
    the sound to be played once.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当SpaceMine发射时，我们希望有射击声音，因此创建一个新声音，`snd_Bullet_SpaceMine`，并加载`Chapter 3/Sounds/Bullet_SpaceMine.wav`。我们不会将其附加到子弹本身，因为我们将创建八颗子弹，但我们只需要播放一次声音。
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**. Create
    a new Object and name it `obj_SpaceMine`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未设置，将**类型**设置为**普通声音**，然后单击**确定**。创建一个新对象，命名为`obj_SpaceMine`。
- en: Set **Sprite** to `spr_SpaceMine` and **Parent** to `obj_Enemy_Parent`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**精灵**设置为`spr_SpaceMine`，**父对象**设置为`obj_Enemy_Parent`。
- en: Create a new Script and name it `scr_SpaceMine_Create`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，并将其命名为`scr_SpaceMine_Create`。
- en: We need the SpaceMine to do a few things. It is going to fire bullets, so we
    will need a variable to control when it shoots. It needs to move across the screen,
    so we need to apply velocity. Finally, we will want to slow down the animation
    so that it doesn't blink too fast.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要SpaceMine做一些事情。它将发射子弹，所以我们需要一个变量来控制何时射击。它需要在屏幕上移动，所以我们需要应用速度。最后，我们希望减慢动画的速度，以免闪烁太快。
- en: 'Write the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下代码：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we are setting the horizontal speed to move slowly to the left. `canFire`
    is a Boolean variable that will determine if it is to shoot or not. Finally, `image_speed`
    sets the speed of the animation. At a speed of `0.2`, it animates at 20 percent
    of normal, or in other words, each frame of animation will be held for five steps.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将水平速度设置为向左缓慢移动。`canFire`是一个布尔变量，将决定是否射击。最后，`image_speed`设置了动画的速度。以`0.2`的速度，它以正常速度的20%进行动画，换句话说，每一帧动画将保持五个步骤。
- en: In `obj_SpaceMine`, add a **Create** event and apply this script.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_SpaceMine`中，添加一个**Create**事件并应用这个脚本。
- en: Create another new script and name it `scr_SpaceMine_Step`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个新的脚本，命名为`scr_SpaceMine_Step`。
- en: Each step we will want to see whether the player is within proximity of the
    SpaceMine. If the player is too close, the SpaceMine will start firing rings of
    bullets. We don't want a stream of bullets, so we are going to need to add a delay
    between each firing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步，我们都希望查看玩家是否在SpaceMine的附近。如果玩家离得太近，SpaceMine将开始发射子弹环。我们不希望有一串子弹，所以我们需要在每次射击之间添加延迟。
- en: 'Write the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下代码：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by checking two statements; the distance between the SpaceMine and
    `obj_Player`, and whether we are able to shoot. The distance we have chosen is
    `200` pixels, which should be enough space for the player to avoid triggering
    it occasionally. If the player is in range and we can shoot, we set `alarm` for
    `60` steps (2 seconds) and play the bullet sound once.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查两个语句；SpaceMine和`obj_Player`之间的距离，以及我们是否能够射击。我们选择的距离是`200`像素，这应该足够让玩家偶尔避免触发它。如果玩家在范围内并且我们能够射击，我们将`alarm`设置为`60`步（2秒），并播放一次子弹声音。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alarm is an event that, when triggered, will execute code a single time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 警报是一个事件，当触发时，将执行一次代码。
- en: To create the ring of bullets we will use a `for` loop. When we create an instance
    of an object it returns the unique ID of that instance. We need to capture this
    in a variable, so that we can talk to the object and affect it. Here we are using
    a variable called `bullet` which is an instance of `obj_Bullet_SpaceMine`. We
    can then change the properties of the bullet such as direction. In this case,
    each bullet will be offset by 45 degrees. We also apply some additional `hspeed`
    to the bullets, so that they move along with the SpaceMine. Finally, we set the
    `canFire` variable to `true` to indicate that we have fired our bullets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建子弹环，我们将使用一个`for`循环。当我们创建一个对象的实例时，它会返回该实例的唯一ID。我们需要将这个ID捕获在一个变量中，这样我们才能与对象交互并影响它。在这里，我们使用一个名为`bullet`的变量，它是`obj_Bullet_SpaceMine`的一个实例。然后我们可以改变子弹的属性，比如方向。在这种情况下，每颗子弹的偏移角度为45度。我们还给子弹添加了一些额外的`hspeed`，这样它们就可以跟随SpaceMine移动。最后，我们将`canFire`变量设置为`true`，表示我们已经发射了子弹。
- en: In `obj_SpaceMine`, add a **Step** event and apply this script.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_SpaceMine`中，添加一个**Step**事件并应用这个脚本。
- en: We are almost done with the SpaceMine, we just need to add some code to an alarm
    that we can trigger, so that it can shoot more than once. Create a new Script
    and name it `scr_SpaceMine_Alarm0`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了SpaceMine，我们只需要在一个可以触发的警报中添加一些代码，这样它就可以多次射击。创建一个新的脚本，命名为`scr_SpaceMine_Alarm0`。
- en: 'Set the `canFire` variable back to `false`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`canFire`变量设置回`false`：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `obj_SpaceMine`, add an **Alarm 0** event and apply this script. We are now
    done with the SpaceMine and it should look like the following screenshot:![Creating
    the SpaceMine](img/4100OT_03_11.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_SpaceMine`中，添加一个**Alarm 0**事件并应用这个脚本。现在我们已经完成了SpaceMine，它应该看起来像下面的截图：![Creating
    the SpaceMine](img/4100OT_03_11.jpg)
- en: Open `TheGame`, add an instance of `obj_SpaceMine` on the right-hand side of
    the screen, and then run the game.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TheGame`，在屏幕的右侧添加一个`obj_SpaceMine`的实例，然后运行游戏。
- en: If everything is set up properly, the SpaceMine will slowly move across the
    screen to the left and blink. When the player approaches the SpaceMine, eight
    bullets should blast out from it as seen in the next screenshot. Every two seconds,
    another ring will be fired from this instance, so long as the player is still
    within range. If the SpaceMine is hit by one of the player bullets, it will be
    destroyed. Finally, if the player collides with the enemy's bullet the player
    disappears. Let's move on to our final enemy!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，SpaceMine将缓慢地向左移动并闪烁。当玩家靠近SpaceMine时，应该会有八颗子弹从中射出，就像下一个截图中所示。每两秒，这个实例将发射另一个子弹环，只要玩家仍然在范围内。如果SpaceMine被玩家的子弹击中，它将被摧毁。最后，如果玩家与敌人的子弹相撞，玩家就会消失。让我们继续我们的最终敌人！
- en: '![Creating the SpaceMine](img/4100OT_03_12.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Creating the SpaceMine](img/4100OT_03_12.jpg)'
- en: Making the Strafer
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作Strafer
- en: The Strafer is the most dangerous enemy in the game. It moves very quickly in
    a straight line and will target the player no matter where they are. Once again,
    there are two objects needed, so let's start with the bullet.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Strafer是游戏中最危险的敌人。它以直线非常快速移动，并且会瞄准玩家无论他们在哪里。再次，我们需要两个对象，所以让我们从子弹开始。
- en: Create a new Sprite and name it `spr_Bullet_Strafer`. Load `Chapter 3/Sprites/Bullet_Strafer.gif`
    with **Remove Background** checked.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，命名为`spr_Bullet_Strafer`。加载`Chapter 3/Sprites/Bullet_Strafer.gif`，并勾选**Remove
    Background**。
- en: Center the origin.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点居中。
- en: Create a new Object and name it `obj_Bullet_Strafer` and set the Sprite to `spr_Bullet_Strafer`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，命名为`obj_Bullet_Strafer`，并将精灵设置为`spr_Bullet_Strafer`。
- en: We want a unique shooting sound, so create a new Sound, `snd_Bullet_Strafer`,
    and load `Chapter 3/Sounds/Bullet_Strafer.wav`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要一个独特的射击声音，所以创建一个新的声音，`snd_Bullet_Strafer`，并加载`Chapter 3/Sounds/Bullet_Strafer.wav`。
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未将**种类**设置为**普通声音**，请点击**确定**。
- en: Create a new Script and name it `scr_Bullet_Strafer_Create`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`scr_Bullet_Strafer_Create`。
- en: 'This script will be similar to `scr_Bullet_SpaceMine_Create`, except that this
    bullet is faster and playing the bullet sound. Write the following code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本与`scr_Bullet_SpaceMine_Create`类似，只是这颗子弹速度更快，并播放子弹声音。编写以下代码：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `obj_Bullet_Strafer`, add a **Create** event and apply this script.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Bullet_Strafer`中，添加一个**创建**事件，并应用此脚本。
- en: As with the other enemy bullet, let's add collision to the bullet by reusing
    the `scr_Enemy_Collision_Player` script. Add an `obj_Player` event from **Collision**
    and apply the script. We are done with this bullet, so let's build the enemy.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他敌人子弹一样，让我们通过重用`scr_Enemy_Collision_Player`脚本为子弹添加碰撞。从**碰撞**中添加一个`obj_Player`事件，并应用该脚本。子弹部分完成后，让我们构建敌人。
- en: Create a new Sprite and name it `spr_Strafer`, and load `Chapter 3/Sprites/Strafer.gif`
    with **Remove Background** checked.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，并将其命名为`spr_Strafer`，并加载`Chapter 3/Sprites/Strafer.gif`，勾选**删除背景**。
- en: 'We want the bullet to come from the front of the ship, so we need to manually
    move the origin to the proper location. Set **Origin** to **X**: `0`, **Y**: `19`.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望子弹从飞船的前方发射，因此我们需要手动将原点移动到正确的位置。将**原点**设置为**X**：`0`，**Y**：`19`。
- en: Create a new Object and name it `obj_Strafer`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，并将其命名为`obj_Strafer`。
- en: Set **Sprite** to `spr_Strafer` and **Parent** to `obj_Enemy_Parent`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**精灵**设置为`spr_Strafer`，**父对象**设置为`obj_Enemy_Parent`。
- en: Create a new Script and name it `scr_Strafer_Create`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`scr_Strafer_Create`。
- en: 'The Strafer is going to move quickly across the screen and fire bullets at
    the player constantly. Write the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Strafer将快速在屏幕上移动并不断向玩家发射子弹。编写以下代码：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Much like the SpaceMine, we have set `hspeed` to move left, and are also setting
    an alarm so that the Strafer will start shooting immediately.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与SpaceMine类似，我们将`hspeed`设置为向左移动，并设置一个警报，以便Strafer立即开始射击。
- en: In `obj_Strafer`, add a **Create** event and apply this script.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Strafer`中，添加一个**创建**事件，并应用此脚本。
- en: We only need one more script and that is for the alarm. Create a new Script
    and name it `scr_Strafer_Alarm0`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要再创建一个脚本，那就是用于警报的脚本。创建一个新的脚本，并将其命名为`scr_Strafer_Alarm0`。
- en: 'When the alarm goes off, we need to create a bullet, launch it at the player,
    and then reset the alarm so that it can fire again. To do this write the following
    code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当警报响起时，我们需要创建一个子弹，将其发射到玩家，并重置警报，以便它可以再次发射。编写以下代码：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We start here by creating an instance of `obj_Bullet_Strafer`. When an instance
    is created, the function returns the unique ID of that instance; we then capture
    it in a variable, such as `bullet`. Next, we query whether the player exists or
    not. This is a very important step, as without this check if the player is dead
    and the Strafer tries to target it, the game will error out and crash.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`obj_Bullet_Strafer`的一个实例。当创建一个实例时，该函数会返回该实例的唯一ID；然后我们将其捕获在一个变量中，比如`bullet`。接下来，我们查询玩家是否存在。这是一个非常重要的步骤，因为如果没有这个检查，如果玩家死亡并且Strafer试图瞄准它，游戏将出错并崩溃。
- en: If the player does exist, we set the bullet direction at the player. This is
    done through the `point_direction` function that takes any two points in space
    (x1, y1) and (x2, y2) and returns the angle in degrees.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家存在，我们将设置子弹的方向指向玩家。这是通过`point_direction`函数完成的，该函数接受空间中的任意两点（x1，y1）和（x2，y2），并返回角度（以度为单位）。
- en: Finally, we reset the alarm. In this case, to make things more interesting we
    have added a bit of randomness to it. The `irandom` function will return a whole
    number between zero and the number you pass to it. The code we have here will
    give us a random value between `0` and `30` and we will add `15` to it. This means
    a new bullet will be created between every half second to a second and a half.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重置警报。在这种情况下，为了增加趣味性，我们添加了一些随机性。`irandom`函数将返回一个介于零和传递给它的数字之间的整数。我们这里的代码将给我们一个介于`0`和`30`之间的随机值，然后我们将其加上`15`。这意味着每隔半秒到一秒半之间将创建一个新的子弹。
- en: In `obj_Strafer`, add an **Alarm 0** event and apply this script.![Making the
    Strafer](img/4100OT_03_13.jpg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Strafer`中，添加一个**Alarm 0**事件，并应用此脚本。![制作Strafer](img/4100OT_03_13.jpg)
- en: The Strafer is now complete, so let's test it out and place one in `TheGame`
    on the left-hand side.![Making the Strafer](img/4100OT_03_14.jpg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Strafer现在已经完成，让我们测试一下，并将其放置在`TheGame`的左侧。![制作Strafer](img/4100OT_03_14.jpg)
- en: If everything is working correctly, the Strafer will quickly move across the
    screen and fire bullets directly at the position of the player. Make sure you
    move the player around the room to make sure it fires in all directions! The player
    should be able to shoot and destroy the Strafer. If hit by the Strafer's bullet,
    the player should disappear.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，Strafer将快速横穿屏幕，并直接朝向玩家位置发射子弹。确保您将玩家移动到房间的各个方向，以确保它可以朝各个方向射击！玩家应该能够射击并摧毁Strafer。如果被Strafer的子弹击中，玩家应该消失。
- en: The enemies for the game are all complete; now we just need a way to populate
    the game world. Let's bring in an Overlord!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的敌人都已经完成；现在我们只需要一种方法来填充游戏世界。让我们引入一个Overlord！
- en: Controlling the game with the Overlord
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Overlord控制游戏
- en: In this game, we will be using the Overlord, the master controller of the game,
    to control the spawning of enemies, monitor the player's lives, and deal with
    the win/lose condition. The win condition will simply be to survive for two minutes
    against waves of enemies. The lose condition will be that the player runs out
    of lives.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们将使用Overlord，游戏的主控制器，来控制敌人的生成，监视玩家的生命，并处理胜利/失败条件。胜利条件很简单，就是在两分钟内生存下来，抵御敌人的波浪。失败条件是玩家耗尽生命。
- en: Spawning waves of enemies
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成敌人的波浪
- en: We need to start by creating the wave of enemies, so that the game is playable.
    For this, we will utilize a looping timeline to spawn the various enemies. We
    are going to have three different waves, each one spawning a different enemy every
    two seconds.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先创建敌人的波动，以便游戏可玩。为此，我们将利用循环时间线来生成各种敌人。我们将有三个不同的波动，每两秒生成一个不同的敌人。
- en: 'Create three new scripts, and name them: `scr_Wave_Strafer`, `scr_Wave_SpaceMine`,
    and `scr_Wave_FloatBot`.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个新脚本，并命名为：`scr_Wave_Strafer`，`scr_Wave_SpaceMine`和`scr_Wave_FloatBot`。
- en: 'We will start with the wave of Strafer, as it will be the simplest wave. Write
    the following code in `scr_Wave_Strafer`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从Strafer的波动开始，因为它将是最简单的波动。在`scr_Wave_Strafer`中编写以下代码：
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we spawn two instances of the Strafer located `64` pixels off the right-hand
    side of the screen. This will ensure that we don't see them pop into existence.
    We have also offset them by `64` pixels from the vertical center of the room.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成两个Strafer的实例，位于屏幕右侧`64`像素处。这将确保我们看不到它们突然出现。我们还将它们偏移了`64`像素，使其与房间的垂直中心相差`64`像素。
- en: 'For the SpaceMine, we will want them vertically placed in random positions
    to keep things interesting. Write the following code in `scr_Wave_SpaceMine`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于SpaceMine，我们希望它们在随机位置垂直放置，以保持事情的趣味性。在`scr_Wave_SpaceMine`中编写以下代码：
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are creating a variable called `placeY` to hold a value for the vertical
    position. GameMaker: Studio has a special function, `irandom_range`, which will
    return a whole number between any two numbers passed to it. The numbers we used
    will ensure that the SpaceMine will remain at least 64 pixels away from the top
    and bottom of the screen. We then use the `placeY` variable when we create the
    instance.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建一个名为`placeY`的变量来保存垂直位置的值。GameMaker: Studio有一个特殊的函数`irandom_range`，它将返回传递给它的两个数字之间的整数。我们使用的数字将确保SpaceMine距离屏幕顶部和底部至少64像素。然后我们在创建实例时使用`placeY`变量。'
- en: 'The FloatBot is going to use a similar setup for placement on the vertical
    axis, but we will want three instances flying in a "V" formation. Write the following
    code in `scr_Wave_FloatBot`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FloatBot将使用类似的垂直轴放置设置，但我们希望有三个实例以“V”形式飞行。在`scr_Wave_FloatBot`中编写以下代码：
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we are using the `placeY` variable again, but the range of numbers is narrower.
    We need some extra padding, so that all three planes stay onscreen. The first
    instance created is the front unit of the formation. The next two instances spawn
    32 pixels behind and offset 32 pixels above and below the first.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用`placeY`变量，但数字范围更窄。我们需要一些额外的填充，以便所有三个飞机都保持在屏幕上。创建的第一个实例是编队的前部单位。接下来的两个实例在第一个实例的后面生成，偏移了32像素，并分别在第一个实例的上方和下方偏移了32像素。
- en: All the waves are scripted, so we can now implement them in a Time Line. When
    first implementing a Time Line, it is useful to keep the numbers simple, such
    as two seconds apart. Properly balancing the timing comes during the polish phase
    of a game's development, and spending too much time trying to get this right before
    all content is in is most likely wasted time. Create a new Time Line and name
    it `tm_Wave_Spawning`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有波动都已编写脚本，因此我们现在可以在时间线中实现它们。首次实现时间线时，保持数字简单是有用的，例如相隔两秒。适当平衡时间是在游戏开发的打磨阶段进行的，花费太多时间试图在所有内容都在位之前就把这个问题解决好，很可能是浪费时间。创建一个新的时间线，命名为`tm_Wave_Spawning`。
- en: Click on **Add**, set **Indicate the Moment** as `60`, and apply the `scr_Wave_FloatBot`
    script. This will spawn the first enemy into the game for two seconds.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Add**，将**Indicate the Moment**设置为`60`，并应用`scr_Wave_FloatBot`脚本。这将在游戏中生成第一个敌人，持续两秒。
- en: We will want to add the SpaceMines two seconds later. Click on **Add**, set
    **Indicate the Moment** as `120`, and apply the `scr_Wave_SpaceMine` script.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两秒后我们将添加SpaceMines。点击**Add**，将**Indicate the Moment**设置为`120`，并应用`scr_Wave_SpaceMine`脚本。
- en: Finally we bring in the Strafer after six seconds. Click on **Add**, set **Indicate
    the Moment** as `180`, and apply the `scr_Wave_Strafer` script. The Time Line
    is now ready to be used and should look like the following screenshot:![Spawning
    waves of enemies](img/4100OT_03_15.jpg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，六秒后我们将带入Strafer。点击**Add**，将**Indicate the Moment**设置为`180`，并应用`scr_Wave_Strafer`脚本。时间线现在已准备好使用，并且应该如下截图所示：![生成敌人的波动](img/4100OT_03_15.jpg)
- en: Building the Overlord
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Overlord
- en: We are now ready to start building the Overlord and apply our spawning system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始构建Overlord并应用我们的生成系统。
- en: Create a new Object and name it `obj_Overlord`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Overlord`。
- en: There is no Sprite needed, so set **Sprite** to **no sprite**.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不需要精灵，所以将**Sprite**设置为**no sprite**。
- en: 'We will start the Time Line immediately upon creation of the Overlord. Create
    a new Script, name it `scr_Overlord_Create`, and write the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在创建Overlord时立即开始时间线。创建一个新脚本，命名为`scr_Overlord_Create`，并编写以下代码：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first line of code defines what Time Line we want to run, in our case we
    only have one: `tm_Wave_Spawning`. Next, we start the Time Line and then tell
    it to loop. These last two are Boolean variables, which means that they can only
    be turned on and off.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行定义了我们要运行的时间线，我们只有一个：`tm_Wave_Spawning`。接下来，我们启动时间线，然后告诉它循环。这最后两个是布尔变量，这意味着它们只能打开和关闭。
- en: In the Overlord, add a **Create** event and apply this script.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Overlord中，添加一个**Create**事件并应用此脚本。
- en: Open **TheGame** and place a single instance of the Overlord anywhere in the
    room. The location does not matter, but the upper-left corner is a common place
    to put it.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**TheGame**，并在房间中放置一个Overlord的实例。位置无关紧要，但左上角是一个常见的放置位置。
- en: Remove any instances of the enemies that remain in the room. There should be
    only one instance of the Player and one of the Overlord as can be seen in the
    following screenshot:![Building the Overlord](img/4100OT_03_16.jpg)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除房间中剩余的敌人实例。如下截图所示，房间中应该只有一个Player的实例和一个Overlord的实例：![构建Overlord](img/4100OT_03_16.jpg)
- en: Run the game.![Building the Overlord](img/4100OT_03_17.jpg)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。![构建Overlord](img/4100OT_03_17.jpg)
- en: 'The game now has enemies! It will take a couple of seconds for the first enemy,
    the FloatBots, to appear, but after that the enemies will continue to spawn forever.
    At this point we have most of the core gameplay implemented as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在有敌人！第一个敌人FloatBots出现需要几秒钟，但之后敌人将会不断生成。到目前为止，我们已经实现了大部分核心游戏玩法，如下所示：
- en: We can move the player around the screen, but not out of it
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在屏幕上移动玩家，但不能移出屏幕
- en: We can shoot and destroy enemies
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以射击和摧毁敌人
- en: Enemies can shoot and destroy the player
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人可以射击和摧毁玩家
- en: Enemies will spawn continuously
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人将不断生成
- en: The only element remaining is very obvious when playing the game at this stage;
    the player can die, but the game doesn't stop. We need to implement the win/lose
    condition.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段玩游戏时，唯一剩下的元素非常明显；玩家可以死亡，但游戏不会停止。我们需要实现胜利/失败条件。
- en: Dealing with the life and death of the player
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理玩家的生死
- en: As this is a game about survival, we will want the win/lose condition to be
    fairly simple. For the win condition, we will make the player survive for a set
    amount of time. The lose condition will be the player dying, but we don't want
    to come across as too hard to play, so we will give the player three lives. This
    means that we are going to need to respawn the player. Finally, to get this to
    work properly, we will need to give the Overlord some more duties.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个关于生存的游戏，我们希望胜利/失败条件相对简单。对于胜利条件，我们将使玩家生存一段时间。失败条件是玩家死亡，但我们不希望游戏太难玩，所以我们给玩家三条生命。这意味着我们需要重新生成玩家。最后，为了使这个功能正常工作，我们需要给Overlord一些额外的职责。
- en: Setting up the win condition
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置胜利条件
- en: The win condition for this game is to survive for a set amount of time. We can
    achieve this through the use of an alarm and a variable to signal to the Overlord
    that the player has survived.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的胜利条件是生存一段时间。我们可以通过使用警报和一个变量来实现这一点，向Overlord发出信号，玩家已经生存下来。
- en: 'We will need to set up some variables for the lives, win, and lose conditions.
    Reopen `scr_Overlord_Create` and add the following code at the bottom:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为生命、胜利和失败条件设置一些变量。重新打开`scr_Overlord_Create`，在底部添加以下代码：
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'GameMaker: Studio has a few built-in global variables including `lives`. This
    variable is accessible by every instance in the game and never goes away. Here
    we have set it to `3` and will use that as our starting point. We also create
    two other variables, `isVictory` and `isDefeat`, which we have set to `false`.
    The reason we are using two variables to represent winning and losing the game
    instead of one is that we will want to check these during gameplay when they have
    neither won nor lost.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'GameMaker: Studio有一些内置的全局变量，包括`lives`。这个变量可以被游戏中的每个实例访问，永远不会消失。在这里，我们将其设置为`3`，并将其用作我们的起点。我们还创建了另外两个变量，`isVictory`和`isDefeat`，我们将其设置为`false`。我们之所以使用两个变量来表示游戏的胜利和失败，而不是一个，是因为我们希望在游戏过程中检查它们，当他们既没有赢也没有输时。'
- en: 'We can also set our win condition in this script by setting an alarm for 90
    seconds. To do this add the following line of code after the code in step 1:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过在这个脚本中设置一个90秒的警报来设置我们的胜利条件。为此，在步骤1的代码之后添加以下代码行：
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `scr_Overlord_Create` script should now look like the following in total:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`scr_Overlord_Create`脚本现在应该总共如下所示：'
- en: '[PRE27]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we have to set up a script for the alarm event for the victory condition.
    Create a new Script, name it `scr_Overlord_Victory`, and write the following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为胜利条件的警报事件设置一个脚本。创建一个新脚本，命名为`scr_Overlord_Victory`，并编写以下代码：
- en: '[PRE28]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The very first thing we do is stop the Time Line, as we don't want any more
    enemies to spawn. The next step is to remove all enemies still alive in the game.
    We do this by using a `with` statement that is going to execute code to all instances
    of `obj_Enemy_Parent`. As all the enemies are children of this object, they too
    will be destroyed. We will eventually want to restart the game, so we set another
    alarm for three seconds. Finally, we set the `isVictory` variable to true.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是停止时间线，因为我们不希望再生成更多的敌人。下一步是移除游戏中仍然存活的所有敌人。我们通过使用`with`语句来执行`obj_Enemy_Parent`的所有实例的代码来实现这一点。因为所有的敌人都是这个对象的子对象，它们也会被销毁。最后，我们为三秒钟设置另一个警报。最后，我们将`isVictory`变量设置为true。
- en: In `obj_Overlord`, add an **Alarm 0** event and apply the victory script.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Overlord`中，添加一个**Alarm 0**事件并应用胜利脚本。
- en: 'Let''s wrap this up by creating the restart script. Create a new Script, name
    it `scr_Overlord_GameRestart` and write this code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过创建重新启动脚本来结束这一切。创建一个新脚本，命名为`scr_Overlord_GameRestart`，并编写以下代码：
- en: '[PRE29]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Add an **Alarm 1** event and apply this restart script. The win condition is
    now working, so feel free to try it out.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Alarm 1**事件并应用重新启动脚本。现在胜利条件已经生效，随时可以尝试。
- en: Respawning with a Ghost object
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ghost对象重新生成
- en: We can now move on to the losing condition and respawning. When the player dies,
    we don't want to have the player respawn immediately, but instead have a smaller
    buffer of invulnerability. To do this, we will want to create a Ghost object that
    will temporarily stand in for the player.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转向失败条件和重新生成。当玩家死亡时，我们不希望玩家立即重新生成，而是有一个较短的无敌时间。为此，我们需要创建一个Ghost对象，暂时代替玩家。
- en: Create a new Sprite, name it `spr_Ghost`, and load `Chapter 3/Sprites/Ghost.gif`
    with **Remove Background** checked. It looks just like the plane, but is slightly
    transparent and flickers when animated.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新精灵，命名为`spr_Ghost`，并加载`Chapter 3/Sprites/Ghost.gif`，勾选**删除背景**。它看起来就像飞机，但是略微透明，在动画时会闪烁。
- en: 'We need to set the origin to be exactly the same as the origin of `spr_Player`.
    Set **Origin** to **X**: `43`, **Y**: `22`, and then click on **OK**.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将原点设置为与`spr_Player`的原点完全相同。将**原点**设置为**X**:`43`，**Y**:`22`，然后点击**确定**。
- en: Create a new Object, name it `obj_Ghost`, and apply `spr_Ghost` as the Sprite.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Ghost`，并将`spr_Ghost`应用为精灵。
- en: 'When the player dies, we are going to have the Ghost appear offscreen to the
    left and then move into the gameplay area. Create a new Script, name it `scr_Ghost_Create`,
    and write the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家死亡时，我们将让Ghost出现在屏幕左侧并移入游戏区域。创建一个新的脚本，命名为`scr_Ghost_Create`，并编写以下代码：
- en: '[PRE30]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We start by setting the `x` coordinate to be offscreen by `64` pixels. We then
    center the Ghost vertically by setting the `y` coordinate to half of the room
    height. Finally, we are applying a positive velocity to the Ghost, so that it
    starts moving on its own.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`x`坐标设置为屏幕外`64`像素。然后通过将`y`坐标设置为房间高度的一半来垂直居中Ghost。最后，我们对Ghost施加正向速度，使其开始自行移动。
- en: Add a **Create** event to `obj_Ghost` and apply this script.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`obj_Ghost`添加一个**Create**事件并应用此脚本。
- en: 'The Ghost is going to move on the screen, and we will need to change it into
    the player at some point. In our case, we will make the switch once the Ghost
    has passed quarter way into the gameplay area. Create a new script, name it `scr_Ghost_Step`,
    and write the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ghost将在屏幕上移动，我们需要在某个时候将其转换为玩家。在我们的情况下，一旦Ghost通过了游戏区域的四分之一，我们将进行切换。创建一个新的脚本，命名为`scr_Ghost_Step`，并编写以下代码：
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here we check to see if the Ghost''s `x` coordinate has crossed `200` pixels
    or not. If it has, we stop the forward velocity and then we transform into the
    player. The `instance_change` function asks for two arguments: what object to
    transform into and whether we want to run the **Create** event of this new object.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查Ghost的`x`坐标是否已经越过了`200`像素。如果是，我们停止向前的速度，然后转换为玩家。`instance_change`函数需要两个参数：要转换为的对象以及是否要运行此新对象的**Create**事件。
- en: Add a **Step** event to `obj_Ghost` and apply this script.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`obj_Ghost`添加一个**Step**事件并应用此脚本。
- en: One issue we will encounter with this setup is that the player has no control
    of the Ghost, and could end up in a dangerous position near an enemy when they
    transform. We don't want that, so let's give the player some limited controls.
    We can reuse the existing `scr_Player_Key_Up` and `scr_Player_Key_Down` scripts,
    so that the player has vertical movement. Add the appropriate Keyboard events
    and attach these scripts.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这种设置中遇到一个问题，那就是玩家无法控制Ghost，并且在变换时可能会出现在靠近敌人的危险位置。我们不希望出现这种情况，所以让我们给玩家一些有限的控制权。我们可以重用现有的`scr_Player_Key_Up`和`scr_Player_Key_Down`脚本，以便玩家具有垂直移动。添加适当的键盘事件并附加这些脚本。
- en: The Ghost Object's properties should look like the following screenshot and
    is now ready to become a part of the game. We just need to change what happens
    when the player is hit.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Ghost对象的属性应该如下截图所示，现在已经准备好成为游戏的一部分。我们只需要改变玩家被击中时发生的事情。
- en: '![Respawning with a Ghost object](img/4100OT_03_18.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![使用Ghost对象重新生成](img/4100OT_03_18.jpg)'
- en: Reopen `scr_Enemy_Collision_Player`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Enemy_Collision_Player`。
- en: 'Currently, we are destroying both the bullet and the player. We need to change
    the `with` statement to allow for respawning. Remove line **3**:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们正在销毁子弹和玩家。我们需要更改`with`语句以允许重新生成。删除第**3**行：
- en: '[PRE32]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And replace it with:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 并替换为：
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We only want to become a Ghost if we have lives available, so we start by checking
    that. If we do have at least one life, we transform the Player into a Ghost. Otherwise,
    we just destroy the Player and the Player will be permanently dead. Finally, we
    subtract a life every time, whether we have lives or not. The final code should
    look like the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在有生命可用时变成Ghost，因此我们首先要检查这一点。如果我们至少有一条生命，我们就将玩家变成Ghost。否则，我们只是销毁玩家，玩家将永远死亡。最后，无论我们是否有生命，每次都要减少一条生命。最终的代码应该如下所示：
- en: '[PRE34]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At this point we can play the game. Notice that when the player dies:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们可以玩游戏。请注意，当玩家死亡时：
- en: The player disappears
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家消失
- en: A Ghost is created and moves into the play area
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Ghost并移入游戏区域
- en: The Ghost can move up and down
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ghost可以上下移动
- en: The Ghost turns back into the Player
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ghost变回Player
- en: This of course happens three times and then the player disappears forever. The
    rest of the game, however, is continuing on as if nothing happened. We need to
    add in the defeat condition.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会发生三次，然后玩家永远消失。然而，游戏的其余部分正在继续，就好像什么都没有发生。我们需要添加失败条件。
- en: 'Create a new Script, `scr_Overlord_Step`, and write the following code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Overlord_Step`，并编写以下代码：
- en: '[PRE35]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Every step in this code will check to see if the player has any lives left.
    If the player has no lives left and the variable `isDefeat` is still `false`,
    it will set the *Restart Game* alarm for three seconds. Lastly, we set the `isDefeat`
    variable to `true`, so that we don't run this code again.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的每一步都会检查玩家是否还有生命。如果玩家没有生命了，而变量`isDefeat`仍然为`false`，它将为*重新开始游戏*警报设置三秒。最后，我们将`isDefeat`变量设置为`true`，这样我们就不会再运行这段代码了。
- en: In `obj_Overlord`, add a **Step** event and apply this script. The game will
    now restart after the player dies three times.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Overlord`中，添加一个**Step**事件并应用此脚本。玩家死亡三次后游戏将重新开始。
- en: The core mechanics of the game are now complete, but it's not very clear to
    the player as to what is going on. The player can die and respawn a few times,
    but there is no indication of how many lives are left. Nor is there any information
    being displayed on whether the player has won or lost the game. Let's fix this!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的核心机制现在已经完成，但对于玩家来说，发生了什么并不是很清楚。玩家可以死亡并重新生成几次，但没有显示剩余生命的指示。也没有显示玩家是赢了还是输了。让我们来解决这个问题！
- en: Drawing the user interface
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制用户界面
- en: One of the most important elements in creating a great game is ensuring that
    the player has all the information they need to play the game. Much of this is
    usually presented in the **heads-up display**, otherwise known as the **HUD**.
    Every game has different components that can be a part of the HUD including things
    we need such as scoreboards and life counters.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个伟大游戏的最重要元素之一是确保玩家拥有玩游戏所需的所有信息。其中很多通常显示在**HUD**中，也就是**heads-up display**。每个游戏都有不同的组件可以成为HUD的一部分，包括我们需要的记分牌和生命计数器等。
- en: To start with, we are going to need a font for the text we intend to display.
    We have supplied a font called **Retroheavyfuture** for use in this game that
    will need to be installed on your computer. To install this font on a Windows
    7 computer, right-click on `Chapter 3/Fonts/RETRRG__.ttf` and click on **Install**.
    Then follow the directions when prompted.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个用于显示文本的字体。我们提供了一个名为**Retroheavyfuture**的字体供本游戏使用，需要在您的计算机上安装。要在Windows
    7计算机上安装此字体，请右键单击`Chapter 3/Fonts/RETRRG__.ttf`，然后单击**安装**。然后按照提示进行操作。
- en: 'Back into GameMaker: Studio, create a new font and name it `fnt_Scoreboard`.'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '回到GameMaker: Studio，创建一个新的字体，命名为`fnt_Scoreboard`。'
- en: Select **Retroheavyfuture** as **Font**.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Retroheavyfuture**作为**字体**。
- en: Set **Size** under **Style** to `16`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**样式**下将**大小**设置为`16`。
- en: We want a decent sized font to display the score and lives during the game.
    It should look like the following screenshot, so click on **OK**:![Drawing the
    user interface](img/4100OT_03_19.jpg)
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个适当大小的字体来显示游戏中的得分和生命。它应该看起来像下面的截图，所以点击**确定**：![绘制用户界面](img/4100OT_03_19.jpg)
- en: We will need a second version of the font when we display the win/lose condition.
    Create a new font and name it `fnt_WinLose`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们显示胜利/失败条件时，我们将需要字体的第二个版本。创建一个新的字体，命名为`fnt_WinLose`。
- en: Once again, select **Retroheavyfuture** as **Font**, but this time set **Size**
    to `32`. We now have all the in-game fonts we need, so click on **OK**.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择**Retroheavyfuture**作为**字体**，但这次将**大小**设置为`32`。现在我们已经拥有了所有游戏中需要的字体，所以点击**确定**。
- en: 'Let''s move on to the new Script, `scr_Overlord_Draw`. We will start by setting
    the color and the font for the scoreboard text with this code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续进行新的脚本`scr_Overlord_Draw`。我们将从以下代码开始设置记分牌文本的颜色和字体：
- en: '[PRE36]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first line of code sets the color with one of GameMaker: Studio''s premade
    colors, `c_white`. The next line then sets the scoreboard as the font.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行代码设置了一个GameMaker: Studio预设颜色`c_white`。接下来的一行将记分牌设置为字体。'
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Setting colors are globally applied to the `draw` events. That means if you
    don't set a color, it will use the color last set, regardless of the object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 设置颜色是全局应用于`draw`事件的。这意味着如果您不设置颜色，它将使用上次设置的颜色，而不管对象如何。
- en: 'With the font set we can start applying the HUD. We will start with the player
    lives. Add this code to the script:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置字体后，我们可以开始应用HUD。我们将从玩家生命开始。将以下代码添加到脚本中：
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To ensure the text is properly formatted, we set the horizontal alignment of
    the text to be aligned left. The text itself needs to be a string, which can be
    done in two ways. First, anything in quotation marks is considered a string, such
    as `"Lives: "`. If we want to pass a number, such as the amount of lives we have,
    we need to convert it by passing through the string function. As seen here, if
    we have lives remaining we can concatenate the two things to create a single sentence
    *Lives: 3* and draw it in the upper-left corner of the screen. If we are out of
    life, we draw the text without the concatenated value.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保文本格式正确，我们将文本的水平对齐设置为左对齐。文本本身需要是一个字符串，可以通过两种方式完成。首先，任何用引号括起来的内容都被视为字符串，比如`"生命："`。如果我们想传递一个数字，比如我们拥有的生命数量，我们需要通过字符串函数进行转换。如下所示，如果我们还有剩余的生命，我们可以将这两个东西连接起来创建一个句子“生命：3”，并将其绘制在屏幕的左上角。如果我们没有生命了，我们就绘制不带连接值的文本。
- en: 'The other HUD element we want is the score, which we will place on the opposite
    side of the screen in the upper-right corner. Add the following code:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要的另一个HUD元素是得分，我们将其放在屏幕的对面，即右上角。添加以下代码：
- en: '[PRE38]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we did with the previous text, we are setting the horizontal alignment, this
    time to the right. We then place the text in the proper position using the same
    concatenation method for the score.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的文本一样，我们设置了水平对齐，这次是右对齐。然后使用相同的连接方法将文本放在正确的位置。
- en: Let's test this out now by adding a **Draw GUI** event to `obj_Overlord` and
    apply this script.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过向`obj_Overlord`添加**绘制GUI**事件并应用此脚本来测试一下。
- en: Run the game. As seen in the next screenshot, the game should now display the
    lives in the upper-left corner and update each time the player dies. It should
    also display the score in the upper right-hand corner and increase with every
    enemy killed.![Drawing the user interface](img/4100OT_03_20.jpg)
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。如下截图所示，游戏现在应该在左上角显示生命，并在玩家死亡时更新。它还应该在右上角显示得分，并随着每个敌人被杀而增加。![绘制用户界面](img/4100OT_03_20.jpg)
- en: 'We now need to add the display for when the player wins or loses. Add the following
    code at the end of `scr_Overlord_Draw`:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加玩家赢或输时的显示。在`scr_Overlord_Draw`的末尾添加以下代码：
- en: '[PRE39]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We change the font to `fnt_WinLose` and set the horizontal alignment to be in
    the center. We don't want the text to be displayed all the time, instead we should
    only show either **VICTORY** or **DEFEAT** when it is appropriate. We have already
    implemented the code in the Overlord for the game condition, so we just check
    every step whether `isVictory` is `true` or `isDefeat` is `true`. As soon as the
    game is either won or lost, we draw the appropriate text in the center of the
    room.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字体更改为`fnt_WinLose`，并将水平对齐设置为居中。我们不希望文本一直显示，而是应该在适当时只显示**VICTORY**或**DEFEAT**。我们已经在Overlord中实现了游戏条件的代码，所以我们只需要在每一步检查`isVictory`是否为`true`或`isDefeat`是否为`true`。一旦游戏赢了或输了，我们就在房间的中心绘制适当的文本。
- en: 'The complete `scr_Overlord_Draw` script should look like the following code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`scr_Overlord_Draw`脚本应该如下所示：
- en: '[PRE40]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Adding the finishing details to the game
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为游戏添加完成细节
- en: The game is now functionally complete, but it doesn't have any polish or the
    finishing details we would expect of a full game. There is no music, no background
    art, and no explosions! Let's fix that right now.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在在功能上已经完成，但它没有任何光泽或我们期望的完整游戏的完成细节。没有音乐，没有背景艺术，也没有爆炸！让我们立即解决这个问题。
- en: Adding the game music
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加游戏音乐
- en: We want the music to start at the beginning and play for the duration of the
    game. When the win/lose condition occurs, we want the music to fade out to let
    the player know that the game is over.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望音乐从头开始播放，并在游戏持续时间内播放。当发生胜利/失败条件时，我们希望音乐渐渐消失，以让玩家知道游戏已经结束。
- en: Create a new Sound and name it `snd_Music`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的声音并命名为`snd_Music`。
- en: Load `Chapter 3/Sounds/Music.mp3`. **Kind** should be set to **Background Music**.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`Chapter 3/Sounds/Music.mp3`。**种类**应设置为**背景音乐**。
- en: 'Reopen `scr_Overlord_Create`. Since the Overlord controls the overall game,
    we will use it to control the music as well. After the last line of code, add
    the following:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Overlord_Create`。由于霸主控制整个游戏，我们将使用它来控制音乐。在最后一行代码之后，添加以下内容：
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We start by playing the music and set it to loop. We then create a variable,
    `volume`, that we will use for controlling the sound level and the fade out. We
    have set the sound level to `1`, which is full volume. Finally, we set the global
    sound level, or master gain level, to the variable `volume`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先播放音乐并设置为循环。然后创建一个名为`volume`的变量，我们将用它来控制音量和淡出。我们已将音量设置为`1`，即最大音量。最后，我们将全局音量，或主增益级别，设置为变量`volume`。
- en: 'Reopen `scr_Overlord_Step`. To fade the music out we will need to lower the
    global volume over several steps, but only if the game has ended. After the last
    line of code, add the following:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Overlord_Step`。为了淡出音乐，我们需要在几个步骤内降低全局音量，但只有在游戏结束时才这样做。在最后一行代码之后，添加以下内容：
- en: '[PRE42]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here we check to see if either the win or lose condition has been set to `true`.
    If it has been, we decrease the volume variable by `0.02` and apply it to the
    master gain level. It will take 50 steps for the sound level to go from full volume
    to silent, which is about half the duration before the game restart kicks in.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查是否已将胜利或失败条件设置为`true`。如果是，我们将通过`0.02`减少音量变量并将其应用于主增益级别。声音级别从最大音量降至静音需要50步，大约是游戏重新开始之前的一半时间。
- en: Run the game. You should now hear the background music playing. If the player
    dies quickly three times and the defeat condition is triggered, you should hear
    the sound fade out.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。现在你应该听到背景音乐正在播放。如果玩家快速死亡三次并触发了失败条件，你应该听到声音渐渐消失。
- en: Making the background move
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使背景移动
- en: This game takes place in outer space, so we will need to add in a space backdrop.
    In order for the game universe to feel as though the player is moving, we need
    to make the background shift constantly to the left.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏发生在外太空，所以我们需要添加一个太空背景。为了让游戏宇宙感觉玩家在移动，我们需要使背景不断向左移动。
- en: Create a new Background and name it `bg_Starscape`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的背景并命名为`bg_Starscape`。
- en: Load `Chapter 3/Backgrounds/Starscape.gif` with **Remove Background** unchecked.
    This is all we need to do for this, so click on **OK**.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`Chapter 3/Backgrounds/Starscape.gif`，不勾选**删除背景**。这就是我们需要做的一切，所以点击**确定**。
- en: Open `TheGame` and select the **backgrounds** tab.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TheGame`并选择**背景**选项卡。
- en: Set `bg_Starscape` as **background image**. It should happen automatically,
    but ensure that **Background 0** is highlighted and that **Visible when room starts**
    is checked.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bg_Starscape`设置为**背景图像**。这应该会自动发生，但确保**背景0**被突出显示，并且在房间开始时**可见**已被选中。
- en: The starscape is only going to move horizontally, therefore we only need **Tile
    Hor.** checked so that the image wraps around.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 星空只会水平移动，因此我们只需要勾选**水平平铺**，以便图像环绕。
- en: To move the background, set **Hor. Speed:** to `-2`. This will make it move
    to the left, which will make the player appear to move to the right. The settings
    should look like the following screenshot:![Making the background move](img/4100OT_03_21.jpg)
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要移动背景，将**水平速度**设置为`-2`。这将使其向左移动，从而使玩家看起来向右移动。设置应如下截图所示：![使背景移动](img/4100OT_03_21.jpg)
- en: Run the game. You should now see a moving starscape! Check out the following
    screenshot:![Making the background move](img/4100OT_03_22.jpg)
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。现在你应该看到一个移动的星空！查看以下截图：![使背景移动](img/4100OT_03_22.jpg)
- en: Creating the explosions
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建爆炸
- en: Having enemies just blink out of existence not only looks bad, it is not very
    rewarding to the player. Let's make this more exciting by adding in some explosions!
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让敌人突然消失不仅看起来很糟糕，而且对玩家来说也不是很有意义。让我们通过添加一些爆炸效果来使游戏更加令人兴奋！
- en: Create a new Sprite, `spr_Explosion`, and load `Chapter 3/Sprites/Explosion.gif`
    with **Remove Background** checked.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，`spr_Explosion`，并加载`Chapter 3/Sprites/Explosion.gif`，勾选**删除背景**。
- en: Set the origin to the center and click on **OK**.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点设置为中心，然后点击**确定**。
- en: Create a new Sound, `snd_Explosion`, and load `Chapter 3/Sounds/Explosion.wav`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的声音，`snd_Explosion`，并加载`Chapter 3/Sounds/Explosion.wav`。
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未设置**种类**为**普通声音**，请设置为**普通声音**，然后点击**确定**。
- en: Create a new Object, `obj_Explosion`, and set the sprite to `spr_Explosion`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Explosion`，并将精灵设置为`spr_Explosion`。
- en: We want the explosion to make a sound, play its animation, and then remove itself
    from the game.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望爆炸发出声音，播放其动画，然后从游戏中移除自身。
- en: 'Create a new Script, `scr_Explosion_Create`, and write the following code to
    play the explosion sound a single time:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Explosion_Create`，并编写以下代码以播放爆炸声音一次：
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Add a **Create** event and apply this script.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**创建**事件并应用此脚本。
- en: 'To get the explosion to remove itself is best done when the animation is finished.
    Luckily for us, GameMaker: Studio has an event for that. Add an **Animation End**
    event from **Other**, and then create a new Script to apply to it named `scr_Explosion_AnimEnd`
    with the following code to remove the instance:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要使爆炸自行消失，最好在动画完成时执行。幸运的是，GameMaker: Studio有一个事件可以做到这一点。从**其他**中添加一个**动画结束**事件，然后创建一个名为`scr_Explosion_AnimEnd`的新脚本，并添加以下代码以删除实例：'
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The explosion is now prepared and all we have to do is spawn it when we destroy
    an enemy. Open `scr_Enemy_Collision_Bullet` and add the following line of code
    at the very top of the script on line **1**:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 爆炸现在已经准备好了，我们所要做的就是在摧毁敌人时生成它。打开`scr_Enemy_Collision_Bullet`，并在脚本的第一行添加以下代码：
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will create an explosion right where the enemy is located. This needs to
    happen before we remove the enemy from the game.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在敌人所在的位置创建一个爆炸。这需要在我们将敌人从游戏中移除之前发生。
- en: Repeat this code addition with `scr_Enemy_Collision_Player`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scr_Enemy_Collision_Player`重复这段代码添加。
- en: Run the game. You should now see explosions whenever something is destroyed
    as shown in the following screenshot:![Creating the explosions](img/4100OT_03_23.jpg)
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。现在，每当有东西被摧毁时，你应该看到爆炸，就像下面的截图所示：![Creating the explosions](img/4100OT_03_23.jpg)
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Congratulations! You have just finished creating your first side-scrolling
    shooter. We covered quite a lot in this chapter. We have applied all three methods
    of movement: manually adjusting the X and Y coordinates, using `hspeed` and `vspeed`,
    and setting the `speed` and `direction` variables. We are now able to add and
    remove instances from the game world dynamically. With the bullets, we learned
    to transfer information from one instance to another, such as the direction to
    move, by capturing the ID of the instance and accessing it through the dot operator.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚完成了创建你的第一个横向卷轴射击游戏。在本章中，我们涵盖了相当多的内容。我们应用了移动的三种方法：手动调整X和Y坐标，使用`hspeed`和`vspeed`，以及设置`speed`和`direction`变量。我们现在能够动态地向游戏世界添加和移除实例。通过子弹，我们学会了将信息从一个实例传输到另一个实例，比如移动的方向，通过捕获实例的ID并通过点运算符访问它。
- en: We discovered the wonderful `with` statement that gave us the ability to affect
    a single instance, all instances of an object, or even the `other` instance involved
    in a collision. We took a look at global variables, such as `lives` and `score`,
    and used the **Draw** event to display it. Waves of enemies were spawned using
    Time Lines. The illusion of movement was created by scrolling the background image.
    Sound was applied and the volume adjusted to create a fade out effect. We even
    used a bit of trigonometry!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了美妙的`with`语句，它使我们能够影响单个实例、对象的所有实例，甚至是碰撞中涉及的`other`实例。我们研究了全局变量，比如`lives`和`score`，并使用**Draw**事件来显示它。敌人的波浪是使用时间轴生成的。通过滚动背景图像创建了移动的错觉。声音被应用，并调整音量以创建淡出效果。我们甚至使用了一点三角学！
- en: With the skills and knowledge developed in this chapter it is now your turn
    to take this game and extend it even further. Try adding your own enemies, collectible
    items, and weapon power-ups. Have some fun with it!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有了本章中所学的技能和知识，现在轮到你来接管这个游戏，并进一步扩展它。尝试添加你自己的敌人、可收集物品和武器升级。玩得开心吧！
- en: In the next chapter, we are going to learn more about collision and player controls
    by making a spooky adventure game. We will also take a look at artificial intelligence
    and using paths to make the enemies appear to think and act on their own.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过制作一个恐怖冒险游戏，更多地了解碰撞和玩家控制。我们还将研究人工智能，并使用路径使敌人看起来像在自己思考和行动。
