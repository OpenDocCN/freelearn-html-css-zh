- en: Chapter 2. Introducing ImpactJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。介绍ImpactJS
- en: Now that we have gathered all the necessary tools and got the first game up
    and running, it's time to learn more about how Impact actually works.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了所有必要的工具，并且第一个游戏已经开始运行，现在是时候更多地了解Impact的实际工作原理了。
- en: However, before diving into the code, we should first copy the code from the
    `chapter 2` folder to the correct locations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在深入代码之前，我们应该先将代码从`chapter 2`文件夹复制到正确的位置。
- en: Similar to what we have done in [Chapter 1](ch01.html "Chapter 1. Firing Up
    Your First Impact Game"), *Firing Up Your First Impact Game*, we just need to
    overwrite the `main.js` and `index.html` files and the `entities`, `levels`, `plugins`,
    and `media` folders of the `myfirstawesomegame` project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第1章](ch01.html "第1章。启动您的第一个Impact游戏")中所做的类似，*启动您的第一个Impact游戏*，我们只需要覆盖`myfirstawesomegame`项目的`main.js`和`index.html`文件以及`entities`、`levels`、`plugins`和`media`文件夹。
- en: We are now set to go and explore the intricate workings of the ImpactJS engine!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好去探索ImpactJS引擎的复杂工作原理了！
- en: 'In this chapter we will cover the following processes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下过程：
- en: The Weltmeister tool in ImpactJS and the consequences of changing certain parameters
    in a level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImpactJS的Weltmeister工具以及更改关卡中某些参数的后果
- en: The manner in which level layers impact level design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层级图层如何影响关卡设计
- en: How collision is handled in ImpactJS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ImpactJS中如何处理碰撞
- en: The ImpactJS entity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImpactJS实体
- en: The properties of an ImpactJS entity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImpactJS实体的属性
- en: How a playable entity differs from a non-playable one
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可玩实体与不可玩实体的区别
- en: How to spawn or kill a character
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何生成或消灭一个角色
- en: How to set up player controls
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置玩家控制
- en: How to change the game's graphics
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更改游戏的图形
- en: How to play sound effects when triggered and a background tune
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在触发时播放音效和背景音乐
- en: How to add physics to a game using Box2D
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Box2D为游戏添加物理效果
- en: Building your own levels
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的关卡
- en: While designing a game, you would want to create the setting and the place where
    it all happens. Many games are divided into levels, often getting more difficult
    with each level upgradation. For some other games such as **RPGs** (**Role Playing
    Games**), there is no such thing as a level because it implies a certain cutoff
    with often no way back. Throughout the book, a space that can be saved as a single
    file in the Weltmeister will be referred to as a level.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计游戏时，您会想要创建发生一切的环境和地点。许多游戏被分成不同的关卡，通常每个关升级都会变得更加困难。对于一些其他游戏，比如**RPGs**（**角色扮演游戏**），并没有所谓的关卡，因为这意味着通常没有回头的可能。在整本书中，可以将一个空间保存为Weltmeister中的单个文件，称为一个关卡。
- en: 'The Weltmeister is literally the tool to master your world in ImpactJS. If
    you installed ImpactJS correctly you should be able to access the level editor
    shown in the next screenshot by placing the following address in your browser:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Weltmeister实际上是掌握ImpactJS世界的工具。如果您正确安装了ImpactJS，您应该能够通过在浏览器中输入以下地址来访问下一个截图中显示的关卡编辑器：
- en: '`http://localhost/myfirstawesomegame/weltmeister.html`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost/myfirstawesomegame/weltmeister.html`'
- en: '![Building your own levels](img/4568_2_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![创建自己的关卡](img/4568_2_1.jpg)'
- en: Creating, loading, and saving levels in Weltmeister
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Weltmeister中创建、加载和保存关卡
- en: Creating levels for a game is one of the most enjoyable things to do in game
    design. The Weltmeister is so well put together that you will spend hours messing
    around with it just because you can.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏创建关卡是游戏设计中最令人愉快的事情之一。Weltmeister的设计非常出色，您将花费数小时来玩弄它，只是因为您可以。
- en: On opening Weltmeister (by default), it starts with a clean slate; there is
    a vast amount of emptiness for you to fill. Soon we will get to building a level
    from scratch but for now we should load the `level1` level. Press the **Load**
    button in the top-right corner of your Weltmeister and select it in the `levels`
    folder. If you copied it in the beginning of the chapter it should be right there,
    otherwise copy it to the Weltmeister now.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Weltmeister（默认情况下），它会从一个干净的画布开始；有大量的空白等待您填充。很快我们将开始从头构建一个关卡，但现在我们应该加载`level1`关卡。按下Weltmeister右上角的**加载**按钮，并在`levels`文件夹中选择它。如果您在本章的开头复制了它，它应该就在那里，否则现在将其复制到Weltmeister中。
- en: '`Level1` is a rather original name for a first level but let''s personalize
    it a bit by saving it as `myfirstepiclevel`. Press the **Save As** button in the
    top-right corner and save it in the same directory. Now we have a copy to work
    on and mess around with.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Level1`是一个相当原创的第一关的名字，但让我们通过将其保存为`myfirstepiclevel`来个性化一下。按下右上角的**另存为**按钮，并将其保存在相同的目录中。现在我们有一个副本可以使用和玩弄了。'
- en: 'Before we actually use the level called `myfirstepiclevel`, we will need to
    make a change in the `main.js` script''s code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际使用名为`myfirstepiclevel`的关卡之前，我们需要在`main.js`脚本的代码中进行更改：
- en: Open the `main.js` script in your preferred script editor.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的脚本编辑器中打开`main.js`脚本。
- en: In the `main.js` script, you will see a call to the `loadLevel()` function.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`脚本中，您将看到对`loadLevel()`函数的调用。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This call is situated in the `init()` function of the game (`ig.game.init`).
    This means one of the first things the `main.js` script will do (at *initiation*,
    thus `init`) is load the level, `Level1`. Obviously, we don''t want that anymore,
    as we have our own level called `myfirstepiclevel` now. In order to let the game
    know that it has to include this level, you will need to add it to the `.requires()`
    function as shown in the following code lines:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用位于游戏的`init()`函数中（`ig.game.init`）。这意味着`main.js`脚本将在*初始化*（即`init`）时做的第一件事情之一是加载`Level1`关卡。显然，我们不再需要这样做了，因为现在我们有自己的关卡叫做`myfirstepiclevel`。为了让游戏知道它必须包含这个关卡，您需要将它添加到`.requires()`函数中，如下面的代码行所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, change the call to the `loadLevel()` function so it calls the level,
    `myfirstepiclevel`, instead of `Level1` as shown in the following snippet:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要更改对`loadLevel()`函数的调用，使其调用`myfirstepiclevel`关卡，而不是`Level1`，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'As you might have noticed, you always have to put the word `Level` before your
    actual level name. In addition you will always need to write both `Level` and
    your level name with a capital letter. Failure to comply with either of those
    will result in an epic crash at game load. Putting `Level` in front of the actual
    level name is a rather odd convention, especially since functions like `loadlevel()`
    are built to expect a level file. It is possible that this mandatory prefix is
    removed in the future versions of ImpactJS. But for now, failing to insert the
    word `Level` before your actual level name or writing both `Level` and your level
    name with a capital letter will result in the display of the following error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，您总是需要在实际级别名称之前加上`Level`一词。此外，您将始终需要用大写字母写`Level`和您的级别名称。如果违反其中任何一个，将导致游戏加载时发生严重崩溃。在实际级别名称之前加上`Level`一词是一个相当奇怪的约定，特别是因为`loadlevel()`等函数被设计为期望一个级别文件。可能在未来的ImpactJS版本中会删除这个强制前缀。但是目前，如果未在实际级别名称之前插入`Level`一词或者用大写字母写`Level`和您的级别名称，将导致显示以下错误：
- en: '![Creating, loading, and saving levels in Weltmeister](img/4568_2_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![在Weltmeister中创建、加载和保存级别](img/4568_2_2.jpg)'
- en: The other buttons in the Weltmeister are **Save**, **New**, and **Reload** **Images**.
    The **Save** button just saves the file you are working on, and the **New** button
    will open a new and empty file. The **Reload** **Images** button is a refresh
    button for your tilesets. The tilesets of a game are collections of images. All
    the graphics of a single theme can be on a single tileset, for example, the `outdoor`
    tileset. Because several images are stored in a single overall image called a
    tileset, it is easier to create your level while working in the Weltmeister. You
    can look at it as the color palette of an artist, but as a level creator you have
    as many palettes at your disposal as you have tilesets.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Weltmeister中的其他按钮有**保存**、**新建**和**重新加载图像**。**保存**按钮只是保存您正在处理的文件，**新建**按钮将打开一个新的空文件。**重新加载图像**按钮是瓷砖集的刷新按钮。游戏的瓷砖集是图像的集合。单个主题的所有图形可以在单个瓷砖集中，例如`outdoor`瓷砖集。因为几个图像存储在一个称为瓷砖集的整体图像中，所以在Weltmeister中工作时更容易创建您的级别。您可以将其视为艺术家的调色板，但作为级别创建者，您可以使用与瓷砖集一样多的调色板。
- en: 'Summing up everything we came across, we can conclude that:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总结我们所遇到的一切，我们可以得出结论：
- en: 'You can access the Weltmeister by typing the following address in your browser
    while your server is turned on: `localhost/myfirstawesomegame/weltmeister.html`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在服务器打开时在浏览器中输入以下地址访问Weltmeister：`localhost/myfirstawesomegame/weltmeister.html`
- en: Open `level1` by using the **Load** button
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**加载**按钮打开`level1`
- en: Save it again as `myfirstepiclevel` with the **Save As** button
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次保存为`myfirstepiclevel`，使用**另存为**按钮
- en: Include the new level in the `main.js` script by adding `myfirstepiclevel` to
    the `include()` function
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`myfirstepiclevel`添加到`include()`函数中，将新级别包含在`main.js`脚本中
- en: Layers and the z axis
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图层和z轴
- en: With the level opened, you can see the different elements and layers of which
    it is comprised. Let's first have a look at the **Layers** menu on the right-hand
    side of the editor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 打开层级后，您可以看到它包括的不同元素和层。让我们首先看一下编辑器右侧的**图层**菜单。
- en: Select the **collision** layer and you will see the standard properties that
    need to be filled out for a layer in order to exist. All layers (except for the
    **entities** layer) have a name, tileset, tilesize, dimensions, and distance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**碰撞**图层，您将看到需要填写的图层的标准属性。所有图层（除了**实体**图层）都有名称、瓷砖集、瓷砖大小、尺寸和距离。
- en: 'Tilesets are basically chains of square-formed images, which when put together
    well enough, form your idyllic looking landscape or scary dungeon. The tilesize
    is the width and height of one tile measured in pixels. Since all tiles are squares,
    you only need to fill out a number. The dimensions of a layer are the width and
    height of the entire map on which the layer needs to be present, measured in number
    of tiles. So a layer with a tilesize of 8, a width of 20, and a height of 30 is
    composed of 4800 (8 x 20 x 30) pixels. Take this into account while working with
    mobile devices. A level with a resolution of 160 (8 x 20) x 240 (8 x 30) will
    fit most devices. However, if the tilesize is 32 you will need a viewport that
    automatically follows your playable character in order to show off your level.
    This view-port is rather easy to incorporate and will be explained later in this
    chapter. To create a new tileset follow these steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 瓷砖集基本上是由方形图像链组成的，当组合得足够好时，形成您理想的风景或可怕的地牢。瓷砖大小是以像素为单位测量的一个瓷砖的宽度和高度。由于所有瓷砖都是正方形，您只需要填写一个数字。图层的尺寸是图层需要出现的整个地图的宽度和高度，以瓷砖数计量。因此，具有瓷砖大小为8、宽度为20和高度为30的图层由4800（8
    x 20 x 30）像素组成。在使用移动设备时要考虑这一点。分辨率为160（8 x 20）x 240（8 x 30）的级别将适合大多数设备。但是，如果瓷砖大小为32，您将需要一个自动跟随可玩角色的视口来展示您的级别。这个视口相当容易整合，将在本章后面进行解释。按照以下步骤创建一个新的瓷砖集：
- en: Try creating a new layer by clicking on the plus (**+**) sign at the top of
    the layer selection menu.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过单击图层选择菜单顶部的加号（**+**）号来创建一个新图层。
- en: Type in a name for the layer; let's say `astonishinglayer` or `tree`, whatever
    you like.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为图层输入一个名称；比如`astonishinglayer`或`tree`，随便你喜欢什么。
- en: Now select the tree tileset from the `media` folder by clicking the empty box
    next to the **Tileset** field. If you can't reach it by using the Weltmeister
    menu, you just type `media/Tree.png` in the tileset box. Set the tilesize to `32`
    and the dimensions to `30 x 20` (width x height). You can see the border of your
    layer change accordingly.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从`media`文件夹中选择`tree`瓷砖集，方法是点击**瓷砖集**字段旁边的空框。如果无法通过Weltmeister菜单访问，只需在瓷砖集框中输入`media/Tree.png`。将瓷砖大小设置为`32`，尺寸设置为`30
    x 20`（宽度 x 高度）。您可以看到图层边界相应地改变。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a common mistake to have one layer smaller than the other and then not
    be able to add objects on one part of your map. So let's say you intend your level
    to be a map with dimensions of 30 x 20 and a tilesize of 32, and you add a layer
    like this, and fill it with grass. You want to add a bench on the grass so you
    add another layer and make the dimensions 30 x 20\. Because your bench is a 32
    x 16 image, you set the tilesize to 16\. If you do this you will be able to draw
    your bench quite accurately but only in the top-left corner of your level. You
    will need to change the dimensions to 60 x 40 in order to occupy the same space
    as the grass layer does.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是一个层比另一个层小，然后无法在地图的某个部分添加对象。所以假设你的级别意图是一个尺寸为30 x 20，瓷砖大小为32的地图，然后你添加了一个这样的层，并用草填充它。你想在草地上添加一个长凳，所以你添加了另一个层，并将尺寸设置为30
    x 20。因为你的长凳是一个32 x 16的图像，你将瓷砖大小设置为16。如果你这样做，你将能够相当精确地绘制你的长凳，但只能在你的级别的左上角。你需要将尺寸改为60
    x 40，以便占据与草层相同的空间。
- en: Distance is the speed at which the layer moves relative to your game's screen
    position. A value of `1` in the **Distance:** field means it moves at an equal
    speed, whereas the value `2` means the layer moves at half the speed. By setting
    this parameter higher than `1`, it becomes possible to make things appear further
    away; this is ideal for your nice cloudy background in a side scrolling (or parallax)
    game, such as Mario. Go to your game and walk your character from the far left
    edge of the game towards the right boundary to observe the effect of altering
    the value of the **Distance:** field.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 距离是层相对于游戏屏幕位置移动的速度。在“距离”字段中的值为1意味着它以相同的速度移动，而值为2意味着层移动速度减半。通过将此参数设置为大于1，可以使事物看起来更远；这对于侧向滚动（或视差）游戏中的漂亮多云背景非常理想，比如马里奥。前往游戏，让你的角色从游戏的最左边向右边走，观察“距离”字段值的改变对效果的影响。
- en: Now return to the Weltmeister and try setting the value of the **Distance:**
    field to `2`. Save and reload the game, run your character from one edge to another
    edge of the level, and see what happens. Part of the game will appear to move
    slower than the rest. This is useful in side scroller games as a background, but
    it is also used in top-down games to create the impression of a terrifying abyss.
    Underneath, you have the options **Is Collision Layer**, **Pre-Render in Game**,
    **Repeat**, and **Link with Collision**. Turning them on and off can be done by
    clicking on the white squares (which turn black to indicate the option is switched
    off).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回到Weltmeister，尝试将“距离”字段的值设置为2。保存并重新加载游戏，让你的角色从级别的一边跑到另一边，看看会发生什么。游戏的一部分将看起来比其他部分移动得更慢。这在侧向滚动游戏中作为背景很有用，但也用于顶部游戏中创建恐怖深渊的印象。在下面，你有“是否碰撞层”、“游戏中预渲染”、“重复”和“与碰撞链接”的选项。通过点击白色方块（变黑表示选项已关闭）可以打开或关闭它们。
- en: The **Is collision layer** option will tell the level editor that the objects
    in the layer you are drawing are impenetrable. Pre-rendering a layer will cause
    the game to cluster tiles while loading. This will increase the initial load time
    but decrease the number of draws the game requires and, thus, increase performance
    while running.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “是否碰撞层”选项将告诉关卡编辑器，你正在绘制的层中的对象是不可穿透的。预渲染一个层会导致游戏在加载时对图块进行聚类。这将增加初始加载时间，但减少游戏所需的绘制次数，从而提高运行性能。
- en: The **Repeat** option is used for background layers. For example, your background
    clouds can be repeated over and over again if they are a pattern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “重复”选项用于背景层。例如，如果你的背景云是一个图案，可以重复出现。
- en: Finally the **Link with Collision** option will make sure that, for every object
    you draw, collision squares are added to the **collision** layer. You can delete
    them from the **collision** layer later on, but it is a useful tool to speed up
    the drawing of walls and other impassable terrain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，“与碰撞链接”选项将确保对于你绘制的每个对象，碰撞方块都会添加到“碰撞”层。你可以稍后从“碰撞”层中删除它们，但这是一个加快绘制墙壁和其他不可通过地形的有用工具。
- en: Layers can be rearranged within the **Layers** menu by dragging them up or down
    the list. By dragging a layer to the top or down to the bottom of the list, you
    define its place on the z axis. You should look at the z axis as the level's third
    dimension, just as the world we live in has an x axis (width), a y axis (height),
    and a z axis (depth). The game you build is not really 3D in the conventional
    sense, but since the 2D graphics are layers stacked on top of one another, there
    is an actual third dimension at work here. The graphical layer at the top of the
    list will always be visible and will even hide entities. The bottom layer can
    only be visible when nothing else is on the way. The **collision** layer is never
    visible but dragging it to the top will enable you to make modifications to it
    more easily.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在“层”菜单中可以通过将它们拖动到列表中的上方或下方来重新排列层。通过将一个层拖到列表的顶部或底部，你可以定义它在z轴上的位置。你应该把z轴看作级别的第三维，就像我们生活的世界有一个x轴（宽度），一个y轴（高度）和一个z轴（深度）。你构建的游戏并不是传统意义上的3D，但由于2D图形是叠加在一起的层，这里实际上有一个第三维在起作用。列表顶部的图形层将始终可见，甚至会隐藏实体。底层只有在没有其他东西挡住时才能可见。“碰撞”层永远不可见，但将其拖到顶部将使你更容易对其进行修改。
- en: Try rearranging the layers and check out what happens. Save your game and reload.
    Depending on what crazy stuff you did with the layers, the world is now a very
    different place indeed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重新排列层，看看会发生什么。保存游戏并重新加载。根据你对层做了什么疯狂的事情，世界现在确实是一个非常不同的地方。
- en: Instead of dragging a layer to the top of the stack in order to be able to view
    it, you can also turn layers on and off. This is done by clicking on the square
    in front of the layer name. This will not have any effect in the actual game;
    it is visible only in Weltmeister. This is very useful for the **collision** layer.
    Try dragging the **collision** layer to the top of the stack and turn it on and
    off at your will. You will notice that this is the best place for the **collision**
    layer to be while working with the Weltmeister. This is because the **collision**
    layer itself doesn't actually have graphics while playing the game, so it can't
    obscure anything else.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将一个图层拖到堆栈的顶部以便能够查看它，你也可以打开和关闭图层。这是通过点击图层名称前面的方框来实现的。这在实际游戏中不会产生任何影响；它只在Weltmeister中可见。这对于**碰撞**图层非常有用。尝试将**碰撞**图层拖到堆栈的顶部，然后随意打开和关闭它。你会注意到这是在使用Weltmeister时**碰撞**图层的最佳位置。这是因为**碰撞**图层本身在玩游戏时实际上没有图形，所以它不会遮挡其他任何东西。
- en: '![Layers and the z axis](img/4568_2_3.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图层和z轴](img/4568_2_3.jpg)'
- en: 'Summing up the details we came across, we conclude that:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 总结我们遇到的细节，我们得出结论：
- en: A level is made up of different layers with properties such as tilesize, distance,
    and whether it is a **collision** layer
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关卡由具有诸如图块大小、距离以及是否为**collision**图层等属性的不同图层组成
- en: Add a new layer using the (**+**) sign in the **Layers** menu and give it the
    name `astonishinglayer`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Layers**菜单中的（**+**）号添加一个新图层，并将其命名为`astonishinglayer`
- en: Add a tileset `media/tree.png` to the layer. Set its dimension to `30 x 20`
    and its tilesize to `32`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图块集`media/tree.png`添加到图层中。将其尺寸设置为`30 x 20`，将其图块大小设置为`32`
- en: Try messing around with all the properties you can find on the layer including
    dragging the layer up or down
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试玩弄图层上的所有属性，包括将图层上下拖动
- en: Save the level and reload your game in the browser every time you adjust a parameter
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调整参数后，保存关卡并在浏览器中重新加载游戏
- en: Adding and removing entities and objects
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和移除实体和物体
- en: 'There are three big types of layers: **entities**, **collision**, and any other
    layer. For entities and dead objects, the entities and graphical layers are of
    interest.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种大类型的图层：**entities**，**collision**，和其他任何图层。对于实体和死物体，实体和图形图层是感兴趣的。
- en: The **entities** layer holds all the entities that are present in the `entity`
    folder and are called upon by the `main.js` script. An entity can be anything,
    from the character the player uses, to an invisible trap that kills everything
    that dares to come close. All functionalities and the level's AI are in these
    entities. It can hold enemies, triggers, level changes, randomly flying objects,
    fireable projectiles, and everything that can be interacted with.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**entities**图层包含了`entity`文件夹中存在的并由`main.js`脚本调用的所有实体。实体可以是任何东西，从玩家使用的角色到一个会杀死靠近的一切的隐形陷阱。所有功能和关卡的人工智能都在这些实体中。它可以包含敌人、触发器、关卡变化、随机飞行物体、可发射的抛射物，以及所有可以互动的东西。'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have critical bugs in these entities or some non-existing ones are included
    in your `main.js` script, the Weltmeister will not even load. So make sure at
    all times that these entities are bug-free (or not included) when you want to
    build a level.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些实体中存在关键错误，或者在你的`main.js`脚本中包含了一些不存在的实体，Weltmeister甚至无法加载。因此，确保这些实体在你想要构建关卡时始终没有错误（或者没有包含）。
- en: Some entities, such as the player, are already present in the level. First select
    the **entities** layer in the **Layers** menu and then select the player entity
    in order to see its properties. The **x:** and **y:** properties are its current
    location and are always present while putting a new entity in the level.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实体，比如玩家，已经存在于关卡中。首先在**Layers**菜单中选择**entities**图层，然后选择玩家实体以查看其属性。**x:**和**y:**属性是它当前的位置，并且在将新实体放入关卡时始终存在。
- en: Try moving the player entity around by selecting him and dragging him somewhere
    else. The **x:** and **y:** coordinates now change.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择玩家并将其拖动到其他位置来尝试移动玩家实体。**x:**和**y:**坐标现在会改变。
- en: Let's add an **enemy** entity to the level. Select the **entities** layer and
    press the Space bar while your mouse hovers over the level. A menu will appear
    next to your mouse; select the **enemy** entity in this menu. An enemy just appeared
    at your mouse's location! You will now be able to go crazy and basically paint
    every square with enemy entities, but this might be a little bit of overkill,
    so let's just place one enemy for now. Save and reload your game. Now tremble
    in fear as your enemy attacks you or stare at it unimpressed, your choice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在关卡中添加一个**敌人**实体。选择**entities**图层，并在鼠标悬停在关卡上时按下空格键。一个菜单将出现在鼠标旁边；在这个菜单中选择**敌人**实体。一个敌人刚刚出现在你鼠标的位置！现在你可以疯狂地在每个方块上画上敌人实体，但这可能有点过火，所以让我们现在只放一个敌人。保存并重新加载你的游戏。现在，当敌人攻击你或者无动于衷地盯着它时，你会感到恐惧，这取决于你。
- en: If you added too many enemies to safely roam about, remove them from the game
    by first selecting the **entities** layer in Weltmeister, then the enemies you
    want to get rid of and simply press the *Delete* key.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了太多的敌人以至于无法安全地漫游，首先在Weltmeister中选择**entities**图层，然后选择你想要摆脱的敌人，然后简单地按下*Delete*键将它们从游戏中移除。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's a good habit to have both the game and the Weltmeister open to check the
    changes you made. If, for some reason, an entity you added is corrupt and the
    game refuses to load, at least you know the problem lies in the last changes that
    you made. Of course, you still have the Chrome or Firefox debuggers that will
    also point you in the right direction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏和Weltmeister都打开以检查你所做的更改是一个好习惯。如果由于某种原因，你添加的实体是损坏的，游戏拒绝加载，至少你知道问题出在你最后做的更改上。当然，你还有Chrome或Firefox的调试器，它们也会指引你走向正确的方向。
- en: Adding objects is different from adding entities. Dead objects, which cannot
    be interacted with but are just a graphical thing, can simply be painted, for
    example, a square patch of grass, a fountain, or a castle wall. Complex interactions
    with these objects can be done but only with the use of entities. Here we will
    have a look at how to add a simple object, without interaction, to a level.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对象与添加实体不同。死对象，不能与之交互，只是一个图形的东西，可以简单地涂抹，例如，一块草地、一个喷泉或一堵城墙。这些对象的复杂交互可以完成，但只能通过实体来实现。在这里，我们将看看如何向关卡添加一个简单的对象，没有交互。
- en: Although the level looks pretty neat, we will need to give it a makeover. Let's
    select the grass layer from the **Layers** menu. Hover your mouse over the map
    and press the Space bar key. A tileset will appear; you can make it disappear
    by tapping the Space bar key again. If this tileset does not fit your screen you
    can either hover your mouse to a more central location and bring it up there or
    zoom out with the scroll wheel of your mouse. If you do not have a scroll wheel,
    you can use the *Ctrl* + *-* (minus) key combination to zoom out and the *Ctrl*
    key with the plus sign key (*+*) to zoom back in. Now you can see your entire
    grass tileset. Select the grass and start painting it everywhere by clicking and
    holding the left mouse button.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关卡看起来相当整洁，但我们需要对其进行改头换面。让我们从**图层**菜单中选择草地图层。将鼠标悬停在地图上，按下空格键。一个图块集将出现；你可以通过再次按下空格键使其消失。如果这个图块集不适合你的屏幕，你可以将鼠标悬停在更中心的位置并在那里打开它，或者使用鼠标滚轮缩小。如果你没有滚轮，你可以使用*Ctrl*
    + *-*（减号）组合键缩小，使用*Ctrl*键和加号键（*+*）放大。现在你可以看到整个草地图块集。选择草地，通过点击并按住鼠标左键在所有地方涂抹。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A little trick for painting large areas with a single tile is to first paint
    only a small area on the map. Then click on the *Shift* + left mouse button and
    select this freshly drawn bigger area of tiles from the level itself. You can
    now paint with this new selection of tiles and cover more area in less time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用单个图块涂抹大面积的小技巧是，首先只在地图上涂抹一个小区域。然后点击*Shift* +鼠标左键，选择来自关卡本身的这个新绘制的更大的图块区域。现在你可以用这个新选择的图块涂抹，以更少的时间覆盖更大的区域。
- en: If you want to delete something from a given layer, simply select an empty square
    that is empty for that particular layer. If you already have graphics from other
    layers on a certain spot, but not from the layer you are currently working on,
    that square can be considered empty. Now paint with this empty square and the
    formerly chosen tiles will magically disappear. Try deleting some of your grass
    now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从给定的图层中删除某些东西，只需选择该特定图层中的一个空方块。如果你已经在某个位置有其他图层的图形，但不是你当前正在操作的图层，那个方块可以被视为空的。现在用这个空方块涂抹，先前选择的图块将神奇地消失。现在试着删除一些草地。
- en: Grass is at the bottom of everything. If you have an object, any object, it
    will always be on top of the grass, never underneath (except maybe in some crazy
    mole world). To make it so, you must drag your grass layer to the bottom of the
    layer stack.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 草地位于一切的底部。如果你有一个对象，任何对象，它总是在草地的上面，从来不在下面（除非在一些疯狂的鼹鼠世界）。为了实现这一点，你必须将你的草地图层拖到图层堆栈的底部。
- en: Let's add something else to the scene. We still have the layer that we created,
    `astonishinglayer`, ready to go, so let's draw a tree with it. In order to select
    the entire tree at once, select the tree by clicking on the *Shift* + left mouse
    button key combination. Depending on where you have put your layer, the tree will
    now always appear either in front of or behind the player. If you dragged the
    layer to the bottom of the list, it might even be invisible. It's a strange result
    and we will deal with this later. Save your level and reload to check out your
    first level creativity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在场景中添加一些其他东西。我们还有我们创建的图层`astonishinglayer`，准备好了，所以让我们用它画一棵树。为了一次性选择整棵树，通过点击*Shift*
    +鼠标左键组合键选择树。根据你放置图层的位置，树现在将始终出现在玩家的前面或后面。如果你将图层拖到列表的底部，甚至可能看不见。这是一个奇怪的结果，我们稍后会处理。保存你的关卡并重新加载，查看你的第一个关卡创意。
- en: '![Adding and removing entities and objects](img/4568_2_4.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![添加和删除实体和对象](img/4568_2_4.jpg)'
- en: 'Summing up the process of adding and removing entities and objects, we conclude
    that:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总结添加和删除实体和对象的过程，我们得出结论：
- en: The entity layer provides the choice of all your game entities
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体图层提供了所有游戏实体的选择
- en: You can add some of the present entities to the level, and then save and reload
    the game
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将一些当前的实体添加到关卡中，然后保存并重新加载游戏
- en: The collision layer
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞图层
- en: The **collision** layer is a special layer that is not predefined when you open
    the Weltmeister from scratch. It is special because it is an invisible layer that
    marks impassable areas. For example, if you draw a wall on your map by using a
    graphical layer, all your entities will be able to go right through it as if it
    isn't even there. If you want a wall that is actually capable of stopping the
    player and his enemies, draw a line in the **collision** layer where the wall
    is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞**图层是一个特殊的图层，在你从头开始打开Weltmeister时并不是预定义的。它是特殊的，因为它是一个不可见的图层，标记着不可通过的区域。例如，如果你通过使用图形图层在地图上画一堵墙，所有的实体都可以穿过它，就好像它根本不存在一样。如果你想要一堵真正能够阻止玩家和他的敌人的墙，就在**碰撞**图层上画一条线。'
- en: Your game is still open; try drawing a wall (or any other object) and then running
    through it at the bottom of the level. You should find it peculiarly easy to just
    stroll through something that looks this solid. Select the **collision** layer,
    drag it to the top of the list if it isn't already done and make sure it's **visibility**
    option is turned on. All tiles are now clearly visible and as you can see, there
    are none at the bottom wall. Hover your mouse over the level's canvas and press
    the Space bar in order to bring up the collision tileset. Select a square and
    draw a line where the wall is. Deleting collision blocks is just like deleting
    graphics. Select an area on the map (with or without holding the *Shift* key)
    where no collision blocks are present and use this selection to delete the ones
    that are present. Save the level and reload the game. Now try walking through
    the wall again; it has become quite impossible; hurray for that!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏还在打开；尝试画一堵墙（或者其他任何物体），然后在层次的底部穿过它。你会发现很容易穿过看起来很坚固的东西。选择**collision**图层，如果还没有完成，将其拖到列表的顶部，并确保其**visibility**选项已打开。现在所有的瓷砖都清晰可见，你会发现底部墙上没有瓷砖。将鼠标悬停在层次的画布上，按空格键以打开碰撞瓷砖集。选择一个方块，在墙上画一条线。删除碰撞块就像删除图形一样。选择地图上的一个区域（按住*Shift*键或不按住）没有碰撞块，并使用这个选择来删除那些存在的碰撞块。保存层次并重新加载游戏。现在再试着穿过墙；这已经变得相当不可能了；为此欢呼！
- en: 'Summing up the previous process:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的过程：
- en: Select the **collision** layer in the Welmeister
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Weltmeister中选择**collision**图层
- en: Draw some tiles with it
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用它画一些瓷砖
- en: Save and reload the game to see what happens if you want to walk where you drew
    the collision tiles
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存并重新加载游戏，看看如果你想走到你画的碰撞瓷砖的地方会发生什么
- en: Connecting two different levels
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接两个不同的层次
- en: Now that we have a sense of how to build a level by adding some graphics such
    as grass, trees, a player, and some enemies, it is time to have a look at how
    levels get connected.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何通过添加一些图形，比如草地、树木、玩家和一些敌人来构建一个层次，是时候看看层次是如何连接的了。
- en: For this, load the inside level into the Weltmeister. The inside level is situated
    inside a building (didn't see that coming, did you?). As we had to do with `myfirstepiclevel`,
    we need to change the call to the `loadlevel()` function in the `main.js` script,
    as shown in the next code snippet. This time, however, the level itself is already
    included in the `main.require` script.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，将内部层次加载到Weltmeister中。内部层次位于建筑物内部（你没想到这一点，是吧？）。就像我们对`myfirstepiclevel`所做的那样，我们需要在`main.js`脚本中更改对`loadlevel()`函数的调用，如下面的代码片段所示。然而，这次，层次本身已经包含在`main.require`脚本中。
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, don't forget the capital letters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，不要忘记大写字母。
- en: Load both the Weltmeister and the game itself to see if everything has been
    set up correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 加载Weltmeister和游戏本身，看看是否一切都设置正确了。
- en: 'In the Weltmeister, have a look at the level''s entities by selecting the **entities**
    layer. If you can''t get a good view on the entities present in the map, feel
    free to turn off the other layers by clicking on their white square. Alternatively
    you can press the Space bar while hovering over the map to bring up the entities
    selection menu. As always, we have a player entity so we can move around the place,
    but in the menu you should notice some extra entities such as **Void**, **Trigger**,
    and **Levelchange**:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Weltmeister中，通过选择**entities**图层查看层次的实体。如果你无法清楚地看到地图中存在的实体，请随意关闭其他图层，方法是点击它们的白色方块。或者你可以在悬停在地图上时按空格键，以打开实体选择菜单。和往常一样，我们有一个玩家实体，所以我们可以在地方四处移动，但是在菜单中，你应该注意到一些额外的实体，比如**Void**，**Trigger**和**Levelchange**：
- en: The **Void** entity is a rather simple one; it is nothing but a box with a name
    and some coordinates
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Void**实体是一个相当简单的实体；它只是一个带有名称和一些坐标的盒子'
- en: The **Trigger** entity will trigger the code of any other entity to which it
    is linked if a certain type of entity (such as the player) collides with it
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trigger**实体将在特定类型的实体（如玩家）与其碰撞时触发与其链接的任何其他实体的代码。'
- en: The **LevelChange** entity will make the game load another level
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LevelChange**实体将使游戏加载另一个层次'
- en: 'By intelligently combining these three entities you can connect levels, so
    let''s do just that:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过巧妙地组合这三个实体，你可以连接层次，所以让我们来做吧：
- en: Make sure the **entities** layer is one of the top ones, so you can see what
    you add.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**entities**图层是顶部之一，这样你就可以看到你添加的东西。
- en: Start by selecting the **Trigger** entity and place it on the map near the door.
    It will be nothing but a small square at first, so make it a bit bigger so as
    to fit the exit. You do this by selecting the box, moving your mouse to one of
    its edges until you see a double arrow (double arrow symbol), and dragging it
    to make it bigger (the same way you would resize any window object on your PC).
    In choosing your size, your goal is to detect the player when he wants to use
    the door to get out.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先选择**Trigger**实体，并将其放在靠近门的地图上。一开始它只是一个小方块，所以把它做得大一点，以适应出口。你可以通过选择方框，将鼠标移动到其边缘，直到看到双箭头（双箭头符号），然后拖动它使其变大（就像你在PC上调整任何窗口对象的大小一样）。在选择大小时，你的目标是在玩家想要使用门出去时检测到他。
- en: Now add a **Levelchange** entity. If you select the **Levelchange** entity,
    you will see its properties on the right-hand side. For now, this is just its
    location on the map (x and y coordinates) and its dimensions, in case you reshaped
    the box. Give the **Levelchange** entity a name by typing `name` in the key box
    and **ToOutside** as its value. Press the *Enter* key to confirm. Now you will
    see that the entity has an extra attribute (a name) with the value of **ToOutside**.
    Only by giving it a name can it be uniquely identified and that's what we need.
    We also need to tell him what level is needed to be loaded. Add the key **level**
    with a value **outside** and press the *Enter* key.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个**Levelchange**实体。如果选择**Levelchange**实体，您将在右侧看到其属性。目前，这只是地图上的位置（x和y坐标）和其尺寸，以防您重新调整了框的形状。通过在键框中输入`name`，为**Levelchange**实体命名为**ToOutside**。按*Enter*键确认。现在您将看到该实体具有额外的属性（名称），其值为**ToOutside**。只有通过给它一个名称，它才能被唯一标识，这就是我们需要的。我们还需要告诉它需要加载哪个关卡。添加键**level**，值为**outside**，然后按*Enter*键。
- en: The **Trigger** and **Levelchange** entities are now both in the level but they
    are unaware of each other's existence yet; that's pretty important if we want
    them to cooperate.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Trigger**和**Levelchange**实体现在都在关卡中，但它们尚不知道彼此的存在；如果我们希望它们合作，这一点非常重要。'
- en: Return to the trigger entity and give it a target. You do this by typing `target.1`
    as a key and **ToOutside** as a value. Notice the dot (`.`) after the word `target`;
    without it, it will not work. Now press the *Enter* key and watch as the two pretty
    squares get linked to each other by a white line as shown in the next figure.
    The **Trigger** entity now knows it is the **Levelchange** entity; it will have
    to trigger when touched by a player.![Connecting two different levels](img/4568_2_5.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到触发器实体并给它一个目标。您可以通过在键框中输入`target.1`，值为**ToOutside**来实现。注意单词`target`后面的句点（`.`）；没有它，它将无法工作。现在按*Enter*键，看着两个漂亮的方块如何通过一条白线连接在一起，如下图所示。**Trigger**实体现在知道它是**Levelchange**实体；当玩家触摸到它时，它将被触发。![连接两个不同的关卡](img/4568_2_5.jpg)
- en: Save this and load the level. Walk your player towards the trigger location;
    the location of your **Levelchange** entity is irrelevant. If everything goes
    well, you should now be able to move to the next level by walking up to the door!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并加载关卡。将您的玩家走向触发器位置；**Levelchange**实体的位置是无关紧要的。如果一切顺利，现在您应该能够通过走向门来进入下一个关卡！
- en: Strangely enough, when you enter the outside world, you are not placed next
    to the building. That is simply odd, even for a video game. Also, there is no
    way to go back inside when reaching for the door, you are stuck outside forever,
    or until you reload.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，当您进入外部世界时，并没有被放置在建筑物旁边。即使对于一个视频游戏来说，这也太奇怪了。此外，当试图打开门时，没有办法回到室内，您将永远被困在外面，除非重新加载。
- en: This is because no **spawnpoint**, **Trigger**, or **Levelchange** entities
    were added to the outside level. We will make up for that, but let's first add
    a spawn-point to the inside level.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在外部关卡中没有添加**spawnpoint**、**Trigger**或**Levelchange**实体。我们将弥补这一点，但首先让我们在内部关卡中添加一个出生点。
- en: To do this we will need the **Void** entity. Add the **Void** entity to the
    level and put it in front of the door, but past the trigger. Putting it too close
    to (or on top of) the trigger will cause the player to be zapped back outside.
    Although it's fun to make an eternal loop that zaps the player back and forth
    between levels, eternal loops (like dividing by zero) have a chance of destroying
    the world. Name the **Void** entity `insideSpawn`. Select the **Levelchange**
    entity and add the key **spawn** with value **OutsideSpawn**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要**Void**实体。将**Void**实体添加到关卡中，并将其放在门前，但是超过触发器。将其放得太靠近（或者在上面）触发器会导致玩家被击退到外面。虽然制作一个永恒的循环，让玩家在关卡之间来回击退是很有趣的，但是永恒的循环（就像除以零一样）有可能摧毁世界。将**Void**实体命名为`insideSpawn`。选择**Levelchange**实体并添加键**spawn**，值为**OutsideSpawn**。
- en: '![Connecting two different levels](img/4568_2_6.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![连接两个不同的关卡](img/4568_2_6.jpg)'
- en: We are done with the inside level but now need to set up the outside level as
    its mirror opposite. So again, add a **Void**, **Levelchange**, and **Trigger**
    entity. Name the **Void** entity `OutsideDoor` since the **Levelchange** entity
    will look for this. Name the **Levelchange** entity `ToInside` and target the
    trigger to it. Also add the **Level** and **spawn** properties to the **Levelchange**
    entity. The values for these are (as you probably guessed) **Inside** for the
    **Level** property and **InsideDoor** for the **spawn** property.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了内部关卡，现在需要将外部关卡设置为其镜像相反。因此，再次添加**Void**、**Levelchange**和**Trigger**实体。将**Void**实体命名为`OutsideDoor`，因为**Levelchange**实体将寻找它。将**Levelchange**实体命名为`ToInside`，并将触发器指向它。还要向**Levelchange**实体添加**Level**和**spawn**属性。这些属性的值分别为**Inside**和**InsideDoor**。
- en: '![Connecting two different levels](img/4568_2_7.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![连接两个不同的关卡](img/4568_2_7.jpg)'
- en: Save and reload the game. If everything goes well you should now be able to
    move between both levels like a real pro.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重新加载游戏。如果一切顺利，您现在应该能够像专业人士一样在两个关卡之间移动。
- en: 'Summing up the complete process of connecting two levels:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 总结连接两个关卡的完整过程：
- en: Load the level inside in the Weltmeister
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Weltmeister中加载内部关卡
- en: Add three entities to the level, **Trigger**, **Levelchange**, and **Void**
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向关卡中添加三个实体，**Trigger**、**Levelchange**和**Void**
- en: Give every entity a name
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给每个实体命名
- en: Make the trigger point to the **Levelchange** entity
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使触发器指向**Levelchange**实体
- en: 'Add this information to the **Levelchange** entity: the level it needs to load
    and the spawnpoint it will have to use'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些信息添加到**Levelchange**实体中：它需要加载的关卡和它将要使用的出生点
- en: Save inside, load the level outside, and repeat the exercise there
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存内部关卡，加载外部关卡，并在那里重复练习
- en: Make sure both levels are saved and reload the game in the browser
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保两个关卡都已保存并在浏览器中重新加载游戏
- en: Objects – playable and non-playable characters
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象-可玩和不可玩角色
- en: 'Now that we have had a look at how to build a level, it is time to zoom into
    the code behind the entities we have been playing with. Though there is no official
    classification, things can be simplified by distinguishing three types of entities:
    dead objects, non-playable characters, and the player entity itself. These three
    types of entities are ordered in rising level of complexity and interactivity.
    In the first part of this chapter we took a look at the graphical layers of a
    game. Pure graphics have no element of interactivity at all; they are just present
    as stable elements. To get a bit of feedback from the game you are playing (building),
    you need entities. The least complex of these entities are the dead objects, which
    have no artificial intelligence whatsoever but can be interacted with, for example,
    pick-up items such as coins and potions. A type of entity we have already investigated
    is the **Trigger** entity, which itself is invisible but can be placed in the
    same level as graphics and can indicate what will happen further in the game.
    The graphics of lava will not kill you. An entity carefully placed underneath
    the lava, which tells the game to destroy everything that enters that area, can
    certainly kill you. A little bit up the scale of complexity are the **NPC''s**
    (**non-playable characters**). These are your enemies, your friends, everything
    you as a player will kill or defend, or just ignore if you feel like. They can
    range from mindless zombies to complex and very calculated opponents such as a
    chess computer. The last and most complex entity of the game is you, or at least
    your avatar(s). The playable character is by far the most versatile one and well
    worth elaborating on later in this chapter. Before we do so, we will first have
    to take a look at what makes an ImpactJS entity what it is.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过如何构建一个级别，是时候深入研究我们一直在玩的实体背后的代码了。虽然没有官方分类，但可以通过区分三种类型的实体来简化事情：死亡对象、不可玩角色和玩家实体本身。这三种类型的实体按复杂性和互动性逐渐增加排序。在本章的第一部分，我们看了游戏的图形层。纯粹的图形根本没有任何互动元素；它们只是作为稳定的元素存在。要从你正在玩（构建）的游戏中得到一些反馈，你需要实体。这些实体中最简单的是死亡对象，它们根本没有任何人工智能，但可以进行交互，例如，可以拾取的物品，如硬币和药水。我们已经调查过的一种实体类型是**Trigger**实体，它本身是不可见的，但可以放置在与图形相同的级别，并且可以指示游戏中将会发生的事情。岩浆的图形不会杀死你。但是，精心放置在岩浆下面的实体会告诉游戏摧毁进入该区域的一切。在复杂性方面稍微上升的是**NPC**（**不可玩角色**）。这些是你的敌人，你的朋友，你作为玩家将杀死或保护的一切，或者如果你愿意的话，可以忽略。它们可以是毫无头脑的僵尸，也可以是复杂而非常精确的对手，比如国际象棋电脑。游戏中最后一个也是最复杂的实体就是你，或者至少是你的化身。可玩角色是迄今为止最多才多艺的角色，值得在本章后面进行详细阐述。在这样做之前，我们首先必须看一看是什么使ImpactJS实体成为它所是的。
- en: The ImpactJS entity
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImpactJS实体
- en: In order to explain the basics of entities, it is best to first have a look
    at the dead objects. These entities have no complex behavioral patterns like non-playable
    characters or the player, but are certainly more complex than plain graphics.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释实体的基础知识，最好先看一看死亡对象。这些实体没有像不可玩角色或玩家那样复杂的行为模式，但肯定比纯粹的图形复杂得多。
- en: 'An example of this is the **Void** entity, a good friend we encountered while
    setting up the level transition earlier in this chapter. Open the `void.js` file
    in your script editor so we can have a look at it. The following code snippet
    is an example of the **Void** entity:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是**Void**实体，我们在本章前面设置级别转换时遇到的一个好朋友。在脚本编辑器中打开`void.js`文件，这样我们就可以看一看。以下代码片段是**Void**实体的一个例子：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Every entity will at least call the `ig.module`, .`requires()`, and .`defines()`
    functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体至少会调用`ig.module`，`requires()`和`defines()`函数。
- en: In the `ig.module` function, you define the **Void** entity as a module. The
    `ig.module` function call defines the **Void** entity as a new module. The module
    name should be the same as the script's name. The `void.js` file put in the `entities`
    folder within the `game` folder becomes the `game.entities.void` file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ig.module`函数中，你将**Void**实体定义为一个模块。`ig.module`函数调用定义了**Void**实体作为一个新模块。模块名称应该与脚本的名称相同。放在`game`文件夹中的`entities`文件夹中的`void.js`文件将成为`game.entities.void`文件。
- en: The `requires()` function will call the code on which this entity depends. Like
    all entities, the void entity depends on the entity prototype code from the Impact
    Engine, hence the name `impact.entity`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires()`函数将调用此实体所依赖的代码。像所有实体一样，虚空实体依赖于Impact Engine中的实体原型代码，因此被命名为`impact.entity`。'
- en: 'The `defines()` function enables you to define what this specific module is
    all about. Take a look at what is inside the `defines()` function. We see the
    `EntityVoid` module being defined as an extension of the entity class as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`defines()`函数使你能够定义这个特定模块的全部内容。看一看`defines()`函数里面有什么。我们看到`EntityVoid`模块被定义为实体类的扩展，如下所示：'
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Always add `Entity` in front of the entity name and don''t forget the capital
    letters. Weltmeister will not like it if you don''t and you will get an error
    message saying that it is expecting an entity with a different name. The following
    error will be generated by Weltmeister:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体名称前始终添加“Entity”，不要忘记大写字母。如果你不这样做，Weltmeister就不会喜欢，你会收到一个错误消息，说它期望一个不同名称的实体。Weltmeister将生成以下错误：
- en: '![The ImpactJS entity](img/4568_2_8.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![ImpactJS实体](img/4568_2_8.jpg)'
- en: 'The **Void** entity is a special entity because it is invisible in the game;
    this is apparent from the fact that the code does not point to a certain image
    from the `media` folder. Instead it has three properties that apply to the Weltmeister:
    `_wmDrawBox`, `_wmBoxColor`, and `_wmScalable`. The `_wm` prefix property indicates
    they are important for the Weltmeister.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**Void**实体是一个特殊实体，因为它在游戏中是不可见的；这一点从代码并未指向`media`文件夹中的某个图像就可以看出。相反，它有三个属性适用于Weltmeister：`_wmDrawBox`，`_wmBoxColor`和`_wmScalable`。`_wm`前缀属性表明它们对Weltmeister很重要。'
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous code snippet tells Weltmeister that it has to draw a box when the
    entity is inserted into a level. By setting this property to `false`, the color
    from the `_wmBoxColor` property will not be applied.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个代码片段告诉Weltmeister在将实体插入到级别时必须绘制一个框。将此属性设置为`false`，则不会应用来自`_wmBoxColor`属性的颜色。
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code snippet defines the color of this box in an RGBA color scheme.
    For the **Void** entity, at present, the color is purple.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个代码片段定义了此框的颜色，采用RGBA颜色方案。对于**Void**实体，目前颜色是紫色。
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The previous code snippet will allow you to make the box bigger or smaller.
    This is especially useful for things such as the **Trigger** entity, which you
    probably turned into a small but fairly long rectangle when previously connecting
    the two levels.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个代码片段将允许您使框变大或变小。这对于像**Trigger**实体这样的事物特别有用，您可能在以前连接两个级别时将其转换为一个小但相当长的矩形。
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code snippet, the `size` property is the default size of the
    entity. Since this one is scalable, you can change it in the Weltmeister.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码片段中，`size`属性是实体的默认大小。由于这个实体是可伸缩的，您可以在Weltmeister中进行更改。
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally the `update()` function. Every entity calls this function once per frame,
    regardless of whether you explicitly mention the call to this function or not,
    as shown in the previous code snippet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`update()`函数。每个实体每帧调用一次此函数，无论您是否明确提到调用此函数，如前面的代码片段所示。
- en: Try changing the default parameters of the **Void** entity and reload the Weltmeister
    to see what happens.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改**Void**实体的默认参数并重新加载Weltmeister，看看会发生什么。
- en: The **Void** entity is a simple and useful one, but let's face it, it's rather
    boring too. Let's have a look at something more interesting, such as coins. Let's
    say you want your player to grow richer every time he or she picks up a coin.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Void**实体是一个简单而有用的实体，但让我们面对现实，它也相当无聊。让我们看看更有趣的东西，比如硬币。假设您希望玩家每次拾取硬币时都变得更加富有。'
- en: 'The following is a **Coin** entity example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个**Coin**实体示例：
- en: 'For this you will need a **Coin** entity, so let''s open the `coin.js` file
    in the editor. Similar to the **Void** entity, it has a name (coin), it requires
    the `impact.entity` library, is an extension of the prototype entity, and has
    a size. There are, however, some additional interesting properties in the following
    code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您将需要一个**Coin**实体，让我们在编辑器中打开`coin.js`文件。与**Void**实体类似，它有一个名称（coin），需要`impact.entity`库，是原型实体的扩展，并具有大小。然而，在以下代码中还有一些其他有趣的属性：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `type`, `collides`, and `checkAgainst` properties are all about the coin''s
    behavior regarding collision with other entities. The `type` parameter tells the
    game that a coin belongs to type `B` when it has to evaluate collision. The coin
    never actually collides with anything because its `collides` property is set to
    `NEVER`. Other possibilities here are: `LITE`, `PASSIVE`, `ACTIVE`, and `FIXED`.
    The `LITE` and `PASSIVE` entities don''t collide with each other. The `FIXED`
    entities cannot be moved and `LITE` entities can be moved by the `ACTIVE` entities.
    In case an `ACTIVE` entity collides with another `ACTIVE` or `PASSIVE` entity,
    both entities move.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`、`collides`和`checkAgainst`属性都与硬币在与其他实体碰撞时的行为有关。`type`参数告诉游戏硬币在评估碰撞时属于类型`B`。硬币实际上从不与任何东西发生碰撞，因为其`collides`属性设置为`NEVER`。这里的其他可能性是：`LITE`、`PASSIVE`、`ACTIVE`和`FIXED`。`LITE`和`PASSIVE`实体不会相互碰撞。`FIXED`实体无法移动，`LITE`实体可以被`ACTIVE`实体移动。如果`ACTIVE`实体与另一个`ACTIVE`或`PASSIVE`实体发生碰撞，则两个实体都会移动。'
- en: 'At first it sounds tricky but it is worth experimenting with. Open the `player.js`
    file and make sure the `collides` property is set to `ACTIVE`. Now add a coin
    to the game, close to the player''s starting point, using the Weltmeister. Put
    the `checkAgainst` property of the coin in comments by adding two dashes(`//`)
    as shown in the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 起初听起来有点棘手，但值得尝试。打开`player.js`文件，并确保`collides`属性设置为`ACTIVE`。现在使用Weltmeister在游戏中添加一个硬币，靠近玩家的起点。通过在下面的示例中添加两个破折号(`//`)将硬币的`checkAgainst`属性注释掉：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you set the mode of the **coin** entity to `FIXED` you will be unable to
    move the coin. When you set its mode to `PASSIVE` or `ACTIVE`, you can move the
    coin but it will be difficult because the coin pushes back. However, a **coin**
    entity set to the `LITE` property will be very easy to move about. Finally when
    the **coin** entity is set back to the property `NEVER`, the player goes straight
    through the coin as if it isn't there. We used the Weltmeister to add collision
    tiles to a wall; these tiles can be regarded as `FIXED` and thus will not be moved
    by an entity.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将**coin**实体的模式设置为`FIXED`，则无法移动硬币。当将其模式设置为`PASSIVE`或`ACTIVE`时，可以移动硬币，但会很困难，因为硬币会推回。然而，设置为`LITE`属性的**coin**实体将非常容易移动。最后，当**coin**实体重新设置为`NEVER`属性时，玩家会直接穿过硬币，就好像它不存在一样。我们使用Weltmeister向墙上添加碰撞瓦片；这些瓦片可以被视为`FIXED`，因此不会被实体移动。
- en: Remove the dashes from the `checkAgainst` property for it to work again because
    this tells the **coin** entity to check if an entity of type `A` touches it (the
    player entity is set to `A`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从`checkAgainst`属性中删除破折号，以使其再次起作用，因为这告诉**coin**实体检查类型为`A`的实体是否触碰它（玩家实体设置为`A`）。
- en: While the **Void** entity is visible, the coin has in-game graphics and they
    are in an **AnimationSheet** frame.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**Void**实体是可见的，但硬币具有游戏内图形，并且它们位于**AnimationSheet**帧中。
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `AnimationSheet` frame, however, is nothing but a 16-pixel square image,
    so it isn't really capable of real animation. For this you would need a single
    PNG file with at least two different images.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`AnimationSheet`帧实际上只是一个16像素的正方形图像，所以它并不能真正实现动画。为此，您需要一个至少包含两个不同图像的单个PNG文件。
- en: We can, however, replace this coin with the second one. Do this by changing
    `COIN.png` to `COIN2.png` (save and reload).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以用第二个硬币替换这个硬币。通过将`COIN.png`更改为`COIN2.png`（保存并重新加载）来实现这一点。
- en: The `init()` function of every entity will define their standard properties.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体的`init()`函数将定义它们的标准属性。
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since a **coin** entity doesn't have many properties, the `init()` method is
    rather empty.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**coin**实体没有太多属性，`init()`方法相当空。
- en: 'What we do have is a call to the parent entity, which in this case is just
    `entity`. The `this.addAnim()` function is an impact function capable of animating
    the coin. It has three inputs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了父实体，这里只是`entity`。`this.addAnim()`函数是一个能够为coin添加动画的impact函数。它有三个输入：
- en: The status of the entity (`idle`)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体的状态（`idle`）
- en: The speed between switching from one animation to another (`1` second)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个动画切换到另一个动画的速度（`1`秒）
- en: The images on the tileset it has to go through (image `0`)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须经过的图块集上的图像（图像`0`）
- en: Obviously since there is only one image, there is no real animation going on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，由于只有一张图片，实际上没有动画。
- en: 'The `check()` function is a very interesting method for every entity. The following
    example code explains the `check()` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`check()`函数是每个实体非常有趣的一个方法。以下示例代码解释了`check()`函数：'
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It checks whether there is an overlap with another entity and, if so, will do
    what is stated within the function. The `check()` method is tied to the `checkagainst`
    property; the only relevant overlap will be the ones with the type of entity stated
    there. In this case the `check()` function will go off when the player touches
    the coin. This will result in firing the function `ig.game.addCoin()` and then
    removing the coin from the game with the `this.kill()` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查是否与另一个实体重叠，如果是，将执行函数中规定的操作。`check()`方法与`checkagainst`属性相关联；唯一相关的重叠将是其中声明的实体类型。在这种情况下，当玩家触碰到coin时，`check()`函数将触发。这将导致触发`ig.game.addCoin()`函数，然后使用`this.kill()`函数将coin从游戏中移除。
- en: Dead objects are often very simple entities with just a few lines of code, non-playable
    characters with even a simple AI, and playable characters are a different ballgame
    altogether.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 死亡对象通常是非常简单的实体，只有几行代码，不可玩角色甚至有一个简单的AI，而可玩角色则完全是另一回事。
- en: 'Summing up the creation of playable and non-playable characters, we can conclude
    that:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 总结可玩和不可玩角色的创建，我们可以得出结论：
- en: Contrary to pure graphics, the ImpactJS entity is an interactive game element.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与纯粹的图形相反，ImpactJS实体是一个交互式游戏元素。
- en: Dead objects are the least complex entities; two examples of this are the **Void**
    and **coin** entities.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死亡对象是最不复杂的实体；**Void**和**coin**实体就是其中的两个例子。
- en: The **Void** entity is invisible in the game but is visible in the Weltmeister
    because of its special Weltmeister properties. We used it as a spawn-point previously
    in this chapter.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Void**实体在游戏中是不可见的，但在Weltmeister中是可见的，因为它具有特殊的Weltmeister属性。在本章的前面，我们曾将其用作生成点。'
- en: The **coin** entity is visible in the game because it has an animation sheet.
    It can also be picked up by a player because of collision detection.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**coin**实体在游戏中是可见的，因为它有一个动画表。它也可以被玩家捡起，因为有碰撞检测。'
- en: 'Collision detection can take on several forms: entities can kill, block, push
    away, or simply ignore each other depending on its collision properties.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测可以采用多种形式：实体可以杀死、阻挡、推开，或者根据其碰撞属性简单地忽略彼此。
- en: Try messing around with all the explained parameters in the **Void** and **coin**
    entities to see what happens.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试玩弄**Void**和**coin**实体中解释的所有参数，看看会发生什么。
- en: Setting up player controls
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置玩家控制
- en: Nothing is more interesting than the actual player and the enemies he or she
    sends to oblivion.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比实际玩家和他或她送入遗忘的敌人更有趣了。
- en: If you open the `player.js` and `enemy.js` files, you will see there is quite
    a lot to discuss about these entities. From animation over controls to sound effects
    and beyond, they are complex indeed. All these things will be gradually unraveled
    during the remaining pages of this chapter. But first things first, how does ImpactJS
    know the difference between a playable and non-playable character?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`player.js`和`enemy.js`文件，你会发现有很多关于这些实体需要讨论的内容。从动画到控制再到音效等等，它们确实很复杂。所有这些东西将在本章剩余的页面中逐渐揭示。但首先，ImpactJS如何区分可玩和不可玩的角色呢？
- en: The fact that you called an entity player does not automatically make it so;
    ImpactJS does not have a reserved name for this entity in order to recognize what
    can be controlled and what is not player-controlled. This would be very limiting
    indeed since **RTS** (**Real Time Strategy**) games depend on the capability of
    moving different playable objects at the same time. This means the only element
    that differentiates the two entities is whether they are controllable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你称一个实体为player并不会自动使其成为player；ImpactJS没有为这个实体保留名称，以识别什么可以被控制，什么不是由玩家控制的。这将非常有限，因为**RTS**（**实时战略**）游戏取决于同时移动不同可玩对象的能力。这意味着区分这两个实体的唯一元素是它们是否可控。
- en: 'Open the `player.js` file and scroll to the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`player.js`文件，滚动到以下代码：
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In here, we can see the player entity will react to input. When the input command
    `up` is given, the avatar will move upwards and show an animation. These `up`,
    `down`, `left`, and `right` states are not ImpactJS keywords. They are in fact
    defined in the main script. Open the `main.js` file and take a look at the following
    code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到玩家实体将对输入做出反应。当输入命令`up`时，角色将向上移动并显示动画。这些`up`，`down`，`left`和`right`状态不是ImpactJS的关键字。实际上，它们是在主脚本中定义的。打开`main.js`文件，看一下以下代码：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here you can see which key is being associated to which input state. Also notice
    the `if` statementbefore the key bindings. First a check is done on whether you
    are dealing with a mobile device or not. This is because keys, such as the Space
    bar and the directional arrow, do not exist on iPads and iPhones. Try binding
    the attack state to your left mouse button instead of the Space bar with the code
    snippet as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到哪个键与哪个输入状态相关联。还要注意键绑定之前的`if`语句。首先要检查的是你是否在处理移动设备。这是因为iPad和iPhone上不存在Space键和方向箭头等键。尝试将攻击状态绑定到鼠标左键，而不是Space键，代码片段如下：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All the possible combinations can be found on the ImpactJS website.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可能的组合都可以在ImpactJS网站上找到。
- en: Save and reload the game and notice how your trigger finger has moved from the
    Space bar to your left mouse button.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重新加载游戏，注意您的触发手指是如何从空格键移动到左鼠标按钮的。
- en: Notice how these initial key binding definitions are in the `init()` function
    of the `main.js` script while it is waiting for input in the `player.js` script
    within its update function. This is because the actual binding of keys needs to
    be done only once (at game initiation), while your player needs to be controlled
    at all times. The `update` function is called every time the game goes through
    a full game cycle, which is the same as your framerate. Let's assume you have
    a framerate of 60fps (60 frames per second); the update function will, in this
    case, check for user input 60 times per second.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些初始键绑定定义在`main.js`脚本的`init()`函数中，而在`player.js`脚本中的`update`函数中等待输入。这是因为实际的键绑定只需要在游戏初始化时进行一次，而您的玩家需要始终受控制。`update`函数在游戏经过完整的游戏循环时被调用，这与您的帧速率相同。假设您的帧速率为60fps（每秒60帧），在这种情况下，`update`函数将每秒检查用户输入60次。
- en: Things are a bit different when dealing with mobile devices. Since almost no
    keys are present, you will need to add artificial buttons by using HTML objects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 处理移动设备时情况有些不同。由于几乎没有按键，您需要使用HTML对象添加虚拟按钮。
- en: 'Open the `index.html` file and type the following code for adding artificial
    buttons:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`index.html`文件，并键入以下代码以添加虚拟按钮：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When loading an ImpactJS game into the browser, it is this page that is actually
    loaded and the game itself is only shown in a canvas element within the page.
    This means that next to this canvas element, other things can be added, such as
    HTML buttons. Since every button can be pressed with a touchpad, an unlimited
    number of interactive functionalities can be added to the game by the smart use
    of these buttons. You can find the following button definitions in the `index.html`
    file, as shown in the following HTML code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将ImpactJS游戏加载到浏览器时，实际加载的是这个页面，游戏本身只显示在页面内的canvas元素中。这意味着除了canvas元素之外，还可以添加其他东西，比如HTML按钮。由于每个按钮都可以用触摸板按下，通过巧妙使用这些按钮，可以为游戏添加无限数量的交互功能。您可以在`index.html`文件中找到以下按钮定义，如下所示的HTML代码：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The buttons are `<div>` elements in which `div` is the short form for division.
    The <`div`> elements are used together with CSS code to lay out a webpage. In
    this case they provide us with four arrows to press for choosing the direction.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是`<div>`元素，其中`div`是division的缩写。`<div>`元素与CSS代码一起用于布局网页。在这种情况下，它们为我们提供了四个箭头，用于选择方向。
- en: A `<div>` element has several attributes; among them, the `id` attribute is
    of particular interest to us since it uniquely identifies the `<div>` elements
    and enables us to link to the JavaScript code. This can be seen in the `bindTouch`
    method within the `main.js` script.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div>`元素有几个属性；其中，`id`属性对我们来说特别重要，因为它唯一标识了`<div>`元素，并使我们能够链接到JavaScript代码。这可以在`main.js`脚本中的`bindTouch`方法中看到。'
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Its first argument is the `<div>` element's unique ID preceded by a `#` symbol;
    this way JavaScript knows it needs to look for an ID. The second argument is the
    input state that we call `tbleft` (touchbound left).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第一个参数是`<div>`元素的唯一ID，前面加上`#`符号；这样JavaScript就知道它需要查找一个ID。第二个参数是我们称之为`tbleft`（触摸绑定左）的输入状态。
- en: If you have an iPad or any other mobile device, you would be able to load your
    game there if you had it on an online server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有iPad或其他移动设备，并且将游戏放在在线服务器上，您就可以在那里加载游戏。
- en: Now the input keys (whether really on your keyboard or virtual ones) are bound
    to an ImpactJS state; these states can be used to follow player control. An example
    of this is of course moving in a certain direction.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入键（无论是真正的键盘还是虚拟键）都绑定到了ImpactJS状态；这些状态可以用于跟踪玩家控制。当然，一个例子就是朝着某个方向移动。
- en: 'Summing up the procedure for setting up the player controls:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 总结设置玩家控制的程序：
- en: Having control over an entity is what separates the playable character from
    the non-playable characters (NPCs).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制一个实体是可玩角色和不可玩角色（NPC）之间的区别。
- en: The link between the keyboard and an action name is defined once in the main
    script. You should try changing these controls to accommodate your own preferences.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘和动作名称之间的链接在主脚本中定义一次。您应该尝试更改这些控件以适应您自己的偏好。
- en: The link between an action name and actually performing the action can be found
    in the player entity itself.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作名称和实际执行动作之间的链接可以在玩家实体本身找到。
- en: On mobile devices you are somewhat restricted to the touchscreen. Virtual buttons
    can be implemented using the HTML `<div>` tags.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动设备上，您在某种程度上受限于触摸屏。可以使用HTML `<div>`标签实现虚拟按钮。
- en: Position, acceleration, and speed
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置、加速度和速度
- en: Everything has a location, and some things are on route to somewhere. Positioning
    in the ImpactJS world is done by the x and y coordinates and a third, less intuitive,
    z index.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都有位置，有些东西正在前往某个地方。在ImpactJS世界中，定位是通过x和y坐标以及第三个不太直观的z索引来完成的。
- en: The x and y coordinates are the distances to the top-left corner of the level,
    measured in pixels. The x coordinate is the position of any object on the horizontal
    axis, counted from left to right. The y coordinate is the position on the vertical
    axis, counted from top to bottom. This y coordinate is a bit counter-intuitive
    for people who are used to looking at graphs; the y coordinate is always 0 at
    the bottom and higher while moving upwards. Mind you, the top-left corner of a
    level is not always the same as the top-left corner of the canvas! The canvas
    through which you can see the game is only your window on the world. This is really
    evident with strategy games where you never see the entire world and often get
    a mini map in order to navigate faster from battle to battle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: x和y坐标是到达级别左上角的距离，以像素为单位。x坐标是水平轴上任何对象的位置，从左到右计数。y坐标是垂直轴上的位置，从上到下计数。对于习惯于查看图表的人来说，这个y坐标有点反直觉；y坐标在底部始终为0，在向上移动时会变得更高。请注意，级别的左上角并不总是与画布的左上角相同！你可以看到游戏的画布只是世界的窗口。这在策略游戏中非常明显，你永远看不到整个世界，通常会得到一个小地图，以便更快地从战斗到战斗中导航。
- en: '![Position, acceleration, and speed](img/4568_2_9.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![位置、加速度和速度](img/4568_2_9.jpg)'
- en: 'Every entity has an x and y coordinate and when you use Weltmeister, you see
    this change while dragging the entity over the map. Within the entity code, you
    can refer to (and change) its position like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体都有x和y坐标，当你使用Weltmeister时，你可以在地图上拖动实体时看到这种变化。在实体代码中，你可以像这样引用（和更改）它的位置：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is nice if you want things to teleport around, but often you just want
    them to move more subtly. For this we can adjust properties such as velocity and
    acceleration. Setting a velocity to a number different from `0` will make the
    entity's position change over time. Setting the acceleration will change the velocity
    over time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让事物进行瞬间移动，这很好，但通常你只是希望它们移动得更微妙一些。为此，我们可以调整速度和加速度等属性。将速度设置为与`0`不同的数字将使实体的位置随时间改变。设置加速度将随时间改变速度。
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We already saw this piece of code while discussing the player controls. The
    `this.vel.x = -100` command will make the player move upwards at a speed of 100
    px per second. You need the velocity to be negative to go up because, as we saw
    earlier, the y axis is inversed. The speed can be set separately for every direction.
    For example, you can create an area where strong winds make the hero move slower
    when going against them but remain unaffected when moving under a 90 degree angle
    and the player might even move faster with the wind in his/her back with the help
    of this command. Try changing the speeds to simulate a strong wind from the north
    with the use of the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论玩家控制时已经看到了这段代码。`this.vel.x = -100`命令将使玩家以每秒100像素的速度向上移动。因为正如我们之前看到的，需要将速度设置为负值才能向上移动，y轴是反向的。速度可以分别设置为每个方向。例如，你可以创建一个区域，强风使英雄逆风时移动更慢，但在90度角下移动时不受影响，玩家甚至可能在风助下向后移动得更快。尝试使用以下代码更改速度来模拟来自北方的强风：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Acceleration in turn affects speed over time. Acceleration is a bit tricky,
    since slowing down does not naturally end up in stopping but in moving in the
    opposite direction, at which point slowing down actually becomes accelerating
    and vice versa. To introduce the acceleration factor, we insert the following
    code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度反过来影响了随时间的速度。加速度有点棘手，因为减速并不自然地停止，而是转向相反的方向，此时减速实际上变成了加速，反之亦然。为了引入加速度因素，我们插入以下代码：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make sure accelerating does not make your entity go at the speed of light,
    given enough time and button mashing, you can set a maximum velocity using the
    following code example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保加速不会使你的实体以光速前进，只要有足够的时间和按钮操作，你可以使用以下代码示例设置最大速度：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Try adding this code snippet to the `player.js init()` function or as a property.
    If your wind effect is still in place, it should be less strong downwind than
    it was before.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将此代码片段添加到`player.js init()`函数或作为属性。如果你的风效果仍然存在，那么下风的效果应该比以前要弱一些。
- en: 'Apart from the x and y coordinates, a third dimension is at play. To add a
    sense of depth to the game, entities can be placed in front of each other. For
    graphical layers, this can simply be done by shifting them up and down in the
    Weltmeister **Layers** menu. There you could put layers permanently in front of
    or behind each other and all entities. However, how entities are resolved among
    each other is not set in the Weltmeister, but by their respective z indexes. The
    z index of an entity is actually its place in the array of entities. To get a
    better grasp of what this means, have a look at the following Firebug representation
    of the game''s DOM:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除了x和y坐标，还有第三个维度在起作用。为了给游戏增加一些深度感，实体可以放置在彼此的前面。对于图形层，这可以通过在Weltmeister **Layers**菜单中上下移动来简单地完成。在那里，你可以永久地将图层放在其他图层和所有实体的前面或后面。然而，实体之间的解决方式并不是在Weltmeister中设置的，而是通过它们各自的z索引。实体的z索引实际上是它在实体数组中的位置。为了更好地理解这意味着什么，看一下游戏DOM的以下Firebug表示：
- en: '![Position, acceleration, and speed](img/4568_2_10.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![位置、加速度和速度](img/4568_2_10.jpg)'
- en: 'Entities that are at the end of the array will get drawn last by the game''s
    `draw()` method. Getting drawn last means you will be drawn on top of all the
    other ones and thus appear as if in front of them. All newly spawned entities
    get appended to the end of the list. The younger the entity, the closer it will
    appear when put above others. This can be avoided by manually setting the z index
    and using the game''s `sortEntitiesDeferred()` method in the `main.js` update
    function of the `player.js` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组末尾的实体将由游戏的`draw()`方法最后绘制。最后绘制意味着你将被绘制在所有其他实体的顶部，因此看起来就好像在它们的前面。所有新生成的实体都会附加到列表的末尾。实体越年轻，放在其他实体上方时就会显得越靠近。这可以通过手动设置z索引并在`player.js`文件的`main.js`更新函数中使用游戏的`sortEntitiesDeferred()`方法来避免：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Update the `main.js update()` function as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新`main.js`中的`update()`函数：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Your player can move, but how does it move so gracefully instead of just gliding
    from point A to B? This all has to do with sprites and animation sheets.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你的玩家可以移动，但是它是如何如此优雅地移动而不是只是从A点滑向B点呢？这一切都与精灵和动画表有关。
- en: 'Summing up the position, acceleration, and speeding procedure, we conclude:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 总结位置、加速度和速度过程，我们得出：
- en: Every entity has a position, a velocity, and acceleration.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个实体都有一个位置、速度和加速度。
- en: Try changing the player's velocity in order to change his/her position.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试改变玩家的速度以改变他/她的位置。
- en: Try changing the acceleration in order to change the velocity and consequently
    the player's position.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试改变加速度以改变速度，从而改变玩家的位置。
- en: Every entity has a z coordinate, which indicates whether the entity should be
    drawn in front of or behind the other entities. Try changing the z coordinate
    for the player to a very high number. Now the playable character will be drawn
    behind all other entities in the level.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个实体都有一个z坐标，它表示实体是在其他实体的前面还是后面绘制。尝试将玩家的z坐标更改为一个非常大的数字。现在可玩角色将被绘制在关卡中所有其他实体的后面。
- en: 'The game''s graphics: sprites and animation sheets'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏的图形：精灵和动画表
- en: A sprite is a drawing, which is put on a transparent background and then saved
    in a file format that can keep that background transparent like a `.png` or `.gif`
    format. JPEG, for instance, cannot have transparent parts. Having one drawing
    of a character, let's say a red whale with nuclear claws, is nice. However, for
    animation you need more than one of these drawings, preferably from different
    angles. All these drawings are then put together in one file (again, not a `.JPEG`
    format) where they form an animation sheet.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是一种绘画，放在透明背景上，然后以能保持背景透明的文件格式保存，比如`.png`或`.gif`格式。例如，JPEG不能有透明部分。拥有一个角色的绘画，比如一个带有核爪的红鲸鱼，是不错的。然而，对于动画，你需要更多这样的绘画，最好是从不同的角度。然后把所有这些绘画放在一个文件中（同样，不是`.JPEG`格式），它们组成一个动画表。
- en: '![The game''s graphics: sprites and animation sheets](img/4568_2_11.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![游戏的图形：精灵和动画表](img/4568_2_11.jpg)'
- en: Good sprites and animation sheets are not all that easy to come by and the ones
    you can find on the Internet are often licensed and prohibited for game publishing.
    You can either draw them yourself or buy them on websites such as [www.sprites4games.com](http://www.sprites4games.com).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 好的精灵和动画表并不是那么容易获得的，而且你在互联网上找到的往往是有许可证的，禁止用于游戏发布。你可以自己画，也可以在诸如[www.sprites4games.com](http://www.sprites4games.com)这样的网站上购买。
- en: The animation sheets are typically placed in the `media` folder, though it's
    not mandatory and entirely up to you on how you structure them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 动画表通常放在`media`文件夹中，尽管这并不是强制性的，完全取决于你如何组织它们。
- en: 'You assign an animation sheet to an entity by calling the `AnimationSheet()`
    method as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`AnimationSheet()`方法，将动画表分配给一个实体，如下所示：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first argument is the location and name of your animation sheet. Never forget,
    a location is always specified relative to its root folder, which should now be
    the `myfirstawesomegame` folder. The fact that it is stored in the `htdocs` folder
    of the XAMP file structure does not count. The second and third arguments are
    respectively the width and height of every animation in pixels.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是你的动画表的位置和名称。永远不要忘记，位置总是相对于其根文件夹指定的，现在应该是`myfirstawesomegame`文件夹。它存储在XAMP文件结构的`htdocs`文件夹中并不重要。第二和第三个参数分别是每个动画的宽度和高度（以像素为单位）。
- en: 'Now that the animation sheet is linked to the player, all the possible statuses
    a player can take need to be linked to a certain sequence of images. The entity''s
    `addAnim()` method allows you to link the possible statuses to a certain sequence
    of images as shown in the following example code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在动画表与玩家关联起来了，所有可能的状态都需要与一定的图像序列关联起来。实体的`addAnim()`方法允许你将可能的状态与一定的图像序列关联起来，如下例所示：
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At player initiation (the `init()` function), a few sequences are defined and
    given a name. The simplest one is `idle`. The player simply does nothing and only
    requires one image, which is at position 0 (`[0]`) on the animation sheet. All
    JavaScript arrays start at index 0 and so does the animation sheet array for ImpactJS.
    A 128 x 192 pixel animation sheet can hold 16 images of 32 x 48 pixels, numbered
    0 to 15\. The numbering starts at the top-left corner of the sheet and stops at
    the bottom-right corner, just like you would read the pages of this book (except
    maybe if you are Chinese).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家初始化（`init()`函数）时，定义了一些序列并赋予了一个名称。最简单的是`idle`。玩家什么也不做，只需要一张图片，就是在动画表的位置0（`[0]`）上。所有的JavaScript数组都从索引0开始，ImpactJS的动画表数组也是如此。一个128
    x 192像素的动画表可以容纳16张32 x 48像素的图片，编号从0到15。编号从表的左上角开始，到右下角结束，就像你读这本书的页面一样（也许除非你是中国人）。
- en: 'Walking to the left requires only three distinct images: looking to the left,
    sticking out the right leg, and sticking out the left leg. While animating, looking
    to the left is repeated in between the switching of legs, which gives it the impression
    of someone walking, if the speed is set correctly. Here the speed in between switching
    images is set at `0.1` second, which is quiet hasty.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 向左走只需要三张不同的图片：向左看、伸出右腿和伸出左腿。在动画过程中，向左看在切换腿之间重复出现，这给人一种行走的印象，如果速度设置正确的话。这里在切换图片之间的速度设置为`0.1`秒，相当匆忙。
- en: 'Try setting the speed to `100` seconds for the idle animation and `0.5` seconds
    for the walking animations as shown in the following example code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将空闲动画的速度设置为`100`秒，将行走动画的速度设置为`0.5`秒，如下例所示：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how setting the speed for an idle animation to `100` seconds didn't affect
    it at all because there is no real animation, it's just one image anyway. Quintupling
    the time between images for walking does have a big visual impact though. The
    player now looks like he's floating, a bit like a ghost.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将空闲动画的速度设置为`100`秒并没有影响它，因为实际上没有真正的动画，它只是一个图像。但是，将行走之间的时间增加五倍确实有很大的视觉影响。玩家现在看起来像是在漂浮，有点像鬼魂。
- en: Finally, you need to update the entity property `currentAnim` with the animation
    needed at the time. Updating this entity property with the animation needed changes
    the animation sequence when speed and direction by user input are changed.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要使用所需的动画更新实体属性`currentAnim`。使用用户输入更改速度和方向时，更新此实体属性与所需的动画会改变动画序列。
- en: You could mess around with this too. For instance try setting the animation
    to right when the player walks left and vice versa. Combine this with a pretty
    slow animation and oh yes, you're moonwalking!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试玩这个。例如，尝试在玩家向左走时将动画设置为右，反之亦然。将这与相当缓慢的动画结合起来，哦是的，你在后退！
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Summing up the procedure of boosting the game''s graphics using sprite and
    animation sheets, we can conclude that:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 总结使用精灵和动画表提升游戏图形的过程，我们可以得出结论：
- en: Every visible entity has an animation sheet. The animation sheet is a composition
    of all the different ways an entity can look. Try changing the animation sheet
    for the player entity.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个可见的实体都有一个动画表。动画表是实体可以看起来的所有不同方式的组合。尝试更改玩家实体的动画表。
- en: The animation sequence will tell the game which images should follow each other
    while a certain action is performed. Playing around with the sequence and speed
    of animation can create interesting effects. Try replicating a ghost or a moonwalking
    character using only the `addAnim()` method.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画序列将告诉游戏在执行某个动作时应该跟随哪些图像。玩弄动画的序列和速度可以创造出有趣的效果。尝试仅使用`addAnim()`方法复制一个幽灵或后退的角色。
- en: Spawning, health, and death
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成、生命和死亡
- en: Every being has a beginning, life, and death. It would be kind of harsh to say
    you spawned from your mother's womb all these years ago. But in game terms, that
    is what you did.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生物都有一个开始、生命和死亡。说你几年前从你母亲的子宫中产生出来有点残酷。但在游戏术语中，这就是你所做的。
- en: In theory, there is no limit to the number of entities that can be spawned in
    a single game; in practice this is limited by performance issues, especially on
    mobile devices.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，单个游戏中生成的实体数量是没有限制的；实际上，这受性能问题的限制，特别是在移动设备上。
- en: 'Let''s have a look at an entity that is regularly spawned and destroyed: the
    projectile.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个经常生成和销毁的实体：抛射物。
- en: 'The projectile is spawned by the player when he feels his trigger finger itching.
    In the `player.js` update function you will find the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家感到扳机指头发痒时，抛射物就会由玩家生成。在`player.js`的更新函数中，您会找到以下代码：
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Spawning is done by the `ig.game.spawnEntity` method. All that is really required
    for this method to work is the entity type and the location where it needs to
    be spawned. The fourth argument, which is a set of extra settings you might want
    to add, is optional, but is used now to tell the bullet in which direction it
    is fired.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 生成是通过`ig.game.spawnEntity`方法完成的。这个方法真正需要的是实体类型和需要生成的位置。第四个参数是一组额外的设置，您可能想要添加，这是可选的，但现在用于告诉子弹发射的方向。
- en: 'Anything can spawn an entity. The same way the player spawns a projectile,
    the **Levelchange** entity will spawn the player. In the `levelchange.js` file
    you will find the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 任何东西都可以生成一个实体。与玩家生成抛射物的方式相同，**Levelchange**实体将生成玩家。在`levelchange.js`文件中，您会找到以下代码：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What this piece of code does is it detects whether a spawnpoint is present in
    the level to which the player wants to travel and if so, kills the player that
    might be preset. In Weltmeister you can add a player entity to the level; this
    way you can test it separately without going through the fuss of walking through
    all the other ones that might come before it. This preset player entity is killed
    and replaced by a new one at the location of the appropriate spawnpoint. Then
    the `ig.game.player` variable is set to the first preset (`[0]`) player entity
    he finds. This last part is not mandatory but it's sometimes handy to have a direct
    link to the player entity.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用是检测玩家想要前往的关卡中是否存在生成点，如果存在，则杀死可能存在的玩家。在Weltmeister中，您可以将玩家实体添加到关卡中；这样，您可以单独测试它，而不必经历所有可能出现在它之前的其他实体。这个预设的玩家实体被杀死，并在适当的生成点位置被新的玩家实体替换。然后`ig.game.player`变量被设置为找到的第一个预设（`[0]`）玩家实体。最后一部分不是必需的，但有时直接链接到玩家实体是很方便的。
- en: 'The projectile itself doesn''t really have a specified health in this case,
    but it can be killed with the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，抛射物本身并没有指定的生命值，但可以使用以下代码将其杀死：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, the projectile can only live for 100 frames. You could also control the
    lifetime of an entity with real timers or destroy it when it hits something on
    which it can inflict damage. Change the value from `100` to `1000` to see the
    projectile''s range increase drastically. Alternatively you could add a new property
    to the projectile called `range`, and replace the lifetime check with this one.
    Add the range property in the `init()` function as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，抛射物只能存在100帧。您还可以使用真实计时器控制实体的寿命，或者当它击中可以造成伤害的东西时将其销毁。将值从`100`更改为`1000`，以大幅增加抛射物的射程。或者，您可以在抛射物中添加一个名为`range`的新属性，并用这个属性替换寿命检查。在`init()`函数中添加`range`属性，如下所示：
- en: '[PRE36]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the check function replace the value `100` by `this.range`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查函数中，将值`100`替换为`this.range`：
- en: '[PRE37]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Congratulations! Your code has again become a bit more readable and flexible.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您的代码再次变得更加易读和灵活。
- en: 'The projectile can also be destroyed when it hits an enemy using the following
    code snippet:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段，当抛射物击中敌人时，也可以将其销毁：
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Killing an entity is simply done by calling the `kill()` method but the entities
    `receiveDamage()` method will also call the `kill()` method if health reaches
    the value 0.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`kill()`方法来杀死一个实体很简单，但如果健康值达到0，实体的`receiveDamage()`方法也会调用`kill()`方法。
- en: So what happens in this projectile check function? If the projectile collides
    with an enemy, it will receive damage equal to `100` by `this` (the projectile).
    If this happens, the projectile is destroyed in the process.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在这个弹丸检查函数中会发生什么呢？如果弹丸与敌人发生碰撞，它将受到`100`的伤害，由`this`（弹丸）造成。如果发生这种情况，弹丸将在这个过程中被摧毁。
- en: 'Spawning and death are simple things in ImpactJS, health even more so. While
    you spawn or kill an entity with a method, health is nothing but a property you
    can set and change at will. In the `player.js` file you will see that the player
    has a health of `400` if the following code has been added:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在ImpactJS中，生成和死亡都是简单的事情，健康更是如此。当你用一种方法生成或杀死一个实体时，健康只是一个你可以随意设置和改变的属性。在`player.js`文件中，如果添加了以下代码，你会看到玩家的健康值为`400`：
- en: '[PRE39]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Deducting health is built into the Impact Engine by means of the `receiveDamage()`
    method; you can increase health with the same method. Try setting the damage in
    the `receiveDamage()` method to a negative amount and you just invented the healing
    projectile!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 扣除健康是通过`receiveDamage()`方法内置到Impact引擎中的；你可以用相同的方法增加健康。尝试将`receiveDamage()`方法中的伤害设置为负数，你就发明了治疗弹丸！
- en: '[PRE40]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Summing up the complete process of spawning, heath, and death, we can conclude
    that:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 总结生成、健康和死亡的完整过程，我们可以得出结论：
- en: Every ImpactJS entity can spawn, lose, gain health, and get killed.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个ImpactJS实体都可以生成、失去、获得健康并被杀死。
- en: Try changing the spawn position of the projectile entity to make him spawn closer
    or further away from the player.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试改变弹丸实体的生成位置，使其生成离玩家更近或更远。
- en: The projectile causes damage to other entities; try inversing the effect to
    create a healing arrow.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹丸会对其他实体造成伤害；尝试颠倒效果以创建治疗箭。
- en: The camera view
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机视图
- en: When the world you explore is small and cozy, it's easy to keep an overview
    at all times. This does not remain the case with bigger levels and smaller screens.
    If it is your goal to ever release a game for a mobile phone, you must master
    the camera.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当你探索的世界很小很舒适时，随时保持概览是很容易的。但在更大的关卡和较小的屏幕上情况就不一样了。如果你的目标是为手机发布游戏，你必须掌握摄像机。
- en: Your camera is nothing but your window to the world. When your world is big,
    you will need to adjust your window regularly to keep track of things. There are
    several types of cameras but the two most important ones are the free to move
    camera and the automatic camera.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你的摄像机只是你进入世界的窗口。当你的世界很大时，你需要定期调整你的窗口以跟踪事物。有几种类型的摄像机，但最重要的两种是自由移动摄像机和自动摄像机。
- en: However, before diving into the camera itself, it is best to have a look at
    the canvas element and the way it is set up in an Impact game.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在深入研究摄像机之前，最好先看看Impact游戏中画布元素的设置方式。
- en: The game canvas
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏画布
- en: 'If you open both `main.js` and `html.index`, you should find all the canvas
    code you need since this is such a high-level game component. Within the body
    tags of the HTML document you will find the canvas that holds the cinema screen
    of your game. The canvas element has an ID called `"canvas"`, which makes it possible
    to link it to JavaScript by using the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`main.js`和`html.index`，你应该能找到所有你需要的画布代码，因为这是一个高级游戏组件。在HTML文档的body标签中，你会找到包含游戏电影屏幕的画布。画布元素有一个名为`"canvas"`的ID，这使得可以通过以下代码将其与JavaScript链接起来：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `main.js` file you can find the `main` method of the `ig` object. This
    method links the entire game to the canvas by looking up its ID. If JavaScript
    needs to look up an HTML ID, it is always preceded by the `#` symbol as shown
    in the following example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`文件中，你可以找到`ig`对象的`main`方法。这个方法通过查找其ID将整个游戏与画布链接起来。如果JavaScript需要查找HTML的ID，它总是以`#`符号开头，如下面的例子所示：
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ig.main()` method has 6 parameters. The first one is the canvas ID, then
    the name of the game as specified earlier in the `main.js` file. The third parameter
    indicates the frames per second at which the game needs to run; however, this
    one has become obsolete and will probably be removed entirely in future versions.
    Nowadays, the engine itself decides the optimal framerate, so manual setting has
    become impossible.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`ig.main()`方法有6个参数。第一个是画布ID，然后是游戏的名称，如前面在`main.js`文件中指定的。第三个参数表示游戏需要以每秒帧数运行；然而，这个参数已经过时，可能会在将来的版本中被完全移除。现在，引擎本身决定了最佳帧率，因此手动设置已经不可能了。'
- en: The last three parameters are the width and height of the canvas and the zoom
    you want to use. Zoom is something peculiar because it upscales everything by
    the factor you put down.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个参数是画布的宽度和高度以及你想要使用的缩放值。缩放是一种特殊的东西，因为它会按你设定的因子放大一切。
- en: 'A canvas with dimensions 640 x 480 and a zoom value of 1 will really be 640
    x 480 pixels big and every character in it will have its original dimensions.
    If, however, you put the value of zoom as `2`, dimensions will be multiplied by
    2 and so will everything in the game. If, for instance, you have only 640 x 480
    pixels available, but you can barely see your main character, divide the dimensions
    by a value of 2 and set the zoom value to `2` as shown in the following code example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸为640 x 480，缩放值为1的画布实际上是640 x 480像素大，其中的每个字符都保持其原始尺寸。然而，如果将缩放值设为`2`，尺寸将乘以2，游戏中的所有内容也将乘以2。例如，如果你只有640
    x 480像素可用，但几乎看不到你的主角，可以将尺寸除以2，并将缩放值设置为`2`，如下面的代码示例所示：
- en: '[PRE43]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Try setting the zoom value to `6` for extreme eye pain and blurriness.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将缩放值设置为`6`，会导致极度眼睛疼痛和模糊。
- en: 'Summing up canvas characteristics, we can conclude that:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 总结画布特性，我们可以得出结论：
- en: The game canvas is your window to the game world.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏画布是你进入游戏世界的窗口。
- en: Several elements of this window can be changed; size and zoom are the most important
    ones. Try changing them both in order to adjust perfectly to your own screen resolution.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个窗口的几个元素可以改变；大小和缩放是最重要的。尝试同时改变它们，以便完美地适应你自己的屏幕分辨率。
- en: Free to move camera
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自由移动摄像机
- en: 'A free to move camera, as the name states, is free to move by the player himself.
    These viewports are used typically in RTS games because many things are under
    the player''s command. For example, in the famous game Red Alert, you have dozens
    of tanks, airplanes, soldiers, and crazy submarines roaming about. Good players
    have theirs dispersed all over the map, attacking various targets at once. Camera
    controls in such a game are more sophisticated than the simple introduction we
    are going to explore here, but you have to start somewhere. Find the free to move
    camera''s code in the `main.js` file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 自由移动摄像机，顾名思义，可以由玩家自己自由移动。这些视口通常在RTS游戏中使用，因为许多事情都在玩家的指挥下。例如，在著名的游戏《红色警戒》中，你有数十辆坦克、飞机、士兵和疯狂的潜艇四处游荡。优秀的玩家将它们分散在地图的各个地方，同时攻击各种目标。这类游戏中的摄像机控制比我们将要探索的简单介绍更复杂，但你得从某个地方开始。在`main.js`文件中找到自由移动摄像机的代码：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The screen object represents the part of your game that you can see, that is,
    the earlier mentioned view-port. Here, the screen is assigned to a local variable
    called `gameviewport` so that it can be manipulated with the buttons. For example,
    every time the player hits the `camera_right` button, the window is changed to
    the right by 2 pixels.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕对象代表你可以看到的游戏部分，即前面提到的视口。在这里，屏幕被分配给一个名为`gameviewport`的局部变量，以便可以用按钮进行操作。例如，每当玩家按下`camera_right`按钮时，窗口向右移动2像素。
- en: 'Summing up the camera movement procedure, we can conclude that:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 总结摄像机移动过程，我们可以得出结论：
- en: The free to move camera will adjust the window only when manually told to do
    so
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由移动摄像机只有在手动告知时才会调整窗口
- en: You can try moving the camera around in the game
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尝试在游戏中移动摄像机
- en: Automatically following camera
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动跟随摄像机
- en: 'Making an automatically following camera might sound a lot more difficult but
    it does not need to be. We can see the simple process of adding an automatically
    following camera in the following code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个自动跟随摄像机可能听起来更加困难，但实际上并不需要。我们可以看到在以下代码中添加自动跟随摄像机的简单过程：
- en: '[PRE45]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here an extra element is introduced: the canvas itself. The `ig.system` object
    makes sure the game loops and is also responsible for the input. The `ig.system`
    object is usually called through the `ig.main()` function, which we saw when looking
    at the canvas and thus takes the same arguments. Here it is assigned to a local
    variable `gamecanvas` and we need it to get the actual dimensions of the view-port
    we are handling. The player entity is also assigned to a local variable `player`.
    As you might have noticed, the first player entity is taken (index 0 of the array).
    So, in case there are multiple player entities, only the first will be focused
    upon. This makes it an automatically following camera, rather unsuitable for games
    with several playable entities.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引入了一个额外的元素：画布本身。`ig.system`对象确保游戏循环，并负责输入。`ig.system`对象通常通过`ig.main()`函数调用，我们在查看画布时看到了，因此它接受相同的参数。这里它被分配给一个局部变量`gamecanvas`，我们需要它来获取我们正在处理的视口的实际尺寸。玩家实体也被分配给一个局部变量`player`。正如你可能已经注意到的，第一个玩家实体被取出（数组的索引0）。因此，如果有多个玩家实体，只会关注第一个。这使它成为一个自动跟随摄像机，对于有多个可玩实体的游戏来说并不合适。
- en: 'The game window is constantly updated with the position of the player (for
    both x and y axes) and the map width is divided by 2\. This last deduction is
    to keep the player firmly centered. Try leaving out this last part and watch what
    happens:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏窗口会不断更新玩家的位置（包括x和y轴），地图宽度除以2。最后这个减法是为了保持玩家牢固地居中。尝试去掉最后这部分，看看会发生什么：
- en: '[PRE46]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The view-port will be updated to keep the player on the screen but the player
    is placed on the top-left corner. It will always be on the top-left corner since
    coordinates for the x axis are counted left to right and coordinates for the y
    axis increase from top to bottom.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 视口将被更新以保持玩家在屏幕上，但玩家被放置在左上角。它将始终位于左上角，因为x轴的坐标是从左到右计数，y轴的坐标是从上到下增加的。
- en: 'Summing up the procedure of creating an automatically following camera, we
    can conclude that:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 总结创建自动跟随摄像机的过程，我们可以得出结论：
- en: The automatically following camera tries to keep the player in the middle of
    the screen.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动跟随摄像机试图保持玩家在屏幕中央。
- en: You can try changing the code so that the player is kept in the top-left corner
    of the screen.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尝试改变代码，使玩家保持在屏幕的左上角。
- en: Adding music and sound effects
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加音乐和音效
- en: There are good games and there are truly, epically memorable games. Any game
    can hold itself just on a great gameplay and some decent graphics alone; you don't
    always need music. Minecraft is a great example of this type of game; you don't
    actually play it for its refreshing music. But for those who played Zelda Ocarina
    of Time and any Final Fantasy, you know that music is what puts the icing on the
    cake. It has to be said in advance, music can sometimes be a buggy thing on mobile
    devices. Concurrently playing two sounds is often impossible. This is something
    rather basic since background music and sound effects always overlap. Because
    of its unruly nature on mobiles and for the sake of reproducibility, we will only
    look at desktop versions here.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 有好游戏，也有真正令人难忘的游戏。任何游戏都可以凭借出色的游戏性和一些体面的图形自持；你并不总是需要音乐。《Minecraft》就是这类游戏的一个很好的例子；你并不是为了它清新的音乐而玩它。但对于那些玩过《塞尔达传说：时光之笛》和任何《最终幻想》的人来说，你知道音乐是锦上添花的。必须提前说一下，音乐在移动设备上有时可能会出现问题。同时播放两个声音通常是不可能的。这是一个相当基本的问题，因为背景音乐和音效总是重叠的。由于它在移动设备上的难以控制的特性，为了可重现性，我们只会在桌面版本中进行讨论。
- en: 'There are two main types of sound: the real music and the sound effects. The
    real music consists of composed songs; for modern (and expensive) games these
    are often orchestrated. The sound effects are the grunts of your enemies, the
    clashing of swords, the sound of your footsteps, and a gust of wind. If you want
    to get yourself some actual music, you can compose it yourself or buy it. When
    you need sound effects, you only need to get yourself an audio recorder and a
    list of sounds you need and organize a recording session with some of your best
    friends.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要类型的声音：真正的音乐和音效。真正的音乐由作曲的歌曲组成；对于现代（和昂贵）的游戏来说，这些通常是管弦乐曲。音效是您的敌人的呻吟声，剑的撞击声，您的脚步声和一阵风的声音。如果您想得到一些真正的音乐，您可以自己创作或购买。当您需要音效时，您只需要准备一个音频录音机和您需要的声音列表，并与您最好的朋友之一组织一个录音会话。
- en: Playing background music
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放背景音乐
- en: 'In the `main.js` file you should find the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`文件中，您应该找到以下代码：
- en: '[PRE47]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The first important element you see here is `ig.music`, which is (as you probably
    guessed) the object that takes care of all music. The music array forms the list
    of all the music you will want to use, and adding a song is done the same way
    you add something at the end of any array, that is, using the `.add()` method.
    The method needs only one parameter: the music file you want to use with its location
    relative to the game''s root folder. You can set the volume with the volume property.
    The volume can range from value `0` to `1`. Of course you can set the volume to
    `1` as much as you want, there will be no sound if you don''t activate the music.
    This is done with the .`play()` method. Try setting the music volume to 1 and
    reload the game.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里看到的第一个重要元素是`ig.music`，这是（您可能已经猜到的）负责所有音乐的对象。音乐数组形成了您想要使用的所有音乐的列表，添加歌曲的方式与您在任何数组末尾添加东西的方式相同，即使用`.add()`方法。该方法只需要一个参数：您想要与其位置相对于游戏根文件夹的音乐文件。您可以使用音量属性设置音量。音量可以从值`0`到`1`。当然，您可以将音量设置为`1`，只要您愿意，如果您不激活音乐，就不会有声音。这是通过`.play()`方法完成的。尝试将音乐音量设置为1并重新加载游戏。
- en: 'Whether the player wants to hear your music or not should really be up to her
    or him. Let''s say they are playing your game during class; you don''t want them
    to get caught do you; that would be evil. For this purpose, you will find the
    following code in the `main.js` file:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家是否想听您的音乐实际上应该取决于他或她。假设他们在上课时玩您的游戏；您不希望他们被抓到吧；那将是邪恶的。出于这个目的，您将在`main.js`文件中找到以下代码：
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It basically checks whether the sound buttons (which you have defined earlier)
    are pressed and if so, volume is increased, reduced, or just turned off entirely.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上检查您之前定义的声音按钮是否被按下，如果是，音量会增加，减少或完全关闭。
- en: 'Summing up the entire process of adding music and sound effect, we can conclude
    that:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 总结添加音乐和音效的整个过程，我们可以得出结论：
- en: Music can be added to the game in either the `.mp3` or `.ogg` format
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音乐可以以`.mp3`或`.ogg`格式添加到游戏中
- en: The `music` class is especially useful for entire tracks of music since it has
    several functions equivalent to a standard radio
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`music`类对于整个音乐曲目特别有用，因为它具有几个等同于标准收音机的功能'
- en: You can try changing the volume and turning the music on and off
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以尝试更改音量并打开或关闭音乐
- en: Introducing sound effects
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍音效
- en: Music is a continuous thing and not really dependent on the game events (except
    maybe some more nervous music when your player is almost dead). Sound effects
    on the other hand can be added to almost anything.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐是一个连续的东西，不是真正依赖于游戏事件（除非您的玩家几乎快死了，也许会有一些更紧张的音乐）。另一方面，音效可以添加到几乎任何东西上。
- en: 'Open the `player.js` file and find the following code in its `init()` function:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`player.js`文件，并在其`init()`函数中找到以下代码：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Another new object, `ig.sound`, will be able to handle any sound you offer it,
    including background music. It is, however, still better to attribute your music
    to the `ig.music` object because of the extra options you have for handling music
    tracks. For example, with the `ig.music` object, you can shuffle your tracks (`.random`)
    or add a fade out effect (`.fadeOut`) if not already included in your MP3 file.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新对象`ig.sound`将能够处理您提供的任何声音，包括背景音乐。然而，最好将您的音乐属性分配给`ig.music`对象，因为您可以使用额外的选项来处理音乐曲目。例如，使用`ig.music`对象，您可以随机播放曲目（`.random`）或添加淡出效果（`.fadeOut`），如果尚未包含在您的MP3文件中。
- en: 'The walk sound is added as a new sound to the player entity (`this`) and its
    volume is set to `1`. We have a sound to add for the footsteps but it wouldn''t
    make much sense to hear footsteps when he is not actually walking:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 行走声音被添加为玩家实体（`this`）的新声音，并且其音量设置为`1`。我们有一个要添加的脚步声，但当他实际上没有在走路时听到脚步声并没有太多意义：
- en: '[PRE50]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When the player is not strolling around, all is quiet. If he starts walking
    again, the sound of footsteps resumes. There are many more examples for adding
    sound effects, but for now we will end it at this one.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家不四处闲逛时，一切都是安静的。如果他再次开始走路，脚步声就会恢复。还有许多其他添加音效的例子，但现在我们将在此结束。
- en: 'Summing up the complete procedure to add sound effects, we can conclude that:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 总结添加音效的完整过程，我们可以得出结论：
- en: A sound effect is a short sound that is usually only played when a certain action
    happens
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音效是通常只在发生某种动作时播放的短声音
- en: A sound effect will only play once by default
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，音效只会播放一次
- en: You can try activating the snow-walk sound effect
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以尝试激活雪地行走音效
- en: Game physics with Box2D
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Box2D进行游戏物理
- en: 'To end the exploratory chapter, we will have a look at the physics engine of
    ImpactJS: Box2D. Physics engines are game engines capable of simulating many of
    the visible forces at play on earth like gravity and pressure forces (impact).
    One of the most famous games with a physics engine is, of course, Angry Birds.
    Physics was used in lots of games before this 2D world hit (such as Half-life
    and games even way before this one). Angry Birds should, however, be an example
    of how a simple game (combined with a considerable marketing machine) can reap
    enormous success.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束探索性章节，我们将看看ImpactJS的物理引擎：Box2D。物理引擎是游戏引擎，能够模拟地球上许多可见的力，如重力和压力力（冲击）。当然，最著名的带有物理引擎的游戏之一是愤怒的小鸟。在这个2D世界出现之前，物理在许多游戏中都得到了应用（例如《半条命》和甚至比这个更早的游戏）。然而，愤怒的小鸟应该是一个例子，说明一个简单的游戏（加上一个可观的营销机器）可以获得巨大的成功。
- en: 'The engine is not an invention of Dominic (maker of ImpactJS) but a port from
    Flash ActionScript to JavaScript. As such, a full description of all the Box2D
    capabilities is not available on the Impact website (as it is for the Impact Engine),
    but it is available on the following website: [http://www.box2dflash.org/docs/2.0.2/manual.php](http://www.box2dflash.org/docs/2.0.2/manual.php).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 该引擎不是Dominic（ImpactJS的制作者）的发明，而是从Flash ActionScript移植到JavaScript。因此，Impact网站上并没有提供有关所有Box2D功能的完整描述（就像Impact引擎一样），但可以在以下网站上找到：[http://www.box2dflash.org/docs/2.0.2/manual.php](http://www.box2dflash.org/docs/2.0.2/manual.php)。
- en: The documentation on combining ImpactJS and Box2D, however, is fragmentary at
    best. You need a totally different way of thinking when building a game with physics
    versus one without and that is why the source code is also separate from the standard
    package. As mentioned in [Chapter 1](ch01.html "Chapter 1. Firing Up Your First
    Impact Game"), *Firing Up Your First Impact Game*, you can get your Box2D source
    code from a downloadable file called `physics` when you buy ImpactJS. The folder
    called `Box2D` should be placed under the `plugins` folder in order to proceed.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于结合ImpactJS和Box2D的文档在最好的情况下是零碎的。在构建具有物理特性的游戏和没有物理特性的游戏时，您需要完全不同的思维方式，这也是为什么源代码与标准包是分开的原因。正如在[第1章](ch01.html
    "第1章。启动您的第一个Impact游戏")中提到的，*启动您的第一个Impact游戏*，您可以从购买ImpactJS时的可下载文件`physics`中获取Box2D源代码。文件夹称为`Box2D`应放置在`plugins`文件夹下以继续进行。
- en: Before diving into the Box2D code, load up a game and press the *Shift* + *F9*
    key combination. You are now magically teleported to the bizarre world of Box2D,
    where things can fly and gravity soaks everything back down. Try pushing the coins
    around and see how they react to well placed headbutts from different directions.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究Box2D代码之前，加载一个游戏并按下*Shift* + *F9*键组合。您现在神奇地被传送到Box2D的奇异世界，在那里物体可以飞翔，重力使一切都回到原位。尝试推动硬币并看看它们如何对来自不同方向的有力头槌做出反应。
- en: Gravity and force
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重力和力
- en: 'If you open the `main.js` file, you will stumble upon a new game definition.
    This time it is not an extension of the standard `ig.game` function, but `ig.Box2DGame`.
    Yes, it is possible to define different games in a single file and often this
    technique is used for making game over screens, splash screens, and the sort using
    the following code:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`main.js`文件，您将遇到一个新的游戏定义。这次不是标准`ig.game`函数的扩展，而是`ig.Box2DGame`。是的，可以在单个文件中定义不同的游戏，通常使用此技术制作游戏结束屏幕、闪屏等，使用以下代码：
- en: '[PRE51]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Right from the beginning we can define the gravity of the world as a property
    of the `BouncyGame` variable. Feel free to change it and watch the difference
    in gravity take effect in the game. Gravity does not need to be a positive force
    either. Try setting it to a negative number such as `-100` and you will see everything
    being drawn towards the ceiling.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们可以将世界的重力定义为`BouncyGame`变量的属性。随意更改它，并观察重力在游戏中产生的影响。重力也不一定需要是正向力。尝试将其设置为负数，如`-100`，您将看到一切都被吸向天花板。
- en: The stronger the gravity, the more force you will need to overcome it. With
    a gravity value of `300` (or `-300`) your movement becomes restricted to left
    and right.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 重力越大，您需要克服它的力就越大。使用重力值`300`（或`-300`），您的移动将受到左右的限制。
- en: 'This can be changed in the player entity itself. Open the `boxPlayer.js` file
    to find a special instance of the player entity. Special, because it is not an
    extension of the normal player entity, but the other entity called the `Box2DEntity`,
    as shown in the following code example:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在玩家实体本身中进行更改。打开`boxPlayer.js`文件，找到玩家实体的特殊实例。特殊之处在于它不是普通玩家实体的扩展，而是另一个称为`Box2DEntity`的实体，如下面的代码示例所示：
- en: '[PRE52]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Also notice that we needed to include the Box2D entity.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们需要包含Box2D实体。
- en: 'While the normal Impact Engine makes use of velocity, Box2D uses vectors. As
    you might remember from physics and mathematics, a vector is a line with both
    direction and magnitude; let''s take a look at how it is implemented:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的Impact引擎使用速度，而Box2D使用向量。正如您可能从物理学和数学中记得的那样，向量是具有方向和大小的线；让我们看看它是如何实现的：
- en: '[PRE53]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For example, for going upwards you apply force with your own body on the position
    of your body. The force you output has a magnitude of `200` as shown in this example.
    We changed the value of gravity to `300` so we don't have enough to overcome it
    with a force of 200\. Try setting its value to `500` and you will be able to gradually
    overcome gravity again. Set its value to `1000` and even though you will still
    fall like a brick, overcoming gravity by pressing the up button becomes a breeze.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了向上移动，您在身体的位置上施加力。如本例所示，您输出的力的大小为`200`。我们将重力值更改为`300`，因此我们没有足够的力量来克服200的力。尝试将其值设置为`500`，您将能够逐渐克服重力。将其值设置为`1000`，即使您仍然像砖块一样掉下来，通过按下上键来克服重力变得轻而易举。
- en: 'Summing up the concept of gravity and force, we can conclude that:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 总结重力和力的概念，我们可以得出结论：
- en: Box2D is a physics engine, not officially part of ImpactJS, but fairly integrated
    with it.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Box2D是一个物理引擎，不是ImpactJS的正式部分，但与之相当集成。
- en: Box2D is vector-based. All movements translate in a combination of force and
    direction. Gravity is just a specific case, always having a vertical direction.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Box2D是基于向量的。所有运动都以力和方向的组合进行转换。重力只是一个特例，始终具有垂直方向。
- en: Try changing the game's gravity to make things float upwards.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试改变游戏的重力，使物体向上浮动。
- en: Change the force that is applied to the player when pressing the up button.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改按下上按钮时施加在玩家身上的力。
- en: Collision impact and bounciness
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞影响和弹性
- en: While hitting another object like a coin, it can be moved by the force of the
    impact. You probably tried doing that already. The force the player exerts is
    applied to the coin and it goes flying. Eventually the coin is brought to rest
    again by gravity but you are free to hit it again of course.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当撞击另一个物体（如硬币）时，它可能会被撞击力移动。您可能已经尝试过这样做。玩家施加的力被应用于硬币，它飞起来了。最终，硬币又被重力带到了静止，但您当然可以再次撞击它。
- en: 'The coin also has a certain amount of bounciness, which in Box2D is called
    restitution. The value of restitution can be set on a scale from `0` to `1`. Since
    force decreases over time, an object will never bounce back at the same speed
    with which it hit the wall. You can set the bounciness of the coin yourself in
    the `boxcoin.js` file as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币也具有一定的弹性，在Box2D中被称为恢复。恢复的值可以在`0`到`1`的范围内设置。由于力随时间减小，物体永远不会以与其撞击墙壁时相同的速度弹回。您可以在`boxcoin.js`文件中自行设置硬币的弹性如下：
- en: '[PRE54]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Try setting the value of restitution to `0` and see if the coins still bounce
    off the walls.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将恢复值设置为`0`，看看硬币是否仍然会从墙壁上弹开。
- en: This was a very short introduction to Box2D. In the next chapter we will build
    up a small RPG from the ground up.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Box2D的一个非常简短的介绍。在下一章中，我们将从头开始构建一个小型RPG。
- en: 'Summing up the collision impact and bounciness concept, we can conclude that:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 总结碰撞影响和弹性的概念，我们可以得出结论：
- en: Collision between two bodies in a Box2D environment will translate in each body
    exerting a certain force on the other body
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Box2D环境中两个物体之间的碰撞将导致每个物体对另一个物体施加一定的力
- en: A body can have a certain amount of elasticity when hitting a solid object;
    this is called restitution or bounciness
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当撞击固体物体时，物体可以具有一定的弹性；这被称为恢复或弹性
- en: You can try changing the restitution of the coin entity and observe the small
    difference in bounciness
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以尝试更改硬币实体的恢复值，并观察弹性的细微差异
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The aim of this chapter was to grant a quick insight into each of the important
    components of an Impact game by exploring a pre-made example. We first used the
    Weltmeister tool to open an existing level and gain a deeper insight into how
    it is built up out of layers and entities. We took a look at a playable character
    and how it differs from a non-playable character. By adapting some entity parameters
    we could change things like health, movement speed, and even the way our entities
    look. Since in most games you can't see your entire playing field on a single
    screen, we took a look at a manual and automatically following camera. We added
    a background tune and sound effects as part of the atmosphere of a game.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是通过探索一个预制示例，快速了解Impact游戏的每个重要组件。我们首先使用Weltmeister工具打开了一个现有的关卡，并深入了解了它是如何由图层和实体构建起来的。我们看了一个可玩角色以及它与不可玩角色的区别。通过调整一些实体参数，我们可以改变诸如生命值、移动速度甚至实体外观等内容。由于在大多数游戏中，您无法在单个屏幕上看到整个游戏场景，我们看了一下手动和自动跟随相机。我们添加了背景音乐和音效作为游戏氛围的一部分。
- en: Finally we took a quick peek at the Box2D physics engine. While in this chapter
    we have only been tweaking parameters, in the next chapter we will build a game
    from the ground up.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要地了解了Box2D物理引擎。虽然在本章中我们只是在调整参数，但在下一章中我们将从头开始构建一个游戏。
