- en: Chapter 5. Adding Some Advanced Features to Your Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。为您的游戏添加一些高级功能
- en: In the previous chapters we saw how to set up a work environment, took a look
    at the Impact engine, and even built two types of games. Now it is time to have
    a look at a few interesting extras.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们看到了如何设置工作环境，看了Impact引擎，甚至构建了两种类型的游戏。现在是时候看一些有趣的额外内容了。
- en: 'To test the elements covered in this chapter, it is best to either download
    the code material in the `chapter 5` folder or build directly on the game we designed
    in [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role Playing Game"), *Let''s
    Build a Role Playing Game*. Since we will not be working with the Box2D extension
    in this chapter, some things will be incompatible with the side scroller game
    in [Chapter 4](ch04.html "Chapter 4. Let''s Build a Side Scroller Game"), *Let''s
    Build a Side Scroller Game*. In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试本章涵盖的元素，最好要么下载`第5章`文件夹中的代码材料，要么直接在我们设计的游戏中构建[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")中的游戏，*让我们建立一个角色扮演游戏*。由于本章我们不会使用Box2D扩展，一些东西将与[第4章](ch04.html
    "第4章。让我们建立一个侧面卷轴游戏")中的侧面卷轴游戏不兼容，*让我们建立一个侧面卷轴游戏*。在本章中，我们将涵盖：
- en: Making a Start and Victory screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作开始和胜利画面
- en: Extra debug possibilities and introducing a customized ImpactJS debug panel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的调试可能性和引入定制的ImpactJS调试面板
- en: Saving data with cookies and the lawnchair application, and turning an Excel
    file into useful game data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cookie和lawnchair应用程序保存数据，并将Excel文件转换为有用的游戏数据
- en: A few extra game functionalities for the role playing game (RPG) in [Chapter
    3](ch03.html "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role
    Playing Game*
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")的角色扮演游戏（RPG）中的一些额外游戏功能，*让我们建立一个角色扮演游戏*
- en: Making your character move by use of a mouse
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过鼠标移动角色
- en: Intelligent spawn locations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能生成位置
- en: Adding basic conversation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加基本对话
- en: Showing a player's health bar
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示玩家的生命值条
- en: Extending the Artificial Intelligence (AI) with a hive mind
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集体智慧扩展人工智能（AI）
- en: Implementing Playtomic for game analytics
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施Playtomic进行游戏分析
- en: The Start and Game-over screen
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和游戏结束画面
- en: When the player starts your game, the first thing you might want him to see
    is a splash screen. This screen usually has the name of the game and other interesting
    info; often it contains some information on the game's story or controls. At the
    end of the game you could have a Victory screen that tells the player how well
    he did by placing his achieved score in a leaderboard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家开始游戏时，你可能希望他看到的第一件事是一个闪屏。这个屏幕通常包含游戏的名称和其他有趣的信息；通常包含一些关于游戏故事或控制的信息。在游戏结束时，你可以有一个胜利画面，告诉玩家他在排行榜上的得分有多高。
- en: 'With regards to code, this can be done by introducing new game instances next
    to the actual game. Every single screen: Start, Game-over, and Victory are direct
    extensions of the ImpactJS game class. Let''s kick off by creating a Start screen.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，可以通过在实际游戏旁边引入新的游戏实例来实现。每个屏幕：开始、游戏结束和胜利都是ImpactJS游戏类的直接扩展。让我们首先创建一个开始画面。
- en: The game's Start screen
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏的开始画面
- en: 'In order to make a nice opening screen, we need a background image and our
    trusted `main.js` script:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作一个漂亮的开场画面，我们需要一个背景图片和我们信任的`main.js`脚本：
- en: 'Open the `main.js` script and insert the following code:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main.js`脚本并插入以下代码：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The opening screen is an extension of the `ig.Game` function, just like our
    game is. As a matter of fact, when we are done here, we will have four game instances:
    one real game called `MyGame`, and three other games, which will merely act as
    a Start, Victory, or Game-over screen. This might be a little counter intuitive,
    since you would expect the screens to be part of that same game. In reality this
    is most certainly true. However, in code it is more convenient to turn these screens
    into separate game class extensions.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开场画面是`ig.Game`函数的扩展，就像我们的游戏一样。事实上，当我们完成这里的工作后，我们将有四个游戏实例：一个真正的游戏称为`MyGame`，另外三个游戏，它们只是作为开始、胜利或游戏结束画面。这可能有点反直觉，因为你可能期望这些画面是同一个游戏的一部分。实际上，这绝对是真的。然而，在代码中，将这些画面转换为单独的游戏类扩展更方便。
- en: 'In this part of the `OpenScreen` code, we first define the image we will be
    showing: `StartScreen.png`.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OpenScreen`代码的这一部分中，我们首先定义了我们将要显示的图像：`StartScreen.png`。
- en: 'Finally we bind the Space bar to an action state called `LoadGame` shown as
    follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将空格键绑定到一个名为`LoadGame`的动作状态，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we can load the game by pressing the Space bar, but we still need to actually
    show something on the screen.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过按空格键加载游戏，但我们仍然需要在屏幕上实际显示一些东西。
- en: 'We can visualize things by manipulating the `draw()` function, as shown in
    the following code snippet, of any ImpactJS class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过操纵任何ImpactJS类的`draw()`函数来可视化事物，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `draw()` function will draw the background image we specified when initializing
    our `OpenScreen` function. Having done so, it will also add a small red rectangle
    in which we will print the name of the player, if we have it. We will go into
    getting this name and storing it for later use when we take a look at game data
    later in this chapter. For now, the `GameInfo.name` variable is undefined and
    will show up exactly like starting a new game.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`draw()`函数将绘制我们在初始化`OpenScreen`函数时指定的背景图像。这样做后，它还会添加一个小的红色矩形，我们将在其中打印玩家的名字（如果有的话）。我们将在本章后面查看游戏数据时，获取这个名字并存储它以供以后使用。目前，`GameInfo.name`变量是未定义的，将会像开始新游戏一样显示出来。'
- en: 'To make sure our brand new opening screen is actually used, we need to replace
    the `MyGame` game class instance by the `OpenScreen` function in our `ig.main`
    function call, as shown in the following code line:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们全新的开场画面实际上被使用，我们需要在我们的`ig.main`函数调用中用`OpenScreen`函数替换`MyGame`游戏类实例，如下面的代码行所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now have an opening screen! Adding a Game-over screen and a Victory screen
    are very similar procedures. Before making these other screens, let''s quickly
    recap on what we have just done:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个开场画面！添加游戏结束画面和胜利画面的过程非常相似。在制作这些其他画面之前，让我们快速回顾一下我们刚刚做的事情：
- en: We made sure a background image is available in the `media` folder
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确保`media`文件夹中有背景图像
- en: We added the `OpenScreen` function as a new game instance
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了`OpenScreen`函数作为一个新的游戏实例
- en: We bound the Space bar so it can be used to load the actual game
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们绑定了空格键，以便用来加载实际游戏
- en: We set up the `Draw()` function so it can show the background and even the player's
    name later on
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设置了`Draw()`函数，以便它可以显示背景，甚至以后还可以显示玩家的名字
- en: We initialized our canvas in the `OpenScreen` function window instead of the
    `MyGame` game class instance
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`OpenScreen`函数窗口中初始化了我们的画布，而不是在`MyGame`游戏类实例中
- en: The Victory and Game-over screens
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 胜利和游戏结束画面
- en: 'The Victory screen is a relatively simple extension of the game entity. The
    procedure is pretty much the same for every type of screen we will want to show.
    To set up the Victory screen, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利画面是游戏实体的一个相对简单的扩展。对于我们想要显示的每种类型的画面，该过程几乎是相同的。要设置胜利画面，请按照以下步骤进行：
- en: 'Open the `game.js` file and add our new `GameEnd` game class, as shown in the
    following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`game.js`文件，并添加我们的新`GameEnd`游戏类，如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All we need to initialize here is the image we will be showing and a key for
    restarting our game.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要初始化的是我们将要显示的图像和一个用于重新开始游戏的键。
- en: 'Similar to the Start screen, we use the Space bar to load a new game. We continually
    check whether the Space bar was pressed by adding the following `if` statement
    to the `update` function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与开始画面类似，我们使用空格键加载新游戏。我们通过在`update`函数中添加以下`if`语句来不断检查空格键是否被按下：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to draw the actual game-end image and place the text **HIT SPACE TO
    RESTART** using the following code. This way we make sure the player doesn't resort
    to refreshing the browser instead of using the Space bar.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用以下代码绘制实际的游戏结束图像，并放置文本**HIT SPACE TO RESTART**。这样我们就确保玩家不会刷新浏览器而是使用空格键。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Victory screen needs to be shown when the player is at the end of the game.
    In our case, this would be when the boss entity is defeated. Open the `boss.js`
    file and change the `kill()` method as shown in the following code so that he
    will load the Victory screen when he dies:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家到达游戏结束时，需要显示胜利画面。在我们的情况下，这将是当boss实体被击败时。打开`boss.js`文件，并按照以下代码更改`kill()`方法，以便在他死亡时加载胜利画面：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `kill()` method, we call the `gameWon()` function, which is a method
    of our current game and which is not yet defined.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`kill()`方法中，我们调用了`gameWon()`函数，这是我们当前游戏的一个方法，但尚未定义。
- en: Open the `game.js` file and add the `gameWon()` method as a new method of the
    `MyGame` file, as shown in the following code.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`game.js`文件，并将`gameWon()`方法添加为`MyGame`文件的一个新方法，如下所示。
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the moment, it may seem rather pointless to introduce an extra intermediary
    function to call the Victory screen. However, this will start to make sense once
    we get into handling game data. Eventually, this function will not only call the
    Victory screen, but will also save the player's score. Using an intermediary function
    is a cleaner way of programming than adding the `ig.system.setGame()` function
    directly into the player entity.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，引入一个额外的中间函数来调用胜利画面可能看起来有点无聊。然而，一旦我们开始处理游戏数据，这将开始变得有意义。最终，这个函数不仅会调用胜利画面，还会保存玩家的得分。使用中间函数比直接将`ig.system.setGame()`函数添加到玩家实体中是一种更干净的编程方式。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Game-over screen can be the exact equivalent of the Victory screen, except
    that another image is used and it is triggered by the death of the player, not
    the boss.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束画面可以是胜利画面的确切等价物，只是使用另一张图像，并且是由玩家的死亡而不是boss的触发。
- en: 'Add the `gameOver` function to the `game.js` file as shown in the following
    code snippet:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，在`game.js`文件中添加`gameOver`函数：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make sure the `gameOver` function is triggered by the death of our player by
    adjusting his `kill()` method using the following code:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下代码调整他的`kill()`方法，确保`gameOver`函数在玩家死亡时被触发：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again we called an intermediary function to handle the actual screen loading.
    This function will need to be added as a method to the `MyGame` game class instance.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用中间函数来处理实际画面加载。这个函数需要作为`MyGame`游戏类实例的一个方法添加。
- en: 'In the `game.js` script, add the `gameOver()` method to the `MyGame` game class
    instance as shown in the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`game.js`脚本中，将`gameOver()`方法添加到`MyGame`游戏类实例中，如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These are very basic Start and Game-over screens, which show that it can be
    done by using the `ig.game` class as a starting point. A good idea for both the
    Victory and Game-over screen would be to show a leaderboard or any other interesting
    info gathered during the game.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是非常基本的开始和游戏结束画面，它们表明可以通过使用`ig.game`类作为起点来完成。对于胜利和游戏结束画面，一个好主意是显示排行榜或在游戏过程中收集的其他有趣信息。
- en: 'When the game gets more complicated by adding advanced features, debugging
    becomes increasingly important to cope with these added levels of complexities.
    We will now have a look at what advanced debugging options we have at our disposal.
    However, before we do that, let''s quickly recap on the Victory and Game-over
    screens:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏通过添加高级功能变得更加复杂时，调试变得越来越重要，以应对这些增加的复杂性。我们现在将看看我们可以使用哪些高级调试选项。然而，在我们这样做之前，让我们快速回顾一下胜利和游戏结束画面：
- en: We made two new game instances that function as Victory and Game-over screens
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们制作了两个新的游戏实例，作为胜利和游戏结束画面
- en: The `update` function was adapted to listen to the Space bar, while the `draw`
    function was adapted to show both the background image and the **HIT SPACE TO
    RESTART** message
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`函数被调整以监听空格键，而`draw`函数被调整以显示背景图像和**HIT SPACE TO RESTART**消息'
- en: The functions of both the boss and player entity were adapted to trigger the
    Victory and Game-over screens
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 老板和玩家实体的功能被调整以触发胜利和游戏结束屏幕
- en: We made use of intermediary functions called `gameOver()` and `gameWon()` because
    we wanted to adapt these later on so that they trigger the lawnchair application
    to store a score
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了名为`gameOver()`和`gameWon()`的中间函数，因为我们希望稍后调整它们，以便触发lawnchair应用程序来存储分数
- en: More advanced debugging options
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高级的调试选项
- en: In [Chapter 1](ch01.html "Chapter 1. Firing Up Your First Impact Game"), *Firing
    Up Your First Impact Game*, we took a look at how to debug using the browser and
    what the ImpactJS debug panel has to offer. Here we will go a little further by
    making ourselves a new ImpactJS debug panel. This code is readily made available
    by Dominic on his ImpactJS website but many people overlook this functionality
    even though it is surprisingly useful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。启动你的第一个Impact游戏")中，*启动你的第一个Impact游戏*，我们看了如何使用浏览器进行调试以及ImpactJS调试面板提供了什么。在这里，我们将进一步制作一个新的ImpactJS调试面板。这段代码由Dominic在他的ImpactJS网站上提供，但很多人忽视了这个功能，尽管它非常有用。
- en: In [Chapter 1](ch01.html "Chapter 1. Firing Up Your First Impact Game"), *Firing
    Up Your First Impact Game*, we also talked about the logical error, an error that
    is very difficult to find because it does not necessarily generate an error in
    the browser debug console. To cope with these kinds of errors, programmers often
    use a method known as unit testing. This basically involves defining in advance
    what your desired result is for every piece of code, translating these desired
    results into conditions, and testing whether the output adheres to these conditions.
    Let's take a look at a short example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。启动你的第一个Impact游戏")中，*启动你的第一个Impact游戏*，我们还谈到了逻辑错误，这是一种非常难以找到的错误，因为它不一定会在浏览器调试控制台中生成错误。为了应对这些错误，程序员经常使用一种称为单元测试的方法。基本上，这涉及到预先定义每段代码的期望结果，将这些期望结果转化为条件，并测试输出是否符合这些条件。让我们看一个简短的例子。
- en: Short introduction to unit testing
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试的简短介绍
- en: 'One of the most basic components of our ImpactJS scripts is the function. Some
    of our functions return values, others alter properties directly. Let''s assume
    we have a function called `dummyUnitTest()`, which takes a single argument: `functioninput`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ImpactJS脚本中最基本的组件之一是函数。我们的一些函数返回值，其他函数直接改变属性。假设我们有一个名为`dummyUnitTest()`的函数，它接受一个参数：`functioninput`。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An `inputnumber` variable can be any number, but our function transforms the
    `inputnumber` variable into an `outputnumber` variable, which it then returns.
    The `inputnumber` variable raised to the power of two should always return a positive
    number. So we can say at least two things about what we expect from this function:
    the output cannot be null and it cannot be negative.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputnumber`变量可以是任何数字，但我们的函数将`inputnumber`变量转换为`outputnumber`变量，然后返回它。`inputnumber`变量的平方应该始终返回一个正数。所以我们至少可以说两件事关于我们对这个函数的期望：输出不能为null，也不能为负数。'
- en: 'We can unit test this function by adding `assert` functions dedicated to checking
    certain conditions. An `assert` function checks a condition and when it is false,
    it will write a message to the console log. The console element itself has this
    function but so does ImpactJS when the debug module is activated. The `ig.assert()`
    function is the ImpactJS equivalent of the `Console.assert()` function. Remember
    that activating ImpactJS debugging can be done by including `''impact.debug.debug''`
    in the `main.js` file. Using the `ig.assert` function is preferable over the `console.assert()`
    function. This is because getting rid of the `ig` class messages when preparing
    to launch the game is done simply by turning off the ImpactJS debug module. Methods
    of the console class, such as the `console.assert()` call would need to be turned
    off separately. In general, the `assert()` function looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加专门用于检查特定条件的`assert`函数来对这个函数进行单元测试。`assert`函数检查一个条件，当条件为假时，它会将消息写入控制台日志。控制台元素本身具有这个函数，当调试模块被激活时，ImpactJS也有这个函数。`ig.assert()`函数是`Console.assert()`函数的ImpactJS等价物。记住，通过在`main.js`文件中包含`'impact.debug.debug'`来激活ImpactJS调试。使用`ig.assert`函数优于`console.assert()`函数。这是因为在准备启动游戏时，通过简单地关闭ImpactJS调试模块来摆脱`ig`类消息。控制台类的方法，如`console.assert()`调用需要单独关闭。一般来说，`assert()`函数看起来像这样：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For our specific example we could perform several tests as shown in the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的具体示例，我们可以执行几个测试，如下所示的代码：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We could go on, and this method is not without the pitfall of overkill. But
    in general, when you plan on building a very complex game, unit testing can help
    out tremendously by reducing the time you will spend looking for the source of
    logical errors. For example, if in this case our output was a negative number,
    the function itself will not fail; maybe most of the code that relies on this
    function will not either, but somewhere down the chain, something will. While
    introducing all these dependencies, one function built on top of another and so
    on, unit testing is certainly justified.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续，这种方法并不是没有过度的缺陷。但一般来说，当你计划构建一个非常复杂的游戏时，单元测试可以通过减少你寻找逻辑错误源的时间来极大地帮助你。例如，在这种情况下，如果我们的输出是一个负数，函数本身不会失败；也许大部分依赖于这个函数的代码也不会失败，但在链条的某个地方，会有问题。在引入所有这些依赖关系的同时，一个函数建立在另一个函数之上，依此类推，单元测试是完全合理的。
- en: Next to the `ig.assert()` and `ig.log()` function is another interesting function.
    It is the ImpactJS equivalent of the `console.log()` function and will write to
    the log at all times, without checking certain conditions. This can be useful
    for keeping an eye on an enemy's health without having to look for it in the **Document
    Object Model** (**DOM**).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ig.assert()`和`ig.log()`函数旁边还有另一个有趣的函数。它是`console.log()`函数的ImpactJS等价物，将始终写入日志，而不检查特定条件。这对于在不必在**文档对象模型**（**DOM**）中寻找的情况下关注敌人的健康状况非常有用。
- en: 'Let''s quickly recap what unit testing is about before moving on to our own
    ImpactJS debug panel:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在继续使用我们自己的ImpactJS调试面板之前，快速回顾一下单元测试的内容：
- en: Unit testing is about foreseeing what you expect your code components to do,
    and returning and checking the output validity.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试是关于预见您期望代码组件执行的操作，并返回和检查输出的有效性。
- en: We use the `ig.assert()` or `console.assert()` function to check certain conditions
    and print a message to the log if they are violated.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`ig.assert()`或`console.assert()`函数来检查某些条件，并在违反条件时向日志打印消息。
- en: Adding your own debug panel to the ImpactJS debugger
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将您自己的调试面板添加到ImpactJS调试器
- en: As stated earlier, activating the debug panel is done by simply including the
    `'impact.debug'` statement in the `main.js` file. When starting a new game, the
    panel is minimized at the bottom of the screen and can be made entirely visible
    by simply clicking on it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过简单地在`main.js`文件中包含`'impact.debug'`语句来激活调试面板。开始新游戏时，面板会最小化显示在屏幕底部，只需点击即可完全显示。
- en: 'Let''s get round to building our own panel, which will enable us to activate
    and deactivate entities while playing the game. This way we can venture unharmed,
    past our most ferocious enemies by freezing them in position. Let''s get to it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们自己的面板，这将使我们能够在玩游戏时激活和停用实体。这样我们就可以在游戏中毫无阻碍地通过最凶猛的敌人，通过冻结它们的位置。让我们开始吧：
- en: Open a new file and save it as `MyDebugPanel.js`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件，将其保存为`MyDebugPanel.js`。
- en: 'Insert the following code in the file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中插入以下代码：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Before we actually define our panel, we will inject code in two ImpactJS core
    classes: `Game` and `Entity`. Injecting code is like extending, except we don''t
    make a new class. The original code is replaced by an extended version of itself.
    In the previous code we tell the core `loadlevel()` function to load our panel
    as well, which will be called a **Fancy panel**.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实际定义面板之前，我们将在两个ImpactJS核心类中注入代码：`Game`和`Entity`。注入代码就像扩展一样，只是我们不创建一个新类。原始代码被其扩展版本所替换。在前面的代码中，我们告诉核心`loadlevel()`函数也要加载我们的面板，这将被称为**Fancy
    panel**。
- en: 'We then upgrade our core entity code by adding a new property: `_shouldUpdate`,
    as shown in the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过在核心实体代码中添加一个新属性`_shouldUpdate`来升级，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When true, the entity's `update` method will be called, which is also the default
    method. However, when false, the `update()` function is bypassed and no real action
    will be performed by the entity.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当为true时，实体的`update`方法将被调用，这也是默认方法。但是，当为false时，`update()`函数将被绕过，并且实体不会执行任何实际操作。
- en: 'Now let''s have a look at the panel itself. We can see the following code contained
    in the panel:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来看看面板本身。我们可以看到面板中包含以下代码：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our fancy panel is initialized as an extension of the panel of ImpactJS, called
    the `DebugPanel`. Calling the `this.parent` function will make sure a DIV container
    is supplied to the panel so that it can be shown in HTML5\. The container would
    not hold anything if there were no entities in the game, so then a message is
    placed instead. For example, this will be the case for our start and end screens.
    Since the `this.container.innerHTML` function will hold the panel's content, opening
    the panel while in the start screen should result in the message **Entities not
    loaded yet**.![Adding your own debug panel to the ImpactJS debugger](img/4568_5_1.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的花哨面板被初始化为ImpactJS面板的扩展，称为`DebugPanel`。调用`this.parent`函数将确保向面板提供一个DIV容器，以便它可以在HTML5中显示。如果游戏中没有实体，容器将不包含任何内容，因此会放置一条消息。例如，这将是我们的开始和结束屏幕的情况。由于`this.container.innerHTML`函数将保存面板的内容，因此在开始屏幕中打开面板应该会显示消息**Entities
    not loaded yet**。
- en: 'To display the previous message we should add the following code within the
    `this.container.innerHTML` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示先前的消息，我们应该在`this.container.innerHTML`函数中添加以下代码：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On loading the level, our panel is filled with all the entities in the game
    and the option to turn their `update()` functions off. Also, their health is shown.
    The `addOption()` function is what makes it possible to switch the `_shouldUpdate`
    property from true to false and back, whenever needed. It takes two arguments:
    a label and the variable that needs to alternate between true and false.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载级别时，我们的面板将填充游戏中的所有实体，并提供关闭它们的`update()`函数的选项。还会显示它们的健康状况。`addOption()`函数使得可以在需要时从true切换到false，并反之。它接受两个参数：一个标签和需要在true和false之间交替的变量。
- en: 'These last functions are not used for our particular panel but are useful nonetheless.
    The following code explains the previous functions:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些最后的函数并没有用于我们特定的面板，但仍然很有用。以下代码解释了先前的函数：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The main difference between the `load()`, `ready()`, `beforeRun()`, and `afterRun()`
    function is the moment they are called within the game. Depending on your needs,
    you will use one, the other, or a combination. We used the `load()` method, which
    is called when a level is loaded. But for other panels you might want to use the
    other methods.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`load()`、`ready()`、`beforeRun()`和`afterRun()`函数之间的主要区别在于它们在游戏中被调用的时刻。根据您的需求，您将使用一个，另一个或者组合。我们使用了`load()`方法，它在加载级别时被调用。但对于其他面板，您可能希望使用其他方法。'
- en: 'As a last step, we actually add the customized panel to our set of standard
    panels as shown in the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，我们实际上将定制面板添加到我们的标准面板集中，如下所示：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Reload your game and take a look at your new panel. Try freezing your enemies!
    You will notice that the enemies will still face the player but not move towards
    him. This is because we disabled their `update()` method but not their `draw()`
    methods.![Adding your own debug panel to the ImpactJS debugger](img/4568_5_2.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加载游戏，看看您的新面板。尝试冻结您的敌人！您会注意到敌人仍然会面对玩家，但不会朝向他移动。这是因为我们禁用了它们的`update()`方法，但没有禁用它们的`draw()`方法。
- en: 'We will now move on to using game data, but let''s first have a look at what
    we just covered:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续使用游戏数据，但让我们首先看一下我们刚刚涵盖的内容：
- en: ImpactJS has a very interesting debugger for which you can design your own panels.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImpactJS有一个非常有趣的调试器，您可以设计自己的面板。
- en: Activating the ImpactJS debugger is done by including the `'impact.debug.debug'`
    command in your main script.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在主脚本中包含`'impact.debug.debug'`命令来激活ImpactJS调试器。
- en: We made ourselves a panel by extending the ImpactJS `DebugPanel` class. Our
    own panel needs to enable us to freeze any entity into position, so we can explore
    our levels unimpeded.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过扩展ImpactJS的`DebugPanel`类制作了自己的面板。我们自己的面板需要让我们能够将任何实体冻结在位置上，这样我们就可以无阻碍地探索我们的关卡。
- en: Making use of a technique called injection; we changed our core entity class
    so that the debug panel gets to control the `update` function of every entity.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用一种称为注入的技术；我们改变了我们的核心实体类，以便调试面板可以控制每个实体的`update`函数。
- en: Finally we added our debug panel to the standard set so that it becomes available
    to us at all times.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将我们的调试面板添加到标准设置中，以便随时可用。
- en: Handling game data
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理游戏数据
- en: 'Working with data can be essential for game building. Simple games do not need
    explicit data management. However, when we start looking at games that feature
    conversations or keep high-scores, understanding data handling becomes an important
    topic. We will talk about two things:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据对于游戏构建可能是至关重要的。简单的游戏不需要显式的数据管理。然而，当我们开始研究那些包含对话或保持高分的游戏时，理解数据处理就成为一个重要的话题。我们将讨论两件事：
- en: Bringing data into your game
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据引入游戏
- en: Storing data that is generated in a game
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在游戏中生成的数据
- en: 'For the latter we will have a look at two different ways of tackling the problem:
    cookies and the lawnchair application.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后者，我们将看看解决问题的两种不同方式：cookie和lawnchair应用程序。
- en: Let's first have a look at what we need to do if we want to introduce data for
    a conversation between an NPC and a player.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看如果我们想要在NPC和玩家之间的对话中引入数据，我们需要做些什么。
- en: Adding data to your game
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向游戏添加数据
- en: As mentioned before, RPGs are often packed with conversations between the player
    and several non-playable characters (NPCs). In these conversations the player
    is given several options when it is his time to answer. The code mechanics for
    this can get pretty complicated and we will get to that later in this chapter,
    but first we need the actual sentences themselves. We can prepare these in an
    application such as Excel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，RPG游戏通常充满了玩家和多个非玩家角色（NPC）之间的对话。在这些对话中，玩家在回答时会有几个选项。这方面的代码机制可能会变得非常复杂，我们将在本章后面详细介绍，但首先我们需要实际的句子。我们可以在诸如Excel之类的应用程序中准备这些句子。
- en: '![Adding data to your game](img/4568_5_3.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![向游戏添加数据](img/4568_5_3.jpg)'
- en: 'Setting up RPG conversations is an art; there are many ways to do it, each
    with its pros and cons. Creating a decent conversation setup and flow, even database-wise,
    is a discussion that reaches beyond the scope of this book. Here we will try to
    keep it simple and work with two tables: one for all the things an NPC can say
    and one for what the player can answer. The flow of a conversation for our game
    will be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 设置RPG对话是一门艺术；有许多方法可以做到这一点，每种方法都有其优缺点。创建一个体面的对话设置和流程，甚至是数据库方面的，是一个超出本书范围的讨论。在这里，我们将尽量简单，并与两个表一起工作：一个用于NPC可以说的所有事情，另一个用于玩家可以回答的事情。我们游戏中对话的流程将如下：
- en: The NPC says something. Everything an NPC can say has a unique key called **NPC_CONVO_KEY**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NPC说了些什么。NPC可以说的一切都有一个名为**NPC_CONVO_KEY**的唯一键。
- en: The player is presented with a set of possible answers. Every set gets a key
    called **REPLY_SET_KEY**. In addition to that, although it will not be used by
    us, every answer has its own unique key, which we call **UNIQUE_REPLY_KEY**. It
    is essentially a good practice to have primary keys available, even if you don't
    use them just yet.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家将被呈现一组可能的答案。每组都有一个名为**REPLY_SET_KEY**的键。除此之外，虽然我们不会使用它，但每个答案都有自己的唯一键，我们称之为**UNIQUE_REPLY_KEY**。即使你现在不使用它们，拥有主键也是一个很好的做法。
- en: 'The player selects one of the answers. An answer has a foreign key, which leads
    back to the NPC. We named this foreign key: **NPC_CONVO_KEY**.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家选择其中一个答案。答案有一个外键，指向NPC。我们将这个外键命名为**NPC_CONVO_KEY**。
- en: Using **NPC_CONVO_KEY**, the NPC knows what to say next, and we have completed
    the loop. This will go on until the conversation is abruptly aborted or naturally
    comes to an end.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**NPC_CONVO_KEY**，NPC知道接下来该说什么，我们已经完成了循环。这将继续进行，直到对话被突然中止或自然结束。
- en: The actual sentences are kept in the variables **PC_SPEECH** and **NPC_SPEECH**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的句子保存在变量**PC_SPEECH**和**NPC_SPEECH**中。
- en: 'We can easily prepare our data in an Excel document but we still need to import
    it into our game. We will do this by using a converter such as the one on the
    following website: [http://shancarter.com/data_converter/](http://shancarter.com/data_converter/).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Excel文档中轻松准备我们的数据，但我们仍需要将其导入到我们的游戏中。我们将使用转换器，例如以下网站上的转换器：[http://shancarter.com/data_converter/](http://shancarter.com/data_converter/)。
- en: Simply copy and paste the data from Excel to the converter and select **JSON-Column
    Arrays** to get your data in the JSON-format documents.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将数据从Excel复制粘贴到转换器中，并选择**JSON-Column Arrays**，即可将数据转换为JSON格式文档。
- en: 'Once we have it in this format, all we need to do is copy and paste the data
    to separate modules. The following code is what our excel data looks like once
    it is converted to JSON:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种格式存在，我们所需要做的就是将数据复制粘贴到单独的模块中。以下代码是我们的Excel数据转换为JSON后的样子：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We store the data in JSON format just like the Weltmeister does with the level
    files. The following code is the player''s speech data turned into JSON:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据以JSON格式存储，就像Weltmeister对级别文件所做的那样。以下代码是玩家的语音数据转换为JSON后的样子：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All that remains now is putting the data inside our game directory and including
    both files in the `main.js` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是将数据放入我们的游戏目录，并在`main.js`文件中包含这两个文件：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you were to reload your game, you should be able to explore your newly introduced
    data in the DOM with the Firebug application as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新加载游戏，您应该能够在Firebug应用程序中探索您新引入的数据，如下面的屏幕截图所示：
- en: '![Adding data to your game](img/4568_5_4.jpg)![Adding data to your game](img/4568_5_5.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![向游戏添加数据](img/4568_5_4.jpg)![向游戏添加数据](img/4568_5_5.jpg)'
- en: 'Now that we have taken a look at how to introduce data, let''s take a look
    at two ways to store data on the player''s computer, starting with cookies. But
    let''s first summarize what we have done here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了如何引入数据，让我们来看一下两种在玩家计算机上存储数据的方法，首先是使用cookie。但首先让我们总结一下我们在这里所做的事情：
- en: Setting up conversations is an art form, which will not be explored in depth
    in this chapter
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置对话是一门艺术，本章不会深入探讨
- en: We set up a simple conversation in Excel or an equivalent application
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在Excel或等效应用程序中设置了一个简单的对话
- en: This Excel sheet is converted to a JSON-format document. You can do this by
    using online converters such as the one on [http://shancarter.com/data_converter/](http://shancarter.com/data_converter/)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个Excel表格被转换为JSON格式的文档。您可以使用在线转换器来做到这一点，比如[http://shancarter.com/data_converter/](http://shancarter.com/data_converter/)
- en: We turn the new JSON encoded data into ImpactJS modules
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将新的JSON编码数据转换为ImpactJS模块
- en: Finally we include the two newly created data modules in our main script
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们在我们的主脚本中包含了这两个新创建的数据模块
- en: Using cookies to store data on the player's computer
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cookie在玩家的计算机上存储数据
- en: Cookies are not much more than a piece of string data stored in your browser
    and are used by many websites to track visitors. If you are a user of Google Analytics,
    you probably know that Google provides a script that places several different
    cookies per visitor. Google Analytics is not the only program that works this
    way. After a good day of surfing the Internet, your browser is full of cookies;
    some of them will remain there for several months until finally deleting themselves.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie不过是存储在浏览器中的一段字符串数据，许多网站用它来跟踪访问者。如果您使用Google Analytics，您可能知道Google提供了一个脚本，为每个访问者放置了几个不同的cookie。Google
    Analytics并不是唯一以这种方式工作的程序。在一天愉快的上网之后，您的浏览器中充满了cookie；其中一些将在几个月内保留，直到最终删除自己。
- en: Storing information such as the player's name and high score in the user's browser
    makes sense; no storage is needed from your side, thus, no need for PHP or SQL
    coding. The downside is the loss of data if the player decides it's time to clean
    up his browser. Also, there is no real one-to-one relationship with the player
    while using cookies. One person can have several devices and even several browsers
    per device. Cookies are thus recommended for games you always replay from the
    start. It is certainly not good for games that require a massive time investment
    from the player; for instance, MMORPGs (Massively Multiplayer Online Role Playing
    Games) tend to do. For these more advanced games, working with accounts and server-side
    databases is the way to go.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户的浏览器中存储玩家姓名和最高分等信息是有意义的；您不需要从您这边进行存储，因此不需要PHP或SQL编码。缺点是如果玩家决定清理浏览器，数据将丢失。此外，在使用cookie时与玩家之间没有真正的一对一关系。一个人可以有多个设备，甚至每个设备可以有多个浏览器。因此，建议对您总是从头开始重玩的游戏使用cookie。对于需要玩家大量时间投入的游戏来说，这显然不适用；例如，大型多人在线角色扮演游戏（MMORPGs）往往是如此。对于这些更高级的游戏，使用帐户和服务器端数据库是正确的方式。
- en: 'Let''s build ourselves a cookie plugin, using the following steps, which will
    be able to store the player''s name so that we can retrieve it when restarting
    the game:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤构建一个能够存储玩家姓名的cookie插件，这样我们可以在重新开始游戏时检索它：
- en: 'Open a new file and save it as `cookie.js`. Insert basic class extension code
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件，将其保存为`cookie.js`。插入基本的类扩展代码如下：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We start off by defining our cookie plugin as an ImpactJS class extension.
    We know it will have to store a username later on, so let''s initialize it with
    the value `null`. The first thing our new DOM object will do, when created, is
    call the `checkCookie()` function. The `checkCookie()` function will check if
    there is already a cookie with the same username stored inside. There are of course
    two possibilities here: either it exists or it doesn''t. If it doesn''t, the name
    needs to be prompted and stored. If the username was stored before, it can be
    retrieved.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将我们的cookie插件定义为ImpactJS类扩展。我们知道它以后将需要存储用户名，所以让我们用值`null`来初始化它。我们的新DOM对象创建时，第一件事就是调用`checkCookie()`函数。`checkCookie()`函数将检查是否已经存在存储了相同用户名的cookie。当然这里有两种可能性：存在或不存在。如果不存在，需要提示并存储名称。如果用户名以前已存储，可以检索出来。
- en: 'Putting a cookie in place is done with the `setCookie()` function as shown
    in the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将cookie放置在位置上是使用`setCookie()`函数完成的，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function takes in three arguments:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数接受三个参数：
- en: '`c_name`: The name of the variable it needs to store, which is the username'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c_name`：它需要存储的变量的名称，即用户名'
- en: '`value`: The value of the username'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：用户名的值'
- en: '`exdays`: The number of days the cookie is allowed to exist until it should
    delete itself from the browser'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exdays`：cookie允许存在的天数，直到它应该从浏览器中删除自己'
- en: The `setcookie()` function serves to check the input data's validity. The value
    is transformed, so it's more difficult for an amateur hacker to insert damaging
    code instead of a name. The data is then stored in the `document.cookie` variable,
    a part of the DOM that stores all the cookies and is not lost while closing the
    page. Going into the intricate working of the `document.cookie` variable will
    lead us too far but it behaves very peculiarly. Assigning a value to the `document.cookie`
    variable, as shown in the previous code snippet, will not replace what was already
    in there with the newly assigned value. Instead, it will be added to the rest
    of the stack.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setcookie()`函数用于检查输入数据的有效性。该值被转换，因此业余黑客更难插入有害代码而不是名称。然后将数据存储在`document.cookie`变量中，这是DOM的一部分，它存储所有cookie，并在关闭页面时不会丢失。深入研究`document.cookie`变量的工作方式将使我们走得太远，但它的行为非常奇特。如前面的代码片段所示，将值分配给`document.cookie`变量不会用新分配的值替换已经存在的值。相反，它将添加到堆栈的其余部分。'
- en: 'If there is a `setCookie()` function, there is of course a `getCookie()` function
    as shown in the following code snippet:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有`setCookie()`函数，当然也有`getCookie()`函数，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous code will decode the transformed cookie and return it. Its sole
    input argument is the name of the variable you are looking for.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码将解码转换后的cookie并返回它。它的唯一输入参数是您要查找的变量的名称。
- en: In programming, especially in Java, it is very common to use a combination of
    the `set` and `get` functions to change properties. So using this programming
    logic, a `health` property for instance should always have a `setHealth()` and
    `getHealth()` function. Changing parameters directly has advantages and disadvantages.
    The main advantage of directly changing properties is pragmatism; things remain
    easy and intuitive to understand. A big downside is the struggle to maintain code
    validity. If everything can just change any property of any entity from anywhere,
    you can end up with serious issues if you lose sight of things.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编程中，特别是在Java中，很常见使用`set`和`get`函数的组合来更改属性。因此，根据这种编程逻辑，例如`health`属性应该始终具有`setHealth()`和`getHealth()`函数。直接更改参数有优点和缺点。直接更改属性的主要优点是实用主义；事情保持简单和直观。一个很大的缺点是维护代码的有效性的挑战。如果任何地方都可以随意更改任何实体的任何属性，如果失去了对事物的视野，就会出现严重问题。
- en: 'The `checkCookie()` function checks if the username is present in the browser
    by use of the `getCookie()` function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`checkCookie()`函数通过使用`getCookie()`函数检查浏览器中是否存在用户名：'
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If a cookie is present, a `setUserName()` function is called using the fetched
    username as an input parameter. If no cookie is present, the player is prompted
    to insert his or her name and this is subsequently stored with the `setCookie()`
    function.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在cookie，则使用获取的用户名作为输入参数调用`setUserName()`函数。如果没有cookie，则提示玩家插入他/她的名字，然后使用`setCookie()`函数存储。
- en: 'The `getUserName()` and `setUserName()` functions are kept relatively basic
    for this example, as shown in the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getUserName()`和`setUserName()`函数在本示例中保持相对基本，如下面的代码所示：'
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `setUsername()` and `getUsername()` functions could be left out by directly
    getting or setting the `this.username` command with the `checkCookie()` and `setCookie()`
    functions. However, as said earlier, it is a good programming practice to use
    the `set` and `get` statements wherever a property needs to be changed. As seen
    in the `setUserName()` function, some extra checks can be built into these functions.
    While the `getCookie()` and `setCookie()` functions make sure the data is stored
    in a harmless way and fetched appropriately, the `setUserName()` and `getUserName()`
    functions can be used to check other constraints, such as name length.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setUsername()`和`getUsername()`函数可以通过直接使用`checkCookie()`和`setCookie()`函数来获取或设置`this.username`命令来省略。然而，正如前面所说的，使用`set`和`get`语句是一种良好的编程实践，无论何时需要更改属性。正如在`setUserName()`函数中所看到的，这些函数可以内置一些额外的检查。虽然`getCookie()`和`setCookie()`函数确保数据以无害的方式存储和适当获取，但`setUserName()`和`getUserName()`函数可以用于检查其他约束，例如名称长度。'
- en: 'Now that we have finished our cookie extension, we can actually make use of
    it. Open the `main.js` file and add the following two lines to the `GameInfo`
    class:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的cookie扩展，我们实际上可以利用它。打开`main.js`文件，并将以下两行添加到`GameInfo`类中：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `GameInfo` class is perfect for this; everything we want to remain available
    outside of a game instance needs to be gathered in the `GameInfo` class. Separating
    the data component from the game logic as much as possible is a way of keeping
    things clean and understandable when a game grows more complex.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameInfo`类非常适合这个；我们希望在游戏实例之外保持可用的所有内容都需要在`GameInfo`类中收集。尽可能将数据组件与游戏逻辑分离是保持代码清晰和易于理解的一种方式，当游戏变得更加复杂时。'
- en: Our first code line will create an `ig.cookie` array and immediately check if
    a username is present. If it is not present, a prompt will appear and the name
    will be stored after the player has filled out the prompt alert.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一行代码将创建一个`ig.cookie`数组，并立即检查用户名是否存在。如果不存在，将出现提示，并在玩家填写提示警报后存储该名称。
- en: The second line simply hands over the username to the `GameInfo` object that
    we first encountered in [Chapter 3](ch03.html "Chapter 3. Let's Build a Role Playing
    Game"), *Let's Build a Role Playing Game*. As you might remember, we used the
    `GameInfo.name` variable in the beginning of this chapter but it was undefined.
    Now it will be set to `null` until the player gives his name and is, henceforth,
    used for every game he plays.![Using cookies to store data on the player's computer](img/4568_5_6.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二行简单地将用户名传递给我们在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")中首次遇到的`GameInfo`对象，*让我们建立一个角色扮演游戏*。您可能还记得，我们在本章的开头使用了`GameInfo.name`变量，但它是未定义的。现在它将被设置为`null`，直到玩家给出他的名字，并且以后用于他玩的每个游戏。![使用cookie在玩家的计算机上存储数据](img/4568_5_6.jpg)
- en: Initially the player's name will be unknown, and **null** would be shown on
    the screen as shown in the previous screenshot.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，玩家的名字将是未知的，并且在屏幕上将显示**null**，如前一个截图所示。
- en: '![Using cookies to store data on the player''s computer](img/4568_5_7.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![使用cookie在玩家的计算机上存储数据](img/4568_5_7.jpg)'
- en: However, the player is prompted to fill out his or her name in the window as
    shown in the previous screenshot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，玩家被提示在窗口中填写他或她的名字，如前一个截图所示。
- en: '![Using cookies to store data on the player''s computer](img/4568_5_8.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用cookie在玩家的计算机上存储数据](img/4568_5_8.jpg)'
- en: Henceforth, the real name is shown on the screen as shown in the previous screenshot.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，真实姓名将如前一个截图所示地显示在屏幕上。
- en: 'While you should be able to get around using cookies, there is another way
    to store data, which is probably more versatile and easy to use: lawnchair. The
    lawnchair application makes use of the HTML5 local storage, also known as the
    DOM storage. Before moving on to the lawnchair application, we will take a quick
    peek into how to use HTML5 local storage even without using the lawnchair application:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您应该能够绕过使用cookie，但还有另一种存储数据的方式，可能更多功能和易于使用：lawnchair。lawnchair应用程序利用HTML5本地存储，也称为DOM存储。在转向lawnchair应用程序之前，我们将快速了解如何在不使用lawnchair应用程序的情况下使用HTML5本地存储：
- en: Cookies are a way of storing data in the player's browser. Many websites make
    use of them including the web analytics platform, Google Analytics. Cookies are
    useful for short games that are meant to be played of and over again, not for
    complicated games that require many things to be stored over a long period of
    time.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie是一种在玩家浏览器中存储数据的方式。许多网站使用它们，包括网络分析平台Google Analytics。Cookie对于短时间内反复玩的游戏很有用，而不适用于需要长时间存储许多东西的复杂游戏。
- en: We can implement the use of cookies by creating a `cookies` plugin. This plugin,
    once activated, will check whether a cookie is already active and place one if
    none is found.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个`cookies`插件来实现使用cookie。一旦激活了这个插件，它将检查是否已经存在cookie，如果没有找到，则放置一个。
- en: In this example, we use cookies to store and retrieve the player's name, which
    we first ask him to fill out if no cookie is in place.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用cookie来存储和检索玩家的名字，如果没有cookie，我们首先要求他填写。
- en: Emphasis is put on the use of the `set()` and `get()` functions. These functions
    are a standard practice in Java and are a useful technique to keep sight of things
    and check the validity of any property in the code that grows even more complex.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重点放在使用`set()`和`get()`函数上。这些函数是Java中的标准做法，是一种有用的技术，可以在代码中保持对事物的视野，并检查任何属性的有效性，即使代码变得更加复杂。
- en: Local storage
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地存储
- en: 'Local storage, also known as DOM storage, is an HTML5 feature that allows you
    to save information on the user''s computer. It is superior to cookies in almost
    every way but the older browsers do not support it. Using local storage is rather
    straightforward as we can see in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储，也称为DOM存储，是HTML5的一个功能，允许您在用户的计算机上保存信息。它几乎在所有方面都优于cookie，但是旧版浏览器不支持它。使用本地存储相当简单，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This plugin is not strictly necessary in order to make use of local storage.
    It is merely an extension with the `get` and `set` technique in order to check
    data validity. You can use the plugin by including the `'plugins.data.local'`
    command in your `main.js` script and calling the `setData()` and `getData()` functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件并不是必需的，以便使用本地存储。它只是一个扩展，使用`get`和`set`技术来检查数据的有效性。您可以通过在`main.js`脚本中包含`'plugins.data.local'`命令并调用`setData()`和`getData()`函数来使用该插件。
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we'll take a quick look at how to use local storage in general; let's look
    at what the lawnchair application has to offer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来快速看一下如何一般使用本地存储；让我们看看lawnchair应用程序提供了什么。
- en: Using lawnchair as a versatile way of storing data
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lawnchair作为存储数据的多功能方式
- en: 'The lawnchair application is a free and very professional solution for storing
    data on the client side. It is capable of storing data in several ways, and a
    plugin for ImpactJS is readily available. Let''s look at how to use the lawnchair
    application to store data:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: lawnchair应用程序是在客户端存储数据的免费且非常专业的解决方案。它能够以多种方式存储数据，并且ImpactJS的插件已经准备就绪。让我们看看如何使用lawnchair应用程序来存储数据：
- en: 'Download the lawnchair application from the following website: [http://brian.io/lawnchair/](http://brian.io/lawnchair/),
    or you can download the ImpactJS adapted version on [https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS](https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS).'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下网站下载lawnchair应用程序：[http://brian.io/lawnchair/](http://brian.io/lawnchair/)，或者您可以在[https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS](https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS)上下载适用于ImpactJS的版本。
- en: Place the files in your `plugin` folder. In this example, they are placed in
    separate subfolders called `data` and `Lawnchair`. However, you are free to use
    any structure you want, as long as you make sure to change the code accordingly.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件放入您的`plugin`文件夹中。在这个例子中，它们被放在名为`data`和`Lawnchair`的单独子文件夹中。但是，只要确保相应地更改代码，您可以自由使用任何结构。
- en: 'Include the `impact-plugin` file in your `main.js` file as shown in the following
    code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`main.js`文件中包含`impact-plugin`文件，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add a store element to your `GameInfo` class by the use of the newly acquired
    `ig.Lawnchair()` method as shown in the following code line:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用新获得的`ig.Lawnchair()`方法，将存储元素添加到您的`GameInfo`类中，如下面的代码行所示：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `ig.Lawnchair()` method takes two input parameters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ig.Lawnchair()`方法接受两个输入参数：'
- en: 'The first parameter is the most important one and is actually an array. In
    this array you will need to specify two things: which method you want to use to
    store everything, and the name of the data storage you want to create. The first
    variable is called the `adaptor` because the lawnchair application uses the adaptor
    pattern technique to decide what needs to happen next. The lawnchair application
    is programmed very efficiently and this immediately becomes apparent by this use
    of patterns. An adaptor pattern is essentially a piece of code that will link
    your own code to that of the lawnchair application''s storing system. Without
    this pattern, it would be really difficult to communicate with the actual lawnchair
    application''s source code, which saves your data. Here we choose to save it as
    a permanent DOM storage, but other options such as Webkit-SQLite are available.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是最重要的，实际上是一个数组。在这个数组中，您需要指定两件事情：您想要使用哪种方法来存储所有内容，以及您想要创建的数据存储的名称。第一个变量称为`adaptor`，因为lawnchair应用程序使用适配器模式技术来决定接下来需要发生什么。lawnchair应用程序编程非常高效，通过使用模式立即变得明显。适配器模式本质上是一段代码，将您自己的代码链接到lawnchair应用程序的存储系统。没有这种模式，要与实际的lawnchair应用程序源代码进行通信将会非常困难。在这里，我们选择将其保存为永久DOM存储，但也可以选择其他选项，如Webkit-SQLite。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Webkit-SQLite differs from permanent DOM storage such that it acts more like
    a regular database, but on the client's local storage. For instance, like other
    databases, you can query Webkit-SQLite storage with SQL.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Webkit-SQLite与永久DOM存储不同，它更像是一个常规数据库，但是在客户端的本地存储上运行。例如，像其他数据库一样，您可以使用SQL查询Webkit-SQLite存储。
- en: The second input parameter is an optional one. Here you can put functions that
    need to be executed when the `store` variable is prepared. This is the perfect
    place to put log messages.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个输入参数是可选的。在这里，您可以放入需要在准备好`store`变量时执行的函数。这是放置日志消息的完美位置。
- en: Now that we have our store element ready to go, it is just a matter of storing
    whatever data you want by calling the `store.save()` method. Let's say we want
    to store our player's score. For this we can add a method to our `GameInfo` class
    that does just the same.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的存储元素已经准备就绪，只需调用`store.save()`方法存储任何您想要的数据。假设我们想要存储玩家的分数。为此，我们可以向`GameInfo`类添加一个执行相同操作的方法。
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `saveScore()` function can be added to both the `gameOver()` and `gameWon()`
    methods we created while building our victory and Game-over screens as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`saveScore()`函数可以添加到我们构建胜利和游戏结束屏幕时创建的`gameOver()`和`gameWon()`方法中，如下所示：'
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the player dies or wins the game, his score is saved using the lawnchair
    permanent DOM method. Permanent DOM does not mean the DOM is saved permanently
    on the user's PC; it is merely another name for local storage.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家死亡或赢得比赛时，他的分数将使用lawnchair永久DOM方法保存。永久DOM并不意味着DOM永久保存在用户的PC上；这只是本地存储的另一个名称。
- en: 'The last important thing we need to be able to do is retrieve the data. To
    do this, we introduce three new functions to our `GameInfo` class:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要能够做的最后一件重要的事情是检索数据。为此，我们向`GameInfo`类引入了三个新函数：
- en: 'The `setScore()` function will save the input parameter as a `GameInfo.score`
    class if it is an actual number, as shown in the following code:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数是实际数字，`setScore()`函数将把输入参数保存为`GameInfo.score`类，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `getScore()` method will just return the `score value` stored in the `GameInfo.score`
    class as shown in the following code:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getScore()`方法将只返回存储在`GameInfo.score`类中的`分数值`，如下面的代码所示：'
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Neither `setScore()` nor `getScore()` seem too important, but as explained while
    looking at the concept of cookies, using the `set` and `get` statements are useful
    for doing checks on data validity.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`setScore()`和`getScore()`似乎并不太重要，但正如在查看cookies概念时所解释的，使用`set`和`get`语句对数据有效性进行检查是有用的。'
- en: 'The `GameInfo.getSavedScore()` method is the mirror opposite of the `GameInfo.saveScore()`
    method, as we can see in the following code:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameInfo.getSavedScore()`方法是`GameInfo.saveScore()`方法的镜像相反，如下面的代码所示：'
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `getSavedScore()` method makes use of the `setScore()` function to set the
    `GameInfo.score` class to the number it has withdrawn from the storage. Then it
    returns this score using the `getScore()` method where some extra tests can be
    done on data validity.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getSavedScore()`方法利用`setScore()`函数将`GameInfo.score`类设置为从存储中提取的数字，然后使用`getScore()`方法返回此分数，其中可以对数据有效性进行一些额外的测试。'
- en: You can now retrieve the last achieved score whenever you want!
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以随时检索最后达到的分数！
- en: We can adapt our opening screen so that it shows the last achieved score by
    adding the following code line to its `draw()` function.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以调整我们的开屏，以便通过将以下代码行添加到其`draw()`函数中显示最后达到的分数。
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last score of the player is displayed as shown in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的最后得分如下截图所示：
- en: '![Using lawnchair as a versatile way of storing data](img/4568_5_9.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![使用lawnchair作为存储数据的多功能方式](img/4568_5_9.jpg)'
- en: 'Enough about data storage, let''s quickly go over the differences between cookies,
    local storage, and the somewhat more versatile way of using local storage: lawnchair.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据存储的足够了，让我们快速了解一下cookies、本地存储以及使用本地存储的更多灵活的方式：lawnchair之间的区别。
- en: '|   | Storage size | Expiration date | Information safety |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|   | 存储大小 | 过期日期 | 信息安全 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Cookies** | Very limited | Fixed | Can be seen in the URL and will be sent
    to the receiving server and back to the local computer. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **Cookies** | 非常有限 | 固定 | 可以在URL中看到，并将被发送到接收服务器和返回到本地计算机。 |'
- en: '| **Local storage** | Big | Session or unlimited | Is stored on a local computer
    and nothing is sent to and from a server. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **本地存储** | 大 | 会话或无限 | 存储在本地计算机上，没有任何东西发送到服务器和从服务器返回。 |'
- en: '| **lawnchair** | Big | Depends on the chosen technique | Is stored on a local
    computer and nothing is sent to and from a server. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **lawnchair** | 大 | 取决于所选的技术 | 存储在本地计算机上，没有任何东西发送到服务器和从服务器返回。 |'
- en: In short, local storage is the newer way to save data locally. You can still
    use cookies, but the new privacy rules dictate that you must ask for permission
    before using them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本地存储是保存数据的新方法。你仍然可以使用cookies，但是新的隐私规则规定你必须在使用它们之前征得许可。
- en: 'Summing up the complete data storage concept, we conclude that:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 总结完整的数据存储概念，我们得出结论：
- en: The lawnchair application is a code package that is freely downloadable and
    can handle all your client-side storage needs. It can save using several methods,
    such as permanent DOM storage or Webkit-SQLite.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lawnchair应用程序是一个可自由下载的代码包，可以处理所有客户端存储需求。它可以使用多种方法保存，如永久DOM存储或Webkit-SQLite。
- en: The recommended downloadable code package is located at [https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS](https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS),
    since it comes with an ImpactJS plugin.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐的可下载代码包位于[https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS](https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS)，因为它带有一个ImpactJS插件。
- en: Making use of the lawnchair storage system constitutes including the library
    and initializing one of our `GameInfo` class' variables as a lawnchair application's
    object. We can then store and retrieve data through the use of the `this` object
    since it inherits all of the lawnchair methods.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用lawnchair存储系统包括包含库并将我们的`GameInfo`类的变量初始化为lawnchair应用程序的对象。然后我们可以通过使用`this`对象来存储和检索数据，因为它继承了所有的lawnchair方法。
- en: Extra functionalities for the RPG
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPG的额外功能
- en: In this section we will look at a few extra functionalities that might be particularly
    useful for a top-down game such as the **RPG** we designed in [Chapter 3](ch03.html
    "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role Playing Game*.
    First, we will implement character movement by mouse click, which is especially
    useful for mobile games, since touching the screen is the mobile equivalent of
    clicking a mouse. Then we will add a smart spawn point. This spawn point first
    checks whether spawning an entity would cause collision and adjusts its spawn
    coordinates accordingly. The third element adds conversation between the player
    and a non-playable character (NPC). The final add-on is a basic head-up display
    (HUD), which allows the players to keep track of their health.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一些额外的功能，这些功能可能对于像我们在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")中设计的RPG游戏特别有用，*让我们建立一个角色扮演游戏*。首先，我们将通过鼠标点击实现角色移动，这对于移动游戏特别有用，因为触摸屏幕相当于点击鼠标。然后我们将添加一个智能生成点。这个生成点首先检查生成实体是否会导致碰撞，并相应地调整其生成坐标。第三个元素是玩家和非玩家角色（NPC）之间的对话。最后一个附加功能是基本的头顶显示（HUD），允许玩家跟踪他们的健康状况。
- en: Moving the player with a mouse click
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过鼠标点击移动玩家
- en: 'Up until here, we moved our player around by use of the keyboard arrow keys.
    This is very intuitive, yet sometimes impossible. If you were to open your game
    on an iPad or any other mobile device, there is no way to move your character
    since no arrow keys are present. Here it would be more useful if our character
    would just walk towards the spot we touch on our screen. In ImpactJS, the mouse
    click and a touch are treated as the same thing, it just depends on the device.
    Therefore, implementing movement by a mouse click automatically results in movement
    by a touch for your mobile device. To make the player move around by clicking
    the mouse or touching the screen, you need to follow these steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们通过键盘箭头键移动我们的玩家。这是非常直观的，但有时是不可能的。如果你在iPad或其他移动设备上打开游戏，由于没有箭头键，你无法移动你的角色。在这种情况下，如果我们的角色只需朝着我们在屏幕上触摸的位置走就更有用了。在ImpactJS中，鼠标点击和触摸被视为相同的东西，这取决于设备。因此，通过鼠标点击实现移动自动导致了移动触摸设备。要使玩家通过点击鼠标或触摸屏幕移动，需要按照以下步骤进行：
- en: In the `main.js` file, bind the mouse click to the action called `'mouseclick'`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`文件中，将鼠标点击绑定到名为`'mouseclick'`的动作。
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Open the `player.js` file and add a few extra initial variables. We will need
    this once we start using the movement by a mouse function we are about to add.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`player.js`文件并添加一些额外的初始变量。一旦我们开始使用即将添加的鼠标功能，我们将需要这个。
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the `movementspeed` variable was not already there as a `"player"` property,
    be sure to add it now. The `mousewalking` command is a flag variable; a value
    of `1` means the player must walk as commanded by a mouse click. The `takemouseinput`
    variable's value is set to `1` when the mouse is clicked and immediately returned
    to `0` after the goal coordinates are calculated. Without this variable, it would
    be possible to steer your character by the position of your mouse instead of a
    single click. This is a matter of choice; steering by mouse position instead of
    mouse click can certainly be part of a valid and intuitive control scheme.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`movementspeed`变量还不是一个“player”属性，确保现在添加它。`mousewalking`命令是一个标志变量；值为`1`表示玩家必须按鼠标点击的命令行走。当鼠标被点击并且目标坐标被计算后，`takemouseinput`变量的值被设置为`1`，然后立即返回到`0`。没有这个变量，可能会通过鼠标位置来操纵你的角色，而不是单击一次。这是一个选择的问题；通过鼠标位置而不是鼠标点击来操纵可以成为有效和直观的控制方案的一部分。
- en: 'Add the `mousemovement()` method to the `"player"` entity using the following
    code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将`mousemovement()`方法添加到“player”实体：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The length of this function might be a little daunting but actually the same
    logic is repeated several times. The function basically does two things: it can
    set destination coordinates and it can make the player move towards a target.
    In most cases it will not be necessary to calculate a new target. Thus, the first
    check is whether a new destination needs to be used. For this, both `player.takemouseinput`
    and `player.mousewalking` variables need to be `true`. In the calculation of the
    target location coordinates, a correction is applied for the position of the game
    screen.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的长度可能有点令人生畏，但实际上相同的逻辑被重复了几次。该函数基本上有两个功能：它可以设置目的地坐标，也可以使玩家朝着目标移动。在大多数情况下，不需要计算新的目标。因此，第一个检查是是否需要使用新的目的地。为此，`player.takemouseinput`和`player.mousewalking`变量都需要为`true`。在计算目标位置坐标时，对游戏屏幕的位置进行了修正。
- en: Then the function proceeds with the actual movement; whether it should proceed
    or not is set by the value of the `player.mousewalking` variable (`True` or `False`).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，函数继续进行实际的移动；是否进行移动由`player.mousewalking`变量的值（`True`或`False`）设置。
- en: If the player needs to walk, the actual distance to the target is calculated
    for both the x and y axes and stored in the local variables, `distancetotargetx`
    and `distancetotargety`. When the target is within 5 pixels of the player on either
    axis, the player will not move.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家需要行走，实际距离将被计算到目标的x和y轴，并存储在本地变量`distancetotargetx`和`distancetotargety`中。当目标在任一轴上与玩家相距5像素时，玩家将不会移动。
- en: However, if the distance is greater than 5 pixels, the player will move towards
    his target in a linear manner. To make sure the player moves at the preset movement
    speed, it will do so at the axis on which the remaining distance is greatest.
    Let's say the player is far away from his target on the x axis but not so far
    on the y axis. In this case he will move at the preset movement speed on the x
    axis but less than the preset movement speed for the y axis. Also he will be facing
    left or right and not up or down.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果距离大于5像素，玩家将以线性方式朝着目标移动。为了确保玩家以预设的移动速度移动，他将在剩余距离最大的轴上这样做。假设玩家在x轴上离目标很远，但在y轴上不那么远。在这种情况下，他将以x轴上的预设移动速度移动，但在y轴上的速度小于预设移动速度。此外，他将面向左或右，而不是上或下。
- en: 'The two most important triggering variables: `player.mousewalking` and `player.takemouseinput`
    are initialized at a value of `0`; they need to be put to a value of `1` when
    a mouse click is registered. This we do in the `update()` function as shown in
    the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个最重要的触发变量：`player.mousewalking`和`player.takemouseinput`的初始值为`0`；当鼠标点击被注册时，它们需要被设置为`1`。我们在`update()`函数中执行此操作，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We just made sure that the game checks whether the mouse was clicked at every
    new frame.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚确保游戏在每个新帧都会检查鼠标是否被点击。
- en: If we now call our update function by adding a call to the `mousemovement()`
    method, the player will walk wherever a mouse click is registered on the screen.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在通过添加对`mousemovement()`方法的调用来调用我们的更新函数，玩家将在屏幕上注册鼠标点击的地方行走。
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Of course, our keyboard controls are still there and this will cause problems.
    In order to make both control methods work, all we need to do is set the value
    of the `player.mousewalking` variable to `0` every time one of the keys is pressed,
    as shown in the following code for the up arrow key:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，我们的键盘控件仍然存在，这将导致问题。为了使两种控制方法都能正常工作，我们只需要在按下键盘上的任意一个键时，将`player.mousewalking`变量的值设置为`0`，如下面的代码所示，用于上箭头键：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Whether the value of the `player.mousewalking` variable is `0` or not needs
    to be checked constantly using the following code. If not, our old control system
    will immediately stop the movement because no keyboard input was registered.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要不断使用以下代码来检查`player.mousewalking`变量的值是否为`0`。如果不是，我们的旧控制系统将立即停止移动，因为没有注册键盘输入。
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, save your files and reload the game.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存您的文件并重新加载游戏。
- en: You should now be able to run around by clicking the mouse anywhere on the screen.
    You might notice slight course adjustments if the player encounters an obstacle.
    However, he is not smart enough to actually go around it if the obstacle is too
    big. As a player, you need to steer clear of obstacles yourself.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够通过在屏幕上的任何位置单击鼠标来四处走动。如果玩家遇到障碍物，您可能会注意到轻微的航向调整。但是，如果障碍物太大，玩家就不够聪明去绕过它。作为玩家，您需要自己避开障碍物。
- en: 'Let''s have a look at how to create an intelligent spawn location. But before
    we do so, let''s recap what was just covered:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个智能的生成位置。但在这样做之前，让我们回顾一下刚刚讨论的内容：
- en: Being able to move the player with a mouse click is an interesting feature when
    moving to mobile devices, since there the keyboard is not an option. With ImpactJS,
    the click of a mouse is considered the same as touching the screen of an iPad.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过鼠标点击移动玩家是一个有趣的功能，尤其是在移动到移动设备时，因为在那里键盘不是一个选项。在ImpactJS中，鼠标的点击被视为与触摸iPad屏幕相同。
- en: Currently our player can move around with the keyboard so we need to implement
    the possibility to use both the keyboard arrow keys and the mouse. All adjustments
    for this will take place within the player entity.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，我们的玩家可以使用键盘四个方向键移动，因此我们需要实现同时使用键盘方向键和鼠标的可能性。所有这些调整将在玩家实体内进行。
- en: We introduced a new method called `mousemovement()`, which is repeatedly called
    in the player's `update` function. At all times, our method will check whether
    the command for moving by a mouse click was given, and if so will move the player
    to the desired location.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们引入了一个名为`mousemovement()`的新方法，该方法在玩家的`update`函数中被重复调用。在任何时候，我们的方法都会检查是否给出了通过鼠标点击移动的命令，如果是，将移动玩家到所需位置。
- en: In addition to adding this new method, we needed to adjust our old movement
    code so it would allow combining both the arrow keys and the newly implemented
    movement by a mouse click.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了添加这个新方法，我们还需要调整旧的移动代码，以便允许同时使用箭头键和新实现的鼠标点击移动。
- en: Adding intelligent spawn locations
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加智能生成位置
- en: 'While building a level in the Weltmeister, you can immediately add your hostile
    entities to the level itself. This is nice, but sometimes adding a bit of unpredictability
    will increase the replay value of your game. This can be done by adding intelligent
    spawning: spawning enemies on random places but taking collision with other entities
    and the collision layer into account. In order to do this, we will need to create
    a new plugin with the following steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Weltmeister中构建关卡时，可以立即将敌对实体添加到关卡本身。这很好，但有时增加一些不可预测性会增加游戏的重玩价值。这可以通过添加智能生成来实现：在随机位置生成敌人，但考虑到其他实体和碰撞层的碰撞。为了做到这一点，我们需要按照以下步骤创建一个新的插件：
- en: Create a new file and save it as `spawnlocations.js`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存为`spawnlocations.js`。
- en: Add the `'plugins.functions.spawnlocations'` command to your `main.js` file.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`'plugins.functions.spawnlocations'`命令添加到你的`main.js`文件中。
- en: 'Create an `ig.spawnlocations` variable as an extension of the ImpactJS class,
    as shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ig.spawnlocations`变量，作为ImpactJS类的扩展，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Add the `spawnIf()` method, which is a callback function as shown in the following
    code. It can call itself again when certain conditions are met.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`spawnIf()`方法，这是一个回调函数，如下面的代码所示。当满足某些条件时，它可以再次调用自身。
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `spawnIf()` function takes in an x and y start coordinate and checks if
    there is collision with the collision layer or an entity. If this is the case,
    the original coordinates are adjusted with a random number of pixels on both axes.
    These new coordinates are then resubmitted to the `spawnIf()` function until it
    finds a free spot. Once no more collision is detected, an enemy is spawned on
    that location. The `CollisionAt()` and `getEntitiesAt()` functions that it requires
    are also part of the `spawnlocations` class.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spawnIf()`函数接受一个x和y的起始坐标，并检查是否与碰撞层或实体发生碰撞。如果是这种情况，原始坐标将在两个轴上的随机像素数上进行调整。然后，这些新坐标将被重新提交给`spawnIf()`函数，直到找到一个空闲位置。一旦不再检测到碰撞，敌人就会在那个位置生成。它需要的`CollisionAt()`和`getEntitiesAt()`函数也是`spawnlocations`类的一部分。'
- en: 'The `getEntitiesAt()` function will detect entities that would be overlapping
    with the enemy that needs to spawn. The following code depicts the detection process
    applied by the `getEntitiesAt()` function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getEntitiesAt()`函数将检测与需要生成的敌人重叠的实体。以下代码描述了`getEntitiesAt()`函数应用的检测过程：'
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: One by one, the entities are checked to see whether they overlap using their
    position, width, and height. If there is an overlap with a single entity, the
    loop is aborted and the `getEntitiesAt()` function returns the value `true`. If
    no overlap was detected it will return the value `false`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个检查实体，以查看它们是否重叠，使用它们的位置、宽度和高度。如果与单个实体重叠，循环将被中止，`getEntitiesAt()`函数将返回值`true`。如果没有检测到重叠，它将返回值`false`。
- en: 'While the `getEntitiesAt()` function checks for a possible collision with other
    entities, the `CollisionAt()` function checks if the enemy would overlap with
    the collision layer, as shown in the following code snippet:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然`getEntitiesAt()`函数检查与其他实体的可能碰撞，`CollisionAt()`函数检查敌人是否会与碰撞层重叠，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The most important function is the `collisionMap` method's `trace()` function.
    The `trace()` function will check if something is between the value of the `x`
    coordinate and the sum of the values of the `x` and `ent.size.x` variable's coordinate
    or between the value of the `y` coordinate and the sum of the values of the `y`
    and `ent.size.y` variable's coordinate. The last two arguments are the `size`
    of the entity. This is normally used to check a trajectory but we are using it
    to check a specific location. If there is a collision on either the x or y axes,
    the `CollisionAt()` function will return the value `true`, and the `spawnIf()`
    function will need to look for a new spawn location.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最重要的功能是`collisionMap`方法的`trace()`函数。`trace()`函数将检查`x`坐标值和`x`和`ent.size.x`变量坐标值之和之间，或者`y`坐标值和`y`和`ent.size.y`变量坐标值之和之间是否有东西。最后两个参数是实体的`size`。这通常用于检查轨迹，但我们用它来检查特定位置。如果在x轴或y轴上发生碰撞，`CollisionAt()`函数将返回值`true`，`spawnIf()`函数将需要寻找新的生成位置。
- en: 'The last thing we need to do is actually spawn an enemy. This we can do within
    `MyGame` in the `main.js` file using the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是实际生成一个敌人。我们可以在`main.js`文件的`MyGame`中使用以下代码来实现：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: An enemy will now spawn at these coordinates if a free space is available, otherwise,
    the coordinates will be adjusted until a suitable spot is found.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有空闲空间，敌人现在将在这些坐标生成，否则，坐标将被调整，直到找到合适的位置。
- en: 'Now that we added an intelligent spawn point to our game, it is time to move
    on to a somewhat complex game element: conversation. However, before we start
    the conversation process, let''s quickly go through what we just did:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在游戏中添加了智能生成点，是时候转向一个相对复杂的游戏元素：对话。然而，在开始对话过程之前，让我们快速回顾一下我们刚刚做的事情：
- en: The purpose of the intelligent spawn point is to find an open space for an enemy
    to spawn. For this, a check with both the entities already in the game and the
    collision layer of the level will be needed.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能生成点的目的是找到一个敌人生成的开放空间。为此，需要检查游戏中已有的实体和关卡的碰撞层。
- en: 'We build a plugin that consists of three parts:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建了一个包含三个部分的插件：
- en: A callback function that will adjust the coordinates until a good location is
    found, and subsequently spawn the enemy. It makes use of the other two functions
    in our spawn point class.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个回调函数，将调整坐标直到找到一个合适的位置，并随后生成敌人。它利用了我们生成点类中的其他两个函数。
- en: The function that must check for potential overlap with other entities.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须检查潜在与其他实体的重叠的函数。
- en: A function that checks for an overlap with the collision layer.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查与碰撞层的重叠的函数。
- en: Adding an enemy to the game can now be done by initiating a new spawn point
    and using its `spawnIf()` method to put a new enemy into the gaming world.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在可以通过初始化一个新的生成点并使用其`spawnIf()`方法将新的敌人放入游戏世界来向游戏添加敌人。
- en: Introducing basic conversation
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍基本对话
- en: 'Many role playing games (RPGs) have conversations between the player and some
    of the non-playable characters (NPCs). In this section we will address a way to
    get a simple conversation into your game. The main prerequisite is the conversation
    data we added to our game earlier in this chapter. We need to build a conversation
    menu containing items that can be selected by the player using the following steps.
    Talkie, our lovely NPC from [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role
    Playing Game"), *Let''s Build a Role Playing Game*, will serve as our partner
    in crime. The player will not only have several answering options every time Talkie
    says something, but will also have the NPC react to what the player wants to say
    by opening new options. The cycle should be able to go on until all options are
    exhausted or the conversation is aborted abruptly:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 许多角色扮演游戏（RPG）中有玩家和一些不可玩角色（NPC）之间的对话。在本节中，我们将介绍一种将简单对话添加到游戏中的方法。主要前提是我们在本章前面为游戏添加的对话数据。我们需要构建一个包含可以由玩家选择的对话菜单，具体步骤如下。我们可爱的NPC
    Talkie将作为我们的合作伙伴，玩家不仅在Talkie说话时有几个回答选项，而且NPC还会根据玩家想说的话做出反应，开启新的选项。这个循环应该能够一直进行，直到所有选项耗尽或对话被突然中止：
- en: Open a new file and save it as `menu.js` in the `conversation` subfolder of
    the `plugins` folder.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件，并将其保存为`menu.js`，放在`plugins`文件夹的`conversation`子文件夹中。
- en: Add a `'plugins.conversation.menu'` command to your `main.js` file.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main.js`文件中添加一个`'plugins.conversation.menu'`命令。
- en: 'Create a `window.Menu` class as an extension of the ImpactJS class as shown
    in the following code:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`window.Menu`类，作为ImpactJS类的扩展，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our menu `init()` function will require four input variables; we will turn
    all of them into `menu` properties so they are available in our `menu` methods;
    those four input variables are as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的菜单`init()`函数将需要四个输入变量；我们将把它们都转换为`menu`属性，以便它们在我们的`menu`方法中可用；这四个输入变量如下：
- en: '`_font`: This is the font that we will be using'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_font`：这是我们将使用的字体'
- en: '`_choice_spacing`: This is the space we want between each of the choices that
    will be shown on the screen'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_choice_spacing`：这是我们希望在屏幕上显示的每个选择之间的间距'
- en: '`_choices`: This is the array of choices the player has at a specific part
    of the conversation'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _choices：这是玩家在对话特定部分拥有的选择数组
- en: '`_entity`: This is the NPC that needs to talk to the player; in this case that
    would be `Talkie`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_entity`：这是需要与玩家交谈的NPC；在这种情况下，将是`Talkie`'
- en: 'Our `init()` method contains some other important variables as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`init()`方法包含一些其他重要的变量，如下所示：
- en: '`this.selectedChoice`: This is the variable that will store the array index
    of the currently selected choice. It is initialized at a value `0`, which is always
    the first element of any array and, thus, the first option of the player. The
    `this.selectedChoice` variable is important because the symbols `<<` and `>>`
    will be shown at the sides of the currently selected option as a visual aid.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.selectedChoice`：这是将存储当前选定选择的数组索引的变量。它被初始化为值`0`，这始终是任何数组的第一个元素，因此也是玩家的第一个选项。`this.selectedChoice`变量很重要，因为符号`<<`和`>>`将显示在当前选定选项的两侧，作为视觉辅助。'
- en: '`this.cursorLeft` and `this.cursorRight`: They are the variables that store
    the visual aid symbols `<<` and `>>`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.cursorLeft`和`this.cursorRight`：它们是存储视觉辅助符号`<<`和`>>`的变量。'
- en: '`this.cursorLeftWidth` and `this.cursorRightWidth`: They are the variables
    that store the length for the `<<` and `>>` symbols for the chosen font so that
    this can be taken into account when actually drawing the choices on screen.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.cursorLeftWidth`和`this.cursorRightWidth`：它们是存储所选字体的`<<`和`>>`符号的长度的变量，以便在实际在屏幕上绘制选择时可以考虑到这一点。'
- en: '`_choices[i].labelWidth`: This local variable stores the width that has been
    calculated for each of the choices. The calculated width is then stored in the
    menu property array `choices[i].labelWidth`. The `cursorLeftWidth` and `cursorRightWidth`
    variables will be used to determine the screen positioning while drawing the options
    on screen.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_choices[i].labelWidth`：这个局部变量存储了为每个选择计算出的宽度。计算出的宽度然后存储在菜单属性数组`choices[i].labelWidth`中。`cursorLeftWidth`和`cursorRightWidth`变量将用于确定在屏幕上绘制选项时的屏幕定位。'
- en: '`this.Menubackground`: This variable will hold a black square, which serves
    as a background so that the white characters of the conversation are always readable,
    regardless of what the level currently looks like. The background adapts itself
    to the length of the longest option and the number of options. This way it doesn''t
    take more space than is absolutely necessary.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.Menubackground`：这个变量将保存一个黑色的正方形，作为背景，以便对话的白色字符始终可读，无论当前级别的外观如何。背景会根据最长选项的长度和选项的数量自适应。这样就不会占用比绝对必要更多的空间。'
- en: 'The `draw()` method holds all of the menu logic, so we will discuss it in chunks
    using the following code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`draw()`方法包含所有菜单逻辑，因此我们将使用以下代码分块讨论它：'
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first major thing the `draw()` function does is it adjusts the background
    of the menu so that it is always big enough to fit the different sentences, given
    the chosen font. This logic, among others, could just as well have been stored
    in an `update()` function instead of a `draw()` function. This is a matter of
    choice and you are of course free to rewrite the `menu` class as you please. The
    bottom line is that both the `draw()` and `update()` functions are called in every
    frame, which is the most important common attribute of these methods. In the following
    code we can check out the functionality of a `draw()` function:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`draw()`函数的第一个主要功能是调整菜单的背景，使其始终足够大，以适应不同的句子，给定所选择的字体。这种逻辑，以及其他逻辑，实际上可以存储在`update()`函数中，而不是`draw()`函数中。这是一个选择问题，您当然可以根据自己的意愿重写`menu`类。最重要的共同属性是`draw()`和`update()`函数都在每一帧中被调用。在下面的代码中，我们可以查看`draw()`函数的功能：'
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now the position of the text is determined and every choice is written on the
    screen. A check is done to see which option is currently selected. This option
    is encapsulated by the **<<** and **>>** symbols to make the player aware of what
    he is about to choose. To add these functionalities we will look into the following
    code:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在确定文本的位置，并将每个选项写在屏幕上。检查当前选择的选项。这个选项被**<<**和**>>**符号包围，以使玩家意识到他即将做出的选择。为了添加这些功能，我们将查看以下代码：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The player has three options: he can press the up arrow, down arrow, or the
    interact button on the keyboard; the last action state corresponds to the *Enter*
    key. Here we will explain how it is done for a regular desktop. It is a good exercise
    to try implementing this for mobile devices:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家有三个选项：他可以按上箭头、下箭头或键盘上的交互按钮；最后的动作状态对应*Enter*键。在这里，我们将解释如何在常规桌面上实现这一点。尝试为移动设备实现这一点是一个很好的练习：
- en: If the `'up'` input state is activated, the `'up'` state should currently be
    bound to the up arrow of the keyboard and the selected choice shifts one position
    upwards. In the array this translates to an element with a lower index. However,
    if the position 0 within the index is reached, it can't go any lower since this
    is the first option. In this case it stays at the first option.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果激活了`'up'`输入状态，则`'up'`状态当前应该绑定到键盘的上箭头，并且所选选项向上移动一个位置。在数组中，这意味着一个具有较低索引的元素。但是，如果达到索引中的位置0，它就不能再往下走了，因为这是第一个选项。在这种情况下，它会停留在第一个选项。
- en: An equivalent logic is used for going down the menu with the down arrow key.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下箭头键向下移动菜单时使用相同的逻辑。
- en: If the `'interact'` state is not yet bound to the *Enter* key, do so now by
    adding the `ig.input.bind( ig.KEY.ENTER, 'interact' );` command to the `main.js`
    file. The player makes his choice by pressing the *Enter* key. Using the `npcreply()`
    function, the NPC knows what to say and will spawn a text balloon containing his
    reply. Based on this reply, the `this.choices` function will be filled with new
    choices for the player to pick from.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`'interact'`状态尚未绑定到*Enter*键，请通过在`main.js`文件中添加`ig.input.bind( ig.KEY.ENTER,
    'interact' );`命令来绑定。玩家通过按下*Enter*键来做出选择。使用`npcreply()`函数，NPC知道该说什么，并将生成一个包含他回复的文本气球。根据这个回复，`this.choices`函数将填充新的供玩家选择的选项。
- en: 'The menu is composed of different items; every separate option corresponds
    to a single menu item. Add this menu item class to the `menu.js` file using the
    following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单由不同的项目组成；每个单独的选项对应一个单独的菜单项。使用以下代码将此菜单项类添加到`menu.js`文件中：
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A menu item is initialized with the following two input parameters:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单项使用以下两个输入参数进行初始化：
- en: The label, which is the actual text of a choice or option.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签，这是一个选择或选项的实际文本。
- en: '`NPC_Response`, which is the Primary Key of an NPC reply. With this key it
    is possible to look up what the NPC needs to answer and construct new options
    for the player to choose from.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NPC_Response`，这是NPC回复的主键。有了这个键，就可以查找NPC需要回答的内容，并为玩家构建新的选项。'
- en: 'The `npcreply()` method uses the `NPC_Response` key, as shown in the following
    code, to look up the array number of the reply that the NPC will give in the `NPC_CON`
    array we constructed earlier in this chapter:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npcreply()`方法使用`NPC_Response`键（如下面的代码所示）查找NPC在我们在本章前面构建的`NPC_CON`数组中将要给出的回复的数组编号：'
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you might recall, there are only two arrays that together make up our entire
    conversation:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还记得，我们的整个对话只有两个数组：
- en: '`NPC_CON`: This array constitutes everything our NPC has to say'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NPC_CON`：这个数组包含了NPC要说的一切'
- en: '`PC_CON`: This array constitutes everything our player can say'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PC_CON`：这个数组包含了玩家可以说的一切'
- en: 'In the menu code, the key is stored in a local variable called `chosen_reply_key`
    and is then re-used in the following two ways:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单代码中，该键存储在一个名为`chosen_reply_key`的局部变量中，然后以以下两种方式重新使用：
- en: To make the NPC reply
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使NPC回复
- en: To construct new options by inputting it as an argument to the `changechoices()`
    method
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将其作为参数输入到`changechoices()`方法来构建新的选项
- en: Finally, the `changechoices()` method takes in what the NPC has said, as shown
    in the following code, and constructs new options by going through the `PC_CON`
    array we built earlier in this chapter.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`changechoices()`方法接受NPC所说的内容（如下面的代码所示），并通过遍历我们在本章前面构建的`PC_CON`数组来构建新的选项。
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The conversation is a loop, which theoretically can go on forever. However,
    we still need a start. We could do this by initializing our `Talkie` NPC menu
    with a few options in the `Talkie` NPC itself. This is a very pragmatic approach,
    but then again, so is the entire implementation of this conversation plugin, and
    you are free to adapt and extend it as you please.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对话是一个循环，理论上可以永远进行下去。然而，我们仍然需要一个开始。我们可以通过在`Talkie` NPC本身中初始化我们的`Talkie` NPC菜单的一些选项来实现这一点。这是一个非常实用的方法，但与此对话插件的整个实现一样，您可以自由地根据自己的意愿进行调整和扩展。
- en: 'We still need to adjust our `Talkie` entity before we can start talking to
    him:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始与他交谈之前，我们仍然需要调整我们的`Talkie`实体：
- en: 'Open the `talkie.js` file and add the following code to the file as properties:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`talkie.js`文件，并将以下代码添加到文件中作为属性：
- en: '[PRE59]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have now added a conversation menu for Talkie and initialized it at the first
    three options of our `PC_CON` array.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在为Talkie添加了一个对话菜单，并将其初始化为`PC_CON`数组的前三个选项。
- en: 'Now we need a function that checks whether Talkie was actually selected. Otherwise,
    there will be conflicts if we introduce several NPCs at the same time. To check
    if Talkie has been actually selected we write the following code:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个函数来检查Talkie是否被实际选择。否则，如果我们同时引入多个NPC，就会出现冲突。为了检查Talkie是否被实际选择，我们编写以下代码：
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The function will check where the mouse was clicked and correct its position
    for the game screen. No correction would be necessary if our level would perfectly
    fit into the viewport, but this is almost never the case, so a correction needs
    to take place. The function returns a `true` or `false` value. It returns the
    value `true` if the entity was selected, and returns `false` if it wasn't.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数将检查鼠标点击的位置，并校正其在游戏屏幕上的位置。如果我们的级别完全适合视口，则不需要校正，但这几乎永远不是这种情况，因此需要进行校正。该函数返回一个`true`或`false`值。如果实体被选择，则返回值为`true`，如果没有选择，则返回`false`。
- en: 'In our `update()` method, we can now check for a mouse click and see if Talkie
    was actually selected using the following code:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`update()`方法中，我们现在可以检查鼠标点击，并使用以下代码查看Talkie是否被实际选择：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If it was, we set its brand new property `contexted` as `true`. In case Talkie
    wasn't selected, `contexted` is set to `false`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，我们将设置它全新的属性`contexted`为`true`。如果没有选择Talkie，`contexted`将被设置为`false`。
- en: 'If the `Talkie` entity was clicked and there is a menu available, it will be
    drawn underneath the `Talkie` entity with the following code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Talkie`实体被点击并且有菜单可用，它将在`Talkie`实体下方绘制以下代码：
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Talkie is now ready to talk! Certainly try setting up your own conversation
    and see it unfold in your game.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在Talkie已经准备好交谈了！一定要尝试设置自己的对话，并在游戏中看到它展开。
- en: 'As a last useful plugin before we move on to discussing some advanced AI, we
    will add a nice bar, visually presenting the player''s health. However, before
    we do so, we will first recap the conversation plugin:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论一些高级AI之前，我们将添加一个漂亮的条形图，直观地显示玩家的生命值。但在这样做之前，我们将首先回顾一下对话插件：
- en: We want to set up a conversation between our player and an NPC. For this, we
    will make use of the data we imported earlier in this chapter and a new plugin
    called `Menu`.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要在玩家和NPC之间建立一段对话。为此，我们将利用本章早些时候导入的数据和一个名为`Menu`的新插件。
- en: 'The `Menu` plugin consists of two parts: the menu itself and the options within
    the menu. We create both as an extension of the `ImpactJS` class.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Menu`插件由两部分组成：菜单本身和菜单中的选项。我们将两者都创建为`ImpactJS`类的扩展。'
- en: After setting up both the `Menu` plugin and the menu items, some extra adjustments
    need to be made to our friendly NPC Talkie. When the player clicks the `Talkie`
    entity with the mouse button, the menu, featuring several options, should appear
    underneath him. When one of the options is chosen, Talkie replies. To show the
    reply, we make use of the speech balloon, which we created in [Chapter 3](ch03.html
    "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role Playing Game*.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置了`Menu`插件和菜单项之后，我们友好的NPC Talkie需要进行一些额外的调整。当玩家用鼠标点击`Talkie`实体时，应该出现一个带有几个选项的菜单。当选择其中一个选项时，Talkie会回复。为了显示回复，我们利用了在[第3章](ch03.html
    "第3章。让我们建立一个角色扮演游戏")中创建的对话气泡，*让我们建立一个角色扮演游戏*。
- en: The entire conversation is a loop, which ends when either the player or the
    NPC runs out of sentences or the player just walks away.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个对话是一个循环，当玩家或NPC用完句子，或者玩家走开时，循环结束。
- en: Adding a basic Head-Up Display
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加基本的头顶显示
- en: 'Our player has health, but he is not aware of how much or little he is left
    with at any given time. Because being aware of how much health you have left as
    a player is so vital, we are going to show this on the screen as both a number
    and a health bar. For this, we build ourselves the HUD plugin using the following
    steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的玩家有生命值，但他不知道自己在任何给定时间剩下多少。因为作为玩家，了解自己剩下多少生命值是如此重要，所以我们将在屏幕上显示这一点，作为数字和生命条。为此，我们使用以下步骤构建自己的HUD插件：
- en: Open a new file and save it as `hud.js` under a `hud` subfolder of the `plugin`
    folder.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件，并将其保存为`hud.js`，放在`plugin`文件夹的`hud`子文件夹下。
- en: Add the `'plugins.hud.hud'` command to the `main.js` script.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`'plugins.hud.hud'`命令添加到`main.js`脚本中。
- en: 'Start off by inserting the following code in the new `plugin` file:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在新的`plugin`文件中插入以下代码：
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As usual, we define a new class based on the ImpactJS class. We initiate two
    variables: canvas and context, which will allow us to see whether the game is
    being viewed. Also, we initiate a `maxHealth` variable at a value `null`. However,
    unlike the usual condition, we use the inject technique as we did when we constructed
    our debug panel. When extending code, you create a new instance of that original
    code and supply it with a new name. It is, by all means, a copy of the original
    with the difference being the extra code you added. But while injecting, you modify
    the original code. In this case we overwrite the `draw()` function of our game.
    The `this.parent()` function points to our former `draw()` function, so everything
    which was already there is kept. What we add is the check for the presence of
    a player entity. If a player is in the game, a HUD is drawn. Our HUD is comprised
    of two parts: the number and the health bar.'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们基于ImpactJS类定义一个新类。我们初始化两个变量：canvas和context，这将允许我们查看游戏是否正在被查看。此外，我们以值`null`初始化一个`maxHealth`变量。然而，与通常的条件不同，我们使用了注入技术，就像我们构建调试面板时所做的那样。在扩展代码时，您创建原始代码的新实例，并为其提供新名称。它在所有方面都是原始代码的副本，唯一的区别是您添加的额外代码。但在注入时，您修改原始代码。在这种情况下，我们覆盖了游戏的`draw()`函数。`this.parent()`函数指向我们以前的`draw()`函数，因此已经存在的所有内容都被保留。我们添加的是检查玩家实体是否存在。如果玩家在游戏中，将绘制HUD。我们的HUD由两部分组成：数字和生命条。
- en: 'The `number` function will draw a black and slightly transparent rectangle
    in which the health will be visible, using the following code:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`number`函数将绘制一个黑色并略微透明的矩形，其中健康值将可见，使用以下代码：'
- en: '[PRE64]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the first part of our `number()` function, we define and draw the rectangle.
    Since it will need to be situated underneath the number, it needs to be drawn
    first. Unlike before, we are directly using canvas element''s properties to draw
    on the screen. The font, for instance, does not need to be set by using the ImpactJS
    `ig.font` function. As shown here, you can just write characters to the screen
    by directly addressing the canvas and setting the canvas'' `font` property. The
    canvas properties we use here are pretty straightforward and are listed as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`number()`函数的第一部分中，我们定义并绘制了矩形。由于它需要位于数字下方，所以需要先绘制它。与以前不同的是，我们直接使用canvas元素的属性在屏幕上绘制。例如，字体不需要使用ImpactJS的`ig.font`函数来设置。如下所示，您可以通过直接访问画布并设置画布的`font`属性来将字符写入屏幕。我们在这里使用的画布属性非常简单，列举如下：
- en: '`fillstyle`: This property will set the color'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillstyle`: 此属性将设置颜色'
- en: '`font`: This property will set the font'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font`: 此属性将设置字体'
- en: '`setAlpha()`: This property will set the transparency, with a value `1` being
    solid and `0` being fully transparent'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAlpha()`: 此属性将设置透明度，值为`1`表示完全不透明，值为`0`表示完全透明'
- en: '`fillRect()`: This property will draw a rectangle to the screen at a given
    position with a given width and height'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillRect()`: 此属性将在给定位置以给定宽度和高度向屏幕绘制一个矩形'
- en: '`fillText()`: This property will draw text on the screen at a certain position'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillText()`: 此属性将在屏幕上的特定位置绘制文本'
- en: 'Our health bar function works in a similar way as that of the number function,
    as shown in the following code:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的生命条功能的工作方式与数字功能类似，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here we draw two rectangles on top of each other. The bottom one is black at
    all times and is slightly transparent. The top rectangle is either blue or red,
    depending on how much health the player is left with. If the player's health value
    is `30` or higher, the bar will be blue, otherwise it will be red indicating impending
    demise.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们在彼此之上绘制了两个矩形。底部的矩形始终是黑色的，并且略微透明。顶部的矩形要么是蓝色的，要么是红色的，这取决于玩家剩余的健康程度。如果玩家的健康值为`30`或更高，条将是蓝色的，否则将是红色的，表示即将死亡。
- en: 'The size of the black transparent bottom bar is always the same, but its width
    depends on how much health a player has when he starts the game. This we can capture
    with the `setMaxHealth()` method as depicted in the following code:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 黑色透明底部条的大小始终相同，但其宽度取决于玩家开始游戏时的健康状况。我们可以使用`setMaxHealth()`方法来捕获这一点，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'All we now need to do is initialize a HUD and feed it with the player''s health
    using our `setMaxHealth()` method. Add the following code to the `main.js` file:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们所需要做的就是初始化一个HUD，并使用我们的`setMaxHealth()`方法提供玩家的健康值。将以下代码添加到`main.js`文件中：
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: While reloading the game, we should now have a blue health bar and an indication
    that we have a **health** value of **100** left, as shown in the following screenshot:![Adding
    a basic Head-Up Display](img/4568_5_10.jpg)
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加载游戏时，我们现在应该有一个蓝色的生命条，并指示我们还剩下**100**的**生命**值，如下面的屏幕截图所示：![添加基本HUD](img/4568_5_10.jpg)
- en: However, after a small battle with our foes we can see by our red health bar
    that it is time to consult a doctor, as shown in the following screenshot:![Adding
    a basic Head-Up Display](img/4568_5_11.jpg)
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，与敌人进行了一场小战斗后，我们可以通过我们的红色生命条看到，现在是时候去找医生了，如下面的屏幕截图所示：![添加基本HUD](img/4568_5_11.jpg)
- en: 'Now that we took a look at some interesting extensions to [Chapter 3](ch03.html
    "Chapter 3. Let''s Build a Role Playing Game"), *Let''s Build a Role Playing Game*,
    let''s revisit our AI and introduce a new level of complexity. Before moving on,
    let''s quickly go over the way we constructed our HUD:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了一些有趣的扩展内容[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")，*让我们建立一个角色扮演游戏*，让我们重新审视我们的人工智能，并引入新的复杂性。在继续之前，让我们快速回顾一下我们构建HUD的方式：
- en: A HUD or Head-Up Display offers a quick view on several key measures of the
    player, which help the player to be successful. In a shooter, this depicts how
    much ammo he is left with, both in total and in the current magazine. It can indicate
    other items or his overall score. Here we allow him to keep track of his health
    using a classic health bar.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD或抬头显示器提供了玩家几个关键指标的快速视图，这有助于玩家取得成功。在射击游戏中，这显示了他还剩多少弹药，总共和当前弹夹中的数量。它还可以指示其他物品或他的总得分。在这里，我们允许他使用经典的生命条来跟踪他的健康状况。
- en: 'The `hud` plugin is an extension of the ImpactJS class and has two elements:
    the health as a number and as a colored bar. They both have their separate methods
    within the `hud` plugin. You can extend the `hud` plugin yourself by adding new
    methods that represent other trackable statistics.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hud`插件是ImpactJS类的扩展，有两个元素：数字和有颜色的条。它们在`hud`插件内部有各自的方法。您可以通过添加代表其他可跟踪统计数据的新方法来扩展`hud`插件。'
- en: In building the HUD, we used the `canvas` properties as an alternative to using
    ImpactJS classes such as `ig.font`.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建HUD时，我们使用`canvas`属性作为使用ImpactJS类（如`ig.font`）的替代方法。
- en: 'Artificial intelligence: The hive mind'
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能：集体意识
- en: 'In [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role Playing Game"), *Let''s
    Build a Role Playing Game*, we already covered AI and why behavior should be separated
    from the process of decision making. We have also taken a look at strategies,
    but only applied a single strategy: attacking. Here we will set up a supplementary
    layer of intelligence that will decide which entity will follow which strategy.
    Because the decision making process takes into account all enemies in the same
    level, we call it hive mind intelligence. It is very similar to the queen of a
    beehive or the general on a battlefield who decides who should attack and who
    should stay put. The strategy decided in our hive mind is sent to the AI that
    we put in place during [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role Playing
    Game"), *Let''s Build a Role Playing Game*, where it is interpreted and translated
    into behavior. The behavioral commands are in turn sent to the entity itself,
    which then acts upon them. Let''s create our general `ai` plugin using the following
    steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")中，*让我们建立一个角色扮演游戏*，我们已经涵盖了AI以及为什么行为应该与决策过程分开。我们也已经看过策略，但只应用了单一策略：攻击。在这里，我们将建立一个补充的智能层，决定哪个实体将遵循哪种策略。因为决策过程考虑了同一级别中的所有敌人，我们称之为集体意识智能。这与蜂巢的女王或战场上的将军非常相似，他们决定谁应该攻击，谁应该留在原地。我们在集体意识中决定的策略被发送到我们在[第3章](ch03.html
    "第3章。让我们建立一个角色扮演游戏")中放置的AI，那里它被解释并转化为行为。行为命令又被发送到实体本身，然后实体根据它们行动。让我们使用以下步骤创建我们的`ai`插件：
- en: Open a new file and save it as `general_ai.js`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件，将其保存为`general_ai.js`。
- en: Insert the `'plugins.ai.general_ai'` class in the `main.js` file.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`文件中插入`'plugins.ai.general_ai'`类。
- en: 'Create the `ig.general_ai` class as an ImpactJS class extension. Generally,
    the class `general_ai.js` has been created as shown in the following code:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ig.general_ai`类创建为ImpactJS类扩展。通常，类`general_ai.js`已经按照以下代码创建：
- en: '[PRE68]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The first thing we do is define the possible strategies. Here we will issue
    only two strategies: `Approach` or `Rest`.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是定义可能的策略。在这里，我们只会发布两种策略：`Approach`或`Rest`。
- en: 'The `getStrategy()` function is located where our hive mind decides to keep
    it, and it is the function that shall be called by our AI in order to receive
    a strategy. This strategy is in turn translated into behavior using the following
    code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getStrategy()`函数位于我们的集体意识决定保留它的地方，它是我们的AI将调用以接收策略的函数。这个策略又通过以下代码转化为行为：'
- en: '[PRE69]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `getStrategy()` method contains our entire hive mind logic and consists
    of three main parts:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getStrategy()`方法包含我们整个集体意识逻辑，并由三个主要部分组成：'
- en: First, a list of enemies and the player entity are each assigned to a local
    variable.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，敌人列表和玩家实体分别分配给本地变量。
- en: These local variables are then used to calculate the distance between each enemy
    and the player for those enemies who have more than 100 health value. Every enemy
    below the health value of 100 is regarded to be weakened and too scared to attack.
    This code could be made more complex by adding personality to each enemy. We could,
    for example, initialize each enemy with a `courage` property, filled with a random
    number within the health range of our enemy; in our case this is `0` to `200`.
    This way we could decide whether a certain enemy feels bold enough to attack by
    comparing his current health with his courage instead of comparing with a fixed
    value. Certainly try this yourself; it adds depth and unpredictability to the
    game.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，这些本地变量被用来计算每个敌人与玩家之间的距离，对于那些具有超过100生命值的敌人。每个生命值低于100的敌人都被认为是虚弱的，太害怕攻击。通过为每个敌人添加个性，可以使这段代码变得更加复杂。例如，我们可以初始化每个敌人的`courage`属性，填充一个在我们敌人的生命范围内的随机数；在我们的情况下，这是`0`到`200`。这样我们可以通过将当前生命值与勇气进行比较来决定某个敌人是否足够勇敢地攻击，而不是与固定值进行比较。当然，你可以尝试这个方法；它为游戏增加了深度和不可预测性。
- en: Finally, all enemies bold enough to attack are compared by their distance to
    the target, and only the closest of them will attack. The others are issued the
    `Rest` strategy and will only attack when they become the closest enemy around.
    As a player you should still be careful though. If none of them feel strong enough
    to attack on their own, they will join forces and attack together.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，所有足够勇敢攻击的敌人都将根据它们与目标的距离进行比较，只有最接近目标的敌人才会攻击。其他人将被分配`Rest`策略，只有当它们成为周围最近的敌人时才会攻击。作为玩家，你仍然应该小心。如果他们中没有一个感到足够强大来单独攻击，他们将联合起来一起攻击。
- en: 'In our previously built AI, we now need to call the `getStrategy()` function
    using the following code:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前构建的AI中，我们现在需要使用以下代码调用`getStrategy()`函数：
- en: '[PRE70]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If the strategy is `Approach`, the AI will translate this into the appropriate
    action.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果策略是`Approach`，AI将将其转化为适当的动作。
- en: '[PRE71]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If the strategy is something else, it is immediately translated into the `Rest`
    action. Because we only have these two strategies, this makes sense. If you have
    more strategies, you will need more checks.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果策略是其他的，它会立即转化为`Rest`动作。因为我们只有这两种策略，所以这是有意义的。如果你有更多的策略，你将需要更多的检查。
- en: 'Now that we have extended our AI to incorporate strategies, it is time to take
    a look at the final part of this chapter: implementing game analytics with Playtomic.
    Let''s quickly recap the hive mind AI before moving on:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经扩展了我们的AI以包含策略，是时候来看一下本章的最后一部分了：使用Playtomic实现游戏分析。在继续之前，让我们快速回顾一下集体意识AI：
- en: The hive mind is an overhead decision making organ, which will issue strategies
    to the different entities in the game. It is a way to make them act as part of
    a group rather than a bunch of unorganized individuals.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集体意识是一个高层决策机构，将向游戏中的不同实体发布策略。这是一种使它们作为一个团体而不是一群无组织的个体行动的方式。
- en: In [Chapter 3](ch03.html "Chapter 3. Let's Build a Role Playing Game"), *Let's
    Build a Role Playing Game*, we had the decision-making process, which was translated
    into behavior. Now we have a strategy, which translates into individual decision
    making, which is in turn converted to behavior.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")*让我们建立一个角色扮演游戏*中，我们有决策过程，这被转化为行为。现在我们有了一个策略，这转化为个体决策，然后转化为行为。
- en: The hive mind plugin is separate from our AI that we built in [Chapter 3](ch03.html
    "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role Playing Game*.
    This way we can still return to our individualistic AI with only minor code corrections.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集体意识插件与我们在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")*让我们建立一个角色扮演游戏*中构建的AI是分开的。这样我们仍然可以通过只进行少量代码更正来返回我们的个体主义AI。
- en: 'The hive mind logic follows three main steps:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集体意识逻辑遵循三个主要步骤：
- en: Fetch all enemies and the player within the level.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取关卡内的所有敌人和玩家。
- en: Check the health value for each enemy to see if he is a viable candidate for
    an attack.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查每个敌人的健康值，看看他是否是一个适合攻击的候选人。
- en: From this list of viable enemies, choose the one who is closest to the player
    and let him attack. How the enemy will perform this attack is not specified by
    the general AI; this is a decision of the individual AI.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这些可行的敌人中选择一个离玩家最近的敌人让他攻击。敌人将如何执行这次攻击并不是由总体AI指定的；这是个体AI的决定。
- en: Implementing Playtomic for game analytics
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Playtomic进行游戏分析
- en: Playtomic can be regarded as the Google Analytics for games. You can tag certain
    parts of your game and check if they are used often or not. For example, if you
    have a hidden level in your game, you would be able to see how many times and
    by how many different gamers it was discovered by tagging the `loadlevel()` function
    of this hidden level. Then you would be able to determine whether it might be
    too easy or too hard to discover, and adjust your game accordingly. But this is
    just one of the many ways you can apply game statistics. However, you need to
    be aware that tagging your game will tax its performance to a certain degree.
    And so, tagging every inch of code might not be as fertile a solution as intended.
    In addition, you would be left with massive amounts of data that you would then
    need to analyze, which could be a daunting task.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Playtomic可以被视为游戏的Google Analytics。你可以标记游戏的某些部分，并检查它们是否经常被使用。例如，如果你的游戏中有一个隐藏关卡，你可以通过标记这个隐藏关卡的`loadlevel()`函数来查看它被多少不同的玩家发现了多少次。然后你就可以确定它可能太容易或太难被发现，然后相应地调整你的游戏。但这只是你可以应用游戏统计的众多方式之一。然而，你需要意识到标记你的游戏会在一定程度上影响其性能。因此，标记代码的每一寸可能并不像预期的那样富有成效。此外，你将留下大量的数据需要分析，这可能是一项艰巨的任务。
- en: In addition to supplying you with insights on your game usage, Playtomic allows
    you to store certain things on their server, such as scores, which you can turn
    into a leaderboard.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为你提供游戏使用情况的见解外，Playtomic还允许你在他们的服务器上存储一些东西，比如得分，你可以将其转化为排行榜。
- en: If all of this sounds good to you, by all means go over to [https://playtomic.com/](https://playtomic.com/)
    and create yourself a free account.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来对你来说都不错，那么请务必前往[https://playtomic.com/](https://playtomic.com/)创建一个免费账户。
- en: A few warnings are appropriate though. Playtomic is still in its infancy, and
    this translates into some bugs or illogical choices. For example, the default
    practice for saving a score in a leaderboard is not to overwrite the first one,
    even if the new one is higher. This doesn't make sense for a leaderboard and even
    the documentation indicates the default setting to be set on allowing score overwrites.
    Contacting the Playtomic server will slow down your game load, and often data
    is lost because no stable connection was made.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要适当地警告一下。Playtomic仍处于起步阶段，这意味着会有一些错误或不合逻辑的选择。例如，默认的保存得分到排行榜的做法是不覆盖第一个，即使新的得分更高。这对于排行榜来说是没有意义的，即使文档中也指出默认设置应该允许得分覆盖。与Playtomic服务器的连接会减慢游戏加载速度，并且经常会因为没有建立稳定连接而丢失数据。
- en: 'But even though there are flaws in the implementation, server speed, and documentation,
    Playtomic is worth taking a look at if you want to gather insights about your
    game. The following screenshot depicts the data collected by Playtomic and its
    representation:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使在实施、服务器速度和文档中存在缺陷，如果你想要收集有关你的游戏的见解，Playtomic还是值得一看的。以下截图描述了Playtomic收集的数据及其表示：
- en: '![Implementing Playtomic for game analytics](img/4568_5_12.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![实施Playtomic进行游戏分析](img/4568_5_12.jpg)'
- en: 'In order to implement Playtomic, there are a few things you will need to do:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实施Playtomic，你需要做一些事情：
- en: Create a Playtomic account and fetch your data transmission credentials. You
    will need these to set up a connection to their server.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Playtomic账户并获取你的数据传输凭据。你需要这些来建立与他们服务器的连接。
- en: In the `index.html` file we will need to include the Playtomic source script
    as shown in the following code. Certainly check what the latest version is, at
    the time of installation. At the time of writing this book it was Version 2.2
    but these things develop fast.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，我们需要包含Playtomic源脚本，如下面的代码所示。当然，要检查最新版本是什么，在安装时。在撰写本书时，它是2.2版本，但这些东西发展得很快。
- en: '[PRE72]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Open a new file and save it as `PlayTomic.js` under the `data` subfolder in
    the `plugins` folder. Here we will place the functions that we will need in order
    to work with Playtomic.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件，并将其保存为`PlayTomic.js`，放在`plugins`文件夹的`data`子文件夹下。在这里，我们将放置我们需要与Playtomic一起工作的函数。
- en: 'Include this plugin file in our `main.js` script as shown in the following
    code line:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此插件文件包含在我们的`main.js`脚本中，如下面的代码行所示：
- en: '[PRE73]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define the `PlayTomic` plugin module using the following code:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码定义`PlayTomic`插件模块：
- en: '[PRE74]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Our new Playtomic class will have the task of saving the player's score on the
    Playtomic server. However, first a connection with the server needs to be established;
    this is done in the `init()` function. Inserting log messages at key moments is
    extremely useful when implementing and testing your Playtomic setup. You will
    need to fill out your own connection credentials in the highlighted part of the
    previous code.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新Playtomic类将负责在Playtomic服务器上保存玩家的分数。但是，首先需要建立与服务器的连接；这是在`init()`函数中完成的。在实现和测试Playtomic设置时，在关键时刻插入日志消息非常有用。您需要在上述代码的突出部分填写自己的连接凭据。
- en: 'Once we have a connection, we will need to send data. Since we are going to
    save the score, we need a `saveScore` method as shown in the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们建立了连接，我们就需要发送数据。由于我们要保存分数，我们需要一个`saveScore`方法，如下面的代码所示：
- en: '[PRE75]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `Playtomic` class has a **leaderboards** property to which you can save
    the player's score using its `save()` method. You will need to specify that you
    want to save to the high scores table and add the value of the score. You can
    name the table yourself in your **leaderboards** settings on the Playtomic website,
    as shown in the following screenshot:![Implementing Playtomic for game analytics](img/4568_5_13.jpg)
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Playtomic`类有一个**leaderboards**属性，您可以使用其`save()`方法保存玩家的分数。您需要指定要保存到高分榜中并添加分数的值。您可以在Playtomic网站的**leaderboards**设置中自己命名表格，如下截图所示：![Implementing
    Playtomic for game analytics](img/4568_5_13.jpg)'
- en: We add an optional function that will give us feedback if the submit was successful.
    Keeping track of all the sent and received data is highly recommended while working
    with Playtomic. As a final parameter, we will allow duplicates on the leaderboard
    so that one person can have several scores on the board.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个可选函数，用于在提交成功时给我们反馈。在使用Playtomic时，强烈建议跟踪所有发送和接收的数据。作为最后一个参数，我们将允许在排行榜上重复，以便一个人可以在榜单上有多个分数。
- en: 'The `submitComplete()` function is just a way for us to keep track of whether
    a certain data transmission was successful or not:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`submitComplete()`函数只是我们跟踪特定数据传输是否成功的一种方式：'
- en: '[PRE76]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'All that is left to do now is integrating our `PlayTomic` analytics, as shown
    in the following code, using the `GameInfo.saveScore()` function we built for
    saving scores with the lawnchair application:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们唯一需要做的就是集成我们的`PlayTomic`分析，如下所示的代码，使用我们为使用lawnchair应用程序保存分数而构建的`GameInfo.saveScore()`函数：
- en: '[PRE77]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Our `saveScore()` method now not only saves the score locally by use of the
    lawnchair application, but also sends the result to the Playtomic server where
    it is put in a leaderboard, as shown in the following screenshot:![Implementing
    Playtomic for game analytics](img/4568_5_14.jpg)
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`saveScore()`方法现在不仅通过lawnchair应用程序在本地保存分数，还将结果发送到Playtomic服务器，在那里它将被放入排行榜中，如下截图所示：![Implementing
    Playtomic for game analytics](img/4568_5_14.jpg)
- en: There is a lot more to Playtomic than was covered here but that will be up to
    you to discover in full. With this humble introduction, you should already feel
    confident in starting up your own game analytics. Though, be aware that privacy
    regulations apply and they are constantly changing. It is best to ask the player's
    permission to keep the game statistics and make sure you take this into account
    while implementing your Playtomic code.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Playtomic还有很多内容没有涵盖到，但这将由您自行发现。通过这个简单的介绍，您应该已经有信心开始自己的游戏分析了。不过，请注意隐私规定适用且不断变化。最好在保留游戏统计数据时征得玩家的许可，并确保在实现Playtomic代码时考虑到这一点。
- en: 'Summing up the complete process of introducing Playtomic in our game, we conclude
    that:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 总结介绍Playtomic在我们的游戏中的完整过程，我们得出结论：
- en: Playtomic is the Google Analytics of mobile games and is free and relatively
    easy to implement.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playtomic是移动游戏的谷歌分析工具，免费且相对容易实现。
- en: The first thing you need after creating a Playtomic account is a connection
    to their script, which can be included in your `index.html` file.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建Playtomic帐户后，您需要的第一件事是连接到他们的脚本，该脚本可以包含在您的`index.html`文件中。
- en: A connection to the Playtomic server needs to be established. This is done using
    the credentials of your account, though you are free to test with the credentials
    in the example code.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要建立与Playtomic服务器的连接。这是使用您的帐户凭据完成的，尽管您可以使用示例代码中的凭据进行测试。
- en: The goal of this introduction was to send scores from our game platform to the
    Playtomic server where they can be represented in a leaderboard. For this we made
    our own Playtomic plugin.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本介绍的目标是将游戏平台上的分数发送到Playtomic服务器，以便在排行榜中表示。为此，我们制作了自己的Playtomic插件。
- en: Summary
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have taken a look at some of the more advanced things you
    can do with your game, and applied them on the RPG that we designed in [Chapter
    3](ch03.html "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role
    Playing Game*.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些您可以在游戏中做的更高级的事情，并将它们应用到我们在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")中设计的RPG游戏中。
- en: We constructed an introductory, Victory, and Game-over screen and made our game
    prompt for the player's name so we could show it on the intro screen.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个介绍、胜利和游戏结束的屏幕，并让我们的游戏提示玩家的名字，以便在介绍屏幕上显示。
- en: We went deeper into how to debug code by unit testing and made our own ImpactJS
    debug panel. Then we took a look at handling data and ways to store it on the
    player's device. The RPG was extended with a few fun elements, such as a way to
    move the player by a mouse click, an intelligent spawnpoint, NPC conversation,
    and a health bar.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入研究了如何通过单元测试调试代码，并制作了自己的ImpactJS调试面板。然后，我们看了一下处理数据的方法以及在玩家设备上存储数据的方法。RPG增加了一些有趣的元素，比如通过鼠标点击移动玩家的方法，智能生成点，NPC对话和生命条。
- en: Our AI was enhanced by introducing overhead strategy decision making, such as
    the hive mind. Finally we took a look at Playtomic and how to send the player
    scores to the Playtomic database.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过引入高层次的策略决策来增强我们的人工智能，比如集体智慧。最后，我们看了一下Playtomic以及如何将玩家分数发送到Playtomic数据库。
- en: In the next chapter we will have a look at music and sound effects. The aim
    is to get the basic sounds and music needed to start making your first game.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一看音乐和音效。目标是获得开始制作你的第一款游戏所需的基本声音和音乐。
