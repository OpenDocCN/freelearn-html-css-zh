- en: Chapter 1. Drawing Shapes in Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。在画布中绘制形状
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Graphics with 2D canvas
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用2D画布进行图形处理
- en: Starting from basic shapes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从基本形状开始
- en: Layering rectangles to create the flag of Greece
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层矩形以创建希腊国旗
- en: Creating shapes using paths
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路径创建形状
- en: Creating complex shapes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建复杂形状
- en: Adding more vertices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多顶点
- en: Overlapping shapes to create other shapes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重叠形状以创建其他形状
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter's main focus is to make a breakthrough into working in canvas.
    We will spend the majority of our time working with canvas when creating our charts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要重点是突破在画布上工作。在创建图表时，我们将花费大部分时间与画布一起工作。
- en: 'In this chapter, we will master the basic shapes and styles of drawing with
    the canvas API. This chapter will be the graphic''s backbone to the rest of the
    book, so if at any stage you feel you need a refresher you could come back to
    this chapter. Drawing lines can be... well not very thrilling. What better way
    to make it more dramatic than to integrate a theme into this chapter as a subtopic:
    creating flags!'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将掌握使用画布API绘制基本形状和样式。本章将是本书其余部分的图形支柱，因此如果在任何阶段您觉得需要复习，可以回到本章。绘制线条可能...嗯，不是很激动人心。有什么比将主题整合到本章作为一个子主题更能使它更加戏剧化呢：创建旗帜！
- en: Graphics with 2D canvas
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用2D画布进行图形处理
- en: Canvas is the primary and most thrilling addition to HTML. It's the buzz of
    the industry, so let's start there. We will revisit canvas again in the later
    chapters. In this recipe, we will learn how to draw dynamically using canvas,
    and create an array of colorful circles that will update once every second.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 画布是HTML的主要和最激动人心的补充。这是行业的热点，所以让我们从那里开始。我们将在后面的章节中再次访问画布。在这个示例中，我们将学习如何使用画布动态绘制，并创建一个彩色圆形数组，每秒更新一次。
- en: '![Graphics with 2D canvas](img/3707OT_01_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![使用2D画布进行图形处理](img/3707OT_01_01.jpg)'
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will be creating two files (an HTML5 file and a JS file). Let''s start by
    creating a new HTML5 document:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个文件（一个HTML5文件和一个JS文件）。让我们从创建一个新的HTML5文档开始：
- en: 'The first step is to create an empty HTML5 document:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个空的HTML5文档：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.PacktPub.com](http://www.PacktPub.com)的帐户中购买的所有Packt图书下载示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册以直接通过电子邮件接收文件。
- en: The code files are also available at [http://02geek.com/books/html5-graphics-and-data-visualization-cookbook.html](http://02geek.com/books/html5-graphics-and-data-visualization-cookbook.html).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代码文件也可以在[http://02geek.com/books/html5-graphics-and-data-visualization-cookbook.html](http://02geek.com/books/html5-graphics-and-data-visualization-cookbook.html)上找到。
- en: 'Create a new canvas element. We give our canvas element an ID of `myCanvas`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的画布元素。我们给我们的画布元素一个ID为`myCanvas`：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Import the JavaScript file `01.01.canvas.js` into the HTML document (we will
    create this file in step 5):'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JavaScript文件`01.01.canvas.js`导入HTML文档（我们将在第5步中创建此文件）：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add an `onLoad` listener and trigger the function `init` when the document
    loads:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`onLoad`监听器，并在文档加载时触发函数`init`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create the `01.01.canvas.js` file.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`01.01.canvas.js`文件。
- en: 'In the JavaScript file, create the function `init` and call the function `updateCanvas`
    within it:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript文件中，创建函数`init`并在其中调用函数`updateCanvas`：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create the function `updateCanvas`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数`updateCanvas`：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `updateCanvas` function (for the rest of the steps all the code will
    be added in this function) create two variables that will store your desired width
    and height. In our case we will grab the width of our window:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`updateCanvas`函数中（在接下来的步骤中，所有代码都将添加到此函数中），创建两个变量，用于存储您所需的宽度和高度。在我们的情况下，我们将获取窗口的宽度：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Access the canvas layer in the HTML document and change its width and height:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问HTML文档中的画布层，并更改其宽度和高度：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Get the 2D context of the canvas:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取画布的2D上下文：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a rectangle to fill the full visible area of the canvas:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个矩形以填充画布的完整可见区域：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s create a few helper variables to help us establish the color, size,
    and count of elements to be drawn:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些辅助变量，以帮助我们确定要绘制的元素的颜色、大小和数量：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a nested loop and create a grid of circles in random colors:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个嵌套循环，并创建一个随机颜色的圆形网格：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Woah! That was a lot of steps! If you followed all the steps, you will find
    a lot of circles in your browser when you run the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是很多步骤！如果您按照所有步骤进行操作，当您运行应用程序时，您将在浏览器中找到许多圆形。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before we jump right into the JavaScript portion of this application, we need
    to trigger the `onLoad` event to call our `init` function. We do that by adding
    the `onLoad` property into our HTML body tag:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们直接进入此应用程序的JavaScript部分之前，我们需要触发`onLoad`事件以调用我们的`init`函数。我们通过将`onLoad`属性添加到我们的HTML
    body标签中来实现这一点：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s break down the JavaScript portion and understand the reason behind doing
    this. The first step is to create the `init` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解JavaScript部分，并了解这样做的原因。第一步是创建`init`函数：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `init` function immediately calls the `updateCanvas` function. This is done
    so that later we can refresh and call `updateCanvas` again.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`init`函数立即调用`updateCanvas`函数。这样做是为了以后可以刷新并再次调用`updateCanvas`。
- en: 'In the `updateCanvas` function, we start by getting the current width of the
    browser and set a hardcoded value for the height of our drawing area:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateCanvas`函数中，我们首先获取浏览器的当前宽度，并为我们的绘图区域设置一个硬编码值的高度：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our next step is to get our canvas using its ID, and then set its new width
    and height based on the previous variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是使用其ID获取我们的画布，然后根据先前的变量设置其新的宽度和高度：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It''s time for us to start drawing. To do that, we need to ask our canvas to
    return its context. There are a few types of contexts such as 2D and 3D. In our
    case we will focus on the 2D context as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始绘制了。为了做到这一点，我们需要要求我们的画布返回其上下文。有几种类型的上下文，如2D和3D。在我们的情况下，我们将专注于2D上下文，如下所示：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have the context, we have all that we need to start exploring and
    manipulating our canvas. In the next few steps, we define the canvas background
    color by setting the `fillStyle` color using a hex value and by drawing a rectangle
    that would fit within the entire area of our canvas:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了上下文，我们有了开始探索和操纵我们的画布所需的一切。在接下来的几个步骤中，我们通过使用十六进制值设置`fillStyle`颜色来定义画布的背景颜色，并绘制一个适合整个画布区域的矩形：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `fillRect` method takes four parameters. The first two are the (x,y) locations
    of the rectangle, in our case we wanted to start from (0,0), and the following
    parameters are the width and height of our new rectangle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillRect`方法接受四个参数。前两个是矩形的（x，y）位置，在我们的情况下，我们想从（0,0）开始，后面的参数是我们新矩形的宽度和高度。'
- en: Let's draw our circles. To do so we will need to define the radius of our circle
    and the space between circles. Let's not space out the circles at all, and create
    circles with a radius of 10 px.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们画我们的圆。为此，我们需要定义我们圆的半径和圆之间的间距。让我们不间隔圆，创建半径为10像素的圆。
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first line assigns the radius for our circles, while the second line captures
    the gap between the centres of each circle we create, or in our case the diameter
    of our circle. By setting it up as two times the radius we space out our circles
    exactly one after the other.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行分配了我们圆的半径，而第二行捕获了我们创建的每个圆的中心之间的间隙，或者在我们的情况下是我们圆的直径。通过将其设置为两倍的半径，我们将我们的圆精确地一个接一个地间隔开。
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using our new `gaps` variable, we discover how many circles we can create in
    the width and height of our canvas component. We create an array that stores a
    few color options for our circles and set a variable `aColorsLength` as the length
    of `aColors`. We do this to cut down the processing time, as variables are easier
    to fetch than properties as we are about to call this element many times in our
    `for` loop:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的新`gaps`变量，我们发现我们可以在画布组件的宽度和高度上创建多少个圆。我们创建一个存储一些圆的颜色选项的数组，并将变量`aColorsLength`设置为`aColors`的长度。我们这样做是为了减少处理时间，因为变量比属性更容易获取，因为我们将在我们的`for`循环中多次调用这个元素：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our nested `for` loops enable us to create our circles to the width and height
    of our canvas. The first `for` loop focuses on upgrading the width value while
    the second `for` loop is in charge of running through every column.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们嵌套的`for`循环使我们能够创建我们的圆到画布的宽度和高度。第一个`for`循环专注于升级宽度值，而第二个`for`循环负责遍历每一列。
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using `Math.random`, we randomly select a color from `aColors` to be used as
    the color of our new circle.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Math.random`，我们随机从`aColors`中选择一种颜色，用作我们新圆的颜色。
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first and last lines in the previous block of code declare the creation
    of a new shape. The `beginPath` method defines the start of the shape and the
    `closePath` method defines the end of it, while `context.arc` creates the actual
    circle. The `arc` property takes the following format of values:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的第一行和最后一行声明了一个新形状的创建。`beginPath`方法定义了形状的开始，`closePath`方法定义了形状的结束，而`context.arc`创建了实际的圆。`arc`属性采用以下格式的值：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `x` and `y` properties define the center point of the arc (in our case a
    full circle). In our `for` loops we need to add a buffer of an extra radius to
    push our content into the screen. We need to do this as only one fourth of our
    first circle would be visible if we didn't push it to the left and to the bottom
    by an extra radius.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`和`y`属性定义了弧的中心点（在我们的例子中是一个完整的圆）。在我们的`for`循环中，我们需要添加额外半径的缓冲区，将我们的内容推入屏幕。我们需要这样做，因为如果我们不通过额外的半径将其推到左边和底部，那么我们第一个圆的四分之一将是可见的。'
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Last but not least, we need to call the `fill()` method to fill our newly-created
    shape with its color.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们需要调用`fill()`方法来填充我们新创建的形状的颜色。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's make our element refresh once a second; to do that all we need to do is
    add two more lines. The first one will trigger a new call to the `updateCanvas`
    function once every second using `setInterval`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使我们的元素每秒刷新一次；要做到这一点，我们只需要添加两行。第一行将使用`setInterval`每秒触发对`updateCanvas`函数的新调用。
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you refresh your browser you will find that our sample is working. If you
    try really hard to find issues with it you will not, but we have a problem with
    it. It''s not a major problem but a great opportunity for us to learn about another
    useful functionality of the canvas. At any stage we can clear the canvas or parts
    of it. Instead of drawing on top of the current canvas, let''s clear it before
    we redraw. In the `updateCanvas` function, we will add the following highlighted
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新浏览器，您会发现我们的示例正在工作。如果您努力寻找问题，您将找不到，但我们有一个问题。这不是一个主要问题，而是一个让我们学习画布的另一个有用功能的绝佳机会。在任何阶段，我们都可以清除画布或其部分。让我们在重新绘制之前清除当前画布，而不是在当前画布上绘制。在`updateCanvas`函数中，我们将添加以下突出显示的代码：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As soon as we get the context we can clear the data that was already present
    by using the `clearRect` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到上下文，我们就可以使用`clearRect`方法清除已经存在的数据。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另外
- en: The *Starting from basic shapes* recipe
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从基本形状开始*食谱'
- en: Starting from basic shapes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从基本形状开始
- en: At this stage you know how to create a new canvas area and even create a few
    basic shapes. Let's expand our skill and start creating flags.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您知道如何创建一个新的画布区域，甚至创建一些基本形状。让我们扩展我们的技能，开始创建旗帜。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Well, we won't start from the most basic flag as that would just be a green
    rectangle. If you wanted to learn how to create a green flag you wouldn't need
    me, so let's move up to a tad more complex flag.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们不会从最基本的旗帜开始，因为那只是一个绿色的矩形。如果您想学习如何创建绿色旗帜，您不需要我，所以让我们转向稍微复杂一点的旗帜。
- en: If you followed the *Graphics with 2D canvas* recipe you already know how to
    do it. This one is dedicated to our Palauan readers and to the perfect arc (also
    known as circle).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经按照*使用2D画布进行绘图*食谱的步骤进行操作，您已经知道如何做了。这个食谱专门为我们帕劳读者和完美的圆弧（也称为圆）而设。
- en: '![Getting ready](img/3707OT_01_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/3707OT_01_02.jpg)'
- en: In this recipe we will ignore the HTML part, so if you need a refresher on how
    to create a canvas with an ID, please go back to the first recipe in this chapter
    and set up your HTML document. Don't forget to create the canvas with the right
    ID. You could also download our sample HTML files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将忽略HTML部分，因此，如果您需要了解如何创建带有ID的画布，请返回到本章的第一个食谱，并设置您的HTML文档。不要忘记使用正确的ID创建画布。您也可以下载我们的示例HTML文件。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add the following code block:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码块：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That's it, you've just created a perfect arc, and with it your first flag that
    has a shape within it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，你刚刚创建了一个完美的圆弧，以及你的第一个具有形状的国旗。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A big chunk of this code should look very familiar at this stage. So I'll focus
    on the new lines compared to the ones used in the first recipe in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，这段代码的大部分内容应该看起来非常熟悉。因此，我将重点放在与本章第一个食谱中使用的代码相比的新行上。
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In these lines, we extract the width and height of our canvas. We have two
    goals here: to shorten our lines of code and to reduce the number of times we
    make an API call when not needed. As we are using it more than one time, we first
    fetch the values and store them in `wid` and `hei`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们提取了画布的宽度和高度。我们有两个目标：缩短我们的代码行数，减少不必要的API调用次数。由于我们使用它超过一次，我们首先获取这些值并将它们存储在`wid`和`hei`中。
- en: Now that we know our canvas width and height, it's time for us to draw our circle.
    Before we start drawing, we will call the `fillStyle` method to define a background
    color to be used in the canvas, and then we will create the arc followed by triggering
    the `fill` method when complete.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了画布的宽度和高度，是时候画我们的圆圈了。在开始绘制之前，我们将调用`fillStyle`方法来定义在画布中使用的背景颜色，然后我们将创建圆弧，最后触发`fill`方法来完成。
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We then create our first perfect circle using the `arc` method. It's important
    to note that we can change the colors at any point, such as in this case, where
    we change our color just before we create a new circle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`arc`方法创建我们的第一个完美圆圈。重要的是要注意，我们可以在任何时候更改颜色，例如在这种情况下，我们在创建新圆圈之前更改颜色。
- en: 'Let''s take a deeper look at how the `arc` method works. We start by defining
    the center of our circle with the `x` and `y` positions. The canvas tag follows
    the standard Cartesian coordinates: (0, 0) is at the top-left (`x` grows to the
    right and `y` grows towards the bottom).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下`arc`方法的工作原理。我们首先通过`x`和`y`位置定义我们圆圈的中心。画布标签遵循标准的笛卡尔坐标：（0，0）在左上角（`x`向右增长，`y`向底部增长）。
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our example, we decided to position the circle slightly to the left of the
    center by dividing the width of the canvas by `2.3`, and we positioned the `y`
    in the exact center of the canvas. The next parameter is the radius of our circle,
    It is followed by two parameters that define the starting and ending position
    of our stroke. As we want to create a full circle we start from `0` and end at
    two times `Math.PI`, a complete circle (`Math.PI` is equivalent to 180 degrees).
    The last parameter is the direction of our arc. In our case as we are creating
    a full circle, it doesn't matter what we set here (ccw = counterclockwise).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们决定通过将画布的宽度除以`2.3`来将圆圈略微定位到中心的左侧，并将`y`定位在画布的正中心。下一个参数是我们圆圈的半径，接下来是两个参数，定义了我们描边的起始和结束位置。由于我们想要创建一个完整的圆圈，我们从`0`开始，到两倍的`Math.PI`结束，即一个完整的圆圈（`Math.PI`相当于180度）。最后一个参数是我们圆弧的方向。在我们的情况下，由于我们正在创建一个完整的圆圈，设置在这里无关紧要（ccw
    = 逆时针）。
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Last but not least, we call the `fill` function to fill and color the shape
    we created earlier. Contrary to the `fillRect` function that both creates and
    fills the shape, the `arc` method doesn't. The `arc` method only defines the bounds
    of a shape to be filled. You can use this method (and others) to create more complex
    shapes before actually drawing them onto the stage. We will explore this more
    deeply in the following recipes of this chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们调用`fill`函数来填充和着色我们之前创建的形状。与`fillRect`函数不同，它既创建又填充形状，`arc`方法不会。`arc`方法只定义要填充的形状的边界。您可以使用这种方法（和其他方法）在实际绘制到舞台之前创建更复杂的形状。我们将在本章的后续食谱中更深入地探讨这一点。
- en: Layering rectangles to create the flag of Greece
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层叠矩形以创建希腊国旗
- en: 'We learned as we created the flag for Palau that when we create a circle using
    the `arc` method, we have to trigger a request separately to fill the shape. This
    is true for all shapes that we create from scratch, and it is true for creating
    lines as well. Let''s move to a slightly more complex flag: the flag of Greece.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在为帕劳创建国旗时学到，当我们使用`arc`方法创建一个圆圈时，我们必须单独触发一个请求来填充形状。这对我们从头开始创建的所有形状都是如此，对于创建线条也是如此。让我们转向一个稍微复杂一点的国旗：希腊国旗。
- en: '![Layering rectangles to create the flag of Greece](img/3707OT_01_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![将矩形层叠以创建希腊国旗](img/3707OT_01_03.jpg)'
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As in the previous recipe, we will be skipping the HTML part and will jump right
    into the JavaScript portion of drawing in the canvas. For a detailed explanation
    of the steps involved in the creation of the canvas element, please refer to the
    first recipe of this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个食谱一样，我们将跳过HTML部分，直接进入绘制画布的JavaScript部分。有关创建画布元素所涉及的步骤的详细说明，请参考本章的第一个食谱。
- en: Before you start coding, look at the flag closely and try to come up with an
    attack plan on the steps you would need to perform to create this flag.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，仔细观察国旗，并尝试制定一个攻击计划，列出创建这面国旗所需执行的步骤。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If we look at the flag, it''s easy to figure out how to plan this out. There
    are many ways to do this but the following is our attempt:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下旗帜，很容易就能想出如何规划这个过程。有很多方法可以做到这一点，但以下是我们的尝试：
- en: 'We will first start our app and create a blank blue canvas:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先启动我们的应用程序，并创建一个空白的蓝色画布：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you take a look at the previous figure, there are four white strips and
    five blue strips that will be part of the background. Let''s divide the total
    height of our canvas by `9`, so we can find out the right size for our lines:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看一下前面的图，有四条白色条纹和五条蓝色条纹将成为背景的一部分。让我们将画布的总高度除以`9`，这样我们就可以找到我们线条的合适大小：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So far we created shapes using built-in tools, such as `arc` and `fillRect`.
    Now we are going to draw our lines manually, and to do so we will set the `lineWidth`
    and `strokeStyle` values, so we can draw lines on the canvas:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用内置工具创建了形状，比如`arc`和`fillRect`。现在我们要手动绘制线条，为此我们将设置`lineWidth`和`strokeStyle`的值，这样我们就可以在画布上绘制线条：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s loop through and create four times a line that goes from the right-hand
    side to the left-hand side, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们循环四次，创建一条从右侧到左侧的线，如下所示：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That's it, we got it. Reload your HTML page and you will find the flag of Greece
    in all its glory. Well not in all its glory yet, but just about enough to guess
    it's the flag of Greece. Before we move on let's look deeper into how this works.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们成功了。重新加载你的HTML页面，你会发现希腊的国旗以其全部的荣耀展现在那里。嗯，还不是全部的荣耀，但足够让你猜到这是希腊的国旗。在我们继续之前，让我们深入了解一下这是如何工作的。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Notice the addition of an offset. This is done because `lineWidth` grows in
    both directions from the actual point in the center of the line. In other words,
    a line with the width of 20 pixels that is drawn from (0, 0) to (0, height) would
    only have 10 pixels visible as the range of the thickness of the line would be
    between (-10 to 10). As such, we need to take into account that our first line
    needs to be pushed down by half its width so that it's in the right location.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意偏移量的增加。这是因为`lineWidth`从线的中心点向两个方向增长。换句话说，如果从(0, 0)到(0, height)绘制宽度为20像素的线条，那么只有10像素可见，因为线条的厚度范围在(-10到10)之间。因此，我们需要考虑到我们的第一条线需要被其宽度的一半向下推，这样它就在正确的位置上了。
- en: The `moveTo` function takes in two parameters `moveTo(x,y)`. The `lineTo` function
    also takes two parameters. I believe you must have guessed the difference between
    them. One will shift the virtual point without drawing anything while the other
    will create a line between the points.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveTo`函数接受两个参数`moveTo(x,y)`。`lineTo`函数也接受两个参数。我相信你一定已经猜到它们之间的区别了。一个会移动虚拟点而不绘制任何东西，而另一个会在点之间创建一条线。'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you run your HTML file, you will find that our lines were not revealed.
    Don''t worry, you didn''t make any mistake (At least, that''s what I think ;)).
    For the lines to become visible, we need to tell the browser that we are ready,
    just like we called the `fill()` method when we used `arc`. In this case, as we
    are creating lines we will call the `stroke()` method right after we are done
    defining our lines, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行你的HTML文件，你会发现我们的线条没有显示出来。别担心，你没有犯错（至少我是这么认为的；））。为了让线条变得可见，我们需要告诉浏览器我们已经准备好了，就像我们在使用`arc`时调用`fill()`方法一样。在这种情况下，由于我们正在创建线条，我们将在定义完线条后立即调用`stroke()`方法，如下所示：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you refresh the screen now you will see we are getting much closer. It''s
    time for us to add that rectangle on the top-left area of the screen. To do that,
    we will reuse our `lineHeight` variable. The size of our rectangle is five times
    the length of `lineHeight`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在刷新屏幕，你会发现我们已经离成功更近了。现在是时候在屏幕的左上角添加那个矩形了。为此，我们将重用我们的`lineHeight`变量。我们的矩形的大小是`lineHeight`长度的五倍：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It is now time to create the cross in the flag:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在旗帜上创建十字了：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you run the application now you will be really disappointed. We did exactly
    what we learned previously but it's not working as expected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你会感到非常失望。我们完全按照之前学到的内容去做了，但结果并不如预期。
- en: '![There''s more...](img/3707OT_01_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/3707OT_01_04.jpg)'
- en: The lines are all mixed up! OK fear not, it means it's time for us to learn
    something new.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 线条都混在一起了！好吧，别害怕，这意味着是时候学习新东西了。
- en: BeginPath method and closePath method
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: beginPath方法和closePath方法
- en: Our flag didn't pan out that well because it got confused by all the lines we
    created earlier. To avoid this, we should tell the canvas when we are starting
    a new drawing and when we are ending it. To do so we can call the `beginPath`
    and `closePath` methods to let the canvas know that we are done with something
    or are starting with something new. In our case by adding the method `beginPath`
    we can fix our flag issue.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旗帜效果不太好，因为它被我们之前创建的所有线搞混了。为了避免这种情况，我们应该告诉画布我们何时开始新的绘图，何时结束。为此，我们可以调用`beginPath`和`closePath`方法，让画布知道我们已经完成了某些事情或者正在开始新的事情。在我们的情况下，通过添加`beginPath`方法，我们可以解决我们的旗帜问题。
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Congratulations! You just created your first two flags, and in the process learned
    a lot about how the canvas API works. This is enough to be able to create 53 country
    flags out of the 196 flags out there. That's a great start already; 25 percent
    of the world is in your hands.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你的前两个国旗，并且在这个过程中学到了很多关于画布API的知识。这已经足够让你能够从196个国旗中创建53个国家的国旗。这已经是一个很好的开始；世界上25%的国家都在你手中。
- en: The most complex flag you should be able to do right now is the flag of the
    United Kingdom. If you feel like exploring, give it a go. If you're really proud
    of it drop me a line at `<[ben@02geek.com](mailto:ben@02geek.com)>`, I would love
    to see it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够做的最复杂的旗帜是英国的国旗。如果你想探索一下，试试看。如果你真的为此感到自豪，请给我写封邮件`<[ben@02geek.com](mailto:ben@02geek.com)>`，我会很乐意看到它。
- en: Creating shapes using paths
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路径创建形状
- en: We ended the last recipe learning how to create one fourth of the flags of the
    world, but that can't be the end of it, can it? This recipe will be dedicated
    to using paths to create more complex shapes. We will start by creating a triangle
    and progress from there to more complicated shapes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个教程中学习了如何创建世界国旗四分之一的内容，但这并不能结束，对吧？这个教程将致力于使用路径创建更复杂的形状。我们将从创建一个三角形开始，然后逐渐进展到更复杂的形状。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'Let''s start from the simplest shape that isn''t included in the basic shapes
    library: a triangle. So if you''re ready let''s get started...'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本形状库中不包括的最简单的形状开始：三角形。所以，如果你准备好了，让我们开始吧...
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start with creating our first shape, a triangle:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们的第一个形状开始，一个三角形：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The code here with points `x1,y1` through `x3,y3` is pseudocode. You would need
    to pick your own points to create a triangle.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码中的点 `x1,y1` 到 `x3,y3` 是伪代码。你需要选择自己的点来创建一个三角形。
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Most of the elements here aren't new. The most important change here is that
    we are creating the shape from scratch using the elements we worked with before.
    When we create a shape we always start by declaring it using the `beginPath()`
    method. We then create the shape and end the creation with the `closePath()` method.
    We will still not have anything visible on the screen until we decide what we
    want to do with the shape we created, such as show its fill or show its strokes.
    In this case as we are trying to create a triangle we will call the `fill` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大部分元素都不是新的。这里最重要的变化是，我们正在使用之前使用过的元素从头开始创建形状。当我们创建一个形状时，我们总是从使用 `beginPath()`
    方法声明它开始。然后我们创建形状，并使用 `closePath()` 方法结束创建。在屏幕上我们仍然看不到任何东西，直到我们决定我们想要对我们创建的形状做什么，比如显示它的填充或显示它的描边。在这种情况下，因为我们试图创建一个三角形，我们将调用
    `fill` 函数。
- en: Let's see this in action in a live flag sample. This time we will visit Mount
    Roraima in Guyana.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个真实的国旗示例中看看它的运行情况。这次我们将参观圭亚那的罗赖马山。
- en: '![How it works...](img/3707OT_01_05.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/3707OT_01_05.jpg)'
- en: OK, so you get the idea of the triangle. Let's see this in action. I've extracted
    this code and put it into a function. To create this flag, we will need to create
    four triangles.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你已经了解了三角形的概念。让我们看看它的实际应用。我提取了这段代码并将其放入一个函数中。要创建这个国旗，我们需要创建四个三角形。
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By creating the `fillTriangle()` function we can now quickly and effectively
    create triangles just as we created rectangles. This function makes it a breeze
    to create a flag with such a rich numbers of triangles. Now, with the help of
    the `fillTriangle` method we can create any flag in the world that has triangles
    in it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建 `fillTriangle()` 函数，我们现在可以快速有效地创建三角形，就像我们创建矩形一样。这个函数使得创建一个有如此丰富数量的三角形的国旗变得轻而易举。现在，借助
    `fillTriangle` 方法的帮助，我们可以创建世界上任何有三角形的国旗。
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Don't let triangles be your most complex shape, as you can create any number
    of pointed shapes. Let's create a more complex zigzag pattern. To do so, we will
    fly over to the Kingdom of Bahrain.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让三角形成为你最复杂的形状，因为你可以创建任意数量的尖锐形状。让我们创建一个更复杂的锯齿形图案。为此，我们将飞到巴林王国。
- en: '![There''s more...](img/3707OT_01_06.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/3707OT_01_06.jpg)'
- en: Try to locate the new logic before we break it down and explain it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 试着找到我们分解和解释之前的新逻辑。
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's break down this zigzag and understand what's going on here. After starting
    up with our normal setting up of a canvas element, we jump right into creating
    our shape. We start by drawing a red background, leaving us to create a shape
    that will have the white area. It's very much like a rectangle except that it
    has zigzags in it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个锯齿形并理解这里发生了什么。在正常设置画布元素后，我们立即开始创建我们的形状。我们首先绘制一个红色背景，然后创建一个将有白色区域的形状。它非常像一个矩形，只是它里面有锯齿。
- en: 'In this code, we start by creating a rectangle but our goal will be to change
    the highlighted code line with zigzags:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先创建一个矩形，但我们的目标是改变突出显示的代码行，使其成为锯齿形：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this code we set the fill color to white, we set our `beginPath` and then
    `lineTo` (starting at the point `(0,0)`, the default starting point) and create
    a rectangle that fills 25 percent of the width of the canvas. I''ve highlighted
    the horizontal line as this is the one we want to make zigzags with. By looking
    at the flag we can see that we are going to create five triangles going across
    the screen, so let''s switch this line with a `for` loop:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将填充颜色设置为白色，我们设置了 `beginPath`，然后 `lineTo`（从点 `(0,0)` 开始，即默认起始点）并创建一个填充了画布宽度
    25% 的矩形。我突出了水平线，因为这是我们想要用锯齿形的线。通过观察国旗，我们可以看到我们将在屏幕上创建五个三角形，所以让我们用 `for` 循环来替换这条线：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So our first step before we can run through the loop is to decide how tall
    each triangle will be:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们运行循环之前，我们的第一步是决定每个三角形的高度：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We take the total height of the canvas and divide it by five to give us the
    height for each triangle.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将画布的总高度除以五，得到每个三角形的高度。
- en: 'We draw the zigzags in the `for` loop itself. To do so we need to use the following
    two lines of code in each round:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for` 循环中绘制了锯齿形。为此，我们需要在每一轮中使用以下两行代码：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the first line we step away from the current position and expand the line
    out half way through the height of the triangle, and to the extreme point on the
    right; and then on the second line we return back to the starting `x` point and
    update our `y` to the starting point of the next line segment. By the way, the
    addition of `baseX +25` is totally arbitrary. I just played with it until it looked
    good, but if you want you could use ratios instead (that way if you expand the
    canvas it would still look good).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们远离当前位置，并将线条延伸到三角形高度的一半，并延伸到右侧的极点；然后在第二行中，我们返回到起始的 `x` 点，并更新我们的 `y` 到下一行段的起始点。顺便说一句，`baseX
    +25` 的添加是完全任意的。我只是随意尝试，直到看起来不错，但如果你愿意，你可以使用比例来代替（这样如果你扩展画布，它看起来仍然很好）。
- en: The most amazing part of all of this is just knowing how to create some zigzags,
    triangles, rectangles, and circles. You can create an even larger number of flags
    but we are not done yet. Our quest to know how to create all the flags of the
    world continues.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切最令人惊奇的部分就是知道如何创建一些锯齿、三角形、矩形和圆。你可以创建更多的国旗，但我们还没有完成。我们继续追求如何创建世界上所有国旗的知识。
- en: If you are new to drawing via code or feel you can use some extra practice,
    just look at the map of the world and challenge yourself to create flags based
    on the skills we built already.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是第一次通过代码绘图，或者觉得自己需要一些额外的练习，只需查看世界地图，并挑战自己根据我们已经建立的技能创建国旗。
- en: Creating complex shapes
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建复杂形状
- en: It's time to take everything we learned and integrate it into the most complex
    shape we have seen so far, the Star of David. This star is part of the flag of
    Israel (one of my favorite flags in the world ;)). We need to take a roundabout
    before we can create it by visiting the magical world of sine and cosine.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们学到的一切融入到迄今为止我们见过的最复杂的形状中，即大卫之星。这颗星星是以色列国旗的一部分（世界上我最喜欢的国旗之一；））。在我们能够创建它之前，我们需要绕个圈，访问正弦和余弦的神奇世界。
- en: '![Creating complex shapes](img/3707OT_01_07.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![创建复杂形状](img/3707OT_01_07.jpg)'
- en: You got to love it, right? I know many people fear cosines and sines but actually
    they are really easy and fun to work with. Let's break them down here in a more
    programming-for-drawing type of way. The most basic idea is that you have a triangle
    that has a 90 degree angle. You have some information about this triangle, and
    that's all you need to be able to start working with sine and cosine. Once you
    know that you have a 90 degree angle and know the sine/cosine, you have all the
    information you need and with it you can discover any missing information. In
    our case we know all the angles and we know the length of the hypotenuse (it's
    our radius; take a look at the image with the circle to see it in action). In
    JavaScript, the methods `Math.cos()` and `Math.sin()` are both representing a
    circle with a radius of one located on the (0,0) point on the screen. If we input
    the angle we are looking for into the `sin` function, it would return the `x`
    value (in this case the length of the adjacent) and the `cos` function would return
    the length of the opposite, in our case the required value `y`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定会喜欢它，对吧？我知道很多人害怕余弦和正弦，但实际上它们非常容易和有趣。让我们在这里以一种更适合绘图的方式来解释它们。最基本的想法是你有一个有一个90度角的三角形。你对这个三角形有一些信息，这就是你开始使用正弦和余弦的全部所需。一旦你知道你有一个90度角并且知道正弦/余弦，你就有了所有你需要的信息，通过它你可以发现任何缺失的信息。在我们的情况下，我们知道所有的角度，我们知道斜边的长度（它就是我们的半径；看看带有圆的图像，看看它是如何运作的）。在JavaScript中，`Math.cos()`和`Math.sin()`方法都代表一个半径为1的圆，位于屏幕上的(0,0)点。如果我们将要查找的角度输入到`sin`函数中，它将返回`x`值（在这种情况下是邻边的长度），`cos`函数将返回对边的长度，在我们的情况下是所需的值`y`。
- en: I've made a nice video which goes deeper into the logic. You can check it out
    at [http://02geek.com/courses/video/58/467/Using-Cos-and-Sin-to-animate.html](http://02geek.com/courses/video/58/467/Using-Cos-and-Sin-to-animate.html).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我制作了一个很好的视频，深入探讨了这个逻辑。你可以在[http://02geek.com/courses/video/58/467/Using-Cos-and-Sin-to-animate.html](http://02geek.com/courses/video/58/467/Using-Cos-and-Sin-to-animate.html)上查看它。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The easiest way to understand how sine/cosine work is by a live example, and
    in our case we will use it to help us figure out how to create the Star of David
    in the flag of Israel. We will take a step back and learn how we figured out the
    points on the screen to create the shapes. Again we will be skipping the creation
    of the HTML file and will go right into the JavaScript code. For an overview of
    how to get your HTML set, please review the *Graphics with 2D canvas* recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 理解正弦/余弦工作的最简单方法是通过一个实时的例子，而在我们的情况下，我们将用它来帮助我们弄清楚如何在以色列国旗中创建大卫之星。我们将退一步，学习如何找到屏幕上的点来创建形状。同样，我们将跳过创建HTML文件的过程，直接进入JavaScript代码。有关如何设置HTML的概述，请查看*使用2D画布进行图形处理*配方。
- en: '![Getting ready](img/3707OT_01_08.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/3707OT_01_08.jpg)'
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: After creating the JavaScript file add the following code in your `init` function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建JavaScript文件后，在您的`init`函数中添加以下代码。
- en: 'Create our basic canvas variables:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们基本的画布变量：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define one degree in radians. We do that since `Math.cos` and `Math.sin` expect
    a radian value and not a degree value (`radian` is one degree measured in radians):'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义弧度中的一度。我们这样做是因为`Math.cos`和`Math.sin`期望的是弧度值而不是度值（`radian`是以弧度测量的一度）：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a `tilt` variable. This variable will define the tilt of the triangle
    that will be created. Imagine the triangle is in a circle and we are rotating
    the circle with this `tilt` variable:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`tilt`变量。这个变量将定义将要创建的三角形的倾斜。想象三角形在一个圆内，我们正在用这个`tilt`变量旋转圆：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define the center point of the canvas:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布的中心点：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Set the radius of the invisible bounding circle of the Star of David:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置大卫之星的无形边界圆的半径：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define the height of the strips in the flag:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义国旗中条纹的高度：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Define a line width:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义线宽：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create two triangles (one tilted and one not):'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个三角形（一个倾斜，一个不倾斜）：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Draw flag strips:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制国旗条纹：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create the `createTriangle` function:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`createTriangle`函数：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You are done. Run your application and you will find the flag of Israel with
    the Star of David in the center of the flag.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成了。运行你的应用程序，你会发现以色列国旗，中间有大卫之星。
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before we dig into the creation of the flag and how it was done, we need to
    understand how we locate points in a circle. To do so let''s look at a simpler
    example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨国旗的创建和如何完成它之前，我们需要了解如何在圆中定位点。为此，让我们看一个更简单的例子：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following is the output the code will generate:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码将生成的输出：
- en: '![How it works...](img/3707OT_01_09.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3707OT_01_09.jpg)'
- en: Although a circle, in our human-friendly head, is a shape that has 360 degrees,
    it's actually best represented in most programming languages in radians.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们人类友好的头脑中，一个圆是一个有360度的形状，但实际上在大多数编程语言中最好用弧度表示。
- en: 'Radians are just like degrees, only instead of being human-friendly numbers
    between 0 and 360 these are numbers between 0 and two times Pi. You might be wondering
    what Pi is, so a bit more on Pi. Pi is in essence the value that is created when
    you take the circumference of any circle and divide it by the diameter of the
    same circle. The result that would come back would be Pi or about 3.14159\. It
    is a magical number and the good news is you don''t need to know much more about
    it if you don''t want to. All you need to know is that 3.142 is equal to half
    of a circle. With that fact we can now divide Pi by `180` to get a value in radian
    that equals one degree:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度就像度数一样，只是它们不是人类友好的0到360之间的数字，而是0到两倍Pi之间的数字。你可能想知道Pi是什么，所以再多说一点关于Pi。Pi本质上是当你取任何圆的周长并将其除以相同圆的直径时得到的值。返回的结果将是Pi或约为3.14159。这是一个神奇的数字，好消息是，如果你不想知道更多，你就不需要知道更多。你只需要知道3.142等于半个圆。有了这个事实，我们现在可以将Pi除以`180`得到一个弧度值等于一度的值：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We then create a circle with a radius of `30` in the center of the screen, to
    help us visualize this, and move on to start creating a line that will start at
    angle `0` of our circle and end at angle `120` (as we want to create a triangle
    360/3).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在屏幕中心创建一个半径为`30`的圆，以帮助我们可视化，然后开始创建一条线，该线将从我们圆的角度`0`开始，到角度`120`结束（因为我们想创建一个360/3的三角形）。
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s break down the most complex line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解最复杂的那行代码：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As `Math.sin` and `Math.cos` return a value for a radius of `1`, we will multiply
    any value returned by the radius of our circle (in this case `30`). In the parameters
    of `Math.sin` and `Math.cos`, we will provide the exact same values; in this example
    `120` radians. As our circle would be centered at the top left-hand side of the
    canvas we want to shift the circle to start from the center of the screen by adding
    to our values `wid/2` and `hei/2`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Math.sin`和`Math.cos`返回半径为`1`的值，我们将乘以我们圆的半径（在本例中为`30`）返回的任何值。在`Math.sin`和`Math.cos`的参数中，我们将提供完全相同的值；在这个例子中是`120`弧度。由于我们的圆将位于画布的左上角，我们希望通过添加到我们的值`wid/2`和`hei/2`来将圆移到屏幕中心开始。
- en: At this stage, you should know how to find points on a circle, and with that
    how to draw lines between two points. Let's go back to our flag of Israel and
    take a deeper look into the new function `createTriangle`. It was based on the
    function `fillTriangle` created in the *Creating shapes using paths* recipe.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该知道如何在圆上找到点，以及如何在两点之间画线。让我们回到以色列国旗，深入研究新函数`createTriangle`。它是基于*使用路径创建形状*食谱中创建的`fillTriangle`函数。
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: I've highlighted the new components of this function compared to the function
    `fillTriangle`. The two new parameters `fillColor` and `strokeColor` define if
    we should fill or stroke the triangle. Notice that we moved the `strokeStyle`
    and `fillStyle` methods to the bottom of our function to reduce our code footprint.
    Great! We now have a modern triangle creator that could deal with the Star of
    David.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了这个函数的新组件，与函数`fillTriangle`相比。两个新参数`fillColor`和`strokeColor`定义了我们是否应该填充或描边三角形。请注意，我们将`strokeStyle`和`fillStyle`方法移到函数底部，以减少我们的代码量。太棒了！我们现在有了一个现代的三角形创建器，可以处理大卫之星。
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'OK, time to connect the dots (literally speaking) and create the flag of Israel.
    Looking back at our original code we find ourselves using the `createTriangle`
    function twice to create the full Star of David shape. Let''s take a deeper look
    at the logic here by looking at the second triangle (the one that is turned upside
    down):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是时候连接这些点（字面意思）并创建以色列国旗了。回顾我们的原始代码，我们发现自己使用`createTriangle`函数两次来创建完整的大卫之星形状。让我们深入研究一下这里的逻辑，看看第二个三角形（倒置的那个）：
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are sending in three points on the virtual circle to create a triangle. We
    split our virtual circle to three equal parts and find the point values at the
    `0`, `120`, and `240` degrees. This way if we drew a line between these points
    we would get a perfect triangle in which all of the sides were equal.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送三个点到虚拟圆上创建一个三角形。我们将虚拟圆分成三等份，并找到`0`、`120`和`240`度的点值。这样，如果我们在这些点之间画一条线，我们将得到一个完美的三角形，其中所有边都是相等的。
- en: 'Let''s take a deeper look at one of the points sent to the `createTriangle`
    function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究一下发送到`createTriangle`函数的一个点：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We start from `baseX` and `baseY` (the center of the screen) as the center point
    of our circle before we figure out the actual point gap from that base starting
    point. We then add to it the value that we get from `Math.sin` and `Math.cos`
    respectively. In this example, we are trying to get `120` degrees plus the tilt
    value. In other words, `120` degrees plus `180` degrees (or `300` degrees).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`baseX`和`baseY`（屏幕中心）开始作为我们圆的中心点，然后找出从基本起始点到实际点间的间隙。然后分别从中加上我们从`Math.sin`和`Math.cos`得到的值。在这个例子中，我们试图得到`120`度加上倾斜值。换句话说，`120`度加上`180`度（或`300`度）。
- en: 'To make it easier to comprehend, in pseudocode it would look similar to the
    following code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易理解，在伪代码中，它看起来类似于以下代码片段：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Not much more to say besides congrats. We just finished creating another flag
    and in the process, learned how to create complex shapes, use math to help us
    figure out points on the screen, and mix together different shapes to create more
    advanced shapes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除了祝贺之外，没有更多要说的了。我们刚刚完成了另一面国旗的创建，并在这个过程中学会了如何创建复杂的形状，使用数学来帮助我们找出屏幕上的点，并混合不同的形状来创建更复杂的形状。
- en: Adding more vertices
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多顶点
- en: There are many flags that contain stars that just cannot be created by overlapping
    triangles. In this recipe, we will figure out how to create a star that contains
    an arbitrary number of points We will use the same key concept we discovered in
    the previous recipe by taking advantage of a virtual circle to calculate positions,
    this time with only two virtual circles. In this recipe, we will create the flag
    of Somalia and in the process figure out how to create a function that will enable
    us to create stars.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多国旗包含星星，这些星星无法通过重叠的三角形来创建。在这个示例中，我们将找出如何创建一个包含任意数量顶点的星星。我们将利用在上一个示例中发现的相同关键概念，利用虚拟圆来计算位置，这次只用两个虚拟圆。在这个示例中，我们将创建索马里的国旗，并在此过程中找出如何创建一个能够创建星星的函数。
- en: '![Adding more vertices](img/3707OT_01_10.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![添加更多顶点](img/3707OT_01_10.jpg)'
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Please continue working on the sample from the previous recipe. If you haven't
    worked on it yet, I strongly encourage you to do so as this recipe is the next
    logical step of the previous recipe. As in the previous recipe, we will be skipping
    the HTML portion of this sample. Please review the first recipe in the book to
    refresh on the required HTML code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续在上一个示例中工作。如果您还没有开始，请务必这样做，因为这个示例是上一个示例的下一个逻辑步骤。与上一个示例一样，我们将跳过此示例的HTML部分。请查看本书中的第一个示例，以刷新所需的HTML代码。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's jump right in and create the flag of Somalia.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建索马里的国旗。
- en: 'Create the canvas standard logic:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建画布的标准逻辑：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Fill the background color of canvas:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充画布的背景颜色：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Draw the star by calling the `createStar` function:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`createStar`函数来绘制星星：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the `createStart` function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`createStart`函数：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'From this point on we will be working within the `createStart` function. Add
    a few helper variables:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这一点开始，我们将在`createStart`函数中进行工作。添加一些辅助变量：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Call the `beginPath` method before starting to draw any shape:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始绘制任何形状之前，调用`beginPath`方法：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Move the drawing pointer to the angle `0` in the internal circle:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将绘图指针移动到内部圆圈的角度`0`：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Loop through the total points of the star and draw a line back and forth between
    the outer circle and inner circle to create a star:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历星星的总点数，并在外圆和内圆之间来回绘制线条，以创建星形：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Close the path of the drawing and fill or stroke according to the function
    parameters:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭绘图路径，并根据函数参数进行填充或描边：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When you run your HTML wrapper, you will find your first star and with it another
    flag will be under your belt.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行HTML包装器时，您将找到您的第一个星星，随之而来的是另一面国旗。
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start by understanding what the function we are going to create expects.
    The idea is simple, to create a star we want to have a virtual inner circle and
    a virtual outer circle. We can then draw lines between the circles back and forth
    to create the star. To do so, we need some basic parameters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解我们要创建的函数期望的内容。这个想法很简单，为了创建一个星形，我们希望有一个虚拟的内圆和一个虚拟的外圆。然后我们可以在圆圈之间来回绘制线条，以创建星形。为此，我们需要一些基本参数。
- en: '[PRE74]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Our regular context, `baseX` and `baseY` don't need further introductions. The
    virtual `innerRadius` and `outerRadius` are there to help define the length of
    the line segments that create a star and their positions. We want to know how
    many points our star will have. We do so by adding in the `points` parameters.
    We want to know the `fillColor` and/or `strokeColor` so we can define the actual
    colors of the star. We top it with a `tilt` value (it can be useful as we've seen
    when creating the Star of David for the flag of Israel).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的常规上下文，`baseX`和`baseY`不需要进一步介绍。虚拟的`innerRadius`和`outerRadius`用于帮助定义创建星星的线段的长度和它们的位置。我们想知道我们的星星将有多少个点。我们通过添加`points`参数来实现。我们想知道`fillColor`和/或`strokeColor`，这样我们就可以定义星星的实际颜色。我们用`tilt`值来完成（当我们为以色列国旗创建大卫之星时，它可能很有用）。
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We then move on to configure our facilitator variables for our star. It's not
    the first time we see the radian variable, but it is our first `radianStepper`.
    The goal of the radian stepper is to simplify calculations in our loop. We divided
    360 degrees by the number of points our triangle will have. We divided the value
    by `2`, as we will have two times the number of points as lines. Last but not
    least, we want to convert this value into radians so we are duplicating the full
    results by our radian variable. We then create a simple `currentRadian` variable
    to store the current step we are in and finish off by converting the `tilt` value
    to be a radian value, so we can add it into all our lines without extra calculations
    within the loop.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续配置我们星星的辅助变量。这不是我们第一次看到弧度变量，但这是我们第一次看到`radianStepper`。弧度步进器的目标是简化我们循环中的计算。我们将360度除以我们的三角形将具有的点数。我们将该值除以`2`，因为我们将有两倍于线条的点数。最后但并非最不重要的是，我们希望将该值转换为弧度，因此我们通过我们的弧度变量复制完整的结果。然后我们创建一个简单的`currentRadian`变量来存储我们目前所处的步骤，并最后将`tilt`值转换为弧度值，这样我们就可以在循环中添加到所有我们的线条中而无需额外的计算。
- en: 'As always, we start and complete our shapes with the `beginPath` and `closePath`
    methods. Let''s take a deeper look at the starting position for our soon-to-be
    shape:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们使用`beginPath`和`closePath`方法开始和完成我们的形状。让我们更深入地看一下我们即将形成的形状的起始位置：
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Although at first glance this probably looks a bit scary, it's actually very
    similar to how we created the Star of David. We are starting at `currentRadian`
    (that is currently `0`) using `innerRadius` as our start point.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看这可能有点吓人，但实际上与我们创建大卫之星的方式非常相似。我们从`currentRadian`（目前为`0`）开始，使用`innerRadius`作为起点。
- en: 'In our loop, our goal will be to weave back and forth between the inner and
    external circles. To do so we will need to progress the `currentRadian` value
    each time the loop cycles by a `radianStepper`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的循环中，我们的目标是在内部和外部圆圈之间来回织线。为此，我们需要在每次循环周期中通过`radianStepper`来推进`currentRadian`值：
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We start a loop based on the number of points in our parameter. In this loop,
    we go back and forth between the external radius and the internal one each time
    we draw two lines between the inner circle and the external one. Our step size
    is defined by the number of points (the value we configured with the `radianStepper`
    variable).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据参数中的点数开始一个循环。在这个循环中，我们在内圆和外圆之间来回绘制两条线，每次步进大小由点数（我们用`radianStepper`变量配置的值）定义。
- en: We covered the rest of the functions when we created the `createTriangle` function
    in an earlier recipe. There you have it! You can now run the app and find our
    seventh flag. With this new complex function, we can create all solid stars and
    all non-solid stars that are hollow within.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，当我们创建`createTriangle`函数时，我们已经涵盖了其余的功能。就是这样！现在你可以运行应用程序并找到我们的第七面旗帜。有了这个新的复杂函数，我们可以创建所有实心星星和所有镂空的非实心星星。
- en: OK I hope you are sitting down... with the newly-acquired star powers, you can
    now create at least 109 flags including the United States of America and all the
    other countries that have stars in their flag (57 percent of the countries in
    the world and counting!).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我希望你坐下...有了新获得的星星能力，你现在可以创建至少109面旗帜，包括美利坚合众国和所有其他国家的旗帜（世界上57%的国家，而且还在增加！）。
- en: Overlapping shapes to create other shapes
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重叠形状创建其他形状
- en: There are many flags and many shapes in general that can be created by combining
    the shapes we created so far. One of the most popular shapes in 82 flags we don't
    know how to create is the crescent shape like the one in the flag of Turkey. With
    it we learn a new skill of using subtraction to create more in-depth shapes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们已经创建了许多旗帜和许多一般形状，这些形状可以通过组合我们迄今为止创建的形状来创建。在82面我们不知道如何创建的最受欢迎的形状之一是土耳其国旗中的新月形状。通过它，我们学会了使用减法来创建更深入的形状。
- en: '![Overlapping shapes to create other shapes](img/3707OT_01_11.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![重叠形状创建其他形状](img/3707OT_01_11.jpg)'
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The previous recipe is our starting point in this recipe. From here, we will
    continue working to create more advanced shapes that are built out of two shapes
    when combined. As such, we will be using the code created in the last recipe located
    in `01.02.flags.js`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个教程是本教程的起点。从这里开始，我们将继续努力创建更复杂的形状，这些形状是由两个形状组合而成的。因此，我们将使用上一个教程中创建的代码，位于`01.02.flags.js`中。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's jump right into our code and see it in action.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接跳到我们的代码中，看看它是如何运作的。
- en: 'Gain access to the context and save the width and height of the canvas into
    variables:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取上下文并将画布的宽度和高度保存到变量中：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Fill the rectangle canvas area:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充矩形画布区域：
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a full circle:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个完整的圆：
- en: '[PRE80]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Change the color of canvas fill. Fill a circle within its bound with another
    circle that hides part of the last circle that was created. This effect creates
    a shape that looks like a crescent moon:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改画布填充的颜色。用另一个圆填充其边界内的圆，隐藏了上一个创建的圆的一部分。这种效果创建了一个看起来像新月的形状：
- en: '[PRE81]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Reuse `createStart` from the previous recipe to add the Turkish star:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复使用前一个教程中的`createStart`来添加土耳其星：
- en: '[PRE82]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: There you go! You've just created a shape that is not possible without masking
    one shape with another.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你刚刚创建了一个不可能的形状，这是通过用一个形状遮罩另一个形状实现的。
- en: How it works...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The catch here is we are using two circles, one overlaps the other to create
    a crescent shape. By the way, notice how we are tilting the star as well so that
    one of its points will point to the middle of the circle.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是我们使用了两个圆，一个覆盖另一个来创建新月形状。顺便说一句，注意我们如何倾斜星星，以便其一个点指向圆的中心。
- en: We've gone through a lot in the last few examples and at this stage you should
    be very comfortable creating many shapes and elements in the canvas. There is
    still much to explore before we can say we have mastered canvas, but we can definitely
    say we have mastered creating most of the flags of the world and that's very cool.
    I would love to see your flags. Drop me a line when you create one not in the
    book! :)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几个示例中，我们已经经历了很多，此时你应该非常熟悉在画布中创建许多形状和元素。在我们可以说我们已经掌握了画布之前，还有很多东西可以探索，但我们绝对可以说我们已经掌握了大部分世界旗帜的创建，这非常酷。我很想看到你的旗帜。当你创建了一面书中没有的旗帜时，给我留言！
    :)
