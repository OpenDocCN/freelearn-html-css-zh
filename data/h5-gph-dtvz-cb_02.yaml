- en: Chapter 2. Advanced Drawing in Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。画布中的高级绘图
- en: Drawing arcs
  id: totrans-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制弧线
- en: Drawing curves with a control point
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制点绘制曲线
- en: Creating a Bezier curve
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建贝塞尔曲线
- en: Integrating images into our art
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像整合到我们的艺术中
- en: Drawing with text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本绘制
- en: Understanding pixel manipulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解像素操作
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This is the last chapter where we will dig deep into canvas as the remaining
    chapters will focus on building charts and interactivity.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一章，我们将深入研究画布，因为剩下的章节将专注于构建图表和交互。
- en: In this chapter, we will continue to master our skills with canvas by adding
    curves, images, text, and even pixel manipulation to our tool belt.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续通过向画布添加曲线、图像、文本，甚至像素操作来掌握我们的技能。
- en: Drawing arcs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制弧线
- en: There are three types of curves we can create in canvas—using the arc, quadratic
    curves, and Bezier curves. Let's get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在画布中创建三种类型的曲线 - 使用弧线、二次曲线和贝塞尔曲线。让我们开始吧。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you recall in [Chapter 1](ch01.html "Chapter 1. Drawing Shapes in Canvas"),
    *Drawing Shapes in Canvas*, in our first recipe we used the arc method to create
    perfect circles. The arc method is much more than just that. We can actually create
    any partial curve in a circular shape. If you don't recall drawing circles, I
    strongly encourage you to scan through [Chapter 1](ch01.html "Chapter 1. Drawing
    Shapes in Canvas"), *Drawing Shapes in Canvas* again, and while you are there,
    you will find the template for creating the HTML documents as well. We are exclusively
    going to focus on the JavaScript code in this recipe.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回忆一下[第1章](ch01.html "第1章。画布中的形状绘制")，*画布中的形状绘制*，在我们的第一个示例中，我们使用弧线方法创建了完美的圆圈。弧线方法不仅仅是如此。我们实际上可以在圆形中创建任何部分曲线。如果您不记得绘制圆圈，我强烈建议您再次浏览[第1章](ch01.html
    "第1章。画布中的形状绘制") ，*画布中的形状绘制*，同时您也会找到创建HTML文档的模板。在本示例中，我们将专门关注JavaScript代码。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s jump into it and create our first noncircle that has curves:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始并创建我们的第一个具有曲线的非圆形：
- en: 'Access the `pacman` canvas element and fetch its width and height by using
    the following code snippet:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`pacman`画布元素，并使用以下代码片段获取其宽度和高度：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `radian` variable (one degree in radians):'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`radian`变量（一度的弧度）：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Get the canvas context and fill its background in black by using the following
    code snippet:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取画布上下文，并使用以下代码片段将其背景填充为黑色：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Begin a new path before starting to draw:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始绘制之前开始一个新路径：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Change fill style color:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改填充样式颜色：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Move the pointer to the center of the screen:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指针移动到屏幕中心：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Draw a curve that starts at 40 degrees and ends at 320 degrees (with a radius
    of 40) in the center of the screen:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个从40度开始到320度结束的曲线（半径为40），位于屏幕中心：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Close the shape by drawing a line back to the starting point of our shape:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下代码片段，关闭形状，绘制一条线回到我们形状的起始点：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Close the path and fill the shape:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭路径并填充形状：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You have just created a PacMan.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了一个PacMan。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For the first time, we take advantage and create a pie-type shape, known as
    PacMan (you can see how this can be very useful when we get into creating the
    pie graph). Very simple—again we connect to that idea of radians:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，我们利用并创建了一个饼状形状，称为PacMan（当我们开始创建饼图时，您可以看到这是非常有用的）。非常简单 - 再次连接到弧度的概念：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how our 4th and 5th parameters—instead of being a complete circle by
    starting from 0 and ending at `2*Math.PI`—are setting the angle to start the arc
    at radian 40 and end at radian 320 (leaving 80 degrees open to create the mouth
    of a PacMan ). All that is left is to start drawing from the center of the circle:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们的第4和第5个参数 - 而不是从0开始到`2*Math.PI`结束的完整圆圈 - 正在设置弧线开始的角度为弧度40，结束于弧度320（留下80度来创建PacMan的嘴）。剩下的就是从圆的中心开始绘制：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start by moving our pointer to the center of our circle. We then create the
    arc. As our arc isn't a complete shape it's continuing where we left off—drawing
    a line from the center of the arc to the starting point (40 degrees). We complete
    the action by drawing a line back to the center of the arc to complete the shape.
    Now we are ready to fill it and complete our work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将指针移动到圆的中心。然后创建弧线。由于我们的弧线不是完整的形状，它会继续我们离开的地方 - 从弧线的中心到起始点（40度）画一条线。我们通过画一条线回到弧线的中心来完成动作。现在我们准备填充它并完成我们的工作。
- en: '![How to do it...](img/3707OT_02_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3707OT_02_01.jpg)'
- en: Now that we have got arcs out of the way, you can see how useful this will be
    for creating pie charts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经解决了弧线问题，您可以看到这对于创建饼图将会非常有用。
- en: Drawing curves with a control point
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制点绘制曲线
- en: 'If the world was just two points with a perfect arc this would be the end of
    the book, but alas or lucky for us, there are still many more complex shapes to
    learn and explore. There are many curves that are not perfectly aligned curves.
    Till now all the curves that we created were part of a perfect circle, but not
    any more. In this recipe, we will explore quadratic curves. The quadratic curves
    enable us to create curves that are not circular, by adding a third point—a controller
    to control the curve. You can easily understand this by looking at the following
    diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果世界上只有两个点和一个完美的弧线，那么这将是本书的结尾，但不幸或幸运的是，对我们来说，还有许多更复杂的形状需要学习和探索。有许多曲线不是完全对齐的曲线。到目前为止，我们创建的所有曲线都是完美圆的一部分，但现在不再是这样了。在本示例中，我们将探索二次曲线。二次曲线使我们能够创建不是圆形的曲线，通过添加第三个点
    - 控制器来控制曲线。您可以通过查看以下图表轻松理解这一点：
- en: '![Drawing curves with a control point](img/3707OT_02_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![使用控制点绘制曲线](img/3707OT_02_02.jpg)'
- en: A **quadratic curve** is a curve that has one control point. Consider the case
    when creating a line, we draw it between two points (A and B in this illustration).
    When we want to create a quadratic curve, we use an external gravity controller
    that defines the direction of the curve while the middle line (the dotted line)
    defines how far will the curve reach.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**二次曲线**是一条具有一个控制点的曲线。考虑这样一种情况，当创建一条线时，我们在两点（本示例中的A和B）之间绘制它。当我们想要创建一个二次曲线时，我们使用一个外部重力控制器来定义曲线的方向，而中间线（虚线）定义了曲线的延伸距离。'
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As done in previous recipes, we are skipping the HTML part here too—not that
    it's not needed, it just repeats itself in every recipe and if you need to refresh
    yourself on how to get the HTML setup, please take a look at the *Graphics with
    2D Canvas* recipe in [Chapter 1](ch01.html "Chapter 1. Drawing Shapes in Canvas"),
    *Drawing Shapes in Canvas*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的示例一样，我们在这里也跳过了HTML部分——并不是说它不需要，只是每个示例中都重复出现，如果您需要了解如何设置HTML，请参阅[第1章](ch01.html
    "第1章. 在画布中绘制形状")中的*使用2D画布绘图*示例，*在画布中绘制形状*。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this example, we will create a closed shape that looks like a very basic
    eye. Let''s get started:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个看起来像一个非常基本的眼睛的封闭形状。让我们开始吧：
- en: 'We always need to start with extracting our canvas element, setting up our
    width and height variables, and defining a radian (as we find it useful to have
    one around):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们总是需要从提取我们的画布元素开始，设置我们的宽度和高度变量，并定义一个弧度（因为我们发现它对我们有用）：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, fill our canvas with a solid color and after that begin a new shape by
    triggering the `beginPath` method:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用纯色填充我们的画布，然后通过触发`beginPath`方法开始一个新形状：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define the line width and stroke color for our eye shape:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的眼睛形状定义线宽和描边颜色：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Move our drawing pointer to the left-centered point as we will need to draw
    a line from left to right in the center of the screen and back (only with a curve):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的绘图指针移动到左中心点，因为我们需要在屏幕中心从左到右绘制一条线，然后再返回（只使用曲线）：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Draw two quadratic curves from our initial point to the other side of the canvas
    and back to the initial point by using an anchor point, which is in the extreme
    top followed by the extreme bottom of the canvas area:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用锚点从我们的初始点绘制两个二次曲线到画布的另一侧，然后返回到初始点，锚点位于画布区域的极端顶部和极端底部：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Close the path. Fill the shape and use the `stroke` method on the shape (`fill`
    for filling the content and `stroke` for outlines):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭路径。填充形状并在形状上使用`stroke`方法（`fill`用于填充内容，`stroke`用于轮廓）：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great job! You have just created your first shape by using the `quadraticCurveTo`
    method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您刚刚使用`quadraticCurveTo`方法创建了您的第一个形状。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Let''s look at this method closely:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个方法：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we are already at the origin point (point A), we input two other points—the
    control point and point B.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经在原点（点A）上，我们输入另外两个点——控制点和点B。
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In our sample, we create a contained shape—the starting point to create an eye.
    Play with the controller to see how it affects the direction and size of the curve.
    The thumb rule is that the closer to the vertical line the less steep the curve
    will be, and the further away it is from the center point the more curved shape
    would be to the offset.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个封闭形状——创建眼睛的起点。通过控制器来调整方向和曲线的大小。一个经验法则是，越靠近垂直线，曲线就会越平缓，而离中心点越远，曲线的形状就会越弯曲。
- en: '![How it works...](img/3707OT_02_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/3707OT_02_03.jpg)'
- en: Creating a Bezier curve
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建贝塞尔曲线
- en: We've just learned that with the quadratic curve we have one control point.
    Although we can do many things with one control point, we don't really have full
    control over the curve. So let's take it one step further by adding one more control
    point. Adding a second control point actually adds the relationship between these
    two points as well making it three control factors. If we include the actual anchor
    points (we have got two of them), we end up with five points that control the
    shape of the curve. That does sound complicated; it's because the more control
    we get the more complicated it is to actually understand how it works. It's really
    not easy to figure out complicated curves by code alone and as such we actually
    use other tools to help us figure out the right curves.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学到，使用二次曲线时我们有一个控制点。虽然我们可以用一个控制点做很多事情，但我们并没有真正对曲线有完全的控制。所以让我们更进一步，添加一个控制点。添加第二个控制点实际上增加了这两个点之间的关系，使其成为三个控制因素。如果我们包括实际的锚点（我们有两个），最终会有五个控制形状的点。这听起来很复杂；因为我们获得的控制越多，理解它的工作原理就越复杂。仅仅通过代码来弄清楚复杂的曲线并不容易，因此我们实际上使用其他工具来帮助我们找到正确的曲线。
- en: To prove the preceding point, we can find a very complex shape and start with
    that one (don't worry, later on in this recipe, we will practice on a very simple
    shape to make the concept clear). We will pick to draw the flag of Canada and
    mainly the maple leaf.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明前面的观点，我们可以找到一个非常复杂的形状并从那个形状开始（不用担心，在本示例中，我们将练习一个非常简单的形状，以便搞清楚概念）。我们将选择绘制加拿大国旗，主要是枫叶。
- en: '![Creating a Bezier curve](img/3707OT_02_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![创建贝塞尔曲线](img/3707OT_02_06.jpg)'
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is difficult to understand, but we will break it down into details
    in the following *How it works...* section. So if you are new to curves, I strongly
    encourage you to start learning from this *How it works...* section before implementing
    it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很难理解，但我们将在接下来的*工作原理...*部分详细介绍。所以如果您对曲线不熟悉，我强烈建议您在实现之前从*工作原理...*部分开始学习。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create the flag of Canada. Let''s jump right into the JavaScript code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建加拿大国旗。让我们直接进入JavaScript代码：
- en: 'Create the canvas and context:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建画布和上下文：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Fill the background to match the background of the Canadian flag:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充背景以匹配加拿大国旗的背景：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Begin a new path and move the pointer to `84,19`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新路径并将指针移动到`84,19`：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Draw curves and lines to create the maple leaf:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制曲线和线条以创建枫叶：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Close the path and fill the shape:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭路径并填充形状：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, you have created the flag of Canada. I don't know if you already know why
    it works or how we got to the apparently random numbers that we put into our curves
    to create the flag, but you've created the flag of Canada! Don't worry, we are
    about to decrypt the magic of curves right away in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经创建了加拿大国旗。我不知道你是否已经知道它是如何工作的，或者我们是如何得到我们放入曲线中的看似随机的数字的，但你已经创建了加拿大国旗！不要担心，我们将立即在下一节中解密曲线的魔力。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Before we can explain the details of how the Canadian flag works, we should
    take a step back and create a simpler example. In this short example, we will
    create an oval shape by using the `bezierCurveTo` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释加拿大国旗的工作原理之前，我们应该退后一步，创建一个更简单的示例。在这个简短的示例中，我们将使用`bezierCurveTo`方法创建一个椭圆形状。
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s it. The following is the outcome you get out of this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。以下是你通过这种方法得到的结果：
- en: '![How it works...](img/3707OT_02_04.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的……](img/3707OT_02_04.jpg)'
- en: 'If you get this, you are in great shape. We will now explain how this works
    and then move into how we figured out all the points for the Canadian flag. We
    are taking advantage of the full canvas again and we are keeping our controllers
    under control by setting two of our controllers to be the corners of the canvas:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你明白了这一点，那就太好了。我们现在将解释这是如何工作的，然后进入我们是如何找出加拿大国旗的所有点的。我们再次充分利用整个画布，并通过将两个控制器设置为画布的角来控制我们的控制器：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Play around with the controllers to see how much more control you get by using
    two dots—this is very useful when you need more detailed control over a curve.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操纵控制器，看看使用两个点可以获得多少更多的控制权——当你需要更详细地控制曲线时，这是非常有用的。
- en: This is the heart of the full example of our full flag. I strongly encourage
    you to explore the effects of changing the values of the control points to get
    a better understanding and sensitivity to it. It's time for us to get back to
    our flag and see how we structured it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们完整国旗示例的核心。我强烈建议你探索改变控制点的值的影响，以更好地理解和敏感于它。现在是时候回到我们的国旗，看看我们是如何构造它的。
- en: 'It''s time to take our most complex drawing style—Bezier curves—and put them
    to action with something a bit more interesting than an oval. I have a confession:
    when I decided to create the flag of Canada from scratch I got scared. I was thinking
    "How am I going to get this done? This is going to take me hours," and then it
    hit me... it was clear that this flag needs to be created with a lot of Bezier
    points but how would I know where the points should be? So for a shape this advanced,
    I opened up my graphics editor (in my case, Flash Editor) and added pivot points
    to the maple shape:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们最复杂的绘图风格——贝塞尔曲线——用于比椭圆更有趣的东西了。我有一个坦白：当我决定从头开始创建加拿大国旗时，我感到害怕。我在想“我要怎么完成这个？这将花费我几个小时”，然后我恍然大悟……很明显，这面旗帜需要用很多贝塞尔点来创建，但我怎么知道这些点应该在哪里呢？因此，对于这样一个高级的形状，我打开了我的图形编辑器（在我这里是Flash编辑器），并为枫叶形状添加了枢轴点：
- en: '![How it works...](img/3707OT_02_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的……](img/3707OT_02_05.jpg)'
- en: If you closely look at the previous diagram, I basically traced the flag of
    Canada and placed a black dot on every sharp corner. Then I created a canvas and
    drew lines to see if the base shape I got was in the right overall position (by
    the way, I got the dots just by selecting the dots in Flash to see if their (x,
    y) coordinates as Flash and canvas coordinate systems are the same).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看前面的图表，你会发现我基本上是在加拿大国旗上做了标记，并在每个尖角上放了一个黑点。然后我创建了一个画布，并画了线，看看我得到的基本形状是否在正确的位置（顺便说一句，我得到这些点只是通过选择Flash中的点，看看它们的（x，y）坐标是否与画布坐标系统相同）。
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I got a shape that was far from what I was looking for. But now I knew that
    my shape was getting formed in the right direction. What were missing were the
    curves to connect between the dots. If you look at the preceding diagram again,
    you will notice that I've placed two blue points between each sharp corner to
    define where the curves would be and how sharp or soft they would be. I then moved
    back into canvas and then updated the values to have the two control points. I
    added all the curves and switched from creating strokes to creating a fill.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了一个远离我想要的形状。但现在我知道我的形状正在朝着正确的方向发展。缺少的是连接点之间的曲线。如果你再次看前面的图表，你会注意到我在每个尖角之间放了两个蓝点，以定义曲线的位置以及它们的锐利或柔和程度。然后我回到画布，更新了值以获得这两个控制点。我添加了所有的曲线，并从创建描边切换到创建填充。
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Bingo! I just got an almost perfect flag and I feel this is enough for this
    sample.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我刚刚得到了一个几乎完美的国旗，我觉得这对这个样本来说已经足够了。
- en: Don't try to create very complex shapes on your own just yet. Maybe there are
    a few people out there who can do that, but for the rest of us the best way to
    do it is to trace the elements by using a visual editor of some sort. We can then
    grab the graphic information and update the values in canvas as I've done with
    the Canadian flag example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图自己创建非常复杂的形状。也许有一些人可以做到，但对于我们其他人来说，最好的方法是通过某种视觉编辑器来追踪元素。然后我们可以获取图形信息，并像我在加拿大国旗示例中所做的那样更新画布中的值。
- en: At this stage, we have covered the most complex shapes that we can cover in
    canvas. The rest of the chapter is dedicated to other ways of manipulating content
    on the screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经涵盖了画布中可以涵盖的最复杂的形状。本章的其余部分专门讨论屏幕上内容的其他操作方式。
- en: Integrating images into our art
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像集成到我们的艺术中
- en: Lucky for us, we don't need to start from scratch always and we can leave the
    more complex art for external images. Let's figure out how we can integrate images
    into our canvas.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们并不总是需要从头开始，我们可以把更复杂的艺术留给外部图像。让我们想想如何将图像集成到我们的画布中。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We've been in a flag theme in this chapter and getting another flag under our
    belt sounds real good to me right now. So let's turn our heads to Haiti and get
    their flag up and running. To create this flag, we need to have the image of the
    symbol that is placed in the center of the flag.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在讨论国旗主题，现在我觉得现在是时候再添一面国旗了。所以让我们把目光转向海地，让他们的国旗运行起来。要创建这面国旗，我们需要有放置在国旗中心的象征的图像。
- en: '![Getting ready](img/3707OT_02_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/3707OT_02_07.jpg)'
- en: In the source files, you will find an image of the center graphic (at `img/haiti.png`).
    By the way, when integrating art into canvas it's always best to avoid resizing
    the image whenever possible via code to preserve the image quality.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件中，您会找到一个中心图形的图像（在`img/haiti.png`）。顺便说一句，当将艺术作品整合到画布中时，最好尽量避免通过代码调整图像大小，以保持图像质量。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will prepare the background to match the flag and then put the entire image
    above it in the center of the canvas/flag:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将准备背景以匹配国旗，然后将整个图像放在国旗的中心/画布上：
- en: 'Follow the basic steps that we need to access the canvas. Set the width, height,
    and the actual context:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照我们需要访问画布的基本步骤。设置宽度、高度和实际上下文：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Draw the background elements:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制背景元素：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a new `Image` object:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Image`对象：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create an `onLoad` function (that will be called when the image is loaded):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`onLoad`函数（当图像加载时将被调用）：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Set the source of the image:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置图像的来源：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Yes, it's that easy to add images into canvas, but let's review more deeply
    what we have just done.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，将图像添加到画布中是如此简单，但让我们更深入地审视一下我们刚刚做的事情。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The steps involved in creating an image are downloading its data and then creating
    a new image container in the same way as it is done in canvas:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像涉及下载其数据，然后以与画布相同的方式创建一个新的图像容器：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next step is to create a listener that will be triggered when the image
    is loaded and ready to be used:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个监听器，当图像加载并准备好使用时将被触发：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last step in the loading process is to tell canvas what image should be
    loaded. In our case we are loading `img/haiti.png`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 加载过程的最后一步是告诉画布应该加载哪个图像。在我们的情况下，我们正在加载`img/haiti.png`：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Loading an image and having it ready to be used is only the first step. If we
    ran our application without actually telling canvas what to do with it, nothing
    would happen beyond the loading of the image.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像并准备好使用它只是第一步。如果我们在没有实际告诉画布该怎么处理它的情况下运行我们的应用程序，除了加载图像之外什么也不会发生。
- en: 'In our case, when our listener is triggered, we add the image as it is to the
    center of the screen:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，当我们的监听器被触发时，我们将图像按原样添加到屏幕的中央：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That is all it takes to integrate an image into a canvas project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将图像整合到画布项目中所需的全部步骤。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are more operations that we can do with images in canvas beyond using
    them as backgrounds. We can define exactly what parts of the image we want (scaling).
    We can resize and manipulate the full image (scaling). We can even pixel manipulate
    our images. There are many things that we can do with images, but in the next
    few topics we will cover some of the more often used ones.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布中，我们可以对图像进行更多的操作，而不仅仅是将它们用作背景。我们可以精确定义图像的哪些部分（缩放）。我们可以调整和操作整个图像（缩放）。我们甚至可以对图像进行像素操作。我们可以对图像做很多事情，但在接下来的几个主题中，我们将涵盖一些更常用的操作。
- en: Scaling images
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放图像
- en: 'We can scale the image by adding two more parameters to the `drawImage` function,
    which sets the width and height of our image. Try the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`drawImage`函数添加两个参数来缩放图像，这两个参数设置了我们图像的宽度和高度。尝试以下操作：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the previous sample, we are loading the same image but we are forcing a resized
    image (note that the positions are not going to be in the actual center of the
    stage).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在加载相同的图像，但我们正在强制调整大小的图像（请注意，位置不会在舞台的实际中心）。
- en: Adding even more control
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加更多的控制。
- en: 'You can control many aspects of an image. If you need more control than the
    preceding sample, you would need to input the full number of possible coordinates:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以控制图像的许多方面。如果您需要比前面示例更多的控制，您需要输入可能坐标的完整数量：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, the order has changed (notice that!). Now, the first two parameters
    after `this` are the local x and y coordinates of the image followed by the width
    and height (creating the crop that we were talking about) followed by the position
    on the canvas and its controlling information (x, y, width, and height).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，顺序已经改变（注意！）。现在，在`this`之后的前两个参数是图像的本地x和y坐标，然后是宽度和高度（创建我们谈论的裁剪），然后是画布上的位置及其控制信息（x、y、宽度和高度）。
- en: 'In our case:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code line means we want to take the image from its internal position
    of (25,25) and we want to slice a 20 x 20 rectangle out of there. We then want
    to position this new cropped image at (0,0) that is, the top corner of the canvas
    and we want that output to be a 50 x 50 rectangle.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行意味着我们想要从图像的内部位置（25,25）取图像，并且我们想要从中裁剪出一个20 x 20的矩形。然后我们想要将这个新裁剪的图像定位在（0,0），也就是画布的左上角，我们希望输出是一个50
    x 50的矩形。
- en: Using images as a fill
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图像作为填充
- en: 'We can use our loaded image as a way to fill up objects as well:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用加载的图像来填充对象：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the image is loaded (always after the image is loaded, you start manipulating
    it), we create a pattern that repeats based on our image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图像加载后（始终在图像加载后，您开始操作它），我们创建一个基于我们的图像重复的模式：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can then use this pattern as our fill. So in this case, we are calling the
    `createStar` that we created in an earlier task—drawing a star in the center of
    the screen—by using the following pattern:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用这种模式作为我们的填充。因此，在这种情况下，我们正在调用我们在早期任务中创建的`createStar`——通过以下模式在屏幕中心绘制一个星星：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This ends our flag obsession to move on to shapes that just don't appear in
    flags. By the way, at this stage you should be able to create all the flags in
    the world and take advantage of integrating images when it's just not fun to draw
    it yourself from scratch—such as detailed country logos.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对旗帜的痴迷，转向了在旗帜中看不到的形状。顺便说一下，在这个阶段，你应该能够创建世界上所有的旗帜，并利用集成图像的优势，当你自己从头开始绘制它时，这样做就不再有趣，比如详细的国家标志。
- en: Drawing with text
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用文本绘图
- en: I agree, we've been working on some complicated things. Now, its time for us
    to lay back, kick off the shoes, and do something a bit easier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意，我们一直在做一些复杂的事情。现在，是时候放松一下，踢掉鞋子，做一些更容易的事情了。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The good news is, if you are on this page, you should already know the basics
    of getting a canvas up and running. So there isn't much more that you need to
    do besides picking the font, size, and position of your text.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果你在这个页面上，你应该已经知道如何启动和运行画布的基础知识。所以除了选择文本的字体、大小和位置之外，你没有太多需要做的事情。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we aren't covering how you can embed fonts that aren't created within
    JavaScript, but instead, via CSS, we will use a basic font and hope for the best
    in this sample.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不涉及如何嵌入在JavaScript中创建的字体，而是通过CSS，我们将使用基本字体，并希望在这个示例中取得最好的效果。
- en: '![Getting ready](img/3707OT_02_08.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/3707OT_02_08.jpg)'
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this example, we are going to create a text field. In this process, we are
    going to use gradients and shadows for the first time. Perform the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个文本字段。在这个过程中，我们将第一次使用渐变和阴影。执行以下步骤：
- en: 'Gain access to the canvas 2D API:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得对画布2D API的访问：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a gradient style and fill the background with it:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建渐变样式并用它填充背景：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a gradient to be used by the text:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于文本的渐变：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define the font to be used and set the style:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要使用的字体并设置样式：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add shadow details before drawing the text:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在绘制文本之前添加阴影细节：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Use `fillText` to fill the shape and `strokeText` for outlines of the shape
    (notice that I call the text a shape; this is because as soon as we draw it, it
    will just be a part of our canvas and not live text):'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fillText`填充形状，使用`strokeText`描绘形状的轮廓（请注意，我称文本为形状；这是因为一旦我们绘制它，它就只是我们画布的一部分，而不是实时文本）。
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's it, we just integrated our first drawn text into canvas.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们刚刚将我们第一次绘制的文本集成到了画布中。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Until now, we were stuck with the solid colors. We will now break out of that
    and move to a new world of gradient colors. Refer to the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用纯色。现在，我们将摆脱这一点，转向渐变颜色的新世界。请参考以下代码片段：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There are a few steps involved with creating a gradient. The first step is
    defining its scope:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建渐变涉及几个步骤。第一步是定义它的范围：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Contrary to many other languages, it's really easy to define the rotation and
    size of a gradient in canvas. If you have worked with Photoshop before, you will
    find this really easy (even if you haven't, it will be easy).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言相反，在画布中定义渐变的旋转和大小非常容易。如果你以前使用过Photoshop，你会发现这很容易（即使你没有，它也会很容易）。
- en: 'All you need to do is define where you want the gradient to start and where
    you want it to end. You can send two dots into the method `createLinearGradient`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的就是定义渐变的起始位置和结束位置。你可以将两个点发送到`createLinearGradient`方法中：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this transition, we are using only two colors. Position them at a value between
    0 and 1\. These values are ratios, so we are, in other words, requesting to spread
    the color transition from the start of the gradient area all the way to the end.
    We could add more colors, but our goal is to bind them all within the ratio 0
    to 1\. The more colors you add, the more playing around you would need to do with
    the values sent into the first parameter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过渡中，我们只使用两种颜色。将它们放在0和1之间的值。这些值是比率，换句话说，我们要求从渐变区域的开始一直到结束来扩展颜色过渡。我们可以添加更多的颜色，但我们的目标是将它们都绑定在0到1的比率内。你添加的颜色越多，你就需要更多地玩弄发送到第一个参数的值。
- en: 'You just completed creating a gradient. Time to use it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了创建渐变。现在是时候使用它了：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this part again, we will use the `fillStyle` method and then create a rectangle.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们将使用`fillStyle`方法，然后创建一个矩形。
- en: Please note the importance of the range of values that you may send to the `addColorStop`
    method. As you add more colors into your gradient, the more noticeable the importance
    of the values sent here will be. The points are not counters but ratios of colors
    in our sample. The transition is between the two colors' range from 0 to 1 or
    in other words they transition all the way through from our first point that we
    send into the `createLinearGradient` method all the to the last point. As we are
    working with two colors, this is the perfect ratio for us.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可能发送到`addColorStop`方法的值范围的重要性。随着你在渐变中添加更多的颜色，这里发送的值的重要性就会更加明显。这些点不是计数器，而是我们示例中颜色的比率。过渡是在两种颜色的范围从0到1之间，换句话说，它们从我们发送到`createLinearGradient`方法的第一个点一直到最后一个点进行过渡。由于我们正在使用两种颜色，这对我们来说是完美的比率。
- en: 'Although we are not getting into radial gradients, they should be really easy
    for you as we have already learned a lot about radial shapes and gradients. The
    signature of this method is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有涉及径向渐变，但对你来说应该很容易，因为我们已经学到了很多关于径向形状和渐变的知识。该方法的签名如下：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The only difference here is that our shape is a radial shape. We also want to
    add the starting radius and ending radius into it. You might be wondering why
    we need two or even more radii. So why can't we figure out the radius based on
    the distance between the two dots (start point and end point)? I hope you are
    wondering about that and if you are not, wonder about it for a second before reading
    the next paragraph.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的区别是我们的形状是一个径向形状。我们还想将起始半径和结束半径添加到其中。你可能会想知道为什么我们需要两个甚至更多的半径。那么为什么我们不能根据两个点（起点和终点）之间的距离来确定半径呢？我希望你会对此感到好奇，如果你没有，那么在阅读下一段之前，请先思考一下。
- en: We have a separate control over the radius, mainly to enable us to separate
    the radius and to enable us to move the focal point within the drawing without
    changing the actual art or recalculating the ratios of colors. A really great
    way to see this in use is when drawing the moon. The moon's gradients over time
    will change or more accurately the radius of the colors and position of the radius
    would change over time depending on the moon's position compared to the sun.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以单独控制半径，主要是为了使我们能够分离半径并使我们能够在不改变实际艺术或重新计算颜色比例的情况下移动绘图中的焦点。一个真正好的方法是在绘制月亮时使用它。月亮的渐变随时间会改变，或者更准确地说，颜色的半径和半径的位置会随时间改变，具体取决于月亮相对于太阳的位置。
- en: We are not done yet. We just mastered everything that we need to know about
    gradients and it's time for us to integrate some text into it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。我们刚刚掌握了关于渐变的所有知识，现在是时候将一些文本整合到其中了。
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We set the global font value and then create a new text element. The `fillText`
    method gets three parameters; the first is the text to be used while the other
    two are the x and y positions of the new element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置全局字体值，然后创建一个新的文本元素。`fillText`方法有三个参数；第一个是要使用的文本，另外两个是新元素的x和y位置。
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In our example, we are giving our text drawing both a fill and an outline. The
    two functions are called separately. The `fillText` method is used to fill the
    content of the shape while the `strokeText` method is called to outline the text.
    We can use any one of them or both of the methods and they can get the exactly
    same parameters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们给我们的文本绘制了填充和轮廓。这两个函数是分开调用的。`fillText`方法用于填充形状的内容，而`strokeText`方法用于轮廓文本。我们可以使用其中一个或两个方法，它们可以获得完全相同的参数。
- en: There's more...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some more options that you can explore.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些更多的选项可以让你去探索。
- en: Using gradients in your text
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文本中使用渐变
- en: If you can do anything to any graphical element in canvas, you can do it to
    text as well—for example, in our sample we are using a gradient for our text.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以对画布中的任何图形元素进行任何操作，那么您也可以对文本进行操作，例如，在我们的示例中，我们为文本使用了渐变。
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice that we are updating our gradient. Our last gradient was too big for
    such a small text area. As such, we are drawing a line from around the start of
    our text going horizontally for 110 pixels.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在更新我们的渐变。我们上一个渐变对于如此小的文本区域来说太大了。因此，我们正在从文本的开始周围水平绘制一条线，长度为110像素。
- en: Adding shadows and glows
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加阴影和发光
- en: 'You can add a shadow/glow to any filled element:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向任何填充元素添加阴影/发光：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can control the position of the offset of the shadow. In our case, we want
    it to be a glow, so we placed our shadow exactly under our element. When setting
    the blur values to a shadow, try using values that are powers of 2 for efficiency
    (its easier to render values that are powers of 2).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以控制阴影的偏移位置。在我们的例子中，我们希望它成为一个发光的效果，所以我们把阴影放在了我们的元素正下方。当将模糊值设置为阴影时，尝试使用2的幂值以提高效率（渲染2的幂值更容易）。
- en: Notice that when we defined our shadow color, we opted to use an RGBA as we
    wanted to set that alpha value to 50 percent.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们定义阴影颜色时，我们选择使用RGBA，因为我们希望将alpha值设置为50%。
- en: Understanding pixel manipulation
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解像素操作
- en: Now that you have mastered drawing in canvas, it's time for us to turn to a
    new aspect of working with canvas. In canvas, you can manipulate pixels. It's
    not only a vector drawing tool, but a very smart pixel editor (raster).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了在画布中绘制的技巧，是时候转向与画布一起工作的新方面了。在画布中，您可以操作像素。它不仅是一个矢量绘图工具，还是一个非常智能的像素编辑器（光栅）。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Now that we are about to start reading data that is present on the canvas, we
    need to understand how security works when it comes to pixels. In an effort to
    protect content that isn't yours, there are security issues involved in working
    with data that isn't hosted on the same host as yours. We will not cover these
    security issues in this section and will be always working with images in the
    same domain as our code (or all locally).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们即将开始读取画布上存在的数据，我们需要了解在处理像素时安全性是如何工作的。为了保护不属于您的内容，与您的主机不同的数据的处理涉及安全问题。我们不会在本节中涵盖这些安全问题，并且将始终使用与我们的代码（或全部本地）在同一域中的图像。
- en: Your first step is to find an image that you wish to work with (I've added an
    old image of my own into the source files). In this sample, we will recreate a
    pixel fade-out animation—really cool and useful for slides.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一步是找到您希望使用的图像（我已经将自己的旧图像添加到了源文件中）。在本示例中，我们将重新创建一个像素淡出动画-非常酷，对幻灯片非常有用。
- en: '![Getting ready](img/3707OT_02_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/3707OT_02_09.jpg)'
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s get our code working and then break it down to see how it works. Perform
    the following steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让我们的代码运行起来，然后分解它看看它是如何工作的。执行以下步骤：
- en: 'Create a few helper global variables:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些辅助全局变量：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create an `init` function (for the rest of the steps, all code will be in this
    function):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`init`函数（在接下来的步骤中，所有代码都将在这个函数中）：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a context variable for the 2D Canvas API:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为2D画布API创建一个上下文变量：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a new image:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新图像：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add the `onload` listener logic:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`onload`监听器逻辑：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define the image source:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义图像源：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a new function called `fadeOutImage`. This image will transition our
    image in:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fadeOutImage`的新函数。这个图像将过渡我们的图像：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Your outcome should look something like the following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果应该看起来像以下截图：
- en: '![How to do it...](img/3707OT_02_10.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3707OT_02_10.jpg)'
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will skip explaining things that we have already covered in earlier samples
    such as how to load images and how to work with the `drawImage` method (covered
    in the *Integrating images into our art* recipe discussed earlier in this chapter).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过解释我们在早期示例中已经涵盖的内容，比如如何加载图像以及如何使用`drawImage`方法（在本章前面讨论的*将图像整合到我们的艺术品中*配方中涵盖）。
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We will see the usage of these variables in our code, but all these variables
    have been saved as global variables so there is no need to redefine them in our
    functions. By defining these variables once, we improve the efficiency of our
    application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中看到这些变量的用法，但所有这些变量都已保存为全局变量，因此无需在函数中重新定义它们。通过一次性定义这些变量，我们提高了应用程序的效率。
- en: 'The real new logic starts within the `onLoad` listener. Right after we draw
    our image onto the canvas, our new logic is added. It is highlighted in the following
    code snippet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的新逻辑始于`onLoad`监听器。在我们将图像绘制到画布上后，我们添加了新的逻辑。在下面的代码片段中进行了突出显示：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We are now taking advantage of storing information in our canvas area and storing
    it globally. The first variable we are storing is `imageData`. This variable contains
    all the information of our canvas. We get this variable by calling the `context.getImageData`
    method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始利用在画布区域和全局存储信息的优势。我们存储的第一个变量是`imageData`。这个变量包含了我们画布的所有信息。我们通过调用`context.getImageData`方法来获取这个变量。
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `getImageData` function returns every single pixel for a rectangular area.
    We need to set it by defining the area we want. In our case, we want the full
    canvas area as our image is set in the full canvas area.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`getImageData`函数返回矩形区域的每个像素。我们需要通过定义我们想要的区域来设置它。在我们的情况下，我们希望整个画布区域作为我们的图像设置。'
- en: The returned object (`imageData`) stores the direct access to the pixel data
    information in its data property (`imageData.data`) and this is our main focus
    while working directly with pixels. This object contains all the color information
    for each pixel in our canvas. The information is stored in four cells (red, green,
    blue, and alpha). In other words, if there are 100 pixels in total in our application,
    we would expect our array to contain 400 cells in the `imageData.data` array.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象（`imageData`）将像素数据信息直接存储在其数据属性（`imageData.data`）中，这是我们直接处理像素时的主要关注点。该对象包含画布中每个像素的所有颜色信息。信息存储在四个单元格（红色、绿色、蓝色和alpha通道）中。换句话说，如果我们的应用程序中总共有100个像素，我们期望我们的数组在`imageData.data`数组中包含400个单元格。
- en: 'The last thing left to do before finishing the logic in our `onLoad` listener
    is to trigger our animation that will transition our image; to do that we will
    add an interval as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`onLoad`监听器中完成逻辑之前，还剩下最后一件事要做，那就是触发我们的动画，使我们的图像过渡；为此，我们将添加一个间隔，如下所示：
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Our animation is triggered after every 25 milliseconds until it's completed.
    The logic that fades our view happens within our `fadeOutImage` function.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动画在每25毫秒触发一次，直到完成。淡出视图的逻辑发生在我们的`fadeOutImage`函数中。
- en: 'Now that we have got all the prep work done, it''s time to delve into the `fadeoutImage`
    function. Here, we will be doing the actual pixel manipulation logic. The first
    step in this function is to create a variable that will count how many changes
    our `imageData.data` array has made. When we hit the required number of changes,
    we terminate our interval (or in a real application maybe animate the next image):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了所有的准备工作，是时候深入了解`fadeoutImage`函数了。在这里，我们将进行实际的像素处理逻辑。该函数的第一步是创建一个变量，用于计算我们的`imageData.data`数组所做的更改次数。当达到所需的更改次数时，我们终止我们的间隔（或在实际应用中可能是动画下一个图像）：
- en: '[PRE69]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We now start to run through all the pixels by using a `for` loop:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始通过使用`for`循环遍历所有像素：
- en: '[PRE70]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Each pixel stores RGBA values, thus, every pixel gets four positions in our
    array and as such we are jumping four steps at a time to move between pixels.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每个像素存储RGBA值，因此每个像素在我们的数组中占据四个位置，因此我们每次跳过四个步骤以在像素之间移动。
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When we are done with manipulating our data, it's time for us to update our
    canvas. To do that we just need to send our new data back into our context. The
    second and third parameters are for the x and y starting point.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成了对数据的操作，就该更新画布了。为此，我们只需要将新数据发送回我们的上下文。第二个和第三个参数是x和y的起始点。
- en: '[PRE72]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When we have no more changes (you can adjust that to fit your wishes such as
    when there are less than 100 pixels changed), we terminate the interval and trigger
    an alert.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有更多的更改时（您可以调整以符合您的愿望，例如当更改的像素少于100个时），我们终止间隔并触发警报。
- en: 'In our `for` loop, we will lower the values of red, green, and blue until they
    get to 0\. In our case, as we are counting changes we also add the counter into
    the loop:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for`循环中，我们将降低红色、绿色和蓝色的值，直到它们降至0。在我们的情况下，由于我们正在计算更改，因此我们还将计数器添加到循环中：
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Earlier we mentioned that each pixel gets four cells of information in the array.
    The first three cells store the RGB values, while the fourth stores the alpha
    channel. As such I thought it would be important to notice that we are skipping
    position `i+3` as we don't want the alpha channel to get affected. Every element
    in the `pixelData` array is a value between `0` and `255`. In other words, if
    that pixel's value was `#ffffff` (white), all three RGB cells would be equal to
    `255`. By the way, it would take 255 calls to our function to get the values down
    to `0` as the value in the cells would start from `255` and go down by 1 each
    time.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到每个像素在数组中有四个单元格的信息。前三个单元格存储RGB值，而第四个存储alpha通道。因此，我认为值得注意的是，我们跳过位置`i+3`，因为我们不希望影响alpha通道。`pixelData`数组中的每个元素的值都在`0`和`255`之间。换句话说，如果该像素的值为`#ffffff`（白色），所有三个RGB单元格的值将等于`255`。顺便说一句，要使这些单元格中的值降至`0`，需要调用我们的函数255次，因为单元格中的值将从`255`开始，每次减1。
- en: We always skip the position `i+3`, as we don't want to change anything in our
    array. Our values are between `255` and `0`; in other words, if our image has
    a value `#ffffff` (totally white pixel), it would go down `255` times for our
    function to get `0`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是跳过位置`i+3`，因为我们不希望在我们的数组中改变任何内容。我们的值在`255`和`0`之间；换句话说，如果我们的图像的值为`#ffffff`（完全白色像素），我们的函数将下降`255`次才能达到`0`。
- en: Making an image grayscale
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使图像变为灰度
- en: 'To make an image or our canvas grayscale, we need to take all of our colors
    (red, green, blue) into account and mix them together. After mixing them together,
    get to a brightness value, which we can then apply to all the pixels. Let''s see
    it in action:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要使图像或画布变为灰度，我们需要考虑所有的颜色（红色、绿色、蓝色）并将它们混合在一起。混合在一起后，得到一个亮度值，然后我们可以将其应用到所有的像素上。让我们看看它的实际效果：
- en: '[PRE74]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this case, we are taking the red (`pixelData[i]`), green (`pixelData[i+1]`),
    and blue (`pixelData[i+2]`), and using a one third of each to combine together
    to get one color and then we are assigning them all with this new averaged value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们取红色（`pixelData[i]`），绿色（`pixelData[i+1]`）和蓝色（`pixelData[i+2]`），并使用每种颜色的三分之一来组合在一起得到一种颜色，然后我们将它们全部赋予这个新的平均值。
- en: Try only changing two out of the three values and see what comes out.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试只改变三个值中的两个，看看会得到什么结果。
- en: Pixel reversing
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 像素反转
- en: 'Color reversing an image is very easy as all we need to do is flip its value
    pixel by pixel by taking the maximum possible value (`255`) and subtracting the
    current value from it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色反转图像非常容易，因为我们只需要逐个像素地取最大可能值（`255`）并从中减去当前值：
- en: '[PRE75]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There you go! We visited a few options of pixel manipulation, but the limit
    is really just up to your imagination. Experiment, you never know what might come
    out of it!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们讨论了一些像素操作的选项，但限制实际上取决于你的想象力。实验一下，你永远不知道会得到什么结果！
