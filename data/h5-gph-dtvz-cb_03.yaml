- en: Chapter 3. Creating Cartesian-based Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。创建基于笛卡尔的图表
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building a bar chart from scratch
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始构建条形图
- en: Spreading data in a scatter chart
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在散点图中传播数据
- en: Building line charts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建线图
- en: Creating the flying brick chart (waterfall chart)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建飞行砖图（瀑布图）
- en: Building a candlestick chart (stock chart)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建蜡烛图（股票图）
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Our first graph/chart under the microscope is the most popular and simplest
    one to create. We can classify them all roughly under Cartesian-based graphs.
    Altogether this graph style is relatively simple; it opens the door to creating
    amazingly creative ways of exploring data. In this chapter we will lay down the
    foundations to building charts in general and hopefully motivate you to come up
    with your own ideas on how to create engaging data visualizations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放大的第一个图表/图表是最受欢迎和最简单的创建。我们可以粗略地将它们分类为基于笛卡尔的图表。总的来说，这种图表风格相对简单；它为探索数据的惊人创造方式打开了大门。在本章中，我们将奠定构建图表的基础，希望能激励您提出自己的创意，以创建引人入胜的数据可视化。
- en: Building a bar chart from scratch
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始构建条形图
- en: 'The simplest chart around is the one that holds only one dimensional data (only
    one value per type). There are many ways to showcase this type of data but the
    most popular, logical, and simple way is by creating a simple bar chart. The steps
    involved in creating this bar chart will be very similar even in very complex
    charts. The ideal usage of this type of chart is when the main goal is to showcase
    simple data, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的图表是只包含一维数据的图表（每种类型只有一个值）。有许多方法可以展示这种类型的数据，但最受欢迎、逻辑和简单的方法是创建一个简单的条形图。即使在非常复杂的图表中，创建这个条形图所涉及的步骤也会非常相似。这种类型的图表的理想用法是当主要目标是展示简单数据时，如下所示：
- en: '![Building a bar chart from scratch](img/3707OT_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: ！[从头开始构建条形图]（img/3707OT_03_01.jpg）
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'Create a basic HTML file that contains a canvas and an `onLoad` event that
    will trigger the `init` function. Load the `03.01.bar.js` script. We will create
    the content of the JavaScript file in our recipe as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含画布和`onLoad`事件的基本HTML文件，该事件将触发`init`函数。加载`03.01.bar.js`脚本。我们将按照以下的食谱创建JavaScript文件的内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Creating a graph in general has three steps: defining the work area, defining
    the data sources, and then drawing in the data.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，创建图表有三个步骤：定义工作区域，定义数据源，然后在数据中绘制。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In our first case, we will compare a group of friends and how many cats they
    each own. We will be performing the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个案例中，我们将比较一组朋友和他们各自拥有的猫的数量。我们将执行以下步骤：
- en: 'Define your data set:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的数据集：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For this example I''ve created an array that can contain an unlimited number
    of elements. Each element contains three values: a label, a value, and a style
    for its fill color.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我创建了一个可以包含无限数量元素的数组。每个元素包含三个值：标签、值和其填充颜色的样式。
- en: Define your graph outlines.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的图表轮廓。
- en: 'Now that we have a data source, it''s time to create our basic canvas information,
    which we create in each sample:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据源，是时候创建我们的基本画布信息了，我们在每个样本中都会创建：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to define our chart outlines:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义我们的图表轮廓：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our next and final step is to create the actual data bars:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的下一个和最后一步是创建实际的数据条：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's it. Now, if you run the application in your browser, you will find a
    bar chart rendered.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，如果你在浏览器中运行应用程序，你会发现一个条形图被渲染出来。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: I've created a variable called `CHART_PADDING` that is used throughout the code
    to help me position elements (the variable is in uppercase because I want it to
    be a constant; so it's to remind myself that this is not a value that will change
    in the lifetime of the application).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为`CHART_PADDING`的变量，它在整个代码中都被用来帮助我定位元素（变量是大写的，因为我希望它是一个常量；所以这是为了提醒自己这不是应用程序生命周期中会改变的值）。
- en: 'Let''s delve deeper into the sample we created starting from our outline area:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的轮廓区域开始深入研究我们创建的样本：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In these lines we are creating the L-shaped frame for our data; this is just
    to help and provide a visual aid.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们正在创建我们数据的L形框架；这只是为了帮助和提供视觉辅助。
- en: The next step is to define the number of steps that we will use to represent
    the numeric data visually.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义我们将用来在视觉上表示数值数据的步数。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our sample we are hardcoding all of the data. So in the step size we are
    finding the total height of our chart (the height of our canvas minus our padding
    at the top and bottom), which we then divide by the number of the steps that will
    be used in the following `for` loop:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的样本中，我们正在硬编码所有数据。因此，在步长中，我们正在找到我们图表的总高度（画布的高度减去顶部和底部的填充），然后我们将其除以将在以下`for`循环中使用的步数：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We loop through 10 times going through each step to draw a short line. We then
    add numeric information using the `fillText` method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环10次，每次画一条短线。然后使用`fillText`方法添加数字信息。
- en: Notice that we are sending in the value `10-i`. This value works well for us
    as we want the top value to be 10\. We are starting at the top value of the chart;
    we want the displayed value to be 10 and as the value of `i` increases, we want
    our value to get smaller as we move down the vertical line in each step of the
    loop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们发送值`10-i`。这个值对我们很有效，因为我们希望顶部值为10。我们从图表的顶部开始；我们希望显示的值为10，随着`i`的值增加，我们希望我们的值在循环的每一步中向下移动时变小。
- en: Next we want to define the width of each bar. In our case, we want the bars
    to touch each other and to do that we will take the total space available, and
    divide it by the number of data elements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要定义每个条的宽度。在我们的情况下，我们希望条形相互接触，为了做到这一点，我们将利用可用的总空间，除以数据元素的数量。
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this stage we are ready to draw the bar but before we do that, we should
    calculate the width of the bars.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经准备好画条了，但在这之前，我们应该计算条的宽度。
- en: 'We then loop through all the data we have and create the bars:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们循环遍历所有数据并创建条形图：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we are resetting the style twice each time the loop runs. If we
    didn't, we wouldn't get the colors we are hoping to get. We then place our text
    in the middle of the bar that was created.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每次循环运行时，我们都会两次重置样式。如果我们不这样做，我们将无法获得我们希望获得的颜色。然后我们将文本放在创建的条形图的中间。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In our example, we created a non-flexible bar chart, and if this is the way
    we create charts we will need to recreate them from scratch each time. Let's revisit
    our code and tweak it to make it more reusable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个不灵活的条形图，如果这是我们创建图表的方式，我们将需要每次从头开始重新创建它们。让我们重新审视我们的代码，并对其进行调整，使其更具重用性。
- en: Revisiting the code
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新审视代码
- en: 'Although everything is working exactly as we want it to work, if we played
    around with the values, it would stop working. For example, what if I only wanted
    to have five steps; if we go back to our code, we will locate the following lines:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一切都按我们希望的方式工作，但如果我们玩弄数值，它就会停止工作。例如，如果我只想有五个步骤；如果我们回到我们的代码，我们会找到以下行：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can tweak it to handle five steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对其进行调整，以处理五个步骤：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We would very quickly find out that our application is not working as expected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会发现我们的应用程序并没有按预期工作。
- en: 'To solve this problem let''s create a new function that will deal with creating
    the outlines of the chart. Before we do that, let''s extract the data object and
    create a new object that will contain the steps. Let''s move the data and format
    it in an accessible format:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们创建一个新函数，用于创建图表的轮廓。在这样做之前，让我们提取数据对象并创建一个将包含步骤的新对象。让我们将数据移动并以可访问的格式进行格式化：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Take a deep look into `chartYData` object as it enables us to put in as many
    steps as we want without a defined spacing rule and the range object that will
    store the minimum and maximum values of the overall graph. Before creating the
    new functions, let's add them into our `init` function (changes marked in bold).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究`chartYData`对象，因为它使我们能够在没有定义间距规则的情况下放入尽可能多的步骤，并且范围对象将存储整个图形的最小值和最大值。在创建新函数之前，让我们将它们添加到我们的`init`函数中（以粗体标记的更改）。
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All we did in this code is to extract the creation of the chart and its bars
    into two separate functions. Now that we have an external data source both for
    the chart data and the content, we can build up their logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们所做的就是将图表的创建和其条形分开为两个单独的函数。现在我们有了一个外部数据源，用于图表数据和内容，我们可以构建它们的逻辑。
- en: Using the fillChart function
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用fillChart函数
- en: The `fillChart` function's main goal is to create the foundation of the chart.
    We are integrating our new `stepData` object information and building up the chart
    based on its information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillChart`函数的主要目标是创建图表的基础。我们正在整合我们的新`stepData`对象信息，并根据其信息构建图表。'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our changes were not many, but with them we turned our function to be much more
    dynamic than it was before. This time around we are basing the positions on the
    `stepsData` objects and the range length that is based on that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的更改并不多，但通过它们，我们使我们的函数比以前更加动态。这一次，我们基于`stepsData`对象和基于它的范围长度来确定位置。
- en: Using the createBars function
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用createBars函数
- en: Our next step is to revisit the `createBars` area and update the information
    so it can be created dynamically using external objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是重新访问`createBars`区域并更新信息，以便可以使用外部对象动态创建它。
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Almost nothing changed here apart from a few changes in the way we positioned
    the data and extracted hardcoded values. Compare the two samples in our source
    code and find the differences between them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里几乎没有什么改变，除了在定位数据和提取硬编码值的方式上有一些改变。比较我们源代码中的两个示例，并找出它们之间的区别。
- en: Spreading data in a scatter chart
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在散点图中传播数据
- en: The scatter chart is a very powerful chart and is mainly used to get a bird's-eye
    view while comparing two data sets. For example, comparing the scores in an English
    class and the scores in a Math class to find a correlative relationship. This
    style of visual comparison can help find surprising relationships between unexpected
    data sets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是一种非常强大的图表，主要用于在比较两组数据时获得鸟瞰图。例如，比较英语课上的分数和数学课上的分数，以找到相关关系。这种视觉比较方式可以帮助发现意想不到的数据集之间的关系。
- en: This is ideal when the goal is to show a lot of details in a very visual way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这在目标是以非常直观的方式显示大量细节时是理想的。
- en: '![Spreading data in a scatter chart](img/3707OT_03_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![在散点图中传播数据](img/3707OT_03_02.jpg)'
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't had a chance yet to scan through the logic of our first recipe
    in this chapter, I recommend you take a peek at it as we are going to base a lot
    of our work on that while expanding and making it a bit more complex to accommodate
    two data sets.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有机会浏览本章第一个食谱的逻辑，我建议您偷偷看一眼，因为我们将在此基础上进行大量工作，同时扩展并使其稍微复杂化，以容纳两组数据。
- en: The regular HTML start-up code can be found in the code bundle or go through
    [Chapter 1](ch01.html "Chapter 1. Drawing Shapes in Canvas"), *Drawing Shapes
    in Canvas*, for more information on creating the HTML document.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的HTML启动代码可以在代码包中找到，或者查看[第1章](ch01.html "第1章。在画布中绘制形状")，*在画布中绘制形状*，以获取有关创建HTML文档的更多信息。
- en: I've revisited our data source from the previous recipe and modified it to store
    three variables of students' exam scores in Math, English, and Art.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我重新访问了上一个食谱的数据源，并修改为存储学生数学、英语和艺术考试成绩的三个变量。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that this data is totally random so we can't learn anything from the
    data itself; but we can learn a lot about how to get our chart ready for real
    data. We removed the `value` attribute and instead replaced it with `math`, `english`,
    and `art` attributes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些数据是完全随机的，因此我们无法从数据本身中学到任何东西；但我们可以学到很多关于如何准备好我们的图表以用于真实数据。我们删除了`value`属性，而是用`math`、`english`和`art`属性替换它。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s dive right into the JavaScript file and the changes we want to make:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入JavaScript文件和我们想要进行的更改：
- en: 'Define the `y` space and `x` space. To do that, we will create a helper object
    that will store the required information:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`y`空间和`x`空间。为此，我们将创建一个存储所需信息的辅助对象：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It''s time for us to set up our other global variables and start up our `init`
    function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候设置我们的其他全局变量并启动我们的`init`函数了：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Not much is new here. The major changes are highlighted. Let's get on and start
    creating our `fillChart` and `createDots` functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多新东西。主要的变化已经被突出显示。让我们继续创建我们的`fillChart`和`createDots`函数。
- en: 'If you worked on our previous recipe, you might notice that there are a lot
    of similarities between the functions in the previous recipe and this function.
    I''ve deliberately changed the way we create things just to make them more interesting.
    We are now dealing with two data points as well, so many details have changed.
    Let''s review them:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前做过我们的上一个示例，你可能会注意到前一个示例中的函数和这个函数之间有很多相似之处。我故意改变了创建事物的方式，只是为了让它们更有趣。现在我们也处理两个数据点，所以很多细节已经改变。让我们来回顾一下：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you review this code you will notice that our logic is almost duplicated
    twice. While in the first loop and first batch of variables we are figuring out
    the positions of each element in the `y` space, we move on in the second half
    of this function to calculate the layout for the `x` area. The y axis in canvas
    grows from top to bottom (top lower, bottom higher) and as such we need to calculate
    the height of the full graph and then subtract the value to find positions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你审查这段代码时，你会注意到我们的逻辑几乎是重复两次。在第一个循环和第一批变量中，我们正在计算`y`空间中每个元素的位置，然后在这个函数的后半部分，我们继续计算`x`区域的布局。画布中的y轴从上到下增长（顶部较低，底部较高），因此我们需要计算整个图形的高度，然后减去该值以找到位置。
- en: 'Our last function is to render the data points and to do that we create the
    `createDots` function:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一个函数是渲染数据点，为此我们创建`createDots`函数：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we are figuring out the same details for each point—both the `y` position
    and the `x` position—and then we draw a rectangle. Let's test our application
    now!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在为每个点找出相同的细节——`y`位置和`x`位置——然后绘制一个矩形。现在让我们测试我们的应用程序！
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by creating a new `chartInfo` object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的`chartInfo`对象：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This very simple object encapsulates the rules that will define what our chart
    will actually output. Looking closely you will see that we set an object named
    `chartInfo` that has information on the y and x axes. We have a minimum value
    (`min` property), maximum value (`max` property), and the number of steps we want
    to have in our chart (`steps` property), and we define a label.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的对象封装了定义我们的图表实际输出的规则。仔细看，你会发现我们设置了一个名为`chartInfo`的对象，其中包含有关y轴和x轴的信息。我们有一个最小值（`min`属性），最大值（`max`属性），我们想在我们的图表中拥有的步数（`steps`属性），并且我们定义了一个标签。
- en: 'Let''s look deeper into the way the `fillChart` function works. In essence
    we have two numeric values; one is the actual space on the screen and the other
    is the value the space represents. To match these values we need to know what
    our data range is and also what our view range is, so we first start by finding
    our `startY` point and our `endY` point followed by calculating the number of
    pixels between these two points:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`fillChart`函数的工作方式。实质上，我们有两个数值；一个是屏幕上的实际空间，另一个是空间所代表的值。为了匹配这些值，我们需要知道我们的数据范围以及我们的视图范围，因此我们首先通过找到我们的`startY`点和`endY`点，然后计算这两个点之间的像素数量：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These values will be used when we try to figure out where to place the data
    from the `chartInfo` object. As we are already speaking about that object, let''s
    look at what we do with it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试弄清楚从`chartInfo`对象中放置数据时，这些值将被使用。因为我们已经在谈论那个对象，让我们看看我们对它做了什么：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As our focus right now is on the height, we are looking deeper into the `y`
    property and for the sake of comfort we will call it `yData`. Now that we are
    focused on this object, it's time to figure out what is the actual data range
    (`rangeLength`) of this value, which will be our converter number. In other words
    we want to take a visual space between the points `startY` and `endY` and based
    on the the range, position it in this space. When we do so we can convert any
    data into a range between 0-1 and then position them in a dynamic visible area.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在的重点是高度，我们正在深入研究`y`属性，为了方便起见，我们将其称为`yData`。现在我们专注于这个对象，是时候弄清楚这个值的实际数据范围（`rangeLength`）了，这将是我们的转换器数字。换句话说，我们想要在点`startY`和`endY`之间的视觉空间中，根据范围将其定位。当我们这样做时，我们可以将任何数据转换为0-1之间的范围，然后将它们定位在动态可见的区域中。
- en: 'Last but not least, as our new data object contains the number of steps we
    want to add into the chart, we use that data to define the step value. In this
    example it would be 12\. The way we get to this value is by taking our `rangeLength`
    (100 - 40 = 60) value and then dividing it by the number of `steps` (in our case
    5). Now that we have got the critical variables out of the way, it''s time to
    loop through the data and draw our chart:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的，由于我们的新数据对象包含我们想要添加到图表中的步数，我们使用该数据来定义步长值。在这个示例中，它将是12。我们得到这个值的方式是通过取我们的`rangeLength`（100-40=60）值，然后除以`steps`的数量（在我们的例子中是5）。现在我们已经解决了关键的变量，是时候遍历数据并绘制我们的图表了：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is where the magic comes to life. We run through the number of steps and
    then calculate the new `Y` position again. If we break it down we will see:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方。我们遍历步数，然后再次计算新的`Y`位置。如果我们将其分解，我们会看到：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We start from the start position of our chart (upper area) and then we add to
    it the steps by taking the current `i` position and dividing it by the total possible
    steps (0/5, 1/5, 2/5 and so on). In our demo it's 5, but it can be any value and
    should be inserted into the `chartInfo` steps attribute. We multiply the returned
    value by the height of our chart calculated earlier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从图表的起始位置（上部区域）开始，然后通过取当前`i`位置并将其除以总可能步数（0/5、1/5、2/5等）来添加步骤。在我们的演示中，它是5，但它可以是任何值，并且应该插入到`chartInfo`的步骤属性中。我们将返回的值乘以我们之前计算的图表的高度。
- en: 'To compensate for the fact that we started from the top we need to reverse
    the actual text we put into the text field:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弥补我们从顶部开始的事实，我们需要颠倒我们放入文本字段的实际文本：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code takes our earlier variables and puts them to work. We start by taking
    the minimal value possible and then add into it `stepSize` times the total number
    of steps subtracted by the number of the current step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了我们之前的变量并让它们发挥作用。我们首先取可能的最小值，然后加上`stepSize`乘以总步数减去当前步数的数量。
- en: 'Let''s dig into the `createDots` function and see how it works. We start with
    our setup variables:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`createDots`函数以及它是如何工作的。我们从设置变量开始：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is one of my favorite parts of this recipe. We are grabbing the label from
    our `chartInfo` object and using that as our ID; this ID will be used to grab
    information from our data object. If you wish to change the values, all you need
    to do is switch the labels in the `chartInfo` object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我最喜欢的配方之一。我们从`chartInfo`对象中获取标签并将其用作我们的ID；这个ID将用于从我们的数据对象中获取信息。如果您希望更改值，您只需要在`chartInfo`对象中切换标签。
- en: 'Again it''s time for us to figure out our ranges as we''ve done earlier in
    the `fillChart` function. This time around we want to get the actual ranges for
    both the x and y axes and the actual width and height of the area we have to work
    with:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要弄清楚我们的范围，就像我们在`fillChart`函数中所做的那样。这一次，我们想要获取x轴和y轴的实际范围以及我们需要处理的区域的实际宽度和高度：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also need to get a few variables to help us keep track of our current `x`
    and `y` positions within loops:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要获取一些变量来帮助我们在循环中跟踪我们当前的`x`和`y`位置：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s go deeper into our loop, mainly into the highlighted code snippets:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到我们的循环中，主要是突出显示的代码片段：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The heart of everything here is discovering where our elements need to be.
    The logic is almost identical for both the `xPos` and `yPos` variables with a
    few variations. The first thing we need to do to calculate the `xPos` variable
    is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一切的核心是发现我们的元素需要在哪里。逻辑对于`xPos`和`yPos`变量几乎是相同的，只有一些变化。我们需要做的第一件事是计算`xPos`变量：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this part we are using the label, `xDataLabel`, we created earlier to get
    the current student score in that subject. We then subtract from it the lowest
    possible score. As our chart doesn''t start from 0, we don''t want the values
    between 0 and our minimum value to affect the position on the screen. For example,
    let''s say we are focused on math and our student has a score of 80; we subtract
    40 out of that (80 - 40 = 40) and then apply the following formula:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们使用了我们之前创建的标签`xDataLabel`来获取该科目中当前学生的分数。然后我们从中减去最低可能的分数。由于我们的图表不是从0开始的，我们不希望0和我们的最小值之间的值影响屏幕上的位置。例如，假设我们专注于数学，我们的学生得了80分；我们从中减去40（80-40=40），然后应用以下公式：
- en: '`(data[i][xDataLabel] - chartInfo.x.min) / xDataRange`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`(data[i][xDataLabel] - chartInfo.x.min) / xDataRange`'
- en: 'We divide that value by our data range; in our case that would be (100 - 40)/60\.
    The returned result will always be between 0 and 1\. We can use the returned number
    and multiply it by the actual space in pixels to know exactly where to position
    our element on the screen. We do so by multiplying the value we got, that is between
    0 and 1, by the total available space (in this case, width). Once we know where
    it needs to be located we add the starting point on our chart (the padding):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将该值除以我们的数据范围；在我们的情况下，那将是（100-40）/60。返回的结果将始终在0和1之间。我们可以使用返回的数字并将其乘以像素的实际空间，以确切地知道在屏幕上定位我们的元素。我们通过将我们得到的值（在0和1之间）乘以总可用空间（在这种情况下是宽度）来这样做。一旦我们知道它需要定位的位置，我们就在图表上添加起始点（填充）：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `yPos` variable has the same logic as that of the `xPos` variable, but here
    we focus only on the height.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`yPos`变量的逻辑与`xPos`变量的逻辑相同，但这里我们只关注高度。'
- en: Building line charts
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建折线图
- en: The line charts are based on scatter charts. Contrary to scatter charts that
    show isolated correlation between two variables, the line chart tells a story
    in many ways; we can go back to our previous recipe, *Spreading data in a scatter
    chart*, and draw a line between the dots to create the connection. This type of
    chart is usually used in website statistics, tracking things over time, speed,
    age, and so on. Let's jump right into it and see it in action.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 折线图是基于散点图的。与显示两个变量之间孤立相关性的散点图相反，折线图以多种方式讲述了一个故事；我们可以回到我们之前的散点图的配方，*在散点图中传播数据*，并在点之间画一条线来创建连接。这种类型的图表通常用于网站统计，随时间跟踪事物，速度，年龄等。让我们立即跳进去看看它的运作。
- en: '![Building line charts](img/3707OT_03_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![构建折线图](img/3707OT_03_03.jpg)'
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: As usual get your HTML wrapper ready. In this recipe we actually are going to
    base our changes on the previous recipe, *Spreading data in a scatter chart*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，准备好您的HTML包装器。在这个配方中，我们实际上将根据之前的配方*在散点图中传播数据*来进行更改。
- en: 'In our case study for this example, we will create a chart that shows how many
    new members joined my site, [02Geek.com](http://02Geek.com), in 2011 and 2010\.
    I''ve gathered the information month by month and gathered it into two arrays:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我们将创建一个图表，显示2011年和2010年有多少新成员加入了我的网站[02Geek.com](http://02Geek.com)。我逐月收集了信息并将其汇总到两个数组中：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both arrays have a length of 12 (for 12 months of the year). I've deliberately
    created a new data source that is totally different than the one we used earlier.
    I did that to render our old map useless in this example. I've done it to add
    some extra value into this recipe (a good lesson in manipulating data to fit even
    when it doesn't, instead of rebuilding things).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数组的长度都是12（代表一年的12个月）。我故意创建了一个与我们之前使用的完全不同的新数据源。我这样做是为了使我们以前的地图在这个例子中变得无用。我这样做是为了为这个配方增加一些额外的价值（一个很好的课程，教你如何操纵数据以适应，即使它不适合，而不是重建事物）。
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For our chart information we are using the same object type and for the `y`
    position we will assume a range from 0 to 300 (as I haven't had the privilege
    of having more than 300 members in one month, yet I'm hopeful). For our `x` position
    we are setting it to output values from 1 through 12 (for the 12 months of the
    year).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的图表信息，我们正在使用相同的对象类型，并且对于`y`位置，我们将假定范围从0到300（因为我还没有在一个月内拥有超过300名成员的特权，但我对此抱有希望）。对于我们的`x`位置，我们将其设置为输出值从1到12（代表一年的12个月）。
- en: OK, it's time to build it!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是时候来构建它了！
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As always, our `init` function is going to look very similar to the one we
    used in the previous recipe. Let''s take a look at the modifications that have
    taken place in this recipe:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们的`init`函数将看起来与我们在上一个示例中使用的函数非常相似。让我们看看在这个示例中发生了哪些修改：
- en: 'Update/create the global variables:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新/创建全局变量：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Update the `init` function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`init`函数：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change the name of the function `createDots` to `addLine` and update the logic:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改函数`createDots`的名称为`addLine`并更新逻辑：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the `formatData` function:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`formatData`函数：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That's it! We are done!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们完成了！
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: I've added a new method, `rect`, to our tool set for drawing; until now we worked
    with the `drawRect` method. I've used the `rect` method as it just adds the outlines
    without drawing anything, so I can perform the stroke or fill function separately
    and create an outline instead of a fill.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为我们的绘图工具集添加了一个新方法`rect`；到目前为止，我们一直使用`drawRect`方法。我使用`rect`方法是因为它只是添加轮廓而不绘制任何东西，所以我可以分别执行描边或填充功能，并创建轮廓而不是填充。
- en: The `fillChart` function did not change at all, cool right? And I've renamed
    the function `createDots` to `addLine` as it seemed more appropriate for our sample.
    A few additions have been made into that function and a new function, `formatData`,
    is being used to format the data to fit what the `addLine` function is expecting.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillChart`函数一点都没有改变，很酷，对吧？我将函数`createDots`重命名为`addLine`，因为对于我们的示例来说，这似乎更合适。该函数已经进行了一些添加，并且正在使用一个新函数`formatData`来格式化数据以适应`addLine`函数所期望的格式。'
- en: 'As you probably noticed we made a few small changes to our code to accommodate
    the needs of this chart style. Let''s dive in and see them in action:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们对我们的代码进行了一些小的更改，以适应这种图表样式的需求。让我们深入研究并看到它们在实际操作中的表现：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The biggest change we can visibly see in the way we are calling the `addLine`
    function is that we are calling the `formatData` function to render a data source
    for us that will be acceptable by the `addLine` function. You might be thinking
    right now, why didn't I just create the data the way it needs to work for the
    `addLine` function. When we move to the real, live data sources many times we
    will find data sources that just don't match our original work. That doesn't mean
    we need to change our work, often a better solution is to create a converter method
    that will modify the data and rebuild it to match our application structure so
    it is in the format we expect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调用`addLine`函数的方式中可以明显看到的最大变化是，我们正在调用`formatData`函数为我们呈现一个数据源，该数据源将被`addLine`函数接受。您可能现在正在想，为什么我不只是创建需要为`addLine`函数工作的数据的方式。当我们转移到真实的实时数据源时，我们经常会发现数据源与我们的原始工作不匹配。这并不意味着我们需要改变我们的工作，通常更好的解决方案是创建一个转换器方法，该方法将修改数据并重建它以匹配我们的应用程序结构，使其符合我们的期望格式。
- en: 'A reminder from our previous recipe: this is what our data source looked like:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们以前的示例中提醒一下：这是我们的数据源的样子：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'While currently our array is flat, we need to change that to work with our
    current system; it expects two properties that will define the `x` and `y` values:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的数组目前是平的，但我们需要改变它以适应我们当前的系统；它期望两个属性来定义`x`和`y`值：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In other words the object we need to create needs to look something like the
    following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要创建的对象需要看起来像下面这样：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So let''s make the function that will create this data format:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们创建一个将创建这种数据格式的函数：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice how we loop through our old array and restructure it to fit our expected
    data format using both the array data and external data that was sent to our `formatData`
    functions. Even though we aren't using all of the information in this recipe,
    I wanted to keep it up-to-date with all the basics in case you want to expand
    this sample. We will do so in the future.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何循环遍历我们的旧数组，并重新构造它以适应我们期望的数据格式，使用数组数据和发送到我们的`formatData`函数的外部数据。即使在这个示例中我们没有使用所有的信息，我也想保持它与所有基本信息保持最新，以防您想要扩展这个示例。我们将在未来这样做。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is one of the most powerful tricks in programing in the tool set. I've
    met many developers, who change their code instead of changing their data to fit
    their required application structure. There is always a way to modify data to
    make it more easily consumed by your application and it's much easier to dynamically
    modify data than it is to change your architecture.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编程工具集中最强大的技巧之一。我遇到过许多开发人员，他们改变他们的代码而不是改变他们的数据以适应所需的应用程序结构。总是有一种方法可以修改数据，使其更容易被应用程序消耗，动态修改数据比更改架构要容易得多。
- en: I didn't change anything in the core logic of this `addLine` function, but instead
    just added drawing lines from one dot to the next one.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有改变这个`addLine`函数的核心逻辑，而是只是从一个点到下一个点添加了画线。
- en: 'In case you''re not familiar with the ternary operation, it is a shorthanded
    `if` statement:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉三元操作符，它是一个简写的`if`语句：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By the way, if you are worried about efficiency, you might want to change the
    `for` loop by extracting the first instance out of the loop as that's the only
    occurrence where our ternary operator would trigger the else value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果您担心效率问题，您可能希望通过将第一个实例提取出循环来更改`for`循环，因为这是我们的三元运算符触发else值的唯一发生的地方。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's revisit our code and optimize it to be more adaptable. Our goal is to
    add more flexibility to our chart to render in various modes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们的代码，并优化它以使其更具适应性。我们的目标是为我们的图表添加更多的灵活性，以便以各种模式呈现。
- en: 'My goal here is to enable our chart to render in three render modes: dot mode
    (as in the previous sample), line mode (in this sample), and fill mode (new addition):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标是使我们的图表能够以三种渲染模式呈现：点模式（如前一个示例中），线模式（在本示例中），以及填充模式（新添加）：
- en: '![There''s more...](img/3707OT_03_04.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/3707OT_03_04.jpg)'
- en: Although, in the preceding screenshot, we have three chart elements and they're
    all with a fill, with the new code you can pick, per line added, how you wish
    to treat it. So let's jump right in.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在前面的屏幕截图中，我们有三个图表元素，它们都有填充，但在新代码中，您可以选择每行添加的方式。所以让我们开始吧。
- en: Enabling switching mode between dots and lines
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用在点和线之间切换模式
- en: 'All the work we added into the function doesn''t need to go through a big overhaul
    as nothing is visible until it''s actually rendered. That is controlled in one
    line, where we create the stroke in the `addLine` function. So let''s add a new
    rule that if a style is not sent, it would mean we don''t want to create a line:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到函数中的所有工作都不需要经过大修，因为直到实际呈现之前，什么都看不见。这在一个地方受控，即我们在`addLine`函数中创建描边的地方。因此，让我们添加一个新规则，如果没有发送样式，那就意味着我们不想创建一条线：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In other words, only if we have style information will the line we just created
    be drawn; if not, no line will be drawn.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，只有当我们有样式信息时，我们才会绘制刚刚创建的线；如果没有，就不会绘制线。
- en: Creating fill shapes
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建填充形状
- en: 'To create the fill shapes and for the sake of keeping our code simple, we will
    create an `if...else` statement within our code, and if the user sends a new fourth
    parameter, we will render it in the fill mode (the changes are highlighted in
    the following code snippet):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建填充形状并且为了保持我们的代码简洁，我们将在我们的代码中创建一个`if...else`语句，如果用户发送了一个新的第四个参数，我们将以填充模式呈现它（更改在以下代码片段中突出显示）：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The differences are not large in the new code. We just removed some of the code
    and added a few new lines to create a complete shape. I superimposed the Alpha
    value as well. A smarter way would be to revisit the values sent and put into
    them an Alpha value as needed; but that is left for you to improve. Now our `addLine`
    function can add three types of visualization and we can add multiple types at
    the same time to our chart (check out the source code to see this in action).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码中的差异并不大。我们只是删除了一些代码，并添加了一些新行来创建一个完整的形状。我也叠加了Alpha值。一个更聪明的方法是重新审视发送的值，并根据需要放入Alpha值；但这留给你来改进。现在我们的`addLine`函数可以添加三种类型的可视化，我们可以同时向我们的图表中添加多种类型（查看源代码以查看其运行情况）。
- en: Creating the flying brick chart (waterfall chart)
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建飞行砖块图（瀑布图）
- en: In each recipe in this chapter we've been advancing the complexity of our code
    and so we are going to revisit the bar chart and modernize it to fit our evolving
    charting platform. After we complete this mini task, we will be ready to create
    our first waterfall chart breaking away from the standard charts into more creative
    avenues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的每个配方中，我们都在提高我们代码的复杂性，因此我们将重新审视条形图，并使其适应我们不断发展的图表平台。完成这个小任务后，我们将准备好创建我们的第一个瀑布图，摆脱标准图表，进入更有创意的领域。
- en: '![Creating the flying brick chart (waterfall chart)](img/3707OT_03_05.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![创建飞行砖块图（瀑布图）](img/3707OT_03_05.jpg)'
- en: The waterfall chart is a very useful chart to outline trends, such as monthly
    total changes (positive and negative) while outlining the total value of the big
    picture. This type of chart helps to outline total assets of a company while showing
    if they made profits or losses throughout the month. This type of chart is ideal
    for data that shifts between positive/negative values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布图是一个非常有用的图表，可以概述趋势，比如每月的总变化（正面和负面），同时概述整体价值。这种类型的图表有助于概述公司的总资产，同时显示他们在整个月份内是盈利还是亏损。这种类型的图表非常适合在正负值之间变化的数据。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be taking advantage of the interface we created in the earlier recipes
    and as such we will be integrating the creation of bars into our library of updated
    functions. To do that, we will need to dig out our old `createBars` function created
    in `03.02.bar-revamp.js`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们在早期配方中创建的接口，因此我们将把条形图的创建整合到我们更新的函数库中。为此，我们需要找出我们在`03.02.bar-revamp.js`中创建的旧`createBars`函数。
- en: 'The following is the code before implementing changes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施更改之前的代码如下：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And the following is our newly updated function to fit into the new skills we
    developed in the earlier recipes (changes are highlighted in the following code
    snippet).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们新更新的函数，以适应我们在早期配方中开发的新技能（更改在以下代码片段中突出显示）。
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These changes are more than cosmetic; we are leveraging our external data feeds
    that have been used throughout a few of our previous samples. Now that our function
    is up-to-date and working in our latest logic developed in the previous two recipes,
    it's time to start building our waterfall chart.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改不仅仅是表面的；我们正在利用我们在之前的一些示例中使用的外部数据源。现在我们的函数已经更新并且在前两个配方中开发的最新逻辑中运行，现在是时候开始构建我们的瀑布图了。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first step to create a waterfall chart is to copy, paste, and rename the
    function `createBars` and then manipulate it and change the way the data is rendered
    (mainly where and how we position elements). Notice what we change in this method
    before I dig deeper into why and how it was done:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建瀑布图的第一步是复制、粘贴和重命名函数`createBars`，然后操纵它并改变数据呈现的方式（主要是元素的位置和方式）。在深入讨论之前，注意我们在这个方法中所做的更改：
- en: 'Let''s start with an updated data source:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个更新后的数据源开始：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `init` function we will update the following highlighted code snippets:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`函数中，我们将更新以下突出显示的代码片段：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a few helper variables:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些辅助变量：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the `for` loop logic, draw a rectangle if the value is not `0`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环逻辑中，如果值不是`0`，则绘制一个矩形：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If the current data value is `0` then make it a total column:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前数据值是`0`，那么将其作为总列：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the changed value inside the element:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在元素内添加更改的值：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There are a lot of changes here, but in essence these two functions do almost
    the same thing; only our waterfall chart is smarter and more detailed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多变化，但实质上这两个函数几乎做了相同的事情；只有我们的瀑布图更智能、更详细。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step and the first problem when we start to think about how to create
    a waterfall chart is that there is a relationship between each element. To simplify
    the logic we would want to create a counter that would store the changes (the
    current summary value).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始考虑如何创建瀑布图时，第一步和第一个问题是每个元素之间存在关系。为了简化逻辑，我们希望创建一个计数器来存储变化（当前汇总值）。
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first variable is just a helper variable to try to make our code more readable
    while the total is all about keeping up with what is the current total.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量只是一个辅助变量，试图使我们的代码更易读，而总和则是为了跟踪当前总和是多少。
- en: 'It''s time to jump into the `for` loop and see the big changes. Let''s focus
    first on the types of tasks we might need to do within a waterfall chart. There
    are three types (value goes up, value goes down, and value remains unchanged).
    Before we start figuring out how to deal with these cases, let''s update our variables:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进入`for`循环并看到重大的变化。让我们首先关注我们可能需要在瀑布图中进行的任务类型。有三种类型（值上升、值下降和值保持不变）。在我们开始解决这些情况之前，让我们更新我们的变量：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The element value will give us the current numeric value (don't forget this
    does not correspond to the size on screen; we would still need to duplicate this
    by the `stepSize` number when we want to draw the element as this is the raw real
    number). Same is true for our `total` variable; we are just keeping track of the
    current summary.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 元素值将给我们当前的数值（不要忘记这与屏幕上的大小不对应；当我们想要绘制元素时，我们仍然需要将其乘以`stepSize`数）。`total`变量也是如此；我们只是跟踪当前的汇总。
- en: 'So as we stated earlier, we have three possible tasks and there is nothing
    wrong with creating an `if...else` case as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们之前所述，我们有三个可能的任务，创建一个`if...else`情况没有问题，如下所示：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This would capture all three options but would add some extra code that wouldn't
    be needed. So, we will use the same `if` statement for both negative and positive
    values as their logic is very close to each other. That way we can reuse our code
    and type less.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将捕捉所有三种选项，但会添加一些不必要的额外代码。因此，我们将对负值和正值使用相同的`if`语句，因为它们的逻辑非常接近。这样我们可以重用我们的代码并减少输入。
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Perfecto! Now let''s dig into the positive/negative task:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在让我们深入了解正负任务：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Notice that our first line of code in this block is the only difference between
    positive/negative values. We are literally just changing a color based on whether
    we are in the positive or negative range using a ternary operation. After figuring
    out our `currentY` position we create a rectangle in the current position (this
    current position is after the value was added, so this is our end point). The
    most important element to notice is the fourth parameter, `elementValue*stepSize`
    . The fourth parameter captures the size of the rectangle. With it, it captures
    if it's a negative or positive value. The `elementValue` variable can be positive
    or negative. This is the trick we are using here as we would draw the bar upwards
    (if the value is negative) or draw the bar downwards (if the value is positive).
    If we first created the drawing before updating our `currentY` position, it would
    be much harder and probably require us to create the three separate `if` cases.
    Cases like these are really what makes programming so much fun to me; finding
    these hidden ways to take advantage of the same code to do opposite things.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个代码块中的第一行代码是正负值之间唯一的区别。我们只是基于是否处于正负范围内改变颜色。在确定了`currentY`位置之后，我们在当前位置创建一个矩形（这个当前位置是在值被添加之后，所以这是我们的终点）。最重要的元素是第四个参数，`elementValue*stepSize`。第四个参数捕捉了矩形的大小。它捕捉了它是负值还是正值。`elementValue`变量可以是正数或负数。这就是我们在这里使用的技巧，因为我们会向上绘制条（如果值为负），或向下绘制条（如果值为正）。如果我们首先创建绘图再更新我们的`currentY`位置，那将会更加困难，可能需要我们创建三个单独的`if`情况。像这样的情况确实是我觉得编程如此有趣的原因；找到利用相同代码做相反事情的隐藏方法。
- en: 'It''s time for us to visit the `else` case:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候访问`else`情况了：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the `else` case we want to draw the full length of the bar followed by a
    small hack. We are assigning the value of our current total into the `elementValue`
    variable (this will not change our original data as we are doing this as the last
    thing after we have no more use for the `elementValue` variable). We are doing
    this to avoid another `if...else` statement when adding the text into the bars.
    Only if the value is `0`, we want the total to be displayed instead of the current
    change and that's what this hack captures.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`情况下，我们想要绘制条的全长，然后进行一个小技巧。我们将当前总和的值赋给`elementValue`变量（这不会改变我们的原始数据，因为我们在没有再使用`elementValue`变量之后才这样做）。我们这样做是为了避免在将文本添加到条中时再使用`if...else`语句。只有当值为`0`时，我们希望显示总和而不是当前变化，这就是这个技巧的作用。
- en: 'Leaving us the last part of creating a bar for our waterfall chart, which is
    to get the value of the bar in the center of the element we just created:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 留下我们创建瀑布图的最后一部分，即获取我们刚刚创建的元素中心的条形的值：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Take a deep look at the positioning of the text element; it took a bit of tinkering
    until I figured it out. What I'm doing here mainly in the last parameter (the
    `y` position of our new text) is taking the bottom area of our chart, subtracting
    the current total that would give us exactly the tip of the bar. But that wouldn't
    work well as for positive values as it would be above the bar while for negative
    elements it would place it within the bottom area of the bar. Here comes the creative
    thinking; instead of creating a few cases, how about we position our text exactly
    in the middle of our element. To do that, we can take advantage of our `elementValue`
    variable again (as it's positive or negative) and if we take half its size and
    add it to our total, we will be in the center of the bar leaving only one last
    tweak adding 6 to our value (as our text is 12 pixels in height).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究文本元素的定位；直到我弄清楚为止，我进行了一些调整。我在这里主要是在最后一个参数（我们新文本的`y`位置）中进行操作，我取了我们图表的底部区域，减去当前的总数，这样就能得到条形图的顶端。但对于正值来说，这样做不太好，因为它会在条形图的上方，而对于负值来说，它会放在条形图的底部区域。这就需要创造性思维；我们可以把文本放在我们元素的中间。为了做到这一点，我们可以再次利用我们的`elementValue`变量（因为它是正数或负数），如果我们取它的一半大小并加到我们的总数中，我们就会处于条形图的中心，只需要最后一个调整，给我们的值加上6（因为我们的文本高度为12像素）。
- en: 'There you go! You have just created your first waterfall chart. Let''s test
    it; remove any data visualization function calls from our `init` function (such
    as `createBars` or `addLine`) and instead replace them with our new function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你刚刚创建了你的第一个瀑布图。让我们来测试一下；从我们的`init`函数中删除任何数据可视化函数调用（比如`createBars`或`addLine`），并用我们的新函数替换它们：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that I am using the `formatData` object as I''m just reusing our array
    from an earlier sample. I just updated the values so they don''t step out of a
    total of 300:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我正在使用`formatData`对象，因为我只是重用了我们之前样本中的数组。我只是更新了值，使它们不超出总数300：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's more...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Where we ended, leads us to the issue that we can''t control the data and the
    more we ask of the end user/developer to adjust, the longer the learning curve
    is. It''s great that we have our `chartInfo` object that stores most of our helper
    information, but what if someone doesn''t fill out the attributes? Should our
    application fail or should we do our best to figure out new default values for
    the user? So let''s say in this example the user does not fill out the `max` and
    `min` attributes of the `y` object:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们结束的地方，引出了一个问题，那就是我们无法控制数据，而且我们要求最终用户/开发人员做出调整的越多，学习曲线就越长。我们有一个存储大部分辅助信息的`chartInfo`对象，这很好，但是如果有人没有填写属性会怎么样呢？我们的应用程序应该失败，还是应该尽力为用户找到新的默认值？比如在这个例子中，用户没有填写`y`对象的`max`和`min`属性：
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The user indicates how many steps they want, but they do not provide any information
    on the smallest and largest values the chart should output. To solve this issue
    we need to revisit the way we are creating our charts. So far we created the chart
    in two totally separate steps (the last two lines in our `init` function):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 用户指定他们想要多少步骤，但他们没有提供关于图表应该输出的最小值和最大值的任何信息。为了解决这个问题，我们需要重新审视我们创建图表的方式。到目前为止，我们完全分开地创建了图表（在我们的`init`函数的最后两行）：
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: First we usually create the background and then draw the items, but in this
    case we have a much clearer relationship between the `fillchart` function and
    the `createWaterfall` function. As we are trying to reduce the user's code footprint
    we wouldn't want to add a bunch of logic for each sample that would be unique
    for each bar type. So instead we will revisit all the graphic functions we created
    (`addLine`, `createBars`, and `createWaterfall`) and move the `fillChart` function
    call to be the first thing in the functions. This will enable us to create custom
    tweaks before calling the `fillChart` function that would be invisible to the
    end user of our functions (such as you in a few months, so you don't need to remember
    how everything works). Everything should work the same for now but only our `createWaterfall`
    function will know how to deal with missing information (I'll leave it up to you
    to update the other functions).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们通常创建背景，然后绘制项目，但在这种情况下，我们在`fillchart`函数和`createWaterfall`函数之间有一个更清晰的关系。由于我们试图减少用户的代码占用，我们不希望为每个样本添加大量逻辑，这些逻辑对于每种条形图类型都是独特的。因此，我们将重新审视我们创建的所有图形函数（`addLine`、`createBars`和`createWaterfall`），并将`fillChart`函数调用移到函数的第一件事。这将使我们能够在调用`fillChart`函数之前创建自定义调整，这些调整对我们函数的最终用户（比如几个月后的你）是不可见的，因此你不需要记住一切是如何工作的。现在一切应该都能正常工作，但只有我们的`createWaterfall`函数会知道如何处理缺失的信息（我会让你更新其他函数）。
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that we have our `fillChart` function and everything is working, let''s
    add some extra logic just before we call the `fillChart` function to help add
    the `min`/`max` values dynamically:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`fillChart`函数，并且一切都正常工作，让我们在调用`fillChart`函数之前添加一些额外的逻辑，以帮助动态添加`min`/`max`值：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notice that we are checking to see if the `min` or `max` values are missing
    and if so, we are calling the `updateCumulativeChartInfo` function to update or
    add the values.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在检查`min`或`max`值是否缺失，如果是，我们将调用`updateCumulativeChartInfo`函数来更新或添加这些值。
- en: 'Let''s create the `updateCumulativeChartInfo` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`updateCumulativeChartInfo`函数：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We are using two variables: `aTotal` and `total`. The `aTotal` variable stores
    the total in each loop. After we have the value of our `total` variable throughout
    all phases of our chart within the `aTotal` array, it''s time to figure out what
    the minimum and maximum value will be. We have a problem here. The `Math.min`
    method can take in an unlimited number of parameters but we have an array that
    isn''t compatible with the requirements of the `Math.min` method. To determine
    the values we can use a fun hack by using the `apply` method. Every function has
    an `apply` method. What the `apply` method does is enable you to change the scope
    of a function and send the parameters as an array.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个变量：`aTotal`和`total`。`aTotal`变量在每个循环中存储总数。在`aTotal`数组中，我们有了我们的`total`变量在图表的所有阶段中的值后，就该确定最小值和最大值了。我们有一个问题。`Math.min`方法可以接受无限数量的参数，但我们有一个与`Math.min`方法的要求不兼容的数组。为了确定值，我们可以使用`apply`方法的一个有趣的技巧。每个函数都有一个`apply`方法。`apply`方法的作用是使您能够更改函数的作用域并将参数作为数组发送。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more info on the `apply` method check the video at the following website:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`apply`方法的更多信息，请查看以下网站的视频：
- en: '[http://02geek.com/catagory/favorites/apply.html](http://02geek.com/catagory/favorites/apply.html)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://02geek.com/catagory/favorites/apply.html](http://02geek.com/catagory/favorites/apply.html)'
- en: Now that our data has been dynamically created everything should work. When
    we run the application we will see we are getting some numbers that are too detailed
    (such as 3.33333). The next step is to do some format tweaking.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据已经动态创建，一切应该正常工作。当我们运行应用程序时，我们会发现得到一些太详细的数字（例如3.33333）。下一步是进行一些格式调整。
- en: Cleaning the format of numbers
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理数字的格式
- en: 'To solve the problem of our numeric values being very ugly, we can create a
    formatting function and just call it each time we output dynamically created values.
    So let''s first create the function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的数字值非常丑陋的问题，我们可以创建一个格式化函数，并在每次输出动态创建的值时调用它。所以让我们首先创建这个函数：
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The function parameters are the values to be formatted (`num`) and the number
    of places we want after the decimal point. In the function, we are multiplying
    the value by ten; the number of times is based on the value of the `lead` variable.
    We then convert the number into an integer and divide the number again.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数是要格式化的值（`num`）和小数点后我们想要的位数。在函数中，我们将值乘以十；乘以的次数基于`lead`变量的值。然后我们将数字转换为整数，再次除以该数字。
- en: 'Last but not least, let''s track down where we are adding the text; we will
    find it in the `fillChart` function. All that is left for us is to find the right
    text that is affected and update it to use our new formatting function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，让我们跟踪我们添加文本的位置；我们会在`fillChart`函数中找到它。我们唯一剩下的事情就是找到受影响的正确文本，并更新它以使用我们的新格式化函数：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Our format will look much better. And yes, you probably should leave these details
    to be configurable in the external `chartInfo` object, but we will leave that
    to you to make our library even smarter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的格式看起来会好得多。是的，你可能应该将这些细节留给外部`chartInfo`对象来配置，但我们会让你来使我们的库更加智能。
- en: Other tasks I've left open
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我留下的其他任务
- en: Our new waterfall has one assumption that we always start from zero. In our
    sample we won't change that, but we will revisit this idea in the next recipe
    when working with the candlestick chart. If you're bold, try to figure out a solution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新瀑布图有一个假设，即我们总是从零开始。在我们的示例中，我们不会改变这一点，但在下一个配方中，当使用蜡烛图表时，我们会重新审视这个想法。如果你勇敢的话，试着找出一个解决方案。
- en: Building a candlestick chart (stock chart)
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建蜡烛图表（股票图表）
- en: We are just about to make a super leap. Until now we worked with charts that
    had one data point, two data points, and a few variations on them, and now we
    are moving into a new world of four data points in every bar. The stock chart
    is a way to showcase changes in the market in a given time frame (in our example
    this is one day). Each day stock prices change many times, but the most important
    factors are the low and high values of the day and the opening and closing prices.
    A stock analyst needs to be able to see the information quickly and understand
    overall trends. We are skipping three data points elements, but we will be back
    to them in the recipe *Building a bubble chart* in [Chapter 4](ch04.html "Chapter 4. Let's
    Curve Things Up"), *Let's Curve Things Up*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正要迈出一大步。到目前为止，我们使用的图表只有一个数据点，两个数据点，以及一些变化，现在我们要进入一个新世界，每个柱状图有四个数据点。股票图表是展示市场在特定时间范围内（在我们的例子中是一天）变化的一种方式。每天股票价格会多次变动，但最重要的因素是当天的最低价、最高价以及开盘价和收盘价。股票分析师需要能够快速看到信息并理解总体趋势。我们跳过了三个数据点元素，但我们将在[第四章](ch04.html
    "第四章。让曲线变得更加曲线")“让曲线变得更加曲线”中的“构建气泡图表”中回到它们。
- en: '![Building a candlestick chart (stock chart)](img/3707OT_03_06.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![构建蜡烛图表（股票图表）](img/3707OT_03_06.jpg)'
- en: The worst thing you can do is to assume that the only usage of four dimensions
    of data is in the stock market. This is where you can come up with the next big
    thing. Visualizing data in a clean and quick way and converting data into logic
    is one of the most fun things about charts. With that said let's start creating
    our stock chart.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做的最糟糕的事情就是假设四个维度数据的唯一用途是在股票市场上。这就是你可以想出下一个大事件的地方。以清晰快速的方式可视化数据，并将数据转化为逻辑是关于图表最有趣的事情之一。说了这么多，让我们开始创建我们的股票图表。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Our first step is going to be a bit different in this recipe. I''ve created
    a sample CSV file called `DJI.txt`; you can find it in our source files. The format
    is the standard CSV format and the first line names all the data columns:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个配方中的第一步会有点不同。我创建了一个名为`DJI.txt`的示例CSV文件；你可以在我们的源文件中找到它。格式是标准的CSV格式，第一行命名了所有数据列。
- en: '[PRE72]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And all future lines contain the data (daily data in our case):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的所有行都包含数据（在我们的例子中是每日数据）：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: So the steps we will need to go through are loading the file, converting the
    data to fit our standard data set, and then build the new chart type (and then
    fixing things as we discover issues; agile development).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要经历的步骤是加载文件，将数据转换为适合我们标准数据集的格式，然后构建新的图表类型（然后在发现问题时进行修复；敏捷开发）。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to base our work starting from where we left in the previous recipe.
    We will start the modifications right in the JavaScript file:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一个步骤离开的地方开始工作。我们将直接在JavaScript文件中开始修改：
- en: 'Let''s update our global variables:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新全局变量：
- en: '[PRE74]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Before we start our internal logic, we need to load our new external CSV file.
    We will rename the `init` function and call it `startUp` and then create a new
    `init` function:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始内部逻辑之前，我们需要加载新的外部CSV文件。我们将重命名`init`函数并将其称为`startUp`，然后创建一个新的`init`函数：
- en: '[PRE75]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The data we get back from the CSV file needs to be formatted to a structure
    we can work with. For that we create the `translateCSV` function that takes in
    the raw CSV data and converts it into an object that matches our architecture
    needs:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从CSV文件中获取的数据需要格式化为我们可以使用的结构。为此，我们创建了`translateCSV`函数，该函数接受原始CSV数据并将其转换为与我们架构需求匹配的对象：
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Our `startUp` function, formally known as `init`, will remain the same besides
    changing the `createWaterfall` method to call `addStock`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`startUp`函数，以前称为`init`，除了将`createWaterfall`方法更改为调用`addStock`之外，将保持不变：
- en: '[PRE77]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It is time to create the `addStock` function:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建`addStock`函数了：
- en: '[PRE78]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: All these steps are required to create a new candlestick chart.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的蜡烛图表需要执行所有这些步骤。
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Let's review the steps to load our external file. If you are working with open
    source tools such as jQuery you will be better off using them to load external
    files but, to avoid using other libraries, we will work with the `XMLHttpRequest`
    object as it's supported in all modern browsers that support HTML5.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下加载外部文件的步骤。如果您使用jQuery等开源工具，最好使用它们来加载外部文件，但是为了避免使用其他库，我们将使用`XMLHttpRequest`对象，因为它在支持HTML5的所有现代浏览器中都受支持。
- en: 'We start with creating a new `XMLHttpRequest` object:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的`XMLHttpRequest`对象：
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The next step is to set what we want to do (`GET/POST`) and the name of the
    file, followed by creating a handler function for the `onreadystatechange` callback
    and sending our request.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置我们想要执行的操作（GET/POST）和文件名，然后创建`onreadystatechange`回调的处理程序函数并发送我们的请求。
- en: '[PRE80]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The event handler `onreadystatechange` gets called a few times throughout the
    loading process of a file. We only want to listen in and act once the file is
    loaded and ready to be played with; to do that we will check whether the `readyState`
    variable is equal to four (ready and loaded). When the file is loaded, we want
    to split our file into an array based on line breaks.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序`onreadystatechange`在文件加载过程中会被调用几次。我们只想在文件加载完成并准备好处理时监听并执行操作；为此，我们将检查`readyState`变量是否等于四（准备就绪和已加载）。文件加载完成后，我们希望根据换行符将文件拆分为数组。
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the file was created on a Mac. The `\n` does the trick, but when you
    create your own files or download files, you might need to use `\r` or a combination
    `\n\r` or `\n\r`. Always confirm that you made the right selection by outputting
    the length of your array and validating its right size (then test to see if its
    content is what you expect it to be).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该文件是在Mac上创建的。`\n`起到了作用，但是当您创建自己的文件或下载文件时，您可能需要使用`\r`或组合`\n\r`或`\n\r`。始终通过输出数组的长度并验证其正确大小（然后测试其内容是否符合您的预期）来确认您是否做出了正确的选择。
- en: After our array is ready we want to format it to the user-friendly format followed
    by starting up the old `init` function that is now known as `startUp`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数组准备就绪后，我们希望将其格式化为用户友好的格式，然后启动旧的`init`函数，现在称为`startUp`。
- en: 'Let''s quickly review the `translateCSV` formatting function. We are literally
    looping through our data array that was created earlier and replacing each line
    with a formatted object that will work for our needs. Notice that we have an optional
    parameter `startIndex`. If nothing or zero is set then on the first line we are
    assigning it the value of `1`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下`translateCSV`格式化函数。我们实际上是在循环遍历之前创建的数据数组，并用格式化的对象替换每一行，这将适用于我们的需求。请注意，我们有一个可选参数`startIndex`。如果未设置任何值或设置为零，则在第一行上我们将其赋值为`1`：
- en: '[PRE81]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The former is a shorthand way of writing:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 前者是一种简写的写法：
- en: '[PRE82]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If the `startIndex` parameter has a value that is equivalent to true then it
    would remain as it was; if not, it would be converted to `1`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`startIndex`参数的值等于true，则保持不变；否则，将其转换为`1`。
- en: 'By the way, if you don''t know how to work with these shortcuts, I really recommend
    getting familiar with them; they are really fun and save time and typing. If you
    want to learn more on this check the following links:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果您不知道如何使用这些快捷方式，我真的建议您熟悉它们；它们非常有趣，可以节省时间和输入。如果您想了解更多，请查看以下链接：
- en: '[http://www.jquery4u.com/javascript/shorthand-javascript-techniques/](http://www.jquery4u.com/javascript/shorthand-javascript-techniques/)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.jquery4u.com/javascript/shorthand-javascript-techniques/](http://www.jquery4u.com/javascript/shorthand-javascript-techniques/)'
- en: '[http://02geek.com/javascript/objects-and-arrays.html](http://02geek.com/javascript/objects-and-arrays.html)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://02geek.com/javascript/objects-and-arrays.html](http://02geek.com/javascript/objects-and-arrays.html)'
- en: Great! Now we have a data source that is formatted in the style we've been using
    so far.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有了一个数据源，其格式与我们迄今为止使用的样式相同。
- en: We will hardcode our `chartInfo` object. It will work out well for our `y` values
    but not that well for our date requirements (in the `x` values). We will revisit
    that issue later after we get our chart running. We created a dynamic range generator
    in an earlier exercise, so if you want to keep up with that then review it and
    add that type of logic into this chart as well, but for our needs we will keep
    it hardcoded for now.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将硬编码我们的`chartInfo`对象。它对我们的`y`值效果很好，但对我们的日期要求（在`x`值中）效果不是很好。在我们的图表运行后，我们将稍后重新讨论这个问题。在早期的练习中，我们创建了一个动态范围生成器，所以如果您想跟上这个，那么请回顾一下，并将这种类型的逻辑也添加到这个图表中，但对于我们的需求，我们现在将它硬编码。
- en: 'Ok, so let''s dig deeper into the `addStock` function. By the way, notice that
    as we are working with the same format and overall tools, we can mix charts together
    with ease. But before we do that, let''s understand what the `addStock` function
    actually does. Let''s start with our base variables:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们深入了解`addStock`函数。顺便说一下，注意到我们正在使用相同的格式和整体工具，我们可以轻松地混合图表。但在这之前，让我们了解一下`addStock`函数实际上是做什么的。让我们从我们的基本变量开始：
- en: '[PRE83]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We are gathering information that will make it easier to work in our loop when
    creating the bars from the width of elements (`elementWidth` to the ratio between
    our values and the height of our chart). All these variables have been covered
    in earlier recipes in this chapter.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在收集信息，这将使我们在创建柱状图时更容易工作（从元素的宽度`elementWidth`到我们的值和图表高度之间的比率）。所有这些变量在本章的早期示例中都有涉及。
- en: '[PRE84]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: These variables are going to be our helper variables (updated after every round
    of our loop) to establish the position of the high, low, open, and close offsets
    (as we are drawing a rectangle, it expects the height and not a second `y` value).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量将成为我们的辅助变量（在每轮循环后更新），用于确定高、低、开盘和收盘偏移的位置（因为我们正在绘制一个矩形，它期望高度而不是第二个`y`值）。
- en: 'The first thing we do in each round of our loop is to find out the values for
    these variables:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的循环的每一轮中，我们首先找出这些变量的值：
- en: '[PRE85]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You will notice that the logic is almost the same in all of the variables. We
    are just subtracting the minimum from the value (as our chart doesn't cover values
    under our minimum value), and then multiplying it by our `stepSize` ratio to have
    the value fit within our chart dimensions (this way even if we change our chart
    size everything should continue working). Note that only the `closeYOffset` variable
    doesn't subtract the `min` property but instead it subtracts the `close` property.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，所有变量的逻辑几乎都是相同的。我们只是从值中减去最小值（因为我们的图表不包括最小值以下的值），然后将其乘以我们的`stepSize`比率，使值适应我们的图表尺寸（这样即使我们改变图表尺寸，一切都应该继续工作）。请注意，只有`closeYOffset`变量不是减去`min`属性，而是减去`close`属性。
- en: 'The next step is to draw our candlestick chart starting with a line from the
    low to the high of the day:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是绘制我们的蜡烛图表，从当天的最低点到最高点开始画一条线：
- en: '[PRE86]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This will be followed by the rectangle that represents the full open and close
    values:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是代表完整开盘和收盘值的矩形：
- en: '[PRE87]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: After this, we will create a fill to this rectangle and set the style color
    based on the value of the `closeYOffset` variable. At this stage we have a running
    application, although it can use a few more tweaks to make it work better.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将为这个矩形创建一个填充，并根据`closeYOffset`变量的值设置样式颜色。在这个阶段，我们有一个运行中的应用程序，尽管它可能需要一些调整来使其运行得更好。
- en: There's more...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It''s time to fix our `x` coordinate values:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候修复我们的`x`坐标值了：
- en: '[PRE88]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We didn''t change this variable before as until now there was a clear separation
    between the outline and our content (the chart itself); but at this stage as our
    `x` outline content isn''t a linear number anymore but a date; we need to somehow
    introduce into the `fillChart` method external data that is related to the content
    of the chart. The biggest challenge here is that we don''t want to introduce into
    this method something that is only relevant to our chart as this is a globally
    used function. Instead we want to put our unique data in an external function
    and send that function in as a formatter. So let''s get started:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们没有改变这个变量，因为到目前为止，轮廓和我们的内容（图表本身）之间有明显的分离；但在这个阶段，由于我们的`x`轮廓内容不再是一个线性数字，而是一个日期；我们需要以某种方式将与图表内容相关的外部数据引入`fillChart`方法。这里最大的挑战是，我们不想在这个方法中引入仅与我们的图表相关的东西，因为这是一个全局使用的函数。相反，我们希望将我们的唯一数据放在一个外部函数中，并将该函数作为格式化程序发送进去。所以让我们开始吧：
- en: '[PRE89]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Our `x` space in a stock chart represents time and as such our previous usage
    based on linear data does not apply (the properties such as `min`, `max`, and
    `steps` have no meaning in this case). We will remove them in favor of a new property
    `formatter` that will take a function as its value. We will use this `formatter`
    function instead of the default function. If this function is set we will let
    an external function define the rules. We will see more on this when we describe
    the `weeklyCapture` function. This method of coding is called **plugin coding**
    . Its name is derived out of the idea of enabling us to create replaceable functions
    without reworking our core logic in the future. Before we create the `weeklyCapture`
    function, let''s tweak the `chartInfo` object so we have the right range and number
    of steps:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们股票图表中的`x`空间代表时间，因此我们以前基于线性数据的使用不适用（例如`min`、`max`和`steps`等属性在这种情况下没有意义）。我们将删除它们，而是使用一个新属性`formatter`，它将以函数作为其值。我们将使用这个`formatter`函数而不是默认函数。如果设置了这个函数，我们将让一个外部函数定义规则。当我们描述`weeklyCapture`函数时，我们将会更多地了解这一点。这种编码方法称为**插件编码**。它的名称源自这样一个想法，即使我们在未来重新设计核心逻辑，也能够创建可替换的函数。在创建`weeklyCapture`函数之前，让我们调整`chartInfo`对象，以便获得正确的范围和步数：
- en: '[PRE90]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: What we are doing here is, before we call the `fillChart` function in our `addStock`
    function, we are checking to see if the `max` value is set; if it isn't set, we
    are going to reset all the values, setting the `min` to `0` and the `max` and
    `steps` to the length of our data array. We are doing this as we want to travel
    through all of our data elements to test and see if there is a new weekday.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要做的是，在`addStock`函数中调用`fillChart`函数之前，我们要检查`max`值是否已设置；如果没有设置，我们将重置所有值，将`min`设置为`0`，将`max`和`steps`设置为数据数组的长度。我们这样做是因为我们想要遍历所有的数据元素，以测试并查看是否有新的工作日。
- en: Now we integrate our `weeklyCapture` function into the `fillChart` function.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将`weeklyCapture`函数整合到`fillChart`函数中。
- en: '[PRE91]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In our first step, we are going to fetch the value that comes back from our
    `formatter` function.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一步中，我们将获取从我们的`formatter`函数返回的值。
- en: '[PRE92]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The logic is simple, we are checking to see if the `formatter` function exists
    and if it does we are calling it and sending the current value of `i` (as we are
    in the loop).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单，我们正在检查`formatter`函数是否存在，如果存在，我们就调用它并发送当前值`i`（因为我们在循环中）。
- en: 'The next step is if our output isn''t empty (negative or has a value equivalent
    to false) or if our output is empty but our formatter isn''t active then render
    the data:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是，如果我们的输出不为空（负数或等于false的值），或者如果我们的输出为空但我们的格式化程序没有激活，那么渲染数据：
- en: '[PRE93]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Only if we have an output from the `formatter` function and/or if the `formatter`
    function does not exist we don''t need to do anything. As such we need the `if`
    statement to capture both the scenarios, if we do not have the `if` statement,
    then our output will not conform to our earlier recipes. The only content we are
    changing within this block of code is the `fillText` method. If we are working
    with our output, we want to use that for the text. If not, we want to keep the
    logic that was there before the same:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们从`formatter`函数获得输出和/或`formatter`函数不存在时，我们才不需要做任何事情。因此，我们需要`if`语句来捕获两种情况，如果我们没有`if`语句，那么我们的输出将不符合我们之前的规则。我们在这段代码块中更改的唯一内容是`fillText`方法。如果我们正在处理输出，我们希望将其用于文本。如果没有，我们希望保持之前的逻辑不变：
- en: '[PRE94]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We have one last thing we need to cover before we can run our application and
    see it in action and that is to create our `weeklyCapture` function. So let''s
    create it now:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行应用程序并查看它运行的最后一件事是创建我们的`weeklyCapture`函数。所以现在让我们创建它：
- en: '[PRE95]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We start by creating a helper variable called `DAY` that will store how many
    milliseconds there are in a day:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`DAY`的辅助变量，它将存储一天有多少毫秒：
- en: '[PRE96]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If you take a peek at our external data, you will see that only on day `0`
    we have an actual date (formatted in milliseconds since 1970). All we need to
    do is send that to the `date` object to create a date:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们的外部数据，您会发现只有在第`0`天我们有一个实际日期（以自1970年以来的毫秒格式化）。我们只需要将其发送到`date`对象以创建一个日期：
- en: '[PRE97]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'While all other data lines contain only a number that represents how many days
    passed since that original date, we want to test and see if the current date is
    only one day after the last day. Only if the date change is greater than one day,
    we will create a new date format for it:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有其他数据行只包含一个数字，表示自原始日期以来经过了多少天，但我们想要测试并查看当前日期是否仅比上一个日期晚一天。只有当日期变化大于一天时，我们才会为其创建新的日期格式：
- en: '[PRE98]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that to create the date object we need to take our current original date
    from row `0` and then add to it the total days in milliseconds (multiplying our
    `DAY` variable with the current day value).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要创建日期对象，我们需要获取第`0`行的当前原始日期，然后将其与毫秒中的总天数相加（将我们的`DAY`变量乘以当前天数值）。
- en: 'With this method all that is left to check is if we have a valid date. Let''s
    format it and send it back, and if not, we will send back `false`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们只需要检查是否有有效的日期。让我们格式化它并发送回去，如果没有，我们将发送回`false`：
- en: '[PRE99]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Congratulations! Now our sample is a fully fledged integrated candlestick chart
    with live dynamic dates.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在我们的示例是一个完全集成的蜡烛图表，具有动态日期。
- en: Adding other render options to our stock chart
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向我们的股票图表添加其他渲染选项
- en: 'Although the candlestick chart is a very popular option, there is another popular
    technical chart view. One that is used when there are no colors to use. Instead
    of the usage of colors, on the left-hand side we draw a line to define the opening
    price, and on the right-hand side we capture the closing price. Let''s integrate
    that logic into our chart as an optional render mode. We will add a new parameter
    to the `addStock` function:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管蜡烛图表是一个非常受欢迎的选项，但还有另一种受欢迎的技术图表视图。当没有颜色可用时使用的一种视图。在左侧绘制一条线来定义开盘价，在右侧捕获收盘价。让我们将该逻辑集成到我们的图表中作为可选的渲染模式。我们将向`addStock`函数添加一个新参数：
- en: '[PRE100]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We are now going to adjust our internal `for` loop to change the render depending
    on the value of this variable:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调整我们的内部`for`循环，以根据这个变量的值改变渲染：
- en: '[PRE101]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'There we go. We set the default to be `false` for our `isCandle` Boolean variable.
    If we run our application again, we will find it rendering in the new format.
    To change that, all we need to do is provide that third parameter as `true` when
    calling the `addStock` function:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以了。我们将`isCandle`布尔变量的默认值设置为`false`。如果我们再次运行我们的应用程序，我们会发现它以新格式呈现。要更改这一点，我们只需要在调用`addStock`函数时提供第三个参数为`true`：
- en: '![Adding other render options to our stock chart](img/3707OT_03_07.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![向我们的股票图表添加其他渲染选项](img/3707OT_03_07.jpg)'
- en: This chapter has been self-contained and really the hub of all the charts if
    you need to strengthen your chart building skills. I recommend you to revisit
    some of the earlier recipes in this chapter.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是自包含的，真正是所有图表的中心，如果您需要加强图表构建技能。我建议您重新查看本章中的一些早期示例。
