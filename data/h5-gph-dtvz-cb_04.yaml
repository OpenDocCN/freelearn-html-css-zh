- en: Chapter 4. Let's Curve Things Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 让事情变得曲线
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Building a bubble chart
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建气泡图
- en: Creating a pie chart
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建饼图
- en: Using a doughnut chart to show relationships
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用甜甜圈图表显示关系
- en: Leveraging a radar
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用雷达
- en: Structuring a tree chart
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建树状图
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the last chapter, we built a component for linear graphs ranging through
    dots, lines, and bars. Most of the data we worked with was two-dimensional, while
    we ended our lesson with a four-dimensional chart. It was still represented using
    linear art. In this chapter, we will leverage the capability of creating non-linear
    data to represent data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个用于线性图的组件，通过点、线和条形图进行范围。我们处理的大部分数据是二维的，而我们在四维图表结束了我们的课程。它仍然使用线性艺术来表示。在本章中，我们将利用创建非线性数据来表示数据的能力。
- en: Building a bubble chart
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建气泡图
- en: Although many items in our chart will have correlations with earlier charts
    that we created in [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based
    Graphs"), *Creating Cartesian-based Graphs*, we will start from scratch. Our goal
    is to create a chart that has bubbles in it—the bubbles enable us to showcase
    data with three data points (x, y, and the size of the bubble). This type of chart
    is really ideal when animated as it can showcase changes over time (it could showcase
    many years in a few seconds).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们图表中的许多项目与我们在[第3章](ch03.html "第3章. 创建基于笛卡尔坐标系的图表")中创建的图表有关，但我们将从头开始。我们的目标是创建一个具有气泡的图表——气泡使我们能够展示具有三个数据点（x、y和气泡大小）的数据。这种类型的图表在动画时非常理想，因为它可以展示随时间的变化（它可以在几秒钟内展示多年的变化）。
- en: A great demo of the powers of bubble charts can be seen in a TED presentation
    by Hans Rosling ([http://blog.everythingfla.com/2012/05/hans-rosling-data-vis.html](http://blog.everythingfla.com/2012/05/hans-rosling-data-vis.html)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡图的强大功能在Hans Rosling的TED演示中可以得到很好的展示（[http://blog.everythingfla.com/2012/05/hans-rosling-data-vis.html](http://blog.everythingfla.com/2012/05/hans-rosling-data-vis.html)）。
- en: '![Building a bubble chart](img/3707OT_04_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![构建气泡图](img/3707OT_04_01.jpg)'
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will start up our project with a canvas setup and skip the HTML end. If you
    have forgotten how to create it please refer to the *Graphics with 2D Canvas*
    recipe in [Chapter 1](ch01.html "Chapter 1. Drawing Shapes in Canvas"), *Drawing
    Shapes in Canvas*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从画布设置开始启动我们的项目，并跳过HTML结尾。如果您忘记了如何创建，请参考[第1章](ch01.html "第1章. 在画布中绘制形状")中的*使用2D画布绘制图形*。
- en: 'There are three major steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要步骤：
- en: Creating the data source
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据源
- en: Creating the background
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建背景
- en: Adding the chart data info into the chart
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图表数据信息添加到图表中
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s list the steps required to create a bubble chart:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出创建气泡图所需的步骤：
- en: 'The next data object should look familiar in an array that has objects within
    it with student scores in English, Math, and programming. Build the data object:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个数据对象应该看起来很熟悉，它是一个数组，其中包含有关学生在英语、数学和编程方面的成绩的对象。构建数据对象：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create our chart information; contrary to previous charts, this chart has a
    third parameter for our bubble information. Define our chart rules:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的图表信息；与以前的图表相反，这个图表有一个用于气泡信息的第三个参数。定义我们的图表规则：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last data object will contain all the styling information that we might
    want to change in the future. Add a styling object:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的数据对象将包含我们将来可能想要更改的所有样式信息。添加一个样式对象：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We create an event callback when the document is ready to trigger `init`, so
    let''s create the `init` function:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文档准备就绪时，我们创建一个事件回调来触发`init`，因此让我们创建`init`函数：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We start creating our outline when we create our style object. Now it''s time
    to draw everything into our canvas. So we start by setting up our base canvas
    style:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建样式对象时，我们开始创建我们的轮廓。现在是时候将一切绘制到我们的画布中了。因此，我们首先设置我们的基本画布样式：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to save our current, canvas-based graphic layout information, change
    it to make it easier to position elements and then return it back to its original
    state:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要保存我们当前的基于画布的图形布局信息，对其进行更改以使其更容易定位元素，然后将其恢复到原始状态：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now it is time to draw the outlines with the help of our `chartInfo` object:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候借助我们的`chartInfo`对象绘制轮廓了：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now it is time to add the data into our chart by creating the `addDots` method.
    The function `addDots` will take in the data with the definition of rules (keys)
    to be used, contrary to what we did in the earlier recipes.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候通过创建`addDots`方法将数据添加到我们的图表中了。`addDots`函数将使用规则（键）来接收数据的定义，与我们在之前的食谱中所做的相反。
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This block of code, although redone from scratch, bears a lot of resemblance
    to the *Spreading data in a scatter chart* recipe in [Chapter 3](ch03.html "Chapter 3. Creating
    Cartesian-based Graphs"), *Creating Cartesian-based Graphs*, with modifications
    to enable the third level of data and the new charting format.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这一段代码虽然是从头开始重新编写的，但与[第3章](ch03.html "第3章. 创建基于笛卡尔坐标系的图表")中的*在散点图中传播数据*食谱有很多相似之处，通过修改使其能够处理第三级数据和新的图表格式。
- en: That's it. You should have a running bubble chart. Now when you run the application,
    you will see that the `x` parameter is showcasing the math score, the `y` parameter
    is showcasing the programming score, while the size of our bubble showcases the
    student's score in English.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。您应该有一个运行中的气泡图。现在当您运行应用程序时，您将看到`x`参数展示了数学成绩，`y`参数展示了编程成绩，而我们气泡的大小展示了学生的英语成绩。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start with the `createOutline` function. In this method, apart from
    the regular canvas drawing methods that we grow to love, we introduce a new style
    of coding where we manipulate the actual canvas to help us define our code in
    an easier way. The two important key methods here are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`createOutline`函数开始。在这个方法中，除了我们喜欢的常规画布绘制方法之外，我们还引入了一种新的编码风格，在这种风格中，我们操纵实际的画布来帮助我们以更简单的方式定义我们的代码。这里的两个重要关键方法如下：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will be leveraging both the methods a few times. The `save` method saves
    the current view of the canvas while the `restore` method returns users to the
    last saved canvas:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将多次利用`save`方法。该方法保存画布的当前视图，而`restore`方法将用户返回到上次保存的画布：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first use of this style, we are using it to draw our text by rotating
    it to the right. The `translate` method moves the `0, 0` coordinates of the canvas
    while the `rotate` method rotates the text using radians.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次使用这种样式时，我们将其用于通过将其旋转到右侧来绘制我们的文本。`translate`方法移动画布的`0,0`坐标，而`rotate`方法使用弧度旋转文本。
- en: After drawing the external bars, it's time for us to use this new capability
    to our advantage. Most charts rely on a y coordinate that grows upwards, but this
    canvas has the y values growing from the top to the bottom of the canvas area.
    We can flip this relationship by adding some code before we loop through to add
    the range values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制外部条之后，是时候利用这种新能力了。大多数图表依赖于y坐标向上增长，但是这个画布的y值是从画布区域的顶部向底部增长的。我们可以通过在循环之前添加一些代码来翻转这种关系。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding lines, we are first moving the `0,0` coordinates of our canvas
    to be exactly at the bottom-right range of our chart, and then we are flipping
    our canvas by switching the scale value. Note that from now on if we try to add
    text to the canvas, it will be upside down. Keep that in mind as we are now drawing
    in a canvas that is flipped upside down.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们首先将画布的`0,0`坐标移动到图表的右下范围，然后通过切换比例值翻转画布。请注意，从现在开始，如果我们尝试向画布添加文本，它将是颠倒的。请记住，因为我们现在正在绘制一个颠倒的画布。
- en: 'One thing to note in our first loop when we try to type in new text is that
    when we want to add text, we first undo our scale and then return back our canvas
    for it to be flipped:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个循环中，当我们尝试输入新文本时，需要注意的一点是，当我们想要添加文本时，我们首先撤消我们的比例，然后将画布返回以进行翻转：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we are multiplying our y coordinate by `*-1`. We are doing this because
    we actually want the value of our y coordinate to be negative as we have just
    flipped the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将y坐标乘以`*-1`。我们这样做是因为我们实际上希望y坐标的值为负数，因为我们刚刚翻转了屏幕。
- en: The work around the x bar text is very similar; notice the main differences
    related to finding the x and y value calculations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于x条文本的工作方式非常相似；请注意与查找x和y值计算相关的主要区别。
- en: It's time to dig into the `addDots` function. The function will again look familiar
    if you've been following [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based
    Graphs"), *Creating Cartesian-based Graphs*, but this time we are working with
    a modified canvas.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是深入了解`addDots`函数的时候了。如果您一直在关注[第3章](ch03.html "第3章。创建基于笛卡尔的图表")，*创建基于笛卡尔的图表*，那么这个函数会再次让您感到熟悉，但这次我们使用的是修改后的画布。
- en: 'We start with a few helper variables:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一些辅助变量：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are adding the bubble effect dynamically, which means that this method can
    work even if there are only two points of information and not three. We continue
    by testing to see if our data object contains the bubble information:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们动态添加气泡效果，这意味着即使只有两个信息点而不是三个，该方法也可以工作。我们继续测试我们的数据对象是否包含气泡信息：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If so, we add a few more variables and align our text to the left as we are
    going to use it in this example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们将添加一些变量并将我们的文本对齐到左侧，因为我们将在这个示例中使用它。
- en: It's time for us to look through our data object and propagate the data on the
    chart.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候浏览我们的数据对象并在图表上传播数据了。
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For each loop, we recalculate the `_x` and `_y` coordinates based on the current
    values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个循环，我们根据当前值重新计算`_x`和`_y`坐标。
- en: If we have a third element, we are ready to develop a bubble. If we do not have
    it, we need to create a simple dot.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有第三个元素，我们就准备开发一个气泡。如果没有，我们需要创建一个简单的点。
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At this stage, we should have an active bubble/dot method. All that is left
    is for us to integrate our overlay copy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该有一个活跃的气泡/点方法。我们所要做的就是集成我们的覆盖副本。
- en: 'Before we add a label, let''s take a peek at the function signature:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加标签之前，让我们看一下函数签名：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `context` and `chartInfo` parameters are already a standard in our samples.
    The idea of keys was to enable us to switch what data will be tested dynamically.
    The keys' values are the array positions `0` and `1` that are correlated to the
    x and y coordinates, and position `2` is used for bubbles, as we've seen earlier.
    The `label` parameter enables us to send in a key value for the label. In this
    way, if the label is there we will add a label and if it is not there we will
    not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`和`chartInfo`参数在我们的示例中已经是标准的。键的想法是使我们能够动态切换要测试的数据。键的值是与x和y坐标相关的数组位置`0`和`1`，位置`2`用于气泡，正如我们之前所见。`label`参数使我们能够发送标签的键值。通过这种方式，如果标签存在，我们将添加一个标签，如果不存在，我们将不添加。'
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then we add the preceding `if` statement. If our label is set, we position the
    style and create the text of the label.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加前面的`if`语句。如果我们设置了标签，我们就定位样式并创建标签的文本。
- en: Creating a pie chart
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建饼图
- en: 'The steps to create a pie chart are relatively easy and short. Pie charts are
    ideal for showcasing a closed amount of data that we want to easily compare between
    data fields such as, in our example, dividing the number of people in the world
    into groups based on their region:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建饼图的步骤相对简单而短。饼图非常适合展示我们想要在数据字段之间轻松比较的封闭数据量，例如，在我们的示例中，根据其地区将世界上的人数分组：
- en: '![Creating a pie chart](img/3707OT_04_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![创建饼图](img/3707OT_04_02.jpg)'
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first step will be to update our canvas size in the HTML area to be a rectangular
    area. In our sample, we will update the values to 400 x 400\. That's about it;
    let's start building it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是在HTML区域更新我们的画布大小为矩形区域。在我们的示例中，我们将更新值为400 x 400。就是这样；让我们开始建立它。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps we will create our first pie chart. Let''s get started:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将创建我们的第一个饼图。让我们开始吧：
- en: 'Set up our data source and our global variables:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的数据源和全局变量：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Prepare our canvas (from here on we are delving into the `init` function):'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备我们的画布（从这里开始我们将深入`init`函数）：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Count the total data (world population):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算总数据（世界人口）：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Set up 360 degrees in radians and move our pivot point to `0,0`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置360度的弧度并将我们的旋转点移动到`0,0`：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Draw the pie chart by using the following code snippet:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段绘制饼图：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's it; we have just created a basic pie chart—I told you it would be easy!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；我们刚刚创建了一个基本的饼图——我告诉过你这很容易！
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Our pie chart, as its name indicates, uses pies and always showcases 100 percent
    of data. As our arc method works based on radians, we need to convert these data
    points from percentile to radians.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，我们的饼图使用饼图，并始终展示100%的数据。由于我们的弧线方法是基于弧度的，我们需要将这些数据点从百分比转换为弧度。
- en: After figuring out what the total of all the values is and the total radians
    in a circle (`2*PI`), we are ready to loop through and draw the slices.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在弄清楚所有值的总和以及圆圈中的总弧度（`2*PI`）之后，我们准备循环并绘制切片。
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The logic is relatively simple; we loop through all the data elements, change
    the fill style based on the data object, and move our pointer to `0,0` (to the
    center of our screen as we have changed the pivot point of our canvas).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑相对简单；我们循环遍历所有数据元素，根据数据对象改变填充样式，并将指针移动到`0,0`（将画布的中心点作为我们的旋转点）。
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we draw the arc. Pay attention to the highlighted text; we start with where
    we left off our current total and through that we calculate the angle in radians:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来绘制弧线。注意高亮显示的文本；我们从当前总数结束的地方开始，并通过这个计算弧度角度：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can turn this value into a percentage value that we can duplicate against
    the total radian of our circle. Our second parameter is very close, so we just
    add into it the current value of the current region we are in:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个值转换为我们可以对圆圈的总弧度进行复制的百分比值。我们的第二个参数非常接近，所以我们只需将当前值添加到我们所在的当前区域的当前值中：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And the last point to note here is that we are setting the arc's last parameter
    to `false` (counter clockwise) as that works best for our calculations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，我们将弧线的最后一个参数设置为`false`（逆时针），因为这对我们的计算效果最好。
- en: Last but not least, we update our `currentTotal` value to encompass the newly
    added region as that will be our starting point in the next round of our `for`
    loop.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们将更新我们的`currentTotal`值，以包括新添加的区域，因为这将是我们`for`循环的下一轮中的起始点。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: A pie chart without any information on its content is probably not going to
    work as well as a chart with information, but we can figure out the locations...
    well worry not; we are going to revisit our old friends `cos` and `sin` to help
    us locate the dots on our circle, to enable us to add textual information on our
    newly created pie.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有任何内容信息的饼图可能不会像有信息的图表那样有效，但我们可以找出位置……别担心；我们将重新审视我们的老朋友`cos`和`sin`来帮助我们定位圆圈上的点，以便我们能够在我们新创建的饼图上添加文本信息。
- en: Revisiting Math.cos() and Math.sin()
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新审视Math.cos()和Math.sin()
- en: 'We will start with adding a new global variable to store the color of our lines
    and then we will call it `copyStyle`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个新的全局变量来存储我们线条的颜色，然后我们将称之为`copyStyle`：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we are right back into our `init` function, let''s add it into our
    `for` loop just before the last line:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到了`init`函数，让我们在最后一行之前的`for`循环中添加它：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As expected, we will first set our new `copyStyle` variable as our fill and
    stroke value:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们将首先将我们的新`copyStyle`变量设置为我们的填充和描边值：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our next step is to locate where in our pie we would like to draw a line out
    so that we can add the text:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是确定我们想要在饼图中的哪个位置绘制一条线，以便我们可以添加文本：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To accomplish this, we will use a new variable that will store the mid-value
    between the last total and the new value (the center of the new slice). So far
    so good. Now we need to figure out how to get the x and y positions of that point.
    Lucky for us, there is a very easy way of doing it in a circle by using the `Math.cos`
    (for the x) and `Math.sin` (for our y) functions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用一个新变量来存储上一个总数和新值（新切片的中心）的中间值。到目前为止还不错。现在我们需要弄清楚如何获得该点的x和y位置。幸运的是，在圆圈中有一种非常简单的方法，就是使用`Math.cos`（对于x）和`Math.sin`（对于y）函数：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Armed with our `midRadian` variable, we will get the value for a circle with
    a radius of `1`, so all that is left for us to do is duplicate that value by our
    real radius to find our starting point. As we want to draw a line in the same
    direction to the arc externally, we will find the points of an imaginary circle
    that is larger; so for that we are going to use the same formula, but instead
    upgrade our radius values by 20, creating a diagonal line that is correlative
    to the arc.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有我们的`midRadian`变量，我们将得到一个半径为`1`的圆的值，所以我们要做的就是将这个值乘以我们真正的半径来找到我们的起始点。由于我们想要在同一方向上绘制一条线到外部的弧线，我们将找到一个更大的虚拟圆的点；所以我们将使用相同的公式，但是将我们的半径值升级20，创建一个与弧线相关的对角线。
- en: 'All that is left for us to do is figure out what text we would want to have
    within our chart, using the same arc point with a larger circle size:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的就是弄清楚我们想要在图表中放置什么文本，使用相同的弧线点和更大的圆圈尺寸：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Looks good... The only problem is that we don't have our values; let's add them
    and figure out the challenges involved with them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错……唯一的问题是我们没有我们的值；让我们添加它们并弄清楚涉及其中的挑战。
- en: Improving our bubbles' text format
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进我们气泡的文本格式
- en: 'In a real-world example, we would probably want to use a rollover if this was
    a live application (we will visit that idea in a later chapter), but let''s try
    to figure out a way to create the chart capable of containing all the information.
    We stopped in our preceding line of code with a really large exterior circle (`radius+40`).
    Well that''s because we wanted to slip in a new line of text right under, so let''s
    do it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，如果这是一个实时应用程序，我们可能希望使用悬停效果（我们将在后面的章节中讨论这个想法），但让我们尝试找出一种创建包含所有信息的图表的方法。我们在前一行代码中停下来，有一个非常大的外圆（`radius+40`）。这是因为我们想在下面插入一行新的文本，所以让我们来做吧：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It''s a bit of a mouthful, but it''s basically the same as the preceding line
    with a new line of text and an extra change, as we are shifting the y value by
    12 pixels to account for the first line of text on the same area. To get this
    working, we are using two helper functions that format our text:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点啰嗦，但基本上与前一行相同，只是多了一行文本和一个额外的更改，因为我们将y值向上移动12像素以适应同一区域上的第一行文本。为了使其工作，我们使用了两个帮助函数来格式化我们的文本：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you run the application in its current format, you will find that the text
    just doesn't look good on the page, and that is where the artist within you needs
    to sort things out. I've continued the sample in our source files until it felt
    right, so check it out or create your own variations from here on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以当前格式运行应用程序，您会发现文本在页面上看起来不好，这就是您内心的艺术家需要解决的问题。我一直在我们的源文件中继续示例，直到感觉合适，所以请查看它或从这里开始创建您自己的变体。
- en: Using a doughnut chart to show relationships
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用甜甜圈图表显示关系
- en: 'The doughnut chart is a fancy pie chart. So if you haven''t created a pie chart
    yet, I strongly encourage you to revisit the previous recipe, *Creating a pie
    chart*. A doughnut chart is a layered pie chart. This chart is ideal for condensing
    the comparable data between data types that would fit into a pie chart:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 甜甜圈图表是一种花哨的饼图。因此，如果您还没有创建过饼图，我强烈建议您重新查看上一个示例，*创建饼图*。甜甜圈图表是一种分层饼图。这种图表非常适合压缩适合饼图的数据类型之间的可比数据：
- en: '![Using a doughnut chart to show relationships](img/3707OT_04_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![使用甜甜圈图表显示关系](img/3707OT_04_03.jpg)'
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to grab our code from the last example and adjust it to fit our
    needs. So we will start with the same HTML file and the same code from the last
    example.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一个示例中获取我们的代码，并调整它以满足我们的需求。因此，我们将从相同的HTML文件和上一个示例中的相同代码开始。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Let''s update our data with some dummy data (we will create two data objects):'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一些虚拟数据更新我们的数据（我们将创建两个数据对象）：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Modify the `init` function by extracting all the pie-creating lines to a separate
    function and adding a new function `createHole` (for our doughnut):'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提取所有创建饼图的行到一个单独的函数并添加一个新函数`createHole`（用于我们的甜甜圈）来修改`init`函数：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Modify the pie creation to change the text layout to fit into a pie chart:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改饼图创建以改变文本布局以适应饼图：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to create the method `createHole` (actually a simple circle):'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建方法`createHole`（实际上是一个简单的圆）：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That's it! We can now create an endless doughnut with as many layers as we would
    like by changing the radius, making it smaller each time we add a new layer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在可以通过更改半径来创建一个无尽的甜甜圈，每次添加新层时使其变小。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The core logic of the doughnut chart is the same as that of the pie chart.
    Our main focus is really about reformatting and rewiring the content to be outlined
    at the visual level. As such, part of our work is to delete the things that are
    not relevant and to make the needed updates:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 甜甜圈图表的核心逻辑与饼图相同。我们的主要重点实际上是重新格式化和重连内容以在视觉层面进行轮廓。因此，我们的工作的一部分是删除不相关的内容并进行所需的更新：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The main thing to note is that we are hardcoding a value that is 20 less than
    the current radius. If we wanted our sample to work for every possible option,
    we would need to figure out a smarter way of generating this data as ideally we
    would want the text to be in between the doughnut area and rotated, but we have
    done things of that nature before so I'll leave that for you to explore.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要事情是，我们正在硬编码一个比当前半径小20的值。如果我们希望我们的样本适用于每种可能的选项，我们需要找出一种更智能的方法来生成这些数据，因为理想情况下，我们希望文本位于甜甜圈区域之间并且旋转，但我们以前做过类似的事情，所以我会留给你去探索。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although our doughnut is created and ready, it would help if we add some more
    information to it, such as outlines and a legend, as we extracted the majority
    of the text from the last example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的甜甜圈已经创建并准备好了，但如果我们添加一些更多的信息，比如轮廓和图例，会有所帮助，因为我们从上一个示例中提取了大部分文本。
- en: Adding an outline
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加轮廓
- en: 'We will use shadows to create a glow around our shapes. The easiest and quickest
    way to do it is to revisit the `init` function and add into it the shadow information
    to create this effect:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用阴影来在我们的形状周围创建发光效果。最简单和最快的方法是重新访问`init`函数并添加阴影信息以创建这种效果：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The key here is that we are setting our offset on both the x and y values to
    be `0`, and as such our shadow is being used as a glow. Every element that will
    be drawn from here on will have a shadow, and that works perfectly for us.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们将x和y值的偏移量都设置为`0`，因此我们的阴影被用作发光。从现在开始绘制的每个元素都将有一个阴影，这对我们来说非常完美。
- en: Creating a legend
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建图例
- en: Hey, since we have a huge hole in our doughnut, how about we put our legend
    right in the middle of everything? As sometimes the middle isn't exactly the best-looking
    thing, it will probably be best to manually figure out what is the perfect position
    after we create the legend.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，既然我们的甜甜圈中有一个巨大的洞，我们怎么把我们的图例放在一切的中间呢？有时候中间并不是最好看的东西，最好手动找出创建图例后的完美位置。
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We start by removing our shadow, by setting its alpha to `0` and moving our
    pivot point. (I tweaked these numbers after the legend was created until I was
    happy.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过将其alpha设置为`0`并移动我们的枢轴点来移除我们的阴影。（在创建图例后，我调整了这些数字，直到我满意为止。）
- en: 'OK, we are ready to create our legend with the `createLegend` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们准备使用`createLegend`函数创建我们的图例：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have completed a fully fledged doughnut chart with a legend.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了一个带有图例的完整的圆环图。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a pie chart* recipe
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建饼图*配方'
- en: Leveraging a radar
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用雷达
- en: Radars are very misunderstood charts but are really amazing. A radar enables
    us to showcase a really large amount of comparable data in a very condensed way.
    The radar chart is known as a spider chart as well.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 雷达图是非常被误解的图表，但它们真的很棒。雷达使我们能够以非常紧凑的方式展示大量可比较的数据。雷达图也被称为蜘蛛图。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Warning**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: You really need to be friendly with the `Math.cos` and `Math.sin` functions,
    as we are going to use them plenty of times in this chart type. With that said,
    if you don't feel comfortable with them yet, it would be a good idea to start
    from the start of the chapter to refresh your memory on this.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您真的需要熟悉`Math.cos`和`Math.sin`函数，因为我们将在这种图表类型中多次使用它们。也就是说，如果您还不熟悉它们，最好从本章的开头开始，刷新一下您的记忆。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As always, we are going to start with our base HTML page with an `init` callback.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从具有`init`回调的基本HTML页面开始。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Note**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: A radar chart is really a line chart wrapped up into a circular shape with a
    lot of different math involved; but it's the same idea—instead of spreading our
    data horizontally, we are spreading our data around a center point.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 雷达图实际上是一个线图，包裹在一个圆形中，涉及了很多不同的数学；但它的想法是一样的——我们不是将我们的数据水平展开，而是将我们的数据围绕一个中心点展开。
- en: '![Getting ready](img/3707OT_04_04.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/3707OT_04_04.jpg)'
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see what are the steps involved in creating a radar chart:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建雷达图涉及哪些步骤：
- en: 'Create/Organize the chart data and the actual data:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建/组织图表数据和实际数据：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add a few helper variables and an `init` function:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些辅助变量和一个`init`函数：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now it is time to create the `createSpider` function:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是创建`createSpider`函数的时候了：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We split the creation of the radar web into two stages. The first is the lines
    coming out of the center of the web and the other is the actual webs that loop
    around this center point. Let''s start with the first step and continue to the
    next part in the second loop:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将雷达网的创建分为两个阶段。第一个是从网的中心出来的线，另一个是围绕这个中心点循环的实际网。让我们从第一步开始，然后在第二个循环中继续下一部分：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now it''s time to integrate our data:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候整合我们的数据了：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Congratulations, you have just created a radar/spider chart.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您刚创造了一个雷达/蜘蛛图。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The radar chart is one of our more complicated chart types. So far it uses a
    lot of cos/sin functions, but the logic is very consistent and as such relatively
    simple.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 雷达图是我们更复杂的图表类型之一。到目前为止，它使用了很多cos/sin函数，但逻辑非常一致，因此相对简单。
- en: 'Let''s take a deeper look into the `drawWeb` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解`drawWeb`方法：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We start by creating a few helper variables and repositioning our pivot point
    to the center of the screen to help us with our calculations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一些辅助变量，并重新定位我们的枢轴点到屏幕中心，以帮助我们进行计算。
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We then create our spikes based on the number of courses, as each course will
    be represented with a spike.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据课程数量创建我们的尖峰，因为每门课程都将用一个尖峰表示。
- en: 'It''s time to create the interwebs of our spider web now that we have our core
    building blocks (the spikes):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的蜘蛛网的互联网了，现在我们有了我们的核心构建块（尖峰）：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this multidimensional loop, we are running through step by step to draw lines
    from one dot on a circle to the next (from one spike point to the next), growing
    our radius each time we are done with creating a complete shape. Each shape we
    create here represents a growth by 10 in the students' score, as our students
    can only have scores between 0 and 100\. We can ignore extreme cases in this sample.
    (You might need to adjust this code if your data range doesn't start at 0.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个多维循环中，我们逐步从一个圆上的一个点画线到下一个点（从一个尖峰点到下一个点），每次完成创建一个完整的形状时，我们的半径都会增长。我们在这里创建的每个形状代表学生分数增加了10分，因为我们的学生只能在0到100分之间得分。在这个示例中，我们可以忽略极端情况。（如果您的数据范围不是从0开始，您可能需要调整此代码。）
- en: While our `drawDataWeb` method changes, the radius based on the score assumes
    a range of 0 to 100\. (If your ranges are not the same, you will need to modify
    this code, or modify your data sets to be between 0 and 100 when sent to the method.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的`drawDataWeb`方法会改变基于分数的半径，假设范围是0到100。（如果您的范围不同，您将需要修改此代码，或者在发送到该方法时修改您的数据集为0到100之间。）
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Our radar isn't perfect as it could use a legend and some textual information
    around our radar so that we know what each bar represents. We will let you sort
    out a legend as we've done in the previous recipe *Using a doughnut chart to show
    relationships*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的雷达并不完美，因为它可能需要一个图例和一些文本信息围绕我们的雷达，以便我们知道每个条形代表什么。我们将让您像在前面的配方*使用圆环图显示关系*中所做的那样整理一个图例。
- en: Adding a rotated legend
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加旋转的图例
- en: 'To fix this issue and add our text, we will revisit our function `drawWeb`
    with our first loop in that function, and instead of updating the cos/sin values
    to find the rotation, we will just rotate our canvas and integrate our text at
    the edge each time:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并添加我们的文本，我们将重新访问我们的`drawWeb`函数，通过该函数中的第一个循环，而不是更新cos/sin值来找到旋转，我们将只是旋转我们的画布，并在每次边缘集成我们的文本：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The logic here is a bit simpler as we are just rotating our canvas each time
    and using the exact same code over and over until the rotation comes to a full
    circle.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑要简单一些，因为我们每次只是旋转我们的画布，并且一遍又一遍地使用完全相同的代码，直到旋转完成一个完整的圆。
- en: Structuring a tree chart
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建树状图
- en: There are many types of trees in the virtual world, although the most intuitive
    one is a family tree. A family tree is a bit more complex than a basic data tree
    such as a class inheritance tree, as for the most part classes have only one parent
    while family trees usually have two.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟世界中有许多类型的树，尽管最直观的是家谱树。家谱树比基本数据树（如类继承树）更复杂，因为大多数情况下，类只有一个父类，而家谱树通常有两个。
- en: We will build an inheritance tree for the display objects of ActionScript 3.0.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为ActionScript 3.0的显示对象构建一个继承树。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Please note that this sample is cutting edge in HTML5\. One of the new features
    that no one really knows whether will get adopted or not is E4X. It's been embraced
    by Firefox, but not all browsers have implemented it (it is fully supported in
    Flash as well).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个示例在HTML5中是尖端的。一个新功能，没有人真正知道是否会被采用的是E4X。它已经被Firefox采用，但并非所有浏览器都实现了它（Flash也完全支持）。
- en: '**ECMAScript for XML** (**E4X**) is a programming language extension that adds
    native XML support to ECMAScript. It has replaced the DOM interface and is implemented
    as a primitive (such as numbers and Booleans), making it faster and more optimized.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECMAScript for XML**（**E4X**）是一种编程语言扩展，它为ECMAScript添加了本机XML支持。它已经取代了DOM接口，并作为原语（如数字和布尔值）实现，使其更快速和更优化。'
- en: As we are mainly working locally, we are going to save our XML document directly
    in our JavaScript to avoid sandbox security issues.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们主要在本地工作，我们将直接在JavaScript中保存我们的XML文档，以避免沙盒安全问题。
- en: To help us space out our elements, we will make our canvas area much larger
    in this sample (800 x 400). Alright, let's start implementing our tree sample
    created with E4X.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们分隔元素，我们将在此示例中将我们的画布区域扩大（800 x 400）。好了，让我们开始实现使用E4X创建的树示例。
- en: '![Getting ready](img/3707OT_04_05.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/3707OT_04_05.jpg)'
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We will start by creating our XML object that contains our class tree (please
    note that this will only work on an up-to-date version of Firefox as at the time
    of this book being written):'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建包含我们类树的XML对象（请注意，这只适用于Firefox的最新版本，因为在撰写本书时）：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then create our standard helper and styling objects:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建我们的标准辅助和样式对象：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will implement our `init` function and then call the `drawTree` function:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实现我们的`init`函数，然后调用`drawTree`函数：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Time to implement the `drawTree` function (our recursive function):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候实现`drawTree`函数了（我们的递归函数）。
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tah Dah! We just created our first tree.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 塔达！我们刚刚创建了我们的第一个树。
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For more information on how E4X works, I recommend checking out some online
    resources such as [http://goo.gl/jLWYd](http://goo.gl/jLWYd) and [http://goo.gl/dsHD4](http://goo.gl/dsHD4).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有关E4X工作原理的更多信息，我建议查看一些在线资源，如[http://goo.gl/jLWYd](http://goo.gl/jLWYd)和[http://goo.gl/dsHD4](http://goo.gl/dsHD4)。
- en: Let's take a deeper look at how our recursive `drawTree` works. The basic idea
    of `createTree` is to create the current node in focus and to check if the node
    has children; if it does, to send them to the `drawTree` and have them recursively
    continue until all the children are created and done. One of the most critical
    things you need to worry about when creating a recursive function (a function
    that calls itself) is to make sure that it doesn't end up being endless, and as
    our scenario has a very defined end that is based on the XML structure, we are
    safe.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下我们的递归`drawTree`是如何工作的。`createTree`的基本思想是创建当前焦点节点，并检查节点是否有子节点；如果有，将它们发送到`drawTree`并让它们递归继续，直到所有子节点都创建完成。创建递归函数（调用自身的函数）时，最关键的一点是确保它不会无休止地进行下去，而我们的情景有一个非常明确定义的基于XML结构的结束，所以是安全的。
- en: 'We start by creating the current node in focus, based on the point values that
    were sent over in our function''s parameters:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先根据函数参数中发送的点值创建当前焦点节点：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Right after these lines is where it starts getting really interesting. If our
    node is complex, we are going to assume that it has children, as that''s our base
    rule in creating our XML object; and if so, it''s time for us to draw the children:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行之后，事情开始变得真正有趣。如果我们的节点很复杂，我们将假设它有子节点，因为这是我们创建XML对象的基本规则；如果是这样，那么现在是时候为我们绘制子节点了：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We start by drawing a visualizer bar to help us see what the children of the
    current element are, and create a few helper variables in the process:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先绘制一个可视化条，以帮助我们查看当前元素的子元素，并在此过程中创建一些辅助变量：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After creating our outline helper lines, it''s time for us to loop through
    the children and send them to `drawTree` with their new positions:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的轮廓辅助线之后，是时候循环遍历子节点并将它们发送到`drawTree`以获得它们的新位置了：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That covers all the logic. At this stage, the logic will start all over again
    for each element, one at a time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了所有的逻辑。在这个阶段，逻辑将为每个元素重新开始。
- en: There's more...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In a perfect world our work with our tree would be done by now, but many a
    time in real-world scenarios we would encounter issues. If we play with our current
    tree enough, we will discover visual issues, such as if a child node has more
    than one child, its children will overlap the other tree branches. For example,
    if we update our `Loader` class to have two new children (two dummy classes just
    for the sake of our example):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，我们的树的工作现在应该已经完成了，但在现实世界的情况下，我们经常会遇到问题。如果我们足够玩弄我们当前的树，我们会发现视觉问题，比如如果一个子节点有多个子节点，它的子节点将重叠在其他树枝上。例如，如果我们更新我们的`Loader`类以拥有两个新的子节点（这只是为了我们的示例而创建的两个虚拟类）：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you refresh your browser (currently only Firefox), you will see that our
    elements are overlapping as we didn't take into account the option of children
    that have children. If we review our code more deeply, we will see that in the
    current logic format there is no way to solve the problem as the creation of the
    children is happening separately. We will need to figure out a way to manage lines
    so that our elements will have a way to know that they are about to overlap.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新浏览器（目前仅限Firefox），您会发现我们的元素重叠在一起，因为我们没有考虑到具有子元素的选项。如果我们更深入地审查我们的代码，我们会发现在当前的逻辑格式中，没有办法解决这个问题，因为子元素的创建是分开进行的。我们需要想出一种方法来管理行，这样我们的元素就会知道它们即将重叠。
- en: 'To solve this problem, we will need to make our recursive function more complex,
    as it will need to keep track of its children''s x position so that it can offset
    whenever there is an overlap. Please review the modified code (changes marked
    in bold):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要使我们的递归函数更复杂，因为它需要跟踪其子元素的x位置，以便在重叠时进行偏移。请查看修改后的代码（更改用粗体标记）：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Wow that looks complicated—it's because it is! So let's break the logic down.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，看起来很复杂——因为它确实很复杂！所以让我们分解这个逻辑。
- en: The idea is simple, but as for every simple idea, sometimes it's harder to visualize
    after it's implemented. The idea is that every time we create a new tree element,
    we will return `0` if it has no children, and if it has children, we will send
    back the next free position for future children. We added a fourth parameter to
    the function as well, and we sent that information each time we looped through
    children. That way each child is aware of where the last child left off. If an
    element's real position can't be worked out, we draw a redirect line as per the
    amount of the offset and update `startXPoint`. Take a deeper look at this (so
    far my favorite code in the cookbook), which was fun to figure out!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单，但对于每个简单的想法来说，有时在实施后很难可视化。这个想法是，每当我们创建一个新的树元素时，如果它没有子元素，我们将返回`0`，如果它有子元素，我们将为未来的子元素发送下一个空闲位置。我们还向函数添加了第四个参数，并且每次循环遍历子元素时都发送了该信息。这样每个子元素都知道上一个子元素离开的位置。如果无法计算出元素的实际位置，我们将根据偏移量绘制重定向线，并更新`startXPoint`。深入研究一下这个（到目前为止，这是我在食谱中最喜欢的代码），这很有趣！
