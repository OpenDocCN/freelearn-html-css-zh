- en: Chapter 5. Getting Out of the Box
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章.走出常规
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Going though a funnel (a pyramid chart)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过漏斗（金字塔图表）
- en: 'Revisiting lines: making the line chart interactive'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视线条：使线状图表具有交互性
- en: Tree mapping and recursiveness
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树状映射和递归
- en: Adding user interaction into tree mapping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户交互添加到树状映射中
- en: Making an interactive click meter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个交互式点击计数器
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We have covered our bases with the majority of the standard charts. At this
    stage, it's time for us to become more creative with our charts. From this chapter
    onwards, we will progress into more out-of-the-box, less commonly used charts
    and revisit some of our old charts to incorporate dynamic data into them or to
    change their layout.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了大多数标准图表的基础知识。在这个阶段，是时候让我们的图表变得更有创意了。从本章开始，我们将进入更具创意的、不常用的图表，并重新审视一些旧图表，将动态数据整合到它们中，或者改变它们的布局。
- en: Going through a funnel (a pyramid chart)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过漏斗（金字塔图表）
- en: It's rare that you see a pyramid chart that is actually created dynamically.
    For the most part, they're designed and fleshed out creatively and turn into a
    `.jpg` file when they reach the web, and that's exactly why I wanted to start
    this chapter with this chart—it's not as complex as it might sound.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很少见到动态创建的金字塔图表。在大多数情况下，它们是在设计和创意上进行完善，当它们到达网络时变成一个.jpg文件，这正是我想以这个图表开始这一章的原因——它并不像听起来那么复杂。
- en: '![Going through a funnel (a pyramid chart)](img/3707OT_05_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![通过漏斗（金字塔图表）](img/3707OT_05_01.jpg)'
- en: A pyramid chart is in essence a way for us to visualize changes in data that
    are quantitative by nature. They have a clear relationship between the lower layers
    and the higher layers. That sounded very vague, so let's explain it through an
    example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔图表本质上是一种让我们可视化数据变化的方式，这些数据本质上是定量的。它们在较低层和较高层之间有明确的关系。听起来很模糊，所以让我们通过一个例子来解释。
- en: Imagine that X amount of people complete their eighth year of school in a given
    year, if we follow the same group of people, how many of them would have completed
    their twelfth year of education four years later? Fair enough! We can't know the
    answer to that, but one thing we do know is that it can't be more than the initial
    X amount of people. The idea of a pyramid chart is exactly that of a body of data,
    of which less and less goes through the funnel as time or something else changes
    It's a really great chart to compare between levels of education, finance, involvement
    in politics, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在某一年有X人完成了他们的第八年学校教育，如果我们跟随同一群人，四年后有多少人完成了他们的第十二年教育？好吧！我们无法知道答案，但我们知道的一件事是，它不可能超过最初的X人数。金字塔图表的概念正是这样一个数据体，随着时间或其他因素的变化，通过漏斗的数据越来越少。这是一个非常好的图表，可以比较教育水平、财务、政治参与等方面的情况。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Just as always, set up our HTML file logic. For a refresher on how to start
    up the HTML file, please go back to the *Graphics with 2D canvas* recipe in [Chapter
    1](ch01.html "Chapter 1. Drawing Shapes in Canvas"), *Drawing Shapes in Canvas*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，设置我们的HTML文件逻辑。如果需要关于如何启动HTML文件的复习，请回到[第1章](ch01.html "第1章.在画布中绘制形状")中的*使用2D画布进行图形处理*。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '如何做... '
- en: Beyond our standard HTML preparation, we need to come up with the data sources
    that we wish to showcase. Let's start building our pyramid. Go right into the
    JS file and let's start.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们标准的HTML准备工作之外，我们需要想出我们希望展示的数据来源。让我们开始建立我们的金字塔。直接进入JS文件，让我们开始吧。
- en: For our example, we will create a pyramid to find out how many people that read
    this book from chapter one through chapter five actually reach chapter five (this
    data is fake; I hope everyone that starts reading will get there!).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将创建一个金字塔，以找出从第一章到第五章阅读本书的人中实际到达第五章的人数（这些数据是虚构的；我希望每个开始阅读的人都能到达那里！）。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, provide some charting and styling information.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，提供一些图表和样式信息。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, for the first time, we are differentiating between what we want the
    size of our canvas to be and the actual size of our chart (funnel/triangle). Another
    important thing to note is that, for our sample to work in its current format,
    our triangle height and width (base) must be the same.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是我们第一次区分我们希望画布的大小和图表（漏斗/三角形）的实际大小。另一个重要的事情是，为了使我们的示例在当前格式下工作，我们的三角形高度和宽度（底）必须相同。
- en: Define a few global helper variables.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些全局辅助变量。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's time for us to create our `init` function. This function will be doing
    most of the heavy lifting with the help of another function.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的`init`函数了。这个函数将在另一个函数的帮助下承担大部分的工作。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our function performs the normal setup and executes the styling logic and then
    it creates a triangle, after which it finds the right points (by using the `findLine`
    function) at which we should cut the triangle:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的函数执行正常的设置并执行样式逻辑，然后创建一个三角形，然后找到正确的点（使用`findLine`函数）我们应该在哪里切割三角形：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function finds the dots on our triangle based on the data of the current
    line. That's it; now its time to understand what we just did.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数根据当前线的数据找到我们三角形上的点。就是这样；现在是时候理解我们刚刚做了什么了。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After setting the code for lines in the `init` function, we are ready to start
    thinking about our triangle. First, we need to find out the total pixels that
    are within our triangle.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中设置了线条的代码之后，我们准备开始考虑我们的三角形。首先，我们需要找出在我们的三角形内的总像素数。
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That is easy as we know our height and our width, so the formula is really simple.
    The next data point that is critical is the total amount of data. We can create
    a relationship between the pixels and the data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易，因为我们知道我们的高度和宽度，所以公式非常简单。下一个关键的数据点是总数据量。我们可以创建像素和数据之间的关系。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As such, we loop through all the data layers and calculate the summary of all
    data points. At this stage, we are ready to find out the actual number of pixels.
    Each data element is equivalent to:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们循环遍历所有的数据层，并计算所有数据点的总和。在这个阶段，我们已经准备好找出实际像素的数量。每个数据元素相当于：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After setting up the styles for our stroke and fill, we stop to think about
    the best translation that would help us build our triangle. For our triangle,
    I''ve picked the top edge to be the `0,0` point, after creating the triangle:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了我们的描边和填充样式后，我们停下来考虑哪种最好的转换方式可以帮助我们构建我们的三角形。对于我们的三角形，我选择了顶边作为`0,0`点，创建了三角形后：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last two lines of our `init` function call the `findLine` method for each
    element in our `layers` array:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`init`函数的最后两行调用`layers`数组中每个元素的`findLine`方法：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Time to dig into how the `findLine` function actually finds the points to create
    the lines. The idea is very simple. The basic idea is to try to find out how many
    lines it would take to complete the number of pixels in a triangle. As we are
    not building a math formula, we don't care if it's 100 percent accurate, but it
    should be accurate enough to work visually.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入了解`findLine`函数是如何找到创建线的点的。这个想法非常简单。基本思想是尝试找出完成三角形中像素数量需要多少条线。由于我们不是在建立数学公式，我们不在乎它是否100%准确，但它应该足够准确以在视觉上工作。
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's start with introducing color into our pallet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始向我们的调色板引入颜色。
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: OK, we are done with the easy part. Now, it's time to rework our logic.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们完成了简单的部分。现在，是时候重新调整我们的逻辑了。
- en: Making findLine smarter
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使`findLine`更智能
- en: 'For us to be able to create a closed shape, we need to have a way to change
    the direction of the line drawn from right to left or from left to right and not
    have it go in one direction always. Beyond that, we are using `moveTo` right now
    and as such can never create a closed shape. What we actually want is to move
    our point and draw a line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够创建一个封闭的形状，我们需要有一种改变绘制线的方向的方法，从右到左或从左到右，而不是让它总是朝一个方向。除此之外，我们现在正在使用`moveTo`，因此永远无法创建一个封闭的形状。我们实际上想要的是移动我们的点并绘制一条线：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our next problem is that we don't want to change the actual triangle height
    as we will be calling this function more times than we did in the past. To come
    up with a plan for this problem, we need to extract some of the logic. We will
    return the new number of lines that were created, so that we can remove them externally
    from the triangle. This action enables us to have more finite control over visuals
    (a thing that will be important when we incorporate text).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个问题是，我们不想改变实际的三角形高度，因为我们将调用这个函数的次数比过去多。为了解决这个问题，我们需要提取一些逻辑。我们将返回创建的新线的数量，这样我们就可以从三角形中外部删除它们。这个操作使我们对视觉有更精细的控制（当我们加入文本时这一点将很重要）。
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this stage, our `findLine` function is really smart and is capable of helping
    us to create closed shapes without controlling more than it needs to control (as
    it isn't changing any of our global data).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的`findLine`函数非常智能，能够帮助我们创建封闭的形状，而不需要控制更多（因为它不会改变任何全局数据）。
- en: Changing the logic in init to create shapes
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改`init`中的逻辑以创建形状
- en: Now that we have a smart `findLine` function, it's time for us to rewrite our
    logic related to drawing lines in the `init` function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个智能的`findLine`函数，是时候重新编写与在`init`函数中绘制线相关的逻辑了。
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, we draw all elements in our loop, minus the last one (as our last element
    is actually a triangle and not a line). Then, to help us hide our mathematical
    inaccuracy, we create a new path each time our loop starts and call our `findLine`
    function first with no new data (drawing a line in the last place where it drew
    a line as there is no data) and then drawing a second line, this time with the
    real new data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在循环中绘制所有元素，减去最后一个（因为我们的最后一个元素实际上是一个三角形而不是一条线）。然后，为了帮助我们隐藏我们的数学不准确性，每次循环开始时我们都创建一个新路径，并首先调用我们的`findLine`函数，没有新数据（在上次绘制线的地方绘制线，因为没有数据），然后绘制第二条线，这次使用真实的新数据。
- en: Our exception to the rule is created out of the loop, and there, we just manually
    draw our shape, starting with the last line, and add the `0,0` point into it,
    over our triangle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对规则的例外是在循环之外创建的，在那里，我们只是手动绘制我们的形状，从最后一行开始，并将`0,0`点添加到它上面，覆盖我们的三角形。
- en: Adding text into our graph
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文本添加到我们的图表中
- en: 'This one will be simple, as we are already getting back the line count before
    we resize our triangle. We can use this data to calculate where we want to position
    our textfield variable, so let''s do it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将很简单，因为我们在调整三角形大小之前已经得到了线数。我们可以使用这些数据来计算我们想要定位文本字段变量的位置，所以让我们做吧：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Just see the difference between drawing our text in the loop and out of it.
    As we don't get new line data out of the loop, we need to change the point logic
    by using the total size of our leftover triangle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只需看一下在循环中绘制文本和在循环外绘制文本之间的区别。由于我们在循环中没有获取新的行数据，我们需要通过使用剩余三角形的总大小来改变点逻辑。
- en: 'Revisiting lines: making the line chart interactive'
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温线条：使线图表交互
- en: In this recipe, we will travel back in time to one of our earlier recipes, *Building
    line charts in* [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based Graphs"),
    *Creating Cartesian-based Graphs* and add some user control to it. This control
    enables the user to turn on and off the streams of data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将回到我们早期的一个食谱，*在[第3章](ch03.html "第3章。创建基于笛卡尔的图表")*中创建基于笛卡尔的图表，并为其添加一些用户控制。这个控制使用户能够打开和关闭数据流。
- en: '![Revisiting lines: making the line chart interactive](img/3707OT_05_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![重温线条：使线图表交互](img/3707OT_05_02.jpg)'
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first step that you will need to take is to grab the source code from [Chapter
    3](ch03.html "Chapter 3. Creating Cartesian-based Graphs"), *Creating Cartesian-based
    Graphs*. We will rename `03.05.line-revamp.html` and `03.05.line-revamp.js` to
    `05.02.line-revisit`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要采取的第一步是从[第3章](ch03.html "第3章。创建基于笛卡尔坐标的图表")*创建基于笛卡尔坐标的图表*中获取源代码。我们将`03.05.line-revamp.html`和`03.05.line-revamp.js`重命名为`05.02.line-revisit`。
- en: Now that we have our files up to date, add our HTML file—three radio groups
    to represent the three data sources (years 2009, 2010, and 2011).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的文件已经更新，添加我们的HTML文件——三个单选按钮组来表示三个数据源（2009年、2010年和2011年）。
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that I've named each radio group with "i" added to the year and set the
    possible values to be `-1`, `0`, or `1`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经为每个单选按钮组添加了“i”以表示年份，并将可能的值设置为“-1”、“0”或“1”。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a few constants (well, variables that are not going to change), and
    set the following three lines, now that the default values have already been assigned:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些常量（不会更改的变量），并设置以下三行，现在默认值已经分配：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Time to move the logic of creating the chart into a separate function. Everything
    after the initalization of our canvas is going to be moved out.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将创建图表的逻辑移到一个单独的函数中。在初始化画布之后的所有内容都将被移出。
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Update the radio boxes to highlight whatever is currently selected and to add
    the `onchange` events to all radio buttons.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新单选框以突出显示当前选定的内容，并为所有单选按钮添加`onchange`事件。
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make some updates in our `drawChart` function. Our goal is to incorporate the
    new controller `elementStatus` into the drawing of lines.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`drawChart`函数中进行一些更新。我们的目标是将新的控制器`elementStatus`纳入线条的绘制中。
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Last but not least, let's add the logic into our `onChangedRadio` function.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，让我们将逻辑添加到我们的`onChangedRadio`函数中。
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's it! We just added user interaction into our chart.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们刚刚在图表中添加了用户交互。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We haven''t planned for user interaction on this chart in advance. As such,
    we need to revisit it to change some of the logic. When Canvas draws something,
    that''s it, it''s there forever! We can''t just delete an object, as there are
    no objects in Canvas, and as such, we need a way to redraw on demand. To accomplish
    that, we need to extract all the drawing logic from the `init` function and create
    the `drawChart` function. Besides adding our logic to the end of the function,
    we also need to add the start of the function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有提前计划在此图表上进行用户交互。因此，我们需要重新审视它以更改一些逻辑。当Canvas绘制某物时，就是这样，它将永远存在！我们不能只删除一个对象，因为Canvas中没有对象，因此我们需要一种按需重新绘制的方法。为了实现这一点，我们需要从`init`函数中提取所有绘图逻辑，并创建`drawChart`函数。除了在函数末尾添加我们的逻辑之外，我们还需要添加函数的开始部分：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although we originally worked out the default to use as the width for our background,
    in a second redraw, our canvas would still have stored its last size (in our case
    it could be `3`), and as such, we reset it to the original value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们最初计算出用作背景宽度的默认值，在第二次重绘中，我们的画布仍然会保留其上次的大小（在我们的情况下可能是`3`），因此我们将其重置为原始值。
- en: 'We are using an object called `elementStatus` to store the current status of
    each line on our chart. The values it can store are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`elementStatus`的对象来存储图表上每条线的当前状态。它可以存储的值如下：
- en: '`-1`: Do not draw'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1`：不绘制'
- en: '`0`: Draw a line with no fill'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：绘制无填充的线'
- en: '`1`: Draw a fill'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：绘制填充'
- en: 'As such, we are adding the following logic into the end of our function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在函数末尾添加以下逻辑：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As the logic repeats three times, let's just focus on one of them. If we want,
    we can use our constant variables to make the logic easier to view.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逻辑重复三次，让我们只关注其中一个。如果愿意，我们可以使用我们的常量变量使逻辑更容易查看。
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The logic breaks down into a first `if` statement, testing to see if our content
    should be hidden. If we establish that this line should be added, we draw it by
    sending into the fill/line parameter the outcome of comparing our current value
    to `FILL_ELEMENT`, resulting in two variations based on the outcome of this operation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑分解为第一个`if`语句，测试我们的内容是否应该隐藏。如果我们确定应该添加这行，我们通过将当前值与`FILL_ELEMENT`进行比较的结果发送到填充/线参数中来绘制它，根据此操作的结果有两种变化。
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unfortunately, because we are not using any open source library, the built-in
    HTML capabilities don't allow us to set events to groups of radios, and as such,
    we need to find them all and add the `onchange` event to them using the IDs we
    are storing in our `elementStatus` controller.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，因为我们没有使用任何开源库，内置的HTML功能不允许我们为单选按钮组设置事件，因此我们需要找到它们并使用我们在`elementStatus`控制器中存储的ID为它们添加`onchange`事件。
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Pay attention to the highlighted code. Here, we are checking to see whether
    our current radio button's value matches our element value in `elementStatus`.
    If it does, it means that the radio button will be selected.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意高亮显示的代码。在这里，我们正在检查当前单选按钮的值是否与`elementStatus`中的元素值匹配。如果是，这意味着单选按钮将被选中。
- en: Breaking down the logic of onChangedRadio
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解onChangedRadio的逻辑
- en: 'Let''s take another peek at the logic in this function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看看这个函数中的逻辑：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first thing we do is save the newly selected value into our `elementStatus`
    controller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是将新选择的值保存到我们的“elementStatus”控制器中。
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We follow that by deleting everything from our canvas.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们清空画布上的所有内容。
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, wipe the slate clean and start with a new path.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，清空并开始一个新路径。
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And... you guessed it... Then start drawing everything all over, and our new
    parameter in `elementStatus` will validate that the right things will be drawn.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后开始重新绘制所有内容，我们在`elementStatus`中的新参数将验证正确的内容将被绘制。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Building line charts* recipe in [Chapter 3](ch03.html "Chapter 3. Creating
    Cartesian-based Graphs"), *Creating Cartesian-based Graphs*
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。创建基于笛卡尔坐标的图表")*创建基于笛卡尔坐标的图表*中的*构建线图*配方'
- en: Tree mapping and recursiveness
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树状映射和递归
- en: Tree mapping enables us to see in-depth data from a bird's-eye view. Contrary
    to comparative charts—such as most of the charts that we have created until now—tree
    mapping displays tree structured data as a set of nested rectangles, enabling
    us to visualize their quantitative nature and relationship.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 树状映射使我们能够从鸟瞰视角深入了解数据。与比较图表相反——例如我们到目前为止创建的大多数图表——树状映射将树状结构的数据显示为一组嵌套的矩形，使我们能够可视化它们的数量特性和关系。
- en: '![Tree mapping and recursiveness](img/3707OT_05_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![树状映射和递归](img/3707OT_05_03.jpg)'
- en: Let's start with a tree mapping that showcases only one level of information.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从仅展示一级信息的树状映射开始。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start our application with the number of people in the world, in millions,
    divided by continent (based on public data from 2011).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从世界上的人数开始我们的应用程序，以百万为单位，按大陆划分（基于2011年的公共数据）。
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will update this data source later in our example, so keep in mind that this
    dataset is temporary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的示例中稍后更新这个数据源，所以请记住这个数据集是临时的。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will start by creating a simple, working, flat tree chart. Let''s jump right
    into it and figure out the steps involved in creating the tree map:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个简单的、工作的、平面树状图开始。让我们直接开始，找出创建树状图所涉及的步骤：
- en: Let's add a few helper variables on top of our dataset.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在数据集的顶部添加一些辅助变量。
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create the `init` function.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`init`函数。
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Create the function `drawTreeMap`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数`drawTreeMap`。
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create a few formatting functions to help us create a random color for our tree
    map block.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些格式化函数来帮助我们为我们的树状映射块创建一个随机颜色。
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is a bit of overkill in the creation of so many formatting functions;
    their main goal is to help us when we are ready for the next step—to create more
    depth in our data (refer to the *There's more...* section in this recipe for more
    details).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这么多格式化函数时有点过度，它们的主要目标是在我们准备进行下一步时帮助我们——在我们的数据中创建更多深度（有关更多细节，请参阅本食谱中的*还有更多...*部分）。
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start with the initial idea. Our goal is to create a map that will showcase
    the bigger volume areas inside our rectangular area and leave a strip on the side
    for the smaller areas. So, let''s start with our `init` function. Our first task
    beyond our basic getting started work is to calculate the actual total. We do
    that by looping through our data source, thus:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最初的想法开始。我们的目标是创建一个地图，展示我们矩形区域内更大的体积区域，并在一侧留下一条条带以展示较小的区域。所以，让我们从我们的`init`函数开始。我们的基本入门工作之外的第一个任务是计算实际总数。我们通过循环遍历我们的数据源来做到这一点，因此：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We continued with some playing around with the design and making our work area
    10 pixels smaller than our total canvas size.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续设计一些东西，并且让我们的工作区比总画布大小小10像素。
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It's time to take a look into how our `drawTreeMap` function works. The first
    thing to notice is that we send in an array instead of working directly with our
    data source. We do that because we want to be open to the idea that this function
    will be re-used when we start building the inner depths of this visualization
    type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候来看看我们的`drawTreeMap`函数是如何工作的了。首先要注意的是，我们发送一个数组而不是直接使用我们的数据源。我们这样做是因为我们希望这个函数在我们开始构建这种可视化类型的内部深度时可以被重复使用。
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start our function with a few helper variables (the `percent` variable will
    store the current `percent` value in a loop). The `cx` (the current x) position
    of our rectangle and `rollingPercent` will keep track of how much of our total
    chart has been completed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数从几个辅助变量开始（`percent`变量将存储循环中的当前`percent`值）。我们的矩形的`cx`（当前x）位置和`rollingPercent`将跟踪我们的总图表完成了多少。
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Time to start looping through our data and drawing out the rectangles.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始循环遍历我们的数据并绘制出矩形了。
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Before we complete our first loop, we will test it to see when we cross our
    threshold (you are welcome to play with that value). When we reach it, we need
    to stop the loop, so that we can start drawing our rectangles by height instead
    of by width.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成第一个循环之前，我们将测试它，看看我们何时越过我们的阈值（欢迎您调整该值）。当我们达到它时，我们需要停止循环，这样我们就可以开始按高度而不是宽度绘制我们的矩形。
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Before we start working on our boxes, which take the full leftover width and
    expand to the height, we need a few helper variables.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理我们的框之前，它们占据了全部剩余的宽度并扩展到高度，我们需要一些辅助变量。
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As we need to calculate each element from now on based on the amount of space
    left, we will figure out the value (`leftOverPercent`), and then we will extract
    the remaining width of our shape and start up a new `cy` variable to store the
    current y position.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们需要根据剩余空间的大小计算每个元素，我们将计算值（`leftOverPercent`），然后我们将提取我们形状的剩余宽度，并启动一个新的`cy`变量来存储当前的y位置。
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We start our loop with one value higher than what we left off (as we broke out
    of our earlier loop before we had a chance to update its value and draw to the
    height of our remaining area.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从比我们离开的值高一个值开始我们的循环（因为我们在之前的循环中打破了它之前，我们没有机会更新它的值并绘制到我们剩余区域的高度。
- en: Note that in both loops we are using `formatColorObject` and `getRandomColor`.
    The breakdown of these functions was created so that we can have an easier way
    to manipulate the colors returned in our next part.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在两个循环中我们都使用了`formatColorObject`和`getRandomColor`。这些函数的分解是为了让我们在下一部分中更容易操纵返回的颜色。
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'For our chart to really have that extra kick, we need to have a way to make
    it capable of showing data in at least a second lower-level details of data. To
    do that, we will revisit our data source and re-edit it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的图表真正具有额外的功能，我们需要一种方法来使它能够以至少第二个较低级别的数据显示数据的方式。为此，我们将重新审视我们的数据源并对其进行重新编辑：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we have two regions of the world with a more in-depth view of their subregions.
    It's time for us to start modifying our code, so that it will work again with
    this new data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了世界上两个地区的更深入的子地区的视图。是时候修改我们的代码，使其能够再次处理这些新数据了。
- en: Updating the init function – recalculating the total
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新`init`函数——重新计算总数
- en: The first step we need to carry out in the `init` function is to replace the
    current total loop with a new one that can dig deeper into elements to count the
    real total.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，我们需要执行的第一步是用一个新的循环替换当前的总循环，这个新循环可以深入到元素中计算真正的总数。
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In essence, we are checking to see whether there is no total and whether there
    is a data source. If that is the case, we start a new loop to calculate the actual
    total for our elements—a good exercise for you now would be to try to make this
    logic into a recursive function (so that you can have more layers of data).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们正在检查是否没有总数，以及是否有数据源。如果是这样，我们就开始一个新的循环来计算我们元素的实际总数——现在您可以尝试将这个逻辑变成一个递归函数（这样您就可以有更多层的数据）。
- en: Next, we will change `drawTreeMap` and get it ready to become a recursive function.
    To make that happen, we need to extract the global variables from it and send
    them in as parameters of the function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改`drawTreeMap`并准备将其变成一个递归函数。为了实现这一点，我们需要从中提取全局变量，并将它们作为函数的参数发送。
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Turning drawTreeMap into a recursive function
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将drawTreeMap转换为递归函数
- en: Let's update our function to enable recursive operations. We start by adding
    an extra new parameter to capture the latest color.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的函数以启用递归操作。我们首先添加一个额外的新参数来捕获最新的颜色。
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we pass a `clr` parameter, we need to keep that color throughout all the
    new rectangles that will be created, and we need to add a padding around the shapes
    so that it becomes easier to see them. We make the color a bit darker as well
    by subtracting 10 percent of its color on all its RGA properties.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递了一个`clr`参数，我们需要在所有新创建的矩形中保持该颜色，并且我们需要在形状周围添加一些填充，以便更容易看到它们。我们还通过减去其所有RGA属性的10%使颜色变暗一点。
- en: The next stage is to add the padding and recursive logic.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加填充和递归逻辑。
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The same logic is then implemented on the second loop as well (to see it check
    the source files).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑也在第二个循环中实现了（查看源文件以了解详情）。
- en: Turning the data and total to recursive data
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据和总数转换为递归数据
- en: Let's start by updating our tree data to be really recursive (for the full dataset
    please refer to the source code).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先更新我们的树数据，使其真正递归（完整数据集请参考源代码）。
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, with a tree map that has over four levels of information, we can revisit
    our code and finalize our last outstanding issue validating that our total is
    always up-to-date at all levels. To fix that, we will extract the logic of calculating
    the total into a new function and update the `total` line in the `init` function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个具有四个以上信息级别的树状图，我们可以重新审视我们的代码，并解决我们最后的问题，验证我们的总数在所有级别上始终是最新的。为了解决这个问题，我们将计算总数的逻辑提取到一个新函数中，并更新`init`函数中的`total`行。
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Time to create this magical (recursive) function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建这个神奇的（递归）函数了。
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The logic is really similar to what it was, with the exception that all the
    data entries are internal to the function, and each time there is a need to deal
    with another level of data, it's re-sent to the same function (in a recursive
    way) until all data is resolved—until it returns the total.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与以前非常相似，唯一的区别是所有数据条目都是函数内部的，并且每次需要处理另一层数据时，它都会以递归的方式重新发送到同一个函数中，直到所有数据都解析完毕——直到它返回总数。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Adding user interaction into tree mapping* recipe
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将用户交互添加到树映射*教程'
- en: Adding user interaction into tree mapping
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户交互添加到树映射
- en: Until now, we have limited our user interaction with our samples. In one of
    our last samples, we added a controlled way to add and remove chart elements;
    in this one, we will enable the user to dig deeper into the chart and see more
    details by creating a truly endless experience (if we only had an endless amount
    of data to dig into).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在示例中限制了用户的交互。在我们最后的一个示例中，我们以一种受控的方式添加和删除图表元素；在这个示例中，我们将使用户能够深入图表并通过创建一个真正无尽的体验来查看更多细节（如果我们只有无尽的数据可以挖掘）。
- en: In the following image, on the left-hand side, you can see the initial state
    and what happens after one click of the user (the chart redraws itself to showcase
    the area that was clicked on).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，左侧是初始状态，右侧是用户点击一次后的状态（图表重新绘制以展示被点击的区域）。
- en: '![Adding user interaction into tree mapping](img/3707OT_05_04.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![将用户交互添加到树映射](img/3707OT_05_04.jpg)'
- en: Consider the case when the user clicks on the chart (for example, the next picture
    is generated by clicking on the left-hand side rectangle—the tree map will update
    and zoom into that area).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当用户点击图表时的情况（例如，点击左侧矩形后生成的下一张图片——树状图将更新并放大到该区域）。
- en: '![Adding user interaction into tree mapping](img/3707OT_05_05.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![将用户交互添加到树映射](img/3707OT_05_05.jpg)'
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get this sample right, you will need to start from our last recipe, *Tree
    maping and recursiveness*, and adjust it to work for this sample.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确使用这个示例，您需要从我们上一个教程*树映射和递归*开始，并调整它以适应这个示例。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This is our first sample where we make our canvas area interactive. In the
    next few steps, we will add some logic from the last sample into our recipe, to
    enable the user to zoom into or out of it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个示例，我们使我们的画布区域具有交互性。在接下来的几步中，我们将从上一个示例中添加一些逻辑到我们的教程中，以使用户能够放大或缩小它：
- en: Add a new global variable,
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新增一个全局变量，
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Store the current data that is sent to the tree mapping function.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储发送到树映射函数的当前数据。
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Add a `click` event to our canvas area.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的画布区域添加一个`click`事件。
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Create the `onTreeClick` event.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`onTreeClick`事件。
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Draw a rectangle twice—within `drawTreemap`—for the first time in the first
    loop and again in the second loop. Let''s replace it with an external function—replace
    both the `for` loop lines to draw a rectangle with:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`drawTreemap`中两次绘制矩形——第一次在第一个循环中，第二次在第二个循环中。让我们用一个外部函数来替换它——替换绘制矩形的`for`循环行：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Time to create the rectangle function.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建矩形函数了。
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There you go! We have a fully functional, deep-level, endless interaction with
    the user (just dependent on how much data we have).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们有一个完全功能的、深层次的、与用户无限交互的图表（只取决于我们有多少数据）。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Canvas element doesn't currently support a smart way to interact with objects.
    As there are no objects in the canvas, as soon as you create the element it tunes
    into a bitmap and its information is removed from memory. Luckily for us, our
    sample is constructed out of rectangles, making it much easier to recognize when
    our element is clicked on. We will need to store in memory the current box location
    of each element that we draw.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas元素目前不支持与对象交互的智能方式。由于画布中没有对象，一旦创建元素，它就会变成位图，并且其信息将从内存中删除。幸运的是，我们的示例是由矩形构成的，这样就更容易识别我们点击的元素。我们需要在内存中存储我们绘制的每个元素的当前框位置。
- en: 'As such, our first step of logic is the last thing that we did in our procedure
    (in step 6). We want to capture the points that construct our rectangles, so then
    in our `click` event we can figure out where our dot is in relation to the rectangle:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们逻辑的第一步是我们在步骤6中做的最后一件事。我们想捕获构成我们矩形的点，这样在我们的`click`事件中，我们就可以弄清楚我们的点与矩形的关系：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We loop through our data source (current one) and check to see whether the element
    we are currently in has a data source (that is, children); if it does, we continue,
    and if not, we will skip to the next element to test it as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环遍历我们的数据源（当前的数据源），并检查我们当前所在的元素是否有数据源（即子元素）；如果有，我们继续，如果没有，我们将跳过下一个元素来测试它。
- en: Now that we know our element has children, we are ready to see if our dot is
    in the range of our element.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的元素有子元素，我们准备看看我们的点是否在元素的范围内。
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If it is, we are ready to redraw the tree map and replace our current dataset
    with the current deeper dataset.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是，我们准备重新绘制树状图，并用当前更深的数据集替换我们当前的数据集。
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We then exit from the loop (by using a `break` statement). Please note that
    the last thing we do is update `currentDataset`, as we still need information
    from it to send the total data into `drawTreeMap`. When we have finished using
    it, we are ready to override it with the new dataset (what were the children before
    turn into our main players for the next round).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们退出循环（使用`break`语句）。请注意，我们做的最后一件事是更新`currentDataset`，因为我们仍然需要从中获取信息以将总数据发送到`drawTreeMap`。当我们使用完它后，我们准备用新的数据集覆盖它（之前的子元素变成了下一轮的主要参与者）。
- en: There's more...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Currently, there is just no way to get back without refreshing everything. So,
    let's add it to our logic that if the user clicks in an element with no children,
    we will revert to the original map.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，没有办法在不刷新一切的情况下返回。因此，让我们添加到我们的逻辑中，如果用户点击没有子元素的元素，我们将恢复到原始地图。
- en: Going back to the main treemap
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到主要的树状图
- en: 'Let''s add the following code into the `click` event:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下代码添加到`click`事件中：
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Fantastically done! We have just finished creating a fully interactive experience
    for our users, and now it's in your hands to make this look a bit better. Add
    some rollover labels and all the visualization that will make your chart visually
    pleasing and will help understanding.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们刚刚完成了为用户创建一个完全互动的体验，现在轮到你来让它看起来更好一些了。添加一些悬停标签和所有可视化效果，这将使您的图表在视觉上更加愉悦，并有助于理解。
- en: Making an interactive click meter
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个交互式点击计量器
- en: In this next example, we will focus on one more powerful feature of any client-side
    programming—the ability to interact with the user and the ability to update data
    dynamically. To keep it simple, let's revisit an old chart—the bar chart from
    [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based Graphs"), *Creating
    Cartesian-based Graphs*—and integrate a counter that will count how many times
    a user clicks on an HTML document in any given second and update the chart accordingly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将专注于客户端编程的一个更强大的特性——与用户交互的能力和动态更新数据的能力。为了简单起见，让我们重新访问一个旧图表——[第3章](ch03.html
    "第3章。创建基于笛卡尔坐标的图表")中的条形图，*创建基于笛卡尔坐标的图表*——并集成一个计数器，它将计算用户在任何给定秒内点击HTML文档的次数，并相应地更新图表。
- en: '![Making an interactive click meter](img/3707OT_05_06.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个交互式点击计量器](img/3707OT_05_06.jpg)'
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Most of the steps are going to be familiar, if you have worked on the bar chart
    from [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based Graphs"), *Creating
    Cartesian-based Graphs*. So, let''s run through them and then focus on the new
    logic:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分步骤都会很熟悉，如果你曾经在[第3章](ch03.html "第3章。创建基于笛卡尔坐标的图表")中的条形图上工作过，*创建基于笛卡尔坐标的图表*。因此，让我们运行它们，然后专注于新的逻辑：
- en: Let's create some helper variables.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些辅助变量。
- en: '[PRE60]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Follow this with our `init` function.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的`init`函数。
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now it's time to create the `onTimeReset` function.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候创建`onTimeReset`函数了。
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The next step is to create the `onClick` listener.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建`onClick`监听器。
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now create the `refreshChart` function.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建`refreshChart`函数。
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Last but not least, let's create `drawChart` (most of its logic is the same
    as for the `init` function discussed in [Chapter 3](ch03.html "Chapter 3. Creating
    Cartesian-based Graphs"), *Creating Cartesian-based Graphs*).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，让我们创建`drawChart`（它的大部分逻辑与[第3章](ch03.html "第3章。创建基于笛卡尔坐标的图表")中讨论的`init`函数相同，*创建基于笛卡尔坐标的图表*）。
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That's it! We have an interactive chart that will be updated every second, depending
    on how many times you manage to click your mouse in 1 second—I assume no one can
    click more than 10 times a second but I've managed to get there (when using two
    hands).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们有一个交互式图表，它将每秒更新一次，取决于您在1秒内点击鼠标的次数——我假设没有人可以在一秒内点击超过10次，但我已经成功做到了（使用两只手）。
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's focus on the breakdown of the data variables in [Chapter 3](ch03.html
    "Chapter 3. Creating Cartesian-based Graphs"), *Creating Cartesian-based Graphs*.
    We had all our data ready inside our data object. This time around, we are keeping
    the data object empty, and instead, we have one data line in a separate variable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于[第3章](ch03.html "第3章。创建基于笛卡尔的图表")中数据变量的分解，*创建基于笛卡尔的图表*。我们之前在数据对象中准备好了所有数据。这一次，我们保持数据对象为空，而是将一个数据行放在一个单独的变量中。
- en: '[PRE66]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Each time the user clicks, we update the counter for `currentObject` and refresh
    the chart thus making the user experience more dynamic and live.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户点击时，我们都会更新`currentObject`的计数器，并刷新图表，从而使用户体验更加动态和实时。
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We set the interval in the `init` function as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`init`函数中设置间隔如下：
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Every time a second passes, the function checks whether the user had any clicks
    in that time interval, and if they did, it ensures that we push `currentObject`
    into the dataset. If the size of the dataset is greater than `25`, we cut the
    first item out of it and we refresh the chart. No matter what we create, a new
    empty object is labeled with a new label showing the current time in seconds.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒钟，函数都会检查用户在那段时间内是否有任何点击，如果有，它会确保我们将`currentObject`推入数据集中。如果数据集的大小大于`25`，我们就会将其中的第一项删除，并刷新图表。无论我们创建什么，一个新的空对象都会被标记上显示当前时间的新标签。
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'One last thing that you should look at before we wrap this sample up is:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这个示例之前，你应该看一下最后一件事：
- en: '[PRE70]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This part of our logic is really the glue that makes it possible for us to update
    our data every time a user clicks a button. The idea is we want to have a new
    array that will store the new data, but we do not want to the current element
    to be affected, so for that we are duplicating this data source by adding the
    new data object into it and then sending it off to create the chart.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逻辑的这一部分真的是让我们能够在用户点击按钮时更新数据的关键。我们想要有一个新的数组来存储新数据，但我们不希望当前元素受到影响，所以我们通过将新数据对象添加到其中来复制数据源，然后将其发送到创建图表。
