- en: Chapter 10. Maps in Action
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。地图行动
- en: 'In this chapter we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Connecting a Twitter feed to a Google map
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Twitter动态连接到Google地图
- en: Building an advanced interactive marker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个高级交互式标记
- en: Adding multiple tweets into an InfoWindow bubble
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多条推文添加到信息窗口气泡中
- en: Customizing the look and feel of markers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义标记的外观和感觉
- en: 'Final project: building a live itinerary'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终项目：构建实时行程
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter on mapping, we will tie in more deeply to our topic of data
    visualization. One of the most popular ways to visualize data these days is by
    using maps. In this chapter, we will explore a few ideas on how to integrate data
    into maps, using the Google Maps platform.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将更深入地与数据可视化这一主题联系起来。如今，可视化数据最流行的方式之一是使用地图。在本章中，我们将探讨如何将数据集成到地图中，使用Google地图平台。
- en: Connecting a Twitter feed to a Google map
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Twitter动态连接到Google地图
- en: This is the start of a very fun experiment with Google Maps. The goal of the
    task is to create a link between Twitter posts and a Google map. It will take
    us a few recipes to get to our final goal. By the end of this recipe, we will
    have a Google map. This Google map will be clickable in any area of the screen.
    When the user clicks on the map, they will connect to the Twitter API and search
    for tweets in that area that have the word "HTML5" in them. When the result comes
    back, it will pop a new marker onto the area that was clicked and add the most
    recent tweet on that topic originating from that location. At this stage, it would
    just be a marker with a rollover that shows us the actual tweet without more information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有趣的与Google地图的实验的开始。任务的目标是在Twitter帖子和Google地图之间创建一个链接。我们需要几个配方才能达到最终目标。在本配方结束时，我们将拥有一个Google地图。这个Google地图在屏幕的任何区域都可以点击。当用户点击地图时，他们将连接到Twitter
    API，并搜索该区域中包含“HTML5”一词的推文。当结果返回时，它将在被点击的区域上弹出一个新的标记，并添加来自该位置的关于该主题的最新推文。在这个阶段，它只是一个带有悬停效果的标记，显示我们的实际推文而没有更多信息。
- en: '![Connecting a Twitter feed to a Google map](img/3707OT_10_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![将Twitter动态连接到Google地图](img/3707OT_10_01.jpg)'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't read through [Chapter 9](ch09.html "Chapter 9. Using Google Maps"),
    *Using Google Maps*, you might find this chapter a little difficult, so I encourage
    you to read it before starting with this recipe. At this stage you should have
    a Google API set up (see the *Obtaining a Google API key* recipe in [Chapter 9](ch09.html
    "Chapter 9. Using Google Maps")).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有阅读[第9章](ch09.html "第9章。使用Google地图")*使用Google地图*，你可能会发现本章有点困难，所以我鼓励你在开始本章之前阅读它。在这个阶段，你应该已经设置了Google
    API（参见[第9章](ch09.html "第9章。使用Google地图")中的*获取Google API密钥*配方）。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create new HTML and JavaScript files and call them `10.01.socielmap.html`
    and `10.01.socielmap.js`, respectively, and then perform the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建新的HTML和JavaScript文件，并分别称它们为`10.01.socielmap.html`和`10.01.socielmap.js`，然后执行以下步骤：
- en: 'Add the following code in the HTML file using your own API key:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文件中添加以下代码，使用你自己的API密钥：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's move into the JavaScript file. As we have an `init()` function being called
    when the `onload` event triggers, we will place all of our code within a new `init`
    function.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进入JavaScript文件。由于`onload`事件触发时会调用`init()`函数，我们将把所有代码放在一个新的`init`函数中。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will start by setting our center point of the map. So far, we were extremely
    focused on my home state, New York, so let's change our focus to Europe.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从设置地图的中心点开始。到目前为止，我们一直非常关注我的家乡纽约州，所以让我们把注意力转向欧洲。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, let's create a black-and-white style for our map so it's easier to focus
    on the markers we are about to create.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为地图创建一个黑白风格，这样更容易专注于我们即将创建的标记。
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create a new Google map.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Google地图。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Set up the `grayStyle` styling object to be our default style.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`grayStyle`样式对象为我们的默认样式。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our next step is going to use Google's API to create a new `click` event for
    the map. When the map is clicked we want to trigger a `listener` function. When
    a click happens, we want to start our Twitter search as we will connect to the
    Twitter API and search for the submission of the keyword `html5` within a 50 kilometer
    radius from where our click on the map was. Let's create a new mouse event and
    start up the Twitter search.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的下一步是使用Google的API为地图创建一个新的`click`事件。当地图被点击时，我们希望触发一个`listener`函数。当发生点击时，我们希望开始我们的Twitter搜索，因为我们将连接到Twitter
    API，并搜索关键词`html5`在我们点击地图的位置的50公里半径内的提交。让我们创建一个新的鼠标事件并启动Twitter搜索。
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the Twitter search value is returned, it is time to show our new tweet;
    if no tweet is found, we will put in default content letting the user know that
    nothing could be found.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Twitter搜索值返回时，是展示我们的新推文的时候；如果没有找到推文，我们将放入默认内容，让用户知道找不到任何内容。
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you load the map again, you will find a map of Europe waiting to be clicked
    on. Each click will trigger a new Twitter search and will generate a new result
    based on the location you clicked on. To read the tweet, roll over the marker
    after it returns.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次加载地图时，你会发现一个欧洲地图等待点击。每次点击都会触发一个新的Twitter搜索，并根据你点击的位置生成一个新的结果。要阅读推文，请在返回后将鼠标悬停在标记上。
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We live in an age when data about almost anything increasingly overlaps with
    geolocation data and maps. It's almost impossible to write a book about data without
    talking about maps, and it's not possible to write a book about data visualization
    without at least opening the Pandora's box of the world of mapping and its possibilities,
    either.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个几乎任何数据都与地理位置数据和地图重叠的时代。几乎不可能写一本关于数据的书而不谈论地图，也不可能写一本关于数据可视化的书而不至少打开地图世界和其可能性的潘多拉魔盒。
- en: Twitter lately has been trying more and more to capture the location of users.
    For most of the time, the location is still void. That having been said, Twitter
    always knows the base location of users based on their information, and more so
    when users tweet through their cell phones. As such, Twitter always has a rough
    idea of where users are when they send a message, and in the coming years this
    accuracy is expected to only get better. In the future, more and more Twitter
    results will have such an accurate location for users that we will be able to
    pinpoint them directly on a map.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Twitter一直在努力捕获用户的位置。大部分时间，位置仍然是空的。话虽如此，Twitter始终根据用户的信息知道用户的基本位置，尤其是当用户通过他们的手机发送推文时。因此，Twitter总是大致知道用户发送消息时的位置，未来几年，这种准确性预计只会变得更好。在未来，越来越多的Twitter结果将为用户提供如此准确的位置，以至于我们将能够直接在地图上找到他们。
- en: 'After creating the map, the first step is that, as soon as a user clicks on
    any area of the map, we start building out a search query to be used on the Twitter
    API:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建地图后，第一步是，一旦用户点击地图的任何区域，我们就开始构建要在Twitter API上使用的搜索查询：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We don''t cover all the possibilities with search, but instead we are focusing
    on two main points: the search query, in our case HTML5, and the location of the
    query. We get the location information directly from the event that is passed
    into a marker. We reformat the information from our Google returned event and
    format it into a string, adding to it the range; in our case we set this to 50
    kilometers (you can choose `ml` for miles as well). As we are taking a look at
    the map of Europe now, I thought it would be appropriate to work in kilometers
    and not miles.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不涵盖搜索的所有可能性，而是专注于两个主要点：搜索查询，在我们的案例中是HTML5，以及查询的位置。我们直接从传递给标记的事件中获取位置信息。我们重新格式化来自我们的Google返回事件的信息，并将其格式化为一个字符串，添加到其中的范围；在我们的案例中，我们将其设置为50公里（您也可以选择`ml`表示英里）。由于我们现在正在查看欧洲地图，我认为使用公里而不是英里会更合适。
- en: We want to get our search values back as **JavaScript Object Notation** (**JSON**)
    values. JSON is a very minimal shorthand way to pass object information as strings
    between servers. For the most part, you will usually work with automatic converters
    so you will be sending objects and getting objects, but under the hood there is
    a JSON encoder and decoder that will process the request.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将我们的搜索值作为**JavaScript对象表示**（**JSON**）值返回。 JSON是在服务器之间以字符串形式传递对象信息的一种非常简洁的方式。在大多数情况下，您通常会使用自动转换器，因此您将发送对象并获取对象，但在幕后有一个JSON编码器和解码器来处理请求。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't know what JSON is, don't worry about it; it's all done in the background
    and it's not critical to understand how JSON works in order to work with it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道JSON是什么，不用担心；这一切都是在后台完成的，不必理解JSON的工作原理才能使用它。
- en: 'We want to get our data in JSON format; to do that we will send our URL parameters
    to the following URL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望以JSON格式获取我们的数据；为此，我们将将我们的URL参数发送到以下URL：
- en: '[http://search.twitter.com/search.json](http://search.twitter.com/search.json)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://search.twitter.com/search.json](http://search.twitter.com/search.json)'
- en: 'Append to it our `q` values and `geocode` values. If you want to explore options
    and possibilities with the Twitter search API more deeply, visit the following
    page:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到其中我们的`q`值和`geocode`值。如果您想更深入地探索Twitter搜索API的选项和可能性，请访问以下页面：
- en: '[https://dev.twitter.com/docs/api/1/get/search](https://dev.twitter.com/docs/api/1/get/search)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dev.twitter.com/docs/api/1/get/search](https://dev.twitter.com/docs/api/1/get/search)'
- en: 'The next step is to send our information to this service and get our results
    back. To do that, we will use the `$.getJSON` function in jQuery. This function
    will take care of all our needs: sending our request, getting it back, and then
    decoding the information into a regular JavaScript object.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将我们的信息发送到此服务并获取我们的结果。为此，我们将使用jQuery中的`$.getJSON`函数。此函数将处理我们所有的需求：发送我们的请求，获取它，然后将信息解码为常规的JavaScript对象。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The two parameters we need to send in are the search link and the return function.
    In our case, we will grab our data and send it to an external function, `showTweet`.
    We will send only the first result from the data to return and the `e.latLng`
    object information we got from our click event.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要发送的两个参数是搜索链接和返回函数。在我们的案例中，我们将获取我们的数据并将其发送到外部函数`showTweet`。我们将仅发送数据的第一个结果以返回和我们从点击事件中获取的`e.latLng`对象信息。
- en: Time to create the marker. In the `showTweet` function, our first task will
    be to check whether there is actually any data in the returned first element.
    If there is no value it means Twitter didn't find anything.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建标记了。在`showTweet`函数中，我们的第一个任务是检查返回的第一个元素中是否实际上有任何数据。如果没有值，这意味着Twitter没有找到任何内容。
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If no object was returned, we will create a new object with placeholder information
    to replace the regular result information. This is a great way to avoid complexities
    in your code: by building the exceptions into the regular user experience. We
    are done; all that is left is for us to create the marker.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有返回对象，我们将创建一个新对象，其中包含占位符信息，以替换常规结果信息。这是避免代码复杂性的好方法：通过将异常构建到常规用户体验中。我们完成了；我们所要做的就是创建标记。
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although we got what we had our minds set on, the `latLng` information we have
    is for our click and not the exact location of our tweet. Currently there is a
    property called geo that is returned in the object returned from Twitter. At the
    time of writing this book, it always comes back empty. Currently it looks like
    it's a feature that is about to be released or is partially implemented, so by
    the time you read this book try to check and see if there is a value being returned
    from the `obj.geo` property and use it to make your point more accurate when this
    information is available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们得到了我们心中所想的，但我们拥有的`latLng`信息是我们点击的位置，而不是我们推文的确切位置。目前返回的Twitter对象中有一个名为geo的属性。在撰写本书时，它总是返回为空。目前看起来它是一个即将发布或部分实现的功能，所以在阅读本书时，请尝试检查并查看`obj.geo`属性是否返回一个值，并在此信息可用时使用它使您的观点更准确。
- en: Building an advanced interactive marker
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个高级交互式标记
- en: The next step in our social map project is to add more details for our Twitter
    search result. We would like to open up an information panel automatically when
    the Twitter result comes in. In the process, we will create a subclass of Google
    Marker and extend it and add a new InfoWindow to enable us to add live HTML data
    right into our map.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们社交地图项目的下一步是为我们的Twitter搜索结果添加更多细节。当Twitter结果出现时，我们希望自动打开一个信息面板。在这个过程中，我们将创建一个Google标记的子类，并扩展它，并添加一个新的InfoWindow，使我们能够将实时HTML数据直接添加到我们的地图中。
- en: '![Building an advanced interactive marker](img/3707OT_10_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![构建高级交互式标记](img/3707OT_10_02.jpg)'
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It will be really hard to join in, if you haven't started from the start of
    this chapter. As this recipe is in continuation of the previous recipe, we will
    not create a new HTML file or a new JavaScript file but will instead continue
    from where we left off.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有从本章的开头开始，加入会很困难。由于这个配方是上一个配方的延续，我们不会创建新的HTML文件或新的JavaScript文件，而是会从我们离开的地方继续。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Grab your latest JavaScript file and let''s continue to the next steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 拿出你最新的JavaScript文件，让我们继续下一步：
- en: In the function `showTweet`, replace the new marker with a new `TwitterMarker`
    marker.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`showTweet`函数中，用一个新的`TwitterMarker`标记替换新标记。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we are not using the regular built-in marker, it's time for us to create
    our own marker. Let's start with the constructor.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们不再使用常规的内置标记，是时候为我们创建自己的标记了。让我们从构造函数开始。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will want to extend our new object from the `google.maps.Marker` marker so
    we can have all the features of the regular marker.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要从`google.maps.Marker`标记中扩展我们的新对象，以便我们可以拥有常规标记的所有功能。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s create a toggle button in our marker event listener. When the event
    is called, it will open or close our InfoWindow:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在标记事件监听器中创建一个切换按钮。当调用事件时，它将打开或关闭我们的InfoWindow：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is time to create the Twitter message by creating an HTML string.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候通过创建HTML字符串来创建Twitter消息了。
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you reload your HTML file, you will find it interactive in any area of the
    world; if it can find a tweet, it will output it on the map within an InfoWindow.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新加载HTML文件，您会发现它在世界的任何地方都是交互式的；如果它能找到一条推文，它将在地图上输出它。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Although there are not many lines, a lot of logic is condensed into this code.
    Let's start by looking at our new marker. This is the first time in this book
    that we use inheritance. Inheritance, as its name implies, enables us to extend
    the features of an object in JavaScript without affecting the original object.
    In our case, we want to take all the features of the marker (methods, properties,
    and so on) and add to them some custom behaviors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码行数不多，但其中包含了许多逻辑。让我们从新标记开始。这是本书中第一次使用继承。继承，顾名思义，使我们能够在JavaScript中扩展对象的功能，而不影响原始对象。在我们的情况下，我们希望获取标记的所有功能（方法、属性等），并为它们添加一些自定义行为。
- en: The inheritance is done in JavaScript by defining a prototype. Until now, we
    have used the prototype without talking about it much, but we used it mainly to
    create new methods. If we assign a full object to the prototype, all of the properties
    and methods of that object will be copied into our new object as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，通过定义原型来完成继承。到目前为止，我们使用原型而没有过多地谈论它，但我们主要用它来创建新方法。如果我们将一个完整的对象分配给原型，那么该对象的所有属性和方法也将被复制到我们的新对象中。
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always start first with extending of the object you want to extend, before any
    other additions. This is because if you've placed any new prototype methods before
    this line of code, they will silently be deleted and thus will not work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 始终首先通过扩展要扩展的对象来开始，然后再进行任何其他添加。这是因为如果在这行代码之前放置了任何新的原型方法，它们将被静默删除，因此将无法工作。
- en: The `buildTwitterHTML` method takes in the Twitter object returned and converts
    some of its data into HTML. We use this method once per marker. When we create
    a new marker, we create a new `InfoWindow` object as well. We place an InfoWindow
    on top of the marker and showcase the tweet information.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildTwitterHTML`方法接收返回的Twitter对象并将其数据转换为HTML。我们每个标记使用此方法一次。当我们创建一个新的标记时，我们也创建一个新的`InfoWindow`对象。我们将InfoWindow放在标记的顶部，并展示推文信息。'
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are setting the width as well, to avoid having a really big panel. We send
    our newly created `strTweet` string into the `infoWindow` object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了宽度，以避免出现一个非常大的面板。我们将新创建的`strTweet`字符串发送到`infoWindow`对象中。
- en: We wanted our marker to be a toggle button that controls the InfoWindow status.
    To do that we add a newly dynamically created property called `isOpen`. Even though
    we open up the InfoWindow earlier in the constructor, we don't set the value of
    `isOpen` there. We can fix that issue in the first action we perform in our click
    event listener of the marker.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的标记是一个切换按钮，用于控制InfoWindow的状态。为此，我们添加了一个新动态创建的名为`isOpen`的属性。即使我们在构造函数中打开了InfoWindow，我们也没有在那里设置`isOpen`的值。我们可以在标记的点击事件监听器中执行的第一个操作中解决这个问题。
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the marker is clicked, we automatically change the state of the `isOpen`
    variable. As it was not set before, it will now be set to `true`. The `!` operator
    is a `boolean` operator that switches a value between `true` and `false`. Its
    actual meaning is `not`. In other words, we are saying:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击标记时，我们会自动改变`isOpen`变量的状态。因为它之前没有设置，现在将被设置为`true`。`!`运算符是一个布尔运算符，可以在`true`和`false`之间切换值。它的实际含义是`not`。换句话说，我们是在说：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The interesting fact here is that undefined (the value of a variable that wasn't
    defined) for the not (`!`) operator is the same as `false`, `null`, or even `0`.
    Any other value would be considered true. This way, each time the marker is clicked,
    the value of the variable `this.isOpen` switches. And *that* is the heart of the
    logic of our toggle button. All that is left is to decide whether to open or close
    the InfoWindow.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实是，对于非（`!`）运算符的未定义值（未定义的变量的值）与`false`、`null`甚至`0`是相同的。任何其他值都被视为true。这样，每次点击标记时，变量`this.isOpen`的值都会切换。这就是我们切换按钮逻辑的核心。现在只剩下决定是打开还是关闭InfoWindow。
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This leads us to our final step of figuring out what will be our Twitter text.
    We will edit this method in the next few recipes. You can play around with it
    and ideally personalize it to what you prefer it to look like. We have two possible
    outcomes: *no Twitter messages in the search area* and *Twitter messages in the
    search area*. If there is a message, we will use some of the returned object properties
    to build up an HTML outline that will be used inside the `infoWindow` object that
    is associated with this marker. If there isn''t a result, we will create one.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引导我们进入最后一步，找出我们的Twitter文本是什么。我们将在接下来的几个步骤中编辑这个方法。您可以随意尝试，并根据自己的喜好进行个性化。我们有两种可能的结果：*搜索区域中没有Twitter消息*和*搜索区域中有Twitter消息*。如果有消息，我们将使用一些返回对象属性来构建一个HTML大纲，该大纲将用于与此标记相关联的`infoWindow`对象内。如果没有结果，我们将创建一个。
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There you go! Our social map is starting to be much more interesting. It still
    is missing some features. It would be really nice if we could see more than one
    message in the InfoWindow result. In the next recipe we will try to solve that
    issue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们的社交地图开始变得更加有趣。它仍然缺少一些功能。如果我们可以在InfoWindow结果中看到多条消息，那将是非常好的。在下一个步骤中，我们将尝试解决这个问题。
- en: Adding multiple tweets into an InfoWindow bubble
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多条推文添加到InfoWindow气泡中
- en: So far, in our interactive social map, we added markers in each location that
    we clicked on and opened up an InfoWindow with the tweet information. Our next
    step will be to enable multiple tweets to live inside our InfoWindow by adding
    a pagination system into our window.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的交互式社交地图中，我们在每个点击的位置添加了标记，并打开了一个包含推文信息的InfoWindow。我们的下一步将是通过在窗口中添加分页系统，使多条推文可以存在于我们的InfoWindow中。
- en: '![Adding multiple tweets into an InfoWindow bubble](img/3707OT_10_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![将多条推文添加到InfoWindow气泡中](img/3707OT_10_03.jpg)'
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get through this recipe you must be knee deep into our holistic chapter.
    If you dropped in just now, it would be a good idea to go back to the start of
    this chapter as we are going to continue from where we left off in the previous
    recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个步骤，您必须深入了解我们的整体章节。如果您刚刚加入，最好回到本章的开头，因为我们将从上一个步骤离开的地方继续进行。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: We are still in our JavaScript file and we will continue to add code and adjust
    our code to get multiple Twitter posts into our social map.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在我们的JavaScript文件中，并将继续添加代码和调整我们的代码，以便将多个Twitter帖子添加到我们的社交地图中。
- en: Let's start by changing our Twitter search to return up to 100 values per search.
    We are doing this because there is a limit on how many times we can call the Twitter
    API. So, we will try to grab as much as we can in one hit (this code should be
    around line 30).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先将Twitter搜索更改为每次搜索返回最多100个值。我们这样做是因为我们调用Twitter API的次数是有限的。因此，我们将尝试一次性获取尽可能多的内容（此代码应该在第30行左右）。
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we are now going to treat all the tweets that come back, we will need to
    change our references to send to our `TwitterMaker` marker the full array (changes
    highlighted in the code snippet).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在要处理返回的所有推文，我们需要更改我们发送到`TwitterMaker`标记的引用，发送完整的数组（代码片段中的更改已突出显示）。
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We want to update the `TwitterMarker` constructor to include our array and quick
    information on it, such as the total tweets and the current tweet we are in. We
    will need a way to identify our object, and as such, we will give it an ID as
    well (more on that in a few steps).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望更新`TwitterMarker`构造函数，包括我们的数组以及有关它的快速信息，例如总推文数和当前所在的推文。我们需要一种方法来标识我们的对象，因此我们也会给它一个ID（在接下来的几个步骤中会详细介绍）。
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We want to store, in a static array that can be accessed from any place in
    our code, all the markers created. To do that, we will add a new status array
    to our `TwitterMarker` class:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在我们的代码中的任何地方都可以访问一个静态数组，其中包含所有创建的标记。为此，我们将在`TwitterMarker`类中添加一个新的状态数组：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `buildTwitterHTML` method, we want to add in back/next links that will
    be visible to users from InfoWindow:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`buildTwitterHTML`方法中，我们希望添加回/下一个链接，用户可以从InfoWindow中看到：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's now add the `next` and `prev` methods.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加`next`和`prev`方法。
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Load the HTML file, and you should find a working InfoWindow that can accommodate
    up to 100 tweets per click.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 加载HTML文件，您应该会发现一个可以容纳每次点击最多100条推文的工作InfoWindow。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our first change was to change the number of results coming back from the Twitter
    search API. This change forced us to change the references in our code from referring
    directly to the first object returned to focus on the full results object and
    sending it to our `TwitterMarker` constructor. This change created a few smaller
    changes in the flow of the information within the constructor as well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个改变是改变了从Twitter搜索API返回的结果数量。这个改变迫使我们改变了代码中的引用，不再直接引用第一个返回的对象，而是专注于完整的结果对象，并将其发送到我们的`TwitterMarker`构造函数。这个改变也在构造函数内的信息流中创建了一些较小的改变。
- en: Our goals are to create two buttons that will update our InfoWindow. This is
    an issue as we need a two-way connection between our marker and its InfoWindow.
    Until now, all our communication with the InfoWindow was one way. The easiest
    way for us to solve this problem and bypass the Google interface is to create
    a static array that will store all markers and refer to our static marker when
    we trigger buttons inside the `InfoWindow` object. All we need to do is add a
    variable direction to our class name.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建两个按钮，这些按钮将更新我们的InfoWindow。这是一个问题，因为我们需要标记和其InfoWindow之间的双向连接。到目前为止，我们与InfoWindow的所有通信都是单向的。我们解决这个问题并绕过Google接口的最简单方法是创建一个静态数组，该数组将存储所有标记，并在`InfoWindow`对象内部触发按钮时引用我们的静态标记。我们只需要向我们的类名添加一个变量direction。
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By adding our variable directly into the `TwitterMarker` class, we can now refer
    to it directly at any point and it will not get duplicated in our objects (as
    it's not part of the prototype). Now that we have an array, it's time for us to
    go back into our `TwitterMarker` constructor and send a new reference to this
    array each time we create a new `TwitterMarker` object. Another benefit we get
    out of doing this is that we automatically get a unique identifier (ID) for each
    marker as the returned number will always be a unique number for our needs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接将变量添加到`TwitterMarker`类中，我们现在可以在任何时候直接引用它，并且它不会在我们的对象中重复（因为它不是原型的一部分）。现在我们有了一个数组，是时候回到我们的`TwitterMarker`构造函数中，每次创建一个新的`TwitterMarker`对象时，都向这个数组发送一个新的引用。我们通过这样做得到的另一个好处是，我们自动获得一个唯一的标识符（ID），因为返回的数字将始终是我们需要的唯一数字。
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this one line of code, we perform all of the tasks we talked about in the
    previous paragraph. The array `push` method returns the new length of the array.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行代码中，我们执行了前一段中讨论的所有任务。数组`push`方法返回数组的新长度。
- en: Now that we have a way to refer to our marker and have got an identifier, it's
    time for us to go back into the `buildTwitterHTML` method and add into the rendered
    HTML two `href` buttons that will trigger the right marker when the next/previous
    selections are clicked.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种引用我们的标记并获得标识符的方法，是时候回到`buildTwitterHTML`方法中，并在呈现的HTML中添加两个`href`按钮，当单击下一个/上一个选择时，将触发正确的标记。
- en: Before we delve into that, we want to check and validate that we have more than
    one Twitter message that came back; if there is none, there is no point in adding
    the new logic, and we would be introducing a bug if we had next/previous logic
    for an item that has only one item.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究之前，我们要检查并验证我们是否有多于一个返回的Twitter消息；如果没有，添加新逻辑就没有意义，如果我们为只有一个项目的项目引入了下一个/上一个逻辑，我们将引入一个错误。
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By the following `if` statement, we figure out whether we are currently in
    the first Twitter message, and if not we shall add the back button:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下`if`语句，我们可以确定我们当前是否在第一个Twitter消息中，如果不是，我们将添加返回按钮：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This might look like a huge mess but, if we ignore the HTML and focus on the
    actual JavaScript that will be triggered when the button is pressed, this is what
    we will get:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很混乱，但是，如果我们忽略HTML，专注于当按钮被按下时将触发的实际JavaScript，我们将得到这样的结果：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `this.id-1` parameter will be replaced with the actual current number:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.id-1`参数将被实际的当前数字替换：'
- en: 'As this is rendered into a string to be parsed as HTML, the value that will
    be integrated into the HTML will be hardcoded. Let''s see this in a real case
    to make it clear. The first array ID would be `0`, and as such the `prev` button
    would look like this code statement:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是渲染为要解析为HTML的字符串，将集成到HTML中的值将是硬编码的。让我们看一个真实案例来澄清这一点。第一个数组ID将是`0`，因此`prev`按钮将如下代码语句所示：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now the logic is starting to reveal itself. By grabbing the marker from the
    array that is our current element, all that is left for us to do is trigger the
    `prev` method and let it take over.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在逻辑开始显露出来。通过从数组中抓取我们当前元素的标记，我们所要做的就是触发`prev`方法并让它接管。
- en: 'The same logic happens for our other end. The only condition is that we are
    not in the last Twitter result and if not we call the `next` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一端，同样的逻辑发生了。唯一的条件是我们不在最后的Twitter结果中，如果不是，我们调用`next`方法：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There you have it! The core of our logic is in place.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止！我们的逻辑核心已经就位。
- en: If we wanted we could have created our InfoWindow by wrapping a `<div>` tag
    with a unique ID and just called it and made direct updates to our content (try
    doing that by yourself as that would be a better solution). Instead, we are working
    with the limitations of the InfoWindow. As we cannot update the full bucket container
    while it's open, we need to close it to update it and then open it again. Thus
    our logic in both the `next` and `prev` methods is similar; both have a limitation
    on the change of the actual value that is being rendered.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以通过用一个唯一ID包装`<div>`标签来创建我们的InfoWindow，并直接调用它并直接更新我们的内容（尝试自己做这个，因为那将是一个更好的解决方案）。相反，我们正在处理InfoWindow的限制。由于我们不能在打开时更新完整的bucket容器，我们需要关闭它以更新它，然后再次打开它。因此，我们在`next`和`prev`方法中的逻辑是相似的；两者都对正在呈现的实际值的更改有限制。
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All the logic is the same and limited to the highlighted code snippet. If you
    aren't familiar with this shortcut, the `++` and `--` operators when set before
    a variable, enable us to add/subtract 1 from it and update it before its value
    is sent on. Thus in one line, we can both change the number in the variable and
    send that newly created number to continue its tasks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的逻辑都是相同的，并且限制在高亮显示的代码片段中。如果你不熟悉这个快捷方式，当`++`和`--`操作符设置在变量之前时，它们使我们能够在变量上加/减1，并在发送其值之前更新它。因此，在一行中，我们既可以改变变量中的数字，又可以发送新创建的数字以继续其任务。
- en: In the case of the `next` method, we want to grab the next tweet, while for
    the `prev` method, we want to grab the previous tweet.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`next`方法的情况下，我们想抓取下一个推文，而在`prev`方法的情况下，我们想抓取上一个推文。
- en: Customizing the look and feel of markers
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义标记的外观和感觉
- en: This will be our last recipe for social mapping. In this recipe, we will revisit
    our marker itself and give it a facelift. As our marker represents Twitter messages
    in a clicked area, we will update our marker to look like a Twitter bird (hand
    made). We will not stop there; after updating our graphic, we will add another
    graphical layer to shadow our Twitter marker. It will be a shadow, and its opacity
    will range from zero to full, depending on the number of tweets (a maximum of
    hundred tweets).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们社交地图的最后一个配方。在这个配方中，我们将重新审视我们的标记本身，并对其进行改头换面。由于我们的标记代表了点击区域的Twitter消息，我们将更新我们的标记，使其看起来像Twitter鸟（手工制作）。我们不会止步于此；在更新我们的图形后，我们将添加另一个图形层来阴影我们的Twitter标记。它将是一个阴影，其不透明度将根据推文数量（最多一百条推文）从零到完全不同。
- en: 'The best way to understand our goal is by checking out the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们的目标的最佳方法是查看以下屏幕截图：
- en: '![Customizing the look and feel of markers](img/3707OT_10_04.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![自定义标记的外观和感觉](img/3707OT_10_04.jpg)'
- en: Note how some tweets have no visible circle outline, while others have a very
    dark one (that is based on how many tweets are there).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些推文没有可见的圆形轮廓，而另一些则有非常深的轮廓（这取决于推文的数量）。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this task you need to first complete all the previous recipes in
    this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此任务，您需要首先完成本章中的所有先前的配方。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: We will jump right into the JavaScript file and continue from where we left
    off in the previous recipe.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接进入JavaScript文件，并从上一个步骤离开的地方继续。
- en: Update the `showTweet` function.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`showTweet`函数。
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create an instance of the `MarkerCounter` object in the `TweeterMarker` constructor.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TweeterMarker`构造函数中创建`MarkerCounter`对象的实例。
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Create the `MarkerCounter` constructor.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MarkerCounter`构造函数。
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create subclass, `MarkerCounter`, for the `google.maps.OverlayView` object.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`google.maps.OverlayView`对象创建子类`MarkerCounter`。
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create an `onAdd` method. It will be called automatically when an element is
    added into the map. In this method, we will finish up all the preparatory work
    for the drawing but won't draw the elements.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`onAdd`方法。当元素添加到地图中时，它将自动调用。在此方法中，我们将完成所有绘制的准备工作，但不会绘制元素。
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Last but not least, it's time to override the `draw` method and draw into the
    new canvas element created in the previous step and position the `div` element.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，现在是时候重写`draw`方法，并在上一步创建的新画布元素中绘制，并定位`div`元素。
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When you run the application, you will find that now our markers look like those
    of Twitter and the larger the number of tweets that originate from a location,
    the more opaque the egg under our Twitter bird will be.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您会发现现在我们的标记看起来像Twitter的标记，而来自某个位置的推文数量越多，我们Twitter鸟下的蛋就会越不透明。
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first step is to swap the graphic that is the default graphic for the marker.
    As we are extending the regular marker, we have all of its default features and
    behaviors. One of these features is the ability to swap the icon. To do that,
    we pass in one of our object parameters as the icon and its path.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是交换默认标记的图形。由于我们正在扩展常规标记，因此我们拥有其所有默认功能和行为。其中一个功能是交换图标。为此，我们将我们的对象参数之一作为图标及其路径传递。
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You might be wondering how this actually works, as we are not actually doing
    anything to the icon parameter in our code. It''s very simple. If you take a deeper
    look at the `TwitterMaker` constructor, you will find the following line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这实际上是如何工作的，因为我们在代码中实际上没有对图标参数做任何事情。这很简单。如果您深入研究`TwitterMaker`构造函数，您会发现以下行：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Passing the `setValues` method to the `opt` object is our way of letting the
    marker continue and rendering our marker with the information we just got into
    our constructor. All the things that can be done in a regular marker can be done
    in ours as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将`setValues`方法传递给`opt`对象是我们让标记继续并使用我们刚刚在构造函数中获得的信息渲染我们的标记的方式。所有常规标记中可以完成的事情在我们的标记中也可以完成。
- en: At this stage we have our Twitter bird as our graphic interface for our marker.
    Unfortunately, this is as far as we can go with customizing our marker; next,
    we will need to add another visual layer. As we want to create a visual layer
    that behaves like a marker just visually (as it will be part of the marker), we
    will need to create a subclass for the `google.maps.OverlayView` object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的Twitter鸟是我们标记的图形界面。不幸的是，这是我们可以自定义标记的最远的地方；接下来，我们需要添加另一个视觉层。由于我们希望创建一个视觉层，其行为就像标记一样（因为它将成为标记的一部分），我们需要为`google.maps.OverlayView`对象创建一个子类。
- en: Similar to the marker logic, when we are ready to render our element, we want
    to call the method `setMap` (for the marker it was a different method but the
    same idea).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与标记逻辑类似，当我们准备渲染元素时，我们希望调用`setMap`方法（对于标记，这是一个不同的方法，但是相同的想法）。
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In our constructor, we are only storing very basic global information, such
    as our target opacity, radius, and the `options` object. We can store any information
    we want here. The most important element of information that we will need is the
    position (latitude and longitude). We will send that information into our marker,
    and it will be inside our `opt` object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们只存储非常基本的全局信息，例如我们的目标不透明度、半径和`options`对象。我们可以在这里存储任何我们想要的信息。我们将需要的最重要的信息元素是位置（纬度和经度）。我们将发送该信息到我们的标记，并且它将在我们的`opt`对象中。
- en: The `google.maps.OverlayView` object has an `onAdd` method. It's just like a
    listener, but in addition, we will override this method and add our processing/preparation
    work when the element is added into the map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`google.maps.OverlayView`对象有一个`onAdd`方法。它就像一个监听器，但另外，我们将覆盖此方法并在元素添加到地图中时添加我们的处理/准备工作。'
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Most of the logic here should look familiar. We start by creating a new `div`
    element. We set its CSS attributes to make absolute the position of the `div`
    element so we can move it around easily. We follow this with creating a canvas
    element and setting its width and height to be two times the radius of our circle.
    We add the canvas into our `div` element. Last but not least it's time for us
    to add our `div` element into the map. We will do that by accessing the `getPanes`
    method. This method will return all the visual layers this element can contain.
    In our case, we will go right to our overlay layer and add our `div` element to
    it. We do this inside the `onAdd` method rather than doing it earlier because
    the overlay will not be rendered and we will not have access to the last two lines
    in the previous code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大部分逻辑应该看起来很熟悉。我们首先创建一个新的`div`元素。我们设置它的CSS属性，使`div`元素的位置绝对，这样我们就可以轻松地移动它。然后我们创建一个canvas元素，并将其宽度和高度设置为我们圆的半径的两倍。我们将canvas添加到我们的`div`元素中。最后但并非最不重要的是，是时候将我们的`div`元素添加到地图中了。我们将通过访问`getPanes`方法来实现这一点。这个方法将返回这个元素可以包含的所有视觉层。在我们的情况下，我们将直接进入我们的覆盖层，并将我们的`div`元素添加到其中。我们之所以在`onAdd`方法中这样做，而不是在之前就这样做，是因为覆盖物不会被渲染，我们将无法访问前面代码中的最后两行。
- en: Just as we overrode the `onAdd` method, we do the same for the `draw` method.
    This is our last critical step. For the most part, all the work in this method
    will be very familiar as we have played a lot with canvas in this book. So, let's
    explore the new steps to find where we want to position our overlay.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们重写了`onAdd`方法一样，我们也对`draw`方法做了同样的事情。这是我们最后的关键步骤。在大部分情况下，这个方法中的所有工作都会非常熟悉，因为在这本书中我们已经玩过很多canvas。所以，让我们探索新的步骤，找到我们想要定位覆盖物的位置。
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the first line in the preceding code, we get the projection. The projection
    is the relative point of view of our overlay. Through this projection, we can
    extract the actual point in pixels. We call the `projection.fromLatLngToDivPixel`
    method, send to it a latitude/longitude object, and get back a point (`x`, `y`
    values). All that is left is to update the style of our `div` element and position
    it according to this information (not forgetting to subtract our radius size so
    our element is exactly in the middle of the actual point that was clicked).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的第一行中，我们获取了投影。投影是我们覆盖物的相对视角。通过这个投影，我们可以提取出实际的像素点。我们调用`projection.fromLatLngToDivPixel`方法，向它发送一个经纬度对象，并得到一个点（`x`，`y`值）。现在我们只需要根据这些信息更新我们的`div`元素的样式，并将其定位到这个信息（不要忘记减去我们的半径大小，这样我们的元素就恰好位于被点击的实际点的中间）。
- en: Until now, we have treated our `TwitterMarker` constructor as if there are always
    tweets somewhere in the world, but the reality is that sometimes there will not
    be anything, and right now we are creating both a visualization that won't work
    and a marker that won't visualize it. Let's override our behaviors and put up
    an alternative marker if there is no result and skip all of our customizations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直把我们的`TwitterMarker`构造函数当作世界上总是有推文的地方，但现实是有时候可能什么都没有，而现在我们正在创建一个无法工作的可视化和一个无法可视化它的标记。让我们重写我们的行为，如果没有结果，就放上一个替代的标记，并跳过所有我们的自定义。
- en: '![How it works...](img/3707OT_10_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3707OT_10_05.jpg)'
- en: Let's sort it out. We start by removing our original error logic from the `showTweet`
    method. Instead, we will just update the `text` attribute but will not create
    a new array.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们整理一下。我们首先从`showTweet`方法中删除我们原始的错误逻辑。相反，我们只会更新`text`属性，而不会创建一个新的数组。
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In case you are not familiar with the ternary operator, it''s a very condensed
    way of creating an `if...else` statement within code. The core logic of it is
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对三元运算符不熟悉，它是一种在代码中创建`if...else`语句的非常简洁的方式。它的核心逻辑如下：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The outcome is then sent back, and we can capture it right into our variable
    as we are doing in this case.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后结果被发送回来，我们可以将其捕捉到我们的变量中，就像我们在这种情况下所做的那样。
- en: The next area we want to change is the `TwitterMarker` constructor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们想要改变的是`TwitterMarker`构造函数。
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The main changes here are that we start our application by first checking if
    there are any tweets. If no tweets are around, we update the icon graphic to a
    new **X** icon. If we do have a result, all remains the same. We extracted the
    `setValues` method to be called out of the `if...else` conditions as we need to
    call it in any case.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要变化是，我们首先通过检查是否有任何推文来启动我们的应用程序。如果周围没有推文，我们将图标图形更新为一个新的**X**图标。如果我们有结果，一切都保持不变。我们将`setValues`方法提取出来，以便在任何情况下都需要调用它。
- en: There you go! We've completed our social map. There is much more you can do
    with this project. A couple of examples could be making it easier to change the
    search term, and comparing between two search results (that could be very interesting
    and easy). I would be interested to see around the world the number of times Flash
    versus HTML5 are mentioned, so if you get to it send me an e-mail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！我们完成了我们的社交地图。你可以用这个项目做更多的事情。一些例子可能是使更改搜索词更容易，并比较两个搜索结果（这可能非常有趣且容易）。我会很感兴趣地看到全世界提到Flash与HTML5的次数，所以如果你做到了，给我发封电子邮件。
- en: 'Final project: building a live itinerary'
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终项目：构建一个实时行程
- en: Although the natural next step from our previous sample would be just to add
    an extra feature to our already growing social map (which we have built throughout
    this chapter), we are taking a direction shift.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从我们之前的示例中自然的下一步是向我们已经在本章中构建的不断增长的社交地图添加额外的功能，但我们正在改变方向。
- en: 'In our final recipe, we will build an interactive Google map that will animate
    with the travel information of a close friend of mine in South America while I
    was working on this book. To build this application, we will animate the map by
    adding drawings and moving markers; we will integrate with an external feed of
    travel information and integrate animations and text snippets that will describe
    the journey. In the following screenshot, you can see a very small snapshot of
    the plain path:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终配方中，我们将构建一个交互式的Google地图，它将以我在写这本书时在南美洲的一位亲密朋友的旅行信息为动画。为了构建这个应用程序，我们将通过添加绘图和移动标记来为地图添加动画；我们将与旅行信息的外部源集成，并集成动画和文本片段来描述旅程。在下面的屏幕截图中，你可以看到一个非常小的纯路径快照：
- en: '![Final project: building a live itinerary](img/3707OT_10_06.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![最终项目：构建实时行程](img/3707OT_10_06.jpg)'
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Many of the elements we will be working with in this recipe will be based on
    work we did throughout all of the chapters. As such, it will not be easy to just
    jump right in if you haven't gone through the journey together with us. There
    are no prerequisites. We will start from scratch, but we will not focus on things
    we have learned already.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用许多元素，这些元素都是基于我们在所有章节中所做的工作。因此，如果你没有和我们一起经历这段旅程，那么就不容易立即开始。没有先决条件。我们将从头开始，但不会专注于我们已经学过的东西。
- en: 'As the user "travels" around the world map when there is a message for the
    user in the data source, the map will fade out and the message will be displayed
    before the user can continue traveling the world:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在世界地图上“旅行”时，如果数据源中有用户的消息，地图将变暗，并在用户继续旅行之前显示消息：
- en: '![Getting ready](img/3707OT_10_07.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/3707OT_10_07.jpg)'
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe we will be creating two files: an HTML file and a JavaScript
    file. Let''s look into them, starting with the HTML file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建两个文件：一个HTML文件和一个JavaScript文件。让我们来看看它们，从HTML文件开始：
- en: Create the HTML file.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建HTML文件。
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Time to move to the JavaScript file, `10.05.travel.js`. We will start by initiating
    the visualization library and storing a global map variable.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候转到JavaScript文件`10.05.travel.js`了。我们将通过初始化可视化库并存储全局地图变量来开始。
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'var map;     When the `init` function is triggered, the map is loaded and it triggers the loading
    of a Google spreadsheet in which we will store all of my friend''s travel information.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'var map;     当触发`init`函数时，地图被加载，并触发加载Google电子表格，我们将在其中存储所有朋友的旅行信息。'
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When the document is loaded, it will trigger the `onTripDataReady` listener.
    When that happens, we will want to create a new `GoogleMapTraveler` object (a
    custom class for managing our experience).
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档加载时，它将触发`onTripDataReady`监听器。当发生这种情况时，我们将想要创建一个新的`GoogleMapTraveler`对象（一个用于管理我们的体验的自定义类）。
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The constructor method of the `GoogleMapTraveler` object will prepare our variables,
    create a new `Animator` object, a `Traveler` object and a new `google.maps.Polyline`
    object, and will trigger the creation of the first travel point by calling the
    `nextPathPoint` method.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GoogleMapTraveler`对象的构造方法将准备我们的变量，创建一个新的`Animator`对象、一个`Traveler`对象和一个新的`google.maps.Polyline`对象，并通过调用`nextPathPoint`方法触发第一个旅行点的创建。'
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `getPosition` method is a very smart, small method that enables us to create
    a new `google.maps.LatLng` object each time it's called and to create a point
    based on an average of points or based on one item.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getPosition`方法是一个非常聪明、小巧的方法，它使我们能够每次调用时创建一个新的`google.maps.LatLng`对象，并根据点的平均值或一个项目创建一个点。'
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We want to be able to set the position of our traveler, and as such we will
    want to create a `setPosition` method as well.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望能够设置我们旅行者的位置，因此我们还希望创建一个`setPosition`方法。
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the heart of our application is the ability to automatically move from one
    step to the next. This logic is applied using our `Animator` object in combination
    with the `nextPathPoint` method:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序的核心是能够自动从一步移动到下一步。这种逻辑是使用我们的`Animator`对象结合`nextPathPoint`方法应用的：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are two callbacks that are triggered through our `Animator` object (they're
    highlighted in the preceding code snippet). It is time to create the logic that
    updates the information on our `onUpdate` callback. Let's take a peek at the `renderLine`
    method.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两个回调通过我们的`Animator`对象触发（它们在前面的代码片段中突出显示）。现在是时候创建更新`onUpdate`回调信息的逻辑了。让我们来看看`renderLine`方法。
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the next step, when the animation is complete, it triggers our overlay logic.
    The overlay logic is very simple; if there is text in the Google document, in
    the fifth column, we will darken the screen and type it out. If there is no text,
    we will skip this step and go right to the next step that is in the `hideOverlayCopy`
    method that triggers the next travel point (the next line in the spreadsheet).
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，当动画完成时，它会触发我们的覆盖逻辑。覆盖逻辑非常简单；如果在Google文档的第五列中有文本，我们将使屏幕变暗并输入文本。如果没有文本，我们将跳过这一步，直接进入触发`hideOverlayCopy`方法的下一步（电子表格中的下一行）。
- en: Our previous method of the `GoogleMapTraveler` object is the `bind` method.
    We already created this `bind` method in the *Moving to an OOP perspective* recipe
    in [Chapter 6](ch06.html "Chapter 6. Bringing Static Things to Life"), *Bringing
    Static Things to Life*; as such, we will not elaborate on it further.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们`GoogleMapTraveler`对象的先前方法是`bind`方法。我们已经在[第6章](ch06.html "第6章。将静态事物变得生动")*将静态事物变得生动*的*转向面向对象编程*配方中创建了这个`bind`方法；因此，我们不会进一步详细说明。
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Create the `Traveler` class. The `Traveler` class will be based on the work
    we did in the *Customizing the look and feel of markers* recipe in this chapter,
    only this time it will be an animating marker.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Traveler`类。`Traveler`类将基于本章中*自定义标记的外观和感觉*配方中的工作，只是这一次它将是一个动画标记。
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will grab the `Animator` class created in the *Animating independent layers*
    recipe in [Chapter 6](ch06.html "Chapter 6. Bringing Static Things to Life"),
    *Bringing Static Things to Life*, and tweak it (changes are highlighted in the
    code snippet).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将获取在[第6章](ch06.html "第6章。使静态事物活动起来")中创建的*Animating independent layers*食谱中创建的`Animator`类，并对其进行调整（代码片段中的更改已突出显示）。
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When you load the HTML file, you will find a fullscreen map that is getting
    its directions from a spreadsheet. It will animate and show you the paths my friend
    took as he traveled from Israel to South America and back.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当您加载HTML文件时，您会发现一个全屏地图，它从电子表格中获取方向。它将以动画方式显示我朋友从以色列到南美洲再返回时所走过的路径。
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are many components in this example, but we will focus mainly on the new
    steps that we haven't covered in any other part of this book.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有许多组件，但我们主要关注我们在本书的其他部分中尚未涵盖的新步骤。
- en: 'The first new thing we meet is right in our HTML and CSS:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的第一件新事物就在我们的HTML和CSS中：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We picked a font from the Google font library at [http://www.google.com/webfonts](http://www.google.com/webfonts)
    and integrated it into the text overlays.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Google字体库[http://www.google.com/webfonts](http://www.google.com/webfonts)中选择了一种字体，并将其集成到文本覆盖中。
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It is time to travel into our JavaScript file, which we start by loading in
    the Google Visualization Library. It's the same library we were working with in
    [Chapter 8](ch08.html "Chapter 8. Playing with Google Charts"), *Playing with
    Google Charts*. Once it's loaded, the `init` function is triggered. The `init`
    function starts our map up and starts loading in the spreadsheet.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进入我们的JavaScript文件了，我们首先加载Google可视化库。这是我们在[第8章](ch08.html "第8章。与Google图表一起玩")中使用的相同库，*与Google图表一起玩*。加载完成后，将触发`init`函数。`init`函数启动我们的地图，并开始加载电子表格。
- en: In the *Changing data source to Google spreadsheet* recipe in [Chapter 8](ch08.html
    "Chapter 8. Playing with Google Charts"), *Playing with Google Charts*, we worked
    with Google spreadsheets for the first time. There you learned all the steps involved
    with preparing and adding a Google chart into the Google visualization. In our
    case, we created a chart that contains line by line all the areas through which
    my friend traveled.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。与Google图表一起玩")的*将数据源更改为Google电子表格*食谱中，*与Google图表一起玩*，我们首次使用了Google电子表格。在那里，您学会了准备和添加Google图表到Google可视化中所涉及的所有步骤。在我们的情况下，我们创建了一个包含我朋友走过的所有地区的线路的图表。
- en: '![How it works...](img/3707OT_10_08.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3707OT_10_08.jpg)'
- en: 'The exception in this case is that we don''t want to feed our URL into a Google
    chart, but instead we want to work with it directly. To do that we will use one
    of Google''s API interfaces, the `google.visualization.Query` object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下的例外是，我们不想将我们的URL提供给Google图表，而是想直接使用它。为此，我们将使用Google的API接口之一，`google.visualization.Query`对象：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The next step is to create our `GoogleMapTraveler` object. The Google map traveler
    is a new way for us to work with Google Maps. It doesn't extend any built-in feature
    of Google maps but is instead a hub for all the other ideas we created in the
    past. It is used as a manager hub for the marker, called Traveler, that we will
    create soon and the `google.maps.Polyline` object that enables us to draw lines
    on the map.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的`GoogleMapTraveler`对象。Google地图旅行者是我们与Google地图一起工作的一种新方式。它不扩展Google地图的任何内置功能，而是我们过去创建的所有其他想法的中心。它被用作标记管理中心，称为Traveler，我们将很快创建的`google.maps.Polyline`对象，它使我们能够在地图上绘制线条。
- en: Instead of having a very static line appearance, let's create a reveal effect
    for new lines that are added to the Google map. To achieve that, we need a way
    to update the polyline every few milliseconds to create an animation. From the
    get go, I know the start point and the destination point as I get that information
    from the Google spreadsheet created earlier.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想让新添加到Google地图中的线条呈现出非常静态的外观，而是想为其创建一个揭示效果。为了实现这一点，我们需要一种方法，每隔几毫秒更新折线以创建动画。一开始，我就知道起点和终点，因为我从之前创建的Google电子表格中获取了这些信息。
- en: The idea is very simple even though in a very complex ecosystem. The idea is
    to have an array that will store all the latitude/longitude points. This would
    then be fed into the `this.line` object every time we wanted to update our screen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法非常简单，尽管在一个非常复杂的生态系统中。这个想法是创建一个数组，用于存储所有的纬度/经度点。然后，每当我们想要更新屏幕时，将其提供给`this.line`对象。
- en: 'The heart of the logic in this application is stored within this line of code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的逻辑核心存储在这行代码中：
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It will start a recursive journey throughout all of the points in our chart.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它将开始一个递归的旅程，遍历图表中的所有点。
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's take a deeper look at the logic behind the `GoogleMapTraveler.prototype.nextPathPoint`
    method. The first thing we do in this function is to set our map view.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解`GoogleMapTraveler.prototype.nextPathPoint`方法背后的逻辑。在这个函数中，我们首先要做的事情是设置地图视图。
- en: '[PRE67]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `setPosition` method does a few things that are all related to repositioning
    our map and our zoom level based on the data in the current index that is sent.
    It's a bit smarter than that as it takes in a second parameter that enables it
    to average out two points. As one travels between two points, it would be best
    if our map is at the center of the two points. That is done by sending in `2`
    as the second parameter. The internal logic of the `setPosition` method is simple.
    It will loop through as many items as it needs to, to average out the right location.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPosition`方法执行了一些与根据发送的当前索引中的数据重新定位地图和缩放级别相关的操作。它比这更智能，因为它接受第二个参数，使其能够对两个点进行平均。当一个人在两点之间旅行时，最好是我们的地图位于两点的中心。通过将`2`作为第二个参数发送进去来实现。`setPosition`方法的内部逻辑很简单。它将循环遍历需要的项目，以平均出正确的位置。'
- en: Next, we add a new point to our `this.pathPoints` array. We start by duplicating
    the same point that is already in the array, as we want our new second point to
    start from the starting point. This way, we can update the last value in our array
    each time, until it reaches the end goal (of the real next point).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向我们的“this.pathPoints”数组添加一个新点。我们首先复制已经在数组中的相同点，因为我们希望我们的新第二点从起点开始。这样，我们可以每次更新数组中的最后一个值，直到它达到终点（真正的下一个点）。
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We create a few helper variables. One will point to the new object we just created
    and pushed into our `pathPoints` array. And the second is the point that we want
    to reach at the end of our animation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一些辅助变量。一个将指向我们刚刚创建并推送到我们的“pathPoints”数组中的新对象。第二个是我们希望在动画结束时达到的点。
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first variable is not a new object but a reference to the last point created,
    and the second line is a new object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量不是一个新对象，而是对最后创建的点的引用，第二行是一个新对象。
- en: Our next step will be to start and animate the values of our `currentPoint`
    until it reaches the values in the `point` object and to update our traveler latitude/longitude
    information until it reaches its destination as well. We give a delay of 0.75
    seconds to our second animation to keep things more interesting.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步将是开始并动画化我们的“currentPoint”的值，直到它达到“point”对象中的值，并更新我们的旅行者纬度/经度信息，直到它也到达目的地。我们给第二个动画延迟0.75秒，以使事情更有趣。
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Before we end this method, we want to actually animate our lines. Right now,
    we are animating two objects that are not visual. To start animating our visual
    elements, we will listen to updates till the time we complete the animations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这个方法之前，我们想实际动画化我们的线。现在，我们正在动画化两个不可视的对象。为了开始动画化我们的可视元素，我们将监听更新，直到我们完成动画。
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Each time the animation happens, we update the values of our visual elements
    in the `renderLine` method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每次动画发生时，我们在“renderLine”方法中更新我们的可视元素的值。
- en: To avoid getting runtime errors, we added to the traveler marker an `isReady`
    Boolean to indicate to us when our element is ready to be drawn into.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免运行时错误，我们为旅行者标记添加了一个“isReady”布尔值，以指示我们的元素何时准备好绘制。
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When the animation completes, we move to the `showOverlayCopy` method, where
    we take over the screen and animate the copy in the same strategy as we've done
    before. This time around, when we are done with this phase, we will trigger our
    initial function again and start the cycle all over with an updated index.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画完成时，我们转到“showOverlayCopy”方法，在那里我们接管屏幕并以与之前相同的策略动画复制。这一次，当我们完成这个阶段时，我们将再次触发我们的初始函数，并以更新后的索引重新开始整个循环。
- en: '[PRE73]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That covers the heart of our build. It's time for us to talk briefly about the
    two other classes that will help create this application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们构建的核心。现在是时候简要谈谈另外两个类，这些类将帮助创建这个应用程序。
- en: Understanding the Traveler marker
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解旅行者标记
- en: We will not dig deeply into this class, as for the most part, it's based on
    the work we did in the previous recipe, *Customizing the look and feel of markers*.
    The biggest difference is that we added internal animation to our element and
    an `updatePosition` method that enables us to move our marker around whenever
    we want to move it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入研究这个类，因为在很大程度上，它是基于我们在上一个配方中所做的工作，“自定义标记的外观和感觉”。最大的区别是，我们在我们的元素中添加了内部动画和一个“updatePosition”方法，使我们能够在需要移动时移动我们的标记。
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This method gets a latitude and longitude and updates the marker's position.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法得到一个纬度和经度，并更新标记的位置。
- en: As we are animating the actual `ll` object of this object in the main class,
    we added a second method, `refreshPosition`, which is called each time the animations
    are updated.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在动画化这个对象的实际“ll”对象在主类中，我们添加了第二个方法“refreshPosition”，每次更新动画时都会调用它。
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There is more to explore and find in this class, but I'll leave that for you
    to have some fun.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个课程中还有更多可以探索和发现的东西，但我会留给你一些乐趣。
- en: Updating the Animator object
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新动画对象
- en: 'We made two major updates to our `Animator` class, which was originally created
    in the *Animating independent layers* recipe in [Chapter 6](ch06.html "Chapter 6. Bringing
    Static Things to Life"), *Bringing Static Things to Life*. The first change was
    integrating callback methods. The idea of a callback is very similar to events.
    Callbacks enable us to call a function when something happens. This way of working
    enables us to only have one listener at a time. To do this, we start by creating
    the two following variables that are our callback functions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的“Animator”类进行了两个重大更新，这个类最初是在[第6章](ch06.html "第6章。让静态事物活起来")的“独立层动画”配方中创建的，“让静态事物活起来”。第一个变化是集成回调方法。回调的概念与事件非常相似。回调使我们能够在发生某事时调用一个函数。这种工作方式使我们一次只能有一个监听器。为此，我们首先创建了以下两个变量，它们是我们的回调函数：
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We then trigger both functions in the `Animator` class in their relevant location
    (on update or on complete). In our `GoogleMapTraveler` object, we override the
    default functions with functions that are internal to the `GoogleMapTraveler`
    object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在“Animator”类中的相关位置（在更新或完成时）触发这两个函数。在我们的“GoogleMapTraveler”对象中，我们用“GoogleMapTraveler”对象内部的函数覆盖了默认函数。
- en: Our second and last major update to the `Animator` object is that we added smarter,
    more detailed logic to enable our animator to animate both to positive and negative
    areas. Our original animation didn't accommodate animating latitude/longitude
    values, and as such we tweaked the core animation logic.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对“Animator”对象的第二个也是最后一个重大更新是，我们添加了更智能、更详细的逻辑，使我们的动画师能够动画化正负区域。我们的原始动画没有考虑到动画化纬度/经度值，因此我们调整了核心动画逻辑。
- en: This covers the major new things we explored in this recipe. This recipe is
    jam-packed with many other small things we picked up throughout the chapters.
    I truly hope you've enjoyed this journey with me, as this is the end of our book.
    Please feel free to share with me your work and insight. You can find me at [http://02geek.com](http://02geek.com)
    and my e-mail is `<[ben@02geek.com](mailto:ben@02geek.com)>`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们在这个食谱中探索的一些重要新事物。这个食谱中还充满了我们在各章中学到的许多其他小东西。我真诚希望你喜欢和我一起走过这段旅程，因为这是我们书的结尾。请随时与我分享你的工作和见解。你可以在[http://02geek.com](http://02geek.com)找到我，我的电子邮件是`<[ben@02geek.com](mailto:ben@02geek.com)>`。
