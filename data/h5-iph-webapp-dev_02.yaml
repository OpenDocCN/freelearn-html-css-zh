- en: Chapter 2. Integrating HTML5 Video
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。集成HTML5视频
- en: Media distribution is essential for any web application; delivering rich experiences
    that alter the user's perception. Many times we are asked to put a still image
    on a site, and other times we are asked to include video galleries that allow
    the user to switch videos easily through some sort of unique navigation. Previously,
    we were able to do this with Flash and other plugin based technologies, but with
    the wide support of HTML5 video, we now have the ability to deliver video without
    the condition of downloading a plugin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体分发对于任何Web应用程序都是必不可少的；提供改变用户感知的丰富体验。很多时候，我们被要求在网站上放一张静态图片，而其他时候，我们被要求包含视频画廊，允许用户通过某种独特的导航轻松切换视频。以前，我们可以使用Flash和其他基于插件的技术来实现这一点，但随着HTML5视频的广泛支持，我们现在有能力在不需要下载插件的情况下提供视频。
- en: One thing to keep in mind is that HTML5 video and audio share the same specification.
    This is because they are both considered a media element ([http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#media-element](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#media-element)).
    What this means is that both video and audio share some attributes and methods,
    making it easier to implement them within our applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，HTML5视频和音频共享相同的规范。这是因为它们都被认为是媒体元素。这意味着视频和音频共享一些属性和方法，使得在我们的应用程序中实现它们更容易。
- en: Either way, let's get going by learning how we can configure our server to deliver
    our videos correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们开始学习如何配置我们的服务器以正确地传送我们的视频。
- en: 'In this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Configuring our server for video distribution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置我们的服务器以进行视频分发
- en: Implementing HTML5 video
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施HTML5视频
- en: Listening to HTML5 video events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听HTML5视频事件
- en: Creating a thorough JavaScript video library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个完整的JavaScript视频库
- en: Customizing HTML5 video controls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义HTML5视频控件
- en: Configuring the server
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器
- en: Before implementing our video, we need to make sure our server knows what media
    types we will be serving. Doing this now helps to avoid headaches later on when
    we don't know why we are getting network errors. So let's get to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施视频之前，我们需要确保服务器知道我们将提供哪些媒体类型。现在这样做有助于避免以后出现网络错误时不知道原因的头痛。所以让我们开始吧。
- en: Video formats
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频格式
- en: First, we need to know what file types we will be serving up. In our examples
    we will be using MP4, but it's always a good idea to allow what is supported.
    Make sure you have WebM, OGV, and MP4 formats for your videos. But first, before
    we go on, let's side step and learn a little bit about these formats.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道我们将提供哪些文件类型。在我们的示例中，我们将使用MP4，但允许支持的文件类型总是一个好主意。确保你的视频有WebM、OGV和MP4格式。但首先，在我们继续之前，让我们先了解一下这些格式。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We're not going to get too deep into explaining the different types that are
    widely supported, but keep in mind that Theora, WebM, and H.264/MPEG-4 are the
    most widely supported formats. Both Theora and WebM are free, with WebM development
    being supported by Google. The implementation for Theora in browsers has lagged
    due to worry about patents, while WebM has been widely supported by Mozilla Firefox,
    Google, and Opera due to its royalty-free and open video compression features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入解释广泛支持的不同类型，但请记住，Theora、WebM和H.264/MPEG-4是最广泛支持的格式。Theora和WebM都是免费的，WebM的开发得到了Google的支持。由于担心专利问题，Theora在浏览器中的实现一直滞后，而WebM由于其免版税和开放的视频压缩功能，得到了Mozilla
    Firefox、Google和Opera的广泛支持。
- en: Things get a bit hairy when it comes to H.264\. Although a great format for
    having high quality, good speed, and being a standard for video compression, patents
    encumber it. For this reason, it has lagged behind in support in popular browsers
    for a long time. Eventually, each browser came to support this format, but not
    without controversy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到H.264时，情况变得有点棘手。尽管它是一个高质量、速度快、视频压缩的标准格式，但专利使其受到限制。因此，它在流行浏览器中的支持一直滞后。最终，每个浏览器都开始支持这种格式，但不是没有争议。
- en: Video format directives
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频格式指令
- en: 'Next, depending on the server type, we need to include specific directives
    to allow our file types. In this example, we are using an Apache server, thus
    the following syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据服务器类型，我们需要包含特定的指令来允许我们的文件类型。在这个例子中，我们使用的是Apache服务器，因此以下语法：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous code would be added to either an `.htaccess` file on the server
    or to the `httpd.conf` file. Either way, the `AddType` directive informs the server
    what types it should and can serve. So when we go line by line, we can see that
    we are adding the `video/ogg` type with extension `.ogv`, and we do this for MP4
    and WebM.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将被添加到服务器上的`.htaccess`文件或`httpd.conf`文件中。无论哪种方式，`AddType`指令都会告诉服务器它应该和可以提供哪些类型。因此，当我们逐行进行时，我们可以看到我们正在添加`video/ogg`类型和扩展名`.ogv`，我们也为MP4和WebM这样做。
- en: Taking these initial steps helps us to avoid any network issues when we go ahead
    and implement video on our site using HTML5\. If you're curious how we use these
    types, don't worry, that's exactly what we'll be going over in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 采取这些初始步骤有助于我们在使用HTML5在网站上实现视频时避免任何网络问题。如果你想知道我们如何使用这些类型，不用担心，下一节我们将详细介绍。
- en: A simple HTML5 video
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的HTML5视频
- en: We've been dying to do something cool in our web application, so let's get to
    it. Let's start out by including a video on our site in the simplest manner possible,
    and without any complicated interactions!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直渴望在我们的Web应用程序中做一些酷炫的东西，所以让我们开始吧。让我们从在我们的网站上以最简单的方式包含一个视频开始，而不涉及任何复杂的交互！
- en: Single video format
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一视频格式
- en: First, let's open up our `index.html` file located in the `video` subdirectory
    of the `Chapter 2` project. If you skipped the first chapter, don't worry about
    it, the `Chapter 2` source files follow along and help keep you going.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开位于`Chapter 2`项目的`video`子目录中的`index.html`文件。如果你跳过了第一章，不要担心，`Chapter 2`的源文件会跟随并帮助你继续前进。
- en: 'Once we have our `index.html` file, we want to include the `video` element
    within our content area, right after the `<header>` element. This is simple, we
    can do it like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的`index.html`文件，我们希望在内容区域中包含`video`元素，在`<header>`元素之后。这很简单，我们可以这样做：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code works similar to an image element. We define a `src` attribute
    that instructs the browser where to find the video, and then we define a `controls`
    and `preload` attribute, which directs the browser to display default native controls
    and to preload the video. Simple, eh?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码类似于图像元素。我们定义了一个`src`属性，指示浏览器在哪里找到视频，然后我们定义了`controls`和`preload`属性，这些属性指示浏览器显示默认的本机控件并预加载视频。简单吧？
- en: Supporting multiple formats
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多种格式
- en: 'This is all we need to put video on our site, but of course, things aren''t
    always so simple. As we discussed earlier, browsers can support one or none of
    the formats that we specify. Of course, right now we have good browser support,
    but we want to make sure that our application is solid, so we need to make sure
    that we deliver the appropriate file. To do this, we can modify the previous code
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在网站上放置视频所需要的一切，但当然，事情并不总是那么简单。正如我们之前讨论的，浏览器可以支持我们指定的格式中的一个或一个都不支持。当然，现在我们有很好的浏览器支持，但我们要确保我们的应用程序是稳固的，所以我们需要确保我们传递适当的文件。为了做到这一点，我们可以修改上面的代码如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have introduced a new attribute, `poster`. The `poster` attribute is
    an image we show at the beginning of the video or in cases where the video doesn't
    load. Things now get a bit complex when we move the source element inside of the
    `video` element. But, if we check everything out, we're basically defining multiple
    source videos and their types. The browser will then choose the appropriate one
    to display. What might confuse you is the paragraph element containing the `Fallback
    Content` text. This is here if everything else fails and/or if the browser does
    not support the HTML5 video.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了一个新属性，`poster`。`poster`属性是我们在视频开始时显示的图像，或者在视频无法加载时显示的图像。当我们将源元素移动到`video`元素内部时，事情变得有点复杂。但是，如果我们检查一切，我们基本上是在定义多个源视频及其类型。然后浏览器将选择适当的视频进行显示。可能会让你困惑的是包含`Fallback
    Content`文本的段落元素。如果一切都失败了，或者浏览器不支持HTML5视频，这就是它的作用。
- en: 'If this is a bit confusing, don''t worry about it too much because iPhone''s
    mobile Safari supports MP4 and is honestly all you need for your applications.
    So if we want to keep it simple, we can use the following code for our iPhone
    applications, and this is exactly what we do in this book:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这有点令人困惑，不要太担心，因为iPhone的移动Safari支持MP4，而且这对你的应用程序来说已经足够了。所以如果我们想保持简单，我们可以在我们的iPhone应用程序中使用以下代码，这也正是我们在本书中所做的：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have a simple video playing in our application, we might want to
    pick up on the events of our video.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序中有一个简单的视频播放，我们可能想要捕捉视频的事件。
- en: Listening to HTML5 video events
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听HTML5视频事件
- en: It's very likely that you will want full control of your application, or at
    least monitor what may be going on. You will usually find yourself attaching events
    or listening to them for various reasons. From tracking to enhancing an experience,
    events are how we can drive interactivity on the page. With HTML5 video, we can
    use the native browser to monitor the status of the video from start to finish.
    You have the opportunity to listen for when a video has finished loading and when
    the user has paused a video.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你会想要完全控制你的应用程序，或者至少监视可能发生的事情。出于各种原因，你通常会发现自己附加事件或监听事件。从跟踪到增强体验，事件是我们如何在页面上驱动交互的方式。使用HTML5视频，我们可以使用本机浏览器从头到尾监视视频的状态。你有机会监听视频何时加载完成以及用户何时暂停视频。
- en: 'Let''s review the events that are available to us. What you will find is that
    the events we use with videos can also be transferrable for audio. This is because,
    as we''ve learned previously, both video and audio elements are categorized as
    media elements in the HTML5 specification. Here is a table of events that are
    available to us:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们可以使用的事件。你会发现，我们用于视频的事件也可以转移到音频上。这是因为，正如我们之前学到的那样，视频和音频元素都被归类为HTML5规范中的媒体元素。这是我们可以使用的事件表：
- en: '| Event Name | Condition |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 条件 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `loadedmetadata` | The duration and dimensions of the media resource have
    been determined. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `loadedmetadata` | 已确定媒体资源的持续时间和尺寸。 |'
- en: '| `loadeddata` | Media data can now be rendered for the first time. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `loadeddata` | 现在可以首次渲染媒体数据。 |'
- en: '| `canplay` | Playback of the media data can resume. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `canplay` | 媒体数据的播放可以恢复。 |'
- en: '| `seeking` | The seeking attribute of the media resource has been set to true.
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `seeking` | 媒体资源的寻找属性已设置为true。 |'
- en: '| `seeked` | The seeking attribute of the media resource has been set to false.
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `seeked` | 媒体资源的寻找属性已设置为false。 |'
- en: '| `play` | The element is not paused. This is fired when the `play()` method
    has returned or when the `autoplay` attribute has caused the element to begin
    playback. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `play` | 元素未暂停。当`play()`方法已返回或`autoplay`属性已导致元素开始播放时触发。 |'
- en: '| `ended` | The end of the media resource was reached and playback has stopped.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `ended` | 已到达媒体资源的结尾并且播放已停止。 |'
- en: '| `pause` | The `pause()` method has returned and the element has been paused.
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `pause` | `pause()`方法已返回，元素已暂停。 |'
- en: '| `timeupdate` | The playback position of the media resource has changed in
    some way. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `timeupdate` | 媒体资源的播放位置以某种方式发生了变化。 |'
- en: '| `volumechange` | Fired when either the volume or muted attribute has changed.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `volumechange` | 当音量或静音属性发生变化时触发。 |'
- en: There are more events that are defined by the specification, however these are
    the events we will listen to from our previous simple implementation. So let's
    get started.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 规范定义了更多的事件，但这些是我们将从先前简单实现中监听的事件。所以让我们开始吧。
- en: Video markup review
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频标记回顾
- en: 'First, open your `index.html` file inside of the `video` directory. In this
    file, you have to make sure your content looks like the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`video`目录中的`index.html`文件。在这个文件中，您必须确保您的内容看起来像下面这样：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't pay attention to the ellipsis, these are just in there to make the code
    shorter in the text. What you want to make sure of is that you have the simple
    `<video>` element implementation from the last section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不要注意省略号，这只是为了使代码在文本中更短。您要确保的是，您有来自上一节的简单的`<video>`元素实现。
- en: Attaching video events
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加视频事件
- en: Now the fun starts. Let's start extending our JavaScript to include the listeners.
    Let's open the `App.Video.js` file located in the `/js` directory under the `App`
    folder. If you haven't been following along from our architecture chapter, don't
    worry, what's important for you to understand here is that we have created a structure
    for our applications and that the `App.Video.js` file will contain all functionality
    for the video application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始有趣的部分。让我们开始扩展我们的JavaScript以包括监听器。让我们打开位于`App`文件夹下`/js`目录中的`App.Video.js`文件。如果您没有从我们的架构章节一直跟着做，不用担心，对您来说重要的是要理解我们为应用程序创建了一个结构，`App.Video.js`文件将包含视频应用程序的所有功能。
- en: 'Find the constructor for the `App.Video` class. This should be on line 16 of
    your text editor, and should currently look like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`App.Video`类的构造函数。这应该在您的文本编辑器的第16行，并且当前应该看起来像下面这样：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, as a review we are passing in an object that we call `options` into our
    constructor. From here, we create a property called `options` that is for that
    instance of `Video`, and this property will get set to an extended or merged version
    of the options and defaults using Zepto's extend method. Then, we cache the element
    that was sent via the merged options. This might be a bit confusing, but it is
    a very well recognized pattern in JavaScript applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回顾一下，我们将一个称为`options`的对象传递给我们的构造函数。从这里，我们创建一个名为`options`的属性，用于`Video`的实例，这个属性将使用Zepto的extend方法设置为选项和默认值的扩展或合并版本。然后，我们缓存通过合并选项发送的元素。这可能有点令人困惑，但在JavaScript应用程序中，这是一个非常公认的模式。
- en: 'Since we have verified that our constructor exists and is doing fine, we now
    want to add the previous listeners. We can easily do this using the native `addEventListener`
    method as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经验证了我们的构造函数存在并且运行良好，现在我们想要添加先前的监听器。我们可以使用本地的`addEventListener`方法轻松地做到这一点，如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are a couple of things to note here. First, we are using `this.options.element`
    instead of the cached version `this.$element`. We do this because we actually
    want the element and not a `Zepto` object. Second, we are calling `addEventListener`
    and passing it two parameters. The first parameter is a string that defines the
    event we want to listen to. The second parameter is a callback function, which
    gets called every time that the event we specified in parameter one fires.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情需要注意。首先，我们使用`this.options.element`而不是缓存版本的`this.$element`。我们这样做是因为我们实际上想要元素而不是`Zepto`对象。其次，我们调用`addEventListener`并传递两个参数。第一个参数是一个字符串，定义了我们要监听的事件。第二个参数是一个回调函数，每当我们在参数一中指定的事件触发时都会被调用。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we are using the `console.log()` method. It is similar to `alert()`
    except without all the annoyances. It helps debug better and outputs to a console
    that lets us keep track of all our log output. Using this method is a good way
    of debugging our applications and testing out functionality before going further.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用`console.log()`方法。它类似于`alert()`，但没有那么烦人。它有助于更好地调试，并输出到一个控制台，让我们跟踪所有的日志输出。在继续之前，使用这种方法是调试我们的应用程序和测试功能的好方法。
- en: 'Your constructor should now look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您的构造函数现在应该如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Initializing our video
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化我们的视频
- en: 'Now that we have a preliminary video class defined, we need to initialize it.
    So let''s go ahead and open up `main.js`, where our initialization code should
    be located. It should look something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个初步的视频类，我们需要初始化它。所以让我们继续打开`main.js`，我们的初始化代码应该在那里。它应该看起来像这样：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We created this in the previous chapter, but let's go over it briefly. Here
    we are creating a closure, passing it the `window` and `document` objects. Inside,
    we set the interpreter to read our code strictly. We then create an instance of
    the overall `App` class and then expose it to the `window` object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中创建了这个，但让我们简要地回顾一下。在这里，我们创建了一个闭包，传递了`window`和`document`对象。在内部，我们设置解释器严格地读取我们的代码。然后我们创建了`App`类的一个实例，然后将其暴露给`window`对象。
- en: 'Now we need to add the initialization of the `Video` class. To do this, let''s
    put the following snippet of code after we declare a new instance of `App`, as
    follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加`Video`类的初始化。为此，让我们在声明`App`的新实例之后放入以下代码片段，如下所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This snippet creates a new instance of the `App.Video` class or the `Video`
    class, and passes in a simple object containing the element. The way we retrieve
    an element is through the use of the `getElementsByTagName` method attached to
    the `document` object. We tell the method to look for all the video elements.
    The interesting part is `[0]`, which tells the results of the lookup to only get
    the first one in the array that is returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段创建了`App.Video`类或`Video`类的一个新实例，并传入一个包含元素的简单对象。我们通过使用附加到`document`对象的`getElementsByTagName`方法来检索元素。我们告诉方法查找所有的视频元素。有趣的部分是`[0]`，它告诉查找结果只获取返回的数组中的第一个元素。
- en: 'If we load our page and test the video, we should have the log output we defined
    earlier in our console, similar to the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载页面并测试视频，我们应该在控制台中看到我们之前定义的日志输出，类似于以下的截图：
- en: '![Initializing our video](img/1024_02_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![初始化我们的视频](img/1024_02_01.jpg)'
- en: Video log output
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 视频日志输出
- en: We've got the preliminary aspects of our `Video` class going, from events to
    initialization. However, we need to tidy it up a bit if we are going to make it
    reusable for our application, and if we ever want to extend its functionality.
    So let's take some time creating a fully functional JavaScript video library that
    will work in our iPhone web applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始了`Video`类的初步工作，从事件到初始化。然而，如果我们要使它可重用于我们的应用程序，并且如果我们想要扩展其功能，我们需要稍微整理一下。因此，让我们花一些时间创建一个完全功能的JavaScript视频库，它将在我们的iPhone网络应用程序中工作。
- en: Creating a JavaScript video library
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个JavaScript视频库
- en: At the moment, we have a very simple `Video` class that caches an element and
    then attaches multiple events that are defined by the media element specification
    for HTML5\. We have defined the essentials of a video player and now need to abstract
    it a bit further so it can be reused and managed much better. Following some conventions
    and creating a flexible framework will help us move faster and more effectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个非常简单的`Video`类，它缓存一个元素，然后附加了多个由HTML5媒体元素规范定义的事件。我们已经定义了视频播放器的基本要素，现在需要进一步抽象，以便更好地重用和管理。遵循一些约定并创建一个灵活的框架将帮助我们更快更有效地移动。
- en: 'First, let''s think about some things we may want from this class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一些可能需要从这个类中得到的东西：
- en: An events method that attaches the proper events
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个附加适当事件的事件方法
- en: Callback methods that can be defined, for example, `onPlay`, `onPause`, and
    `onEnded`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义的回调方法，例如`onPlay`，`onPause`和`onEnded`
- en: Public methods that can be called from outside the instance
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从实例外部调用的公共方法
- en: Chainable methods similar to jQuery where you can call one method after another,
    for example, `fadeIn().fadeOut().show().hide()`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于jQuery的可链接方法，您可以依次调用一个方法，例如`fadeIn().fadeOut().show().hide()`
- en: Having a list of items that abstract the behavior of a class is a step in the
    right direction for establishing a solid framework or library. Now let's start
    by creating callbacks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个抽象类行为的项目列表是建立一个坚实框架或库的正确方向。现在让我们开始创建回调。
- en: Centralizing our events
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中我们的事件
- en: First, let's tackle how we attach the events for our `Video` class. Previously,
    we added these events to the constructor, and although that is a fine technique,
    it can definitely be improved by specifying a function that handles the attachment
    of events onto an instance of a `Video` object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解决如何为我们的`Video`类附加事件。以前，我们将这些事件添加到构造函数中，虽然这是一种不错的技术，但可以通过指定一个处理事件附加到`Video`对象实例的函数来改进。
- en: 'So, let''s create a private method called `attachEvents` in the `Video` class
    that can only be accessed within the `App.Video` closure or IIFE. When we create
    our method `attachEvents`, we should just place all our event handlers into it.
    We then want to call the `attachEvents` method after we initialize `this.$element`.
    When you''re done doing this, your code should look like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们在`Video`类中创建一个名为`attachEvents`的私有方法，该方法只能在`App.Video`闭包或IIFE中访问。当我们创建我们的`attachEvents`方法时，我们应该将所有的事件处理程序放在其中。然后我们希望在初始化`this.$element`之后调用`attachEvents`方法。完成后，您的代码应该如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the previous code, the `attachEvents()` function will contain our event handlers
    created earlier. For the sake of brevity, I'm omitting them for now.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`attachEvents()`函数将包含我们之前创建的事件处理程序。为了简洁起见，我现在省略了它们。
- en: Now, if we run this code we'll most likely run into a couple of errors. This
    is actually normal and is known as a scope issue. In order to fix the problem,
    first we'll sidestep to understand what's going on behind the scenes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这段代码，很可能会遇到一些错误。这实际上是正常的，被称为作用域问题。为了解决这个问题，首先我们需要了解幕后发生了什么。
- en: Scope in JavaScript
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript中的作用域
- en: If you're new to JavaScript, scope will most likely confuse you sooner or later.
    If you're at an intermediate or advanced level in JavaScript, you might still
    have scope issues. This is completely normal and is something that we all come
    across. Either way, let's take our current `Video` class and analyze it to understand
    scope in context.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是JavaScript的新手，作用域很可能会在早晚困扰您。如果您在JavaScript中处于中级或高级水平，您可能仍然会遇到作用域问题。这是完全正常的，我们都会遇到这种情况。无论如何，让我们拿出当前的`Video`类并分析一下，以便在上下文中理解作用域。
- en: JavaScript has function-level scope, this means that every time a new function
    is created, we create a new scope. Scope can be quite confusing, but with practice
    it becomes easier. For now think of scopes as a reference to your current position,
    aware of itself and its environment, but unaware of newly created scopes inside
    it. If it sounds confusing, it can be when you get started. But let's go over
    some code to gain a better understanding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript具有函数级作用域，这意味着每次创建新函数时，都会创建一个新的作用域。作用域可能会相当令人困惑，但通过实践会变得更容易。现在把作用域看作是对当前位置的引用，它知道自己和它的环境，但不知道在它内部新创建的作用域。如果听起来令人困惑，当你开始时可能会有些困惑。但让我们通过一些代码来更好地理解一下。
- en: 'So, let''s start with the global scope:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们从全局范围开始：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, a stripped down version of `App.Video`, we can see that the
    global scope is around the closure. When we create a closure, a new scope is created.
    The cool thing here is that anything outside of the closure can get accessed.
    So when we do `console.log` inside the closure, we should get back `10`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`App.Video`的简化版本中，我们可以看到全局作用域在闭包周围。当我们创建一个闭包时，会创建一个新的作用域。这里很酷的一点是，闭包外的任何东西都可以被访问到。因此，当我们在闭包内部执行`console.log`时，我们应该得到`10`。
- en: Whenever you create a new function scope, you can pass it parameters that essentially
    namespace the value you're sending. In this case, we pass in `Zepto` and we tell
    the new function scope to define the dollar sign as an instance of `Zepto` inside
    that scope. Hopefully that explains scope a bit more clearly, if not, don't worry
    about it; it does take time and patience to understand this concept.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你创建一个新的函数作用域时，你可以传递参数，本质上是给你发送的值命名空间。在这种情况下，我们传入`Zepto`，并告诉新的函数作用域在该作用域内将美元符号定义为`Zepto`的实例。希望这能更清楚地解释作用域，如果不清楚，不要担心；理解这个概念需要时间和耐心。
- en: 'So, the problem with our event handlers is the fact that the new function scope,
    inside of `attachEvents`, does not have a reference to `this.options`. The keyword
    `this` is relative to the window object because of the new scope. The reason it
    doesn''t have a reference is because our constructor is a completely different
    scope, and the two are not speaking with each other. To fix this problem, we can
    use the `.call()` method, which will change the reference of the `this` keyword
    to reflect the `Video` function scope. It can be done by changing the call of
    `attachEvents` like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们事件处理程序的问题在于`attachEvents`内的新函数作用域没有对`this.options`的引用。由于新的作用域，关键字`this`相对于窗口对象，而不是`Video`对象。它没有引用的原因是因为我们的构造函数是一个完全不同的作用域，它们之间没有交流。为了解决这个问题，我们可以使用`.call()`方法，它将改变`this`关键字的引用，以反映`Video`函数作用域。可以通过修改`attachEvents`的调用来实现：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you run your code now, you should not get any errors. If you do, take a look
    at the finalized version of the code in order to do a comparison and figure out
    the issue.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的代码，你不应该得到任何错误。如果有的话，看看代码的最终版本，进行比较并找出问题所在。
- en: Exposing functionality
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露功能
- en: Later on in this chapter, we will be exploring custom user interfaces that help
    us override the default functionality of a video player. However, in order to
    do this we need to make sure some functionality is exposed. In JavaScript, in
    order to make methods public outside of the closure, we need to attach methods
    to the prototype of `class`—in this case, `Video`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将探索自定义用户界面，帮助我们覆盖视频播放器的默认功能。然而，为了做到这一点，我们需要确保一些功能是公开的。在JavaScript中，为了使方法在闭包之外公开，我们需要将方法附加到`class`的原型上——在这种情况下是`Video`。
- en: We can already see that we have two methods that are exposed within all our
    classes; these include `getDefaults` and the overriding function `toString`. Let's
    start extending the prototype by adding the `play`, `pause`, `stop`, `mute`, `unmute`,
    and `fullscreen` methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们的所有类中都暴露了两个方法；这些包括`getDefaults`和重写函数`toString`。让我们通过添加`play`、`pause`、`stop`、`mute`、`unmute`和`fullscreen`方法来扩展原型。
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I'm sure you have noticed the lack of code in these methods, and that's fine.
    What we want to understand is that we can extend the `Video` prototype, and that
    we can add chaining to our methods by returning the instance with the `return
    this` line.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经注意到这些方法中缺少了代码，没关系。我们想要理解的是，我们可以扩展`Video`原型，并且可以通过在`return this`行中返回实例来为我们的方法添加链式调用。
- en: 'Let''s start adding functionality to our methods, beginning with `play`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为我们的方法添加功能，从`play`开始：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here we are getting the element we''ve cached in the constructor of `Video`
    by calling the `play` method. You might be wondering where this `play` method
    is coming from? Well, the HTML5 specification defined a `play` method for media
    elements, including video and audio. Thus, we can tap into this method using `this.element.play()`.
    We can do the same with the `pause` method as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过调用`play`方法获取了我们在`Video`构造函数中缓存的元素。你可能想知道这个`play`方法是从哪里来的？嗯，HTML5规范为媒体元素（包括视频和音频）定义了一个`play`方法。因此，我们可以使用`this.element.play()`来调用这个方法。我们可以用同样的方法来调用`pause`方法：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Again, we have a method defined by the HTML5 specification for pausing a media
    element. Things get a bit confusing when we define a `stop` method as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有一个由HTML5规范定义的暂停媒体元素的方法。当我们定义一个`stop`方法时，事情变得有点混乱：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's the same as previous; we actually haven't made any changes. Let me explain,
    the specification does not define a `stop` method, so it's up to us to create
    one so that we can provide that functionality. But it's not too difficult because
    we've defined a `pause` method that does a similar action. So all we need to do
    is call `this.pause()`, because this is an instance of `Video` and we have a `pause`
    method defined. The neat thing here is that we don't need to return `this`, because
    the pause method already returns `this`, and so all we need to do is return the
    results of calling the `pause` method. I know it's a bit confusing but over time,
    if this is the first time you're doing this, it will become clear.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样；我们实际上没有做任何改变。让我解释一下，规范没有定义`stop`方法，所以我们需要创建一个方法来提供这个功能。但这并不太困难，因为我们已经定义了一个执行类似操作的`pause`方法。所以我们需要做的就是调用`this.pause()`，因为这是`Video`的一个实例，我们已经定义了一个`pause`方法。这里的巧妙之处在于我们不需要返回`this`，因为暂停方法已经返回了`this`，所以我们只需要返回调用`pause`方法的结果。我知道这有点令人困惑，但随着时间的推移，如果这是你第一次这样做，它会变得清晰起来。
- en: 'Now, on to our `mute` and `unmute` methods:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看我们的`mute`和`unmute`方法：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The only difference in these methods is that we are setting a property on the
    video element to `false`. In this case, we are setting the muted property to either
    `true` or `false`, depending on what method you call.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的唯一区别在于我们在视频元素上设置了一个属性为`false`。在这种情况下，我们将静音属性设置为`true`或`false`，取决于你调用的方法。
- en: 'Here is where things get a bit complicated:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的事情变得有点复杂：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a bit more complicated, and probably a bit frustrating. Trust me, many
    within the industry are feeling the pain. What we need to understand here is that
    the browser we are dealing with, Safari, runs on an engine called WebKit—an open
    source web browser engine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂，可能有点令人沮丧。相信我，行业内的许多人都感到痛苦。我们需要理解的是，我们正在处理的浏览器Safari是运行在一个名为WebKit的开源网络浏览器引擎上。
- en: WebKit is extremely popular and widely supported. The issue is that while it
    does a great job at implementing the latest and greatest features, many of these
    are experimental and thus, they have a prefix added to them. We see this a lot
    in CSS (Cascading Style Sheets) using `–webkit`. But we also face the same problem
    in JavaScript, `webkit[standardMethodName]`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: WebKit非常受欢迎并得到广泛支持。问题在于，虽然它在实现最新和最好的功能方面做得很好，但其中许多是实验性的，因此它们具有前缀。我们在CSS（层叠样式表）中经常看到这一点，使用`-webkit`。但在JavaScript中，我们也面临相同的问题，`webkit[standardMethodName]`。
- en: While this may be awesome, we need to make sure that we have backward compatibility
    for newer versions that strip out that prefix. This is why, in the previous method,
    we do a check on the standard method name, and if it doesn't exist, we use the
    `-webkit` prefix. Otherwise, we use the standard version.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能很棒，但我们需要确保我们对剥离该前缀的新版本具有向后兼容性。这就是为什么在上一个方法中，我们对标准方法名称进行检查，如果不存在，我们使用`-webkit`前缀。否则，我们使用标准版本。
- en: Integrating callbacks
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成回调
- en: 'Callbacks are quite useful in any library or framework, and you''ve probably
    already seen something like it using jQuery or some other popular framework. In
    essence, a callback is a method that gets called once the method has completed.
    For example, in the `Zepto` method, `fadeout` accepts two parameters, the first
    being the speed, and the second parameter is a function that gets called when
    the fading has completed. This can be seen as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 回调在任何库或框架中都非常有用，您可能已经在使用jQuery或其他一些流行框架时看到过类似的东西。实质上，回调是在方法完成后调用的方法。例如，在`Zepto`方法中，`fadeout`接受两个参数，第一个是速度，第二个参数是在淡出完成时调用的函数。可以如下所示：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second parameter in the previous code is not only a callback function,
    but also an anonymous function. An anonymous function is just a function without
    a name. In this case, it is executed every time the `fadeOut()` effect is finished.
    We can rewrite the previous code as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码中的第二个参数不仅是一个回调函数，还是一个匿名函数。匿名函数只是一个没有名称的函数。在这种情况下，它在每次`fadeOut()`效果完成时执行。我们可以将上一个代码重写如下：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since we have created a method called `someFadeOutFunc`, when `fadeOut` is complete
    we'll just call that function instead of creating a new one. This is more efficient
    and manageable from an architecture standpoint.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了一个名为`someFadeOutFunc`的方法，当`fadeOut`完成时，我们只需调用该函数，而不是创建一个新函数。从架构的角度来看，这更有效和可管理。
- en: 'The first step in the process of creating callbacks is to define where we may
    want callbacks in our code. In this case, we may want a callback for each action
    taken in the video player, so we''ll create the following callbacks:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建回调的第一步是定义我们在代码中可能需要回调的位置。在这种情况下，我们可能希望为视频播放器中采取的每个操作创建一个回调，因此我们将创建以下回调：
- en: '`onCanPlay`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCanPlay`'
- en: '`onSeeking`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSeeking`'
- en: '`onSeeked`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSeeked`'
- en: '`onEnded`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onEnded`'
- en: '`onPlay`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPlay`'
- en: '`onPause`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause`'
- en: '`onLoadedData`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoadedData`'
- en: '`onLoadedMetaData`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoadedMetaData`'
- en: '`onTimeUpdate`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onTimeUpdate`'
- en: '`onFullScreen`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onFullScreen`'
- en: 'Ok, so now that we know which callbacks we want in our code, let''s implement
    them in the constructor, right before the `attachEvents` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道我们的代码中需要哪些回调，让我们在`attachEvents`方法之前的构造函数中实现它们：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What we've done here is attached a property, known as `callbacks`, onto an instance
    of `Video`. This property contains an object that has key/value pairs for each
    callback we want to implement, with the value being an empty anonymous function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将一个名为`callbacks`的属性附加到`Video`的实例上。该属性包含一个对象，该对象为我们想要实现的每个回调设置了键/值对，值是一个空的匿名函数。
- en: Extending callbacks
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展回调
- en: 'Although we can have our callbacks within the class, the problem is that they
    are not extensible, meaning the developers using your `Video` class won''t be
    able to extend your callbacks. In order to make them extensible, we need to put
    them within our `_defaults` object:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在类中使用回调，但问题在于它们不具有可扩展性，这意味着使用您的`Video`类的开发人员将无法扩展您的回调。为了使它们具有可扩展性，我们需要将它们放在我们的`_defaults`对象中：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The drawback is that now we would need to use `this.options.callbacks` in order
    to access the callback we want. This can be easily fixed by doing the following
    in our constructor:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是现在我们需要使用`this.options.callbacks`来访问我们想要的回调。通过在我们的构造函数中执行以下操作，可以轻松解决这个问题：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will still allow us to access the callback, but only from the extended
    object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然允许我们访问回调，但只能从扩展对象中访问。
- en: Using callbacks
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用回调
- en: 'Now that we have our callbacks, and have made them extensible, we can go in
    and integrate them into our event handlers. But first, we need to make our event
    handlers as private methods in this `Video` class and call our custom callbacks
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了回调，并且已经使它们具有可扩展性，我们可以进入并将它们集成到我们的事件处理程序中。但首先，我们需要将我们的事件处理程序作为私有方法放在这个`Video`类中，并按以下方式调用我们的自定义回调：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, we have our callbacks fully integrated into our library. Now,
    we just need to call them by modifying the `attachEvents` handler as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经完全将我们的回调集成到我们的库中。现在，我们只需要通过修改`attachEvents`处理程序来调用它们，如下所示：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are a couple of concepts being implemented here. First, we've replaced
    `console.logs` with the actual private methods that we have defined previously.
    Second, we used the `call` method to change the scope of the `private` method
    by passing in `that`, then we sent in `event` and `element` as parameters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里实施了一些概念。首先，我们用之前定义的实际私有方法替换了`console.logs`。其次，我们使用`call`方法通过传入`that`来更改`private`方法的范围，然后将`event`和`element`作为参数发送进去。
- en: Tying it all up
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容联系起来
- en: We have everything we need, such as event handlers, exposed functionality, callbacks,
    and even chainable methods. That's all good, but now we need to make it work.
    This is where the magic comes in.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有一切所需的东西，如事件处理程序、公开功能、回调，甚至可链接的方法。这都很好，但现在我们需要让它起作用。这就是魔法发挥作用的地方。
- en: 'To verify, your `Video` class should look something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证，您的`Video`类应该如下所示：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the ellipsis in the previous code denote that there should
    be functionality. Due to page count limitations, we can only showcase a brief
    summary of the code up to this point. If you need to see what has been done, please
    review the previous sections or checkout the source code with this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上一段代码中的省略号表示应该有功能。由于页面数量的限制，我们只能展示到目前为止代码的简要摘要。如果您需要查看已完成的工作，请查看前面的部分或查看本书附带的源代码。
- en: If your file looks like this, perfect! If it doesn't look quite like this, don't
    worry about it, this is why we have the source code attached with this book. At
    this point, we're ready to initialize this library on our page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的文件看起来像这样，那就太完美了！如果它看起来不太像这样，不要担心，这就是为什么我们在这本书中附上了源代码。在这一点上，我们已经准备好在我们的页面上初始化这个库了。
- en: 'Let''s open up our `main.js` file; the file should be located under the `js`
    directory. We need to make the following addition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`main.js`文件；该文件应该位于`js`目录下。我们需要进行以下添加：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s go through this quickly. First, we create a new instance of `App.Video`,
    passing in one parameter— a simple object. Second, the object we are passing in
    contains two objects: the `video` element we want on the page, and a callbacks
    object that overrides defaults. The first parameter is using the built in method
    `getElementsByTagName` to get all the instances of the `video` element, and then
    we get the first one found using `[0]`. This is because that method returns an
    array. The second parameter, `callbacks`, contains the function callbacks we want
    to be called on this instance of `App.Video`. All we want to do in these methods
    is log out the method being called.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下。首先，我们创建一个新的`App.Video`实例，传入一个参数——一个简单的对象。其次，我们传入的对象包含两个对象：我们想要在页面上的`video`元素，以及一个覆盖默认值的回调对象。第一个参数使用内置方法`getElementsByTagName`来获取`video`元素的所有实例，然后我们使用`[0]`获取找到的第一个实例。这是因为该方法返回一个数组。第二个参数`callbacks`包含我们想要在`App.Video`实例上调用的函数回调。在这些方法中，我们只想要记录被调用的方法。
- en: From here on, when the instance is initialized the `Video` library we've defined
    will merge the simple object we've passed in and take it from there. Almost like
    magic, except we've created it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，当实例被初始化时，我们定义的`Video`库将合并我们传入的简单对象，并从那里开始。几乎就像魔术一样，除了我们已经创建了它。
- en: 'One last item to take care of is to make sure we only initialize a video when
    we are on the video page. If we are on a non-video page in our application, this
    code will produce an error. This is because there are no video elements and we
    have not added error detection. This is a good thing to have, but will not be
    covered in this book. So, let''s do the following in `main.js`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，确保我们只在视频页面上初始化视频。如果我们在应用程序的非视频页面上，这段代码将产生一个错误。这是因为没有视频元素，我们也没有添加错误检测。这是一个很好的功能，但本书不涵盖这部分。因此，让我们在`main.js`中做以下操作：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous code, we are wrapping our initialization code within an `if`
    statement, checking to make sure that we are on the video page. The way we do
    a check is by using the built in method on the document object called `querySelector`.
    This method accepts a CSS type selector, in this case we are sending the `video`
    selector, telling it to get all the instances of a `video` element. If the result
    coming back is not null, then we initialize.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将我们的初始化代码包装在一个`if`语句中，检查我们是否在视频页面上。我们进行检查的方式是使用文档对象上的内置方法`querySelector`。这个方法接受一个CSS类型的选择器，在这种情况下，我们发送`video`选择器，告诉它获取所有`video`元素的实例。如果返回的结果不是null，那么我们就初始化。
- en: Now we don't need to do anything with the markup, this code will run and we
    should be good. If for some reason you come up with any errors, please take a
    look at the source code provided with this book. Next, let's consider overwriting
    the default controls of this video player to give us more control over the functionality.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不需要对标记做任何事情，这段代码将运行，我们应该没问题。如果由于某种原因您遇到任何错误，请查看本书附带的源代码。接下来，让我们考虑覆盖视频播放器的默认控件，以便更好地控制功能。
- en: Customizing HTML5 video controls
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义HTML5视频控件
- en: 'We probably want more input into the video controls, from styling to video
    functionality, such as adding a stop button. In order to do this we need to modify
    our markup a bit. We should do the following with the video:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望对视频控件有更多的输入，从样式到视频功能，比如添加停止按钮。为了做到这一点，我们需要稍微修改我们的标记。我们应该对视频做以下操作：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All we did here was add a class containing `div` around the `video` element
    and added a class of `video-container` to it. Now we want to add some responsive
    styling to the `video` element, so let''s open up `video.css` and add the following
    styles:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是在`video`元素周围添加了一个包含`div`的类，并给它添加了一个`video-container`的类。现在我们想要为`video`元素添加一些响应式样式，所以让我们打开`video.css`并添加以下样式：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first selector will apply to all the `video` elements on the page, and we
    are telling each element to have a width of 100 percent relative to its container,
    but to only have a max width of `640px`. The margin property helps it center itself
    on the page or to the container. The next selector, `video-container`, just specifies
    the width to be 100 percent. This styling will resize the player accordingly;
    you can check it out by resizing your browser.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选择器将应用于页面上的所有`video`元素，并告诉每个元素相对于其容器具有100%的宽度，但最大宽度为`640px`。边距属性有助于使其在页面或容器中居中。下一个选择器`video-container`只指定宽度为100%。这种样式将相应地调整播放器的大小；您可以通过调整浏览器大小来查看。
- en: For this example, we'll use basic controls using the anchor element. Keep in
    mind that you can use any sort of styling or markup to style your controls, just
    remember that we have exposed our video playback in our `Video` class, so to keep
    it short and simple, we'll just demonstrate how you can do this using the anchor
    element.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用锚元素来使用基本控件。请记住，您可以使用任何类型的样式或标记来设计您的控件，只要记住我们已经在我们的`Video`类中公开了视频播放，所以为了简洁起见，我们将演示如何使用锚元素来实现这一点。
- en: 'In our `video-container` dive, we want to append the following markup:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`video-container`中，我们想要附加以下标记：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous markup is what we will be using for our controls. They are pretty
    straightforward, but let's review a couple of decisions that were made here. One,
    we have a surrounding `div` with a class of `video-controls` to help define where
    all our controls will exist. Two, each type of control is prefixed with `vc`,
    standing for video controls. Three, in this example we have four types of controls,
    namely a state, track, volume, and full screen control. The final point is that
    some of these controls have show/hide functionality, for example, play and pause
    should only show when the others cancel out.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的标记是我们将用于控件的标记。它们非常直观，但让我们回顾一下这里做出的一些决定。首先，我们有一个带有`video-controls`类的周围`div`，以帮助定义我们所有控件的存在位置。其次，每种类型的控件都以`vc`为前缀，代表视频控件。第三，在这个例子中，我们有四种类型的控件，即状态、轨道、音量和全屏控件。最后一点是，其中一些控件具有显示/隐藏功能，例如，播放和暂停只有在其他控件取消时才会显示。
- en: 'For styling, we can add the following styles to the `video.css` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于样式，我们可以将以下样式添加到`video.css`文件中：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this bit of styling, we self-contain all video control styling to the `video-controls`
    class. This helps in maintaining styles in a modular pattern. Again, following
    responsive design principles, we tell the controls to have a width of 100 percent.
    Then, each type of control is set to display as inline-blocks, similar to `float`.
    Lastly, we tell all default controls that are not supposed to appear initially
    to have a display of none. Now, we need to add interactivity to our controls.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '在这一部分的样式中，我们将所有视频控件样式自包含到`video-controls`类中。这有助于以模块化的方式维护样式。再次遵循响应式设计原则，我们告诉控件宽度为100%。然后，每种类型的控件都设置为显示为内联块，类似于`float`。最后，我们告诉所有默认控件，它们不应该在初始时显示，所以设置为`display:
    none`。现在，我们需要为我们的控件添加交互性。'
- en: 'First, let''s create an `App.VideoControls` class that follows our entire framework:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个遵循整个框架的`App.VideoControls`类：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see, there''s not much difference here. The only thing is that we
    now have an `init` method that gets called. This is to separate out initialization
    functionality elsewhere so that the constructor is not completely populated with
    code. Now we need to add the following defaults:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里并没有太大的区别。唯一的区别是现在有一个被调用的`init`方法。这是为了将初始化功能分离到其他地方，以便构造函数不完全被代码填满。现在我们需要添加以下默认值：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Just as a review of these defaults, the first default is a features array, allowing
    the developer tapping into this code to customize what we need initialized. The
    second default keeps the state of the controls, namely play, pause, and so on.
    The third is a state specifically for sound. The classes default allows us to
    use custom classes, thus the developer using this `videocontrols` class isn't
    limited to the classes we've defined in the markup. The last is an events default
    that defines the custom events we want to be dispatched. By including it in our
    defaults, the developer can now customize these as well.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这些默认值的回顾，第一个默认值是一个特性数组，允许开发人员进入这段代码来自定义我们需要初始化的内容。第二个默认值保持控件的状态，即播放、暂停等。第三个是专门用于声音的状态。类默认值允许我们使用自定义类，因此使用这个`videocontrols`类的开发人员不受我们在标记中定义的类的限制。最后一个是事件默认值，定义了我们想要分发的自定义事件。通过将其包含在我们的默认值中，开发人员现在也可以自定义这些事件。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you can notice, a lot goes into building a video player that can be reused
    and implemented correctly across a web application of any kind. Putting effort
    does help out in the end, although it is very difficult at the beginning. Now
    we can add and remove functionality in a much more modular way.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，构建一个可以在任何类型的网络应用程序中重复使用和正确实现的视频播放器需要很多工作。尽管一开始非常困难，但付出努力最终会有所帮助。现在我们可以以更模块化的方式添加和删除功能。
- en: Due to the fact that there's a lot of code that goes into creating custom controls
    that mimic those in native controls, we've decided to leave the rest of the functionality,
    including show/hide and triggering custom events, in the source code for your
    review. Don't worry though, everything is commented and if you do have questions,
    I encourage you to e-mail me or ask your fellow colleagues for help.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建模仿原生控件的自定义控件需要大量的代码，我们决定将其余的功能，包括显示/隐藏和触发自定义事件，留在源代码中供您审查。不过不用担心，所有内容都有注释，如果您有问题，我鼓励您给我发电子邮件或向您的同事寻求帮助。
- en: 'Now, we want to implement the communication between the controls and the video
    player. But first, we need to clean the `main.js` file a bit. So, let''s remove
    the following code from `main.js`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要实现控件和视频播放器之间的通信。但首先，我们需要清理一下`main.js`文件。因此，让我们从`main.js`中删除以下代码：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We don't want this code in `main.js` because it will be shared among all the
    applications built in this book, so what we need to do is extrapolate it. For
    this reason, we have created another JavaScript file named `App.VideoController.js`
    in our `js/App` directory. This file is also included with the source code of
    this book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望这段代码出现在`main.js`中，因为它将在本书中构建的所有应用程序之间共享，所以我们需要将其抽离出来。因此，我们在`js/App`目录中创建了另一个名为`App.VideoController.js`的JavaScript文件。这个文件也包含在本书的源代码中。
- en: 'Please open the `App.VideoController.js` file included with this book, and
    find the `initControls` method; it should look like the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请打开本书附带的`App.VideoController.js`文件，并找到`initControls`方法；它应该看起来像下面这样：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's briefly review what is going on in this method to understand it better.
    First, we are telling our `video` element to hide its controls. This is done by
    removing the `controls` attribute. Then we cache our `controls` div in `controlsEle`.
    Next, we initialize our `App.VideoControls` class and pass it in the cached `controls`
    div. Finally, we add listeners to the cached video controls and listen to the
    custom events that we have defined in our defaults of `App.VideoControls`. These
    listeners then call the methods we have exposed in `App.Video` by telling the
    instance, `video`, to run the appropriate function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下这个方法中正在发生的事情，以便更好地理解它。首先，我们告诉我们的“video”元素隐藏它的控件。这是通过移除“controls”属性来实现的。然后我们将我们的“controls”
    div 缓存在“controlsEle”中。接下来，我们初始化我们的“App.VideoControls”类，并将其传递给缓存的“controls” div。最后，我们为缓存的视频控件添加监听器，并监听我们在“App.VideoControls”默认值中定义的自定义事件。这些监听器然后通过告诉实例“video”运行适当的函数来调用我们在“App.Video”中公开的方法。
- en: 'The last issue we need to take care of is initializing this whole program.
    Since we removed the initialization in `main.js`, we need to start it elsewhere.
    The best place would be on the specific `index.html`, which would be `video/index.html`.
    So, let''s open up this file and include the following script at the bottom of
    the page, right after the inclusion of `main.js`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理的最后一个问题是初始化整个程序。由于我们在“main.js”中删除了初始化，我们需要在其他地方开始它。最好的地方应该是在特定的“index.html”上，即“video/index.html”。因此，让我们打开这个文件，并在页面底部包含以下脚本，就在“main.js”包含之后。
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This was the last item to take care of. When we run our page, we should have
    a fully functional video player that runs off our customized controls.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后需要处理的事项。当我们运行我们的页面时，我们应该有一个完全功能的视频播放器，它可以使用我们定制的控件。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Give yourself a big pat on the back, because you have accomplished quite a bit!
    Not only do you have a video player with customized controls, but you have built
    a solid video library that ties into the HTML5 specification and works on the
    iPhone. We have gone over the HTML5 specification for video integration, created
    a simple video player that used native controls, built a fully functional and
    modular video library, extended the video library with a controls class that customizes
    our experience, and finally created a controller class that hooks up both the
    video and the customized controls. On the way, we've taken some time to understand
    scopes in JavaScript, the prototype, and the usefulness of callbacks. If at any
    point you had some trouble with the concepts taught in this chapter, please review
    the source code with this book, and as always, practice makes perfect. The next
    chapter should be easier since we'll take the concepts we've learned here and
    apply them to audio.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 给自己一个大大的鼓励，因为你已经取得了相当大的成就！你不仅拥有了一个带有定制控件的视频播放器，而且还建立了一个符合HTML5规范并在iPhone上运行的稳固视频库。我们已经研究了HTML5规范的视频集成，创建了一个使用原生控件的简单视频播放器，构建了一个完全功能和模块化的视频库，用一个控件类扩展了视频库，定制了我们的体验，并最终创建了一个控制器类，将视频和定制控件连接起来。在这个过程中，我们花了一些时间来理解JavaScript中的作用域、原型和回调的有用性。如果在本章教授的概念中的任何时候你遇到了一些困难，请通过本书查看源代码，并且一如既往地，实践是完美的。下一章应该会更容易，因为我们将把我们在这里学到的概念应用到音频上。
