- en: Chapter 7. Interactivity using JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用JavaScript进行交互
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Playing audio files with JavaScript
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript播放音频文件
- en: Using the drag-and-drop API with text
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本的拖放API
- en: Crossbrowser video support with `vid.ly` and jQuery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`vid.ly`和jQuery实现跨浏览器视频支持
- en: Displaying video dynamically using jQuery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery动态显示视频
- en: Movable video ads using jQuery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery创建可移动的视频广告
- en: Controlling the display of images using `Easel.js` and the `canvas` tag
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Easel.js`和`canvas`标签控制图像的显示
- en: Animating a sequence of images using `Easel.js` and the `canvas` tag
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Easel.js`和`canvas`标签来显示一系列图像的动画
- en: Random animation with audio using the `canvas` tag and JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`canvas`标签和JavaScript进行随机动画和音频
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: While HTML5 may put an end to the use of Flash for many rich media applications,
    it is causing JavaScript to become even more popular than before. There are many
    libraries and plugins available to enhance and extend HTML5 and CSS3 to create
    rich interactive experiences.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTML5可能会结束对Flash的许多丰富媒体应用程序的使用，但它正在导致JavaScript比以前更受欢迎。有许多库和插件可用于增强和扩展HTML5和CSS3，以创建丰富的交互体验。
- en: This chapter contains recipes that show how JavaScript can be used with HTML5
    tags, such as audio, video, and canvas, as well as CSS3 selectors and elements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了一些示例，展示了JavaScript如何与HTML5标签（如音频、视频和画布）、CSS3选择器和元素一起使用。
- en: Playing audio files with JavaScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript播放音频文件
- en: HTML5 introduces more flexibility in how audio files are used on the Internet.
    In this recipe, we will create a game to practice loading and playing sounds using
    the audio tag and JavaScript.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5在互联网上如何使用音频文件提供了更多的灵活性。在这个示例中，我们将创建一个游戏，练习使用音频标签和JavaScript加载和播放声音。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need an audio file to play, an image, and a modern browser that supports
    HTML5\. The example files for this chapter can be downloaded from [http://www.packtpub.com/support?nid=7940](http://www.packtpub.com/support?nid=7940).
    The Free Sound Project ([http://freesound.org](http://freesound.org)) has audio
    files you can use as long as credit is given to the producer, and photos can be
    found at [http://www.Morguefile.com](http://www.Morguefile.com) for use in your
    personal projects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个要播放的音频文件，一张图片，以及支持HTML5的现代浏览器。本章的示例文件可以从[http://www.packtpub.com/support?nid=7940](http://www.packtpub.com/support?nid=7940)下载。Free
    Sound Project ([http://freesound.org](http://freesound.org))有您可以使用的音频文件，只要给予制作人信用，照片可以在[http://www.Morguefile.com](http://www.Morguefile.com)找到，供您在个人项目中使用。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Now we are ready to create a series of buttons and a short JavaScript program
    that will play a random audio file when one of the buttons is pushed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建一系列按钮和一个简短的JavaScript程序，当其中一个按钮被按下时，它将播放一个随机的音频文件。
- en: Open up your HTML editor and create the opening section of an HTML5 page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的HTML编辑器并创建一个HTML5页面的开头部分。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because we only have a few styles, we will add them to the head area of the
    HTML page.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只有一些样式，我们将把它们添加到HTML页面的head区域。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Three variables need to be created for the script. The opening script tag and
    variables should look like the following code block:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本需要创建三个变量。打开脚本标签并创建变量，应该看起来像下面的代码块：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have created the global variables for the script, we can create
    the functions. Type `function whackmole(){` to begin the function, then on a new
    line type `var i = Math.floor(Math.random() * 5)`; to generate a somewhat random
    number using the JavaScript math library. Next, type `soundChoice = mySounds[i]`;
    to assign the array value to `soundChoice`. Close out the function with `soundElements[soundChoice].play();}`.
    Your function code should currently look like the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为脚本创建了全局变量，我们可以创建函数。键入`function whackmole(){`开始函数，然后在新行上键入`var i = Math.floor(Math.random()
    * 5)`;使用JavaScript数学库生成一个随机数。接下来，键入`soundChoice = mySounds[i]`;将数组值分配给`soundChoice`。使用`soundElements[soundChoice].play();}`关闭函数。您的函数代码目前应该看起来像下面的代码：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Type `function init(){` to begin the function. On a new line, type `soundElements
    = document.getElementsByTagName("audio");} </script>` to complete our block of
    JavaScript code. It should look like the following code block:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`function init(){`开始函数。在新行上，键入`soundElements = document.getElementsByTagName("audio");}
    </script>`来完成我们的JavaScript代码块。它应该看起来像下面的代码块：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Close the head tag and type the body tag, adding an `init()` function call
    to it so it looks like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭head标签并键入body标签，添加一个`init()`函数调用，使其看起来像：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a heading area for the header area of the page using the `<header>`
    tag. Use the heading tag `<h1>` to display the title of the page:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<header>`标签为页面的头部区域创建一个标题区域。使用标题标签`<h1>`显示页面的标题：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are five buttons to create a balanced look, and they are all assigned
    a class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个按钮来创建一个平衡的外观，它们都被分配了一个类。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The third button has a class name of `crosshairthree` to give us more control
    over positioning it on the screen.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个按钮的类名为`crosshairthree`，以便我们更好地控制它在屏幕上的位置。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you are using the code files from this book, the sound file tags should
    look similar to the code block below:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用本书的代码文件，那么音频文件标签应该类似于下面的代码块：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finish the page with the closing tags:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下标签完成页面：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save the file as `playing-audio-files-with-javascript.html` and view it in
    your browser. It should look similar to the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为`playing-audio-files-with-javascript.html`并在浏览器中查看。它应该看起来类似于以下屏幕截图：
- en: '![How to do it...](img/1048_07_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_07_01.jpg)'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we created the beginnings of a basic HTML5 page. Then, we added CSS styles
    to add background images to buttons and change the mouse icon to a crosshair when
    the mouse or pointing device moved over a button. This gave us a visual simulation
    of a targeting weapon and was more fun than a default mouse icon.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个基本的HTML5页面。然后，我们添加了CSS样式，为按钮添加了背景图像，并在鼠标或指向设备移动到按钮上时将鼠标图标更改为十字准星。这给我们提供了一个视觉模拟的瞄准武器，比默认的鼠标图标更有趣。
- en: 'Three variables were created to use in the script: `mySounds, soundElements`,
    and `soundch`. The first function we created named `whackmole()` contained an
    internal variable `i` that held the result of a randomly generated number. `Math.random()`
    caused a pseudorandom number to be generated. We then multiplied it by `5`, the
    number of our audio files, and used the result in `Math.floor()` to create a whole
    number with a value ranging from zero to five. This value was then assigned to
    the temporary variable `i` that in turn was used to populate the variable `mySounds`
    with a randomly generated array value. This new array value, was stored in the
    variable `soundChoice` with `soundChoice = mySounds[i]`;. This enabled us to trigger
    the `play()` action of the `audio` tag using `soundElements[soundChoice].play()`;
    when a button was pressed.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了三个变量以在脚本中使用：`mySounds，soundElements`和`soundch`。我们创建的第一个函数名为`whackmole()`包含一个内部变量`i`，该变量保存了随机生成的数字的结果。`Math.random()`导致生成一个伪随机数。然后我们将其乘以`5`，我们的音频文件数量，并将结果用于`Math.floor()`以创建一个值范围从零到五的整数。然后将该值分配给临时变量`i`，然后用于使用随机生成的数组值填充变量`mySounds`。将新的数组值存储在变量`soundChoice`中，`soundChoice
    = mySounds[i]`。这使我们能够在按下按钮时使用`soundElements[soundChoice].play()`触发`audio`标签的`play()`动作。
- en: The second function we created was `init()`, which we later tied to the `body`
    tag using `onLoad`, so that we could grab an audio file with `getElementsByTagName`
    using the `audio` tag and its array value, as carried in the `soundElements` variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第二个函数是`init()`，稍后我们将其与`onLoad`一起绑定到`body`标签，以便我们可以使用`audio`标签及其数组值在`soundElements`变量中获取音频文件。
- en: Next, we added the body tag `<body onLoad="init();">`, and a series of buttons
    containing our adorable mole image to the page. Each of the buttons contained
    an `onClick()` event which invoked the `whackmole()` function. Our third button
    had a different class than the others, `crosshairthree`, which added additional
    margin to the left of the button, giving it a more centered appearance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了`<body onLoad="init();">`标签，并在页面上添加了一系列包含可爱的鼹鼠图像的按钮。每个按钮都包含一个`onClick()`事件，该事件调用了`whackmole()`函数。我们的第三个按钮与其他按钮的类不同，`crosshairthree`，它在按钮左侧添加了额外的边距，使其看起来更加居中。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Firefox currently has a quirk, where if you don't list the `.ogg` audio source
    first, it will not find it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox目前存在一个怪癖，如果您不首先列出`.ogg`音频源，它将无法找到它。
- en: Finally, we added the sound files to the page using the `<audio>` and `<source>`
    tags. The `ogg` and `mp3` formats for each file were listed using the source tag.
    Because the source tag is considered a "child" of the parent audio tag it is surrounded
    by, either file format would play, depending on the browser used, as different
    browsers currently prefer different sound file formats.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`<audio>`和`<source>`标签将声音文件添加到页面中。使用源标签列出了每个文件的`ogg`和`mp3`格式。因为源标签被认为是其所包围的父音频标签的“子级”，所以根据使用的浏览器不同，任何文件格式都会播放，因为不同的浏览器目前更喜欢不同的声音文件格式。
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can see it would be very easy to create an app such as a child's read aloud
    page of shapes or animals by playing a different sound file for different images.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，通过为不同的图像播放不同的声音文件，非常容易创建一个类似于儿童读物的形状或动物的页面的应用程序。
- en: Controlling the appearance of audio clips with jQuery
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用jQuery控制音频剪辑的外观
- en: 'The `.animate` function in jQuery opens up new ways to cause audio controls
    to appear, fade, and disappear when actions are taken by visitors or as part of
    a rich media experience. Following is an example of how you could fade and audio
    control away then cause it to quickly reappear:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中的`.animate`函数为使音频控件在访问者采取行动时出现，淡出和消失提供了新的方法，这是丰富媒体体验的一部分。以下是一个示例，演示了如何使音频控件淡出，然后迅速重新出现：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will perform a similar trick using a video file in a recipe in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的一个示例中使用视频文件执行类似的技巧。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 8](ch08.html "Chapter 8. Embracing Audio and Video"), *Embracing Audio
    and Video* will cover a lot more information about the audio tag and ways to use
    it.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。拥抱音频和视频") *拥抱音频和视频*将涵盖有关音频标签及其使用方式的更多信息。'
- en: Using the drag-and-drop API with text
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文本的拖放API
- en: While all browsers can natively drag images or links, dropping objects used
    to require complex JavaScript or third-party libraries. The drag-and-drop API
    is intended to provide an easier, standardized way to enable users to drop any
    type of object into an identified area. In reality, working with the API across
    browsers is a challenge. The main browsers currently supporting this API are Firefox,
    Chrome, and Safari.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有浏览器都可以本地拖动图像或链接，但放置对象以前需要复杂的JavaScript或第三方库。拖放API旨在提供一种更简单，标准化的方式，使用户能够将任何类型的对象放入标识区域。实际上，在不同浏览器中使用该API是一项挑战。目前主要支持此API的浏览器是Firefox，Chrome和Safari。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Download the code for this tutorial at [http://www.packtpub.com/support?nid=7940](http://www.packtpub.com/support?nid=7940).
    The font used in the heading of this tutorial is from [http://www.fontsquirrel.com](http://www.fontsquirrel.com),
    where you can also download a different font if you choose. This tutorial may
    not work with Internet Explorer. We will be creating a tic-tac-toe game that demonstrates
    how the drag-and-drop API works.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://www.packtpub.com/support?nid=7940](http://www.packtpub.com/support?nid=7940)下载本教程的代码。本教程标题中使用的字体来自[http://www.fontsquirrel.com](http://www.fontsquirrel.com)，您也可以在那里下载不同的字体。本教程可能无法在Internet
    Explorer中使用。我们将创建一个井字棋游戏，演示拖放API的工作原理。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open up your HTML editor and start by creating a basic HTML5 page. We will add
    two stylesheet links, one to support an `@fontface` font we will be loading for
    the header of the page, and our main stylesheet. Type the code as shown below,
    then save the file as `using-drag-drop-api.html`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的HTML编辑器，首先创建一个基本的HTML5页面。我们将添加两个样式表链接，一个用于支持我们将为页面标题加载的`@fontface`字体，另一个用于我们的主样式表。输入以下代码，然后将文件保存为`using-drag-drop-api.html`。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's go ahead and style the page. Create or open up a CSS file named `stylesheet.css`.
    Set the overall `margin` for the `body` of the page to `100px` and the default
    color to `#666`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续为页面添加样式。创建或打开名为`stylesheet.css`的CSS文件。将页面的整体`margin`设置为`100px`，默认颜色设置为`#666`。
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The content tags for the page should all be set to `display:block` as shown
    in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的内容标签应该都设置为`display:block`，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we specify the `@fontface` information. The code and font files are from
    a `www.fontsquirrel.com` font kit, which is included in the code files of this
    tutorial.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们指定`@fontface`信息。代码和字体文件来自于`www.fontsquirrel.com`字体包，该字体包包含在本教程的代码文件中。
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Add a color for the `h1` tag and set the `font-family` property to `3DumbRegular`,
    the name of our font.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为`h1`标签添加颜色，并将`font-family`属性设置为`3DumbRegular`，这是我们字体的名称。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new div called `gametilebox` to hold the letters that will make up
    the game tiles. Set the `float` property of the box to `left` and the width and
    height to `280px`. Set the `padding, margin-right, border`, and `background-color`
    as shown in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`gametilebox`的新div来容纳组成游戏块的字母。将该框的`float`属性设置为`left`，宽度和高度设置为`280px`。按照以下代码片段中所示的方式设置`padding,
    margin-right, border`和`background-color`。
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The game board will share many of the same properties as the tile box, so copy
    the styles for the `gametilebox`, paste, and name the copy "gameboard". Add a
    `background-image` property with a url of `images/tictactoegrid.jpg`, and set
    the `background-color` to `aa`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏板将共享许多与瓷砖框相同的属性，因此复制`gametilebox`的样式，粘贴并命名为“gameboard”。添加一个`background-image`属性，其url为`images/tictactoegrid.jpg`，并将`background-color`设置为`aa`。
- en: 'The `gameboard div` should look like the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameboard div`应该看起来像以下代码：'
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s style the `div` blocks in which to place our letters. The `float` should
    be set to `left` on all of the `block` divs. The `width` should be no greater
    than `85px`, the `height` no greater than `80px`. They will be on a 3 by 3 grid,
    so the first block on the second and third rows need to have a `clear:both` property
    as well. The third block on the second and third row should have low to none `padding`
    and `margin-right` properties. Because there are nine of them, only a sample of
    the block code is shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为放置字母的`div`块添加样式。所有`block` div的`float`应该设置为`left`。`width`不应大于`85px`，`height`不应大于`80px`。它们将位于3x3的网格上，因此第二行和第三行的第一个块也需要具有`clear:both`属性。第二行和第三行的第三个块应该具有较低或没有`padding`和`margin-right`属性。因为有九个，所以这里只显示了一个块代码的示例：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will set the styles for the letter game tiles. Create a new class in
    the stylesheet named `lettertile`, then set the properties for the class as shown
    here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为字母游戏块设置样式。在样式表中创建一个名为`lettertile`的新类，然后按照以下方式设置类的属性：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last style we will add is for the `draggable` attribute. Create the style
    below to help with cross-browser compatibility:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的最后一个样式是`draggable`属性。创建下面的样式以帮助跨浏览器兼容性：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The stylesheet is complete, so now we can work on the script to drag the letter
    tiles and drop them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表已经完成，现在我们可以开始编写脚本来拖动字母块并放置它们。
- en: 'Open up the previously created html page `using-drag-drop-api.html`, and type
    the following code for IE browsers:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 打开先前创建的html页面`using-drag-drop-api.html`，并为IE浏览器键入以下代码：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Add a opening `<script>` tag directly below the stylesheet link, and type the
    first function, `dragDefine(ev)`, which accepts an event argument, and follow
    it with a `{`. After the curly brace, type `ev.dataTransfer.effectAllowed ='move'`;
    then, on a new line, type `ev.dataTransfer.setData("text/plain", ev.target.getAttribute('id'))`;
    to set the data type and the target attribute. Finally, type `return true`; with
    a closing `}` to complete the function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式表链接的下面添加一个开放的`<script>`标签，并键入第一个函数`dragDefine(ev)`，它接受一个事件参数，然后跟着一个`{`。在大括号之后，键入`ev.dataTransfer.effectAllowed
    ='move'`；然后，在新的一行上，键入`ev.dataTransfer.setData("text/plain", ev.target.getAttribute('id'))`；以设置数据类型和目标属性。最后，键入`return
    true`；并加上一个闭合的`}`以完成函数。
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we need to define the `dragOver` function. Type `dragOver(ev)` and an
    opening `{`, then invoke the `preventDefault()` function by adding `ev.preventDefault()`;.
    The function block should look similar to the one below:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义`dragOver`函数。键入`dragOver(ev)`和一个开放的`{`，然后通过添加`ev.preventDefault()`来调用`preventDefault()`函数。函数块应该类似于下面的代码：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The next function we need is one to indicate that the drag is complete. Type
    `function dragEnd(ev)`, then an opening `{`. Type `return true; }` to complete
    the function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个函数是指示拖动完成的函数。键入`function dragEnd(ev)`，然后输入`{`。键入`return true; }`以完成函数。
- en: 'Type `function dragDrop(ev)` with an opening `{`, and go to a new line to add
    our first method. Type `var idDrag = ev.dataTransfer.getData("Text")`; to create
    a drag variable that will hold the text string then type `ev.target.appendChild
    (document.getElementById(idDrag))`;. Finish the function with `ev.preventDefault()`;.
    The function block should look like the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`function dragDrop(ev)`并打开一个`{`，然后转到新的一行添加我们的第一个方法。键入`var idDrag = ev.dataTransfer.getData("Text")`；创建一个将保存文本字符串的拖动变量，然后键入`ev.target.appendChild
    (document.getElementById(idDrag))`；。最后，键入`ev.preventDefault()`；完成函数块应该看起来像以下代码：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Close the head section of the page. Type `<body><header>`, then `<h1>Drag and
    Drop Tic Tac Toe</h1></header>` to complete the heading of the page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭页面的头部部分。键入`<body><header>`，然后`<h1>拖放井字棋</h1></header>`以完成页面的标题。
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, type `<section><h3>Drag the letters from the gray box to the game board
    (and back again!)</h3>`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，键入`<section><h3>将字母从灰色框拖到游戏板上（然后再拖回来！）</h3>`。
- en: 'Create a div with and ID of `"gametilebox"` and `ondragover ="dragOver(event)"`
    and `ondrop="dragDrop(event)"`. It should look like the following statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个ID为`"gametilebox"`的div，并设置`ondragover ="dragOver(event)"`和`ondrop="dragDrop(event)"`。它应该看起来像以下语句：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we will create a `div` for each game tile. Create six **"X"** tiles and
    six **"O"** tiles, each with an `id` that begins with `"lettertile"` and ends
    in a number in value from `1-12`. Each `div` will contain the class `"lettertile"`
    and each `draggable` attribute will contain the value `"true"`. Every tile will
    also contain `ondragstart="return dragDefine(event)"` and `ondragend="dragEnd(event)"`.
    The `div` block should look like the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为每个游戏瓷砖创建一个`div`。创建六个**"X"**瓷砖和六个**"O"**瓷砖，每个都以`"lettertile"`开头并以值从`1-12`的数字结尾的`id`。每个`div`将包含类`"lettertile"`，每个`draggable`属性将包含值`"true"`。每个瓷砖还将包含`ondragstart="return
    dragDefine(event)"`和`ondragend="dragEnd(event)"`。`div`块应该看起来像以下代码：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we can create the actual `divs` for those block styles we created in **stylesheet.css**.
    First type `<div id= "gameboard">`. There should be a `div` for each block id,
    ranging from "blockA" to "blockI". Each of them will contain an `ondragover="return
    dragOver(event)"` and an `ondrop="dragDrop(event)"`. They should look like the
    following code block.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们在**stylesheet.css**中创建的那些块样式创建实际的`divs`。首先输入`<div id= "gameboard">`。应该有一个`div`对应每个块id，从"blockA"到"blockI"。它们每个都将包含一个`ondragover="return
    dragOver(event)"`和一个`ondrop="dragDrop(event)"`。它们应该看起来像以下代码块。
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Close the page with the `body` and `html` closing tags, name the file `"using-drag-drop-api.html"`,
    then view the results in a browser window. Drag a few letters over and the results
    should look similar to the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`body`和`html`结束标签关闭页面，将文件命名为`"using-drag-drop-api.html"`，然后在浏览器窗口中查看结果。拖动几个字母，结果应该类似于以下截图：
- en: '![How to do it...drag-and-drop APIusing, with text](img/1048_07_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...拖放API使用，带有文本](img/1048_07_02.jpg)'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we created a basic HTML5 page and added a sketchy font for the heading
    using `@fontface` to give our game a fun visual look. Next, we styled the page
    by setting the `margin` for the `body` and all block level elements to `display:block`;
    to have greater control of the presentation of those elements. After styling our
    heading font, we define the `width` and `height` for the game tile box. This would
    be the container to hold the letters that make up the game tiles.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个基本的HTML5页面，并使用`@fontface`添加了一个草图字体作为标题，以使我们的游戏具有有趣的视觉效果。接下来，我们通过将`margin`设置为`body`和所有块级元素来设置页面的样式，以更好地控制这些元素的呈现。在设置标题字体样式后，我们为游戏瓷砖框定义了`width`和`height`。这将是容纳组成游戏瓷砖的字母的容器。
- en: 'We began our script by typing an special comment tag for IE browsers to point
    them to an extra script file to trigger HTML5 elements: `<!--[if IE]><script src="img/html5.js"></script><![endif]-->`
    . It was provided under the MIT license by Remy Sharp (http://remysharp.com/html5-enabling-script/)
    to keep us all sane when working with Internet Explorer.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在IE浏览器中键入一个特殊的注释标签来开始我们的脚本，以指向额外的脚本文件来触发HTML5元素：`<!--[if IE]><script src="img/html5.js"></script><![endif]-->`。这是由Remy
    Sharp (http://remysharp.com/html5-enabling-script/)根据MIT许可证提供的，可以让我们在处理Internet
    Explorer时保持理智。
- en: The function `dragDefine()` was called when a user began to drag an item. It
    first checked to see if an item was draggable using `dataTransfer.effectAllowed='move'`.
    It then set the type of data to be transferred to `text` with `dataTransfer.setData("text/plain")`
    and identified the target by the `id` using `target.getAttribute('id'))`. The
    function returns true, meaning the object can be dragged.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`dragDefine()`函数在用户开始拖动物品时被调用。它首先使用`dataTransfer.effectAllowed=''move''`来检查物品是否可拖动。然后使用`dataTransfer.setData("text/plain")`设置要传输的数据类型为`text`，并使用`target.getAttribute(''id''))`来识别目标的`id`。该函数返回true，表示可以拖动对象。'
- en: Next, we defined the `dragOver` function, which is called when an item being
    dragged is over another item, and accepts an event argument shown as `ev` that
    is then used to invoke `preventDefault()` to allow the item to be dropped. The
    drag-and-drop API specification clearly states that we must cancel dragging in
    order to then prepare to drop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`dragOver`函数，当被拖动的物品位于另一个物品上方时调用，接受一个名为`ev`的事件参数，然后用它来调用`preventDefault()`以允许放置物品。拖放API规范明确规定，我们必须取消拖动，然后准备放置。
- en: The function `dragEnd()` was then created to return a value of true when drag
    is complete. It also accepted an event argument.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建了`dragEnd()`函数，在拖动完成时返回true。它还接受一个事件参数。
- en: After completing all the dragging functions we were ready to create the code
    to drop the item. The `dragDrop()` function took an event argument and used that
    value to get the value of the text object, which it then passed to a new variable
    `var idDrag` to hold the text string, which in turn was used by `getElementById`
    to identify the correct element ID to drop. Just as with `dragEnd()`, we had to
    indicate it was ok to drop the object by calling the `preventDefault()` function
    from the drag-and-drop API.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有拖动功能后，我们准备创建代码来放置物品。`dragDrop()`函数接受一个事件参数，并使用该值获取文本对象的值，然后将其传递给一个新变量`var
    idDrag`来保存文本字符串，然后再使用`getElementById`来识别正确的元素ID进行放置。与`dragEnd()`一样，我们必须调用拖放API中的`preventDefault()`函数来指示可以放置对象。
- en: After we closed the head area of the page, in the body we placed the content
    boxes to hold our letter tiles and game board. These were made up of two parent
    div containers which each held child divs containing letter tiles or sections
    of the game board grid.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭页面的头部区域后，我们在正文中放置了内容框来容纳我们的字母瓷砖和游戏板。这些由两个父div容器组成，每个容器都包含包含字母瓷砖或游戏板网格部分的子div。
- en: The game tile box invoked the `dragOver()` function whenever a letter tile was
    dragged over it. The letter tile divs themselves were made draggable by `draggable="true"`
    and returned `dragDefine()` whenever they were dragged. When dragging stopped,
    they invoked the `dragEnd()` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每当字母瓷砖被拖动到游戏瓷砖框上时，游戏瓷砖框都会调用`dragOver()`函数。字母瓷砖div本身通过`draggable="true"`可拖动，并在拖动时返回`dragDefine()`。拖动停止时，它们调用`dragEnd()`函数。
- en: Because we wanted the letter tiles to drop and stay in a specific area of the
    game board, we created divs for each individual block on the grid to hold our
    letters in place when they are dropped onto the board that would also return the
    `dragOver` event when an object was dragged over them, and invoke `dragDrop()`
    when an object was dropped on them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望字母瓦片在游戏板的特定区域内下落并停留，所以我们为网格上的每个单独块创建了div，以便在它们被放置到板上时保持我们的字母位置，并在对象被拖动到它们上时返回`dragOver`事件，并在对象被放置到它们上时调用`dragDrop()`。
- en: Why bother with the block divs? We could have set up our game tile box on the
    left and the game board on the right and been done. The result would have been
    that when we dragged tiles from the left box to the game board, they would have
    dropped onto it and lined up in the order they were dropped instead of where we
    wanted to place them. This default behavior is fine when you want to sort a list,
    but not when control over precisely where an object is placed is needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用块div？我们本可以在左边设置我们的游戏瓦片框，在右边设置游戏板，然后完成。结果将是，当我们从左边的框拖动瓦片到游戏板时，它们会被放置在上面，并按照它们被放置的顺序排列，而不是我们想要放置它们的位置。当您想要对列表进行排序时，默认行为是可以接受的，但当需要精确控制对象放置位置时，就不行了。
- en: We needed to override the default behavior that results when objects are dropped.
    We created nine game board blocks, all the same basic size. The main changes for
    each one were to the `padding` and `margin`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要覆盖对象被放置时产生的默认行为。我们创建了九个游戏板块，都是相同的基本大小。每个块的主要变化是`padding`和`margin`。
- en: Spend a few moments reading up on the drag-and-drop specification at [http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html)
    and you will notice they explicitly state they are only defining a drag-and-drop
    mechanism, and not what operation you have to perform. Why? Users with a smart
    phone or other touch screen device may not have a pointing device such as a mouse.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 花一些时间阅读[http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html)上的拖放规范，你会注意到他们明确表示他们只定义了一个拖放机制，而不是你必须执行的操作。为什么？使用智能手机或其他触摸屏设备的用户可能没有鼠标等指针设备。
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This demonstration of the drag and-drop API can be built into a complete game
    with scoring; a game board reset button, and other interactive elements in several
    ways.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放API的演示可以通过多种方式构建成一个完整的游戏，包括计分；游戏板重置按钮和其他交互元素。
- en: Create a canvas-based tic-tac-toe game
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基于画布的井字棋游戏
- en: Two canvases could be used, one for the game tile box and another for the game
    board. The boards and game tiles could be dynamically drawn using canvas, and
    then scores or messages such as "you win" could be written to the screen.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两个画布，一个用于游戏瓦片框，另一个用于游戏板。可以使用画布动态绘制板和游戏瓦片，然后将分数或消息（如“你赢了”）写入屏幕。
- en: Show responsive messages as the user plays
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在用户玩游戏时显示响应消息
- en: Remy Sharp has a great demo online at [http://html5demos.com/drag-anything](http://html5demos.com/drag-anything)
    showing how to display messages on the screen when an object is dropped.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Remy Sharp在[http://html5demos.com/drag-anything](http://html5demos.com/drag-anything)上有一个很棒的演示，展示了当对象被放置时如何在屏幕上显示消息。
- en: 'The source tag of the object to be dropped would be similar to:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置的对象的源标记可能类似于：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The "drop zone" box when the object would be dragged to might look like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被拖动到时，“放置区”框可能看起来像：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the image was dropped into the box, instead of the image, you would see
    the text contained in "data-science-fact".
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像被放置到框中时，您会看到包含“data-science-fact”的文本，而不是图像。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Packt book on jQuery, other recipes in this book, an advanced HTML5 Packt book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的Packt书籍，本书中的其他配方，高级HTML5 Packt书籍。
- en: Crossbrowser video support with vid.ly and jQuery
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用vid.ly和jQuery支持跨浏览器的视频
- en: Supporting most browsers requires encoding a video into multiple formats, then
    serving up the right one to a browser. In this recipe we will use an online video
    display library named vid.ly ([http://www.vid.ly](http://www.vid.ly)) to prepare
    and share a video on a page reliably across multiple browsers and make the background
    color change over time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 支持大多数浏览器需要将视频编码为多种格式，然后将正确的格式提供给浏览器。在这个示例中，我们将使用一个名为vid.ly的在线视频显示库([http://www.vid.ly](http://www.vid.ly))来在多个浏览器上可靠地准备和分享视频，并使背景颜色随时间变化。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a video to upload to [http://www.vid.ly](http://www.vid.ly). Some
    browsers do not allow files to be served locally, so you may also want a location
    where you can upload your files and test pages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个视频上传到[http://www.vid.ly](http://www.vid.ly)。一些浏览器不允许本地提供文件，因此您可能还需要一个可以上传文件并测试页面的位置。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Type `<!DOCTYPE html> <html lang="en"> <head>`, then begin adding style declarations
    by typing `<style type="text/css"> h2{color:#303;}`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`<!DOCTYPE html> <html lang="en"> <head>`，然后开始添加样式声明，键入`<style type="text/css">
    h2{color:#303;}`。
- en: 'Style a div to contain featured content: `#featured {position:relative; padding:
    40px; width: 480px; background-color:#000000; outline: #333 solid 10px; }`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '样式化一个包含特色内容的div：`#featured {position:relative; padding: 40px; width: 480px;
    background-color:#000000; outline: #333 solid 10px; }`。'
- en: 'Type `video {padding: 3px;background-color:black;}` to create the style for
    the video tag, then add a closing `</style>` tag.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '键入`video {padding: 3px;background-color:black;}`来创建视频标记的样式，然后添加一个闭合的`</style>`标记。'
- en: Declare the scripts used in the page. Type `<script src="img/jquery.min.js"
    type="text/javascript" charset="utf-8"></script>` to reference a minimized version
    of the main jQuery library. Then, type `<script type="text/javascript" src="img/jquery-ui.min.js"></script>`
    to reference the jQuery UI library used for the color change effect. Finally,
    we will reference our own script by typing `<script type="text/javascript" src="img/mycolor.js"></script>`
    just before the closing `</head>` tag.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 声明页面中使用的脚本。输入`<script src="img/jquery.min.js" type="text/javascript" charset="utf-8"></script>`来引用主要jQuery库的最小化版本。然后，输入`<script
    type="text/javascript" src="img/jquery-ui.min.js"></script>`来引用用于颜色变化效果的jQuery
    UI库。最后，我们将引用我们自己的脚本，通过在关闭`</head>`标签之前输入`<script type="text/javascript" src="img/mycolor.js"></script>`。
- en: Enter an opening `<body>` and `<section>` tag, then type `<header> <h2>Featured
    Video</h2></header>` to display the page heading.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个开放的`<body>`和`<section>`标签，然后输入`<header> <h2>Featured Video</h2></header>`以显示页面标题。
- en: Now, we can create the div to hold our featured content that we styled earlier.
    Type `<div id="featured"> <p>This video was converted to cross-browser formats
    by <a href="http://vid.ly">vid.ly</a></p>`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个div来容纳我们之前设计的特色内容。输入`<div id="featured"> <p>此视频已通过<a href="http://vid.ly">vid.ly</a>转换为跨浏览器格式</p>`。
- en: 'The next step is to upload the video clips to [http://vid.ly](http://vid.ly)
    for conversion into multiple file formats. You will receive an e-mail when the
    process is complete and can then grab the code snippet for your video as seen
    in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将视频剪辑上传到[http://vid.ly](http://vid.ly)进行转换成多个文件格式。当过程完成时，您将收到一封电子邮件，然后可以获取视频的代码片段，如下面的屏幕截图所示：
- en: '![How to do it...](img/1048_07_03.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_07_03.jpg)'
- en: 'Copy the code from the site, and then paste it into your page. The `src` value
    in the video and script tag should be the URLs you were given by vid.ly. The code
    block should look like:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 复制网站上的代码，然后粘贴到您的页面中。视频和脚本标签中的`src`值应该是vid.ly给出的URL。代码块应该如下所示：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Just to add a little extra fun, let''s add another video tag to the page. Type
    the following code: `<p>Awwww it''s a baby video!</p>`, use a different id for
    the video tag and resize it as shown: `<video id="tinymovie1" controls="controls"
    width="190" height="120">`, then use the same source tag: `<source src="img/7m5x7w?content=video"/><script
    id="vidjs" language="javascript" src="img/html5.js"></script></video>`, and close
    the page: `</div> </section></body></html>` . Save the file as `display-videos-using-videly.html`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加一点额外的乐趣，让我们在页面上添加另一个视频标签。输入以下代码：`<p>哎呀，这是一个宝宝视频！</p>`，为视频标签使用不同的id并调整大小如下：`<video
    id="tinymovie1" controls="controls" width="190" height="120">`，然后使用相同的源标签：`<source
    src="img/7m5x7w?content=video"/><script id="vidjs" language="javascript" src="img/html5.js"></script></video>`，然后关闭页面：`</div>
    </section></body></html>`。将文件保存为`display-videos-using-videly.html`。
- en: The last thing we are going to do is create a jQuery script to change the background
    color of the `#featured` div. Open up your editor and create a new file called
    `myColor.js`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是创建一个jQuery脚本来改变`#featured` div的背景颜色。打开您的编辑器，创建一个名为`myColor.js`的新文件。
- en: 'Type `$(document).ready(function() {` then go to a new line and type the code
    that will call the animate function and alter the background color: `$(''#featured'').animate({''backgroundColor'':''#ff3333'',
    ''color'': ''#ffffff''}, 6000);})`; .'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '输入`$(document).ready(function() {`，然后转到新行并输入将调用动画函数并改变背景颜色的代码：`$(''#featured'').animate({''backgroundColor'':''#ff3333'',
    ''color'': ''#ffffff''}, 6000);})`;。'
- en: 'Load the page in your browser, and watch the colors change as the main video
    loads. You can see the following screenshot of how it should appear:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中加载页面，观察主视频加载时颜色的变化。您可以看到以下屏幕截图显示了它应该是什么样子：
- en: '![How to do it...](img/1048_07_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_07_04.jpg)'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we created a standard HTML5 page and began adding style declarations.
    We set the position of the `featured` div to relative to have more flexibility
    in the future in case we decided to add additional jQuery effects. A strong visual
    look was created by setting the `padding` to `40px` and the `outline` color to
    a dark gray with a weight of `10px`. The default background color was set to black
    `(#000000)` to give us a high contrast color to compare the ending red background
    against.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个标准的HTML5页面，并开始添加样式声明。我们将`featured` div的位置设置为相对位置，以便在将来如果我们决定添加额外的jQuery效果时具有更大的灵活性。通过将`padding`设置为`40px`，将`outline`颜色设置为深灰色并设置为`10px`的粗细，创建了强烈的视觉效果。默认的背景颜色设置为黑色`(#000000)`，以便与最终的红色背景进行高对比度的比较。
- en: Next, we styled the `video` tag to give it a `background-color` of `black` while
    it loads. We could have also added a background image here to act as a poster.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对`video`标签进行了样式设置，使其在加载时具有黑色的`background-color`。我们还可以在这里添加一个背景图像作为海报。
- en: The base jQuery script was declared next using `<script src="img/jquery.min.js"
    type="text/javascript" charset="utf-8"></script>`. Because it does not contain
    effects such as `animate()`, we needed to also reference a minimized version of
    the jQuery UI library used for the color change effect. We then added a reference
    to our own script by typing `<script type="text/javascript" src="img/mycolor.js"></script>`.
    An alternative way to reduce the script file size further would be to create a
    custom script that contained only the animate effects from the jQueryUI library.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`<script src="img/jquery.min.js" type="text/javascript" charset="utf-8"></script>`声明了基本的jQuery脚本。因为它不包含`animate()`等效果，我们还需要引用用于颜色变化效果的jQuery
    UI库的最小化版本。然后，我们通过输入`<script type="text/javascript" src="img/mycolor.js"></script>`来添加对我们自己脚本的引用。进一步减小脚本文件大小的另一种方法是创建一个自定义脚本，其中只包含来自jQueryUI库的动画效果。
- en: Next, we created the main page content, including the links to the video on
    vid.ly. The default code vid.ly provides applies an ID of `'vidley video'` to
    the `video` tag, but that can be left out if you want to use your own style id
    or will be using a different id for each video. Another option would be to assign
    all videos the same class, then assigning them unique IDs as needed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了主页内容，包括指向vid.ly上视频的链接。 vid.ly提供的默认代码会给`video`标签应用一个ID为`'vidley video'`，但如果你想使用自己的样式ID或者为每个视频使用不同的ID，那么可以省略这一部分。另一个选择是给所有视频分配相同的类，然后根据需要分配它们唯一的ID。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 8](ch08.html "Chapter 8. Embracing Audio and Video"), *Embracing Audio
    and Video* covers the video element in more detail.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。拥抱音频和视频")，*拥抱音频和视频*更详细地介绍了视频元素。'
- en: Displaying video dynamically using jQuery
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery动态显示视频
- en: The video element gives us the power to treat videos like images and manipulate
    them in fun and exciting ways.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 视频元素使我们能够像处理图像一样处理视频，并以有趣和令人兴奋的方式操纵它们。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a video available in multiple file formats (which are provided
    in the chapter code for this book). A server to which to upload your files is
    recommended, as not all browsers play files locally in a predictable way.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个以多种文件格式提供的视频（本书的章节代码中提供了这些格式）。建议将文件上传到服务器，因为并非所有浏览器都能以可预测的方式本地播放文件。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we have to prepare an HTML5 page in which to place it. Type the opening
    tags for our page: `<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"
    /> <title>Video Explosion</title>`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要准备一个HTML5页面来放置它。输入我们页面的开头标签：`<!DOCTYPE html> <html lang="en"> <head>
    <meta charset="utf-8" /> <title>Video Explosion</title>`。
- en: Open up the `stylesheet.css` file from the downloaded code files or create a
    new file with the same name.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 打开下载的代码文件中的`stylesheet.css`文件，或者创建一个同名的新文件。
- en: 'Type the following for the body `style: body {background: white;color:#333333;
    }`, then style a div tag as shown: `div {float:left; border:1px solid #444444;padding:5px;margin:5px;
    background:#999999;}`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '为body输入以下内容`style: body {background: white;color:#333333; }`，然后按照以下方式为div标签添加样式：`div
    {float:left; border:1px solid #444444;padding:5px;margin:5px; background:#999999;}`。'
- en: 'The first unique div we need to create and style is `#featured`. Type `#featured
    {position:relative; width: 480px; background-color:#f2f1f1;}` to create the style.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要创建和样式化的第一个唯一的div是`#featured`。输入`#featured {position:relative; width: 480px;
    background-color:#f2f1f1;}`来创建样式。'
- en: Now create a div named `details` to hold a small information box. Type `#details{
    position:relative;display:block;background-color:#6CF;color:#333333; padding:10px;}`
    to create a div that will display next to the `featured` div.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`details`的div来容纳一个小的信息框。输入`#details{ position:relative;display:block;background-color:#6CF;color:#333333;
    padding:10px;}`来创建一个将显示在`featured` div旁边的div。
- en: Save the `css` file, and reference it in the head of the html page with the
    link tag by typing `<link rel="stylesheet" href="css/stylesheet.css"type="text/css"
    media="screen" charset="utf-8"/>`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`css`文件，并在html页面的头部使用链接标签引用它，输入`<link rel="stylesheet" href="css/stylesheet.css"type="text/css"
    media="screen" charset="utf-8"/>`。
- en: 'Type the following link to the main jQuery library below the stylesheet link:
    `<script src="img/jquery-latest.js" type="text/javascript" charset="utf-8"></script>`,
    then link to the jQuery UI library in this recipe''s code file by typing `<script
    type="text/javascript" src="img/jquery-ui.min.js"></script>`. Finally, add a link
    to the script we are about to create by typing `<script type="text/javascript"
    src="img/explode.js"></script>` to complete the referenced scripts.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式表链接下方输入以下主jQuery库的链接：`<script src="img/jquery-latest.js" type="text/javascript"
    charset="utf-8"></script>`，然后在这个配方的代码文件中链接到jQuery UI库，输入`<script type="text/javascript"
    src="img/jquery-ui.min.js"></script>`。最后，通过输入`<script type="text/javascript" src="img/explode.js"></script>`来添加对即将创建的脚本的引用，以完成引用的脚本。
- en: 'Create a new file and name it `explode.js`, and store it in a new subfolder
    named `js`. Type `$(document).ready(function(){}`. Between the two curly braces
    ({}) type `$(''h1'').effect(''shake'', {times:5}, 200)`; Create the statement
    that will cause content contained in the featured div tag to explode. On a new
    line, type `$(''#featured'').effect(''shake'', {times:3}, 100).delay(500).hide(''explode'',{},
    2000).slideDown(''fast'');)`; to complete the script. Your block of code should
    look similar to the following block:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并命名为`explode.js`，并将其存储在一个名为`js`的新子文件夹中。输入`$(document).ready(function(){}`。在两个大括号({})之间输入`$('h1').effect('shake',
    {times:5}, 200)`；创建一个语句，将导致featured div标签中包含的内容爆炸。在新的一行上，输入`$('#featured').effect('shake',
    {times:3}, 100).delay(500).hide('explode',{}, 2000).slideDown('fast');)`；以完成脚本。你的代码块应该类似于以下代码块：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save the file and return to the html page.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并返回到html页面。
- en: 'Add a closing tag for the `</head>`, and opening `<body>`, tag to the HTML
    file. Next, enter an opening `<header>` tag and heading text: `<h1>Featured` Moto
    Video</h1> then closing the `</header>` tag to complete the header area.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文件中添加`</head>`的闭合标签和`<body>`的开头标签。接下来，输入一个开头的`<header>`标签和标题文本：`<h1>Featured
    Moto Video</h1>`，然后输入`</header>`标签以完成头部区域。
- en: 'Create an opening `<section>` tag then create a div by typing `<div id="featured">`,
    to hold our video tag and related elements. Type `<video id="movie" width="480"
    height="360" preload controls>`, then add a source tag for each of the three video
    file types: `<source src=''motogoggles.ogv'' type=''video/ogg; codecs="theora,
    vorbis"''/> <source src=''motogoggles.mp4'' type=''video/mp4; codecs="avc1.42E01E,
    mp4a.40.2"''/> <source src=''motogoggles.webm'' type=''video/webm; codecs="vp8,
    vorbis"''/>`, then close the `</video>` tag and the featured div with `</div>`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个开头的`<section>`标签，然后输入`<div id="featured">`，来容纳我们的视频标签和相关元素。输入`<video id="movie"
    width="480" height="360" preload controls>`，然后为三种视频文件类型添加一个源标签：`<source src='motogoggles.ogv'
    type='video/ogg; codecs="theora, vorbis"'/> <source src='motogoggles.mp4' type='video/mp4;
    codecs="avc1.42E01E, mp4a.40.2"'/> <source src='motogoggles.webm' type='video/webm;
    codecs="vp8, vorbis"'/>`，然后关闭`</video>`标签和`</div>`标签。
- en: 'The final block of content is contained in the `details` div. To create it
    type `<div id="details">`, then add a heading tag with text `<h1>Details</h1>`,
    and finally a short explanatory paragraph of text: `<p>The video will explode
    then appear again!</p>`. Close out the `</div></section> </body></html>` tags.
    Save the HTML file as `exploding-video-dynamically.html`, and open it in a browser
    to see the results. They should look similar to the following screenshot, which
    shows the video breaking into sections and exploding.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的内容块包含在`details` div中。要创建它，输入`<div id="details">`，然后添加一个带有文本的标题标签`<h1>Details</h1>`，最后是一个简短的解释性文字段落：`<p>视频将爆炸然后再次出现！</p>`。关闭`</div></section>
    </body></html>`标签。将HTML文件保存为`exploding-video-dynamically.html`，在浏览器中打开以查看结果。它们应该与以下截图类似，显示视频分成几个部分并爆炸。
- en: '![How to do it...videosmanipulating, jQuery used](img/1048_07_05.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...视频操作，使用jQuery](img/1048_07_05.jpg)'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `stylesheet.css` file contained the styles for the featured div that determined
    the positioning of the video object on the page. The first important thing to
    notice is the `position` is set to `relative`. This makes it possible for us to
    move the video object and perform other actions on it using jQuery.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`stylesheet.css`文件包含了特色div的样式，确定了页面上视频对象的定位。首先要注意的是`position`被设置为`relative`。这使我们能够使用jQuery移动视频对象并对其执行其他操作。'
- en: We created a div named `details` whose `position` was also `relative` but with
    the `background-color` set to `light blue (#6CF)`. The different color will help
    visually set it apart from the video object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`details`的div，其`position`也是`relative`，但`background-color`设置为`浅蓝色(#6CF)`。不同的颜色将有助于在视觉上将其与视频对象区分开来。
- en: Next, we added the jQuery library scripts. The jQuery UI library is required
    in order for us to have access to the methods and functions contained in the `animate`
    class. We are referencing it locally in this example, but you could also link
    to it in the same way we accessed the main jQuery library.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了jQuery库脚本。为了能够访问`animate`类中包含的方法和函数，需要引用jQuery UI库。在这个例子中，我们是在本地引用它，但您也可以像访问主要的jQuery库一样链接到它。
- en: Finally, we were able to write our own script to make elements on the page shake
    and explode! We created a statement to verify that the page was ready for our
    code by typing `$(document).ready(function(){}`. This function queries the DOM
    and asks if the page is loaded and ready for the script. Using this wrapper function
    is a best practice when creating jQuery scripts. We use the alias symbol `$` for
    the jQuery function to grab the `h1` selector and apply to it the action `effect`
    containing the `shake` parameter to make the element move sideways, which in turn
    contained an argument for the number of `times` to shake the element. The interval
    of time the shake should last was defined in milliseconds, in this case `200`.
    We use the selector `$('#featured')` to grab the featured div element, and just
    like we did with the `h1` tag, we `shake` it (only three times for variety) for
    a period of `100` milliseconds per shake. Now we add a few new actions. A `delay`
    of `500` milliseconds between the `shakes` and the explosion is appended to command
    using `.delay(500)`. We then append to that the `hide` action with the parameter
    `explode`, which will occur one time by default and will last a total of `2000
    milliseconds`. After the video explodes, the `slidedown` action slides it back
    onto the screen with a parameter of `fast`. Note that the amount of time used
    in the explosion was a bit long so we could see it easily. A timing of `100-500`
    milliseconds would create a more realistic explosion effect. You could also have
    grabbed the video tag directly by using `$('video')` if you only wanted the video
    itself and not the background or border provided by the featured tag.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们能够编写自己的脚本来使页面上的元素摇晃和爆炸！我们创建了一个语句来验证页面是否准备好接受我们的代码，方法是输入`$(document).ready(function(){}`。这个函数查询DOM并询问页面是否已加载并准备好接受脚本。在创建jQuery脚本时，使用这个包装函数是最佳实践。我们使用别名符号`$`来调用jQuery函数，抓取`h1`选择器并对其应用包含`shake`参数的`effect`动作，使元素侧向移动，其中又包含了摇动元素的次数参数。摇动应持续的时间间隔以毫秒定义，本例中为`200`。我们使用选择器`$('#featured')`来抓取特色div元素，并像对`h1`标签所做的那样，对其进行`shake`操作（只摇动三次以增加变化），每次摇动持续`100`毫秒。现在我们添加了一些新的动作。在`shakes`和爆炸之间添加了`500`毫秒的`delay`命令，使用`.delay(500)`。然后我们附加了`hide`动作，参数为`explode`，默认情况下将发生一次，持续时间为`2000`毫秒。视频爆炸后，`slidedown`动作以`fast`参数将其滑回屏幕上。请注意，爆炸所用的时间有点长，这样我们可以更容易地看到它。使用`100-500`毫秒的时间间隔会产生更真实的爆炸效果。如果您只想要视频本身而不是特色标签提供的背景或边框，也可以直接使用`$('video')`来抓取视频标签。
- en: 'Moving back to the HTML file, we placed our video in a container div named
    `featured` and created a parent `video` tag that would `preload` and contain the
    default `controls`. Before we closed the `video` tag, we nestled a `source` tag
    for each of the three video file types within it so users with different browsers
    could watch the video: We did not provide a FLASH fallback, but we could have
    using a JavaScript library such as `Video.js`. We then closed the `</video>` tag
    and the featured div with `</div>`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回到HTML文件，我们将视频放在一个名为`featured`的容器div中，并创建了一个父`video`标签，它将`preload`并包含默认的`controls`。在关闭`video`标签之前，我们在其中嵌套了三种视频文件类型的`source`标签，以便不同浏览器的用户可以观看视频：我们没有提供FLASH回退，但我们可以使用JavaScript库，比如`Video.js`。然后我们关闭了`</video>`标签和特色div标签`</div>`。
- en: Finally we created a div to hold information about what users could expect to
    happen in the `details` div.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个div来保存关于用户可以期待在`details` div中发生的信息。
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is so much more that can be done with the video element, JavaScript, and
    the canvas tag. Read on for more experiments.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 视频元素、JavaScript和canvas标签还有很多可以做的事情。继续阅读更多实验。
- en: More interactive explosions using video and canvas
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用视频和画布进行更多交互式爆炸
- en: 'Sean Christmann at [http://www.craftymind.com](http://www.craftymind.com) has
    an amazing experiment that gives you the power to explode multiple parts of a
    video at once in real time while it plays using multiple canvases. You can check
    it out here: [http://www.craftymind.com/2010/04/20/blowing-up-html5-video-and-mapping-it-into-3d-space/](http://www.craftymind.com/2010/04/20/blowing-up-html5-video-and-mapping-it-into-3d-space/)
    but be warned — it is very resource intensive in Firefox.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Sean Christmann在[http://www.craftymind.com](http://www.craftymind.com)上有一个令人惊叹的实验，可以让您在视频播放时实时爆炸多个部分，使用多个画布。您可以在这里查看：[http://www.craftymind.com/2010/04/20/blowing-up-html5-video-and-mapping-it-into-3d-space/](http://www.craftymind.com/2010/04/20/blowing-up-html5-video-and-mapping-it-into-3d-space/)，但请注意——在Firefox中这会消耗大量资源。
- en: What's with all the explosions?
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 爆炸是怎么回事？
- en: It doesn't seem like there is any real practical reason to break apart videos
    at first. However, this could be very useful for mimicking unique transition effects
    or responses to user actions in games.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看似乎没有任何真正的实际原因来首先分解视频。然而，这对于模仿独特的过渡效果或对用户在游戏中的操作做出响应可能非常有用。
- en: Chroma key background replacement in real time
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时色度键背景替换
- en: 'Firefox developers have been experimenting with manipulating the video element.
    They created a tutorial that explained how they performed Chroma key replacement
    using canvas, JavaScript, and the attributes of the video element. You can read
    about it and view a demo at: [https://developer.mozilla.org/En/Manipulating_video_using_canvas](http://https://developer.mozilla.org/En/Manipulating_video_using_canvas).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox开发人员一直在尝试操纵视频元素。他们创建了一个教程，解释了他们如何使用画布、JavaScript和视频元素的属性执行色度键替换。您可以在[https://developer.mozilla.org/En/Manipulating_video_using_canvas](http://https://developer.mozilla.org/En/Manipulating_video_using_canvas)上阅读相关内容并查看演示。
- en: Imagine displaying a video on a website where you displayed exotic backgrounds
    or created interactive mash-ups of products and people.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在网站上显示视频，其中展示了异国情调的背景或者创建了产品和人的互动混搭。
- en: See also
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The video element is explored in depth in[Chapter 8](ch08.html "Chapter 8. Embracing
    Audio and Video"), *Embracing Audio and Video* of this book.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的[第8章](ch08.html "Chapter 8. Embracing Audio and Video")*拥抱音频和视频*中深入探讨了视频元素。
- en: Movable video ads using jQuery
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery移动视频广告
- en: We will be creating a video ad on a website that will move as the user scrolls
    down the page using jQuery and the video tag.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在网站上创建一个视频广告，当用户向下滚动页面时，它会移动，使用jQuery和视频标签。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a video file in multiple formats such as `.ogg/.ogv, .mp4`, and
    `.webm`, or use a video service such as [http://www.vid.ly.com](http://www.vid.ly.com)
    to serve cross-browser videos. This example was not tested in Internet Explorer,
    but should work fine in recent versions of Safari, Google Chrome, Opera, and Firefox.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要多种格式的视频文件，如`.ogg/.ogv, .mp4`和`.webm`，或者使用视频服务，如[http://www.vid.ly.com](http://www.vid.ly.com)来提供跨浏览器视频。这个例子没有在Internet
    Explorer中进行测试，但应该在Safari、Google Chrome、Opera和Firefox的最新版本中正常工作。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will begin by creating a typical website page. Open a new file in your editor,
    and save it as `movable-video-ad.html`. `Type <!DOCTYPE html> <html lang="en"><head><meta
    charset="utf-8" /><title>Movable Video Ad</title>` to place the first tags on
    the page.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个典型的网站页面。在编辑器中打开一个新文件，并将其保存为`movable-video-ad.html`。输入`<!DOCTYPE html>
    <html lang="en"><head><meta charset="utf-8" /><title>Movable Video Ad</title>`来放置页面上的第一个标签。
- en: Now, create a reference link for our default stylesheet `<link rel="stylesheet"
    href="css/main.css" type="text/css" media="screen" charset="utf-8" />` and a secondary
    stylesheet named `<link rel="stylesheet" href="css/scroll.css" type="text/css"
    media="screen" charset="utf-8" />`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为我们的默认样式表创建一个引用链接`<link rel="stylesheet" href="css/main.css" type="text/css"
    media="screen" charset="utf-8" />`，以及一个名为`<link rel="stylesheet" href="css/scroll.css"
    type="text/css" media="screen" charset="utf-8" />`的辅助样式表。
- en: Next, create reference links for the jQuery scripts. Type `<script src="img/jquery-1.4.min.js"
    type="text/javascript" charset="utf-8"></script>` to reference the core jQuery
    code. Add the link statement `<script type="text/javascript" src="img/jquery-ui-1.7.2.custom.min.js"></script>`.
    The final script to which we will link is our own script that we will create for
    the recipe named `myAd.js`, which will be stored in a subfolder we create named
    "js". Type `<script type="text/javascript" src="img/myAd.js"></script>` to link
    to the file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为jQuery脚本创建引用链接。输入`<script src="img/jquery-1.4.min.js" type="text/javascript"
    charset="utf-8"></script>`来引用核心jQuery代码。添加链接语句`<script type="text/javascript"
    src="img/jquery-ui-1.7.2.custom.min.js"></script>`。我们将链接到的最终脚本是我们为名为`myAd.js`的配方创建的自己的脚本，它将存储在我们创建的名为"js"的子文件夹中。输入`<script
    type="text/javascript" src="img/myAd.js"></script>`来链接到该文件。
- en: Type `</head><body><div id="container">to` begin the content area of the page.
    Display a page heading by typing `<header> <h1>Motocross Mania</h1></header>`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`</head><body><div id="container">`来开始页面的内容区域。通过输入`<header> <h1>Motocross
    Mania</h1></header>`来显示页面标题。
- en: Begin adding page content by typing `<div id="content"> <h2>No dirt = no fun</h2>`.
    The div that will contain the ad can now be added to the page by entering the
    text `<div id="motoad"><h3>Buy this movie!</h3>`, and then a movie title enclosed
    in paragraph element tags `<p><strong>MotoHelmet</strong></p>` .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 开始添加页面内容，输入`<div id="content"> <h2>No dirt = no fun</h2>`。现在可以通过输入文本`<div id="motoad"><h3>Buy
    this movie!</h3>`，然后在段落元素标签中包含电影标题`<p><strong>MotoHelmet</strong></p>`来添加包含广告的div到页面中。
- en: 'A video tag `<video width="190" height="143" preload controls>` should then
    be added. Type source tags containing each video format as shown in the following
    code block:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应该添加一个视频标签`<video width="190" height="143" preload controls>`。输入包含每种视频格式的源标签，如下面的代码块所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Close the `</div>` tag and save progress so far.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭`</div>`标签并保存目前的进展。
- en: 'Create a paragraph with an id of intro `<p id="intro">` to contain the text
    `We review the best motorcross gear ever!!!`. Follow the paragraph tag and text
    with a list of dummy links: `<ul><li><a href="#">Helmets</a></li> <li><a href="#">Gloves</a></li><li><a
    href="#">Goggles</a></li></ul>`, close the paragraph with `</p>` , then create
    a new div to contain a dummy news content block followed by two more dummy div
    blocks , a footer tag, and the closing page elements, as shown in the code block
    below:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有id为intro的段落`<p id="intro">`来包含文本`We review the best motorcross gear ever!!!`。在段落标签和文本后面跟着一个虚拟链接列表：`<ul><li><a
    href="#">Helmets</a></li> <li><a href="#">Gloves</a></li><li><a href="#">Goggles</a></li></ul>`，用`</p>`关闭段落，然后创建一个新的div来包含一个虚拟新闻内容块，然后是另外两个虚拟div块，一个页脚标签和关闭页面元素，如下面的代码块所示：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we will style the page elements in the `main.css` file. The first crucial
    style is the `#container` div. It should have a margin of `0 auto` and a width
    of `650px`. Next the `#motoad` div should be styled to `float right` and contain
    a `width` of `200px` to hold the video element. Finally, the `#intro` div should
    contain a shorter width of `450px`. The three styles should look similar to the
    code block shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`main.css`文件中为页面元素设置样式。第一个关键样式是`#container` div。它应该有一个`0 auto`的边距和`650px`的宽度。接下来，`#motoad`
    div应该被设置为`右浮动`，并包含一个`200px`的宽度来容纳视频元素。最后，`#intro` div应该包含一个较短的宽度`450px`。这三种样式应该类似于下面显示的代码块：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The rest of the styles are minor adjustments to padding and color or other standard
    declarations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的样式都是对填充和颜色或其他标准声明的微小调整。
- en: 'Now, open the `scroll.css` file to define the styles to help our ad scroll.
    We will cascade the attributes of `#motoad` to form a div block that can then
    be moved. Next, define the `height` of the `#content` attribute, and the width
    of the paragraph and `h2` elements. The styles in `scroll.css` should now look
    like:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`scroll.css`文件来定义样式，以帮助我们的广告滚动。我们将级联`#motoad`的属性，以形成一个可以移动的div块。接下来，定义`#content`属性的`height`，以及段落和`h2`元素的宽度。`scroll.css`中的样式现在应该如下所示：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save the file, and get ready to create our jQuery script.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，并准备创建我们的jQuery脚本。
- en: 'Open or create `myAd.js` and begin by typing the document ready function `$(document).ready(function(){}`
    and curly braces. Click enter between the curly braces and type the scroll function
    `$(window).scroll(function() {`. After the opening curly brace of that function
    type the command: `$(''#motoad'').stop().animate({top: $(document).scrollTop()},''slow'',''easeOutBack'')`;.
    Close the script with "});});" as well. Our jQuery script should now look like
    the following code block:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '打开或创建`myAd.js`，并开始输入文档准备函数`$(document).ready(function(){}`和花括号。在花括号之间点击enter，并输入滚动函数`$(window).scroll(function()
    {`。在该函数的开花括号后面输入命令：`$(''#motoad'').stop().animate({top: $(document).scrollTop()},''slow'',''easeOutBack'')`;。用"
    });});"关闭脚本。我们的jQuery脚本现在应该看起来像下面的代码块：'
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Save all the files and load the HTML page in a browser window. The page should
    look like the following screenshot before you begin scrolling the page.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有文件，并在浏览器窗口中加载HTML页面。在开始滚动页面之前，页面应该看起来像下面的截图。
- en: '![How to do it...](img/1048_07_06.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_07_06.jpg)'
- en: 'Try scrolling up and down the page. The ad should move up and down the page
    as well. The result should look similar to the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试上下滚动页面。广告应该随着页面的上下移动而上下移动。结果应该类似于以下截图：
- en: '![How to do it...](img/1048_07_07.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_07_07.jpg)'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After to creating a typical HTML page with different content elements, we were
    ready to style the CSS pages. We separated the CSS into two files, `main.css`
    and `scroll.css`, so that when we call the scroll function in our jQuery script
    and actively apply it, the content elements on the page shrink so that our ad
    can easily move without blocking any information on the page.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建具有不同内容元素的典型HTML页面后，我们准备为CSS页面设置样式。我们将CSS分为两个文件，`main.css`和`scroll.css`，这样当我们在jQuery脚本中调用滚动函数并积极应用它时，页面上的内容元素会缩小，以便我们的广告可以轻松移动，而不会阻塞页面上的任何信息。
- en: We wanted to cause the `#motoad` div tag to move whenever the window scroll
    event was called. To do this we use the alias symbol `$` for the jQuery function
    to grab the `window` selector from the DOM and apply to it the action `scroll`
    containing the default scroll action parameters. Using this function, we then
    created our command to control the behavior of our `#motoad` div block. We gave
    it the action of `stop`, so it would then be ready to animate. The `animate` action
    was chained to the `stop` command. The first parameter of `animate` that we applied
    to the `#motoad` div caused the div to move when the scroll bar was moved in the
    document window. The parameter `slow` controlled the speed at which the ad would
    move up and down and the parameter `easeOutBack` referenced an easing command
    to create a fluid animation movement instead of an abrupt start or stop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在调用窗口滚动事件时使`#motoad` div标签移动。为此，我们使用别名符号`$`来抓取DOM中的`window`选择器，并将其应用于包含默认滚动动作参数的`scroll`动作。使用这个函数，我们然后创建了控制`#motoad`
    div块行为的命令。我们给它了`stop`的动作，这样它就准备好进行动画了。`animate`动作被链接到`stop`命令。我们应用到`#motoad` div的`animate`的第一个参数使得div在文档窗口中的滚动条移动时移动。`slow`参数控制了广告上下移动的速度，`easeOutBack`参数引用了一个缓动命令，以创建流畅的动画运动，而不是突然开始或停止。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we've animated a custom HTML element by causing it to respond
    to user actions on the page. This just one way we can subtly add effects that
    can be used for real-world solutions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过使其响应页面上的用户操作来为自定义HTML元素添加动画效果。这只是我们可以微妙地添加效果的一种方式，可以用于实际解决方案。
- en: Have HTML element, will travel
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有HTML元素，就会旅行
- en: Explore the jQuery UI library and you will be inspired by the many ways you
    can manipulate and style any HTML element. Visit [http://jqueryui.com](http://jqueryui.com)
    for demos and documentation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 探索jQuery UI库，你会被许多可以操纵和样式化任何HTML元素的方式所启发。访问[http://jqueryui.com](http://jqueryui.com)查看演示和文档。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Learning jQuery: Better Interaction Design and Web Development with Simple
    JavaScript Techniques, available from Packt Publishing.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 学习jQuery：使用简单的JavaScript技术实现更好的交互设计和Web开发，可从Packt Publishing获取。
- en: Controlling the display of images using Easel.js and the canvas tag
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Easel.js和canvas标签控制图像的显示
- en: The JavaScript library `Easel.js` reduces the complexity of creating animations
    and rich interactive environments with the `canvas` tag. In this recipe, we will
    use a series of images in a single file named "sprites" to show how to use `Easel.js`
    to control which graphic image in the sprite is selectively displayed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript库`Easel.js`减少了使用`canvas`标签创建动画和丰富交互环境的复杂性。在这个示例中，我们将使用一个名为"sprites"的单个文件中的一系列图像，以展示如何使用`Easel.js`来控制精灵中选择性显示的图形图像。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download the `Easel.js` library or use the copy in the code
    files for this recipe.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要下载`Easel.js`库，或者使用本示例的代码文件中的副本。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the opening tags for an HTML5 file. Your code should look similar to
    the following code block:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个HTML5文件的开头标签。您的代码应该类似于以下代码块：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, link to the main stylesheet `styles.css` used in this recipe: `<link
    href="styles.css" rel="stylesheet" type="text/css" />`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，链接到在本示例中使用的主样式表`styles.css`：<link href="styles.css" rel="stylesheet" type="text/css"
    />。
- en: 'Next, we will import the `Easel.js` Framework library by inserting links to
    the following script files: `UID.js, SpriteSheetUtils.js, SpriteSheet.js, DisplayObject.js,
    Container.js, Stage.js, BitmapSequence.js`, and `Ticks.js`. You can see the path
    and link for each script file here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过插入以下脚本文件的链接来导入`Easel.js`框架库：`UID.js, SpriteSheetUtils.js, SpriteSheet.js,
    DisplayObject.js, Container.js, Stage.js, BitmapSequence.js`和`Ticks.js`。您可以在这里看到每个脚本文件的路径和链接：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, create and opening `<script>tag` and declare the following three variables:
    `var canvas;var stage;var critterSheet = new Image()`; for our script.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个开头的`<script>`标签，并声明以下三个变量：`var canvas; var stage; var critterSheet =
    new Image()`;用于我们的脚本。
- en: 'Type `function init(){` to begin the function, and follow it with `canvas =
    document.getElementById("testCanvas")`; to tie the canvas in the body of the page
    to the canvas variable. Prepare to load a new `spriteSheet` by typing `critterSheet.onload
    = handleImageLoad`;. The `critterSheet` variable stores the source of the sprite
    images. Type `critterSheet.src = "images/moles.png"`; to load our own series of
    mole images. The function block should look like the code block below:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`function init(){`开始函数，并跟随`canvas = document.getElementById("testCanvas")`;将页面主体中的canvas与canvas变量绑定。通过输入`critterSheet.onload
    = handleImageLoad`;准备加载一个新的`spriteSheet`。`critterSheet`变量存储精灵图像的来源。输入`critterSheet.src
    = "images/moles.png"`;加载我们自己的一系列鼹鼠图像。函数块应该像下面的代码块一样：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The second function we will create is `handleImageLoad()`. Type function `handleImageLoad()
    {` then `stage = new Stage(canvas)`; to create a new instance of the stage. Type
    `var spriteSheet = new SpriteSheet(critterSheet, 76, 80);to` create a new `spriteSheet`.
    Create a new bitmap sequence variable called `critter1` to live on it and define
    its position on the stage using x and y coordinates by typing: `var critter1 =
    new BitmapSequence(spriteSheet); critter1.y = 85;critter1.x = 85`;. Add a critter
    from the second image on our sprite sheet `moles.png` by typing `critter1.gotoAndStop(1)`;.
    Next, add it to the stage using the command `stage.addChild(critter1)`;.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第二个函数是`handleImageLoad()`。输入`function handleImageLoad() {`然后输入`stage =
    new Stage(canvas)`;创建一个新的stage实例。输入`var spriteSheet = new SpriteSheet(critterSheet,
    76, 80);`创建一个新的`spriteSheet`。创建一个名为`critter1`的新位图序列变量，并使用x和y坐标定义其在舞台上的位置，输入：`var
    critter1 = new BitmapSequence(spriteSheet); critter1.y = 85; critter1.x = 85`;。通过输入`critter1.gotoAndStop(1)`从我们的精灵表`moles.png`中添加一个critter。然后使用命令`stage.addChild(critter1)`将其添加到舞台上。
- en: Clone the first `critter1` variable we created, and pass its value to a new
    critter variable by typing `var critter2 = critter1.clone()`;. Position the new
    variable to the right of the first critter by adding to its current location value
    using `critter2.x += 120`;.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆我们创建的第一个`critter1`变量，并通过输入`var critter2 = critter1.clone()`将其值传递给一个新的critter变量。通过添加`critter2.x
    += 120`将新变量定位到第一个critter的右侧。
- en: 'Type `critter2.gotoAndStop(0)` to assign a value to the `critter2` variable.
    The code block for cloning critter 1 and critter 2 should look like the following
    code block:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`critter2.gotoAndStop(0)`为`critter2`变量赋值。克隆critter 1和critter 2的代码块应该如下所示的代码块：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Tick interval `Tick.setInterval(300)`; and listener `Tick.addListener(stage)`;
    are the last two statements we will add to the script. Close the brace (}) for
    the `handleImageLoad()` function, and type a closing script tag.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tick.setInterval(300)`;和`Tick.addListener(stage)`;是我们将添加到脚本的最后两个语句。关闭`handleImageLoad()`函数的大括号（}），然后输入一个闭合的脚本标签。'
- en: Close the `</head>` tag, then enter the opening `body` tag with an `onload`
    attribute that calls the `init()` function. Create a div named "description" for
    content. Add a div named `canvasHolder` to contain the canvas element. Display
    the image file `moles.png` at the bottom of the page.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭`</head>`标签，然后输入带有`onload`属性的开头`body`标签，调用`init()`函数。为内容创建一个名为"description"的div。添加一个名为`canvasHolder`的div来包含canvas元素。在页面底部显示图像文件`moles.png`。
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Save the files as `whack-mole-easel-test-single.html`. The result can be seen
    in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为`whack-mole-easel-test-single.html`。结果可以在以下截图中看到：
- en: '![How to do it...](img/1048_07_08.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_07_08.jpg)'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After we took care of setting up the beginnings of an HTML5 page we were ready
    to import the `Easel.js` framework and create our main script.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置HTML5页面的开头之后，我们准备导入`Easel.js`框架并创建我们的主要脚本。
- en: 'We created an opening `<script>tag` and declared the following global variables:
    `var canvas;var stage;var critterSheet = new Image()`; for our script.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个开头的`<script>`标签，并声明了以下全局变量：`var canvas; var stage; var critterSheet =
    new Image()`;用于我们的脚本。
- en: The function `init()which` was created would be invoked when the page is loaded.
    It contained the `canvas` variable in the process of being assigned the selector
    `testCanvas` using `document.getElementById("testCanvas");to` tie the canvas in
    the body of the page to the canvas variable. Next, we prepare to load a new `spriteSheet`
    by typing `critterSheet.onload = handleImageLoad`;. The `critterSheet` variable
    stores the source of the sprite images. Typing `critterSheet.src = "images/moles.png"`;
    gave us access to our own series of mole images.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，将调用创建的`init()`函数。它包含了`canvas`变量，该变量正在被分配选择器`testCanvas`，使用`document.getElementById("testCanvas")`将页面主体中的画布与画布变量绑定。接下来，我们准备通过输入`critterSheet.onload
    = handleImageLoad`来加载一个新的`spriteSheet`。`critterSheet`变量存储了精灵图像的来源。输入`critterSheet.src
    = "images/moles.png"`使我们能够访问我们自己的一系列鼹鼠图像。
- en: The second function we created was `handleImageLoad()`. In this function, we
    did most of our work, starting with creating a new instance of the stage using
    `stage = new Stage(canvas)`;. Next, we created a new `spriteSheet` using `var
    spriteSheet = new SpriteSheet(critterSheet, 76, 80)`; to create a new `spriteSheet`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第二个函数是`handleImageLoad()`。在这个函数中，我们做了大部分的工作，首先创建了一个舞台的新实例，使用`stage = new
    Stage(canvas)`。接下来，我们使用`var spriteSheet = new SpriteSheet(critterSheet, 76, 80)`创建了一个新的`spriteSheet`。
- en: 'Now that we had a sprite sheet instance, we could create a new bitmap sequence
    variable called `critter1` to live on it and define its position on the stage
    using x and y coordinates by typing: `var critter1 = new BitmapSequence(spriteSheet);critter1.y
    = 85;critter1.x = 85`;. Next, we referenced the frames we wanted to add by number
    so that we applied the correct action first to the critter and then to the stage.
    We linked the `critter1` variable to the second image on our sprite sheet `moles.png`
    by typing `critter1.gotoAndStop(1)`;. We added the image to the stage using the
    command `stage.addChild(critter1)`;.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个精灵图实例，我们可以创建一个新的位图序列变量，称为`critter1`，并定义其在舞台上的位置，使用x和y坐标，输入：`var critter1
    = new BitmapSequence(spriteSheet);critter1.y = 85;critter1.x = 85`。接下来，我们通过数字引用我们想要添加的帧，以便首先将正确的动作应用于critter，然后应用于舞台。我们通过输入`critter1.gotoAndStop(1)`将`critter1`变量链接到我们精灵表`moles.png`上的第二个图像。我们使用命令`stage.addChild(critter1)`将图像添加到舞台上。
- en: We cloned the first `critter1` variable we crated and passed its value to a
    new critter variable by typing `var critter2 = critter1.clone()`;. We positioned
    the new variable to the right of the first critter by adding to its current location
    value using `critter2.x += 120`;. We assigned the critter its own image from the
    `moles.png` image file by commanding the `BitSequence` to `goto` the location
    of the first image on `moles.png` and `stop` there and assign that to the `critter2`
    variable.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们克隆了我们创建的第一个`critter1`变量，并通过输入`var critter2 = critter1.clone()`将其值传递给一个新的critter变量。我们通过添加到其当前位置值来将新变量定位在第一个critter的右侧，使用`critter2.x
    += 120`。我们通过命令`BitSequence`去到`moles.png`上的第一个图像的位置，并在那里停止，并将其分配给`critter2`变量。
- en: We added `Tick.setInterval(300)`; , which applied a time period of `300` milliseconds
    between `Ticks`. The Tick interface acts as a global timing device, giving us
    the ability to return frame rates per second (FPS) if needed. We added a listener
    to the stage `Tick.addListener(stage)`; which behaves like other types of listeners
    in that it listens for ticks. This can be used to help redraw the stage at a specified
    time, or perform other timing related actions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`Tick.setInterval(300)`，在`Ticks`之间应用了`300`毫秒的时间间隔。Tick接口充当全局定时设备，使我们能够返回每秒的帧速率（FPS）（如果需要的话）。我们向舞台添加了一个监听器`Tick.addListener(stage)`，它像其他类型的监听器一样监听`Ticks`。这可以用来在指定的时间重新绘制舞台，或执行其他与时间相关的操作。
- en: We used the `onload` attribute to call the `init()` function in the `body` tag.
    This causes the `init()` function to be invoked on page load.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`onload`属性在`body`标签中调用`init()`函数。这会导致`init()`函数在页面加载时被调用。
- en: See also
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Animating a sequence* recipe.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*制作图像序列*教程。'
- en: Animating a sequence of images using Easel.js and the canvas tag
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Easel.js和canvas标签来制作图像序列动画
- en: We can animate image strips called sprites by creating arrays and functions
    using the `Easel.js` JavaScript library and then manipulating them with the `canvas`
    element. In this recipe, we will animate the same strip but display two differently
    timed sequences.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Easel.js` JavaScript库创建数组和函数来操纵`canvas`元素，从而制作称为精灵的图像条的动画。在本教程中，我们将制作相同的图像条动画，但显示两个不同时间序列。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the code files for this recipe to use the `Easel.js` framework library
    as well as supporting files. You will need a recent browser that will display
    HTML5 elements to view properly and test the code used in this recipe.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下载本教程的代码文件，使用`Easel.js`框架库以及支持文件。您需要一个能够正确显示HTML5元素并测试本教程中使用的代码的最新浏览器。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the opening tags for an HTML5 file. Your code should look similar to
    the following code block:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个HTML5文件的开头标签。您的代码应该类似于以下代码块：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Link to the main stylesheet `styles.css` used in this recipe: `<link href="styles.css"
    rel="stylesheet" type="text/css" />`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 链接到本教程中使用的主样式表`styles.css`：`<link href="styles.css" rel="stylesheet" type="text/css"
    />`。
- en: 'Import the `Easel.js` Framework library by inserting links to the following
    script files: `UID.js, SpriteSheetUtils.js, SpriteSheet.js, DisplayObject.js,
    Container.js, Stage.js, BitmapSequence.js`, and `Ticks.js`. Refer to the previous
    example for how the framework block should look.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过插入以下脚本文件的链接来导入`Easel.js`框架库：`UID.js, SpriteSheetUtils.js, SpriteSheet.js,
    DisplayObject.js, Container.js, Stage.js, BitmapSequence.js`和`Ticks.js`。参考前面的示例，了解框架块应该是什么样子。
- en: 'Create an opening `<script>` tag and declare the following three variables:
    `var canvas;var stage;var critterSheet = new Image()`; for our script.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个开头的`<script>`标签，并声明以下三个变量：`var canvas;var stage;var critterSheet = new Image()`；用于我们的脚本。
- en: Type `function init(){` to begin the function and follow it with `canvas = document.getElementById("testCanvas")`;.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`function init(){`开始函数，然后跟上`canvas = document.getElementById("testCanvas")`。
- en: 'Prepare to load a new `spriteSheet` by typing `critterSheet.onload = handleImageLoad`;.
    Type `critterSheet.src = "images/moles.png"`; to load our own series of mole images.
    The function block should look like the following code block:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 准备加载一个新的`spriteSheet`，键入`critterSheet.onload = handleImageLoad`;。键入`critterSheet.src
    = "images/moles.png"`;加载我们自己的一系列鼹鼠图像。函数块应如下所示：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The second function we will create is `handleImageLoad()`. Type function `handleImageLoad()
    {` then `stage = new Stage(canvas)`; to create a new instance of the stage. Type
    `var spriteSheet = new SpriteSheet(critterSheet, 80, 80)`; to create a new `spriteSheet`.
    Now that we have a sprite sheet, create a new bitmap sequence variable named `critter1`
    to live on it and define its position on the stage using x and y coordinates by
    typing: `var critter1 = new BitmapSequence(spriteSheet)`; and then `critter1.y
    = 100;critter1.x = 90`;. Next, we will create an array to map to each image on
    the original `spritesheet` file by entering `var frameData = {shymole:0, upmole:1,
    downmole:2, whacked:3, whackedow:4, clouds:5,tinycloud:6, cloudgroup:7}`; so that
    we have eight name values, each of which is tied to an array id.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第二个函数是`handleImageLoad()`。键入函数`handleImageLoad() {`然后`stage = new Stage(canvas)`;创建一个新的舞台实例。键入`var
    spriteSheet = new SpriteSheet(critterSheet, 80, 80)`;创建一个新的`spriteSheet`。现在我们有了一个精灵表，创建一个新的位图序列变量名为`critter1`，并使用x和y坐标定义其在舞台上的位置，键入：`var
    critter1 = new BitmapSequence(spriteSheet)`;然后`critter1.y = 100;critter1.x = 90`;。接下来，我们将创建一个数组，将其映射到原始`spritesheet`文件上的每个图像，输入`var
    frameData = {shymole:0, upmole:1, downmole:2, whacked:3, whackedow:4, clouds:5,tinycloud:6,
    cloudgroup:7}`;这样我们就有了八个名称值，每个名称值都与一个数组id相关联。
- en: 'The code block we have so far for `handleImageLoad()` should look like the
    following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`handleImageLoad()`的代码块应如下所示：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new `spriteSheet` using it as a parameter by typing: `spriteSheet
    = new SpriteSheet(critterSheet, 80, 80, frameData)`;.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键入`spriteSheet = new SpriteSheet(critterSheet, 80, 80, frameData)`;使用它作为参数创建一个新的`spriteSheet`。
- en: 'Create a new bitmap sequence variable named `critter1` and apply the image
    sprite by typing: `critter1gotoAndStop(0)`;. Add `critter1` to the `stage` using
    `stage.addchild(critter1)`;.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的位图序列变量名为`critter1`，并应用图像精灵，键入：`critter1gotoAndStop(0)`;。使用`stage.addchild(critter1)`;将`critter1`添加到`stage`中。
- en: 'Clone the first `critter1` variable, and pass its value to a new critter variable
    by typing `var critter2 = critter1.clone()`;. Define the `x` value of the new
    variable using `critter2.x += 120`;. Assign the critter its own image from the
    `moles.png` image file by typing `critter2.gotoAndStop(5)`; The code block for
    adding a new `spriteSheet`, creating `critter 1` and cloning `critter 2` should
    look like the following code block:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键入克隆第一个`critter1`变量，并将其值传递给一个新的critter变量：`var critter2 = critter1.clone()`;。使用`critter2.x
    += 120`;定义新变量的`x`值。通过键入`critter2.gotoAndStop(5)`;为`critter`分配其自己的图像。添加新的`spriteSheet`，创建`critter
    1`和克隆`critter 2`的代码块应如下所示：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Type: `var critter3 = critter2.clone(); critter3.spriteSheet = spriteSheet`;.
    Just like with the other critter variables we created earlier, redefine the `x`
    value of `critter3` by adding `10` to its current value: `critter3.x += 10`;.
    The following code block shows what we have done:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 键入：`var critter3 = critter2.clone(); critter3.spriteSheet = spriteSheet`;。就像我们之前创建的其他critter变量一样，通过将`10`添加到其当前值来重新定义`critter3`的`x`值：`critter3.x
    += 10`;。以下代码块显示了我们所做的事情：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Reference the image `frames` in `moles.png` by name by typing `critter3.gotoAndStop("upmole")`;.
    Swap the current `upmole` frame image for a different frame by cloning a new variable
    and referencing a new frame: `var critter4 = critter3.clone(); critter4.gotoAndStop("downmole")`;.
    Move that frame over `10` pixels by typing: `critter4.x += 10`;.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称引用`moles.png`中的图像`frames`，键入`critter3.gotoAndStop("upmole")`;。通过克隆一个新变量并引用一个新帧，将当前的`upmole`帧图像替换为不同的帧：`var
    critter4 = critter3.clone(); critter4.gotoAndStop("downmole")`;。通过键入将该帧向右移动`10`像素：`critter4.x
    += 10`;。
- en: 'Swap the frames out one more time and move our new frame over `10` pixels to
    the right: `var critter5 = critter4.clone(); critter5.gotoAndStop("shymole");
    critter5.x += 10`;. Let''s take a look at the block of code we should have so
    far:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 再次交换帧并将我们的新帧向右移动`10`像素：`var critter5 = critter4.clone(); critter5.gotoAndStop("shymole");
    critter5.x += 10`;。让我们看一下到目前为止我们应该有的代码块：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Cycle through the frames in our `moles.png` file by typing:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键入循环遍历我们的`moles.png`文件中的帧：
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add a second animation sequence to the stage, changing the timing of the animation
    by referencing a different starting frame when the new critter sprite is added
    to the stage: `var critter7 = critter1.clone(); critter7.x = critter6.x + 100;
    critter7.gotoAndPlay(1); stage.addChild(critter7)`;.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 向舞台添加第二个动画序列，当新的critter精灵添加到舞台时，通过引用不同的起始帧来改变动画的时间：`var critter7 = critter1.clone();
    critter7.x = critter6.x + 100; critter7.gotoAndPlay(1); stage.addChild(critter7)`;。
- en: 'Our two animation sequences should now contain the following code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个动画序列现在应包含以下代码：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The Tick interval `Tick.setInterval(200)`; and listener `Tick.addListener(stage)`;
    are the last two statements we will add to the script. Close the brace (}) for
    the `handleImageLoad()` function and type a closing script tag.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tick.setInterval(200)`;和`Tick.addListener(stage)`;是我们将添加到脚本的最后两个语句。关闭`handleImageLoad()`函数的大括号（}），然后键入一个闭合的脚本标签。'
- en: Type `</head>`, then `<body onload="init()">` . Create a div named `"description"`
    to hold content. The last div is `canvasHolder`, containing the canvas element.
    Set the width to `600`, the height to `280`, and the background color to a light
    gray `(#ccc)`. A link to the image file `moles.png` is added so users can see
    the image sprites referenced in `moles.png`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`</head>`，然后`<body onload="init()">`。创建一个名为`"description"`的div来容纳内容。最后一个div是`canvasHolder`，包含canvas元素。将宽度设置为`600`，高度设置为`280`，背景颜色设置为浅灰色`(#ccc)`。添加指向图像文件`moles.png`的链接，以便用户可以查看`moles.png`中引用的图像精灵。
- en: Save the file, and open it in a browser window. You should see a still frame
    on the left side (the image of the mole head with eyes closed) and two animation
    sequences cycling on the right side of the screen. The following screenshot shows
    how the two sequences are loading the same frames but with different timing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，并在浏览器窗口中打开。您应该在屏幕左侧看到一个静止的画面（闭着眼睛的鼹鼠头像），以及屏幕右侧循环播放的两个动画序列。以下截图显示了这两个序列如何加载相同的帧，但时间不同。
- en: '![How to do it...](img/1048_07_09.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/1048_07_09.jpg)'
- en: How it works...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first steps in the recipe of creating the HTML page and referencing the
    canvas are the same as in the previous recipe.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 创建HTML页面和引用canvas的第一步与上一个步骤相同。
- en: 'After creating the `spriteSheet`, we created a new variable to hold our sprite
    frames called `critter1` and defined the `x` and `y` coordinates for the frame
    location by typing: `var critter1 = new BitmapSequence(spriteSheet); critter1.y
    = 100;critter1.x = 90`;.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`spriteSheet`后，我们创建了一个新变量来保存我们的精灵帧，名为`critter1`，并通过输入以下内容定义了帧位置的`x`和`y`坐标：`var
    critter1 = new BitmapSequence(spriteSheet); critter1.y = 100;critter1.x = 90`。
- en: We created the array `var frameData` to declare eight key/value pairs. We were
    then able to create a new `spriteSheet` that took the parameters for a `spriteSheet`
    name, a default height and width for each frame, and loaded all the frames from
    `moles.png` at once into the `spriteSheet` using `frameData`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了数组`var frameData`来声明八个键值对。然后，我们能够创建一个新的`spriteSheet`，它接受了`spriteSheet`名称、每个帧的默认高度和宽度的参数，并使用`frameData`一次性将所有帧从`moles.png`加载到`spriteSheet`中。
- en: Next, we experimented with using `frameData` to reference frames by number value
    and name key, creating a series of bitmap sequences, then replacing them with
    their clones.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试使用`frameData`通过数字值和名称键引用帧，创建一系列位图序列，然后用它们的克隆替换它们。
- en: We animated sequences and placed them on the stage. They both followed the same
    format but started their animation sequences on different frames by changing the
    number argument in the `gotoAndPlay` action.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对序列进行了动画处理，并将它们放置在舞台上。它们都遵循相同的格式，但通过改变`gotoAndPlay`操作中的数字参数，它们在不同的帧上开始它们的动画序列。
- en: Finally, we added `Tick.setInterval(200)`;, which applied a time period of 200
    milliseconds between Ticks. The Tick interface acts as a global timing device
    which gives us the ability to return frame rates per second (FPS) if needed. We
    added a listener to the stage `Tick.addListener(stage)`; which behaves like other
    types of listeners in that it listens for ticks. This can be used to help redraw
    the stage at a specified time, or perform other timing related actions. We used
    the `onload` attribute to call the `init()` function in the `body` tag. This causes
    the `init()` function to be invoked on page load.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了`Tick.setInterval(200)`;，它在Ticks之间应用了200毫秒的时间间隔。Tick接口充当全局定时设备，使我们能够返回每秒的帧速率（FPS）（如果需要的话）。我们向舞台添加了一个监听器`Tick.addListener(stage)`;，它像其他类型的监听器一样监听Ticks。这可以用来在指定的时间重新绘制舞台，或执行其他与时间相关的操作。我们使用`onload`属性在`body`标签中调用`init()`函数。这会导致在页面加载时调用`init()`函数。
- en: There's more...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`Easel.js` and other similar libraries to make controlling HTML5 elements easier
    are cropping up everywhere. Take caution on how you use them though as some may
    not be stable enough for use in production environments.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Easel.js`和其他类似的库使得控制HTML5元素变得更加容易。但是要小心使用它们，因为有些可能不够稳定，无法在生产环境中使用。'
- en: Pirates Love Daisies and so should you
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 海盗喜欢雏菊，你也应该喜欢
- en: The creator of `Easel.js` was asked by Microsoft to create a proof of concept
    web game named Pirates love daisies ([http://www.pirateslovedaisies.com](http://www.pirateslovedaisies.com))
    made entirely using HTML5 and JavaScript with heavy reliance on the `Easel.js`
    library to manipulate the `canvas` element. You can play the game in any web browser
    and in what may be an ironic twist; it contains special features for visitors
    using the Internet Explorer 9 browser.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Easel.js`的创建者被微软要求创建一个名为"Pirates love daisies"的概念性网络游戏（[http://www.pirateslovedaisies.com](http://www.pirateslovedaisies.com)），完全使用HTML5和JavaScript，并且大量依赖`Easel.js`库来操作`canvas`元素。您可以在任何网络浏览器中玩这个游戏，或许具有讽刺意味的是，它还为使用Internet
    Explorer 9浏览器的访问者提供了特殊功能。'
- en: The return of old school computer animation techniques
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 老派计算机动画技术的回归
- en: 'When I first began playing games on a computer, it was a big deal for a game
    to have 256 colors on the screen and 8-bit animations. Computer animators used
    a lot of tricks to replicate effects such as water moving. Revisit those days
    (or discover them for the first time with this demo from effect games: [http://www.effectgames.com/demos/canvascycle/](http://www.effectgames.com/demos/canvascycle/).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次在计算机上玩游戏时，游戏屏幕上有256种颜色和8位动画是一件大事。计算机动画师使用了许多技巧来复制水流动等效果。重温那些日子（或者第一次通过来自effect
    games的演示发现它们：[http://www.effectgames.com/demos/canvascycle/](http://www.effectgames.com/demos/canvascycle/)）。
- en: See also
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There is a whole chapter in this book full of canvas recipes. Go devour them
    now if you skipped them.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中有一个完整的章节充满了canvas的示例。如果你跳过了它们，现在去看看吧。
- en: Random animation with audio using the canvas tag and JavaScript
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用canvas标签和JavaScript进行随机动画和音频
- en: In this recipe we will use the canvas tag to draw and animate a series of shapes.
    We will also loop an audio file using the audio tag to play while the animation
    displays. We are adapting an original animation created by Michael Nutt. We will
    be creating a slower, more relaxing animation that looks like waving grass.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用canvas标签来绘制和动画一系列形状。我们还将使用音频标签循环播放音频文件，同时显示动画。我们正在改编Michael Nutt创建的原始动画。我们将创建一个更慢、更轻松的动画，看起来像是摇曳的草。
- en: Getting ready
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a recently updated browser, such as Firefox 3.6 or Google Chrome,
    and an audio file in multiple formats. It does display at a different (smaller)
    size in Opera browsers 9 and 10\. The audio will also not play in those versions
    of Opera.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个最近更新的浏览器，如Firefox 3.6或Google Chrome，以及多种格式的音频文件。在Opera浏览器9和10中显示的大小不同（较小）。音频也不会在这些版本的Opera中播放。
- en: How to do it...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, open a new HTML5 page and name it `random-animation-with-audio.html`.
    Enter the beginnings of an HTML5 page including the page title:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个新的HTML5页面，并将其命名为`random-animation-with-audio.html`。输入HTML5页面的开头，包括页面标题：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, add links to the JavaScript and CSS files that will be imported when
    the page loads: `<script type="text/javascript" src="img/animatedlines.js"></script><link
    rel="stylesheet" href="css/stylesheet.css" type="text/css" media="screen" charset="utf-8"
    />`, and close the head tag with `</head>`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加链接到将在页面加载时导入的JavaScript和CSS文件：`<script type="text/javascript" src="img/animatedlines.js"></script><link
    rel="stylesheet" href="css/stylesheet.css" type="text/css" media="screen" charset="utf-8"
    />`，并使用`</head>`关闭head标签。
- en: Enter `<body onLoad="init();">` to activate the `init()` function when the page
    loads.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`<body onLoad="init();">`以在页面加载时激活`init()`函数。
- en: Next we create the header for the page `<header><h1>CANVAS Reggae</h1></header>`,
    and then add the canvas element by typing `<canvas id="tutorial" width="480" height="360"></canvas>`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建页面的标题`<header><h1>CANVAS Reggae</h1></header>`，然后通过输入`<canvas id="tutorial"
    width="480" height="360"></canvas>`添加canvas元素。
- en: 'Create a new div with an of `id` credits to hold a link to Michael''s site:
    `<div id="credits">Based on Canvas Party by <a href="http://nuttnet.net/">Michael
    Nutt</a>&nbsp;&nbsp`;. Then add a link to the div to grab the audio element and
    apply the `pause()` function to the music when the link is clicked. `<a href="#"
    onClick="document.getElementsByTagName(''audio'')[0].pause();">[OFF]</a></div>`.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的div，其中`id`为credits，用于保存指向Michael网站的链接：`<div id="credits">Based on Canvas
    Party by <a href="http://nuttnet.net/">Michael Nutt</a>&nbsp;&nbsp;`。然后向div添加一个链接，以获取音频元素，并在单击链接时应用`pause()`函数来暂停音乐：`<a
    href="#" onClick="document.getElementsByTagName('audio')[0].pause();">[OFF]</a></div>`。
- en: 'Now, enter the audio tag, and set autoplay to true and loop to loop: `<audio
    autoplay="true" loop="loop">` Create two source tags to contain the audio formats:
    `<source type="audio/ogg" src="img/randomreggae.ogg" /><source type="audio/mpeg"
    src="img/randomreggae.mp3" />`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入音频标签，并将autoplay设置为true，loop设置为loop：`<audio autoplay="true" loop="loop">`创建两个source标签来包含音频格式：`<source
    type="audio/ogg" src="img/randomreggae.ogg" /><source type="audio/mpeg" src="img/randomreggae.mp3"
    />`。
- en: 'Before closing the audio tag, we will add a string of text that will appear
    if the audio tag is not supported: `Your browser doesn''t recognize the HTML5
    audio tag`.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭音频标签之前，我们将添加一段文本，如果不支持音频标签，将显示：`您的浏览器不识别HTML5音频标签`。
- en: Close the audio, body, and html tags, and save the page.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭音频、body和html标签，并保存页面。
- en: 'Before we create our script, open the `stylesheet.css` page, and type the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建脚本之前，打开`stylesheet.css`页面，并输入以下内容：
- en: '[PRE53]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now that the HTML and CSS pages are built, we will tackle the animation script.
    Create a new JavaScript file and name it `animatedLines.js`. We will place it
    in a new subfolder named `js`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在HTML和CSS页面都已构建，我们将着手处理动画脚本。创建一个新的JavaScript文件，并将其命名为`animatedLines.js`。我们将把它放在一个名为`js`的新子文件夹中。
- en: 'First, we will declare the flatten variable and create a new array function:
    `var flatten = function(array) { var r = []`;. Next, within the function, we will
    create a `for` statement to declare an array beginning with one object (var `i
    = 0)` and then increment the size of the array while the length of the array is
    greater than `i. for(var i = 0; i < array.length; i++) {`. Using the `push` function
    we will add new values to the array by typing: `r.push.apply(r, array[i]);}` then
    finally we end the function by returning the array: `return r; }`.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明flatten变量并创建一个新的数组函数：`var flatten = function(array) { var r = [];`。接下来，在函数内部，我们将创建一个`for`语句来声明一个以一个对象开始的数组（`var
    i = 0`），然后在数组长度大于`i`时增加数组的大小。通过使用`push`函数，我们将输入新值到数组中：`r.push.apply(r, array[i]);}`，最后通过返回数组来结束函数：`return
    r; }`。
- en: 'Our script so far should look like the following code block:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的脚本应该看起来像以下代码块：
- en: '[PRE54]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we will create a function named shuffle that accepts an array as an argument.
    Type `function shuffle(array) { var tmp, current, top = array.length`;. Inside
    the function, we have an if/while loop to move through the values in the array.
    Add it to the script by entering: `var tmp, current, top = array.length; if(top)
    while(--top) { current = Math.floor(Math.random() * (top + 1)); tmp = array[current];
    array[current] = array[top]; array[top] = tmp; }. Return` the `array` value at
    the end of the function. Our function to shuffle array values randomly should
    now look like the following code block:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为shuffle的函数，该函数接受一个数组作为参数。输入`function shuffle(array) { var tmp,
    current, top = array.length;`。在函数内部，我们有一个if/while循环来遍历数组中的值。通过输入以下代码将其添加到脚本中：`var
    tmp, current, top = array.length; if(top) while(--top) { current = Math.floor(Math.random()
    * (top + 1)); tmp = array[current]; array[current] = array[top]; array[top] =
    tmp; }`。在函数末尾返回`array`值。我们的随机打乱数组值的函数现在应该看起来像以下代码块：
- en: '[PRE55]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we are ready to create a global `canvas` variable and a `context` variable
    by typing: `var canvas`; and `var ctx;respectively`.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建一个全局的`canvas`变量和一个`context`变量，输入：`var canvas;`和`var ctx;`。
- en: 'With those variables created, we can add the `init()` function to the script,
    where all the action starts. Type function `init() {` then enter the statement
    to associate our canvas variable with the canvas element: `canvas = document.getElementById(''tutorial'')`;.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这些变量后，我们可以将`init()`函数添加到脚本中，所有操作都从这里开始。输入`function init() {`然后输入语句将我们的canvas变量与canvas元素关联起来：`canvas
    = document.getElementById('tutorial');`。
- en: 'Now, we will create an `if` statement to set the width and height attributes
    of our canvas variable: `if (canvas.getContext) {canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 100; ctx = canvas.getContext(''2d''); ctx.lineJoin
    = "round"; setInterval("draw()", 300); }.This` completes the `init()` function.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`if`语句来设置我们的canvas变量的宽度和高度属性：`if (canvas.getContext) {canvas.width
    = window.innerWidth; canvas.height = window.innerHeight - 100; ctx = canvas.getContext('2d');
    ctx.lineJoin = "round"; setInterval("draw()", 300); }。这`完成了`init()`函数。
- en: 'Next, we add a listener for our browser window to detect when it is being resized:
    `window.addEventListener(''resize'', function() {canvas.width = window.innerWidth;canvas.height
    = window.innerHeight - 100; });}`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为浏览器窗口添加一个监听器，以便在调整大小时检测：`window.addEventListener('resize', function()
    {canvas.width = window.innerWidth;canvas.height = window.innerHeight - 100; });}`。
- en: 'The most recent additions to our script should now look like:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的最新添加现在应该看起来像：
- en: '[PRE56]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are finally ready to create a function to draw shapes onto the canvas. This
    function will contain most of the script that powers the animation of the shapes.
    Type `function draw(){ctx.globalCompositeOperation = "darker"; ctx.fillStyle =
    '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);ctx.globalCompositeOperation
    = "lighter";to` set the look of the canvas background.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好创建一个函数来在画布上绘制形状。这个函数将包含大部分驱动形状动画的脚本。键入`function draw(){ctx.globalCompositeOperation
    = "darker"; ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);ctx.globalCompositeOperation
    = "lighter";to`设置画布背景的外观。
- en: 'Now, we will enter the colors to use in the animation. We will create an array
    of arrays containing `rgba` values. Type: `var colors = ["rgba(134, 154, 67, 0.8)",
    "rgba(196, 187, 72, 0.8)", "rgba(247, 210, 82, 1)", "rgba(225, 124, 20, 0.8)"];.Our`
    colors are defined, so now we will set the width and height of the shapes using
    an array containing individual arrays of width and height values: `var data =
    [ [ [5, 20], [15, 2] ], [ [50, 12], [10, 14], [3, 21] ], [ [60, 8]], [ [30, 24],
    [15, 4], [10, 17] ], [ [5, 10] ], [ [60, 5], [10, 6], [3, 26] ], [ [20, 18] ],
    [ [90, 11], [40, 13], [15, 10] ], [ [70, 19] ], ]`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将输入用于动画的颜色。我们将创建一个包含`rgba`值的数组数组。键入：`var colors = ["rgba(134, 154, 67,
    0.8)", "rgba(196, 187, 72, 0.8)", "rgba(247, 210, 82, 1)", "rgba(225, 124, 20,
    0.8)"];。我们`已经定义了颜色，现在我们将使用一个包含宽度和高度值的数组来设置形状的宽度和高度：`var data = [ [ [5, 20], [15,
    2] ], [ [50, 12], [10, 14], [3, 21] ], [ [60, 8]], [ [30, 24], [15, 4], [10, 17]
    ], [ [5, 10] ], [ [60, 5], [10, 6], [3, 26] ], [ [20, 18] ], [ [90, 11], [40,
    13], [15, 10] ], [ [70, 19] ], ]`。
- en: Now we can animate the shapes by changing their width and height using `data
    = shuffle(data)`;.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用`data = shuffle(data)`来改变它们的宽度和高度来使形状动起来。
- en: To animate the shapes up and down as well as side to side, we need to "flatten"
    or squish their height. Create a new variable to contain the `var flatData = flatten(data)`;
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使形状上下以及左右移动，我们需要"压扁"或压缩它们的高度。创建一个新变量来包含`var flatData = flatten(data)`；
- en: 'Now we will be contorting the lines so they appear to wave by pulling them
    in different directions and using `bezierCurve`. This is a large function block
    contained within the `draw()` function we created earlier, so enter the `link()`
    function as shown here:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将扭曲线条，使它们看起来像是在不同方向上拉动，并使用`bezierCurve`。这是一个大的函数块，包含在我们之前创建的`draw()`函数中，所以输入`link()`函数如下所示：
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now while we are still in the `draw()` function let''s add a new variable to
    represent the starting point for a shape, and then add a `for` loop to create
    a new variable that can hold an array of data value sets. Below is the variable
    and loop code: `Var topStartingPoint = 0; for(var i in data) { var group = data[i];
    var color = colors[ i % colors.length ];ctx.strokeStyle = color`;.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们仍然在`draw()`函数中时，让我们添加一个新变量来表示形状的起点，然后添加一个`for`循环来创建一个可以容纳数据值集合数组的新变量。以下是变量和循环代码：`Var
    topStartingPoint = 0; for(var i in data) { var group = data[i]; var color = colors[
    i % colors.length ];ctx.strokeStyle = color`。
- en: 'Take it further by creating a nested `for` loop that passes a group of data
    values to a new variable named `line: for(var j in group) { var line = group[j]`;
    which we can then manipulate after creating a `bottomStartingPoint` variable with
    an initial value of zero: `var bottomStartingPoint = 0`;.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个嵌套的`for`循环，将一组数据值传递给一个名为`line`的新变量，进一步进行。`for(var j in group) { var line
    = group[j]`；然后我们可以在创建一个初始值为零的`bottomStartingPoint`变量后进行操作：`var bottomStartingPoint
    = 0`。
- en: 'A third nested `for` loop will allow us to control the positioning and movement
    of the shapes further: `for(var k in flatData) { if(flatData[k][1] < line[1])
    { bottomStartingPoint += flatData[k][0] + 11;} }`.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个嵌套的`for`循环将允许我们进一步控制形状的定位和移动：`for(var k in flatData) { if(flatData[k][1]
    < line[1]) { bottomStartingPoint += flatData[k][0] + 11;} }`。
- en: 'Finally, we use link to set the top and bottom starting points for a line,
    `link(topStartingPoint, bottomStartingPoint, line[0])`;, then assign the `topStartingPoint`
    the value of its current value plus the line array. The final statement sets the
    `topStartingPoint` value to its current value plus five: `topStartingPoint +=
    line[0]; } topStartingPoint += 5; }}`. Save the script file.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用link来设置线条的顶部和底部起点，`link(topStartingPoint, bottomStartingPoint, line[0])`；然后将`topStartingPoint`赋值为其当前值加上线条数组。最后一条语句将`topStartingPoint`的值设置为其当前值加上五：`topStartingPoint
    += line[0]; } topStartingPoint += 5; }}`。保存脚本文件。
- en: 'Open the file `random-animation-with-audio.html` in a browser, and you should
    see the lines sway back and forth similar to what is shown in the following screenshot:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开文件`random-animation-with-audio.html`，您应该看到线条来回摆动，类似于以下截图所示：
- en: '![How to do it...](img/1048_07_10.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_07_10.jpg)'
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we created our HTML5 page with links to the JavaScript and CSS files
    that would be imported when the page loaded: `<script type="text/javascript" src="img/animatedlines.js"></script><link
    rel="stylesheet" href="css/stylesheet.css" type="text/css" media="screen" charset="utf-8"
    />`. To activate our animation sequence, we placed the `init()` function in the
    body tag of the HTML page. The `init()` function in the `animatedLines.js` JavaScript
    file will be initialized by `<body onLoad="init();">` when the page loads.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个HTML5页面，其中包含对在页面加载时导入的JavaScript和CSS文件的链接：`<script type="text/javascript"
    src="img/animatedlines.js"></script><link rel="stylesheet" href="css/stylesheet.css"
    type="text/css" media="screen" charset="utf-8" />`。为了激活我们的动画序列，我们将`init()`函数放在HTML页面的body标签中。当页面加载时，`animatedLines.js`
    JavaScript文件中的`init()`函数将通过`<body onLoad="init();">`进行初始化。
- en: 'We used the `body` style to set a global default `margin` of `0`, a `background-color`,
    font `color`, and `font-family` for the page. We styled a basic link color, then
    styled the `h1` heading tag so it would display at the `top` with `position: absolute;
    top: 0`; and always appear above most other content blocks by setting the `z-index`
    to `50`. The `#credits` div was positioned to appear at the bottom-right corner
    of the page and the audio tag was hidden using `visibility: hidden`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用`body`样式设置了全局默认的`margin`为`0`，页面的`background-color`，字体`color`和`font-family`。我们为基本链接颜色设置了样式，然后为`h1`标题标签设置了样式，使其以`position:
    absolute; top: 0`的方式显示在`top`位置，并通过将`z-index`设置为`50`始终显示在大多数其他内容块的上方。`#credits`
    div被定位在页面的右下角，音频标签使用`visibility: hidden`进行隐藏。'
- en: We created a new script named `animatedLines.js` and first defined a series
    of variables and functions to control the behavior of the shapes.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`animatedLines.js`的新脚本，并首先定义了一系列变量和函数来控制形状的行为。
- en: We set up an array named `flatten` that would add new values to itself. We next
    needed a function to rotate randomly through array values. We used the `Math.floor(Math.random()`
    statement to calculate a random number, and multiply the result by the sum of
    the current value of the variable `top + 1`. We then returned a whole number value
    to the variable `current`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个名为`flatten`的数组，它会向自身添加新值。接下来，我们需要一个函数来随机遍历数组值。我们使用`Math.floor(Math.random()`语句来计算一个随机数，并将结果乘以变量`top
    + 1`的当前值的总和。然后我们将一个整数值返回给变量`current`。
- en: 'We defined the dimensional values of the `canvas` variable by grabbing the
    ID of the `canvas` element on page load using `document.getElementById`. We set
    the `width` and `height` attributes of our `canvas` variable with some help from
    the DOM: `canvas.height = window.innerHeight - 100; ctx = canvas.getContext(''2d'')`;
    then created a statement to apply a `lineJoin` to the `2d` context of the `canvas`
    with a parameter of `round`. We set the speed the lines were drawn on the canvas
    to `300` milliseconds using the `setInterval()` function. The higher the number,
    the slower the animation looks. We added a listener for our browser window to
    detect when it is being resized using `window.addEventListener`, which contained
    parameters for the size of the browser window and the canvas.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`document.getElementById`在页面加载时抓取`canvas`元素的ID来定义了`canvas`变量的尺寸值。我们使用DOM设置了`canvas`变量的`width`和`height`属性：`canvas.height
    = window.innerHeight - 100; ctx = canvas.getContext('2d')`；然后创建了一个语句来将`lineJoin`应用到`canvas`的`2d`上下文中，并设置参数为`round`。我们使用`setInterval()`函数将画布上的线条绘制速度设置为`300`毫秒。数字越大，动画看起来越慢。我们为浏览器窗口添加了一个监听器，以便检测调整大小时使用`window.addEventListener`，其中包含了浏览器窗口和画布的尺寸参数。
- en: The shapes were then drawn onto the canvas using the `draw()` function. The
    `globalCompositeOperation = "darker"`; was used to darken lines as they moved
    across each other. Areas of the lines brightened as they overlapped in the front
    area of the canvas stage using `globalCompositeOperation = "lighter"`; to set
    the look of the canvas background.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`draw()`函数将形状绘制到画布上。使用`globalCompositeOperation = "darker"`来使线条在相互交叠时变暗。线条在画布舞台前部重叠时，使用`globalCompositeOperation
    = "lighter"`来设置画布背景的外观。
- en: The colors used to decorate the lines need to be in `rgba` format. The 'a' in
    rgba refers to the alpha value, which controls the visibility of each color. Each
    rgba value set was contained in an array, which in turn became a list of arrays.
    We needed a matching number of width and height value sets for the lines. These
    were stored in the array `var data`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 用于装饰线条的颜色需要以`rgba`格式。`rgba`中的'a'指的是alpha值，控制每种颜色的可见性。每个`rgba`值设置都包含在一个数组中，然后成为数组列表。我们需要相匹配的宽度和高度值集合用于线条。这些存储在数组`var
    data`中。
- en: We next assigned the `data` array the value returned from our `shuffle()` function
    so we could randomize the appearance of the lines on the screen. Then, we assigned
    to the variable `flatData` the value returned from the `flatten()` function. Assigning
    a pull value to each line enabled us to move it over a set number of pixels. We
    combined this with `bezierCurve` to cause the lines to bend.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`data`数组分配给从我们的`shuffle()`函数返回的值，以便我们可以随机化屏幕上线条的外观。然后，我们将`flatData`变量分配给从`flatten()`函数返回的值。为每条线分配一个拉动值使我们能够将其移动一定数量的像素。我们将这个与`bezierCurve`结合起来使线条弯曲。
- en: There's more...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Combining the audio tag, canvas animations, and JavaScript sounds like a fun
    way to create cool visualization effects. These are heavily dependent upon browser
    support though, so many web browser users won't be able to view them properly
    at this time. By which I mean most standard browsers won't be able to play them
    as far off as a year or two.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 结合音频标签、画布动画和JavaScript听起来是创建酷炫可视化效果的有趣方式。然而，这些效果在很大程度上依赖于浏览器的支持，因此目前许多网络浏览器用户无法正确查看它们。我的意思是，大多数标准浏览器在一两年内都无法播放它们。
- en: Visualizing your audio with cutting edge browsers
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用尖端浏览器可视化您的音频
- en: 'If you have downloaded the beta Firefox 4, you have access to the Firefox Audio
    and Video API. You will be able to view and create your own audio visualizations
    using tools like the Spectrum Visualizer:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经下载了beta版的Firefox 4，你就可以访问Firefox音频和视频API。你将能够使用类似Spectrum Visualizer的工具查看和创建自己的音频可视化：
- en: '[http://www.storiesinflight.com/jsfft/visualizer/index.html](http://www.storiesinflight.com/jsfft/visualizer/index.html)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.storiesinflight.com/jsfft/visualizer/index.html](http://www.storiesinflight.com/jsfft/visualizer/index.html)'
- en: Pushing the implementation of audio in HTML5
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在HTML5中推动音频的实现
- en: 'Alexander Chen has been experimenting with audio and canvas by porting Flash-based
    app. He has run into some issues with using multiple audio files that are detailed
    here on his blog:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Alexander Chen一直在尝试通过移植基于Flash的应用程序来实验音频和画布。他在使用多个音频文件时遇到了一些问题，这些问题在他的博客上有详细介绍：
- en: '[http://blog.chenalexander.com/2011/limitations-of-layering-html5-audio/](http://blog.chenalexander.com/2011/limitations-of-layering-html5-audio/)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://blog.chenalexander.com/2011/limitations-of-layering-html5-audio/](http://blog.chenalexander.com/2011/limitations-of-layering-html5-audio/)'
- en: See also
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The canvas and
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 画布和
