- en: Chapter 9. Data Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。数据存储
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Testing browsers for data storage support
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试浏览器是否支持数据存储
- en: Using browser developer tools to monitor web storage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器开发工具监视Web存储
- en: Setting and getting session storage variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和获取会话存储变量
- en: Setting and getting a local storage variable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和获取本地存储变量
- en: Converting local storage strings to numbers using `parseInt`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地存储字符串转换为数字使用`parseInt`
- en: Creating a web SQL database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Web SQL数据库
- en: Using a web SQL database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web SQL数据库
- en: Creating a cache manifest and using sites offline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建缓存清单并离线使用站点
- en: Displaying the current location using the Geolocation API and `geo.js`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Geolocation API和`geo.js`显示当前位置
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: HTML5 introduces a new way to store information without using cookies. This
    gives designers and developers more flexibility in how dynamic content is processed
    and displayed. We will begin with testing browsers for support of the three main
    data storage methods, and end by creating an HTML5 page that uses local storage
    to store and access a video. Although each of these recipes build on each other,
    you do not have to complete them in the order they are presented. The example
    files from this chapter are available for download at [http://www.packtpub.com/support?nid=7940](http://www.packtpub.com/support?nid=7940).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5引入了一种新的存储信息的方式，而不使用cookie。这为设计师和开发人员提供了更多的灵活性，以处理和显示动态内容。我们将从测试浏览器是否支持三种主要数据存储方法开始，并最终创建一个使用本地存储来存储和访问视频的HTML5页面。尽管这些示例都是基于彼此构建的，但您不必按照它们呈现的顺序完成它们。本章的示例文件可在[http://www.packtpub.com/support?nid=7940](http://www.packtpub.com/support?nid=7940)上下载。
- en: Testing browsers for data storage support
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试浏览器是否支持数据存储
- en: Knowing how to test quickly whether a browser supports a data storage method
    you want to use will make developing pages and applications easier. In this recipe,
    we will create a script that queries a browser's DOM to test for support of different
    data storage methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何快速测试浏览器是否支持您想要使用的数据存储方法将使页面和应用程序的开发更加容易。在这个示例中，我们将创建一个脚本，查询浏览器的DOM，以测试对不同数据存储方法的支持。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: You will need access to a modern browser such as Firefox 3.6, or the latest
    versions of a popular browser such as Google Chrome, Opera, Safari, or Internet
    Explorer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问现代浏览器，如Firefox 3.6，或流行浏览器的最新版本，如Google Chrome，Opera，Safari或Internet Explorer。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we are going to create a simple html page. Open an HTML editing program
    or a text editor, and enter the starting code for a basic HTML5 page:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的html页面。打开一个HTML编辑程序或文本编辑器，并输入基本HTML5页面的起始代码：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The look of the test page now needs to be styled. We will use `<style>` tags
    within the `<head>` tags HTML page, but you could also place them in a separate
    CSS file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要对测试页面的外观进行样式设置。我们将在HTML页面的`<head>`标记中使用`<style>`标记，但您也可以将它们放在单独的CSS文件中。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Type a closing `head` tag, then create a `body` tag as shown below. Notice the
    big difference is we are calling a `RunTest()` function to activate when the page
    loads.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个关闭的`head`标记，然后创建一个`body`标记如下所示。请注意，主要区别在于我们在页面加载时调用`RunTest()`函数来激活。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a paragraph tag with descriptive text similar to what is show below.
    Close the tag, and create an `<h3>` header tag to contain the result heading.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个段落标记，其中包含类似下面所示的描述性文本。关闭标记，并创建一个包含结果标题的`<h3>`标题标记。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, type each storage method followed by a span tag that is styled by the
    class value. Type the ID of the storage method and the text "not supported". Close
    the span tag and add a break tag to separate the results onto individual lines
    in the browser window. The results'' display area should look like the following
    code block:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入每种存储方法，然后输入一个由类值样式化的span标记。输入存储方法的ID和文本“不支持”。关闭span标记并添加一个换行标记，以便在浏览器窗口中将结果分开显示在单独的行上。结果显示区域应该如下代码块所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are almost done creating our test page. Create a paragraph explaining the
    purpose of the test. Finish the content area off with a `<footer>` tag to contain
    the script block we will be adding next. The descriptive text should look like
    the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了创建我们的测试页面。创建一个段落来解释测试的目的。用`<footer>`标记结束内容区域，以包含我们接下来要添加的脚本块。描述性文本应如下代码所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we will add `script` tags so that the browser will process a small test
    program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加`script`标记，以便浏览器处理一个小型测试程序：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will create a case statement that includes a block of code for each
    data storage method we are going to test:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个包含每种数据存储方法的代码块的case语句，我们将要测试：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the file as `data-storage-support-test.html`, and open it in your browser
    window. You should see a result similar to the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为`data-storage-support-test.html`，并在浏览器窗口中打开它。您应该看到类似以下截图的结果：
- en: '![How to do it...](img/1048_09_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_09_01.jpg)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The HTML5 test page we created used a small snippet of JavaScript code to query
    the browser to see if it supported specific storage methods. We began by writing
    a standard HTML5 page with the appropriate `<html>, <head>`, and other document
    tags. If you need a refresher on them, they are covered in the earlier chapters
    of this book. Next, we set up the opening block of a JavaScript code snippet using
    the simplified `<script>` tag. The HTML5 JavaScript API is covered in more detail
    elsewhere in this book. We created a function named `RunTest()` to contain the
    variables and code. Two variables were then created. The variable supp was given
    the value of an empty string. This would contain the final support result for
    each storage method. We're looping through the properties of the window object.
    During each iteration the current property is temporarily stored in the `mydata`
    variable. This allows us to test the property against the three cases.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的HTML5测试页面使用了一小段JavaScript代码来查询浏览器是否支持特定的存储方法。我们首先编写了一个标准的HTML5页面，包括适当的`<html>`，`<head>`和其他文档标签。如果您需要复习它们，它们在本书的早期章节中有介绍。接下来，我们使用简化的`<script>`标签设置了JavaScript代码片段的开头块。HTML5
    JavaScript API在本书的其他地方有更详细的介绍。我们创建了一个名为`RunTest()`的函数来包含变量和代码。然后创建了两个变量。变量`supp`被赋予了一个空字符串的值。这将包含每种存储方法的最终支持结果。我们正在循环遍历window对象的属性。在每次迭代中，当前属性暂时存储在`mydata`变量中。这使我们能够测试属性与三种情况进行比较。
- en: Next, we use a switch statement to test the `mydata` variable against the particular
    properties in which we are interested. Because we are only testing a single value
    at a time, and the list is short, this is a good way to test for support of each
    storage method. The body of the `switch` statement contained three cases, one
    for each storage method. Each case contains an expression that must be evaluated.
    If the storage method is supported, the final action of each case is to change
    the value of the result text in the main body of the document from "not supported"
    to "supported" if the expression evaluates as true. If the case does not evaluate
    as true, then the text displayed in the result section of the page will remain
    unchanged.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用switch语句来测试`mydata`变量与我们感兴趣的特定属性。因为我们一次只测试一个值，而且列表很短，这是测试每种存储方法支持的好方法。`switch`语句的主体包含三种情况，每种情况对应一种存储方法。每种情况都包含一个必须评估的表达式。如果支持存储方法，则每种情况的最终操作是将文档主体中结果文本的值从“不支持”更改为“支持”，如果表达式评估为真。如果情况评估为假，则页面结果部分显示的文本将保持不变。
- en: After creating the code we controlled the presentation of the results using
    CSS styles. A container to display the box was created using a div tag named results,
    and a background color, font colors, and weight were specified. This was the last
    block of code for the head section of the html page.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建代码后，我们使用CSS样式控制了结果的呈现。使用一个名为results的div标签创建了一个用于显示框的容器，并指定了背景颜色、字体颜色和粗细。这是html页面头部的最后一个代码块。
- en: The body section of the page was then created. The test was set to activate
    when page loaded in the browser using the `onload` command. The opening text and
    title for the result box were written, and the display text for each result was
    tied to a unique ID. The closing tags were then entered to complete the page.
    After saving the page, the results were then displayed on the screen when the
    test page was viewed in the browser window. The browser used in the screenshot
    was Firefox 3.6.13\. The results we saw mirrored the current support Firefox offers
    in versions 3.6 and 4.0.3 for storage methods. This helped us determine that we
    could expect Firefox visitors to view and use any features easily on a web page
    that depended on local storage and session storage methods. They would be unable
    to take advantage of any features dependent upon WebSQL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建了页面的主体部分。使用`onload`命令设置了页面在浏览器中加载时激活测试。编写了结果框的开头文本和标题，并将每个结果的显示文本与唯一的ID相关联。然后输入了闭合标签以完成页面。保存页面后，当在浏览器窗口中查看测试页面时，结果将显示在屏幕上。截图中使用的浏览器是Firefox
    3.6.13。我们看到的结果反映了Firefox在3.6和4.0.3版本中对存储方法的当前支持。这帮助我们确定我们可以期望Firefox访问者轻松查看和使用依赖本地存储和会话存储方法的网页上的任何功能。他们将无法利用任何依赖于WebSQL的功能。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Testing sites and online applications has never been easier. There are many
    tools and services available that can be used to test on different platforms and
    across browsers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网站和在线应用程序从未如此简单。有许多可用的工具和服务可用于在不同平台和浏览器上进行测试。
- en: Mobile testing
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动测试
- en: You can download multiple browsers on smart devices, such as the iPod Touch
    or iPad, enabling you to test the responsiveness of your rich media content on
    mobile devices and different browsers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在智能设备上下载多个浏览器，如iPod Touch或iPad，从而可以测试移动设备和不同浏览器上丰富媒体内容的响应性。
- en: Adobe browser lab
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Adobe浏览器实验室
- en: Adobe CS5 is not required to try Adobe BrowserLab, an online cross-browser testing
    tool that is integrated with Adobe CS5 products. Visit [https://browserlab.adobe.com](https://browserlab.adobe.com)
    to learn more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要Adobe CS5即可尝试Adobe BrowserLab，这是一个与Adobe CS5产品集成的在线跨浏览器测试工具。访问[https://browserlab.adobe.com](https://browserlab.adobe.com)了解更多信息。
- en: Free cross-browser and OS testing with BrowserShots
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用BrowserShots进行免费的跨浏览器和操作系统测试
- en: An alternative for those on a budget and with time to spare is [BrowserShots.org](http://BrowserShots.org).
    This site enables visitors to enter the URL of their website and then select from
    an enormous list of browsers and operating systems. It can take a few minutes
    for the results to appear using the free version of the service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预算有限且有时间的人来说，[BrowserShots.org](http://BrowserShots.org)是一个替代选择。该网站允许访问者输入其网站的URL，然后从庞大的浏览器和操作系统列表中进行选择。使用免费版本的服务可能需要几分钟才能看到结果。
- en: Using browser developer tools to monitor web storage
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浏览器开发工具监视Web存储
- en: Web storage can be challenging to test. Using developer tools in browsers, such
    as Safari or Firefox addons such as Firebug, make it easier to diagnose issues
    and track the values of variables. In this recipe, we will use the native developer
    tools in the Google Chrome browser to explore the key/value pairs stored in the
    local storage area of a browser.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储可能很难测试。使用浏览器中的开发者工具，如Safari或Firefox附加组件，如Firebug，可以更容易地诊断问题并跟踪变量的值。在这个示例中，我们将使用Google
    Chrome浏览器中的原生开发者工具来探索浏览器本地存储区中存储的键/值对。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a recent version of the Google Chrome browser and one of the local
    storage code files for this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个最新版本的Google Chrome浏览器和本章的一个本地存储代码文件。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open one of the local storage exercise files from this chapter in a Google Chrome
    browser window.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Chrome浏览器窗口中打开本章中的一个本地存储练习文件。
- en: Click **View**, select **Developer** from the **View** menu, and then choose
    **Developer tools** from the **Developer** fly-out menu.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**查看**，从**查看**菜单中选择**开发者**，然后从**开发者**弹出菜单中选择**开发者工具**。
- en: 'When the **Developer** window appears over the current page, select the **Resources**
    tab, click **Local Storage** in the navigation area of the Google Chrome Developer
    Tools window, and then the submenu within it. You should see a result similar
    to the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当**开发者**窗口出现在当前页面上时，选择**资源**选项卡，点击Google Chrome开发者工具窗口导航区域中的**本地存储**，然后选择其中的子菜单。您应该看到类似以下截图的结果：
- en: '![How to do it...](img/1048_09_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1048_09_02.jpg)'
- en: The Local Storage section under the Resources tab of the Google Developer tools
    window gives us access to local storage areas for each page. It displays keys
    and their corresponding values on the right side of the screen. If you right-click
    on an object you will have the option to delete it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google开发者工具窗口的资源选项卡下的本地存储部分，我们可以访问每个页面的本地存储区域。它在屏幕右侧显示键和它们对应的值。如果右键单击对象，您将有删除它的选项。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We loaded a page that we knew used local storage to test how the Google Developer
    tools window available in the Google Chrome browser would display key/value pairs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载了一个我们知道使用本地存储的页面，以测试Google Chrome浏览器中的Google开发者工具窗口如何显示键/值对。
- en: When we navigated down the left menu of the developer tools we could choose
    from different web storage methods and other resources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在开发者工具的左侧菜单中导航时，我们可以选择不同的Web存储方法和其他资源。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many free plugins and native browser tools of which developers can
    take advantage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多免费的插件和原生浏览器工具供开发人员利用。
- en: Use a Firebug addon even if you don't use Firefox
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 即使不使用Firefox，也可以使用Firebug附加组件
- en: Firefox users have long enjoyed debugging and browsing websites and other online
    applications using the Firebug addon ([http://getfirebug.com/downloads](http://getfirebug.com/downloads)).
    Users of Opera, Google Chrome, Safari, and IE 6+ can use Firebug Lite ([http://getfirebug.com/firebuglite](http://getfirebug.com/firebuglite))
    and experience similar functionality with a lightweight bookmarklet they can easily
    add to their browser.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox用户长期以来一直在使用Firebug附加组件（[http://getfirebug.com/downloads](http://getfirebug.com/downloads)）来调试和浏览网站和其他在线应用程序。Opera、Google
    Chrome、Safari和IE 6+的用户可以使用Firebug Lite（[http://getfirebug.com/firebuglite](http://getfirebug.com/firebuglite)），并通过轻量级的书签工具体验类似的功能，他们可以轻松地添加到他们的浏览器中。
- en: Safari developer tools are native to the Safari browser
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Safari开发者工具是Safari浏览器的原生工具
- en: With the Safari browser open, click **Safari**, select **Preferences**, and
    click on the **Advanced** tab. Click the checkbox next to "Show **develop menu
    in menu bar"** to begin using the native developer tools.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开Safari浏览器时，点击**Safari**，选择**首选项**，然后点击**高级**选项卡。点击“在菜单栏中显示**开发菜单**”旁边的复选框，开始使用原生开发者工具。
- en: Setting and getting a session storage variable
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和获取会话存储变量
- en: Session storage and local storage both share the web storage API. In this recipe,
    we will define two session storage variables, and then display them on the screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 会话存储和本地存储都共享Web存储API。在这个示例中，我们将定义两个会话存储变量，然后在屏幕上显示它们。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need an up-to-date browser that supports session storage. Safari and
    Google Chrome respond best if you are testing your files locally on your computer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个支持会话存储的最新版本的浏览器。如果您在本地计算机上测试文件，Safari和Google Chrome会有最佳响应。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we will create the head area of an HTML5 page and an opening `body`
    tag:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个HTML5页面的头部区域和一个开放的`body`标签：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add a `section` and an `article` tag. Give the article tag an ID of "aboutyou".
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`section`和一个`article`标签。给article标签一个ID为“aboutyou”。
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we will create two session storage variables using the `setItem` method
    as show in the following code block:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`setItem`方法创建两个会话存储变量，如下面的代码块所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we will display the session storage variables we just set on the screen
    using the `getElementByID` and `getItem` methods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`getElementByID`和`getItem`方法在屏幕上显示我们刚刚设置的会话存储变量：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The results should display on the HTML page in the browser similarly to how
    they are shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该在浏览器中的HTML页面上显示，类似于以下截图中显示的方式：
- en: '![How to do it...](img/1048_09_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1048_09_03.jpg)'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We set two session variables to unique values in this example. Session storage
    uses key/value pairs, so each variable must be set with a value when created.
    By default, these values are strings.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们为两个会话变量设置了唯一的值。会话存储使用键/值对，因此在创建时必须为每个变量设置一个值。默认情况下，这些值都是字符串。
- en: We defined a session variable for the person's nickname by typing `sessionStorage.setItem('`
    then added a name for our variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过输入`sessionStorage.setItem('`为人的昵称定义了一个会话变量，然后为我们的变量添加了一个名称。
- en: 'We named the variable `"nickname"` and gave it the value of "Jumpin Joseph":
    `''nickname'', ''Jumpin Joseph'')`;.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量命名为“nickname”，并赋予它值“Jumpin Joseph”：`'nickname', 'Jumpin Joseph')`。
- en: When we created a second session variable to contain the variable named `"interest"`
    and its value, we used the same syntax format as we did when setting the first
    session variable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建第二个会话变量来包含名为“interest”的变量及其值时，我们使用了与设置第一个会话变量时相同的语法格式。
- en: Although normally these variables would be populated with values from a form,
    we focused on using the correct syntax in the example. The `sessionStorage` keyword
    identified the type of storage method. We followed that with a period which attached
    the action `setItem` to the keyword. The variable `nickname` was then declared
    and given a value of `Jumpin Joseph`. What this will tell the browser when it
    is used is to create a new session storage variable named "nickname" and store
    the value of "Jumpin `Joseph"` inside it. We then created a second session storage
    variable just because we could. We will use a form to pull variable values in
    the local storage example in this chapter to give a full lifecycle view of storage
    method creation, usage, and destruction.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常这些变量将由表单中的值填充，但我们在示例中专注于使用正确的语法。`sessionStorage`关键字标识了存储方法的类型。我们在关键字后面加上一个句点，附加了`setItem`动作到关键字上。然后声明了变量`nickname`并赋予了值`Jumpin
    Joseph`。当使用时，这将告诉浏览器创建一个名为“nickname”的新会话存储变量，并将“Jumpin Joseph”的值存储在其中。然后我们创建了第二个会话存储变量，只是因为我们可以。在本章的本地存储示例中，我们将使用表单来获取本地存储变量的值，以便全面了解存储方法的创建、使用和销毁的完整生命周期视图。
- en: There's more...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Session storage gives us a more powerful way to provide short-term client side
    storage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 会话存储为我们提供了一种更强大的方式来提供短期客户端存储。
- en: One browser, one session
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个浏览器，一个会话
- en: Session storage is best used for situations that do not benefit from visitors
    using multiple tabs of their browser to navigate a site, and where the need for
    storage is temporary. While the data storage area of the HTML5 specification is
    still evolving, and the security does not have a long track record for use by
    financial institutions or other websites where information must be highly secure,
    there are still many useful ways to take advantage of session storage.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 会话存储最适合于不需要访问者使用多个浏览器标签来浏览网站，并且需要存储是临时的情况。虽然HTML5规范的数据存储区域仍在不断发展，安全性在金融机构或其他需要高度安全信息的网站使用方面并没有长期的记录，但仍然有许多有用的方法可以利用会话存储。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Setting and getting a local storage variable recipe*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*设置和获取本地存储变量的教程*。'
- en: Setting and getting a local storage variable
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和获取本地存储变量
- en: Although session storage is temporary, and lasts only as long as a browser session
    is active. Local storage persists even after a browser is closed. In this recipe,
    we will create a story-writing application using the HTML5 `contenteditable` attribute
    and local storage.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管会话存储是临时的，只在浏览器会话处于活动状态时持续。本地存储甚至在关闭浏览器后仍然存在。在这个教程中，我们将使用HTML5的`contenteditable`属性和本地存储创建一个故事写作应用程序。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should be using a recently updated browser. This recipe works best in Google
    Chrome and Safari but also functions fine in Firefox.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用最近更新的浏览器。这个教程在Google Chrome和Safari中效果最佳，但在Firefox中也可以正常运行。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First create a basic HTML5 page, and then add a script tag between the opening
    and closing `head` tags. The script should link to the 1.5.2 minimized jQuery
    library at [http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js](http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js).
    Your code should now look similar to the following block:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个基本的HTML5页面，然后在开放和关闭的`head`标签之间添加一个脚本标签。脚本应该链接到1.5.2最小化的jQuery库，网址为[http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js](http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js)。您的代码现在应该类似于以下代码块：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we will add CSS styles to set the `background-color` and text `color`
    of the article tag as well as the `font-family`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加CSS样式来设置文章标签的`background-color`和文本`color`，以及`font-family`。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Close the `head` tag and create opening tags for the `body` and `header` elements.
    Add an `h1` tag to display `Storywriter` as the page title, and close the `header`
    tag.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭`head`标签并为`body`和`header`元素创建开放标签。添加一个`h1`标签来显示页面标题为`Storywriter`，然后关闭`header`标签。
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create opening tags for the `section` and `article` elements. Add an id of "mypage"
    to the `article` element, and set the `contenteditable` attribute to "true".
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为`section`和`article`元素创建开放标签。将`article`元素的id设置为“mypage”，并将`contenteditable`属性设置为“true”。
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, create a paragraph tag which contains the placeholder text `type something`,
    and then close the paragraph, `article`, and `section` tags. Add descriptive instructional
    text between two `em` tags. What you just entered should look like the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个包含占位文本`type something`的段落标签，然后关闭段落、`article`和`section`标签。在两个`em`标签之间添加描述性的指令文本。您刚刚输入的内容应该如下所示的代码：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Create a `script` tag, and then declare the jQuery function by typing `$(function(){`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`script`标签，然后通过键入`$(function(){`声明jQuery函数。
- en: Invoke the `document.getElementById` method with an argument string of "mypage",
    assigning it to the variable 'edit'.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数字符串“mypage”调用`document.getElementById`方法，将其分配给变量'edit'。
- en: Next, we need to add an event handler triggered by the blur event on the 'edit'
    element. Type `$(edit).blur(function(){` , and then type `localStorage.setItem('storyData",
    this.innerHTML);})`; to complete the function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个由“edit”元素的模糊事件触发的事件处理程序。键入`$(edit).blur(function(){`，然后键入`localStorage.setItem('storyData",
    this.innerHTML);})`;以完成函数。
- en: Now that local storage can store strings with `setItem`, we can use `getItem`
    to push the stored string content back onto the page by typing `if ( localStorage.getItem('storyData')
    ) { edit.innerHTML = localStorage.getItem('storyData'); } })`;
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于本地存储可以使用`setItem`存储字符串，我们可以使用`getItem`通过键入`if ( localStorage.getItem('storyData')
    ) { edit.innerHTML = localStorage.getItem('storyData'); } })`将存储的字符串内容推送回页面。
- en: 'The script code block should now look like the following code block:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本代码块现在应该如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Close the body and HTML tags, and save the file. Open it in a browser window.
    You should now be able to begin typing your own story and see the entered text
    display on the page, even if you close the browser and reopen it again later.
    It should look similar to the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭body和HTML标签，并保存文件。在浏览器窗口中打开它。现在，您应该能够开始输入自己的故事，并在页面上看到输入的文本，即使您关闭浏览器，稍后再次打开它。它应该看起来类似于以下的屏幕截图：
- en: '![How to do it...](img/1048_09_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_09_04.jpg)'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we set the `article` tag's `contenteditable` attribute to `true`, we told
    the browser to allow users to enter text. Most HTML5 elements can have a `contenteditable`
    attribute declared and then set to `true` or `false`. We then captured the content
    as it was entered using `document.getElementById` using the id `mypage`. The `getElementById`
    jQuery method searches the document for a specific ID name listed in its argument.
    We then added an event handler on the `blur` event to smooth the look of the text
    being entered. We also stored the text at the same time using the local storage
    method `setItem` and the variable `storyData`. Finally, we used the `getItem`
    local storage method to check if `storyData` existed, and if it did, to load it
    into an editable HTML element with `edit.innerHTML` and `getItem`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`article`标签的`contenteditable`属性设置为`true`时，我们告诉浏览器允许用户输入文本。大多数HTML5元素都可以声明`contenteditable`属性，然后将其设置为`true`或`false`。然后，我们使用`document.getElementById`使用ID`mypage`捕获输入的内容。`getElementById`
    jQuery方法会在其参数中搜索特定ID名称的文档。然后，我们在`blur`事件上添加了一个事件处理程序，以使输入的文本看起来更加平滑。同时，我们还使用本地存储方法`setItem`和变量`storyData`存储文本。最后，我们使用`getItem`本地存储方法来检查`storyData`是否存在，如果存在，则将其加载到可编辑的HTML元素中，使用`edit.innerHTML`和`getItem`。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Earlier chapters in this book on HTML5 elements, and PACKT jQuery books.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章介绍了HTML5元素和PACKT jQuery书籍。
- en: Converting local storage strings to numbers using parseInt
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`parseInt`将本地存储的字符串转换为数字
- en: In this recipe, we will take a string value from local storage and convert it
    into an integer so we can perform a mathematic operation on it by using `parseInt`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将从本地存储中获取一个字符串值，并将其转换为整数，以便我们可以使用`parseInt`进行数学运算。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Modernizr ([http://www.modernizr.com](http://www.modernizr.com))
    to detect if local storage is available, hosting it locally in a subfolder named
    "js". You will also need at least one recently updated browser.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Modernizr ([http://www.modernizr.com](http://www.modernizr.com))来检测本地存储是否可用，将其托管在名为"js"的子文件夹中。您还需要至少一个最近更新的浏览器。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the beginnings of a new html page up to the title tag as shown in the
    code block below:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的代码块创建一个新的html页面的开始，直到标题标签为止：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, add styles to specify the font-family, the text color of the `h1` and
    `h2` tag, and a background-color and height for the `h2` tag.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加样式来指定`h1`和`h2`标签的字体族、文本颜色，以及`h2`标签的背景颜色和高度。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add an IE HTML5 shiv, hosted by Google, and a link to a local Modernizr JavaScript
    file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个由Google托管的IE HTML5 shiv，并添加一个指向本地Modernizr JavaScript文件的链接：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Perform a check to see if local storage is supported by the browser with some
    help from the Modernizr script:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Modernizr脚本来检查浏览器是否支持本地存储：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Create a function named `storemyradius()`, declare a variable named `myradiusToSave`,
    and assign it `document.getElementById('myradius').value`; to pass the value entered
    by the visitor into the text field when they click save.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`storemyradius()`的函数，声明一个名为`myradiusToSave`的变量，并将其赋值为`document.getElementById('myradius').value`；以便在访问者点击保存时将输入的数值传递到文本字段中。
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add an `if` statement to check if `myradiusToSave` is null. Below that, create
    a local storage `setItem` method with a key of "myradius" and a value of "myradiusToSave".
    Place a function call to `displaymyradius()`; before the closing bracket of the
    `if` statement and the `storemyradius` function as shown in the following code
    block:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`if`语句来检查`myradiusToSave`是否为null。在此之下，创建一个本地存储`setItem`方法，键为"myradius"，值为"myradiusToSave"。在`if`语句的闭合括号和`storemyradius`函数的闭合括号之前，放置一个对`displaymyradius()`的函数调用，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a function named `displaymyradius`, which accepts no arguments, and
    then add a variable named `myradius`. Assign to it the JavaScript function `parseInt`
    containing a local storage `getItem` method with an argument of "myradius" and
    a radix of 10\. The function should look like the following code block so far:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`displaymyradius`的函数，不接受任何参数，然后添加一个名为`myradius`的变量。将其赋值为包含一个本地存储`getItem`方法的JavaScript函数`parseInt`，参数为"myradius"，基数为10。到目前为止，函数应该如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the same function, create an if statement that will check to see that the
    `myradius` variable is not null and is greater than zero. Create the variable
    `diameter`, and assign as its value the result of multiplying `2` times the value
    in `myradius`. Use `document.getElementById` and `innerHTML` to display the value
    of the diameter variable along with the message "The `diameter of the circle is"`
    between the h2 tags in the body of the HTML page.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，创建一个`if`语句，用于检查`myradius`变量是否不为null且大于零。创建变量`diameter`，并将其值赋为`2`乘以`myradius`的结果。使用`document.getElementById`和`innerHTML`来显示直径变量的值，以及在HTML页面的`h2`标签之间显示消息"The
    `diameter of the circle is`"。
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a function named `clearmyradius` that accepts no arguments, and then
    create an `if` statement that checks if the local storage `getItem` method contains
    a value that is not null. Between the `if` statement brackets, place the local
    storage `removeItem` method with an argument string of "myradius" and a call to
    the local storage `clear` method. Close the script and head tags. The code we
    just wrote should look similar to the following code block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`clearmyradius`的函数，不接受任何参数，然后创建一个`if`语句，检查本地存储`getItem`方法是否包含一个不为null的值。在`if`语句的括号之间，放置本地存储`removeItem`方法，参数为字符串"myradius"，以及对本地存储`clear`方法的调用。关闭脚本和头标签。我们刚刚写的代码应该看起来类似于以下的代码块：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create opening body, section, `hgroup` and `h1` tags, and type `"localStorage
    Number Conversion"` before the closing `h1` tag. Create an `h2` tag and assign
    it an ID of `"yayanswer"`. Close the `hgroup` tag, and then add a label tag for
    the `myradius` text field. Type `"Enter the radius of the circle:"` as the label
    text. Create an input form field tag with an ID of `"myradius"` and a `maxlength`
    of `"4"`. Create two input buttons, one with an `onclick` value that calls the
    function `storemyradius()`; and another with an `onclick` value that calls the
    function `clearmyradius();.` Close the section, body, and html tags, and save
    the page. The final block of code should look like the following one:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建开放的body、section、`hgroup`和`h1`标签，在关闭的`h1`标签之前输入`"localStorage Number Conversion"`。创建一个`h2`标签，并为其分配一个ID为`"yayanswer"`。关闭`hgroup`标签，然后为`myradius`文本字段添加一个标签标签。输入标签文本为`"输入圆的半径:"`。创建一个带有ID为`"myradius"`和`maxlength`为`"4"`的输入表单字段标签。创建两个输入按钮，一个带有`onclick`值调用函数`storemyradius()`；另一个带有`onclick`值调用函数`clearmyradius()`。关闭section、body和html标签，并保存页面。最终的代码块应该如下所示：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is how the finished HTML page should look in a Google Chrome browser window:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Chrome浏览器窗口中，完成的HTML页面应该如下所示：
- en: '![How to do it...](img/1048_09_05.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_09_05.jpg)'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The text field displayed in the HTML page accepts what the visitor types and
    passes it as a value to the `storemyradius()` function. We declared a variable
    named `myradiusToSave` and assigned it `document.getElementById('myradius').value`;
    which stored the value contained in `myradius`. It in turn will pass the value
    entered in the text field "myradius" to the `setItem` method of local storage.
    Before the value can be passed to local storage we needed to verify that `myradiusToSave`
    actually contained a value that was not null. If it is not null, then there is
    data to save to local storage. The value was then saved to local storage, using
    `setItem` as a part of a key/value pair. To use the `myradius` value as a number,
    we needed to convert it back from a string to an integer. This was done by calling
    the `parseInt` JavaScript function. Next, we created a variable named `diameter`
    to hold the result of our diameter formula, which is 2 multiplied by the value
    of the radius. Finally, we returned the result to the screen using the `getElementbyId`
    method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML页面中显示的文本字段接受访问者输入并将其作为值传递给`storemyradius()`函数。我们声明了一个名为`myradiusToSave`的变量，并将其分配为`document.getElementById('myradius').value`；它存储了`myradius`中包含的值。然后，它将传递到本地存储的`setItem`方法中。在将值传递到本地存储之前，我们需要验证`myradiusToSave`实际上包含的值不是null。如果不是null，则有数据保存到本地存储。然后，该值作为键/值对的一部分保存到本地存储中，使用`setItem`。为了将`myradius`值作为数字使用，我们需要将其从字符串转换为整数。这是通过调用`parseInt`
    JavaScript函数来完成的。接下来，我们创建了一个名为`diameter`的变量，用于保存我们的直径公式的结果，即半径值的两倍。最后，我们使用`getElementbyId`方法将结果返回到屏幕上。
- en: The other option we had on the page was to clear the value of the local storage
    variable. While we could have just used the `removeItem` method, using the clear
    method as well insured that there were no other local storage variables lurking
    around. A refresh of the page with Google Developer Tools open verified that the
    local storage area was empty.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个页面上的选项是清除本地存储变量的值。虽然我们本可以使用`removeItem`方法，但同时使用clear方法可以确保没有其他潜在的本地存储变量。通过打开Google开发者工具刷新页面，可以验证本地存储区域为空。
- en: There's more...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Currently by default `localStorage` stores all data as strings. We just practiced
    converting `localStorage` variables into integers, but they can also be converted
    into objects such as arrays.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '当前，默认情况下`localStorage`将所有数据存储为字符串。我们刚刚练习了将`localStorage`变量转换为整数，但它们也可以转换为数组等对象。 '
- en: Storing and retrieving arrays in localStorage
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在localStorage中存储和检索数组
- en: There will be many times when you will want to use arrays with `localStorage`
    to save progress in a game or retain user data or messages. You can use the JSON
    library by Douglas Crockford to streamline the storing and retrieving of arrays.
    Visit [https://github.com/douglascrockford/JSON-js](http://https://github.com/douglascrockford/JSON-js)
    to download code and learn more about JSON.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您会希望使用`localStorage`与数组一起保存游戏中的进度或保留用户数据或消息。您可以使用Douglas Crockford的JSON库来简化数组的存储和检索。访问[https://github.com/douglascrockford/JSON-js](http://https://github.com/douglascrockford/JSON-js)下载代码并了解更多关于JSON的信息。
- en: 'Create a new HTML5 page, and add script tags between two footer tags. Declare
    a new variable array named "horsedef", and assign it the following key/value pairs
    as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的HTML5页面，并在两个页脚标签之间添加脚本标签。声明一个名为"horsedef"的新变量数组，并将其分配为以下键/值对，如下所示：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, set a new item named "describehorse" in local storage, while also using
    `JSON` to turn our array `horsedef` into a string as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在本地存储中设置一个名为"describehorse"的新项目，同时使用`JSON`将我们的数组`horsedef`转换为字符串，如下所示：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Retrieve the values from local storage using JSON parse:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON解析从本地存储中检索值：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Save the page, and open a browser window. You should see an alert box showing
    the key/value pairs in the `horsedef` array that were passed to `describehorse`
    as shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 保存页面，打开浏览器窗口。您应该看到一个警报框，显示传递给`describehorse`的`horsedef`数组中的键/值对，如下面的屏幕截图所示：
- en: '![Storing and retrieving arrays in localStorage](img/1048_09_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![在localStorage中存储和检索数组](img/1048_09_06.jpg)'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Beware of cross-site callbacks when using JSON. It is usually best to download
    and use a file off your own server. Always download your copy of JSON directly
    from the source. Don't fall for imitations like JSONP.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JSON时要注意跨站点回调。通常最好从自己的服务器下载并使用文件。始终直接从源下载JSON的副本。不要上当受骗，比如JSONP。
- en: Creating a Web SQL Database
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Web SQL数据库
- en: In this recipe we will create a web SQL database and give it attributes that
    define its version, name, size, and description.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个Web SQL数据库，并赋予它定义版本、名称、大小和描述的属性。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to be using a current browser that supports web SQL databases.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用支持Web SQL数据库的当前浏览器。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new HTML5 file, and place opening and closing script tags between
    two footer tags. Declare a variable named `db`, then assign `openDatabase()` to
    it. Give `openDatabase` the following arguments: `''mymotodb'', ''1.0'', ''Motocross
    Rider List DB'', 2 * 1024 * 1024`, and then close the declaration. The code should
    look like the following snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的HTML5文件，并在两个页脚标签之间放置打开和关闭脚本标签。声明一个名为`db`的变量，然后将`openDatabase()`赋给它。给`openDatabase`以下参数：`'mymotodb',
    '1.0', 'Motocross Rider List DB', 2 * 1024 * 1024`，然后关闭声明。代码应该看起来像以下代码片段：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Save the file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All web SQL databases use the `openDatabase` method to assign values to a database.
    The first argument "mymotodb" was the name of the database. The next and required
    argument was the version number. The number here must match whenever the user
    attempts to use the web SQL database. Next, we defined the description of the
    database, then the estimated size. Once all the arguments are defined for the
    requested `openDatabase` method, the database is created and a first (and invisible)
    transaction takes place — the creation of the database itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Web SQL数据库都使用`openDatabase`方法来为数据库分配值。第一个参数“mymotodb”是数据库的名称。下一个必需的参数是版本号。这里的数字必须与用户尝试使用Web
    SQL数据库时匹配。接下来，我们定义了数据库的描述，然后是估计的大小。一旦为请求的`openDatabase`方法定义了所有参数，数据库就被创建了，并且进行了第一次（不可见的）事务——数据库本身的创建。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Browser implementation of specifications such as Web SQL databases has been
    very unpredictable and so has the support of such specifications themselves within
    the web development community.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Web SQL数据库之类的规范的浏览器实现一直非常不可预测，同样，Web开发社区对这些规范本身的支持也是如此。
- en: Web SQL may be replaced by SQLite
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web SQL可能会被SQLite取代
- en: The Web SQL database specification itself is no longer being maintained by the
    W3C, but it works reasonably well in most browsers. It is possible within the
    next year or so that enough major stakeholders will agree on how to implement
    a different client-side database solution such as SQLite, but such things can
    be difficult to predict. Keep an eye on the specification at [http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/)
    for updates on current options for using client-side databases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Web SQL数据库规范本身已不再由W3C维护，但在大多数浏览器中运行得相当好。可能在接下来的一年左右，足够多的主要利益相关者将会就如何实现不同的客户端数据库解决方案达成一致，比如SQLite，但这样的事情很难预测。关注[http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/)上的规范，了解使用客户端数据库的当前选项的更新。
- en: Using a Web SQL database
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web SQL数据库
- en: In this recipe, we will take the database we created in the previous recipe
    and add tables and data to it then display the results on an HTML page.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将使用前面步骤中创建的数据库，并向其中添加表和数据，然后在HTML页面上显示结果。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a current browser and an HTML5 page with basic tags for the head
    area and body area.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个当前的浏览器和一个带有基本标签的HTML5页面，用于头部区域和主体区域。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On a basic HTML5 page, add an `h1` tag to display a page heading, and then
    create a `div` tag with an ID of "status" to hold our results as shown in the
    following code block:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个基本的HTML5页面上，添加一个`h1`标签来显示页面标题，然后创建一个ID为“status”的`div`标签来保存我们的结果，如下面的代码块所示：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Begin the script as shown in the previous recipe to create the database if
    you have not already. Create a new variable named info, and then create a new
    transaction that contains a function that accepts an argument. Using the passed
    argument, create a table named RIDERS with a unique id and a row named `ridername`.
    The code should look similar to the following block:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未创建数据库，请按照前面的步骤开始脚本以创建数据库。创建一个名为info的新变量，然后创建一个包含接受参数的函数的新事务。使用传递的参数，创建一个名为RIDERS的带有唯一ID和名为`ridername`的行的表。代码应该类似于以下代码块：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add data into the table rows, with a number for the unique id and a text string
    for each name:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据添加到表行中，使用唯一ID的数字和每个名称的文本字符串：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Perform a query to pull data from the database:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询以从数据库中提取数据：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new variable and `for` loop to cycle through results and print them
    to the screen:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新变量和`for`循环，循环遍历结果并将其打印到屏幕上：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Close the script and the HTML page.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭脚本和HTML页面。
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we open the page we just created in a browser, we’ll see the information
    we used the database to display. This is because the query and loop work together
    to look through the database and display the appropriate information.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中打开我们刚创建的页面时，我们将看到我们使用数据库来显示的信息。这是因为查询和循环一起查看数据库并显示适当的信息。
- en: '![How it works...](img/1048_09_07.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1048_09_07.jpg)'
- en: There's more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Security and database transactions in HTML5 can be poorly executed. Care should
    be taken to safeguard any pages that accept SQL queries in a production environment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5中，安全性和数据库事务可能执行不佳。在生产环境中，应该注意保护接受SQL查询的任何页面。
- en: Save script code in a separate file
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在单独的文件中保存脚本代码
- en: To keep things simple in this recipe, we did not stash the SQL query code and
    JavaScript in a separate file. This could be done by saving the code in a subfolder
    such as `../js/myCode.js`. Beware using web SQL, Indexed DB or any other type
    of browser-based query APIs for secure information.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本步骤，我们没有将SQL查询代码和JavaScript保存在单独的文件中。可以通过将代码保存在子文件夹中，如`../js/myCode.js`来完成。谨慎使用Web
    SQL、Indexed DB或任何其他类型的基于浏览器的查询API来获取安全信息。
- en: Guard against SQL injection on production servers
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在生产服务器上防范SQL注入
- en: Anytime there is an editable field, some bot is likely going to come along and
    try to perform a SQL Injection attack. Basic precautions can be taken by using
    "?" within transaction requests. The following code shows an example.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有可编辑字段时，都可能会有一些机器人尝试执行SQL注入攻击。可以通过在事务请求中使用“?”来采取基本预防措施。以下代码显示了一个例子。
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Packt books on SQL, any Packt HTML5 books that also cover client-side databases.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: SQL的Packt图书，任何覆盖客户端数据库的Packt HTML5图书。
- en: Creating a cache manifest for offline storage
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为离线存储创建缓存清单
- en: In this recipe we will create a cache manifest file to enable us to store an
    HTML5 page offline and still view the images and video displayed on the page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个缓存清单文件，以便我们能够离线存储HTML5页面，并仍然查看页面上显示的图像和视频。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need an HTML5 page, such as the one provided in the code files of this
    recipe, and access to upload files to a server, and then view them on a computer,
    smart phone, or other web-enabled device with a browser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个HTML5页面，例如本示例的代码文件中提供的页面，并且可以上传文件到服务器，然后在计算机、智能手机或其他具有浏览器的网络设备上查看它们。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we will create the Cache Manifest file. This should be created in a
    simple text editor. It should contain all the files and supporting code a user
    will need to access while offline. The first thing listed is the current file
    type (CACHE MANIFEST). The version number of the manifest should also be included.
    Notice we add paths to all the files we want the users to have access to in the
    following block of code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建缓存清单文件。这应该在一个简单的文本编辑器中创建。它应该包含用户在离线时需要访问的所有文件和支持代码。首先列出的是当前文件类型（CACHE
    MANIFEST）。清单的版本号也应包括在内。请注意，我们在以下代码块中添加了所有我们希望用户在离线时访问的文件的路径：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a manifest attribute to the `index.html` page between the opening `DOCTYPE`
    tag and `head` tags as shown:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`页面的`DOCTYPE`标签和`head`标签之间添加一个manifest属性，如下所示：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, create a `.htaccess` file to create the correct mime type:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个`.htaccess`文件来创建正确的MIME类型：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The page should display similar to the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 页面应该显示类似于以下内容：
- en: '![How to do it...](img/1048_09_08.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1048_09_08.jpg)'
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Creating a cache manifest gives a browser a checklist to use when loading a
    page offline. While the idea behind storing a page offline is that it should not
    need to update frequently, using a version number allows the author to push updates
    to the user the next time they connect to the Internet.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 创建缓存清单为浏览器提供了一个加载离线页面时使用的清单。虽然离线存储页面的想法是它不需要频繁更新，但使用版本号允许作者在用户下次连接到互联网时推送更新。
- en: Not all browsers or systems can properly interpret the manifest file type, so
    including an `.htaccess` file ensures that the cache manifest is recognized correctly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有浏览器或系统都能正确解释清单文件类型，因此包括一个`.htaccess`文件可以确保缓存清单被正确识别。
- en: You can exclude files that you feel are not crucial to lower the size of the
    offline page and reduce load time.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以排除您认为不重要的文件，以减小离线页面的大小并减少加载时间。
- en: Displaying the current location using geolocation and geo.js
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地理位置和geo.js显示当前位置
- en: In this recipe, we will use the geolocation specification and `geo.js` to display
    the current location of an active user on a map, and show their current latitude
    and longitude.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用地理位置规范和`geo.js`来显示地图上活动用户的当前位置，并显示他们当前的纬度和经度。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Visit [http://code.google.com/p/geo-location-javascript/](http://code.google.com/p/geo-location-javascript/)
    to download the latest version of `geo.js`, or grab the link URL from the wiki
    (http://code.google.com/p/geo-location-javascript/wiki/JavaScriptAPI) to link
    to it directly online.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://code.google.com/p/geo-location-javascript/](http://code.google.com/p/geo-location-javascript/)下载最新版本的`geo.js`，或者从wiki
    (http://code.google.com/p/geo-location-javascript/wiki/JavaScriptAPI)获取链接URL以直接在线链接到它。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we will create HTML5 opening page tags:<head></head>.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建HTML5开头页面标签：<head></head>。
- en: 'Then, in the meta tag, we will set the name attribute to "viewport", and define
    the following values for the content attribute: `width = device-width; initial-scale=1.0;
    maximum-scale=1.0; user-scalable=no`;'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在meta标签中，我们将把name属性设置为“viewport”，并为content属性定义以下值：`width = device-width;
    initial-scale=1.0; maximum-scale=1.0; user-scalable=no`;
- en: 'Now, declare a script tag with the src attribute of: [http://code.google.com/apis/gears/gears_init.js](http://code.google.com/apis/gears/gears_init.js)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，声明一个带有src属性的脚本标签：[http://code.google.com/apis/gears/gears_init.js](http://code.google.com/apis/gears/gears_init.js)
- en: 'Then, call the `geo.js` script: `src="img/geo.js"`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用`geo.js`脚本：`src="img/geo.js"`。
- en: 'The code block should look like the following so far:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码块应该如下所示：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add a script tag for the Google Maps API: `<script type="text/javascript" src="img/js?sensor=false"></script>`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为Google Maps API添加一个脚本标签：`<script type="text/javascript" src="img/js?sensor=false"></script>`。
- en: 'Now, we will create a function to initialize the map named `initialize_map()`,
    and then create an array named `myOptions` to store the map attributes. The attributes
    are based on the Google Maps API. They should look similar to the following code
    block:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个初始化地图的函数，命名为`initialize_map()`，然后创建一个名为`myOptions`的数组来存储地图属性。这些属性基于Google
    Maps API。它们应该类似于以下代码块：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Add a new map to the page named map using the method `google.maps.Map()`, which
    takes the `document.getElementById` element as an argument, which in turn is being
    passed the id "map_canvas". The other method accepted by `google.maps.Map` is
    `myOptions`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`google.maps.Map()`方法向页面添加一个名为map的新地图，该方法将`document.getElementById`元素作为参数，该元素又传递了id“map_canvas”。`google.maps.Map`接受的另一个方法是`myOptions`。
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Create the `initialize()` function, and add an `if` statement to check if the
    `geo_position_js.init()` function is active. Enter a new status for the div with
    the id of "current" using `document.getElementById` and `innerHTML`. Type "Receiving…"
    for the status text.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`initialize()`函数，并添加一个`if`语句来检查`geo_position_js.init()`函数是否激活。使用`document.getElementById`和`innerHTML`为id为“current”的div输入一个新状态。状态文本为“接收中…”。
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add helper message text to display if we are not able to fetch the location
    or if for whatever reason the browser does not support fetching the current position,
    as shown in the following code block:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 添加帮助消息文本，以显示如果我们无法获取位置或者由于某种原因浏览器不支持获取当前位置，如下所示的代码块：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Create a new variable named `infowindow` to display the `google.maps InfoWindow`,
    a bubble that will display when a marker is clicked. Give it a text string of
    "yes" to display. Create a new marker tied to the current position of the user,
    along with title text for the marker that will display on mouse or pointer hover.
    Add an event listener to detect when the marker is clicked.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`infowindow`的新变量，用于显示`google.maps InfoWindow`，即在点击标记时显示的气泡。给它一个文本字符串“yes”来显示。创建一个新的标记，与用户当前位置相关联，并为标记添加标题文本，以便在鼠标悬停时显示。添加一个事件监听器来检测标记何时被点击。
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Style the page to control the font-family, padding, and the look of the title
    and current divs.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 样式化页面以控制字体系列、填充和标题和当前div的外观。
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Create an `onLoad` command in the body tag that initializes both `initialize_map()`;
    and the `initialize()`; function on page load. Create a new `div` to display the
    page title and a second `div` with an id of "current" to display the current status
    of the location fetching process. Finally, create a `div` with an id of `map_canvas`
    to contain the map once it displays, and set the width and height of the `div`
    using an inline style. Close the tags and save the page.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在body标签中创建一个`onLoad`命令，初始化`initialize_map()`和`initialize()`函数。创建一个新的`div`来显示页面标题，以及一个id为“current”的第二个`div`来显示位置获取过程的当前状态。最后，创建一个id为`map_canvas`的`div`来包含地图一旦显示，并使用内联样式设置`div`的宽度和高度。关闭标签并保存页面。
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open up the page in a browser window, and you should see a result similar to
    the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器窗口中打开页面，您应该会看到类似以下截图的结果：
- en: '![How to do it...](img/1048_09_09.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/1048_09_09.jpg)'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Using `geo.js` simplifies using geolocation for multiple devices. It provides
    prepared error messages and follows the W3C implementation standards, as well
    as the ability to "fall back" to tools such as Google Gears. First, we had to
    create a script with variables to contain arrays of map display and processing
    options, instantiate a new map object, and draw a marker to pin the current location
    of the user onto the screen. Hovering over the pin displayed a bubble window with
    title text. This same text could contain a link to pull and show driving directions,
    reviews, or notes. When the page was loaded, the map options creation function
    `map_initialize()`, and the main action triggering function `initialize()` was
    called. A temporary status message was displayed while the current location of
    the user was determined with the help of `geo.js`, and the map was drawn.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`geo.js`简化了在多个设备上使用地理定位的过程。它提供了准备好的错误消息，并遵循W3C的实现标准，以及“回退”到诸如Google Gears之类的工具的能力。首先，我们需要创建一个包含地图显示和处理选项数组的变量的脚本，实例化一个新的地图对象，并绘制一个标记以将用户的当前位置固定到屏幕上。在标记上悬停会显示一个带有标题文本的气泡窗口。这个文本也可以包含一个链接，用于拉取和显示驾驶方向、评论或笔记。当页面加载时，地图选项创建函数`map_initialize()`和主要的触发函数`initialize()`被调用。在使用`geo.js`的帮助下确定用户的当前位置并绘制地图时，会显示一个临时状态消息。
