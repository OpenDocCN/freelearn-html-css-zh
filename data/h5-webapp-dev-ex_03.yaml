- en: Chapter 3. The Devil is in the Details
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。细节决定成败
- en: '"Men who wish to know about the world must learn about it in its particular
    details."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “希望了解世界的人必须从具体细节中了解它。”
- en: '*—Heraclitus*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*—赫拉克利特*'
- en: '*This chapter is all about the new HTML5 input types and how to interact with
    them using JavaScript. In [Chapter 1](ch01.html "Chapter 1. The Task at Hand"),
    *The Task at Hand*, we created a task list application and in [Chapter 2](ch02.html
    "Chapter 2. Let''s Get Stylish"), *Let''s Get Stylish*, we styled it using new
    CSS3 styles. In this chapter we continue to improve it by adding a task details
    section using the new HTML5 input types. Then we will use custom data attributes
    to automatically bind values in the view to the data model in our application.
    We will also add some jQuery animations to make UI transitions smoother.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章主要介绍新的HTML5输入类型以及如何使用JavaScript与其进行交互。在[第1章](ch01.html "第1章。手头的任务")中，*手头的任务*，我们创建了一个任务列表应用程序，在[第2章](ch02.html
    "第2章。时尚起来")中，*时尚起来*，我们使用了新的CSS3样式对其进行了美化。在本章中，我们将继续改进它，通过添加新的HTML5输入类型的任务详细信息部分。然后，我们将使用自定义数据属性自动将视图中的值绑定到应用程序中的数据模型。我们还将添加一些jQuery动画，使UI过渡更加流畅。*'
- en: 'We will learn the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中学习以下主题：
- en: The new HTML5 input types and what benefits they provide
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的HTML5输入类型及其提供的好处
- en: Custom data attributes and their uses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义数据属性及其用途
- en: How to bind a data model to input elements using custom data attributes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用自定义数据属性将数据模型绑定到输入元素
- en: Using jQuery animation methods to hide and show elements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery动画方法隐藏和显示元素
- en: Using timers to queue up saves to localStorage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用定时器将保存到localStorage的内容排队
- en: HTML5 input types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5输入类型
- en: HTML5 comes with a whole host of new input types. These new types are designed
    to provide formatting, validation, and in some cases, selectors. For touch devices
    some of them provide a different set of keys for the keyboard. Not all of the
    new input types are supported by all browsers yet. Fortunately for us, if a browser
    doesn't support a type it will just display it as a normal text field. Unfortunately
    for us, you can't depend on the browser to provide the correct formatted data
    if the unsupported types are only shown as text fields. So make sure you have
    a backup plan if you are going to use them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5带来了一系列新的输入类型。这些新类型旨在提供格式化、验证，有时还提供选择器。对于触摸设备，其中一些类型为键盘提供了不同的按键。并非所有新的输入类型都得到了所有浏览器的支持。幸运的是，如果浏览器不支持某种类型，它将只是将其显示为普通文本字段。不幸的是，如果不支持的类型只显示为文本字段，您不能依赖浏览器提供正确格式化的数据。因此，如果您要使用它们，请确保您有备用方案。
- en: Here are a few of the more useful new input types with images of the ones that
    are supported by Chrome.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些更有用的新输入类型，以及Chrome支持的其中一些类型的图像。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See examples in `Chapter 3/input-types/input-types.html`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见`第3章/输入类型/input-types.html`中的示例。
- en: Color
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色
- en: 'The `color` input type is used to choose a color. When clicked it usually displays
    a color picker. The value is a hex color specifier (for example, #FF0000). This
    control isn''t widely supported for now, so use with caution.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`color`输入类型用于选择颜色。单击时通常会显示颜色选择器。值是十六进制颜色指示符（例如，#FF0000）。目前这个控件的支持范围有限，因此请谨慎使用。'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Color](img/5947OT_03_04.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![颜色](img/5947OT_03_04.jpg)'
- en: Date
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期
- en: 'The `date` input type is used to select a date. When clicked it usually displays
    a date picker. The value is a date string in the format yyyy-mm-dd (for example,
    2013-01-23). You may also specify the `min` and `max` attributes in the same date
    format to limit the date span:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`输入类型用于选择日期。单击时通常会显示日期选择器。值是yyyy-mm-dd格式的日期字符串（例如，2013-01-23）。您还可以以相同的日期格式指定`min`和`max`属性，以限制日期范围：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Date](img/5947OT_03_05.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![日期](img/5947OT_03_05.jpg)'
- en: Email
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子邮件
- en: 'The `email` input type is used to enter an e-mail address. It looks and behaves
    like a standard text field. On touch devices the keyboard usually changes to provide
    e-mail symbols such as the *@* sign and *.com*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`email`输入类型用于输入电子邮件地址。它的外观和行为类似于标准文本字段。在触摸设备上，键盘通常会更改以提供电子邮件符号，如*@*符号和*.com*：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Number
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'The `number` input type is used to enter a number. It is usually displayed
    with up and down buttons (a spinner control) that change the value by the `step`
    amount when clicked. On touch devices the keyboard may change to a number pad.
    There are a few attributes you can use to restrict the field:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`number`输入类型用于输入数字。通常会显示带有上下按钮（微调控件）的形式，单击时会按`step`的量更改值。在触摸设备上，键盘可能会更改为数字键盘。您可以使用一些属性来限制字段：'
- en: '`min`: This specifies the minimum value allowed'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`：指定允许的最小值'
- en: '`max`: This specifies the maximum value allowed'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`：指定允许的最大值'
- en: '`step`: This specifies the amount by which value changes when you click on
    the up or down spinner buttons'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`：指定单击上下微调按钮时值更改的量'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Number](img/5947OT_03_06.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![数字](img/5947OT_03_06.jpg)'
- en: Range
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: The `range` input type is used to choose a value from a range of values. This
    is nearly identical to the `number` input type, except that it is usually displayed
    as a slider control. It has the same attributes as the `number` input type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`输入类型用于从一系列值中选择一个值。这几乎与`number`输入类型相同，只是通常显示为滑块控件。它具有与`number`输入类型相同的属性。'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Range](img/5947OT_03_07.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![范围](img/5947OT_03_07.jpg)'
- en: Time
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间
- en: The `time` input type is used to select a time. When clicked it may display
    a time picker or you can set the time using the spinners. The value is a 24-hour
    format time string in the format hh:mm:ss (for example, 13:35:15).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`输入类型用于选择时间。单击时，它可能会显示时间选择器，或者您可以使用微调器设置时间。值是24小时格式的时间字符串，格式为hh:mm:ss（例如，13:35:15）。'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Time](img/5947OT_03_08.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![时间](img/5947OT_03_08.jpg)'
- en: URL
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL
- en: The `url` input type is used to enter a URL. Like the `email` type, touch devices
    usually display a keyboard optimized for entering a URL.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`输入类型用于输入URL。与`email`类型一样，触摸设备通常会显示为优化输入URL的键盘。'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Datalist
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据列表
- en: In addition to these new input types, a new `<datalist>` form element has been
    added in HTML5\. It is used to add a drop-down list of hints to a text field.
    When the user starts typing in the text field, all of the list options that match
    the letters being typed will be shown in a dropdown under the field. The user
    can select one of the options to automatically fill in the field.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些新的输入类型，HTML5中还添加了一个新的`<datalist>`表单元素。它用于为文本字段添加一个下拉提示列表。当用户开始在文本字段中输入时，与正在输入的字母匹配的所有列表选项将显示在字段下的下拉菜单中。用户可以选择其中一个选项来自动填写字段。
- en: You associate a `<datalist>` element with a text field by setting an ID on the
    `<datalist>` element, and referencing it with the `list` attribute of an `<input>`
    element.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`<datalist>`元素上设置一个ID，并在`<input>`元素的`list`属性中引用它，将`<datalist>`元素与文本字段关联起来。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Datalist](img/5947OT_03_09.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![数据列表](img/5947OT_03_09.jpg)'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because implementation of the new input types is spotty at this times, be cautious
    when using them. Using a `number` field isn't going to cause many problems if
    it's not supported; the user can still enter a number in the text field. But something
    like the `color` field, if not supported, shows as a text field. Will your user
    be willing to enter a color in hex code in that case?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新输入类型的实现在这个时候还不够完善，所以在使用它们时要小心。如果不支持使用`number`字段不会引起太多问题；用户仍然可以在文本字段中输入数字。但是如果像`color`字段这样的东西不被支持，它会显示为一个文本字段。在这种情况下，你的用户愿意输入十六进制代码的颜色吗？
- en: Autofocus
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动聚焦
- en: There's one more useful addition to HTML5 input elements. A new `autofocus`
    attribute was added to set the focus on a particular `<input>` element when the
    page is first loaded. Previously we did this in our application by calling the
    jQuery `focus()` method for the `<input id="new-task-name">` element. We can do
    the same thing in HTML5 by just adding the `autofocus` attribute.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5输入元素还有一个有用的补充。新增了一个`autofocus`属性，用于在页面首次加载时设置焦点在特定的`<input>`元素上。以前我们在应用程序中通过调用jQuery的`focus()`方法来为`<input
    id="new-task-name">`元素设置焦点。在HTML5中，我们可以通过添加`autofocus`属性来实现相同的功能。
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Task details
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务详细信息
- en: Let's put some of these new input types to good use in our task list application.
    At the moment all we have is a task name input field. There's not much we can
    do with that. So let's add some fields to each task to allow the user to define
    more details about them. You can find the source code for this section in `Chapter
    3\example3.1`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的任务列表应用程序中充分利用一些新的输入类型。目前我们只有一个任务名称输入字段。我们对此无能为力。所以让我们为每个任务添加一些字段，让用户可以定义更多关于它们的细节。你可以在`Chapter
    3\example3.1`中找到这一部分的源代码。
- en: Time for action – adding task details
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加任务详细信息
- en: 'We will give each task the following new fields:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个任务添加以下新字段：
- en: '**Start date**: The date the task should start. The input type is `date`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始日期**：任务应该开始的日期。输入类型为`date`。'
- en: '**Due date**: The date the task should be done by. The input type is `date`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**截止日期**：任务应该完成的日期。输入类型为`date`。'
- en: '**Status**: Drop-down list `<select>` with options for **None**, **Not Started**,
    **Started**, and **Completed**.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：下拉列表`<select>`，选项为**无**，**未开始**，**已开始**和**已完成**。'
- en: '**Priority**: Drop-down list `<select>` with options for **None**, **Low**,
    **Normal**, and **High**.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：下拉列表`<select>`，选项为**无**，**低**，**正常**和**高**。'
- en: '**% Complete**: The input type is `number`, with a valid range from **0** to
    **100**.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% 完成**：输入类型为`number`，有效范围为**0**到**100**。'
- en: 'Let''s define these fields in the task template markup in `taskAtHand.html`.
    The details for each task will be displayed in a section under the task name.
    Our template now looks like the following code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`taskAtHand.html`中的任务模板标记中定义这些字段。每个任务的详细信息将显示在任务名称下的一个部分中。我们的模板现在看起来像以下的代码片段：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First we added a new `<div class="details">` element to contain the new detail
    fields. This allows us to separate the details from the task name to style it
    differently. Then we added the labels and fields to it. Note that for **% Complete**
    we set the `min` and `max` attributes of the `number` field to limit the number
    between 0 and 100.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个新的`<div class="details">`元素来包含新的详细字段。这样我们可以将详细信息与任务名称分开以便以不同的样式进行设置。然后我们向其中添加了标签和字段。请注意，对于**%
    完成**，我们设置了`number`字段的`min`和`max`属性，以限制数字在0到100之间。
- en: Next we need to style the details section. We will give it a gray background
    and rounded corners. We make all the labels of same width and align them to right
    so that all the input fields line up. We then set the `<select>` element of **Status**
    and **Priority** to a fixed width so they line up as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要为详细信息部分设置样式。我们将给它一个灰色的背景和圆角。我们将所有标签设置为相同的宽度，并将它们右对齐，以便所有输入字段对齐。然后我们将**状态**和**优先级**的`<select>`元素设置为固定宽度，以便它们也对齐。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*What just happened?*'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We added a task details section to our tasks using some of the new HTML5 input
    types. The following screenshot shows what the task item looks like now with a
    details section:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一些新的HTML5输入类型为我们的任务添加了一个任务详细信息部分。以下截图显示了现在的任务项目是什么样子的，有一个详细信息部分：
- en: '![What just happened?](img/5947OT_03_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_03_01.jpg)'
- en: Time for action – hiding task details
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 隐藏任务详细信息
- en: This looks good, but it's also taking up a lot of room. If each task in the
    list is this long it will soon scroll off the page and we won't be able to see
    an overview of the task list very well. Since the task details are optional fields
    anyway, we can make our list more compact by not showing the details until the
    user wants to see them. We'll do that by hiding the details section and adding
    a toggle button next to the task name to show or hide the details when clicked.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，但它也占用了很多空间。如果列表中的每个任务都这么长，它很快就会滚动到页面之外，我们将无法很好地看到任务列表的概述。由于任务详细信息是可选字段，我们可以通过不显示详细信息来使我们的列表更加紧凑，直到用户想要查看它们为止。我们将通过隐藏详细信息部分并在任务名称旁边添加一个切换按钮来实现这一点，以便在单击时显示或隐藏详细信息。
- en: 'First let''s add the toggle details button next to the task name in our task
    template and give it a class named `toggle-details`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们在我们的任务模板中的任务名称旁边添加一个切换详细信息按钮，并给它一个名为`toggle-details`的类。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s implement the toggle button in our JavaScript code. First we add
    a click event handler for the toggle button in the `addTaskElement()` method that
    calls the `toggleDetails()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在JavaScript代码中实现切换按钮。首先，在`addTaskElement()`方法中为切换按钮添加一个单击事件处理程序，该处理程序调用`toggleDetails()`方法：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we implement the `toggleDetails()` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现`toggleDetails()`方法：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `toggleDetails()` method uses a couple of new jQuery methods that we haven't
    seen yet. It toggles the visibility of the task details using `slideToggle()`
    and toggles the `expanded` class on the button using `toggleClass()`. The `toggleClass()`
    method adds a class to an element if the element doesn't already have it, and
    removes it if it does.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggleDetails()`方法使用了一些我们尚未见过的新的jQuery方法。它使用`slideToggle()`来切换任务详情的可见性，并使用`toggleClass()`来切换按钮上的`expanded`类。`toggleClass()`方法会在元素没有该类时向元素添加一个类，并在元素有该类时将其删除。'
- en: The `slideToggle()` method is an animation function that toggles the visibility
    of an element. It makes an element visible using a sliding down motion pushing
    the elements below it down. To hide the element it slides it back up, shrinking
    it until it's hidden. There is also a method to fade elements in and out called
    `fadeToggle()`. But a slide provides a smoother transition when an element moves
    other elements out of the way when it becomes visible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`slideToggle()`方法是一个动画函数，用于切换元素的可见性。它通过向下滑动的方式使元素可见，将其下面的元素推下。要隐藏元素，它会将其向上滑动，缩小直到隐藏。还有一个用于淡入淡出元素的方法，称为`fadeToggle()`。但是，当元素在变得可见时，滑动提供了更平滑的过渡，因为它会将其他元素推开。'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In general a slide looks better when the element pushes the elements below it
    down when it's made visible. It is also good for menu-like behavior. A fade usually
    looks best when you are making an element visible that displays over the top of
    other elements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当元素在变得可见时，滑动效果看起来更好，因为它会将下面的元素推下。它还适用于类似菜单的行为。当您使一个元素变得可见并显示在其他元素的顶部时，淡入通常看起来最好。
- en: Now let's add some styling to the button. Of course we want some nice icons
    like our other task buttons, so let's add them to our sprite sheet file, `icons.png`.
    We need an image to show when the task properties are collapsed and one to show
    when they are expanded. Let's create a second row of images for these two icons.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为按钮添加一些样式。当然，我们想要一些漂亮的图标，就像我们的其他任务按钮一样，所以让我们将它们添加到我们的精灵表文件`icons.png`中。我们需要一个图像来显示任务属性折叠时的情况，另一个图像用于显示它们展开时的情况。让我们为这两个图标创建第二行图像。
- en: '![Time for action – hiding task details](img/5947OT_03_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![进行操作-隐藏任务详情](img/5947OT_03_02.jpg)'
- en: 'The first thing we need to do back in our stylesheet is set `display` to `none`
    for the details so that they are hidden by default:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在样式表中需要做的第一件事是将详情的`display`设置为`none`，以便它们默认情况下是隐藏的：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we add styles for the `toggle-details` button. As we are using the same
    sprite sheet as the task tools buttons, we''ll use the same style for our new
    button by adding it to the CSS selector. Then we''ll add selectors to get the
    images into the button using background position offsets:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为`toggle-details`按钮添加样式。由于我们使用与任务工具按钮相同的精灵表，因此我们将通过将其添加到CSS选择器中，使用相同的样式来为我们的新按钮添加样式。然后，我们将添加选择器以使用背景位置偏移将图像放入按钮中：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The vertical offset for our `toggle-details` images is `-16px` because they
    are on the second row in the sprite sheet. Notice that the second image matches
    to the `expanded` class. We are adding the `expanded` class to the button when
    details are visible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`toggle-details`图像的垂直偏移量为`-16px`，因为它们位于精灵表的第二行。请注意，第二个图像与`expanded`类匹配。当详情可见时，我们将`expanded`类添加到按钮上。
- en: '*What just happened?*'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We added a toggle button to each task that hides or shows the task details when
    clicked. Open it in the browser and see what we have now. You can open and close
    task details and they smoothly slide open and closed. Pretty cool.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个任务添加了一个切换按钮，当单击时隐藏或显示任务详情。在浏览器中打开它，看看我们现在有什么。您可以打开和关闭任务详情，并且它们会平稳地展开和关闭。相当酷。
- en: '![What just happened?](img/5947OT_03_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_03_03.jpg)'
- en: Custom data attributes
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义数据属性
- en: Another new feature of HTML5 is custom data attributes. Custom data attributes
    allow you to store custom data private to your application as an attribute on
    any element in the DOM. All you have to do is prefix the attribute name with `data-`.
    The name should be all lower case letters. You can assign any string value to
    the attribute.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5的另一个新功能是自定义数据属性。自定义数据属性允许您将自定义数据存储为DOM中任何元素的属性。您只需使用`data-`作为属性名称的前缀。名称应全部为小写字母。您可以为属性分配任何字符串值。
- en: 'For example, say we had a list of products and we wanted to store information
    about the products, such as product ID and category. All we have to do is add
    `data-product-id` and `data-category` attributes to the associated elements:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个产品列表，我们想要存储有关产品的信息，例如产品ID和类别。我们只需向相关元素添加`data-product-id`和`data-category`属性：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So now that we have custom attributes, we can extract the custom data from the
    elements using JavaScript and use it in our applications. jQuery happens to have
    a `data()` method designed just for this purpose. You give it the name of the
    custom attribute, minus the `data-`, and it returns the value associated with
    it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自定义属性，我们可以使用JavaScript从元素中提取自定义数据，并在我们的应用程序中使用它。jQuery碰巧有一个专门为此目的设计的`data()`方法。您只需给出自定义属性的名称，减去`data-`，它就会返回与其关联的值。
- en: 'Continuing with the previous example, let''s say we want to allow the user
    to click on a product in the list and then do some processing on it. The following
    `setSelectedProduct()` method uses the `data()` method to extract the product
    ID and category from the element that was clicked:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个示例，假设我们希望允许用户单击列表中的产品，然后对其进行一些处理。以下的`setSelectedProduct()`方法使用`data()`方法从被单击的元素中提取产品ID和类别：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Data binding with custom attributes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义属性进行数据绑定
- en: A great use for custom data attributes is to implement data binding. Data binding
    allows us to map user controls in the DOM to fields in the data model so that
    they are automatically updated when the user changes them. Using this technique
    we can eliminate a lot of boring repetitive code that does nothing more than handle
    events and map fields in the view to fields in the model.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义数据属性的一个很好的用途是实现数据绑定。数据绑定允许我们将DOM中的用户控件映射到数据模型中的字段，以便在用户更改它们时自动更新。使用这种技术，我们可以消除许多无聊的重复代码，这些代码只是处理事件并将视图中的字段映射到模型中的字段。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a few excellent data binding libraries available for JavaScript, including
    `Backbone.js` and `Knockout`. We will implement our own simple data binding here
    to learn how to use custom attributes. If you find yourself building an application
    with a lot of data you might consider using one of these libraries.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些出色的数据绑定库可用于JavaScript，包括`Backbone.js`和`Knockout`。我们将在这里实现自己简单的数据绑定，以学习如何使用自定义属性。如果你发现自己正在构建一个大量数据的应用程序，你可能会考虑使用其中一个库。
- en: Time for action – building a data model
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-构建数据模型
- en: Before we can begin implementing data binding, we need a data model to bind
    to. If you recall, we are only saving the task names to `localStorage`. Our data
    model is simply an array of strings. Now that each task has multiple details fields
    we will need something a little more substantial to hold all of that data. You
    can find the source code for this section in `Chapter 3\example3.2`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现数据绑定之前，我们需要一个数据模型进行绑定。如果你还记得，我们只是将任务名称保存到`localStorage`。我们的数据模型只是一个字符串数组。现在每个任务都有多个详细字段，我们需要一些更实质的东西来保存所有这些数据。你可以在`Chapter
    3\example3.2`中找到本节的源代码。
- en: 'Let''s start by defining a task object for our data model. We will create a
    new file, `taskList.js` to put it in:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的数据模型定义一个任务对象开始。我们将创建一个新文件`taskList.js`来放置它。
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Starting from the top, our constructor takes one parameter-the task name. It
    uses that to set the name field in the object. Each task has a unique task ID,
    which gets incremented every time a task is created. The rest of the members are
    set to default values.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始，我们的构造函数接受一个参数-任务名称。它用于设置对象中的名称字段。每个任务都有一个唯一的任务ID，每次创建任务时都会递增。其余成员设置为默认值。
- en: We are attaching a `Task.nextTaskId` field to the `Task` object constructor
    to keep track of what the next unique task ID should be. Doing this allows us
    to define what we would call static or class variables in languages that have
    classes, such as Java or C# (where they are defined using static variables). The
    `nextTaskId` field will get saved to `localStorage` whenever it changes so that
    we know where we left off when the user returns to the application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Task.nextTaskId`字段附加到`Task`对象构造函数，以跟踪下一个唯一任务ID应该是什么。这样做可以让我们定义我们在具有类的语言中定义静态或类变量的内容，比如Java或C#（在这些语言中，它们使用静态变量定义）。`nextTaskId`字段在更改时将保存到`localStorage`，以便我们知道用户返回应用程序时我们离开的位置。
- en: Notice that `priority` and `status` are using enumerations. We implement those
    as static objects (because JavaScript doesn't have enumerations) attached to the
    `Task` constructor.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`priority`和`status`使用枚举。我们将这些实现为静态对象（因为JavaScript没有枚举），附加到`Task`构造函数。
- en: 'The next thing we need is a list to store the `Task` objects in. To make it
    easier to manage the code for this, we will create a `TaskList` object that is
    basically a wrapper over an array. It provides methods to add, remove, and get
    tasks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一件事是一个列表，用于存储`Task`对象。为了更容易管理这段代码，我们将创建一个`TaskList`对象，它基本上是一个数组的包装器。它提供了添加、删除和获取任务的方法：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The constructor takes one optional parameter that is an array of the `Task`
    objects. The first line of the constructor checks to see if an array was passed
    in. If not, it creates a new empty array using empty square brackets (`[]`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个可选参数，即`Task`对象的数组。构造函数的第一行检查是否传入了一个数组。如果没有，则使用空方括号(`[]`)创建一个新的空数组。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In JavaScript the logical OR operator (`||`) can act as a null-coalescing operator.
    It returns the left-hand operand if the operand is "truthy"; otherwise it returns
    the right operand. In this case, truthy means that a `tasks` parameter was passed
    in and is not `null` or `undefined`. This is very useful paradigm for defining
    default values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，逻辑或运算符（`||`）可以充当空值合并运算符。如果操作数是“真值”，它将返回左操作数；否则返回右操作数。在这种情况下，真值意味着传入了`tasks`参数并且不是`null`或`undefined`。这是定义默认值的非常有用的范例。
- en: 'Now we add a public `getTasks()` method that simply returns the array. We will
    need access to it later to save the tasks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一个公共的`getTasks()`方法，它简单地返回数组。我们以后需要访问它来保存任务：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next we add a public `addTask()` method that takes a `Task` object and appends
    it to the end of the array:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们添加一个公共的`addTask()`方法，它接受一个`Task`对象并将其追加到数组的末尾：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The public `removeTask()` method takes a task ID as a parameter and removes
    the associated task from the list:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的`removeTask()`方法以任务ID作为参数，并从列表中删除相关的任务：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It gets the index of the task by calling `getTaskIndex()`, then uses the `array.splice()`
    method to remove it from the `tasks` array. The `getTaskIndex()` method is a private
    method that takes a task ID as a parameter and searches through the array to find
    the task with that ID. If it finds the task it returns it. Otherwise it returns
    `-1`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过调用`getTaskIndex()`获取任务的索引，然后使用`array.splice()`方法从`tasks`数组中删除它。`getTaskIndex()`方法是一个私有方法，它以任务ID作为参数，并通过数组搜索找到具有该ID的任务。如果找到任务，则返回它。否则返回`-1`：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next up is the public `getTask()` method. It takes a task ID as a parameter
    and also uses the `getTaskIndex()` method to find it. It returns the associated
    `Task` object, or `null` if it doesn't exist.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是公共的`getTask()`方法。它以任务ID作为参数，并使用`getTaskIndex()`方法来查找它。它返回相关的`Task`对象，如果不存在则返回`null`。
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last public method we are going to add is called `each()`. It takes a reference
    to a `callback` function as a parameter. It loops over the array of tasks and
    executes the `callback` function for each task in the array. This method can be
    used to iterate over all tasks in the list:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的最后一个公共方法称为`each()`。它将`callback`函数的引用作为参数。它循环遍历任务数组，并对数组中的每个任务执行`callback`函数。此方法可用于遍历列表中的所有任务：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Time for action – implementing the bindings
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-实现绑定
- en: 'Let''s head back over to the task template in our HTML file and add some custom
    data attributes. We''ll add custom attributes to all of the task details `<input>`
    and `<select>` elements. The data attribute name will be `data-field`, and the
    attribute value will be the name of the field the element matches to in the `Task`
    object. We will use those attributes later in our JavaScript to hook the DOM elements
    and data model together:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到HTML文件中的任务模板，并添加一些自定义数据属性。我们将为所有任务详细信息的`<input>`和`<select>`元素添加自定义属性。数据属性的名称将是`data-field`，属性值将是元素在`Task`对象中匹配的字段的名称。我们稍后将在JavaScript中使用这些属性来将DOM元素和数据模型连接在一起：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have a data model, we need to go into the `TaskAtHandApp` object
    in `taskAtHand.js` and update it to use that model. First we''ll add a `taskList`
    variable and initialize it to an instance of a `TaskList` object:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个数据模型，我们需要进入`taskAtHand.js`中的`TaskAtHandApp`对象，并更新它以使用该模型。首先，我们将添加一个`taskList`变量，并将其初始化为`TaskList`对象的实例：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we''ll go into the `addTask()` method and add code to create a new `Task`
    object, and add it to the task list. This is also where we save the `nextTaskId`
    value into `localStorage` after it''s been incremented:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将进入`addTask()`方法，并添加代码来创建一个新的`Task`对象，并将其添加到任务列表中。这也是在将`nextTaskId`值递增后将其保存到`localStorage`中的地方：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice that we also changed the parameter of the `addTaskElement()` method
    to pass in the `Task` object. So let''s update the `addTaskElement()` method to
    take a `Task` object as the parameter instead of a task name:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还更改了`addTaskElement()`方法的参数，以传入`Task`对象。因此，让我们更新`addTaskElement()`方法，以将`Task`对象作为参数而不是任务名称：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After creating a new task element in the DOM we set the task ID on it using
    a custom data attribute named `task-id`. This is done with the jQuery `data()`
    method that takes the data attribute name and value as parameters. Next we set
    the task name into the `<span>` attribute from the `task.name` field.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在DOM中创建新任务元素后，我们使用名为`task-id`的自定义数据属性在其上设置任务ID。这是通过jQuery的`data()`方法完成的，该方法将数据属性名称和值作为参数。接下来，我们将任务名称设置到`task.name`字段的`<span>`属性中。
- en: 'Now we will implement the first part of the data binding. This next block of
    code uses the data attributes we previously added to the markup to set the values
    from the `Task` object into the associated `<input>` and `<select>` elements in
    the details section:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现数据绑定的第一部分。下面的代码块使用了我们之前添加到标记中的数据属性，将`Task`对象的值设置到详细部分中关联的`<input>`和`<select>`元素中：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s how it works:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理如下：
- en: First it finds all `<input>` and `<select>` elements inside the task element.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它查找任务元素内的所有`<input>`和`<select>`元素。
- en: Then it calls the jQuery `each()` method, which is used to iterate over the
    set of selected elements, passing in a `callback` function.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用jQuery的`each()`方法，用于遍历所选元素集，传入一个`callback`函数。
- en: Inside the `callback` function `this` points to the current element. So first
    we wrap the element in a jQuery object.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`callback`函数中，`this`指向当前元素。因此，我们首先将元素包装在jQuery对象中。
- en: Then we use the `data()` method to get the value of the `data-field` custom
    attribute, which is the name of the field in the `Task` object associated with
    the element.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`data()`方法获取`data-field`自定义属性的值，这是与元素关联的`Task`对象中字段的名称。
- en: Finally we set the value of the user control to the value of the field in the
    `Task` object. We get the value from the `Task` object using square brackets.
    Remember that in JavaScript `object["field"]` is the .same as `object.field`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将用户控件的值设置为`Task`对象中字段的值。我们使用方括号从`Task`对象中获取值。请记住，在JavaScript中，`object["field"]`与`object.field`是相同的。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can think of using square brackets to access object fields as similar to
    using reflection in C# or Java to dynamically access values in objects at runtime.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将使用方括号访问对象字段视为类似于在C#或Java中使用反射在运行时动态访问对象中的值。
- en: 'Now we need to add code to go the other way. Whenever the user changes the
    value of a form control we want to automatically save it back to the data model.
    So let''s add a change event handler for each of the details form controls:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加代码来实现双向绑定。每当用户更改表单控件的值时，我们希望自动将其保存回数据模型。因此，让我们为每个详细表单控件添加一个change事件处理程序：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This calls the `onChangeTaskDetails()` method, passing in the task ID and the
    form control element that changed wrapped in a jQuery object. Let''s implement
    that method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用`onChangeTaskDetails()`方法，传入任务ID和更改的表单控件元素，该元素包装在jQuery对象中。让我们实现该方法：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s break it down to see how it works:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下，看看它是如何工作的：
- en: First it gets the `Task` object from the task list with the specified ID.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它从具有指定ID的任务列表中获取`Task`对象。
- en: After making sure we got an object back (you never know, so always check) we
    get the `Task` object field name from the element's `data-field` attribute.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们得到了一个对象（你永远不知道，所以总是检查），我们从元素的`data-field`属性中获取`Task`对象字段名称。
- en: Then we set the value of the field on the `Task` object to the value of the
    form control element, again using square brackets to access it dynamically.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`Task`对象上的字段值设置为表单控件元素的值，再次使用方括号动态访问它。
- en: Finally we call `saveTaskList()` to commit the change to `localStorage`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`saveTaskList()`来提交对`localStorage`的更改。
- en: 'That reminds me, we need to rewrite the `saveTaskList()` method to save our
    new `TaskList` object. That''s easy enough. We just call the `getTasks()` method
    of the task list to get the array of `Task` objects. Then we save the array to
    `localStorage`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，我们需要重写`saveTaskList()`方法来保存我们的新`TaskList`对象。这很容易。我们只需调用任务列表的`getTasks()`方法来获取`Task`对象的数组。然后我们将数组保存到`localStorage`：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have old task list data from the previous examples you will need to delete
    it before using the new data model. In Chrome developer tools you can click on
    the item and press the *Delete* key to remove it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有来自先前示例的旧任务列表数据，则需要在使用新数据模型之前将其删除。在Chrome开发者工具中，您可以单击该项目，然后按*删除*键将其删除。
- en: '*What just happened?*'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: First we created a data model to hold all of the task data. Then we added data
    binding to our application using custom data attributes to automatically update
    the data model when a field on the page changes. Then we saved the task list to
    local storage.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个数据模型来保存所有任务数据。然后，我们使用自定义数据属性向我们的应用程序添加了数据绑定，以在页面更改字段时自动更新数据模型。然后我们将任务列表保存到本地存储。
- en: Time for action – loading the task list
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-加载任务列表
- en: 'Now that we''ve saved the new data model to `localStorage` we need to update
    the `loadTaskList()` method to load the data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已将新数据模型保存到`localStorage`，我们需要更新`loadTaskList()`方法来加载数据：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First we get the task array from `localStorage` and pass that as a parameter
    into the `TaskList` object''s constructor. Then we call a new method, `rebuildTaskList()`
    to create the task elements in the DOM:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`localStorage`获取任务数组，并将其作为参数传递给`TaskList`对象的构造函数。然后，我们调用一个新方法`rebuildTaskList()`来在DOM中创建任务元素：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First we remove any old elements from the task list element using the jQuery
    `empty()` method. Then we use the `each()` method that we implemented in the `TaskList`
    object to iterate over the tasks and call `addTaskElement()` for each one to build
    the task elements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用jQuery的`empty()`方法从任务列表元素中删除任何旧元素。然后，我们使用我们在`TaskList`对象中实现的`each()`方法来迭代任务，并为每个任务调用`addTaskElement()`来构建任务元素。
- en: Queuing up changes
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排队更改
- en: Now we've bound the user controls to the data model and automatically save it
    every time a change is made. There's one problem with this though. Input controls
    like the `number` or `time` types that have spinners associated with them cause
    a `change` event every time a spinner button is clicked. If the user holds a spinner
    button down it will fire `change` events at an alarming rate. This will in turn
    save the task list to `localStorage` repeatedly in a very short period of time.
    That doesn't seem like a very efficient thing to do, especially if you have a
    lot of data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已将用户控件绑定到数据模型，并在每次进行更改时自动保存。不过，这样做有一个问题。像`number`或`time`类型的输入控件，这些控件与微调按钮相关联，每次单击微调按钮时都会触发`change`事件。如果用户按住微调按钮，它将以惊人的速度触发`change`事件。这将反过来在非常短的时间内重复将任务列表保存到`localStorage`。这似乎不是一件非常有效的事情，特别是如果您有大量数据。
- en: Time for action – delaying the saves
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-延迟保存
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See the code in `Chapter 3\example3.3`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`第3章\示例3.3`中的代码。
- en: 'We can alleviate this problem by delaying the save to `localStorage` for a
    period of time to wait until all of the user interaction has finished. This is
    pretty easy to implement using JavaScript''s `setTimeout()` function. We will
    make this change in the `saveTaskList()` method, but first we need a global variable
    in the `TaskAtHandApp` object to keep track of the timeout ID returned by `setTimeout()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过延迟保存到`localStorage`一段时间来缓解这个问题，以等待所有用户交互完成。使用JavaScript的`setTimeout()`函数很容易实现这一点。我们将在`saveTaskList()`方法中进行此更改，但首先我们需要在`TaskAtHandApp`对象中设置一个全局变量，以跟踪`setTimeout()`返回的超时ID：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When changes are pending a save, we want to display a message in the status
    element at the bottom of the page so the user knows that their changes will be
    saved. When the actual save has taken place we will update the message and fade
    it out so the user knows the save is complete. To do that we need to rewrite the
    `setStatus()` method as well:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改待保存时，我们希望在页面底部的状态元素中显示消息，以便用户知道他们的更改将被保存。当实际保存发生时，我们将更新消息并使其淡出，以便用户知道保存已完成。为此，我们需要重写`setStatus()`方法：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We add an optional `noFade` parameter. When set to `true` the message will
    not fade out. Otherwise we use the jQuery `fadeOut()` method to gradually fade
    out the message over 1000 milliseconds, or one second. Now let''s update the `saveTaskList()`
    method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个可选的`noFade`参数。当设置为`true`时，消息将不会淡出。否则，我们使用jQuery的`fadeOut()`方法在1000毫秒或一秒内逐渐淡出消息。现在让我们更新`saveTaskList()`方法：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first thing we do is check to see if there is already a save pending by
    checking if the `timeoutId` variable has a value. If it does, we will cancel the
    timeout using JavaScript's `clearTimeout()` function. This has the effect of resetting
    the timer if the user makes another change while a save is pending. All changes
    will effectively be queued up and saved at one time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查`timeoutId`变量是否有值，以查看是否已经有保存待处理。如果有，我们将使用JavaScript的`clearTimeout()`函数取消超时。这样做的效果是，如果用户在保存待处理时进行其他更改，所有更改将被排队并一次性保存。
- en: Next we set a new timeout using `setTimeout()`. The `setTimeout()` function
    takes a function to execute and the number of milliseconds to wait until it executes
    the function. It returns a timeout ID that we store in our `timeoutId` variable
    in case we need to cancel the timeout later.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`setTimeout()`设置一个新的超时。`setTimeout()`函数接受要执行的函数和等待执行该函数的毫秒数。它返回一个超时ID，我们将其存储在`timeoutId`变量中，以防以后需要取消超时。
- en: After 2000 milliseconds, or two seconds of inactivity the task list will be
    saved. Then we reset the `timeoutId` variable because our timeout is finished.
    Finally we call `setStatus()` to tell the user the changes have been saved.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000毫秒或两秒的不活动后，任务列表将被保存。然后我们重置`timeoutId`变量，因为我们的超时已经结束。最后，我们调用`setStatus()`告诉用户更改已保存。
- en: '*What just happened?*'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We used the JavaScript `setTimeout()` function to effectively queue up changes
    so we aren't constantly saving the task list when values are changing rapidly.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用JavaScript的`setTimeout()`函数来有效地排队更改，这样当值快速变化时，我们不会不断保存任务列表。
- en: Have a go hero
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: That's it; our task list application is complete, as far as this book goes anyway.
    Now go and add your own features to make it even better. For example, add more
    task fields such as a text area to enter notes. Maybe add an option to the toolbar
    to hide completed tasks. Try adding a sorting option to sort the list by name,
    status, or date.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们的任务列表应用程序已经完成，至少在这本书中是这样。现在去添加你自己的功能，使它变得更好。例如，添加更多的任务字段，比如一个文本区域来输入备注。也许在工具栏中添加一个选项来隐藏已完成的任务。尝试添加一个排序选项，按名称、状态或日期对列表进行排序。
- en: Pop quiz
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出测验
- en: Q1\. What happens if a browser doesn't support one of the new HTML5 input types?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 如果浏览器不支持新的HTML5输入类型会发生什么？
- en: The input field is not displayed.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入字段未显示。
- en: The field is displayed as a text field.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字段显示为文本字段。
- en: The field is set to read only.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字段设置为只读。
- en: The browser shows an error message.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器显示错误消息。
- en: Q2\. What kind of element can custom data attributes be used on?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 自定义数据属性可以用在什么样的元素上？
- en: Only form input elements.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有表单输入元素。
- en: Only block level elements.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有块级元素。
- en: Only inline elements.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有内联元素。
- en: Any element.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何元素。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we looked at some of the more useful HTML5 input types. We used
    those input types to create a collapsible task details section for each task.
    Then we used custom data attributes to implement a simple data binding to map
    the input fields in the view to the data model.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些更有用的HTML5输入类型。我们使用这些输入类型为每个任务创建了一个可折叠的任务详情部分。然后我们使用自定义数据属性来实现简单的数据绑定，将视图中的输入字段映射到数据模型。
- en: 'We covered the following concepts in this chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下概念：
- en: How and when to use the new HTML5 input types
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及何时使用新的HTML5输入类型
- en: How to use custom data attributes to store private data in the DOM
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用自定义数据属性在DOM中存储私有数据
- en: How to implement data binding using custom data attributes to bind a data model
    to form controls
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用自定义数据属性实现数据绑定，将数据模型绑定到表单控件
- en: How to use jQuery animation methods to hide and show elements
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用jQuery动画方法隐藏和显示元素
- en: How to use a timer to delay saves to `localStorage` to make applications more
    responsive
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用定时器延迟保存到`localStorage`，使应用程序更加响应
- en: In the next chapter we will head off in a completely new direction. We'll take
    a look at the HTML5 canvas element and API and write a brand new application that
    uses it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将朝着一个全新的方向前进。我们将看看HTML5画布元素和API，并编写一个使用它的全新应用程序。
