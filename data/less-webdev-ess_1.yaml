- en: Chapter 1. Improving Web Development with Less
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。使用Less改进Web开发
- en: It is impossible to imagine modern web design without CSS. With CSS3, web designers
    are able to rely on advanced functions such as gradients, transitions, and animations.
    On the other hand, CSS code becomes more complex and difficult to maintain. *Less*
    is a CSS preprocessor that extends CSS with modern programming-language concepts.
    Less enables you to use variables, functions, operations, and even rule or selector
    nesting while coding your CSS. *Less* helps you write CSS with the **Don't Repeat
    Yourself** (**DRY**) principle. The DRY principle prevents you from repeating
    any kind of information in your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网页设计中，无法想象没有CSS。有了CSS3，网页设计师可以依赖于高级功能，如渐变、过渡和动画。另一方面，CSS代码变得更加复杂和难以维护。*Less*是一种CSS预处理器，它使用现代编程语言的概念扩展了CSS。Less使您能够在编写CSS时使用变量、函数、操作，甚至规则或选择器嵌套。*Less*帮助您使用**不要重复自己**（**DRY**）原则编写CSS。DRY原则防止您在代码中重复任何信息。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to CSS3
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS3介绍
- en: Compiling Less into CSS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Less编译成CSS
- en: Vendor-specific rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商特定规则
- en: CSS3 rounded corners, animations, and gradients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS3圆角、动画和渐变
- en: Using box-sizing border-box
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用box-sizing border-box
- en: Server-side compiling and using GUI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端编译和使用GUI
- en: Using CSS3 for styling your HTML
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS3为您的HTML设置样式
- en: In web design, you will use HTML to describe the structure of your documents
    and CSS language to describe their presentation, including fonts, colors, and
    layout. The current standard HTML5 and CSS3 versions work on most modern browsers
    and mobile devices. CSS3 extends the old CSS with other new selectors, text effects,
    background gradients, and animations. The power of CSS3, the new functionalities,
    and high acceptance on mobile devices using HTML5 and CSS3 make them the standard
    for modern web design. The combination of HTML5 and CSS3 is ideal for building
    responsive websites because of their high acceptance on mobile phones (and other
    devices).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页设计中，您将使用HTML来描述文档的结构，使用CSS语言来描述它们的呈现，包括字体、颜色和布局。当前标准的HTML5和CSS3版本适用于大多数现代浏览器和移动设备。CSS3通过其他新的选择器、文本效果、背景渐变和动画扩展了旧的CSS。CSS3的强大功能、新功能以及在使用HTML5和CSS3的移动设备上的高接受度使它们成为现代网页设计的标准。HTML5和CSS3的组合非常适合构建响应式网站，因为它们在手机（和其他设备）上的高接受度。
- en: Together, HTML5 and CSS3 introduce many new features. You will be shown the
    ones that are the most significant when learning about their concepts within this
    book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5和CSS3一起引入了许多新功能。在本书中，您将了解到学习它们概念时最重要的功能。
- en: Using CSS Selectors to style your HTML
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CSS选择器为您的HTML设置样式
- en: With *Less* (and CSS), you can style your HTML code using **selectors**. CSS
    selectors are patterns or names that identify which HTML elements of the web page
    should be styled. CSS selectors play an important role in writing *Less* code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Less*（和CSS），您可以使用**选择器**来为您的HTML代码设置样式。CSS选择器是用于识别应该设置样式的网页HTML元素的模式或名称。CSS选择器在编写*Less*代码时起着重要作用。
- en: For `body p.article {color:red}`, the selector here is `body p.article`. Selectors
    don't refer exclusively to one element. They can point to more than one element
    and different ones can refer to the same element. For instance, a single `p` selector
    refers to all the `p-elements`, including the `p-elements` with a `.article` class.
    In the case of conflicts, **cascade** and **specificity** determine which styles
    should be applied. When writing *Less* code, we should keep the aforementioned
    rules in mind. *Less* makes it easier to write complex CSS without changing how
    your website looks. It doesn't introduce any limitations on your final CSS. With
    *Less*, you can edit well-structured code instead of changing the effect of the
    final CSS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`body p.article {color:red}`，这里的选择器是`body p.article`。选择器不仅仅指一个元素。它们可以指向多个元素，不同的选择器可以指向同一个元素。例如，单个`p`选择器指的是所有的`p元素`，包括具有`.article`类的`p元素`。在冲突的情况下，**级联**和**特异性**决定应该应用哪些样式。在编写*Less*代码时，我们应该牢记上述规则。*Less*使得编写复杂的CSS变得更容易，而不会改变您的网站外观。它不会对最终的CSS引入任何限制。使用*Less*，您可以编辑结构良好的代码，而不是改变最终CSS的效果。
- en: CSS3 introduces many new and handy selectors. One of them is `:nth-child(n)`,
    which makes it possible to style, for example, every fourth paragraph's `p` tag
    in an HTML document. Such selectors add powerful functions to CSS3\. Now we are
    able to perform operations with CSS alone, whereas, in the past we needed JavaScript
    or hardcoded styles (or classes at the very least). Again, this is one of the
    reasons to learn *Less*. Powerful selectors will make CSS more important, but
    CSS code also becomes cumbersome and difficult to maintain. *Less* will prevent
    this problem in CSS, even making complex code flexible and easy to maintain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3引入了许多新的和方便的选择器。其中之一是`:nth-child(n)`，它使得在HTML文档中可以对每四个段落的`p`标签进行样式设置成为可能。这样的选择器为CSS3添加了强大的功能。现在我们能够仅使用CSS执行操作，而在过去我们需要JavaScript或硬编码样式（或至少需要类）。这也是学习*Less*的原因之一。强大的选择器将使CSS变得更加重要，但CSS代码也变得繁琐和难以维护。*Less*将在CSS中解决这个问题，甚至使复杂的代码变得灵活和易于维护。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please visit [https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Selectors)
    for a complete list of CSS selectors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问[https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Selectors)获取完整的CSS选择器列表。
- en: Specificity, Inheritance, and Cascade in CSS
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS中的特异性、继承和级联
- en: In most cases, many CSS styles can be applied on the same HTML element, but
    only one of them will win. *W3C specifications* describe the rules for which CSS
    styles get the most precedence and will ultimately be applied. You can find these
    specifications in the following section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，许多CSS样式可以应用于同一个HTML元素，但只有一个样式会获胜。*W3C规范*描述了哪些CSS样式具有最高优先级并最终将被应用。您可以在以下部分找到这些规范。
- en: The rules regarding the order of importance have not significantly changed with
    CSS3\. They are briefly mentioned to help you understand some of the common pitfalls
    with *Less*/CSS and how to solve them. Sooner or later, you will be in a situation
    where you're trying to apply a CSS style to an element, but its effect stays invisible.
    You will reload, pull out your hair, and check for typos again and again, but
    nothing will help. This is because in most of these cases, your style will be
    overruled with another style that has a higher precedence.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于重要性顺序的规则在CSS3中并没有发生重大变化。它们被简要提及，以帮助你理解*Less*/CSS中一些常见的陷阱以及如何解决它们。迟早，你会遇到这样的情况，你试图将CSS样式应用到一个元素，但它的效果却看不见。你会重新加载，拔头发，一遍又一遍地检查拼写错误，但什么都不会有用。这是因为在大多数情况下，你的样式将被另一个具有更高优先级的样式所覆盖。
- en: 'The global rules for Cascade in CSS are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CSS中级联的全局规则如下：
- en: Find all the CSS declarations that apply to the element and property in question.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到适用于所讨论的元素和属性的所有CSS声明。
- en: '**Inline styles** have the highest precedence, except for `!important`. The
    `!important` statement in CSS is a keyword used to add weight to a declaration.
    The `!important` statement is added at the end of a CSS property value. After
    this, check who set the declaration; styles set by the author get a higher precedence
    than the styles defined by the user or browser (default). Default means the styles
    are set by the web browser, author styles are defined by CSS in the web page,
    and user styles are set by the user via the settings of his or her web browser.
    The importance of the user is higher than the default, and the code with the `!important`
    statement (see [Chapter 2](ch02.html "Chapter 2. Using Variables and Mixins"),
    *Using Variables and Mixins* for its meaning in *Less*) will always get the highest
    precedence. Note that browsers such as Firefox have options to disable pages in
    order to use other alternatives to user-defined fonts. Here, the user settings
    overrule the CSS of the web page. This way of overruling the page settings is
    not part of the CSS precedence unless they are set using `!important`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联样式**具有最高的特异性，除了`!important`。CSS中的`!important`语句是一个用于增加声明权重的关键字。`!important`语句添加在CSS属性值的末尾。之后，检查是谁设置了声明；作者设置的样式比用户或浏览器（默认）定义的样式具有更高的特异性。默认意味着样式是由Web浏览器设置的，作者样式是由网页中的CSS定义的，用户样式是由用户通过其Web浏览器的设置设置的。用户的重要性高于默认值，而带有`!important`语句的代码（参见[第2章](ch02.html
    "第2章。使用变量和混合")，*使用变量和混合*中的*Less*含义）将始终具有最高的特异性。请注意，像Firefox这样的浏览器有选项来禁用页面以使用其他替代的用户定义字体。在这里，用户设置将覆盖网页的CSS。这种覆盖页面设置的方式不是CSS优先级的一部分，除非它们使用`!important`设置。'
- en: Calculate the specificity, which is discussed in the following section.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算特异性，这将在下一节中讨论。
- en: If two or more rules have the same precedence and specificity, the one declared
    last wins.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个或更多规则具有相同的优先级和特异性，则最后声明的规则获胜。
- en: As a *Less*/CSS designer, you will be making use of the calculated CSS specificity
    in most cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*Less*/CSS设计师，你在大多数情况下将使用计算的CSS特异性。
- en: How CSS specificity works
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS特异性的工作原理
- en: Every CSS declaration gets a specificity, which will be calculated from the
    type of declaration and the selectors used in its declaration. Inline styles will
    always get the highest specificity and will always be applied (unless overwritten
    by the first two Cascade rules). In practice, you should not use inline styles
    in many cases as it will break the DRY principle. It will also disable you from
    changing your styles on a centralized location only and will prevent you from
    using *Less* for styling.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个CSS声明都有一个特异性，这将根据声明的类型和选择器的使用来计算。内联样式将始终具有最高的特异性，并且将始终被应用（除非被前两个级联规则覆盖）。在实践中，你不应该在许多情况下使用内联样式，因为它会违反DRY原则。它还会阻止你在一个集中的位置上更改样式，并阻止你使用*Less*进行样式设置。
- en: 'An example of an inline style declaration is shown as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 内联样式声明的一个示例如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After this, the number of IDs in the selector will be the next indicator to
    calculate specificity. The `#footer #leftcolumn {}` selector has 2 IDs, the `#footer
    {}` selector has 1 ID, and so on.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，选择器中ID的数量将是计算特异性的下一个指标。`#footer #leftcolumn {}`选择器有2个ID，`#footer {}`选择器有1个ID，依此类推。'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that in this case, an ID is a unique selector starting with `#`; the selector
    `[id=]` for the same HTML element counts as an **attribute**. This means that
    `div.#unique {}` has 1 ID and `div[id="unique"] {}` has 0 IDs and 1 attribute.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，ID是以`#`开头的唯一选择器；相同HTML元素的选择器`[id=]`计为一个**属性**。这意味着`div.#unique {}`有1个ID，而`div[id="unique"]
    {}`有0个ID和1个属性。
- en: If the number of IDs for two declarations is equal, the number of **classes**,
    **pseudo classes**, and **attributes** of the selector will be of importance.
    Classes start with a dot. For example, `.row` is a class. Pseudo classes, such
    as `:hover` and `:after`, start with a colon, and attributes, of course, are `href`,
    `alt`, `id`, and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个声明的ID数量相等，则选择器中**类**、**伪类**和**属性**的数量将很重要。类以点开头。例如，`.row`是一个类。伪类，比如`:hover`和`:after`，以冒号开头，而属性，当然，是`href`、`alt`、`id`等。
- en: The `#footer a.alert:hover {}` selector scores 2 (1 class and 1 pseudo class)
    and the `#footer div.right a.alert:hover {}` selector scores 3 (2 classes and
    1 pseudo class).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`#footer a.alert:hover {}`选择器得分为2（1个类和1个伪类），而`#footer div.right a.alert:hover
    {}`选择器得分为3（2个类和1个伪类）。'
- en: If this value is equal for both declarations, we can start counting the **elements**
    and **pseudo elements**. The latest variable will be defined with a double colon
    (`::`) . Pseudo elements allow authors to refer to otherwise inaccessible information,
    such as `::first-letter`. The following example shows you how that works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个声明的值相等，我们可以开始计算**元素**和**伪元素**。最新的变量将使用双冒号（`::`）定义。伪元素允许作者引用其他无法访问的信息，比如`::first-letter`。下面的例子展示了它是如何工作的。
- en: The `#footer div a{}` selector scores 2 (2 elements) and the `#footer div p
    a {}` selector scores 3 (3 elements).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`#footer div a{}`选择器得分为2（2个元素），而`#footer div p a {}`选择器得分为3（3个元素）。'
- en: 'You should now know what to do when your style isn''t directly applied. In
    most cases, make your selector more specific to get your style applied. For instance,
    if `#header p{}` doesn''t work, then you can try adding a `#header #subheader
    p{}` ID, a `#header p.head{}` class, and so on.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '当你的样式没有直接应用时，你现在应该知道该怎么做了。在大多数情况下，使你的选择器更具体以使你的样式应用。例如，如果`#header p{}`不起作用，那么你可以尝试添加`#header
    #subheader p{}` ID，一个`#header p.head{}`类，等等。'
- en: 'When Cascade and `!important` rules do not give a conclusive answer, specificity
    calculation seems to be a hard and time-consuming job. Although *Less* won''t
    help you here, tools such as Firebug (and other developer tools) can make the
    specificity visible. An example using Firebug is shown in the following screenshot,
    where the selector with the highest specificity is displayed at the top of the
    screen and the overruled styles are struck out:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当级联和`!important`规则无法给出明确的答案时，特异性计算似乎是一项困难且耗时的工作。虽然*Less*在这里无法帮助你，但诸如Firebug（和其他开发者工具）之类的工具可以使特异性可见。下面是使用Firebug的一个示例，其中具有最高特异性的选择器显示在屏幕顶部，被覆盖的样式被划掉：
- en: '![How CSS specificity works](img/1465OS-01-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![CSS特异性的工作原理](img/1465OS-01-01.jpg)'
- en: An example of specificity in Firebug
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Firebug中特异性的示例
- en: Building your layouts with flexible boxes
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用灵活盒子构建你的布局
- en: The **Flexbox Layout** (also called flexible boxes) is a new feature of CSS3\.
    It is extremely useful in creating responsive and flexible layouts. Flexbox provides
    the ability to dynamically change the layout for different screen resolutions.
    It does not use floats and contains margins that do not collapse with their content.
    Unfortunately, major browsers do not offer full support for Flexbox layouts at
    this moment. We focus on Flexbox due to its power, and as it is an important feature
    of CSS, we can also produce and maintain it using *Less*. You can access a set
    of *Less* mixins for CSS3 Flexbox at [https://gist.github.com/bassjobsen/8068034](https://gist.github.com/bassjobsen/8068034).
    You can use these mixins to create Flexbox layouts with *Less*, without using
    duplicate code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flexbox布局**（也称为灵活盒子）是CSS3的一个新特性。它在创建响应式和灵活的布局方面非常有用。Flexbox提供了根据不同屏幕分辨率动态更改布局的能力。它不使用浮动，并包含不会与其内容折叠的边距。不幸的是，目前主要浏览器对Flexbox布局的支持并不完整。我们关注Flexbox是因为它的强大，而且作为CSS的一个重要特性，我们也可以使用*Less*来生成和维护它。你可以在[https://gist.github.com/bassjobsen/8068034](https://gist.github.com/bassjobsen/8068034)上访问一组用于CSS3
    Flexbox的*Less* mixin。你可以使用这些mixin来使用*Less*创建Flexbox布局，而不使用重复的代码。'
- en: 'These mixins will not be explained in great detail now, but the following example
    shows how *Less* reduces the code needed to create a flex container. Using CSS,
    you might use the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些mixin现在不会被详细解释，但以下示例显示了*Less*如何减少创建flex容器所需的代码。使用CSS，你可能会使用以下代码：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com/](http://www.packtpub.com/). If
    you purchased this book elsewhere, you can visit [http://www.packtpub.com/support/](http://www.packtpub.com/support/)
    and register to have the files e-mailed directly to you.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在[http://www.packtpub.com/](http://www.packtpub.com/)的帐户中下载你购买的所有Packt图书的示例代码文件。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support/](http://www.packtpub.com/support/)并注册，以便直接通过电子邮件接收文件。
- en: 'However, if you use *Less*, the same effect can be produced by inserting the
    following line of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用*Less*，可以通过插入以下代码行来产生相同的效果：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use Google Chrome to test your Flexbox layouts. At the time of writing
    this book, Firefox and Internet Explorer IE11 also offered full or better support
    for Flexbox layouts. Flexboxes have been mentioned because they have the potential
    to play an important role in the future of web design. For now, they are beyond
    the scope of this book. This book will focus on creating responsive and flexible
    layouts with *Less* using CSS media queries and grids.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Google Chrome来测试你的Flexbox布局。在撰写本书时，Firefox和Internet Explorer IE11也提供了对Flexbox布局的全面或更好的支持。之所以提到Flexbox，是因为它们有潜力在未来的网页设计中扮演重要角色。目前，它们超出了本书的范围。本书将重点介绍如何使用*Less*、CSS媒体查询和网格来创建响应式和灵活的布局。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please visit [https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes)
    for additional information, examples, and browser compatibility.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问[https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes)获取更多信息、示例和浏览器兼容性。
- en: Compiling Less
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译Less
- en: After delving into the theory of CSS, you can finally start using *Less*. As
    mentioned earlier, it has the same syntax as CSS. This means any CSS code is,
    in fact, a valid *Less* code too. With *Less*, you can produce CSS code that can
    be used to style your website. The process used to make CSS from *Less* is called
    **compiling**, where you can compile *Less* code via the **server side** or **client
    side**. The examples given in this book will make use of client-side compiling.
    Client side, in this context, means loading the code in a browser and compiling
    *Less* code into CSS code using resources from the local machine. Client-side
    compiling is used in this book because it is the easiest way to get started while
    being good enough for developing your *Less* skills.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究CSS理论之后，你最终可以开始使用*Less*。如前所述，它与CSS具有相同的语法。这意味着任何CSS代码实际上也是有效的*Less*代码。使用*Less*，你可以生成可以用于样式化你的网站的CSS代码。从*Less*制作CSS的过程称为**编译**，你可以通过**服务器端**或**客户端**编译*Less*代码。本书中给出的示例将使用客户端编译。在这里，客户端指的是在浏览器中加载代码，并使用本地机器的资源将*Less*代码编译成CSS代码。本书使用客户端编译，因为这是最容易入门的方式，同时也足够好用于开发你的*Less*技能。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is important to note that the results from client-side compiling serve only
    for demonstration purposes. For production and especially when considering the
    performance of an application, it is recommended that you use server-side **precompiling**.
    *Less* bundles a compiler based on **Node.js**, and many other GUI's are available
    to precompile your code. These GUI's will be discussed towards the end of this
    chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，客户端编译的结果仅用于演示目的。对于生产环境，特别是在考虑应用程序性能时，建议使用服务器端的**预编译**。*Less*捆绑了一个基于**Node.js**的编译器，还有许多其他的GUI可用于预编译你的代码。这些GUI将在本章末讨论。
- en: Getting started with Less
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用Less
- en: You can finally start using *Less*. The first thing you have to do is download
    *Less* from [http://www.lesscss.org/](http://www.lesscss.org/). In this book,
    Version 1.6 of `less.js` will be used. After downloading it, an HTML5 document
    should be created. It should include `less.js` and your very first *Less* file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以开始使用*Less*了。你需要做的第一件事是从[http://www.lesscss.org/](http://www.lesscss.org/)下载*Less*。在本书中，将使用版本1.6的`less.js`。下载后，应该创建一个HTML5文档。它应该包括`less.js`和你的第一个*Less*文件。
- en: Please note that you can download the examples, including a copy of `less.js`,
    from the support files for this chapter in the downloadable files for the book
    on [www.packtpub.com](http://www.packtpub.com).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以从[www.packtpub.com](http://www.packtpub.com)上本书的可下载文件中下载示例，包括`less.js`的副本。
- en: 'To start with, have a look at this plain yet well-structured HTML5 file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看一下这个简单但结构良好的HTML5文件：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, a *Less* file has been added to this document using the following
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，使用以下代码将*Less*文件添加到了这个文档中：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When `rel="stylesheet/less"` is used, the code will be the same as for a style
    sheet. After the *Less* file, you can call `less.js` using the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`rel="stylesheet/less"`时，代码将与样式表相同。在*Less*文件之后，你可以使用以下代码调用`less.js`：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In fact, that's all that you need to get started!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这就是你开始的全部内容！
- en: To keep things clear, `html5shiv` (which you can access at [http://code.google.com/p/html5shiv/](http://code.google.com/p/html5shiv/))
    and **Modernizr** (which you can access at [http://modernizr.com/](http://modernizr.com/))
    have been ignored for now. These scripts add support and detection of new CSS3
    and HTML5 features for older browsers such as IE7 and IE8\. It is expected that
    you will be using a modern browser such as Mozilla Firefox, Google Chrome, or
    any version of Internet Explorer beyond IE8\. These will offer full support of
    HTML5, CSS3, and **media queries**, which you will need when reading this book
    and doing the exercises.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持清晰，暂时忽略了`html5shiv`（可以在[http://code.google.com/p/html5shiv/](http://code.google.com/p/html5shiv/)访问）和**Modernizr**（可以在[http://modernizr.com/](http://modernizr.com/)访问）。这些脚本为旧版浏览器如IE7和IE8添加了对新的CSS3和HTML5特性的支持和检测。预计你将使用现代浏览器，如Mozilla
    Firefox，Google Chrome，或IE8之后的任何版本。这些浏览器将完全支持HTML5、CSS3和**媒体查询**，这在阅读本书和做练习时是需要的。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You already know you should only use `less.js` for development and testing in
    most cases; there can still be use cases which do justice to the client-side use
    of `less.js` in production. To support `less.js` for older browsers, you could
    try es5-shim ([https://github.com/es-shims/es5-shim/](https://github.com/es-shims/es5-shim/)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道在大多数情况下只能在开发和测试中使用`less.js`；仍然有一些情况可以在生产中使用`less.js`的客户端。为了支持旧版浏览器的`less.js`，你可以尝试使用es5-shim（[https://github.com/es-shims/es5-shim/](https://github.com/es-shims/es5-shim/)）。
- en: 'Now, open `http://localhost/index.html` in your browser. You will see the **Less
    makes me Happy!** header text in its default font and color. After this, you should
    open `less/styles.less` in your favorite text editor. The syntax of *Less* and
    CSS doesn''t differ here, so you can enter the following code into this file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开`http://localhost/index.html`。你会看到**Less makes me Happy!**标题文字以默认的字体和颜色显示。之后，你应该在你喜欢的文本编辑器中打开`less/styles.less`。*Less*和CSS的语法在这里没有区别，所以你可以在这个文件中输入以下代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Following this, reload your browser. You should see the header text in red.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，重新加载你的浏览器。你应该会看到标题文字变成了红色。
- en: From the preceding code, `h1` is the selector that selects the HTML `H1` attribute
    in your HTML. The `color` property has been set to `red` between the accolades.
    The properties will then be applied onto your selectors, just like CSS does.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中，`h1`是选择器，用于选择你的HTML中的`H1`属性。`color`属性已经在大括号中设置为`red`。这些属性将被应用到你的选择器上，就像CSS一样。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is not necessary to have a web server that is running. Navigating to `index.html`
    on your hard drive with your browser should be enough. Unfortunately, this won't
    work for all browsers, so use Mozilla Firefox in order to be sure. The examples
    in this book use `http://localhost/map/`, but this can be replaced with something
    similar to `file:///map/` or `c:\map\`, depending on your situation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要运行一个web服务器。在浏览器中导航到你的硬盘上的`index.html`就足够了。不幸的是，这对所有浏览器都不起作用，所以最好使用Mozilla
    Firefox。本书中的示例使用的是`http://localhost/map/`，但根据你的情况，可以替换为类似于`file:///map/`或`c:\map\`的内容。
- en: Using the watch function for automatic reloading
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自动重新加载的观察功能
- en: 'The `less.js` file has a **watch** function, which checks your files for changes
    and reloads your browser views when they are found. It is pretty simple to use.
    Execute the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`less.js`文件有一个**watch**功能，它会检查你的文件是否有更改，并在发现更改时重新加载你的浏览器视图。使用起来非常简单。执行以下步骤：'
- en: Add `#!watch` after the URL you want to open.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你想要打开的URL后面添加`#!watch`。
- en: Add `#!watch` after `index.html` and then reload the browser window.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`后面添加`#!watch`，然后重新加载浏览器窗口。
- en: So, open `http://localhost/index.html#!watch` in your browser and start editing
    your *Less* files. Your browser will reflect your changes without having to reload.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，在浏览器中打开`http://localhost/index.html#!watch`，开始编辑你的*Less*文件。你的浏览器将在不需要重新加载的情况下反映你的更改。
- en: Now open `less/styles.less` in your text editor. In this file, write `#h1{color:red;}`
    and then save the file.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在你的文本编辑器中打开`less/styles.less`。在这个文件中，写入`#h1{color:red;}`然后保存文件。
- en: You should now navigate to your browser, which should show **Less makes me Happy!**
    in red.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该导航到你的浏览器，应该会看到**Less makes me Happy!**以红色显示。
- en: Rearrange your screen in order to see both the text editor and browser together
    in the same window.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新排列你的屏幕，以便在同一个窗口中同时看到文本编辑器和浏览器。
- en: Furthermore, if you change `red` to `blue` in `less/styles.less`, you will see
    that the browser tracks these changes and shows **Less makes me Happy!** in blue
    once the file is saved.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果你在`less/styles.less`中将`red`改为`blue`，你会发现浏览器跟踪这些更改，并在文件保存后以蓝色显示**Less makes
    me Happy!**。
- en: Pretty cool, isn't it?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 相当酷，不是吗？
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The examples in this code use color names instead of hexadecimal values. For
    example, the code uses `red` instead of `#ff0000`. The basic color names are converted
    to their hexadecimal value by less.js and written to the CSS. In this book, named
    colors are always used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本代码示例中使用颜色名称而不是十六进制值。例如，代码使用`red`而不是`#ff0000`。基本颜色名称由less.js转换为它们的十六进制值，并写入CSS中。在本书中，始终使用命名颜色。
- en: Debugging your code
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试你的代码
- en: As we are only human, we are prone to making a mistake or a typo. It is important
    to be able to see what you did wrong and debug your code. If your *Less* file
    contains errors, it won't compile at all. So, one small typo breaks the complete
    style of the document.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只是人类，我们容易犯错或打字错误。能够看到你的错误并调试你的代码是很重要的。如果你的*Less*文件包含错误，它根本无法编译。因此，一个小小的打字错误会破坏整个文档的样式。
- en: 'Debugging is also easy with `less.js`. To use debugging or allow `less.js`
    to display errors, you can add the following line of code to your `index.html`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`less.js`也很容易进行调试。要使用调试或允许`less.js`显示错误，可以将以下代码添加到你的`index.html`中：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, the line with `less = { env: ''development'' };` is new here.
    This line contains `less` as a JavaScript variable used by `less.js`. In fact,
    this is a global *Less* object used to parse some settings to `less.js`. The only
    setting that will be used in this book is `env: ''development''`. For more settings,
    check out the following website: [http://lesscss.org/#client-side-usage-browser-options](http://lesscss.org/#client-side-usage-browser-options).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，带有`less = { env: ''development'' };`的这一行是新的。这一行包含`less`作为`less.js`使用的JavaScript变量。实际上，这是一个全局*Less*对象，用于将一些设置解析给`less.js`。本书中将使用的唯一设置是`env:
    ''development''`。有关更多设置，请查看以下网站：[http://lesscss.org/#client-side-usage-browser-options](http://lesscss.org/#client-side-usage-browser-options)。'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`env: ''development''` also prevents *Less* from caching. Less doesn''t cache
    files in the browser cache. Instead, files are cached in the browser''s local
    storage. If `env` is set to `production`, this caching could yield unexpected
    results as the changed and saved files are not compiled.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`env: ''development''`还可以防止*Less*缓存。Less不会在浏览器缓存中缓存文件。相反，文件会被缓存在浏览器的本地存储中。如果`env`设置为`production`，这种缓存可能会产生意想不到的结果，因为更改和保存的文件不会被编译。'
- en: To try this new setting, edit `less/styles.less` again and remove an accolade
    to create an invalid syntax of the `h1{color:red` form and then save the file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个新设置，再次编辑`less/styles.less`并删除一个大括号，以创建`h1{color:red`形式的无效语法，然后保存文件。
- en: 'In your browser, you will see a page like the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中，你将看到一个如下截图的页面：
- en: '![Debugging your code](img/1465OS-01-02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![调试你的代码](img/1465OS-01-02.jpg)'
- en: An example of a Less parse error
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Less解析错误示例
- en: Besides **syntax errors**, there will also be **name errors** that are displayed.
    In the case of a name error, an undeclared function or variable would have been
    used.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**语法错误**之外，还会显示**名称错误**。在名称错误的情况下，可能会使用未声明的函数或变量。
- en: 'It is possible to set other settings for debugging, either in the global *Less*
    object or by appending the setting to the URL. For example, you can specify the
    `dumpLineNumbers` setting by adding the following lines of code to your HTML file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在全局*Less*对象中设置其他调试设置，也可以将设置附加到URL中。例如，你可以通过将以下代码添加到你的HTML文件中来指定`dumpLineNumbers`设置：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Alternatively, you can add `!dumpLineNumbers:mediaQuery` to the URL. This setting
    enables other tools to find the line number of the error in the *Less* source
    file. Setting this option to `mediaQuery` makes error reporting available for
    the FireBug or Chrome development tools. Similarly, setting this to `comments`
    achieves the same for tools such as FireLess. For instance, using FireLess allows
    Firebug to display the original *Less* filename and the line number of CSS styles
    generated by *Less* .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在URL中添加`!dumpLineNumbers:mediaQuery`。这个设置可以让其他工具在*Less*源文件中找到错误的行号。将此选项设置为`mediaQuery`可以使FireBug或Chrome开发工具可用于错误报告。类似地，将其设置为`comments`可以使FireLess等工具实现相同的功能。例如，使用FireLess可以使Firebug显示*Less*原始文件名和*Less*生成的CSS样式的行号。
- en: 'FireBug, Chrome development tools, or the default browser inspect the element
    functions (which you can access by right-clicking on your browser screen) can
    also be used to see and evaluate the compiled CSS. The CSS is displayed as inline
    CSS wrapped inside a `<style type="text/css" id="less:book-less-styles">` tag.
    In the example given in the following screenshot, you will see an ID with value
    `less:book-less-styles`. The value of this ID have been automatically generated
    by *Less* based on the path and name of the `book/less/styles.less` *Less* file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: FireBug、Chrome开发工具或默认浏览器检查元素功能（可以通过右键单击浏览器屏幕访问）也可以用来查看和评估编译后的CSS。CSS显示为内联CSS，包裹在`<style
    type="text/css" id="less:book-less-styles">`标签中。在以下截图中给出的示例中，你将看到一个ID，其值为`less:book-less-styles`。这个ID的值是根据`book/less/styles.less`
    *Less*文件的路径和名称自动生成的：
- en: '![Debugging your code](img/1465OS-01-03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![调试你的代码](img/1465OS-01-03.jpg)'
- en: Less-generated CSS styles
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Less生成的CSS样式
- en: Example code used in this book
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本书中使用的示例代码
- en: 'In this book, you will find many code examples. Unless explicitly mentioned,
    the format of these examples always shows the *Less* code first, followed by the
    compiled CSS code. For instance, you can write the following lines of code in
    *Less*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你会找到许多代码示例。除非另有说明，这些示例的格式总是先显示*Less*代码，然后是编译后的CSS代码。例如，你可以在*Less*中编写以下代码行：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code will be compiled into the following CSS syntax :'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将被编译为以下CSS语法：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Your first layout in Less
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Less中的第一个布局
- en: You must first open `first.html` (from the downloadable files for the book)
    in your browser and then open `less/first.less` in your text editor. In your browser,
    you will see a representation of a header, body, and footer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须首先在浏览器中打开`first.html`（从本书的可下载文件中）然后在文本编辑器中打开`less/first.less`。在浏览器中，您将看到一个页眉、正文和页脚的表示。
- en: As expected, `less/first.less` contains the *Less* code that will be converted
    into valid CSS by the `less.js` compiler. Any error in this file will stop the
    compiler and throw an error. Although the *Less* code shows some similarities
    to the plain CSS code, the process described here totally differs from editing
    your CSS directly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`less/first.less`包含了*Less*代码，将由`less.js`编译器转换为有效的CSS。此文件中的任何错误都将停止编译器并抛出错误。尽管*Less*代码与普通CSS代码显示出一些相似之处，但这里描述的过程与直接编辑CSS完全不同。
- en: 'The following screenshot shows you how this layout will look when opened in
    your web browser:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Web浏览器中打开时此布局的外观：
- en: '![Your first layout in Less](img/1465OS-01-04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Less中的第一个布局](img/1465OS-01-04.jpg)'
- en: Your first layout in Less
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Less中的第一个布局
- en: Vendor-specific rules
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供应商特定规则
- en: CSS3 introduced **vendor-specific rules**, which offer you the possibility of
    writing some additional CSS applicable for only one browser. At first sight, this
    seems the exact opposite of what you want. What you want is a set of standards
    and practicalities that work the same with every browser and a standard set of
    HTML and CSS which has the same effect and interpretation for every browser. These
    vendor-specific rules are intended to help us reach this utopia. Vendor-specific
    rules also provide us with early implementations of standard properties and alternative
    syntax. Last but not least, these rules allow browsers to implement proprietary
    **CSS properties** that would otherwise have no working standard (and may never
    actually become the standard).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3引入了**供应商特定规则**，为您提供了编写一些仅适用于一个浏览器的附加CSS的可能性。乍一看，这似乎与您的期望恰恰相反。您想要的是一套标准和实用性，适用于每个浏览器的相同效果和解释的标准HTML和CSS集。供应商特定规则旨在帮助我们实现这一乌托邦。供应商特定规则还为我们提供了标准属性和替代语法的早期实现。最后但并非最不重要的是，这些规则允许浏览器实现专有的**CSS属性**，否则这些属性将没有工作标准（并且可能永远不会成为标准）。
- en: For these reasons, vendor-specific rules play an important role in many new
    features of CSS3\. For example, **animation properties**, **border-radius**, and
    **box-shadow** all depend on vendor-specific rules.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，供应商特定规则在CSS3的许多新功能中起着重要作用。例如，**动画属性**、**border-radius**和**box-shadow**都依赖于供应商特定规则。
- en: 'Vendors use the following prefixes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商使用以下前缀：
- en: '**WebKit**: `-webkit`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebKit**: `-webkit`'
- en: '**Firefox**: `-moz`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firefox**: `-moz`'
- en: '**Opera**: `-o`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Opera**: `-o`'
- en: '**Internet Explorer**: `-ms`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Internet Explorer**: `-ms`'
- en: Build rounded corners with border-radius
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用border-radius构建圆角
- en: Border-radius is a new CSS3 property which will make many web developers happy.
    With border-radius, you can give HTML elements a rounded corner. In previous years,
    many implementations of rounded corners using images and transparency have been
    seen. However, these were inflexible (not fluid) and difficult to maintain.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 边框半径是一个新的CSS3属性，它将使许多网页开发人员感到高兴。使用border-radius，您可以给HTML元素设置圆角。在以前的几年中，已经看到了许多使用图像和透明度来实现圆角的实现。然而，这些方法不够灵活，难以维护。
- en: Vendor-specific rules are required for implementation, and although rounded
    corners can't be handled with a single line of code, its usage definitely makes
    rounding corners a lot easier.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实施需要供应商特定规则，尽管圆角不能用一行代码处理，但它的使用确实使圆角处理变得更加容易。
- en: 'To give an element rounded corners with a radius of 10 pixels, you can use
    the CSS code with vendor-specific rules as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个元素设置10像素半径的圆角，您可以使用带有供应商特定规则的CSS代码，如下所示：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For rounded corners with different radii, use a list with values separated
    by spaces: `10 px 5px 20px 15px;`. The radii are given in the following order:
    top-left, top-right, bottom-right, and bottom-left. By keeping these rules in
    mind, you will see how *Less* can keep your code clean.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有不同半径的圆角，使用一个由空格分隔的值列表：`10 px 5px 20px 15px;`。半径的顺序是：左上，右上，右下和左下。牢记这些规则，您将看到*Less*如何保持您的代码整洁。
- en: You can open `roundedcorners.html` from the download section of this chapter
    in your browser, and open `less/roundedcorners.less` in your text editor. In your
    browser, you will see a representation of a header, body, and footer with rounded
    corners.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器中打开本章下载部分的`roundedcorners.html`，并在文本编辑器中打开`less/roundedcorners.less`。在浏览器中，您将看到一个具有圆角的页眉、正文和页脚的表示。
- en: 'The CSS for the header in `less/roundedcorners.less` looks like the following
    code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`less/roundedcorners.less`中页眉的CSS如下所示：'
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can see that using vendor-specific rules, the corners have been created
    with a radius of 10 pixels. If you were using CSS, you would have to repeat the
    vendor-specific rules three times for the header, footer, and body. In order to
    change these rules or add a vendor, you would also have to change the same code
    three times. To begin with, you will perhaps think, "Why not group the selectors?",
    in a fashion similar to the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到使用供应商特定规则，圆角已经创建为10像素的半径。如果您使用CSS，您将不得不为页眉、页脚和正文重复供应商特定规则三次。为了更改这些规则或添加供应商，您还必须三次更改相同的代码。起初，您可能会想，“为什么不将选择器分组？”，类似于以下代码的方式：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code is syntactically correct in order to write CSS or *Less*
    code, but as your code base grows, it won't be easy to maintain. Grouping selectors
    based on properties makes no sense when reading and maintaining your code. Such
    constructs will also introduce many duplicated and unstructured usages of the
    same selectors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在编写CSS或*Less*代码时在语法上是正确的，但随着代码库的增长，维护起来并不容易。基于属性对选择器进行分组在阅读和维护代码时是没有意义的。这样的结构也会引入许多重复和无结构的相同选择器的用法。
- en: 'With *Less*, you are able to solve these problems efficiently. By creating
    a so-called **mixin**, you can solve the issues mentioned earlier. For the border
    radius, you can use the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Less*，你可以高效地解决这些问题。通过创建所谓的**混合**，你可以解决前面提到的问题。对于边框半径，你可以使用以下代码：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To use this mixin, you will call it as a property for the selector using the
    following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个混合，你将使用以下代码将其作为选择器的属性调用：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The compiled CSS of this *Less* code will now be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*Less*代码的编译CSS现在将如下所示：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Looking at the original code in the `less/roundedcorners.less` file, you can
    see that the preceding code wouldn''t be able to work for `#content`. The border
    radius for the content is 20 pixels instead of 10 pixels, as used for the header
    and footer. Again, *Less* helps us solve this efficiently. Mixins can be called
    with parameters in the same way in which functions can be called in functional
    programming. This means that in combination with a value and a reference for this
    value, mixins can be called in order to set the properties. In this example, this
    will change to the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`less/roundedcorners.less`文件中的原始代码，你会发现前面的代码无法适用于`#content`。内容的边框半径是20像素，而不是用于页眉和页脚的10像素。再次，*Less*帮助我们高效地解决了这个问题。混合可以像在函数式编程中调用函数一样带参数调用。这意味着结合值和对该值的引用，可以调用混合以设置属性。在这个例子中，这将改变为以下代码：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `.roundedcornersmixin(@radius: 10px)` mixin, `@radius` is our parameter,
    and its default value will be `10px`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '在`.roundedcornersmixin(@radius: 10px)`混合中，`@radius`是我们的参数，其默认值将是`10px`。'
- en: From this point onwards, mixins can be used in your code. The `.roundedcornersmixin(50px);`
    statement will set the corners with a radius of 50px and the `.roundedcornersmixin();`
    statement will do the same with a radius of 10px (default).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，你可以在你的代码中使用混合。`.roundedcornersmixin(50px);`语句将设置半径为50像素的角，而`.roundedcornersmixin();`语句将使用默认值10像素进行相同的操作。
- en: 'Using this, you can rewrite `less/roundedcorners.less` so that it changes to
    the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，你可以重写`less/roundedcorners.less`，使其变成以下代码：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `less/roundedcornersmixins.less` file from the downloads section contains
    a copy of this code. To use this, you also have to change the reference in your
    HTML file to `<link rel="stylesheet/less" type="text/css" href="less/groundedcornersmixins.less"
    />`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下载部分的`less/roundedcornersmixins.less`文件包含了这段代码的副本。要使用这个，你还必须在HTML文件中将引用更改为`<link
    rel="stylesheet/less" type="text/css" href="less/groundedcornersmixins.less" />`。
- en: Note that this code leaves out the general styling of the `div` and `body` tags
    in the HTML. These styles are only used to make the demo look good and do not
    actually demonstrate *Less* in any useful manner.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码省略了HTML中`div`和`body`标签的一般样式。这些样式只是用来使演示看起来好看，并没有真正有用地展示*Less*。
- en: After rewriting your *Less* code, reload your browser or watch it if you have
    applied the `#!watch` trick. You will see that the output will be exactly the
    same. This shows you how to get the same results with *Less* using a more efficiently
    structured code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重写*Less*代码后，重新加载浏览器或观察它是否应用了`#!watch`技巧。你会发现输出结果完全相同。这向你展示了如何使用*Less*以更高效的结构化代码获得相同的结果。
- en: Preventing cross-browser issues with CSS resets
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS重置来防止跨浏览器问题
- en: When talking about **cascade** in CSS, there will no doubt be a mention of the
    browser default settings getting a higher precedence than the author's preferred
    styling. When writing *Less* code, you will overwrite the browser's default styling.
    In other words, anything that you do not define will be assigned a default styling,
    which is defined by the browser. This behavior plays a major role in many cross-browser
    issues. To prevent these sorts of problems, you can perform a **CSS reset**. The
    most famous browser reset is Eric Meyer's CSS Reset (accessible at [http://meyerweb.com/eric/tools/css/reset/](http://meyerweb.com/eric/tools/css/reset/)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论CSS中的**层叠**时，无疑会提到浏览器默认设置比作者首选样式具有更高的优先级。在编写*Less*代码时，你将覆盖浏览器的默认样式。换句话说，任何你没有定义的东西都将被分配一个默认样式，这是由浏览器定义的。这种行为在许多跨浏览器问题中起着重要作用。为了防止这些问题，你可以执行**CSS重置**。最著名的浏览器重置是Eric
    Meyer的CSS重置（可在[http://meyerweb.com/eric/tools/css/reset/](http://meyerweb.com/eric/tools/css/reset/)访问）。
- en: CSS resets overwrite the default styling rules of the browser and create a starting
    point for styling. This starting point looks and acts the same on all (or most)
    browsers. In this book, normalize.css v2 is used. Normalize.css is a modern, HTML5-ready
    alternative to CSS resets and can be downloaded from [http://necolas.github.io/normalize.css/](http://necolas.github.io/normalize.css/).
    It lets browsers render all elements more consistently and makes them adhere to
    modern standards.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: CSS重置会覆盖浏览器的默认样式规则，并为样式创建一个起点。这个起点在所有（或大多数）浏览器上看起来和行为都是一样的。在本书中，使用的是normalize.css
    v2。Normalize.css是CSS重置的现代、HTML5-ready替代方案，可以从[http://necolas.github.io/normalize.css/](http://necolas.github.io/normalize.css/)下载。它让浏览器更一致地渲染所有元素，并使它们符合现代标准。
- en: To use a CSS reset, you can make use of the `@import` directive of *Less*. With
    `@import`, you can include other *Less* files in your main *Less* file. The syntax
    is `@import "{filename}";`. By default, the search path for the directives starts
    at the directory of the main file. Although setting alternative search paths is
    possible (by setting the path's variable of your *Less* environment), it will
    not be used in this book.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用CSS重置，您可以使用*Less*的`@import`指令。使用`@import`，您可以在主*Less*文件中包含其他*Less*文件。语法是`@import
    "{filename}";`。默认情况下，指令的搜索路径从主文件的目录开始。虽然可以设置替代搜索路径（通过设置*Less*环境的路径变量），但本书中不会使用。
- en: The example *Less* files in this book will contain `@import "normalize.less";`
    in the first few lines of the code. Again, you should note that `normalize.less`
    does contain the CSS code. You should pay particular attention to the profits
    of this solution!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例*Less*文件将在代码的前几行包含`@import "normalize.less";`。再次强调，您应该特别注意这种解决方案的利润！
- en: If you want to change or update the CSS reset, you will only have to replace
    one file. If you have to manage or build more than one project, which most of
    you should be doing, then you can simply reuse the complete reset code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要更改或更新CSS重置，您只需替换一个文件。如果您必须管理或构建多个项目，那么您应该这样做，那么您可以简单地重用完整的重置代码。
- en: Creating background gradients
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建背景渐变
- en: A new feature in CSS3 is the possibility of adding a **gradient** in the background
    color of an element. This acts as a replacement for complex code and image fallbacks.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3中的一个新功能是在元素的背景颜色中添加**渐变**的可能性。这可以替代复杂的代码和图像回退。
- en: 'It is possible to define different types of gradient and use two or more colors.
    In the following figure, you will see a background gradient of different colors:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义不同类型的渐变并使用两种或两种以上颜色。在下图中，您将看到不同颜色的背景渐变：
- en: '![Creating background gradients](img/1465OS-01-05.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![创建背景渐变](img/1465OS-01-05.jpg)'
- en: A gradient example (from [W3schools.com](http://W3schools.com))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 渐变示例（来自[W3schools.com](http://W3schools.com)）
- en: In the next example, you can use a linear gradient of two colors. The background
    gradients use vendor-specific rules.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，您可以使用两种颜色的线性渐变。背景渐变使用供应商特定的规则。
- en: You can make use of the example code from the rounded corners example to add
    gradients to it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用圆角示例中的示例代码来添加渐变。
- en: 'The first step is to copy or open `less/gradient.less` and add a new mixin
    at the start of this file as shown in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是复制或打开`less/gradient.less`，并在该文件开头添加一个新的mixin，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will create gradients from the left (`@origin`) to the right with colors
    from `@start` to `@stop`. This mixin has default values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从左侧（`@origin`）到右侧创建渐变，颜色从`@start`到`@stop`。这个mixin有默认值。
- en: 'IE9 (and its earlier versions) do not support gradients. A fallback can be
    added by adding `background-color: @start;`, which will create a uniform colored
    background for older browsers.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'IE9（及其早期版本）不支持渐变。可以通过添加`background-color: @start;`来添加回退，这将为旧版浏览器创建统一的彩色背景。'
- en: 'After adding the mixin to your code, you can call on it for our `#header`,
    `#body`, and `#footer` selectors as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在将mixin添加到您的代码后，您可以按照以下代码为我们的`#header`，`#body`和`#footer`选择器调用它：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For example, if you renamed the *Less* file to `less/gradient.less`, you would
    have also had to change the reference in your HTML file to the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您将*Less*文件重命名为`less/gradient.less`，您还必须更改HTML文件中的引用为以下代码：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you now load the HTML file in the browser, your results should be like the
    following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在在浏览器中加载HTML文件，您的结果应该如下截图所示：
- en: '![Creating background gradients](img/1465OS-01-04.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![创建背景渐变](img/1465OS-01-04.jpg)'
- en: Gradients in the header, content, and footer from the example code
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 来自示例代码的标题，内容和页脚中的渐变
- en: CSS transitions, transformations, and animations
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS过渡，变换和动画
- en: Another new feature in CSS3 is the presence of transitions, transformations,
    and animations. These functions can replace the animated images, flash animations,
    and JavaScripts in the existing or new web pages. The difference between transitions,
    transforms, and animations isn't trivial. **Animations** are constructed with
    a range of `@keyframes`, where each `@keyframes` handles different states of your
    element in time. **Transitions** also describe the state of element between start
    and end. Transitions are mostly triggered by CSS changes, such as a mouse over
    (hover) of an element.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3中的另一个新功能是过渡，变换和动画的存在。这些功能可以替代现有或新网页中的动画图像，Flash动画和JavaScript。过渡，变换和动画之间的区别并不是微不足道的。**动画**是由一系列`@keyframes`构建的，其中每个`@keyframes`处理元素在时间上的不同状态。**过渡**也描述了元素在开始和结束之间的状态。过渡大多是由CSS更改触发的，例如鼠标悬停在元素上。
- en: 'To make things clear, it is important to keep in mind the button that is about
    to be pressed. The button will have two states: pressed and not pressed. Without
    transitions and animations, we are enabled to style these states only. The color
    of the button is white, and its color becomes red when you hover the mouse over
    it. (In CSS terms, its state becomes hovered by adding the `:hover` pseudo class.)
    In this case, the transition describes how the hovered button becomes red. For
    example, the change in color from white to red in two seconds (which makes it
    pink halfway) shows that the start of the color change is slow and changes faster
    as time passes. Using animations here enables us to describe the state of the
    button for every time interval between the start and end. For example, you don''t
    have to change the color from white to red, but the change covers all the states,
    from white, blue, green, and finally to red.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搞清楚事情，重要的是要记住即将按下的按钮。按钮将有两种状态：按下和未按下。没有过渡和动画，我们只能对这些状态进行样式设置。按钮的颜色是白色，当您将鼠标悬停在其上时，其颜色变为红色。（在CSS术语中，通过添加`:hover`伪类，其状态变为悬停。）在这种情况下，过渡描述了悬停按钮如何变为红色。例如，从白色到红色的颜色变化在两秒内（使其在一半时变为粉红色）表明颜色变化的开始是缓慢的，并随着时间的推移变化更快。在这里使用动画使我们能够描述按钮在开始和结束之间的每个时间间隔的状态。例如，您不必将颜色从白色变为红色，而是变化涵盖了所有状态，从白色、蓝色、绿色，最终到红色。
- en: '**Transformations** change the position of an element and how it looks. They
    do not depend on the state of the element. Some of the possible transformations
    are **scaling**, **translating** (moving), and **rotating**.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换**改变元素的位置和外观。它们不依赖于元素的状态。一些可能的转换是**缩放**、**平移**（移动）和**旋转**。'
- en: In practice, we use a combination of animations, transformations, and/or transitions
    in most situations. Also, in this case, vendor-specific rules will play an important
    role.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们在大多数情况下都会使用动画、转换和/或过渡的组合。同样，在这种情况下，特定于供应商的规则将发挥重要作用。
- en: Now, a transformation will be added to our example.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的示例将添加一个转换。
- en: 'Using the example code with rounded corners and gradients, copy the following
    code to `less/transition.less` or open `less/transition.less` and add the following
    code to the beginning of the file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有圆角和渐变的示例代码，将以下代码复制到`less/transition.less`，或者打开`less/transition.less`并将以下代码添加到文件的开头：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This **mixin** has three variables; the first will be the **property** (`@prop`)
    that you will change. This can be `height`, `background-color`, `visibility`,
    and so on. The default value `all` shouldn't be used in the production code as
    this will have a negative effect on performance. `@time` sets the duration in
    milliseconds or seconds with `s` appended to it. The last variable, `@ease`, sets
    the **transition-timing-function property**. This function describes the value
    of a property, given that a certain percentage of it has been completed. The transition-timing-function
    property describes the completeness of the transition as a function of time. Setting
    it to `linear` shows the effect with the same speed from start to end, while `ease`
    starts slow and ends slow, having a higher speed in the middle. The predefined
    functions are `ease`, `linear`, `ease-in`, `ease-out`, `ease-in-out`, `step-start`,
    and `step-end`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**mixin**有三个变量；第一个是您将要更改的**属性**(`@prop`)。这可以是`height`、`background-color`、`visibility`等。默认值`all`不应在生产代码中使用，因为这会对性能产生负面影响。`@time`设置以毫秒或秒为单位的持续时间，并在其后附加`s`。最后一个变量`@ease`设置**transition-timing-function属性**。此函数描述了属性的值，假设其某个百分比已经完成。transition-timing-function属性描述了过渡的完成度随时间的函数。将其设置为`linear`会显示从开始到结束相同速度的效果，而`ease`会以较慢的速度开始和结束，并在中间速度更快。预定义的函数有`ease`、`linear`、`ease-in`、`ease-out`、`ease-in-out`、`step-start`和`step-end`。
- en: 'Now, you can edit `less/transition.less` to use this **mixin**. You can set
    the background color of the body when you hover over it. Note that you don''t
    need to use the transition to change the gradient color but rather change the
    `background-color` attribute. You are using `background-color` because `transition-duration`
    doesn''t have a visible effect on the gradient. The code of the `background-color`
    transition is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以编辑`less/transition.less`以使用此**mixin**。当您悬停在页面上时，您可以设置body的背景颜色。请注意，您不需要使用过渡来更改渐变颜色，而是更改`background-color`属性。您使用`background-color`是因为`transition-duration`对渐变没有可见效果。`background-color`过渡的代码如下：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you renamed the *Less* file, for example, to `less/transition.less`, you
    would also have to change the reference in your HTML file to the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将*Less*文件重命名为`less/transition.less`，您还必须更改HTML文件中的引用为以下代码：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you load the HTML file in the browser, you will be able to see the results
    in the browser. Move your mouse over the content and see it change from white
    to red in 5 seconds.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中加载HTML文件，您将能够在浏览器中看到结果。将鼠标悬停在内容上，您将看到它在5秒内从白色变为红色。
- en: 'Finally, a second example that rotates the header can be added. In this example,
    you will use `@keyframes`. Using `@keyframes` will be complex. So, in this case,
    you can define some vendor-specific rules and add these animation properties to
    `#header:` as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以添加一个旋转标题的第二个示例。在这个示例中，您将使用`@keyframes`。使用`@keyframes`会比较复杂。因此，在这种情况下，您可以定义一些特定于供应商的规则，并将这些动画属性添加到`#header:`如下：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can add the preceding code to our example files or open `less/keyframes.less`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将上述代码添加到我们的示例文件中，或者打开`less/keyframes.less`。
- en: 'If you renamed the *Less* file, for example, to `less/keyframes.less`, you
    also have to change the reference in your HTML file to the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将*Less*文件重命名为`less/keyframes.less`，您还必须更改HTML文件中的引用为以下代码：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, load the HTML file in the browser and watch your results. Amazing, isn't
    it? With a little bit of creative thinking, you will see the possibilities of
    creating a rotating windmill or a winking owl using only CSS3\. However, the first
    thing that should be done is to explain the code used here in more detail. As
    mentioned earlier, there are many cases in which you would make combinations of
    **animations** and **transformations**. In this example, you also get to animate
    a transformation effect. To understand what is going on, the code can be split
    into three parts.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中加载HTML文件并观看您的结果。很神奇，不是吗？通过一点创造性思维，您将看到只使用CSS3就可以创建旋转的风车或眨眼的猫头鹰的可能性。然而，首先应该更详细地解释这里使用的代码。如前所述，在许多情况下，您会组合**动画**和**转换**。在这个例子中，您还可以对转换效果进行动画处理。要理解发生了什么，代码可以分为三个部分。
- en: 'The first part is `@keyframes`, shown in the following code, which describe
    the value of the CSS properties (transformation in this case) as a function of
    the percentage of the **animation** completeness:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是`@keyframes`，如下面的代码所示，它描述了CSS属性（在这种情况下是转换）的值作为**动画**完成百分比的函数：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These **keyframes** have been given the name reference `spin`, which is not
    a special effect but only a chosen name. In the preceding example, a state of
    100 percent completeness is described. At this state, the animated element should
    have made a rotation of 360 degrees.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**关键帧**被赋予了名称引用`spin`，这不是一个特殊效果，而只是一个选择的名称。在前面的例子中，描述了100%完成的状态。在这种状态下，动画元素应该旋转360度。
- en: This rotation is the second part that needs our attention. The **transformation**
    describes the position or dimensions of an element in the space. In this example,
    the position is described by the number of degrees of rotation around the axis,
    360 degrees at 100 percent, 180 degrees at 50 percent, 90 degrees at 25 percent,
    and so on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个旋转是需要我们关注的第二部分。**转换**描述了元素在空间中的位置或尺寸。在这个例子中，位置由围绕轴的旋转度数描述，100%时为360度，50%时为180度，25%时为90度，依此类推。
- en: 'The third part is the animation itself, described by: `animation:spin 4s linear
    infinite;`. This is the shorthand notation of settings of the subproperties of
    the animation property. In fact, you can write this as the following code, without
    the vendor-specific rules:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分是动画本身，由`animation:spin 4s linear infinite;`描述。这是动画属性的子属性的设置的简写表示法。实际上，您可以将其写成以下代码，不包括供应商特定的规则：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use these three parts to build a complete animation. After doing this,
    you can extend it. For example, add an extra keyframe, which makes the time curve
    nonlinear, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这三个部分来构建完整的动画。完成后，您可以扩展它。例如，添加一个额外的关键帧，使时间曲线非线性，如下所示：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can add a second property using `background-color`. Don''t forget to remove
    the gradient to see its effect. This is shown in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`background-color`添加第二个属性。不要忘记删除渐变以查看其效果。如下面的代码所示：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You will have noticed that the complete profit of using *Less* isn't realized
    here. You will have to write the `@keyframes` definition repeatedly due to its
    variable animation name. In [Chapter 4](ch04.html "Chapter 4. Avoid Reinventing
    the Wheel"), *Avoid Reinventing the Wheel*, a solution will be provided to you
    for this.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在这里并没有完全实现使用*Less*的利润。由于其可变动画名称，您将不得不重复编写`@keyframes`定义。在[第4章](ch04.html
    "第4章。避免重复造轮子")中，*避免重复造轮子*，将为您提供一个解决方案。
- en: Unfortunately, browser support for transitions, transformations, and animations
    is not great and varies between browsers. Google Chrome does not support CSS 3D
    transforms, Firefox lacks support for CSS Filters, and IE9 (and earlier versions)
    don't support them at all. To solve this, many developers look to jQuery to support
    their animations. The `jQuery.animate()` function allows us to change the CSS
    properties of the elements using JavaScript. You can still use *Less* to set the
    initial CSS. An alternative for this will be to use `animate.css` (which you can
    access at [https://github.com/daneden/animate.css](https://github.com/daneden/animate.css));
    this cross-browser library of CSS animations gets converted into *Less* code with
    a jQuery fallback.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，浏览器对过渡、转换和动画的支持并不理想，并且在各个浏览器之间存在差异。谷歌Chrome不支持CSS 3D转换，火狐缺乏对CSS滤镜的支持，IE9（以及更早的版本）根本不支持它们。为了解决这个问题，许多开发人员寻求jQuery来支持他们的动画。`jQuery.animate()`函数允许我们使用JavaScript更改元素的CSS属性。您仍然可以使用*Less*来设置初始CSS。一个替代方案是使用`animate.css`（您可以在[https://github.com/daneden/animate.css](https://github.com/daneden/animate.css)上访问）；这个跨浏览器的CSS动画库可以转换为*Less*代码，并带有jQuery回退。
- en: Box-sizing
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盒模型
- en: 'The **box-sizing** property is the one that sets the CSS-box model used for
    calculating the dimensions of an element. In fact, box-sizing is not new in CSS,
    but nonetheless, switching your code to `box-sizing: border-box` will make your
    work a lot easier. When using the `border-box` settings, calculation of the width
    of an element includes border width and padding. So, changing the border of padding
    won''t break your layouts. You can find a copy of the code used in this section
    in `boxsizing.html` from the download files.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**box-sizing**属性是设置用于计算元素尺寸的CSS框模型的属性。实际上，box-sizing在CSS中并不新鲜，但是将代码切换到`box-sizing:
    border-box`将使您的工作变得更加容易。使用`border-box`设置时，元素宽度的计算包括边框宽度和填充。因此，更改边框或填充不会破坏您的布局。您可以在下载文件中的`boxsizing.html`中找到本节中使用的代码的副本。'
- en: Nowadays, most web designs use a grid. Grids split your design into columns
    of equal size. This helps you make things clear and build responsive interfaces.
    Depending on the available screen size (or width), you can show your content and
    navigation with a different representation of the same columns.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数网页设计都使用网格。网格将设计分成相等大小的列。这有助于使事情清晰，并构建响应式界面。根据可用的屏幕尺寸（或宽度），您可以以相同列的不同表示形式显示内容和导航。
- en: To handle different screen sizes, some parts of your website will have fluid
    width or height. Other elements, such as borders, gutters, and the white space,
    should have a fixed width. The combination of fluid widths as a percentage of
    the screen width (or viewport) with fixed widths becomes complex. This complexity
    will be due to the fact that browsers use different calculations for padding and
    margins of elements.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理不同的屏幕尺寸，网站的某些部分将具有流体宽度或高度。其他元素，如边框、装订线和空白处，应具有固定宽度。流体宽度作为屏幕宽度（或视口）的百分比与固定宽度的组合变得复杂。这种复杂性是因为浏览器对元素的填充和边距使用不同的计算。
- en: In order for you to see this, look at the following example. A container of
    500 pixels width has been created. Inside this container, you can add two rows
    and split the second row into two parts of 50 percent (or half) width.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您看到这一点，请看以下示例。已创建了一个宽度为500像素的容器。在这个容器内，您可以添加两行，并将第二行分成两部分，宽度为50%（或一半）。
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will now look like the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来应该像以下的截图：
- en: '![Box-sizing](img/1465OS-01-07.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Box-sizing](img/1465OS-01-07.jpg)'
- en: An HTML wrapper
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HTML包装器
- en: 'The current structure doesn''t show a problem until you add some padding, which
    is used to construct some space or a border between the two columns on the second
    row (numbers *2* and *3* in the image of the HTML wrapper). The padding and the
    border will break our layout as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的结构直到您添加一些填充时并不会出现问题，这些填充用于在第二行的两列之间构建一些空间或边框（在HTML包装器图像中的数字*2*和*3*）。填充和边框将破坏我们的布局，如下所示：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, the output of this code should look like the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这段代码的输出应该看起来像以下的截图：
- en: '![Box-sizing](img/1465OS-01-08.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Box-sizing](img/1465OS-01-08.jpg)'
- en: A broken layout due to padding and borders
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于填充和边框而导致的破碎布局
- en: 'A similar action can be performed, except that the wrappers can be wrapped
    inside an extra wrapper. The `box-sizing: border-box;` declaration can then be
    applied to this. Now, the results should look like the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '可以执行类似的操作，只是包装器可以包装在额外的包装器内。然后，`box-sizing: border-box;`声明可以应用于此。现在，结果应该看起来像以下的截图：'
- en: '![Box-sizing](img/1465OS-01-09.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Box-sizing](img/1465OS-01-09.jpg)'
- en: 'A layout with box-sizing: border-box'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '使用box-sizing: border-box的布局'
- en: As you can see, the padding and borders are subtracted by 50 percent from the
    parent. This will make the calculation a lot easier. Of course, you can do the
    calculating yourself once the parent container wrapper has a fixed width. If the
    parent has 300 pixels, then 50 percent of this will be 150 pixels. Taking away
    the padding and the width of the border will give you the fixed size of a column.
    This won't work when your parent has a fluid width (the percentage of the viewport).
    Fluid layouts change their width with the width of the screen. If your screen
    becomes smaller, then all the elements become smaller too and the percentage stays
    equal. By doing calculations for all the possible screen sizes to find the real
    size of a column that allows all of your elements to align, you will quickly find
    this to be a long, challenging, and arduous process.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，填充和边框被父元素减去了50%。这将使计算变得更容易。当然，一旦父容器包装器具有固定宽度，您可以自行进行计算。如果父元素有300像素，那么这个50%将是150像素。减去填充和边框的宽度将给出列的固定大小。当父元素具有流体宽度（视口的百分比）时，这种方法不起作用。流体布局随着屏幕宽度的变化而变化。如果您的屏幕变小，那么所有元素也会变小，百分比保持不变。通过为所有可能的屏幕尺寸进行计算，找到允许所有元素对齐的列的真实大小，您将很快发现这是一个漫长、具有挑战性和艰巨的过程。
- en: 'For these reasons, you should make use of `box-sizing: border-box;` for all
    the examples in this book. Please note that box-sizing has to also be defined
    by vendor-specific rules as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，您应该在本书的所有示例中使用`box-sizing: border-box;`。请注意，box-sizing也必须按照供应商特定的规则进行定义，如下所示：'
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this example, the *Less* code will be as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，*Less*代码将如下所示：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'This code has been added into a separate file called `boxsizing.less`. From
    now on, the basics of our *Less* files will now contain the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码已经被添加到一个名为`boxsizing.less`的单独文件中。从现在开始，我们的*Less*文件的基础将包含以下代码：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the following chapters, you will learn more about organizing your *Less*
    code into files.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习更多关于如何将您的*Less*代码组织成文件。
- en: Server-side compiling
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端编译
- en: You have taken the first few steps towards *Less* development already. As explained
    earlier, client-side compiling has been used. However, **client-side** compiling
    with `less.js` shouldn't be used on real websites. This is because despite making
    your development easy and fast, compiling your *Less* files for every page request
    (or in fact, initial page load per user) will actually slow down your website.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经迈出了*Less*开发的前几步。如前所述，已经使用了客户端编译。然而，**客户端**编译与`less.js`不应该在真实的网站上使用。这是因为尽管使您的开发变得简单和快速，但为每个页面请求（或实际上，每个用户的初始页面加载）编译您的*Less*文件实际上会减慢您的网站速度。
- en: For the production environment, it is required that you compile your files and
    serve the final CSS file to the browser. The term **server side** can be somewhat
    misleading. Server side in this context means a compiled CSS code is sent to the
    client's browser instead of *Less* code, which has to be compiled in the client's
    browser by less.js before it is shown. You should precompile your *Less* code.
    By copying and pasting the results of *less.js* to a file and including this as
    a CSS file in your HTML files, you should have the same effect, except that your
    CSS is not minimized.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，需要编译您的文件并将最终的CSS文件提供给浏览器。术语**服务器端**可能有些误导。在这种情况下，服务器端意味着编译后的CSS代码被发送到客户端浏览器，而不是*Less*代码，它必须在客户端浏览器中由less.js编译后显示。您应该预编译您的*Less*代码。通过将*less.js*的结果复制粘贴到一个文件中，并在HTML文件中包含这个文件作为CSS文件，您应该会得到相同的效果，只是您的CSS没有被最小化。
- en: '*Less* bundles a command-line compiler. Installing and using it is simple using
    the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*Less*捆绑了一个命令行编译器。使用以下命令安装和使用它非常简单：'
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The package manager for the Node JavaScript platform is **npm**. Node enables
    you to run Java scripts without a browser. Node and npm run on Windows, Mac OS
    X, and other Unix/*nix machines. You will find the Node.js source code or a prebuilt
    installer for your platform by visiting [http://nodejs.org/download/](http://nodejs.org/download/).
    To install npm, please read the instructions in the README file by visiting [https://www.npmjs.org/doc/README.html](https://www.npmjs.org/doc/README.html).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Node JavaScript 平台的软件包管理器是 **npm**。Node 可以在没有浏览器的情况下运行 JavaScript 脚本。Node 和
    npm 可在 Windows、Mac OS X 和其他 Unix/*nix 机器上运行。您可以通过访问 [http://nodejs.org/download/](http://nodejs.org/download)
    找到适用于您平台的 Node.js 源代码或预构建安装程序。要安装 npm，请阅读 README 文件中的说明，网址为 [https://www.npmjs.org/doc/README.html](https://www.npmjs.org/doc/README.html)。
- en: 'Use the `–help` function to get a list of options you can use with the following
    command-line compiler:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `–help` 函数获取以下命令行编译器可用的选项列表：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`lessc styles.less styles.css` compiles `styles.less` to `styles.css`. The
    links to `styles.css` in your HTML after successfully compiling it are then shown
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`lessc styles.less styles.css` 将 `styles.less` 编译为 `styles.css`。在成功编译后，HTML
    中指向 `styles.css` 的链接将如下显示：'
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compressing and minimizing your CSS
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩和最小化你的 CSS
- en: After compilation, the CSS code is clean and readable. When taking this code
    into production, you have to compress and minimize it in order to increase the
    loading speed and save on the bandwidth as well. The basic steps for **compressing**
    and **minimizing** the CSS code are removing comments, white spaces, and other
    unnecessary code. The results won't be easy to be read by a human, but this doesn't
    matter because you can use the *Less* files to update or modify the CSS.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，CSS 代码是干净且可读的。在将此代码投入生产时，您必须压缩和最小化它以增加加载速度并节省带宽。**压缩** 和 **最小化** CSS 代码的基本步骤是删除注释、空格和其他不必要的代码。结果可能不容易被人类阅读，但这并不重要，因为您可以使用
    *Less* 文件来更新或修改 CSS。
- en: The *Less* command-line compiler has two options for compressing and minimizing.
    The first option (**-x** or `–yui-compress`) uses the **YUI CSS Compressor** (which
    you can access at [http://yui.github.io/yuicompressor/css.html](http://yui.github.io/yuicompressor/css.html))
    and the second option (`--clean-css`) uses **clean-css** (which you can access
    at [https://github.com/GoalSmashers/clean-css](https://github.com/GoalSmashers/clean-css)).
    You cannot use both options together. **Clean-css** claims to be faster, and until
    recently, you would not have found much difference in the compression. By compiling
    `keyframes.less` from the previous example, including `normalize.less` and `boxsizing.less`,
    the result will have a size of 4377 bytes. With clean-css, this drops to 3516
    bytes, whilst YUI gives 3538 bytes. Since Version 1.5.0 of *Less*, clean-css is
    the compiler's default option.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*Less* 命令行编译器有两个选项用于压缩和最小化。第一个选项（**-x** 或 `–yui-compress`）使用 **YUI CSS 压缩器**（可以在
    [http://yui.github.io/yuicompressor/css.html](http://yui.github.io/yuicompressor/css.html)
    访问），第二个选项（`--clean-css`）使用 **clean-css**（可以在 [https://github.com/GoalSmashers/clean-css](https://github.com/GoalSmashers/clean-css)
    访问）。你不能同时使用这两个选项。**Clean-css** 声称更快，直到最近，你可能不会在压缩中发现太大的差异。通过编译前面示例中的 `keyframes.less`，包括
    `normalize.less` 和 `boxsizing.less`，结果将为 4377 字节。使用 clean-css，这将减少到 3516 字节，而
    YUI 则为 3538 字节。自 *Less* 版本 1.5.0 起，clean-css 是编译器的默认选项。'
- en: Graphical user interfaces
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形用户界面
- en: 'Some of you will prefer a **Graphical User Interface** (**GUI**) instead of
    command-line compiling. There are many GUIs available for different platforms
    in order to edit and compile your *Less* code. All of them cannot be mentioned
    here. Instead, the following is a list of the most positive noticeable ones:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人会更喜欢使用 **图形用户界面**（**GUI**）而不是命令行编译。有许多 GUI 可用于不同平台，以编辑和编译您的 *Less* 代码。这里无法提及所有
    GUI。相反，以下是一些最显著的正面 GUI 的列表：
- en: WinLess is a Windows GUI for less.js.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinLess 是 Windows 上的 *Less* GUI。
- en: SimpLESS is a cross-platform editor and compiler with many functions, including
    the automatic addintion of vendor-specific rules to your code.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SimpLESS 是一个跨平台的编辑器和编译器，具有许多功能，包括自动向您的代码添加供应商特定规则。
- en: CodeKIT is a GUI for Mac (OS X). It compiles many languages including *Less*.
    It includes optimizations and browser previews.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeKIT 是 Mac（OS X）的 GUI。它可以编译许多语言，包括 *Less*。它包括优化和浏览器预览。
- en: The last one mentioned is Crunch! Crunch! is also a cross-platform compiler
    and editor.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后提到的是 Crunch! Crunch! 也是一个跨平台的编译器和编辑器。
- en: When choosing a GUI for *Less* development, always check which version of `less.js`
    it uses. Some GUI's are built on older versions of `less.js` and don't support
    the latest features.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 *Less* 开发的 GUI 时，始终检查它使用的 `less.js` 版本。一些 GUI 是建立在较旧版本的 `less.js` 上，并不支持最新的功能。
- en: Web developers using Visual Studio should check out **Web Essentials**. Web
    Essentials extends Visual Studio with a lot of new features, including *Less*.
    Also, other IDEs such as **PHPStorm** have built-in *Less* compilers. There is
    a *Less* plugin for **Eclipse** also.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 的 Web 开发人员应该查看 **Web Essentials**。Web Essentials 扩展了 Visual
    Studio 的许多新功能，包括 *Less*。此外，其他 IDE（如 **PHPStorm**）也内置了 *Less* 编译器。Eclipse 也有 *Less*
    插件。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you refreshed and extended your knowledge about CSS3\. You
    learned how to compile your *Less* code on the client side. Furthermore, you have
    written the code that allows you to have rounded corners, gradients, and animations
    in *Less*, so you can now witness the profits of using *Less* and take the crucial
    initial steps to organize and plan your new projects. You witnessed why you would
    want to use CSS resets, how to compile these into *Less* code, as well as how
    the box-sizing border-box can make your job easier. You also saw what a mixin
    is, how to use it, and how you can import a *Less* file with the `@import` directive.
    Last but not least, you have learned what server-side compiling is and how to
    use GUIs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您刷新并扩展了关于CSS3的知识。您学会了如何在客户端上编译您的*Less*代码。此外，您已经编写了允许您在*Less*中拥有圆角、渐变和动画的代码，因此您现在可以见证使用*Less*的利润，并采取关键的初始步骤来组织和规划您的新项目。您了解了为什么要使用CSS重置，如何将其编译成*Less*代码，以及box-sizing
    border-box如何使您的工作更轻松。您还了解了mixin是什么，如何使用它，以及如何使用`@import`指令导入*Less*文件。最后但同样重要的是，您已经学会了什么是服务器端编译以及如何使用GUI。
- en: In the next chapter, you will learn how to use variables in *Less* and how to
    build and use complex mixins.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何在*Less*中使用变量以及如何构建和使用复杂的mixin。
