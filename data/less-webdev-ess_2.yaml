- en: Chapter 2. Using Variables and Mixins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用变量和混合
- en: In this chapter, you will study *Less* in more detail, where you will learn
    more about variables and mixins. **Variables** in *Less* can be reused anywhere
    in the code. Although they are often defined in a single place, they can also
    be overwritten elsewhere in the code. They are used to define commonly used values
    that can be edited only once at a single place. Based on the **Don't Repeat Yourself**
    (**DRY**) principle, commonly used values will help you build websites that are
    easier to maintain. **Mixins** are used to set the properties of a class. They
    bundle tasks in a single line of code and are also reusable. You will learn how
    to create, use, and reuse them in your project and write better CSS without code
    duplications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将更详细地学习*Less*，了解更多关于变量和混合的知识。*Less*中的**变量**可以在代码中的任何地方重复使用。虽然它们通常在一个地方定义，但也可以在代码的其他地方被覆盖。它们用于定义常用值，这些值只能在一个地方编辑一次。基于**不要重复自己**（**DRY**）原则，常用值将帮助你构建更易于维护的网站。**混合**用于设置类的属性。它们将任务捆绑在一行代码中，并且可重复使用。你将学习如何在项目中创建、使用和重复使用它们，并且编写更好的CSS而不重复代码。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Commenting on your code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的代码进行注释
- en: Using variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Escaping values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的转义
- en: Using mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混合
- en: Comments
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: Comments make your code clear and readable for others. It is important that
    you are able to understand them clearly. That is why this chapter starts with
    some notes and examples of comments.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注释使你的代码清晰易读。重要的是你能够清楚地理解它们。这就是为什么本章以一些注释的注解和示例开始的原因。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't be sparse with your comments when keeping the file size, download time,
    and performance in mind. In the process of compiling and minimizing your final
    CSS code, comments and other layout structures will be effectively removed. You
    can add comments for understanding and readability wherever needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑文件大小、下载时间和性能时，不要吝啬你的注释。在编译和最小化最终的CSS代码过程中，注释和其他布局结构将被有效地移除。你可以在需要的地方添加注释以便理解和可读性。
- en: In *Less*, you can add comments in the same way as you did while writing the
    CSS code. Comment lines are placed between `/* */`. *Less* also allows single-line
    comments that start with `//`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Less*中，你可以像编写CSS代码时一样添加注释。注释行放在`/* */`之间。*Less*还允许以`//`开头的单行注释。
- en: 'Using *Less*, you will conserve these comments in the final style sheet apart
    from the single-line comments, which are not printed. **Minimizers** will remove
    these comments in your final **compiled style sheet**. An example of this can
    be seen in the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Less*，你将会在最终样式表中保留这些注释，除了单行注释，它们不会被打印出来。**最小化器**会在你的最终**编译样式表**中移除这些注释。以下代码中可以看到一个例子：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Nested comments
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套注释
- en: 'Although *Less*, like PHP or JavaScript, doesn''t allow nested comments, single-line
    comments that start with `//` are allowed and can be mixed with the normal comment
    syntax. This is shown in the following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*Less*，像PHP或JavaScript一样，不允许嵌套注释，但以`//`开头的单行注释是允许的，并且可以与正常的注释语法混合使用。以下代码片段中展示了这一点：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Special comments
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊注释
- en: 'Minimizers define a special comment syntax, sometimes to allow an important
    comment, such as a license notice, to be included in the minimized output as well.
    You can use this syntax to write some copyright notices at the top of your style
    sheet. Using clean CSS and the default minimizer of the `clean-css` command-line
    compiler of *Less*, you should place this important command between `/*! !*/`,
    as shown in the following example code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化器定义了一种特殊的注释语法，有时允许将重要注释（如许可通知）包含在最小化的输出中。你可以使用这种语法在样式表的顶部写一些版权声明。使用干净的CSS和*Less*的`clean-css`命令行编译器的默认最小化器，你应该在`/*!
    !*/`之间放置这个重要的命令，如下例所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Variables
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Variables in *Less* help you keep your files organized and easy to maintain.
    They allow you to specify widely-used values in a single place and then reuse
    them throughout your *Less* code. The properties of the final style sheet can
    be set with variables. So, imagine that you don't have to search for every declaration
    of a specific color or value in your style sheets any more. How does all of this
    work? Variables will start with `@` and have a name. Examples of such variables
    include `@color`, `@size`, and `@tree`. To write the name, you are allowed to
    use any alphanumeric character, underscores, and dashes. This means that `@this-is-variable-name-with-35-chars`
    is a valid variable name.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Less*中的变量帮助你保持文件的组织和易于维护。它们允许你在一个地方指定广泛使用的值，然后在整个*Less*代码中重复使用它们。最终样式表的属性可以通过变量设置。所以，想象一下，你不再需要在样式表中搜索特定颜色或值的每个声明了。所有这些是如何工作的呢？变量将以`@`开头并具有一个名称。这样的变量示例包括`@color`、`@size`和`@tree`。在写名称时，你可以使用任何字母数字字符、下划线和破折号。这意味着`@this-is-variable-name-with-35-chars`是一个有效的变量名。'
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although alphanumeric characters, underscores, and dashes are used in variable
    names in this book, the specifications allow you to use any character, with a
    few exceptions. The specifications find their origin in the CSS grammar (which
    you can view at [http://www.w3.org/TR/CSS21/grammar.html](http://www.w3.org/TR/CSS21/grammar.html)).
    Names starting with a dash are reserved for vendor-specific rules, and a space
    is already used to separate class names from each other. It is possible and allowed
    to use escaping, which is very rare for (programming) languages. However, the
    escaping of white spaces is not possible. `NULL` is also not allowed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书中的变量名使用了字母数字字符、下划线和破折号，但规范允许使用任何字符，有一些例外。这些规范源自CSS语法（你可以在[http://www.w3.org/TR/CSS21/grammar.html](http://www.w3.org/TR/CSS21/grammar.html)查看）。以破折号开头的名称保留给供应商特定规则，而空格已经用于将类名相互分隔。使用转义是可能且允许的，这在（编程）语言中非常罕见。然而，空格的转义是不可能的。`NULL`也是不允许的。
- en: Unfortunately, the use of `@` is ambiguous in *Less*. As you have seen in the
    first chapter, parameters used by mixins also start with `@`. That's not all.
    As valid CSS code is also valid *Less* code, there will be CSS media query declarations
    that also start with `@`. The context will make it clear when `@` is used to declare
    a variable. If the context is not clear enough, the meaning of the `@` will be
    explicitly mentioned in this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在*Less*中使用`@`是有歧义的。正如您在第一章中所见，混合使用的参数也以`@`开头。这还不是全部。由于有效的CSS代码也是有效的*Less*代码，因此还会有以`@`开头的CSS媒体查询声明。上下文将清楚地表明`@`用于声明变量。如果上下文不够清晰，本书中将明确提到`@`的含义。
- en: You can give a variable a value, which will be called a declaration. A value
    can contain anything that is a valid value for a CSS property.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为变量赋值，这将被称为声明。值可以包含任何对CSS属性有效的值。
- en: 'You can use a colon (`:`) to assign a value to a variable. A declaration ends
    with a semicolon (`;`). The following examples will make this clear:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用冒号（`:`）为变量赋值。声明以分号（`;`）结束。以下示例将说明这一点：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After the declaration of a variable, you can use the variable anywhere in your
    code to reference its value. This quality makes variables extremely powerful when
    programming *Less* code. Take a look at the example code for this chapter from
    the downloadable code for this book to get a better understanding.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明之后，您可以在代码中的任何位置使用该变量来引用其值。这使得变量在编程*Less*代码时非常强大。查看本书的可下载代码中的本章示例代码，以更好地理解。
- en: Organizing your files
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织您的文件
- en: As you have seen, you only have to declare a variable once to use it anywhere
    in the code. So, to make changes to the variables, you also have to change them
    only once. The example code defines the variables in a separate file called `less/variables.less`.
    It is a great practice to organize your files. If you want to change something,
    you now know where to look.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，您只需声明一次变量，就可以在代码中的任何地方使用它。因此，要对变量进行更改，您也只需更改一次。示例代码在名为`less/variables.less`的单独文件中定义了变量。组织文件是一个很好的做法。如果您想要进行更改，现在您知道该去哪里查找了。
- en: 'Recalling **CSS reset** and **border-boxing** from the first chapter, your
    main *Less* file will now look like the following code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第一章中的**CSS重置**和**边框盒模型**，您的主*Less*文件现在将如下代码片段所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `@import` statement imports code from the file to the main *Less*
    file. Filenames are written between quotes and followed by a semicolon. Besides
    the *Less* files, you can also import plain CSS files, which will not be processed
    for the *Less* directives; this will be explained in more detail in [Chapter 5](ch05.html
    "Chapter 5. Integrate Less in Your Own Projects"), *Integrating Less in Your Own
    Projects*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@import`语句从文件中导入代码到主*Less*文件中。文件名用引号括起来，后面跟着一个分号。除了*Less*文件，您还可以导入普通的CSS文件，这些文件不会被处理为*Less*指令；这将在[第5章](ch05.html
    "第5章。将Less集成到您自己的项目中")中详细解释，*将Less集成到您自己的项目中*。
- en: Now you should open `http://localhost/index.html` in your browser. You will
    see a straightforward website layout, which contains a header, content block,
    side menu, and three-columned footer, as shown in the following screenshot. All
    the layout items have blue accents. After this, open `less/variables.less` in
    your favorite text editor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在浏览器中打开`http://localhost/index.html`。您将看到一个简单的网站布局，其中包含标题、内容块、侧边菜单和三列页脚，如下面的屏幕截图所示。所有布局项都有蓝色的装饰。之后，打开您喜欢的文本编辑器中的`less/variables.less`。
- en: '![Organizing your files](img/1465OS-02-01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![组织您的文件](img/1465OS-02-01.jpg)'
- en: A layout built with *Less*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Less*构建的布局
- en: Curious as you are, I bet you have also opened the other files. Don't be scared
    by the complexity of the code in them. This code and layout have been used to
    show the power of widely-used variables that have been defined in a single place.
    This can be better demonstrated with more realistic and complex examples than
    by just a few lines of code. Rest assured that all the other code will explain
    this to you soon. Before you know it, all this code will look very familiar to
    you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您很好奇，我敢打赌您也打开了其他文件。不要被其中的代码复杂性吓到。这些代码和布局用于展示在单个位置定义的广泛使用的变量的强大功能。这可以通过比几行代码更现实和复杂的示例更好地展示出来。请放心，所有其他代码很快就会向您解释这一点。在您知晓之前，所有这些代码对您来说都将非常熟悉。
- en: 'Firstly, change `darkblue` to `darkgreen` in the `@darkcolor: darkgreen;` line
    in the `less/variables.less` file, which you opened earlier. After this, watch
    the results in your browser. Reload your browser if you still haven''t used the
    `#!watch` function.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，在您之前打开的`less/variables.less`文件中的`@darkcolor: darkgreen;`行中，将`darkblue`更改为`darkgreen`。之后，观察浏览器中的结果。如果您还没有使用`#!watch`功能，请重新加载浏览器。'
- en: The layout will now be shown in green. If you weren't convinced earlier, you
    should be now. In practice, you won't change a complete website using a single
    line of code, but this example shows what *Less* can do to make your work easier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 布局现在将显示为绿色。如果您之前还不确定，现在应该明白了。在实践中，您不会使用一行代码来更改整个网站，但这个示例展示了*Less*可以如何使您的工作更轻松。
- en: 'Imagine that you have finished your dark-green website''s job, and you show
    it to your boss. "Well done!", he says, but he also tells you, "I know I asked
    for green, but if you don''t mind, I prefer a red website". For now, you smile
    and simply change `darkgreen` to `darkred` in the `@darkcolor: darkgreen;` line
    in the `less/variables.less` file.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '想象一下，您已经完成了您的深绿色网站的工作，并向老板展示了它。"干得好！"他说，但他也告诉您："我知道我要求绿色，但如果您不介意，我更喜欢红色的网站"。现在，您微笑着，只需在`less/variables.less`文件中的`@darkcolor:
    darkgreen;`行中将`darkgreen`更改为`darkred`。'
- en: As you have seen, your HTML is clean and straightforward, with no inline CSS
    or even class names. There is now a new concern; you will have to name, declare,
    and save your variables in a smart and proper fashion. When doing this, be consistent
    and clear as it is of high importance. When organizing your variables, follow
    the same strategy at all times, using name conventions and comments where the
    context isn't clear enough. Please keep in mind that someone should be able to
    take over your work without any further instructions at any moment. To achieve
    this, you will have to explore the variables at deeper levels.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，您的HTML是干净和直接的，没有内联CSS甚至类名。现在有一个新的问题；您将不得不以聪明和适当的方式命名、声明和保存您的变量。在这样做时，保持一致和清晰是非常重要的。在组织您的变量时，始终遵循相同的策略，使用命名约定和在上下文不够清晰的地方添加注释。请记住，任何人都应该能够在任何时候接管您的工作而无需进一步的说明。为了实现这一点，您将不得不深入了解变量。
- en: Naming your variables
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名您的变量
- en: You should always give your variables meaningful and descriptive names. Variable
    names such as `@a1` and `@a2` will get compiled but have not been chosen well.
    When the number of variables grows or when you have to change something quite
    deep in the code, you will not know or remember what `@a2` has been used for.
    You will have to look up its context to find its use in your *Less* files or even
    worse, inspect your HTML elements to find which CSS rules are applied on it in
    order to find the *Less* context. In this unfortunate case, you will be back to
    square one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终给您的变量起有意义和描述性的名称。像`@a1`和`@a2`这样的变量名称会被编译，但选择得不好。当变量数量增加或者您需要在代码中做一些深层次的更改时，您将不知道或者记得`@a2`被用于什么。您将不得不查找它的上下文，以找到它在您的*Less*文件中的使用，或者更糟糕的是，检查您的HTML元素，以找到哪些CSS规则被应用在它上面，以便找到*Less*上下文。在这种不幸的情况下，您将回到原点。
- en: 'Good examples of names include `@nav-tabs-active-link-hover-border-color` and
    `@dark-color`. These variables are meaningful and descriptive because their names
    try to describe their function or usage rather than their value. This process
    of naming will also be called **semantic naming**. So, in this case, `@dark-color`
    is a better choice than `@red`, and in some cases, you can be more specific by
    using `@brand-color`. `brand`. This could describe some house style color of a
    website, like in the previous case. If the house style color changes from dark
    red to light green, then `@brand-color: lightgreen;` still makes sense. However,
    `@dark-color: lightgreen;` or `@red: lightgreen;` just doesn''t quite say it.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '好的命名示例包括`@nav-tabs-active-link-hover-border-color`和`@dark-color`。这些变量是有意义和描述性的，因为它们的名称试图描述它们的功能或用途，而不是它们的值。这种命名过程也被称为**语义命名**。因此，在这种情况下，`@dark-color`比`@red`更好，而在某些情况下，您可以更具体地使用`@brand-color`。这可以描述网站的一些品牌颜色，就像前面的例子一样。如果品牌颜色从深红色变为浅绿色，那么`@brand-color:
    lightgreen;`仍然是有意义的。然而，`@dark-color: lightgreen;`或`@red: lightgreen;`就不太合适了。'
- en: As you can see, hyphens are used to separate words in variable names. These
    names are called **hyphenated names**. You should use lower case letters. There
    aren't any strict rules to use hyphenated names; the so-called **CamelCase** is
    used and is familiar to many programmers as an acceptable alternative. In CamelCase,
    you will use something like `@navTabsActiveLinkHoverBorderColor` and `@darkColor`.
    Both hyphenated and CamelCase names improve readability.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，变量名中使用连字符来分隔单词。这些名称被称为**连字符名称**。您应该使用小写字母。使用连字符名称并没有严格的规则；所谓的**驼峰命名法**也被使用，并且被许多程序员认为是可接受的替代方式。在驼峰命名法中，您将使用类似`@navTabsActiveLinkHoverBorderColor`和`@darkColor`的命名。无论是连字符名称还是驼峰名称都可以提高可读性。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When writing CSS and HTML code, you are using hyphenated two-word terms and
    lowercase class names, ID's, and font names, among other things. These rules are
    not always strict, and they are not followed by convention. This book follows
    this convention when writing *Less* code, and it therefore makes use of hyphenated
    names.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写CSS和HTML代码时，您会使用连字符连接的双词术语和小写的类名、ID和字体名称，以及其他内容。这些规则并不总是严格的，也不是按照惯例遵循的。本书在编写*Less*代码时遵循这种约定，因此使用了连字符名称。
- en: Whether you prefer CamelCase or hyphenated names doesn't matter greatly. When
    you have chosen either CamelCase or hyphenated names, it is important to be consistent
    and use the same way of naming throughout your *Less* files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您喜欢驼峰命名法还是连字符名称都不是很重要。当您选择了驼峰命名法或连字符名称之后，保持一致并在整个*Less*文件中使用相同的命名方式是很重要的。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you perform calculations, a hyphenated name may cause some trouble. You
    will need some extra spacing to solve this. When you declare `@value` minus one,
    `@value-1` will be read as a single variable instead of `@value -1.`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行计算时，连字符名称可能会引起一些麻烦。您将需要一些额外的空格来解决这个问题。当您声明`@value`减一时，`@value-1`将被读作一个单独的变量，而不是`@value
    -1`。
- en: Using a variable
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变量
- en: If your project grows, it will be impossible to add a variable for every CSS
    property value, so you will have to choose which values should be a variable or
    which should not. There are no strict rules for this process. You will find some
    clear guidance to make these choices in the following sections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目不断增长，将为每个CSS属性值添加一个变量将变得不可能，因此您将不得不选择哪些值应该是变量，哪些不应该是。在这个过程中并没有严格的规则。在接下来的章节中，您将找到一些明确的指导来做出这些选择。
- en: You should first try to find property values that are used more than once in
    your code. Repeated usage is suitable when creating variables. The `@dark-color`
    variable in the example code is a good example of such a property value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该尝试找到在您的代码中多次使用的属性值。在创建变量时，重复使用是合适的。示例代码中的`@dark-color`变量就是这种属性值的一个很好的例子。
- en: Second, you can make variables of properties that are used for customization
    settings. The `@basic-width` variable in the example code is an example of such
    a property.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您可以创建用于自定义设置的属性的变量。示例代码中的`@basic-width`变量就是这种属性的一个例子。
- en: 'Finally, you should consider creating variables for reusable components. Looking
    at our example, you could reuse the header in other projects. To make this possible,
    you should create a new `less/header.less` file and import this to your main file
    with the following line of code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该考虑为可重用的组件创建变量。看看我们的示例，你可以在其他项目中重用页眉。为了实现这一点，你应该创建一个新的`less/header.less`文件，并使用以下代码将其导入到你的主文件中：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Organizing variables
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织变量
- en: To make components reusable, you can create *Less* files for each component
    or function and arrange the variables to suit these files. To demonstrate this,
    split the example code into `less/header.less`, `less/content.less` and `less/footer.less`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使组件可重用，你可以为每个组件或函数创建*Less*文件，并安排变量以适应这些文件。为了演示这一点，将示例代码拆分为`less/header.less`，`less/content.less`和`less/footer.less`。
- en: 'The `less/header.less` file will now contain the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`less/header.less`文件现在将包含以下代码：'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that `@dark-color` has been renamed as `@header-dark-color`. Open `http://localhost/project.html`
    in your browser and the `less/project.less` file in the text editor to see all
    the changes and their effects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@dark-color`已被重命名为`@header-dark-color`。在浏览器中打开`http://localhost/project.html`，并在文本编辑器中打开`less/project.less`文件，以查看所有更改及其影响。
- en: 'Now, include the `less/header.less` file in your `less/project.less` file using
    `@import "header.less";` and create a header section in the `less/variablesproject.less`
    file as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的`less/project.less`文件中使用`@import "header.less";`包含`less/header.less`文件，并在`less/variablesproject.less`文件中创建一个页眉部分，如下所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `@header-dark-color: @dark-color;` statement assigns the `@dark-color;`
    value to `@header-dark-color`. After this, you will do the same for `less/content.less`
    and `less/footer.less`. As you can see, `http://localhost/project.html` still
    looks the same after your changes.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`@header-dark-color: @dark-color;`语句将`@dark-color;`的值赋给`@header-dark-color`。之后，你将对`less/content.less`和`less/footer.less`做同样的操作。正如你所看到的，`http://localhost/project.html`在你的更改后仍然看起来一样。'
- en: 'Now, open `less/variablesproject.less` in your text editor and change the footer
    section to the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的文本编辑器中打开`less/variablesproject.less`文件，并将页脚部分更改为以下代码：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In your browser, you will now see the layout with a green footer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中，你现在将看到带有绿色页脚的布局。
- en: The last declaration wins
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后声明获胜
- en: 'In the first chapter, you read about **CSS cascade**, where the last rule said
    that the value declared last will win if the output of the other rules is equal.
    *Less* uses the same strategy, where the last declaration of a variable will be
    used in all the preceding code. In the following code, you will see that the property
    value is set to `2` in accordance with the last declaration wins rule:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，你已经了解了**CSS层叠**，最后一条规则指出，如果其他规则的输出相等，最后声明的值将获胜。*Less*使用相同的策略，变量的最后声明将在所有前面的代码中使用。在下面的代码中，你将看到属性值设置为`2`，符合最后声明获胜的规则：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In fact, *Less* first reads all of your code. When the value of a variable is
    used, it is only the last-assigned or last-read value that is actually used. The
    fact that the last declaration wins will only affect the declaration defined in
    the same scope.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，*Less*首先读取你的所有代码。当变量的值被使用时，实际上只使用最后分配或最后读取的值。最后声明获胜的事实只会影响在相同作用域中定义的声明。
- en: In most programming languages, the scope is defined by a part of the code that
    the compiler can run independent of the other code. Functions and classes can
    have their own scope. In *Less*, mixins have their own scope. Mixins will be discussed
    in more detail later on in this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，作用域由编译器可以独立运行的代码部分定义。函数和类可以有自己的作用域。在*Less*中，mixin有自己的作用域。混合将在本章后面更详细地讨论。
- en: 'The following code shows you that the property value is set to `3` in accordance
    with the value declared inside the scope of the mixin:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码向你展示了，根据在mixin作用域内声明的值，属性值设置为`3`：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code means you can't change variables during the compilation.
    This makes these variables theoretical **constants**. Compare this with a definition
    of the mathematical value of pi in your code, which is always the same. You will
    define `PI` only once, where `PI = 3.14` will be in your code and will remain
    constant when your code is run. For this reason, variables should be declared
    only once.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码意味着你不能在编译过程中更改变量。这使得这些变量成为理论上的**常量**。将这与你代码中数学值pi的定义进行比较，它始终是相同的。你只需定义`PI`一次，`PI
    = 3.14`将在你的代码中，并且在运行代码时保持不变。因此，变量应该只声明一次。
- en: '**Redeclaration** of variables and the rule that the last declaration wins
    will be used in the customization of many *Less* projects and code.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的**重声明**和最后声明获胜的规则将在许多*Less*项目和代码的定制中使用。
- en: 'To demonstrate redeclaration, create a new `less/customized.less` file and
    write the following code into it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示重声明，创建一个新的`less/customized.less`文件，并将以下代码写入其中：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Reference the `customized.less` file in the `customized.html` file as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`customized.html`文件中引用`customized.less`文件，如下所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now load the `customized.html` file in your browser. As you see, you have created
    a customized version of your layout with only three lines of code!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中加载`customized.html`文件。正如你所看到的，你只用了三行代码就创建了一个定制版本的布局！
- en: Variable declaration is not static
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明不是静态的
- en: 'Although variables act like constants, their **declaration** is not necessarily
    unchangeable or static. First, you can assign a value of one variable to another,
    as shown in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管变量的行为类似于常量，但它们的**声明**不一定是不可改变的或静态的。首先，你可以将一个变量的值赋给另一个变量，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The value of `@var1` is now `3` and not `1`. Please understand that you don't
    need to create some kind of **reference** as the rule that the last declaration
    wins is applied here. The `@var1` variable will get the value of the last-declared
    `@var2` variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`@var1`的值现在是`3`而不是`1`。请理解，你不需要创建某种**引用**，因为最后声明获胜的规则在这里适用。`@var1`变量将获得最后声明的`@var2`变量的值。'
- en: 'In the example code, you will also find the `@light-color: lighten(@dark-color,40%);`
    declaration. The `lighten()` function is a so-called built-in function of *Less*.
    [Chapter 3](ch03.html "Chapter 3. Nested Rules, Operations, and Built-in Functions"),
    *Nested Rules, Operations, and Built-in Functions*, will cover the built-in functions.
    The use of the `lighten()` function sets `@light-color` to a calculated color
    value based on `@dark-color`. You should also pay attention to the last declaration
    of `@dark-color`, as this is used for color calculation.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '在示例代码中，您还会发现`@light-color: lighten(@dark-color,40%);`的声明。`lighten()`函数是*Less*的所谓内置函数。[第3章](ch03.html
    "第3章。嵌套规则、操作和内置函数")，*嵌套规则、操作和内置函数*，将介绍内置函数。使用`lighten()`函数将`@light-color`设置为基于`@dark-color`计算的颜色值。您还应该注意`@dark-color`的最后一个声明，因为这用于颜色计算。'
- en: Dynamic declaration of variable values gives flexibility, but keep in mind that
    you should only declare a value once and you can't change it after the declaration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 动态声明变量值可以提供灵活性，但请记住，您只能在声明后声明一次值，并且不能在声明后更改它。
- en: Lazy loading
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载
- en: Before you switch from variables to mixins, you should first know about **lazy
    loading**. In computer programming, this means to defer the initialization of
    an object until the point at which it is needed. Lazy loading is the opposite
    of eager loading. For *Less*, this means the variables are lazy loaded and do
    not have to be declared before they are actually used.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在从变量切换到混合器之前，您应该首先了解**懒加载**。在计算机编程中，这意味着推迟对象的初始化，直到需要它为止。懒加载是急切加载的相反。对于*Less*来说，这意味着变量是懒加载的，不必在实际使用之前声明。
- en: 'It is all very well trying to understand the theoretical aspects, but now,
    it is time to understand how they work in practice through the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 试图理解理论方面固然很好，但现在是时候通过以下示例了解它们在实践中是如何工作的：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code gets compiled into the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码编译为以下代码：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Escaping values
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义值
- en: '*Less* is an extension of CSS. This means that *Less* gives an error when it
    comes across invalid CSS or evaluates a valid CSS during compilation. Some browsers
    define properties with an invalid CSS. Well-known examples will include something
    such as `property: ms:somefunction()`. Some of these rules can be replaced by
    vendor-specific rules. It is important to note that invalid property values won''t
    get compiled in *Less*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Less*是CSS的扩展。这意味着*Less*在遇到无效的CSS或在编译期间评估有效的CSS时会出错。一些浏览器使用无效的CSS定义属性。众所周知的例子包括`property:
    ms:somefunction()`之类的东西。其中一些规则可以被供应商特定的规则替换。重要的是要注意，*Less*中无效的属性值不会被编译。'
- en: A new function, `calc()`, in CSS3 is a native CSS way of doing simple math as
    a replacement for a value of any length.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3中的新函数`calc()`是CSS中进行简单数学运算的一种本地CSS方式，可以替代任意长度的值。
- en: In both cases, *Less* won't give us the right value when we compile or import.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，*Less*在编译或导入时都无法给我们正确的值。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code gets compiled into the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码编译为以下代码：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From the preceding code, `@aside-width: 80px;` is the declaration of a variable
    with the name `aside-width`. This variable gets a value of 80 pixels. More information
    on variables will be covered in the following sections. However, more importantly,
    now the preceding result is wrong (or at least, not as expected) because the `calc()`
    function should be evaluated during the rendering time. During the render time,
    the `calc()` function has the ability to mix units, such as percentages and pixels.
    In the preceding code, `.content` is assigned a width of `100%` of the available
    space (in other words, all of the available space) minus `80px` (pixels).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '从上述代码中，`@aside-width: 80px;`是声明一个名为`aside-width`的变量。这个变量得到了80像素的值。关于变量的更多信息将在接下来的章节中介绍。然而，更重要的是，现在上述结果是错误的（或者至少不如预期），因为`calc()`函数应该在渲染时进行评估。在渲染时，`calc()`函数有能力混合单位，比如百分比和像素。在上述代码中，`.content`被分配了`100%`的可用空间的宽度（换句话说，所有可用空间）减去`80px`（像素）。'
- en: '**Escaping** the values will prevent these problems. In *Less*, you can escape
    values by placing them between quotes (`""`) preceded by a tilde (`~)`. So, in
    this example, you should write `width: ~"calc(100% - @{aside-width})"`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**转义**这些值将防止这些问题。在*Less*中，您可以通过将值放在用波浪号(`~)前面的引号(`""`)之间来转义值。因此，在这个例子中，您应该写`width:
    ~"calc(100% - @{aside-width})"`。'
- en: Please note that the accolades are placed in aside-width's variable name, which
    is called **string interpolation**. In the escaped values, anything between quotes
    is used as it is, with almost no changes. The only exceptions here are the string
    **interpolated variables**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大括号放在`aside-width`的变量名中，这被称为**字符串插值**。在转义的值中，任何在引号之间的内容都会被原样使用，几乎没有变化。唯一的例外是**插值变量**。
- en: Strings are sequences of characters. In *Less* and CSS, values between quotes
    are strings. Without escaping, *Less* compiles its strings into CSS strings.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字符序列。在*Less*和CSS中，引号之间的值是字符串。没有转义，*Less*会将其字符串编译成CSS字符串。
- en: 'For instance, `width: "calc(100 – 80px)"` doesn''t make sense in CSS and neither
    does `width: calc(100% - @aside-width)` because `@aside-width` has no meaning.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`width: "calc(100 – 80px)"`在CSS中没有意义，`width: calc(100% - @aside-width)`也是如此，因为`@aside-width`没有意义。'
- en: 'So, with escaping and string interpolation, you can start with the following
    code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过转义和字符串插值，您可以从以下代码片段开始：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will compile into the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将编译为以下代码：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In the specific case of using the `calc()` function, the *Less* compiler has
    a **strict-math** option (used since Version 1.4). This is used with `–strict-math=on`
    in the command line or `strictMath: true` when using JavaScript. When the strict-math
    option is turned on, the width of `calc(100% - @aside-width);` will get compiled
    into `width: calc(100% - 80px);`. Notice that there have been many changes to
    this **strict-math** option during the development of versions 1.6, 1.7, and 2.0.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用`calc()`函数的特定情况下，*Less*编译器具有**strict-math**选项（自1.4版本以来使用）。这与命令行中的`–strict-math=on`或在JavaScript中使用`strictMath:
    true`一起使用。当打开strict-math选项时，`calc(100% - @aside-width);`的宽度将被编译为`width: calc(100%
    - 80px);`。请注意，在1.6、1.7和2.0版本的开发过程中，对这个**strict-math**选项进行了许多更改。'
- en: Mixins
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合
- en: 'Mixins play an important role in *Less*. You saw mixins in the first chapter
    when the rounded-corners example was discussed. Mixins take their naming from
    object-oriented programming. They look like functions in functional programming
    but in fact act like C macros. Mixins in *Less* allow you to embed all the properties
    of a class into another class by simply including the class name as one of its
    properties, as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 混合在*Less*中扮演着重要角色。在第一章中讨论圆角示例时，您已经看到了混合。混合从面向对象编程中获取其命名。它们看起来像函数式编程中的函数，但实际上像C宏一样起作用。*Less*中的混合允许您通过简单地将类名包含为其属性之一，将一个类的所有属性嵌入到另一个类中，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code will get compiled into the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将被编译为以下代码：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the final CSS code used on the website, every `<p>` paragraph tag will be
    styled with the properties defined in the `mixin()` function. The advantage will
    be that you can apply the same mixin on different classes. As seen in the rounded-corners
    example, you only have to declare the properties once.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站上使用的最终CSS代码中，每个`<p>`段落标记都将使用`mixin()`函数中定义的属性进行样式设置。优点是您可以在不同的类上应用相同的混合。正如在圆角示例中所看到的，您只需要声明一次属性。
- en: Try opening `less/mixins.less` from the available downloadable files of this
    chapter. In the examples of this book, all mixins are saved to a single file.
    In this file, you can arrange your mixins based on their functions. Grouping them
    in a single file prevents us from breaking the code when removing or replacing
    other functional *Less* files. Your project contains an example in `sidebar.less`
    and `content.less`, where both files make use of the border-radius mixin. If we
    now replace `sidebar.less`, you won't break `content.less`. Of course, you also
    don't want to have the same kind of mixins twice in your code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试打开本章可下载文件中的`less/mixins.less`。在本书的示例中，所有混合都保存在一个文件中。在这个文件中，您可以根据它们的功能来安排您的混合。将它们分组到一个文件中可以防止我们在删除或替换其他功能*Less*文件时破坏代码。您的项目中包含了`sidebar.less`和`content.less`的示例，这两个文件都使用了border-radius混合。如果我们现在替换`sidebar.less`，您不会破坏`content.less`。当然，您也不希望在代码中两次使用相同类型的混合。
- en: The box-sizing mixin in `less/boxsizing.less` will be handled as a specific
    case. The box-sizing mixin influences all elements, and you want to be able to
    replace the box-sizing model in its entirety.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`less/boxsizing.less`中的box-sizing混合将被视为一个特例。box-sizing混合影响所有元素，您希望能够完全替换box-sizing模型。'
- en: The `less/mixins.less` file contains four mixins, which will be discussed in
    the following sections. The box-shadow and clearfix mixins also have complex structures
    such as **nesting**, but these mixins will be explained in further detail in the
    next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`less/mixins.less`文件包含四个混合，将在以下部分中讨论。box-shadow和clearfix混合也具有**嵌套**等复杂结构，但这些混合将在下一章中进一步详细解释。'
- en: Basic mixins
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本混合
- en: You have seen the rounded-corners mixin already. A basic mixin looks like a
    class definition in CSS. Mixins are called inside classes and give these classes
    their properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了圆角混合。基本混合看起来像CSS中的类定义。混合在类内部调用并赋予这些类其属性。
- en: In the example code in the `less/mixins.less` file, you will find the `.center-content`
    mixin which sets the value of the `margin` property to `0 auto`. This mixin is
    used to center align the header, content wrapper, and the footer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`less/mixins.less`文件中的示例代码中，您将找到`.center-content`混合，它将`margin`属性的值设置为`0 auto`。这个混合用于居中对齐标题、内容包装器和页脚。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that these center-content mixins are not the one and only solution. A general
    wrapper to center align the header, the content wrapper, and the footer at once
    will also work for this example layout. The name of this mixin can also be discussed.
    When you decide not to center the content anymore, the name of this mixin will
    not make any sense.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些居中内容混合并不是唯一的解决方案。一个通用的包装器可以一次性居中对齐标题、内容包装器和页脚，也适用于这个示例布局。这个混合的名称也可以讨论。当您决定不再居中内容时，这个混合的名称将不再有任何意义。
- en: 'Remove the `margin: 0 auto;` property, which in fact centers the content from
    the mixin. You should then reload `index.html` in your browser to see the effect.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '删除`margin: 0 auto;`属性，实际上是从混合中使内容居中。然后应该重新加载浏览器中的`index.html`以查看效果。'
- en: Parametric mixins
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化混合
- en: 'As mentioned earlier, mixins act as functions in functional programming, and
    so, as functions, they can be parameterized. A parameter is a value used in combination
    with mixins, with the parameter''s name used as a reference to its value inside
    the mixin. The following code shows you an example of the usage of a parametric
    mixin:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，混合在函数式编程中扮演函数的角色，因此，作为函数，它们可以被参数化。参数是与混合结合使用的值，参数的名称在混合内部用作其值的引用。以下代码向您展示了一个使用参数化混合的示例：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code gets compiled to the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码被编译为以下代码：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding example shows how parameterization makes mixins very powerful.
    They can be used and reused to set properties depending on input values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例显示了参数化如何使混合非常强大。它们可以根据输入值设置属性。
- en: Default values
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认值
- en: 'The parameters have an optional default value, which can be defined with `.mixins(@parameter:defaultvalue);`.
    To see how this works, you should consider the border-radius mixin in the `less/mixins.less`
    file, as seen in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 参数具有可选的默认值，可以使用`.mixins(@parameter:defaultvalue);`来定义。要了解这是如何工作的，您应该考虑`less/mixins.less`文件中的`border-radius`混合，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the default value here is `10px`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的默认值是`10px`。
- en: Naming and calling
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名和调用
- en: In this book, mixins have meaningful and descriptive names, and just like variable
    names, these names are hyphenated. Using meaningful and descriptive names for
    your mixins makes your code more readable for others and easier to maintain. Parameters
    and variables both start with an `@` sign. The context should make it clear if
    it is a variable or mixin parameter that is being talked about.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，混合物具有有意义和描述性的名称，就像变量名称一样，这些名称是用连字符分隔的。为混合物使用有意义和描述性的名称使您的代码对其他人更易读，更易于维护。参数和变量都以`@`符号开头。上下文应该清楚地表明正在讨论的是变量还是混合参数。
- en: 'To have a better understanding, consider the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，请考虑以下代码：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code can be compiled into the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译成以下代码：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that `@defaulvalue-parameter1` is a variable here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的`@defaulvalue-parameter1`是一个变量。
- en: 'The following code also illustrates the scope of a mixin:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码还说明了混合的范围：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code can be compiled into the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译成以下代码：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, the last declaration of `@parameter1` is outside the scope of the mixin,
    so the property is still set to `10`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@parameter1`的最后一个声明在混合的范围之外，所以属性仍然设置为`10`。
- en: Multiple parameters
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个参数
- en: Multiple parameters for mixins can be separated by a comma or semicolon. Functional
    programmers often use a comma as a **separator.** In *Less*, a semicolon is preferred.
    A comma actually has an ambiguous role here, as they are not only used to separate
    parameters but also to separate list items in a **csv list**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 混合物的多个参数可以用逗号或分号分隔。函数式程序员通常使用逗号作为**分隔符**。在*Less*中，分号更受青睐。逗号在这里实际上有一个模棱两可的作用，因为它们不仅用于分隔参数，还用于分隔**csv列表**中的列表项。
- en: 'The `.mixin(a,b,c,d)` call calls the mixin with four parameters and similarly
    the `.mixin(a;b;c;d)` call does the same. Now, consider the case where you call
    the mixin with the`.mixin(a,b,c;d)` call. Only two parameters are used here, and
    the first parameter is a list of three items. If at least one semicolon is found
    in the parameter list, then the only separator considered will be the semicolon.
    The following code shows you the effect of adding an extra semicolon to the parameter
    list:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`.mixin(a,b,c,d)`调用使用四个参数调用混合物，同样`.mixin(a;b;c;d)`调用也是一样。现在，考虑一下您使用`.mixin(a,b,c;d)`调用混合物的情况。这里只使用了两个参数，第一个参数是一个包含三个项目的列表。如果参数列表中至少有一个分号，则唯一的分隔符将是分号。下面的代码向您展示了在参数列表中添加额外分号的效果：'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code can be compiled into the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译成以下代码：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Without this extra semicolon, you call a mixin with four parameters. In this
    case, the compiler throws an error: **RuntimeError: No matching definition was
    found for .mixin(a, b, c, d)**. What you actually need is a mixin containing `.mixin(@a,@b,@c,@d)`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '没有这个额外的分号，你调用一个带有四个参数的混合物。在这种情况下，编译器会抛出一个错误：**RuntimeError: No matching definition
    was found for .mixin(a, b, c, d)**。实际上，你需要的是一个包含`.mixin(@a,@b,@c,@d)`的混合物。'
- en: In the preceding example, it has been made clear that mixins with the same name
    are allowed in *Less*. When finding different mixins with the same name, the compiler
    uses the mixins with the right number of parameters only or throws an error when
    no matching mixin is found. This form of parametric matching can be compared with
    **method overloading**, found in various programming languages.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，已经明确表示*Less*中允许具有相同名称的混合物。当找到具有相同名称的不同混合物时，编译器仅使用具有正确数量参数的混合物，或者在找不到匹配的混合物时抛出错误。这种形式的参数匹配可以与各种编程语言中的**方法重载**进行比较。
- en: 'If a mixin call matches more than one mixin, as shown in the following code,
    then all the matching mixins are used by the compiler:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个混合调用匹配多个混合，如下面的代码所示，那么编译器将使用所有匹配的混合：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code gets compiled into the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码编译成以下代码：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: More complex mixins for linear gradient backgrounds
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更复杂的线性渐变背景混合
- en: You now have enough theoretical knowledge to build more complex mixins. In this
    example, you will add directive **background gradients** of three colors to the
    footer columns of our layout.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有足够的理论知识来构建更复杂的混合物。在这个例子中，您将为我们布局的页脚列添加三种颜色的**背景渐变**指令。
- en: 'The end result should look like the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该如下截图所示：
- en: '![More complex mixins for linear gradient backgrounds](img/1465OS-02-02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![更复杂的线性渐变背景混合](img/1465OS-02-02.jpg)'
- en: Linear gradient backgrounds built with *Less*
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Less*构建的线性渐变背景
- en: These gradient backgrounds have been chosen because of their complexity and
    well-documented changes over time. The final result will be a complex mixin, which
    is definitely not perfect, but improves the result significantly. You can be sure
    that you will have to change your gradient mixin from time to time because of
    the drop in support for old browsers, new browsers, changing specifications, and
    new insights. Refer to [https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_gradients](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_gradients)
    for some more examples.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些渐变背景被选择是因为它们的复杂性和随时间变化的充分记录。最终结果将是一个复杂的混合，肯定不完美，但可以显著改善结果。您可以肯定，您将不得不不时更改您的渐变混合，因为旧浏览器的支持下降，新浏览器，规范的变化和新的见解。请参考[https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_gradients](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_gradients)获取更多示例。
- en: You can't prevent these necessary changes, but you can minimize the time spent
    on keeping your mixins up to date. *Less* guarantees that all of your background
    gradients are based on the same mixin defined in a single place.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法阻止这些必要的更改，但你可以最小化花在保持你的混合器最新的时间。*Less*保证了你所有的背景渐变都是基于同一个混合器定义在一个地方。
- en: At a basic level, background gradients in CSS are defined as images. For this
    reason, they are applied on the **background-image property**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，CSS中的背景渐变被定义为图像。因此，它们被应用在**background-image属性**上。
- en: In this book, gradients are set on the `background-image` property. Other examples
    (elsewhere and perhaps in other books) will set them on the `background` property.
    There is no difference in their definitions. CSS defines different properties
    for backgrounds such as `background-image`, `background-color`, `background-size`,and
    `background-position`. The `background` property is the shorthand for all of them
    together. When you define the first value of the `background` property as an image,
    or gradient in this case, all the other property values are set to their default
    value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，渐变是在`background-image`属性上设置的。其他示例（其他地方和其他书中）可能会在`background`属性上设置它们。它们的定义没有区别。CSS为背景定义了不同的属性，如`background-image`、`background-color`、`background-size`和`background-position`。`background`属性是它们所有的缩写。当你将`background`属性的第一个值定义为图像，或者在这种情况下是渐变时，所有其他属性值都设置为它们的默认值。
- en: 'You start your mixin by making a list of the following **requirements**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始你的混合器，列出以下**要求**：
- en: You want a parameter to set the direction of your gradient, where you will use
    degrees
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个参数来设置你的渐变的方向，你将使用角度。
- en: Your gradient will consist of three colors
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的渐变将由三种颜色组成
- en: After this, you define a list of browsers and the browser version you have to
    support
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，你定义一个浏览器列表和你需要支持的浏览器版本
- en: 'Now, you can define the first lines of your mixin as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以定义你的混合器的前几行如下：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![More complex mixins for linear gradient backgrounds](img/1465OS-02-04.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![更复杂的线性渐变背景混合](img/1465OS-02-04.jpg)'
- en: 'One of the ways to illustrate how the gradient line of 45 degrees works. This
    was taken from: [http://dev.w3.org/csswg/css-images-3/](http://dev.w3.org/csswg/css-images-3/),
    Copyright 2013 W3C, 11 September 2013'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 展示45度渐变线如何工作的一种方法。这是从[http://dev.w3.org/csswg/css-images-3/](http://dev.w3.org/csswg/css-images-3/)中获取的，版权所有2013
    W3C，2013年9月11日
- en: 'The background mixins have five parameters, which are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 背景混合器有五个参数，如下：
- en: The first parameter describes the direction in degrees. The number of degrees
    gives the angle between the vertical and the gradient direction. The description
    of the direction starts at the bottom. At the bottom, the angle is 0 degrees and
    describes a gradient from bottom to top. Then the angle goes clockwise to 90 degrees
    point that describes a gradient from left to right, and so on.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数描述了以度为单位的方向。度数的数量给出了垂直和渐变方向之间的角度。方向的描述从底部开始。在底部，角度为0度，描述了从底部到顶部的渐变。然后角度顺时针转到90度点，描述了从左到右的渐变，依此类推。
- en: The next three parameters are the three colors of your gradient, which are the
    default values set for it.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的三个参数是你的渐变的三种颜色，这是为它设置的默认值。
- en: The fifth and last parameter defines where the middle color has its real value.
    The percentage here is a percentage of the width of the element that the gradient
    is applied on. The first and last color has 0 and 100 by default.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个也是最后一个参数定义了中间颜色的真实值。这里的百分比是应用渐变的元素宽度的百分比。第一个和最后一个颜色默认为0和100。
- en: 'Modern browsers, such as IE version 11, Firefox version 16+, Opera version
    12.10+, Safari version 7+, and Chrome version 26+, support these background-image
    properties. For older browsers, vendor-specific rules have to be added. The first
    problem here is that vendor-specific rules use a different way to define the angle.
    To compensate for this, you can use a correction of 90 degrees using the following
    code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器，如IE 11版本，Firefox 16+版本，Opera 12.10+版本，Safari 7+版本和Chrome 26+版本，支持这些背景图像属性。对于较旧的浏览器，必须添加特定于供应商的规则。这里的第一个问题是特定于供应商的规则使用了不同的方式来定义角度。为了补偿这一点，你可以使用以下代码对90度进行校正：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `-ms background-image` property is used by IE10, as an older version of
    IE is unable to support a background image. Alternatively, you can add a filter
    to support a two-color gradient. There is no support for using this filter in
    combination with a fallback image, so you will have to choose webkit-based browsers,
    such as Chrome and Safari, that use `-webkit-linear-gradient`; however, if you
    have to support older versions of these browsers, you will have to use `-webkit-gradient`.
    Note that `-webkit-gradient` has an unusual syntax. For example, your final mixin
    could look like the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`-ms background-image`属性被IE10使用，因为较旧版本的IE无法支持背景图像。或者，你可以添加一个滤镜来支持双色渐变。在使用这个滤镜时，不支持与回退图像的组合，所以你必须选择基于webkit的浏览器，比如Chrome和Safari，它们使用`-webkit-linear-gradient`；然而，如果你必须支持这些浏览器的旧版本，你将不得不使用`-webkit-gradient`。请注意，`-webkit-gradient`有一个不寻常的语法。例如，你的最终混合器可能看起来像以下代码：'
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code shows that even when using *Less*, our code can still be
    complex. Unless this complexity can support different browsers, you can see the
    advantage of using *Less*, which allows you to handle this code only once and
    in a single place.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码表明，即使使用*Less*，我们的代码仍然可能很复杂。除非这种复杂性可以支持不同的浏览器，你可以看到使用*Less*的优势，它允许你只在一个地方处理这段代码。
- en: The code in the preceding example can be found in `directivebackgrounds.html`
    and `less/directivebackgrounds.less`. If you wonder why you should use a CSS background
    gradient at all after all of this, then please take a look at [http://lea.verou.me/css3patterns/](http://lea.verou.me/css3patterns/)
    and see what is possible.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的代码可以在`directivebackgrounds.html`和`less/directivebackgrounds.less`中找到。如果你想知道在经历了这一切之后为什么还要使用CSS背景渐变，那么请看一下[http://lea.verou.me/css3patterns/](http://lea.verou.me/css3patterns/)，看看有什么可能性。
- en: Special variables – @arguments and @rest
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊变量-@arguments和@rest
- en: '*Less* defines two special variables. The `@arguments` variable is the first
    one and contains a list of all the arguments that are passed. The `@arguments`
    variable exists inside mixins. In *Less*, lists are defined separately with spaces,
    so you can use `@arguments` for properties that can be set by a list of values.
    Properties such as `margin` and `padding` accept lists in their shorthand notation,
    as shown in the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*Less*定义了两个特殊变量。`@arguments`变量是第一个，包含传递的所有参数的列表。`@arguments`变量存在于mixin内部。在*Less*中，列表是用空格分隔的，所以你可以用`@arguments`来设置可以由值列表设置的属性。像`margin`和`padding`这样的属性在它们的简写表示法中接受列表，如下面的代码所示：'
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This code can be compiled into the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译成以下代码：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The second special variable is `@rest`. `@rest...`, which binds all odd arguments
    after the preceding arguments from the caller to a list. By doing this, `@rest...`
    gives the opportunity to call a mixin with an endless argument list. Please note
    that the three ending dots are part of the syntax. The following code shows how
    `@rest...` binds all the odd parameters after the `@a` variable to the `property2`
    property:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特殊变量是`@rest`。`@rest...`将调用者的前面参数后的所有奇数参数绑定到一个列表中。通过这样做，`@rest...`可以让mixin使用无限的参数列表。请注意，这三个结束点是语法的一部分。下面的代码显示了`@rest...`将`@a`变量后的所有奇数参数绑定到`property2`属性：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This code will get compiled into the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将被编译成以下代码：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should also consider using `@rest...` as a csv list. To do this, you can
    rewrite the `.backgroundgradient` mixin from `less/mixinswithdirectivebackgrounds.less`
    to the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑使用`@rest...`作为csv列表。为此，你可以将`less/mixinswithdirectivebackgrounds.less`中的`.backgroundgradient`
    mixin重写为以下代码：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, the mixin will accept an endless list of colors, and you can use it with
    the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个mixin将接受一个无限的颜色列表，你可以用以下代码来使用它：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following figure shows the result of the code using this background mixin:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了使用这个背景mixin的代码的结果：
- en: '![Special variables – @arguments and @rest](img/1465OS-02-03.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![特殊变量-@arguments和@rest](img/1465OS-02-03.jpg)'
- en: Return values
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: 'If you are used to functional programming or even know a mathematical function,
    you expect mixins to have a **return value**. This simply means putting `x` into
    it and getting `y` back. Mixins don''t have a return value, but you can mimic
    this behavior using their scope. A variable defined in a mixin will be copied
    to the **scope of the caller**, unless the variable has been defined already in
    the caller''s scope. The following example will make this clear:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于函数式编程，甚至了解数学函数，你会期望mixin有一个**返回值**。这只是意味着把`x`放进去，得到`y`。Mixin没有返回值，但你可以使用它们的作用域模仿这种行为。在mixin中定义的变量将被复制到**调用者的作用域**，除非变量已经在调用者的作用域中定义。下面的例子将说明这一点：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This code will get compiled into the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将被编译成以下代码：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you look at the preceding example, you can compare `property2: @par2;` with
    a function such as `property2 = returnmixin();`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你看前面的例子，你可以将`property2: @par2;`与一个函数比较，比如`property2 = returnmixin();`。'
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using the scope to mimic a return value can also be applied on mixins. A mixin
    defined in another mixin can be used in the scope of the caller. However, these
    are not protected by the scope like variables are! This process is called **unlocking**.
    For now, unlocking is outside the scope of this book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作用域来模仿返回值也可以应用在mixin上。在另一个mixin中定义的mixin可以在调用者的作用域中使用。然而，这些不像变量那样受作用域的保护！这个过程被称为**解锁**。目前，解锁不在本书的范围之内。
- en: Changing the behavior of a mixin
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变mixin的行为
- en: To make mixins more flexible, it will be useful to influence their output based
    on their input parameters. *Less* offers different mechanisms in order to do this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使mixin更加灵活，影响它们的输出基于它们的输入参数将是有用的。*Less*提供了不同的机制来实现这一点。
- en: Switches
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开关
- en: 'Imagine that you have a mixin, `color();` which should set the color property
    to white or black depending on the context. Set the context with a `@context:
    light;` declaration and declare two mixins with the same name, as shown in the
    following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '假设你有一个mixin，`color();`应该根据上下文将颜色属性设置为白色或黑色。使用`@context: light;`声明设置上下文，并声明两个具有相同名称的mixin，如下面的代码所示：'
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can use the `.color(@context);` mixinin your code which sets the `color`
    property of your class to white or black, depending on the value declared to `@context`.
    This may not seem useful now, but it will be useful within your growing project.
    Take a look at the Bootflat project at [http://www.flathemes.com/](http://www.flathemes.com/).
    This project provides color variants of Twitter's Bootstrap. **Twitter's Bootstrap**
    is a **CSS framework** based on *Less*. Bootflat defines two styles, where one
    style is based on the improved style of Bootstrap 3.0 and the other style is a
    Square UI style with the rounded corner removed. This project uses one switch
    to compile two different styles.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在你的代码中使用`.color(@context);` mixin，它将把你的类的`color`属性设置为白色或黑色，取决于声明给`@context`的值。现在这可能看起来没什么用，但在你不断发展的项目中会很有用。看一下Bootflat项目[http://www.flathemes.com/](http://www.flathemes.com/)。这个项目提供了Twitter的Bootstrap的颜色变体。**Twitter的Bootstrap**是基于*Less*的**CSS框架**。Bootflat定义了两种样式，其中一种样式基于改进的Bootstrap
    3.0样式，另一种样式是一个去掉了圆角的Square UI样式。这个项目使用一个开关来编译两种不同的样式。
- en: Argument matching
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数匹配
- en: '*Less* allows different mixins with the same name. If there are such mixins,
    every mixin which matches the caller''s parameter list is used. Refer to the following
    color mixins:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*Less*允许具有相同名称的不同mixin。如果有这样的mixin，那么与调用者的参数列表匹配的每个mixin都将被使用。参考以下颜色mixin：'
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With the color mixins defined in the preceding code, `.color(white)` compiles
    into `color: white;` and `.color(white,black)` will give you `color: gray;`. Note
    that the `.color(white);` call doesn''t match the `.color(@color1,@color2)` mixin,
    which needs two arguments, and so the compiler did not use it.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中定义的颜色混合，`.color(white)`编译成`color: white;`，而`.color(white,black)`将给出`color:
    gray;`。请注意，`.color(white);`调用不匹配`.color(@color1,@color2)`混合，因为它需要两个参数，所以编译器没有使用它。'
- en: Guarded mixins
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 守卫混合
- en: 'Mixins of the same name with the same number of arguments are also possible
    in *Less*. All the matches are used in this case, as shown in the following example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*Less*中也可以有相同名称和相同参数数量的混合。在这种情况下，所有匹配项都会被使用，如下例所示：'
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This code will be compiled into the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将被编译成以下代码：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please also note that *Less* converts the named color `white` to `#ffffff;`
    here.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意*Less*将命名颜色`white`转换为`#ffffff;`。
- en: Two declarations of `color` don't make sense in this case. *Less* doesn't filter
    out double declarations unless they are used in the exact same way.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个`color`声明是没有意义的。*Less*不会过滤掉重复声明，除非它们以完全相同的方式使用。
- en: '**Guards** can be used to prevent trouble with double-defined mixins. A guard
    is defined with a keyword when it is followed by a condition. When the condition
    is true, a mixin is used. The following example makes things clear:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**守卫**可以用来防止重复定义的混合带来的麻烦。守卫是在关键字后面跟着一个条件定义的。当条件为真时，使用混合。以下示例清楚地说明了这一点：'
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This code will be compiled to the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将被编译成以下代码：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Guards can be used as an *if* statement in programming. The comparison operators
    such as `>`, `>=`, `=`, `=<`, and `<` can be used. One or more conditions can
    be combined in the same way when separated with commas, which evaluates as true
    if one of them is true.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫可以像编程中的*if*语句一样使用。比较运算符如`>`、`>=`、`=`, `=<`和`<`可以使用。一个或多个条件可以用逗号分隔的方式组合在一起，如果其中一个为真，则为真。
- en: The keyword `and` can be used to evaluate as true only when both conditions
    are true, for instance, `when @a>1` `and` `@<5`. And finally, a condition can
    be negated with the keyword `not`, for instance, `when (not a = red)`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`and`可以用来在两个条件都为真时评估为真，例如，`when @a>1` `and` `@<5`。最后，条件可以用关键字`not`否定，例如，`when
    (not a = red)`。
- en: Tip
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have used CSS media queries earlier, then you must realize that guards
    act in the very same way that a media query does in CSS.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过CSS媒体查询，那么您一定会意识到守卫的作用方式与CSS中的媒体查询相同。
- en: 'Finally, guard conditions can also contain built-in functions. These functions
    will be discussed in the next chapter and act on all defined variables when they
    are not part of the argument list. The built-in functions of the guard conditions
    can be seen in the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，守卫条件也可以包含内置函数。这些函数将在下一章中讨论，并在它们不是参数列表的一部分时作用于所有定义的变量。守卫条件的内置函数可以在以下代码中看到：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This code can be compiled into the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译成以下代码：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the case of `@style: dark;` or `mixin(1);`, there was no match.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '在`@style: dark;`或`mixin(1);`的情况下，没有匹配项。'
- en: Using guards and argument matching to construct loops
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用守卫和参数匹配来构建循环
- en: 'When *Less* doesn''t find a **matching mixin**, it goes to the next evaluation
    and doesn''t break. This can be used in combination with guards and argument matching
    to construct loops. To show this, imagine 10 **classes**, each containing a numbered
    background image. The `.class1` class has the `background-image` property value
    set to `background-1.png`, the `.class2` class has set the value of the `background-image`
    property to `background-2.png`, and so on, as seen in the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当*Less*找不到**匹配的混合**时，它会继续到下一个评估并不会中断。这可以与守卫和参数匹配结合使用来构建循环。举个例子，想象有10个**类**，每个类都包含一个编号的背景图片。`.class1`类的`background-image`属性值设置为`background-1.png`，`.class2`类将`background-image`属性的值设置为`background-2.png`，依此类推，如下代码所示：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This code can be compiled into the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译成以下代码：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The last mixin perhaps looks complex when you see it first, but if you try to
    evaluate the mixin yourself, you will see that it actually contains a lot of stuff
    you have learned before.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次看到最后一个混合时，它可能看起来很复杂，但如果您尝试自己评估混合，您会发现它实际上包含了您之前学到的很多东西。
- en: In the preceding code, the `setbackground` mixin calls itself. Programmers will
    call this a **recursion**. What happens here?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`setbackground`混合调用了自身。程序员会称这为**递归**。这里发生了什么？
- en: The `.setbackground(10);` call matches the `.setbackground(@number)` mixin when
    `@number>0`, so please make use of this. The first evaluation of `.setbackground(
    @number - 1 );` also matches the mixin. This means that the compiler runs the
    mixin again. This will repeat until `@number -1` is `0`; no matches can be found
    anymore. Now the compiler will read ahead of where it stopped in order to use
    the mixin.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`.setbackground(10);`调用匹配了`.setbackground(@number)`混合，当`@number>0`时，请利用这一点。`.setbackground(
    @number - 1 );`的第一次评估也匹配了混合。这意味着编译器再次运行混合。这将重复直到`@number -1`为`0`；再也找不到匹配项。现在编译器将读取停止位置之后的内容，以使用混合。'
- en: 'The last stop was at `@number = 1`, so it evaluates the `.class@{number} {
    background-image: ~"url(backgroundimage-@{number}.png)"; }` declaration for the
    `@numer = 1` condition. When it stopped before, it was at `@number = 2`. So, it
    evaluates the `.class@{number} { background-image: ~"url(backgroundimage-@{number}.png)";
    }` declaration for the `@numer = 2` condition, and so on. When we are back at
    `@numer = 10`, all the code has been compiled. So, the compiler stops.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一次停在`@number = 1`，所以它会评估`@numer = 1`条件下的`.class@{number} { background-image:
    ~"url(backgroundimage-@{number}.png)"; }`声明。当它之前停止时，是在`@number = 2`。所以，它会评估`@numer
    = 2`条件下的`.class@{number} { background-image: ~"url(backgroundimage-@{number}.png)";
    }`声明，依此类推。当我们回到`@numer = 10`时，所有代码都已经编译完成。所以，编译器停止了。'
- en: Besides guards and argument matching, the preceding example also contains an
    interpolated property in the `.class@{number}` class declaration, as well as an
    example string interpolation with escaping when declaring the `~"url(backgroundimage-@{number}.png)";`
    code. Mixins also show the need to use an additional space when performing calculations.
    So, `@number - 1` won't be evaluated as one `@number-1` variable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保护和参数匹配，上面的示例还包含了`.class@{number}`类声明中的插值属性，以及在声明`~"url(backgroundimage-@{number}.png)";`时进行转义的字符串插值示例。混合还显示了在执行计算时需要使用额外的空格。因此，`@number
    - 1`不会被计算为一个`@number-1`变量。
- en: The !important keyword
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`!important`关键字'
- en: 'The chapter ends with a note on the `!important` keyword in *Less*. Using `!important`
    in a declaration gives the declaration the highest precedence when two or more
    selectors match the same element. The `!important` keyword overrules inline styles,
    as shown in the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以关于*Less*中`!important`关键字的说明结束。在声明中使用`!important`会使该声明在两个或更多选择器匹配同一元素时具有最高的优先级。`!important`关键字会覆盖内联样式，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding code will show the text in green. As the example shows you, you
    can use `!important` to change the styles, which you cannot edit, of the source
    with inline CSS. It can also be used to make sure a style is always applied. Nevertheless,
    please use `!important` with care, as the only way to overrule `!important` is
    to use another `!important`. Any incorrect or unnecessary use of `!important`
    in *Less* will make your code messy and difficult to maintain.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将显示为绿色文本。正如示例所示，您可以使用`!important`来更改内联CSS源的样式，这是您无法编辑的。它还可以用于确保样式始终被应用。然而，请谨慎使用`!important`，因为覆盖`!important`的唯一方法是使用另一个`!important`。在*Less*中不正确或不必要地使用`!important`将使您的代码混乱且难以维护。
- en: 'In *Less*, you can not only use `!important` for properties, but you can also
    use it with mixins. When `!important` is set for a certain mixin, all the properties
    of this mixin will be declared with the `!important` keyword. This can be seen
    in the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Less*中，您不仅可以在属性中使用`!important`，还可以在混合中使用它。当为某个混合设置`!important`时，该混合的所有属性都将使用`!important`关键字声明。这可以在以下代码中看到：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This code will be compiled into the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将编译为以下代码：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about variables and mixins. You have seen how defining
    variables and mixins at a single place will reduce your code and make it easy
    to maintain.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了关于变量和混合的知识。您已经看到了在一个地方定义变量和混合将减少您的代码并使其易于维护。
- en: In the next chapter, you will learn more about mixins and how to nest and extend
    them. You will also read about the built-in functions of *Less*. Built-in functions
    can be used to manipulate values in mixins and other parts of your code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习更多关于混合和如何嵌套和扩展它们的知识。您还将了解*Less*的内置函数。内置函数可用于操纵混合和代码其他部分中的值。
