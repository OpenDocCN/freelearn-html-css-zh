- en: Chapter 3. Understanding the Gravity of HTML5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。理解HTML5的重要性
- en: Before we dive into the game that we'll build in this chapter, we will examine
    why writing applications in HTML and JavaScript can be difficult when deploying
    in multiple different browsers. We will focus on simple and practical solutions
    to these problems, especially with regards to HTML5 and the latest APIs used today.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨本章将构建的游戏之前，我们将研究为什么在多个不同的浏览器中部署HTML和JavaScript应用程序可能会很困难。我们将重点关注这些问题的简单和实用解决方案，特别是关于今天使用的HTML5和最新API。
- en: The game we will build in this chapter will be a basic jelly wobbly gravity
    game. It will make use of HTML5's new API for vector graphics, native audio manipulation,
    and drag-and-drop. As the backbone of the rendering system for this game, we will
    use the old JavaScript timer, which, as we will see, is not at all appropriate
    for games such as this one where we need multiple updates per second. Thankfully,
    modern browsers have solved this issue, and taken into account the need we have
    for highly efficient rendering engines. However, we won't be discussing this new
    feature until the next game. Just for completion, this new feature is known as
    **requestAnimationFrame**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建的游戏是一个基本的果冻重力游戏。它将利用HTML5的新API进行矢量图形、本地音频处理和拖放。作为这个游戏渲染系统的支撑，我们将使用旧的JavaScript定时器，正如我们将看到的，这对于我们需要每秒多次更新的这种游戏来说并不合适。幸运的是，现代浏览器已经解决了这个问题，并考虑到了我们对高效渲染引擎的需求。然而，我们不会在下一个游戏之前讨论这个新功能。只是为了完整起见，这个新功能被称为**requestAnimationFrame**。
- en: Browser compatibility
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器兼容性
- en: Anyone who has done any web development at all has quickly developed a very
    deep, profound, and thorough hatred towards the way different browsers interpret
    and render the same code. However, if we dig a bit deeper into this phenomena,
    and look for the root cause of these discrepancies, it will surprise some people
    to realize that the problem is not what it seems. While finding the cause for
    rendering differences is easy, for example, some browsers define the box model
    differently, finding the cause for differences in code may not be so clear. Surprisingly,
    some developers seem to despise the JavaScript language because some code runs
    differently in some browsers. However, the truth of the matter is that JavaScript
    is actually quite portable, and its API is quite stable and consistent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 任何做过任何网页开发的人都很快就对不同浏览器解释和渲染相同代码的方式产生了非常深刻和彻底的厌恶。然而，如果我们深入研究一下这种现象，并寻找这些差异的根本原因，一些人会惊讶地意识到问题并不是看起来那样。虽然找到渲染差异的原因很容易，例如，一些浏览器以不同的方式定义框模型，但找到代码差异的原因可能并不那么清晰。令人惊讶的是，一些开发人员似乎对JavaScript语言感到厌恶，因为一些代码在某些浏览器中运行方式不同。然而，事实是JavaScript实际上是相当可移植的，它的API非常稳定和一致。
- en: Believe it or not, most of these headaches are caused by the DOM API, and not
    JavaScript itself. Some browsers register DOM-related events one way, while other
    browsers don't acknowledge that method, and instead use their own variation for
    it. The same goes for manipulating DOM elements and subtrees.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这些头疼大部分是由DOM API引起的，而不是JavaScript本身。一些浏览器以一种方式注册与DOM相关的事件，而其他浏览器则不承认该方法，而是使用自己的变体。对于操作DOM元素和子树也是如此。
- en: For example, one way to remove a node from the DOM is to call the `remove` method
    on the node itself. However, as of this writing, only a very limited handful of
    browsers expose this functionality. Most commonly, browsers allow us to remove
    a node from a DOM tree by calling the `removeChild` method on a parent node, passing
    a reference to the child node to be removed from the parent.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从DOM中删除节点的一种方法是在节点本身上调用`remove`方法。然而，截至目前，只有极少数浏览器公开了这个功能。通常，浏览器允许我们通过在父节点上调用`removeChild`方法，传递要从父节点中删除的子节点的引用，来从DOM树中删除节点。
- en: The key point to be made here is this; JavaScript itself is very consistent
    across browsers, but the way that browsers allow us to programmatically interact
    with the DOM, although this is most commonly done via JavaScript, may vary from
    browser to browser. While none of this is news to anybody, and certainly is not
    unique to HTML5, it is still important to remember that the main tool we have
    for programming the web platform, that is, JavaScript, is a very powerful and
    consistent one. The problem that we need to keep in mind is the DOM API (as well
    as CSS, although this particular issue is becoming less and less of an issue,
    as browsers are beginning to agree on common standards related to that).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要强调的关键点是：JavaScript本身在不同浏览器中非常一致，但浏览器允许我们通过编程方式与DOM进行交互的方式，尽管这通常是通过JavaScript完成的，但在不同浏览器中可能会有所不同。虽然这对任何人来说都不是新闻，当然也不是HTML5独有的，但重要的是要记住，我们用于编程Web平台的主要工具，也就是JavaScript，是一个非常强大和一致的工具。我们需要记住的问题是DOM
    API（以及CSS，尽管这个特定问题正在变得越来越不是问题，因为浏览器开始就与之相关的共同标准达成一致）。
- en: Supporting different browsers
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持不同的浏览器
- en: There are different approaches that we can take when developing an HTML5 application
    in order to ensure that the code runs the same in different browsers, and that
    the design is rendered the same as well. Some of these practices are painful and
    tedious, others are unreliable, and others are simply good enough. Unfortunately,
    as long as there are so many browser differences as there are today, there will
    never be one single silver bullet that completely makes the problem disappear.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发HTML5应用程序时，我们可以采取不同的方法来确保代码在不同浏览器中运行相同，并且设计也相同。其中一些做法是痛苦和繁琐的，另一些是不可靠的，还有一些是足够好的。不幸的是，只要今天存在这么多浏览器差异，就不会有一个单一的解决方案完全消除这个问题。
- en: The two main goals when it comes to writing code that runs practically identical
    in different browsers are; write as little unique code to each browser as possible,
    and write code that degrades gracefully. It is one thing to specifically target
    a couple of unique features specific to a particular browser, but it is a completely
    different issue to maintain two or more separate code bases. Remember this, that
    the best code you can possibly write, both in terms of efficient execution and
    security, is the code that you never have to write at all. The more code you write,
    the more subject to errors and faults your code will be. Thus, avoid writing too
    much code that does the same thing as other code you're also writing, but writing
    it uniquely for a different browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写在不同浏览器中运行几乎相同的代码时，主要目标有两个：尽可能少地为每个浏览器编写独特的代码，以及编写能够优雅降级的代码。专门针对特定浏览器的一些独特功能是一回事，但维护两个或更多个独立的代码库是完全不同的问题。记住，你可能写的最好的代码，无论是在执行效率还是安全性方面，都是你根本不需要写的代码。你写的代码越多，你的代码就越容易出错和故障。因此，避免写太多与你正在编写的其他代码相同的代码，但为不同的浏览器编写独特的代码。
- en: While being a perfectionist can be a great attribute, we must be realistic that
    we won't achieve perfection any time soon. Not only that, but in most cases (certainly
    in all cases where a video game is involved) we don't need to write software that
    is anywhere near perfect. At the end of the day, whether you agree with it or
    not, the goal of software development is to produce software that is good enough.
    As long as the program solves the problem for which it was written, and does so
    in a reasonable fashion, then for all practical purposes, we can say that the
    software is good.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然追求完美主义可能是一个很好的品质，但我们必须现实一点，我们不会很快达到完美。不仅如此，在大多数情况下（特别是涉及到视频游戏的所有情况），我们不需要编写接近完美的软件。在一天结束时，无论你是否同意，软件开发的目标是生产足够好的软件。只要程序解决了它被编写的问题，并以合理的方式做到这一点，那么从实际目的来看，我们可以说这个软件是好的。
- en: With that introduction behind us, keep those two principles in mind as you develop
    HTML5 applications, including games, aimed at reaching hundreds of millions of
    people world wide. True, there are some browser-specific functionalities that
    may make a game unplayable, or at least make the user experience significantly
    different, that the final result might not be desirable. But, pay close attention
    to what you're really trying to accomplish, so as to discern what browser differences
    are good enough. It may very well be that a feature targeted to a particular browser
    is used by so few users that there is no cost benefit to the feature. What we
    never want to do, however, is to deploy an unusable product.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍完这些原则后，当你开发HTML5应用程序时，包括面向全球数亿人的游戏时，请记住这两个原则。确实，有一些特定于浏览器的功能可能会使游戏无法玩或者至少使用户体验有很大不同，最终结果可能不理想。但是，要密切关注你真正想要实现的目标，以便辨别哪些浏览器差异是足够好的。可能某个特定浏览器的功能被使用的用户太少，以至于这个功能没有成本效益。然而，我们绝对不希望部署一个无法使用的产品。
- en: HTML5 libraries and frameworks
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML5库和框架
- en: In our quest for multiple browser support in cost efficient ways, we can find
    comfort in knowing that we're not alone in this struggle. Today, there are so
    many open source projects aimed at solving this same problem of browser compatibility
    that we can possibly play the alphabet game, where we name a different HTML5 library
    or framework for each letter of the alphabet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们寻求以成本效益的方式支持多个浏览器时，我们可以放心地知道我们并不孤单。今天，有许多旨在解决浏览器兼容性问题的开源项目，我们可能可以玩字母游戏，为字母表中的每个字母命名一个不同的HTML5库或框架。
- en: There are normally two reasons for the existence of such tools, namely to abstract
    away browser differences, and to speed up development. While most abstractions
    provided by today's JavaScript tools attempt to provide the client with a single
    interface that unifies browser discrepancies, a lot of these libraries also provide
    functionality that simply speed development time and effort.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具存在的主要原因通常有两个，即抽象掉浏览器差异和加快开发速度。虽然今天的大多数JavaScript工具提供的抽象试图为客户端提供统一浏览器差异的接口，但许多这些库也提供功能，简单地加快开发时间和工作量。
- en: jQuery
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: By far, the most popular JavaScript library is one called jQuery. If you haven't
    heard of jQuery before, chances are that you just woke up from a very deep and
    profound hibernation, while your body traveled through distant galaxies. Some
    of the main benefits for using jQuery includes a very powerful DOM query and manipulation
    engine, a very simple, unified **XHR** (**XML HTTP Request** also known as Ajax)
    interface, and the ability to extend it through a well defined plugin interface.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最受欢迎的JavaScript库是一个叫做jQuery的库。如果你以前没有听说过jQuery，那么很可能你刚从一个非常深沉和深刻的冬眠中醒来，而你的身体穿越了遥远的星系。使用jQuery的一些主要好处包括非常强大的DOM查询和操作引擎，一个非常简单、统一的XHR（XML
    HTTP请求，也称为Ajax）接口，以及通过一个良好定义的插件接口来扩展它的能力。
- en: 'One example of how using a JavaScript library, particularly jQuery, can save
    you development time and effort is trying to make an asynchronous request to your
    server. Without jQuery, there is a bit of boilerplate code that we''d need to
    write so that different browsers all behave the same. The code is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript库，特别是jQuery，可以节省开发时间和精力的一个例子是尝试向服务器发出异步请求。没有jQuery，我们需要编写一些样板代码，以便不同的浏览器都表现一致。代码如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in contrast, that exact functionality can be achieved with the following
    code using jQuery:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相比之下，可以使用以下代码使用jQuery来实现相同的功能：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'One of the awesome things about jQuery''s XHR functionality is that it is highly
    flexible. At a bare minimum, we can achieve the same behavior as in the previous
    code, in a completely cross-browser fashion, as shown in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的XHR功能的一个很棒的地方是它非常灵活。至少，我们可以以完全跨浏览器的方式实现与上一个代码中相同的行为，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In conclusion, much can be done with very little effort, time, and code, with
    jQuery. All of this also comes with the added benefit that the library is developed
    by a very dedicated team, with a very involved and active community behind it.
    For more information about jQuery, check out the official website at [http://www.jquery.com](http://www.jquery.com).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，用很少的工作、时间和代码就可以做很多事情，这也带来了额外的好处，即该库是由一个非常专注和活跃的社区开发的。有关jQuery的更多信息，请访问官方网站[http://www.jquery.com](http://www.jquery.com)。
- en: Google Web Toolkit
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google Web Toolkit
- en: Another popular and extremely powerful JavaScript tool is **Google Web Toolkit**
    (**GWT**). First of all, GWT is not a mere library that provides a handful of
    abstractions on top of JavaScript, but rather a full blown development toolkit
    that uses the Java language (which itself comes with all of its benefits), then
    compiles and translates the Java code into highly optimized, browser-specific
    JavaScript code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行且非常强大的JavaScript工具是Google Web Toolkit（GWT）。首先，GWT不仅仅是一个提供了一些JavaScript抽象的库，而是一个完整的开发工具包，使用Java语言（本身具有所有的优势），然后将Java代码编译和转换为高度优化的、特定于浏览器的JavaScript代码。
- en: It is silly to try to compare jQuery with GWT, as each solve different problems,
    and take a completely different look at web development. However, it is worth
    saying that while jQuery is a great tool that is currently found in the toolbox
    of nearly every web developer today, it is not intended for, nor is it a very
    good fit for actual game development. Google Web Toolkit, on the other hand, while
    not the most appropriate tool for small, trivial HTML and JavaScript projects,
    lends itself very well to game development. In fact, the popular game Angry Birds
    used Google Web Toolkit in the development of the Google Chrome version of the
    game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 愚蠢地将jQuery与GWT进行比较，因为它们解决不同的问题，并对Web开发有完全不同的看法。然而，值得一提的是，虽然jQuery是一个很棒的工具，几乎每个网页开发者的工具箱中都可以找到，但它并不适用于实际的游戏开发。另一方面，Google
    Web Toolkit虽然不是小型琐碎的HTML和JavaScript项目的最合适工具，但非常适合游戏开发。事实上，流行的游戏《愤怒的小鸟》在开发Google
    Chrome版本时使用了Google Web Toolkit。
- en: In conclusion, while GWT is enough a subject to occupy its own book, it is a
    great tool to consider when you take on your next large web development project,
    where one of the goals is to provide multiple browser support to your application.
    For more information about Google Web Toolkit, check out the official website
    at [https://developers.google.com/web-toolkit/](https://developers.google.com/web-toolkit/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，虽然GWT足够成为一本独立的书的主题，但在你接手下一个大型Web开发项目时，考虑使用它是一个很好的选择，其中一个目标是为你的应用程序提供多个浏览器的支持。有关Google
    Web Toolkit的更多信息，请访问官方网站[https://developers.google.com/web-toolkit/](https://developers.google.com/web-toolkit/)。
- en: Supporting browsers with limited HTML5 features
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持具有有限HTML5功能的浏览器
- en: As was previously mentioned, none of the browser-caused development headaches
    mentioned above are new with, or specific to, HTML5\. However, it is important
    to know that this same problem has not gone away with HTML5 (yet). Furthermore,
    HTML5 brings with it a whole new level of cross-browser nightmares. For instance,
    while most HTML5 related APIs are well defined in a documented specification,
    there are also many APIs that are currently in an experimental stage (for a discussion
    on experimental APIs and vendor prefixes, refer back to the online chapter, *Setting
    up the Environment*, and [Chapter 2](ch02.html "Chapter 2. HTML5 Typography"),
    *HTML5 Typography*, where the topic is more thoroughly discussed). On top of that,
    there are also browsers that don't yet support some HTML5 features, or currently
    offer limited support, or worse yet, they provide support through a different
    interface than other browsers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，上述由浏览器引起的开发头疼问题都不是HTML5特有的。然而，重要的是要知道，HTML5并没有解决这个问题（尚未）。此外，HTML5带来了全新的跨浏览器噩梦。例如，虽然大多数与HTML5相关的API在文档规范中得到了很好的定义，但也有许多API目前处于实验阶段（有关实验性API和供应商前缀的讨论，请参阅在线章节《设置环境》和[第2章](ch02.html
    "第2章。HTML5排版")《HTML5排版》，在那里这个主题得到了更全面的讨论）。除此之外，还有一些浏览器尚未支持某些HTML5功能，或者目前提供有限的支持，或者更糟糕的是，它们通过与其他浏览器不同的接口提供支持。
- en: Again, as web developers we must always have the user at the top of the list
    of priorities when creating a new application. Since the problem of browser compatibility
    is still among us, some people feel that HTML5 is still a thing for the future,
    and the usefulness of its new features remain yet to be seen. The rest of this
    section will describe ways that we can use HTML5 today without having to worry
    about less desirable browsers, and yet provide a functional application to users
    using such browsers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，作为网页开发者，我们在创建新应用程序时必须始终把用户放在首要位置。由于浏览器兼容性问题仍然存在，一些人认为HTML5仍然是未来的事情，其新功能的实用性尚未得到验证。本节的其余部分将描述我们如何在今天使用HTML5而不必担心不太理想的浏览器，并为使用这些浏览器的用户提供功能性应用程序。
- en: Gracefully degrade
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优雅地降级
- en: If you pay close attention to the previous code snippet where we attempted to
    create an **XHR** object that works in many different browsers, you will notice
    that the code deliberately halts execution if the browser executing the code doesn't
    support one of the two options the code searched for. That is a great example
    of what we should not do, if at all possible. Whenever a specific feature is not
    available to a certain browser, the first option should be to provide an alternative
    construct, even if this alternative method doesn't quite provide the same behavior.
    We should do all that we can to at least provide a functional experience in the
    worst case scenario, where the browser has zero support for what we're trying
    to accomplish.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细关注先前的代码片段，我们尝试创建一个在许多不同浏览器中工作的**XHR**对象，您会注意到，如果执行代码的浏览器不支持代码搜索的两个选项中的一个，代码会故意停止执行。这是一个很好的例子，说明我们不应该这样做，如果可能的话。每当特定功能对某个浏览器不可用时，第一选择应该是提供替代构造，即使这种替代方法并不能完全提供相同的行为。我们应该尽力在最坏的情况下提供一个功能性的体验，即浏览器完全不支持我们要实现的功能的情况。
- en: For example, HTML5 provides a new storage mechanism that's similar to a cookie
    (in other words, a simple key-value pair storage), but with the main difference
    being that this storage mechanism stores the data completely in the client, and
    that data is never sent back and forth to the server as part of the HTTP request.
    While the specifics of what this storage system is and how it works will be covered
    later in the book, we can summarize it by saying that this storage system (called
    Local Storage) stores key-value pairs, and does so through a well defined interface,
    and from a property of the Window object named `localStorage`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，HTML5提供了一种新的存储机制，类似于cookie（换句话说，是一种简单的键值对存储），但主要区别在于这种存储机制完全将数据存储在客户端，并且这些数据永远不会作为HTTP请求的一部分来回传输到服务器。虽然这种存储系统的具体内容和工作原理将在本书的后面进行介绍，但我们可以总结说，这种存储系统（称为本地存储）存储键值对，并通过一个名为`localStorage`的Window对象的属性的明确定义的接口来实现。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One powerful application for Local Storage is to cache asynchronous requests
    made by the user, so that the subsequent requests can be fetched directly from
    the browser's local storage, thus avoiding the round trip to the server. However,
    if a browser doesn't support local storage, the worst case scenario in this particular
    case would be that the application would need to fetch a subsequent request from
    the server again. While not practical or efficient, this is by far a problem one
    should not lose sleep over, except if that means that we'll need to write lots
    of extra code to test for the presence of the `localStorage` object every time
    we need to use it, thus polluting the code base with many repetitive conditional
    statements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储的一个强大应用是缓存用户发出的异步请求，以便后续请求可以直接从浏览器的本地存储中获取，从而避免往返到服务器。然而，如果浏览器不支持本地存储，在这种特定情况下的最坏情况是应用程序需要再次从服务器获取后续请求。虽然这并不实用或高效，但这绝对不是一个应该让人担心的问题，除非这意味着我们需要编写大量额外的代码来测试`localStorage`对象的存在，从而在每次需要使用它时污染代码库，因为会有很多重复的条件语句。
- en: 'A simple solution to a problem such as this is to use polyfills, which we''ll
    discuss more in depth next. In short, though, a polyfill is a JavaScript alternative
    that the browser can use when the original implementation is not yet available.
    This way, you can load the polyfill if the browser needs it, and the rest of the
    code base can use the functionality through the original interface, and never
    know which implementation it is working with. In the case of `localStorage`, we
    could simply check whether the authentic API is available, and write code that
    mimics its behavior if it is not available. The following code snippet shows this
    behavior:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题的一个简单解决方案是使用polyfills，我们将在接下来更深入地讨论。简而言之，polyfill是一个JavaScript替代方案，当原始实现尚不可用时，浏览器可以使用它。这样，如果浏览器需要，您可以加载polyfill，而代码库的其余部分可以通过原始接口使用功能，而不知道它正在使用哪种实现。对于`localStorage`，我们可以简单地检查真实的API是否可用，并在不可用时编写模拟其行为的代码。以下代码片段展示了这种行为：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although the preceding polyfill really doesn't store any data beyond the current
    session, this particular implementation of a local storage polyfill can be enough
    for the needs of a given application. At the very least, this implementation allows
    us to code to the official interface (calling the real methods defined by the
    specification), and no exceptions are thrown by the browser, since the methods
    are indeed present. Eventually, whenever the browser that didn't support the HTML5
    API, and thus used our polyfill because of the conditional that checked for browser
    support of the feature, that conditional will no longer trigger the polyfill to
    be loaded, thus the client code will always refer to the original implementation
    and no changes will be needed to the main source code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的polyfill实际上并没有存储任何数据超出当前会话，但这种本地存储polyfill的特定实现可能足够满足特定应用程序的需求。至少，这种实现允许我们编写符合官方接口的代码（调用规范定义的真实方法），并且浏览器不会抛出异常，因为这些方法确实存在。最终，每当不支持HTML5
    API的浏览器使用我们的polyfill时，由于条件检查了浏览器是否支持该功能，这个条件将不再触发加载polyfill，因此客户端代码将始终引用原始实现，而主源代码不需要进行任何更改。
- en: While it is quite exciting to consider what polyfills can do for us, the observant
    student will quickly notice that writing complete, secure, and accurate polyfills
    is slightly more complicated than adding simple CSS hacks to a style sheet in
    order to make a design compatible with different browsers. Even though the sample
    local storage polyfill shown previously was relatively complicated, it does not
    completely mimic the official interface, and neither does it behave 100 percent
    the same with the little functionality that it did implement. Soon the organized
    student will ask how much time he or she should expect to spend writing bullet-proof
    polyfills. The answer, which I'm glad to report is a positive one, is given and
    explained in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然考虑polyfills对我们有什么作用是相当令人兴奋的，但细心的学生会很快注意到，编写完整、安全和准确的polyfills比在样式表中添加简单的CSS
    hack以使设计与不同浏览器兼容要复杂一些。即使之前展示的样本本地存储polyfill相对复杂，它也没有完全模仿官方接口，也没有完全实现它所实现的少量功能。很快，有组织的学生会问自己应该期望花费多少时间来编写防弹polyfills。我很高兴地报告，答案在下一节中给出并解释。
- en: Polyfills
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Polyfills
- en: To answer the preceding question, that is, how much time should you expect to
    spend writing your own robust polyfills in order to be able to start using HTML5
    features today, and still have your code run on multiple different browsers is,
    zero. Unless you really want the experience of writing a fallback for different
    browsers, there is no reason to cook your own libraries and such, since much work
    has already been done on this area by hundreds of other developers who have shared
    their work with the community.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回答前面的问题，即您应该期望花费多少时间来编写自己的强大polyfills，以便能够开始使用HTML5功能，并且仍然使您的代码在多个不同的浏览器上运行，答案是零。除非您真的想要为不同的浏览器编写后备方案的经验，否则没有理由自己编写库等，因为这个领域已经有数百名其他开发人员为社区分享了他们的工作。
- en: With polyfills, there really isn't a single JavaScript import that we can use
    at the top of our HTML5 project that will magically extend every deficient browser,
    and make them 100 percent HTML5 ready. However, there are many separate projects
    available, so that if you're trying to use a particular element, you can simply
    import that particular polyfill. While there is no definitive source where all
    of these polyfills can be found, a simple Google or Bing search for the particular
    functionality you want should quickly connect you to an appropriate polyfill.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用polyfills时，我们无法在HTML5项目的顶部使用单个JavaScript导入来神奇地扩展每个不足的浏览器，使它们100％准备好使用HTML5。然而，有许多单独的项目可用，因此，如果您想要使用特定元素，只需导入该特定的polyfill即可。虽然没有一个确定的来源可以找到所有这些polyfills，但是简单地通过Google或Bing搜索您想要的特定功能，应该可以迅速连接到适当的polyfill。
- en: Modernizr
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Modernizr
- en: One particular tool that is worth mentioning is Modernizr. This JavaScript library
    inspects the page that loads it, and detects which HTML5 features are available
    in the user's browser. This way, we can very easily check whether or not a particular
    API is available, and take action accordingly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的一个工具是Modernizr。这个JavaScript库检查加载它的页面，并检测用户浏览器中可用的HTML5功能。这样，我们可以非常容易地检查特定API是否可用，并相应地采取行动。
- en: As of this writing, the current version of Modernizr allows us to test for a
    particular API or feature, and load specific polyfills in the case that the test
    returns positive or negative, which makes adding polyfills when needed very easy
    and effortless.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，当前版本的Modernizr允许我们测试特定的API或功能，并在测试结果为正或负时加载特定的polyfills，这使得在需要时添加polyfills非常容易和轻松。
- en: Furthermore, Modernizr also includes HTML5 Shiv, which is a very small piece
    of JavaScript that allows us to use all of the HTML5 semantic tags in browsers
    that don't recognize them. Note that this will not add the actual functionality
    of the tags, but will merely allow you to style those tags through CSS. The reason
    is that in Internet Explorer Version 8 and below, if we try to style an element
    that the browser doesn't recognize, it will simply ignore any CSS applied to it.
    With Modernizr, however, those elements are created (using JavaScript), so that
    the browser then knows about the tags, and thus allows CSS to be applied to them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Modernizr还包括HTML5 Shiv，这是一个非常小的JavaScript片段，允许我们在不识别它们的浏览器中使用所有HTML5语义标签。请注意，这不会添加标签的实际功能，而只是允许您通过CSS样式化这些标签。原因是在Internet
    Explorer 8及更低版本中，如果我们尝试为浏览器不识别的元素添加样式，它将简单地忽略应用于它的任何CSS。然而，使用Modernizr，这些元素被创建（使用JavaScript），因此浏览器知道这些标签，从而允许应用CSS。
- en: For more information about Modernizr, check out the official website at [http://modernizr.com/](http://modernizr.com/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Modernizr的更多信息，请访问官方网站[http://modernizr.com/](http://modernizr.com/)。
- en: The game
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: The project game we'll build in this chapter is simply called *Basic Jelly Wobbling
    Gravity Game*. The goal of the game is to feed our main hero enough jelly that
    he gets sick and drops to the floor with a severe tummy ache. The main character
    is controlled through the left and right arrow keys on the keyboard, and in order
    to eat a jelly, you simply have to direct the hero underneath a falling jelly.
    Every time you feed the hero a jelly, his health meter decreases slightly. Once
    enough jelly has been fed, and the health meter reaches zero, the hero gets too
    sick and faints. If you let a jelly drop on the floor, nothing happens except
    that the jelly splashes everywhere. This is a Basic Jelly Wobbling Gravity Game.
    Can you serve Prince George enough jelly until he passes out?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建的项目游戏简称为*基本果冻摇摆重力游戏*。游戏的目标是喂我们的主角足够多的果冻，以至于他吃得太多而生病并倒在地板上。主角通过键盘上的左右箭头键控制，为了吃果冻，您只需将主角放在一个下落的果冻下面。每次喂主角一个果冻，他的健康指数都会略微下降。一旦喂了足够多的果冻，健康指数降到零，主角就会生病晕倒。如果让果冻掉在地板上，除了果冻到处溅开之外，什么也不会发生。这就是一个基本的果冻摇摆重力游戏。您能为乔治王子提供足够多的果冻直到他昏倒吗？
- en: '![The game](img/6029OT_04_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![游戏](img/6029OT_04_01.jpg)'
- en: In order to demonstrate a few principles about HTML5 game development, we'll
    build this game completely with DOM elements. While this approach is normally
    not the desired approach, you will notice that many games still perform quite
    nicely on most modern browsers, and on the average desktop or laptop computer
    today. However, as we'll learn in the chapters to follow, there are a few techniques,
    tools, and APIs available to us in HTML5 that are far more appropriate for game
    development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一些关于HTML5游戏开发的原则，我们将完全使用DOM元素构建这个游戏。虽然这种方法通常不是理想的方法，但你会注意到许多游戏在大多数现代浏览器和今天的普通台式机或笔记本电脑上仍然表现得相当不错。然而，正如我们将在接下来的章节中学到的那样，HTML5中有一些技术、工具和API对于游戏开发来说更加合适。
- en: Also, as is common to this book, most game elements will be kept to a minimum
    in terms of complexity, so that it can be explained and understood easily. Specifically
    in this game, we'll only use SVG graphics as a proof of concept instead of diving
    deeply into the potential and opportunity available to us through the SVG standard.
    The same goes for drag-and-drop, as there is so much more that can be done with
    it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与本书一贯的做法一样，大多数游戏元素在复杂性方面都会保持在最低水平，以便能够轻松解释和理解。特别是在这个游戏中，我们只会使用SVG图形作为概念验证，而不是深入探讨SVG标准为我们提供的潜力和机会。拖放也是如此，还有很多可以做的事情。
- en: Code structure
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码结构
- en: The way this code is structured is very straightforward. Every element in the
    game is absolutely positioned through CSS, and each element is made up of some
    HTML container styled with a background image or some CSS3 properties that give
    it a fresh look with rounded corners, drop shadows, and so on. Also, although
    some people might prefer object oriented programming to functional programming,
    and better cohesion instead of global variables everywhere, we'll take exactly
    that approach in this game, and focus on the HTML5 aspects instead of the design
    of the game. The same goes for the style and quality of the graphics. All that
    you see in this game was created by myself using a free photo editor program,
    and it took me no longer than 30 minutes to create all of the graphics you see
    in the game. This was mostly to show that fun games can be built even if you're
    on a budget, or don't have a dedicated graphics design team.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结构非常简单。游戏中的每个元素都是通过CSS绝对定位的，并且每个元素都由一些带有背景图像或一些CSS3属性的HTML容器组成，这些属性赋予它们圆角、阴影等新鲜外观。尽管有些人可能更喜欢面向对象的编程而不是函数式编程，更喜欢更好的内聚而不是到处都是全局变量，但在这个游戏中，我们将采取这种方法，并专注于HTML5方面，而不是游戏的设计。同样，图形的风格和质量也是如此。你在这个游戏中看到的所有东西都是我用一个免费的照片编辑程序创建的，而且我用不到30分钟的时间就创建了你在游戏中看到的所有图形。这主要是为了表明即使你预算有限，或者没有专门的图形设计团队，也可以构建有趣的游戏。
- en: Since we're loading all of the SVG entities right inline with our HTML structure,
    we place them inside a `div` container that is hidden from the user, then we clone
    each entity that we need a copy of and use it on the game. We use this technique
    for all of the jellies and the hero. The hero SVG is left the same as what was
    exported from the vector editor software. The jelly SVG is slightly modified by
    removing all of the colors that they were designed with, and replaced with CSS
    classes. This way we can create different CSS classes that specify different colors,
    and each new instance of the jelly SVG is assigned a random class. The final result
    is one single SVG model hidden inside the invisible `div` container, and each
    instance of it, using zero extra code, is given a different color to add variety
    to the game. We could also have randomly assigned a different size and rotation
    to each jelly instance, but this was left out for an exercise to the reader.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将所有的SVG实体都直接加载到HTML结构中，我们将它们放在一个对用户隐藏的`div`容器中，然后克隆我们需要的每个实体，并在游戏中使用它们。我们对所有果冻和英雄都使用这种技术。英雄SVG与从矢量编辑软件导出的内容保持一致。果冻SVG稍作修改，去掉了它们设计时的所有颜色，并用CSS类替换。这样我们可以创建不同的CSS类来指定不同的颜色，每个果冻SVG的新实例都被分配一个随机类。最终结果是一个单一的SVG模型隐藏在不可见的`div`容器中，每个实例都被赋予不同的颜色，而不需要额外的代码，以增加游戏的多样性。我们也可以随机分配不同大小和旋转给每个果冻实例，但这被留作读者的练习。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although we could have used data attributes instead of ID attributes for all
    of those elements, there would have been no real benefit over using them over
    the IDs, just as there is really no benefit in using IDs over data-attributes
    in this situation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用数据属性而不是ID属性来表示所有这些元素，但在这种情况下，使用它们而不是ID并没有真正的好处，就像在这种情况下使用ID而不是数据属性也没有好处一样。
- en: Note how there are two targets where the `bowl-top` can be dragged onto. Actually,
    there is really only one, which is the element `bowl-top-target`. The other element
    that looks like a target, which was cleverly given an ID of `bowl-top-faux-target`,
    is only there for the visual effect. Since a real drop target (an element where
    a draggable element can be placed at the end of a drag option) is only activated
    once the mouse pointer moves over it, there wasn't enough room on that table to
    accomplish the desired effect of showing a small outlined area where `bowl-top`
    appears to be dropped.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`bowl-top`可以拖放到两个目标上。实际上，只有一个目标，即`bowl-top-target`元素。另一个看起来像目标的元素，巧妙地被赋予了`bowl-top-faux-target`的ID，只是为了视觉效果。由于真正的放置目标（拖动元素可以在拖动选项结束时放置的元素）只有在鼠标指针移动到它上面时才会被激活，所以在桌子上没有足够的空间来实现`bowl-top`似乎被放置在一个小轮廓区域的期望效果。
- en: Finally, there is one global timer used in the game, which controls the frequency
    at which we call the game loop function, named `tick()`. Although this is not
    a chapter on proper game design, I will point out that you should avoid the temptation
    to create multiple timers for different purposes. Some people out there won't
    think twice before firing off an event through a unique timer separate from the
    main game timer. Doing so, especially in HTML5 games, can have negative side effects
    both in performance and in synchronizing all of the events.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在游戏中使用了一个全局计时器，用于控制我们调用游戏循环函数`tick()`的频率。虽然这不是一章关于正确游戏设计的内容，但我要指出，您应该避免诱惑去为不同目的创建多个计时器。有些人在这方面毫不犹豫，会通过一个独立于主游戏计时器的唯一计时器触发事件。这样做，特别是在HTML5游戏中，可能会对性能和所有事件的同步产生负面影响。
- en: API usage
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API使用
- en: The three APIs used in this game are audio, SVG, and drag-and-drop. A brief
    explanation of how each of these APIs were used in the game will follow, where
    only a general overview of the feature is given. In the next section, however,
    we'll take a detailed look at what each of these features actually do, and how
    we can use it in this and other situations. For the complete source code for this
    game, check out the book's page from Packt Publishing's website.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中使用的三个API是音频、SVG和拖放。接下来将简要解释这些API在游戏中的使用方式，其中只给出了功能的概述。然而，在下一节中，我们将详细了解这些功能实际上是如何使用的，以及如何在这种和其他情况下使用它。有关此游戏的完整源代码，请查看Packt
    Publishing网站上的书页。
- en: Web audio
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络音频
- en: Audio was used both for a never-ending loop used as a background song, as well
    as individual sound effects that are fired off when a jelly is launched up, bounces
    off the walls, splatters on the floor, or is eaten by the hungry hero. An old
    school sound effect is also fired off when the hero finally dies from eating too
    much jelly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 音频被用作永无止境的循环，作为背景音乐，以及当果冻被发射，弹跳，溅在地板上，或被饥饿的英雄吃掉时，会发出单独的音效。当英雄因吃太多果冻而最终死亡时，也会发出一个老式的音效。
- en: 'The way that each audio entity is managed in the game is through a simple encapsulation
    that holds references to individual sound files, and exposes an interface allowing
    us to play a file, fade sound files in and out, as well as add new sound files
    to the list of audios managed by this class. The code for the same is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中每个音频实体的管理方式是通过一个简单的封装，其中包含对单独音频文件的引用，并公开一个接口，允许我们播放文件，淡入淡出音频文件，以及将新的音频文件添加到此类管理的音频列表中。代码如下：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we instantiate a global object of this custom `SoundFx` type, where every
    sound clip used in the game is stored. This way, if we want to play any type of
    sound, we simply call the `play` method on this global reference. Take a look
    at the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化了一个自定义的`SoundFx`类型的全局对象，其中存储了游戏中使用的每个音频剪辑。这样，如果我们想播放任何类型的声音，我们只需在这个全局引用上调用`play`方法。看一下以下代码：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Scalable Vector Graphics (SVG)
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可伸缩矢量图形（SVG）
- en: As mentioned previously, the way SVG is used in the game is limited simply because
    the SVG spec is so robust and can get fairly complex. As you'll see in the in-depth
    description of the SVG API, there were a lot of things that we could have done
    to each individual primitive shape drawn through SVG (such as natively animating
    the hero's facial expressions, or making each jelly jiggle or rotate, and so on).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，游戏中使用SVG的方式受限于SVG规范非常强大且可能相当复杂。正如您将在SVG API的深入描述中看到的那样，我们可以对通过SVG绘制的每个基本形状做很多事情（例如原生动画化英雄的面部表情，或使每个果冻摇晃或旋转等）。
- en: 'The way we switch the sprite that represents a jelly into a splashed out jelly,
    when a jelly hits the floor is pretty clever. When we draw the jelly vectors using
    the vector editor software, we create two separate images, each representing a
    different state of the jelly. Both images are stacked on top of each other, so
    that they line up properly. Then, inside the HTML code, we assign a CSS class
    to each of these images. These classes are called jelly-block and splash, representing
    a jelly in its natural state, and a jelly splashed on the floor. In both of these
    classes, one of the vectors is hidden and the other is not. Depending on the state
    of each jelly element, these two classes are toggled back and forth. This is all
    done by simply assigning one of the two classes `jelly-svg-on` and `jelly-svg-off`
    to the parent svg element holding these two vector groups, as shown in the following
    code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当果冻触地时，我们将代表果冻溅开的精灵切换成了一个相当巧妙的方法。当我们使用矢量编辑软件绘制果冻矢量时，我们创建了两个分离的图像，每个代表果冻的不同状态。这两个图像叠放在一起，以便正确对齐。然后，在HTML代码中，我们为这些图像分配了一个CSS类。这些类分别称为jelly-block和splash，代表果冻的自然状态和果冻溅在地板上。在这两个类中，一个矢量被隐藏，另一个没有。根据每个果冻元素的状态，这两个类来回切换。这只需简单地将这两个矢量组中的一个分配给父svg元素的`jelly-svg-on`和`jelly-svg-off`两个类之一，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The way the preceding styles are driven is simple. By default, every jelly
    element is given a CSS class of `jelly-svg-on`, meaning that the jelly is not
    splashed. Then, when a jelly is calculated to have hit the floor, we remove that
    class, and add the CSS class of `jelly-svg-off`, as seen in the following code
    snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的样式驱动方式很简单。默认情况下，每个果冻元素都被赋予`jelly-svg-on`的CSS类，这意味着果冻没有溅开。然后，当计算出果冻已经触地时，我们移除该类，并添加`jelly-svg-off`的CSS类，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Drag-and-drop
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖放
- en: Similar to the way SVG was used in the game, drag-and-drop made its way into
    the final product taking a backseat to web audio. Yet, the role that drag-and-drop
    plays in the game is arguably the most important one, it starts the game. Instead
    of having the game start playing right away when the page first loads, or instead
    of having the user press a button or hit a key to start game play, the player
    needs to drag the lid away from the bowl where all the jellies are stored, and
    place it next to the bowl on the table where it sits.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与SVG在游戏中的使用方式类似，拖放以次要的方式进入最终产品，而Web音频则占据主导地位。然而，拖放在游戏中扮演的角色可以说是最重要的，它启动了游戏。与其让游戏在页面加载时立即开始播放，或者让用户按下按钮或按键来开始游戏，玩家需要将盖子从存放所有果冻的碗中拖出，并将其放在桌子上碗的旁边。
- en: The way drag-and-drop works in HTML5 is simple and intuitive. We register at
    least one object to be a draggable object (the one you drag around), and at least
    one other object to be a drop target (the object where the draggable can be dropped
    into). Then we register callback functions for whatever events we want that apply
    to the dragging and dropping behavior.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5中拖放的工作方式简单而直观。我们至少注册一个对象作为可拖动对象（您拖动的对象），至少注册一个其他对象作为放置目标（可将可拖动对象放入其中的对象）。然后，我们为适用于拖放行为的任何事件注册回调函数。
- en: In the game, we only listen for five events, two on the draggable element, and
    three on the drop target element. First, we listen for when the draggable is first
    dragged by the user (on drag start), which we respond to by making the bowl lid
    image invisible and placing a copy of the lid behind the mouse pointer, so that
    it appears that the user is truly dragging that lid.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们只监听了五个事件，两个在可拖动元素上，三个在放置目标元素上。首先，我们监听用户首次拖动可拖动对象时触发的事件（拖动开始），我们会对此做出响应，使碗盖图像不可见，并在鼠标指针后面放置一个盖子的副本，以便看起来用户真的在拖动那个盖子。
- en: Next, we listened for the event that is triggered when the user finally releases
    the mouse button, indicating the end of the dragging action (on drag end). At
    this point, we simply restore the bowl lid back to where it was originally, on
    top of the bowl. This event is fired whenever the dragging action is finished,
    and the drop was not done inside a valid drop target (the user didn't drop the
    lid where it was expected), which essentially restarts the process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们监听用户最终释放鼠标按钮时触发的事件，表示拖动动作的结束（拖动结束）。在这一点上，我们只需将碗盖恢复到最初的位置，放在碗的顶部。每当拖动动作结束，且放置在有效的放置目标内时（用户没有在预期的位置放置盖子），就会触发此事件，从根本上重新启动该过程。
- en: The three events that we listen for on the drop target are the `onDragLeave`,
    `onDragOver`, and `onDrop`. Whenever a draggable is dropped inside a drop target,
    the target's `onDrop` event is fired. In this case, all we do is call the `startGame()`
    function, which sets the game in motion. As part of the set up for this `startGame`
    function, we move the bowl lid element into the exact pixel position where it
    was dropped, and remove the draggable attribute, so that the user can no longer
    drag that element.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在放置目标上监听的三个事件是`onDragLeave`、`onDragOver`和`onDrop`。每当可拖动对象放置在放置目标内时，目标的`onDrop`事件就会被触发。在这种情况下，我们所做的就是调用`startGame()`函数，这将启动游戏。作为`startGame`函数的设置的一部分，我们将碗盖元素移动到放置的确切像素位置，并删除可拖动属性，以便用户无法再拖动该元素。
- en: 'The functions `onDragOver` and `onDragLeave` are triggered whenever the mouse
    pointer is moved on top of, and hovered out of the target object, respectively.
    In our case, all we do in each of those functions is toggle the visibility of
    the bowl lid and the image that shows behind the cursor while the dragging is
    happening. This can be seen in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDragOver`和`onDragLeave`函数分别在鼠标指针移动到目标对象上方和悬停在目标对象外部时触发。在我们的情况下，在这些函数中我们所做的就是切换碗盖和在拖动发生时显示在鼠标指针后面的图像的可见性。可以在以下代码中看到：'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Web audio
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web音频
- en: The new web audio API defines a way to play audio right into the browser without
    the need for a single plugin. For a high level experience, we can simply add a
    few audio tags throughout our HTML page, and the browser takes care of displaying
    a player for the user to interact with and play, pause, stop, rewind, fast forward,
    and adjust the volume. Alternatively, we can use the JavaScript interface available,
    and either control the audio tags on the page with it, or achieve much more powerful
    and complex tasks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Web音频API定义了一种在浏览器中播放音频而无需单个插件的方法。对于高级别的体验，我们可以简单地在整个HTML页面中添加一些音频标签，浏览器会负责显示播放器供用户进行交互和播放、暂停、停止、倒带、快进和调整音量。或者，我们可以使用可用的JavaScript接口，并使用它来控制页面上的音频标签，或者实现更强大和复杂的任务。
- en: One key detail to remember about browser support and the web audio API, is that
    different browsers support different file formats. When defining an audio tag,
    similar to an image tag, we specify the path to the source file. The difference
    is that with audio, we can specify multiple sources for the same file (but different
    formats), then the browser can choose the file it supports, or the best option
    it has, in case it supports multiple file formats. Currently there are three audio
    formats supported by all major browsers, namely `.mp3`, .`wav`, and `.ogg`. As
    of this writing, no single audio format is supported in all major browsers, which
    means that whenever we use the web audio API, we'll need at least two versions
    of each and every file we play through the API, if we wish to reach the greatest
    possible audience.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于浏览器支持和Web音频API的一个关键细节是，不同的浏览器支持不同的文件格式。在定义音频标签时，类似于图像标签，我们指定源文件的路径。不同的是，对于音频，我们可以为同一文件指定多个源（但是不同的格式），然后浏览器可以选择它支持的文件，或者在支持多个文件格式的情况下选择最佳选项。目前，所有主要浏览器都支持三种音频格式，即`.mp3`、`.wav`和`.ogg`。截至目前，没有一种音频格式在所有主要浏览器中都受支持，这意味着每当我们使用Web音频API时，如果我们希望触及尽可能多的受众，我们将需要每个文件的至少两个版本。
- en: Finally, keep in mind that although we can (and should) specify multiple audio
    files per each audio element, each browser only downloads one of these files.
    This is a very handy (and obvious) feature because downloading multiple copies
    of the same file would be awfully inefficient and bandwidth heavy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，尽管我们可以（而且应该）为每个音频元素指定多个音频文件，但每个浏览器只下载其中一个文件。这是一个非常方便（和显而易见）的功能，因为下载多个相同文件的副本将非常低效且占用带宽。
- en: How to use it
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用它
- en: 'The simplest way to get started with the web audio API is with an inline HTML5
    element. The code for it is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web音频API的最简单方法是使用内联HTML5元素。其代码如下：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Adding the above snippet to a page will not result in anything visible. In
    order to add more control to the tag, including adding a player to the page so
    that the user can interact with it, we can choose from the elements associated
    with the tag. These attributes are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述片段添加到页面上不会导致任何可见的结果。为了对标签添加更多控制，包括向页面添加播放器以便用户可以与其交互，我们可以从与标签相关的元素中进行选择。这些属性如下：
- en: '**autoplay**: It starts playing the file right away as soon as the browser
    has downloaded it'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**autoplay**：一旦浏览器下载完成，它立即开始播放文件。'
- en: '**controls**: It displays a visual player with buttons through which the user
    can control audio playback'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**controls**：它显示一个可视化播放器，通过它用户可以控制音频播放。'
- en: '**loop**: It is used to continuously play the file indefinitely'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**loop**：用于无限循环播放文件。'
- en: '**muted**: It is used when audio output is muted'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**muted**：当音频输出被静音时使用。'
- en: '**preload**: It specifies how the audio resource is to be preloaded by the
    browser'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**preload**：它指定浏览器如何预加载音频资源。'
- en: 'To achieve a similar result through JavaScript, we can create a DOM element
    of type audio, or instantiate a JavaScript object of type Audio. Adding the optional
    attributes can be done the same way we would to any other JavaScript object. Note
    that creating an instance of Audio has the exact same effect as creating a reference
    to a DOM element:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过JavaScript实现类似的结果，我们可以创建一个类型为音频的DOM元素，或者实例化一个类型为Audio的JavaScript对象。添加可选属性的方式与我们对任何其他JavaScript对象所做的方式相同。请注意，创建Audio的实例与创建对DOM元素的引用具有完全相同的效果：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although the JavaScript Audio object may seem easier to deal with, especially
    since it takes that awesome constructor argument that saves us a whole line of
    code, they both behave exactly the same, and can only be told apart at run time
    if you really want to be picky and distinguish them from each other. One small
    detail that you should know is that when we create that audio reference in JavaScript,
    it is not necessary to append it to the DOM in order to play the file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript音频对象可能看起来更容易处理，特别是因为它采用了令人惊叹的构造函数参数，可以节省我们一行代码，但它们的行为完全相同，并且只有在运行时才能够区分它们。一个小细节是，当我们在JavaScript中创建音频引用时，不需要将其附加到DOM以播放文件。
- en: 'However you decide to approach this setup step, once we have a reference to
    an audio object in JavaScript, we can control it with any one of the many events
    and attributes associated with the object. The audio objects are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您决定如何处理此设置步骤，一旦我们在JavaScript中有音频对象的引用，我们就可以使用与该对象相关的许多事件和属性来控制它。音频对象如下：
- en: '**play()**: It starts playing the file.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**play()**：开始播放文件。'
- en: '**pause()**: It stops playing the file, and maintains the currentTime.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pause()**：它停止播放文件，并保持currentTime不变。'
- en: '**paused**: Is a Boolean representing the current play state.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**paused**：表示当前播放状态的布尔值。'
- en: '**canPlayType**: Is used to find out whether the browser supports a particular
    audio type.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**canPlayType**：用于查找浏览器是否支持特定的音频类型。'
- en: '**currentSrc**: It returns the absolute path to the file currently assigned
    to the object.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currentSrc**：它返回当前分配给对象的文件的绝对路径。'
- en: '**currentTime**: It returns the current play position in seconds, as a floating
    point number.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currentTime**：它以浮点数形式返回当前播放位置（以秒为单位）。'
- en: '**duration**: It returns the total play time in seconds, as a floating point
    number.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**duration**：它以浮点数形式返回总播放时间（以秒为单位）。'
- en: '**ended**: Is a Boolean indicating whether the currentTime is equal to duration.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ended**：一个布尔值，指示currentTime是否等于duration。'
- en: '**readyState**: It indicates the state of the download of the source file.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readyState**：它指示源文件的下载状态。'
- en: '**volume**: It indicates the current volume of the file, ranging from 0 to
    1 both inclusive. This number is relative to the current system volume.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**volume**：它指示文件的当前音量，范围从0到1，包括0和1。这个数字是相对于当前系统音量的。'
- en: SVG
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG
- en: '**Scalable Vector Graphics** (**SVG**) for short, is an XML based format that
    describes graphics. This format may seem complicated enough to be confused with
    a full blown programming language for 2D graphics, but in truth it is just a markup
    language. While SVG may seem new to some web developers, the specification was
    first developed back in 1999.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**可缩放矢量图形**（**SVG**）简称为SVG，是一种描述图形的基于XML的格式。这种格式可能看起来足够复杂，以至于被误认为是用于2D图形的完整编程语言，但实际上它只是一种标记语言。虽然对一些Web开发人员来说，SVG可能是新的，但该规范最早是在1999年开发的。'
- en: 'The main difference between a vector graphic and a raster graphic (in other
    words, a bitmap) is the way that the graphic is described. In a bitmap, each pixel
    is essentially represented by three or four numbers, representing the color of
    that individual pixel (RGB), along with a possible opacity level. Looking at it
    from a broader sense, a bitmap is nothing more than a grid of pixels. Vectors,
    on the other hand, are described by a series of mathematical functions that describe
    lines, shapes, and colors, instead of each individual point on the entire image.
    To put it in simple terms, vector graphics do a fantastic job of scaling its dimensions,
    as illustrated in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量图形和光栅图形（即位图）的主要区别在于图形的描述方式。在位图中，每个像素基本上由三个或四个数字表示，表示该单个像素的颜色（RGB），以及可能的不透明度级别。从更广泛的意义上看，位图只不过是像素网格。另一方面，矢量图形由一系列数学函数描述，这些函数描述了线条、形状和颜色，而不是整个图像上的每个单独点。简而言之，矢量图形在缩放其尺寸方面表现出色彩，如下面的屏幕截图所示：
- en: '![SVG](img/6029OT_04_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![SVG](img/6029OT_04_02.jpg)'
- en: If you zoom in or try to stretch a vector graph, it will always be as smooth
    as the original, since the shape is defined (and scaled) using the same mathematical
    functions (as exemplified on the image on the left). Raster graphics, on the other
    hand, are only defined by the same grid of pixels. Scaling that grid just means
    multiplying the dimensions of the grid, resulting in the blocky, pixelated image
    represented by the image on the right.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果放大或尝试拉伸矢量图形，它将始终与原始图像一样平滑，因为形状是使用相同的数学函数定义（如左侧图像所示）。另一方面，光栅图形只由相同的像素网格定义。缩放该网格只意味着将网格的尺寸乘以，导致右侧图像所代表的方块状、像素化的图像。
- en: Now, the SVG standard does much more than simply define shapes, lines, paths,
    and colors. The specification also defines transformations and animations that
    can be applied to any single primitive, a group of primitives, or the entire SVG
    context. The specification also allows for SVG to be a very accessible format,
    meaning that it is possible to include text and other meta data right into the
    file, so that other applications can understand the file in other ways besides
    just the graphics. For example, search engines can crawl and index, not only your
    web pages, but also any SVG graphic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SVG标准不仅仅定义了形状、线条、路径和颜色。规范还定义了可以应用于任何单个基元、一组基元或整个SVG上下文的变换和动画。规范还允许SVG成为一种非常可访问的格式，这意味着可以将文本和其他元数据直接包含到文件中，以便其他应用程序可以以除了图形之外的其他方式理解文件。例如，搜索引擎可以爬行和索引，不仅您的网页，还有任何SVG图形。
- en: Since SVG is text based (as opposed to storing binary data, such as an audio
    file, for example), it is also possible to compress an SVG image using such compression
    algorithms as the popular Gzip, which is so prevalent in the world of web development
    these days. When an SVG file is saved as its own, standalone file, it is given
    the extension `.svg`. If the file is Gzip compressed, that extension should be
    `.svgz`, so that the browser knows to uncompress the file before processing it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SVG是基于文本的（与存储二进制数据相反，例如音频文件），因此也可以使用诸如流行的Gzip之类的压缩算法来压缩SVG图像，这在当今的Web开发世界中非常普遍。当SVG文件保存为自己的独立文件时，它被赋予扩展名`.svg`。如果文件经过Gzip压缩，那么扩展名应该是`.svgz`，这样浏览器就知道在处理之前解压缩文件。
- en: SVG files can be used in an HTML file in a few different ways. Since the file
    itself can be saved as its own file, it is possible to embed the entire file on
    a page using the object tag, using an ordinary image tag, or even using an XHR
    object to fetch its contents from a server, and injected right into the HTML document.
    Alternatively, the contents of an SVG file can be manually copied into the host
    HTML file, so that its contents are imported inline.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SVG文件可以以几种不同的方式在HTML文件中使用。由于文件本身可以保存为自己的文件，因此可以使用对象标签将整个文件嵌入到页面中，也可以使用普通图像标签，甚至可以使用XHR对象从服务器获取其内容，并将其注入到HTML文档中。或者，SVG文件的内容可以手动复制到主机HTML文件中，以便其内容内联导入。
- en: 'To import an SVG graphic inline into an HTML document, we simply insert an
    `svg` tag, with all of its contents as children nodes of it. As of this writing,
    the XML namespace attribute is required, along with the version number, as shown
    in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要将SVG图形内联导入到HTML文档中，我们只需插入一个`svg`标签，其中包含所有内容作为其子节点。截至目前，XML命名空间属性是必需的，还需要版本号，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While this may seem easy enough for a simple red circle, once the image gets
    to be more complex, it gets a bit hard to manage all of it in one file. Thus,
    it may be more convenient to simply save all of the SVG files externally, then
    import them individually. This approach also lends itself much better to resource
    sharing and reuse, as we can import the same graphic in multiple files without
    having to copy the entire file every time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于一个简单的红色圆圈来说可能很容易，但一旦图像变得更加复杂，就很难在一个文件中管理所有内容。因此，简单保存所有SVG文件并单独导入它们可能更方便。这种方法也更适合资源共享和重用，因为我们可以在多个文件中导入相同的图形，而无需每次都复制整个文件。
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: One final note about SVG before we dive into some hands on examples, is that
    every node inside the parent `svg` tag (including that parent node) is managed
    by the browser. Thus, every one of these nodes can be styled through CSS. If that's
    not enough, every node inside an SVG graphic can have browser events registered
    to them, allowing us to interact with the graphic and all of its individual components
    the same way as most other DOM elements. This makes SVG a very dynamic, highly
    flexible graphics format.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入一些实际示例之前，关于SVG的最后一点是，父`svg`标签内的每个节点（包括父节点）都由浏览器管理。因此，这些节点中的每一个都可以通过CSS进行样式设置。如果这还不够，SVG图形中的每个节点都可以注册浏览器事件，允许我们与图形及其所有单独组件进行交互，就像大多数其他DOM元素一样。这使得SVG成为一种非常动态、高度灵活的图形格式。
- en: If the SVG instance is inlined with the HTML, then we can simply get a direct
    reference to the parent svg node, or to any child node direct though JavaScript.
    Once we have that reference, we can act on the objects just like any other DOM
    elements. However, if the SVG is external to the HTML, we need to take one extra
    step and load in the actual SVG file into the JavaScript variable. Once this step
    is done, we can work with the SVG's subtree as though it is local to the file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SVG实例与HTML内联，则我们可以直接引用父svg节点，或者通过JavaScript直接引用任何子节点。一旦我们有了这个引用，我们就可以像处理任何其他DOM元素一样处理对象。然而，如果SVG是外部的，我们需要多做一步，将实际的SVG文件加载到JavaScript变量中。一旦完成了这一步，我们就可以像处理本地文件一样处理SVG的子树。
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A few important details about the preceding code snippet that you should always
    remember are:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面代码片段的一些重要细节，你应该始终记住的是：
- en: The imported SVG Document is treated as an external document (similar to an
    Iframe), meaning that any CSS outside of that document (such as the host document)
    is outside of its scope. Thus, if you want to apply a CSS class to an SVG node
    from a `getSVGDocument()` call, that CSS class must be defined within the same
    SVG file that was imported originally.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入的SVG文档被视为外部文档（类似于Iframe），这意味着该文档之外的任何CSS（如宿主文档）都不在其范围之内。因此，如果你想对从`getSVGDocument()`调用中的SVG节点应用CSS类，那么该CSS类必须在最初导入的同一个SVG文件中定义。
- en: The CSS attributes for SVG are slightly different. For example, instead of defining
    a background color you would define a fill color. Basically, the same attributes
    that are used on the SVG elements themselves, are the same ones you'd use in a
    corresponding stylesheet declaration.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG的CSS属性略有不同。例如，你会定义填充颜色而不是背景颜色。基本上，用在SVG元素本身上的属性，也是你在相应的样式表声明中会用到的属性。
- en: Any browser-specific CSS attributes can be applied to SVG nodes (for example,
    transition, cursor, etc.)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何特定于浏览器的CSS属性都可以应用到SVG节点上（例如，过渡、光标等）。
- en: 'Thus, the preceding example is completed with the following `.svg` file as
    the corresponding `red-circle.svg` file, as used in the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的示例是通过以下`.svg`文件完成的，作为相应的`red-circle.svg`文件，如下面的代码片段中所使用的：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to use it
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用它
- en: Although it is highly recommended that you use a professional vector editor
    software when composing complex SVG graphics, such as Inkspace or Adobe Illustrator,
    this section will walk you through the basics of SVG composition. This way you
    can draw basic shapes and graphs by hand, or at least be familiar with the fundamentals
    of SVG drawing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管强烈建议在组合复杂的SVG图形时使用专业的矢量编辑软件，比如Inkspace或Adobe Illustrator，但本节将带你了解SVG组合的基础知识。这样你就可以手工绘制基本的形状和图表，或者至少熟悉SVG绘制的基础知识。
- en: Remember that whether you are importing your SVG graphics into your HTML through
    any of the methods described previously, drawing them inline, or even creating
    them dynamically through JavaScript, you will need to include the XML namespace
    to the root `svg` element. This is a common mistake made by newcomers to SVG,
    which may result in your graphics not showing up on the page.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，无论你是通过之前描述的任何方法将SVG图形导入到HTML中，内联绘制它们，甚至通过JavaScript动态创建它们，你都需要将XML命名空间包含到根`svg`元素中。这是SVG新手常犯的一个错误，可能导致你的图形在页面上不显示。
- en: The primitive shapes we can draw with SVG are rectangle, circle, ellipse, line,
    polyline, polygon, and path. Some of these primitives share attributes (such as
    width and height), while others have attributes that are unique to that shape
    (such as the radius of a circle). Everything you see in an SVG graphic is a result
    of these primitives used together in some combination.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用SVG绘制的原始形状有矩形、圆、椭圆、线、折线、多边形和路径。其中一些原始形状共享属性（如宽度和高度），而其他一些具有特定于该形状的属性（如圆的半径）。在SVG图形中看到的一切都是这些原始形状在某种组合中使用的结果。
- en: Everything in SVG is drawn inside an SVG canvas, which is defined by the parent
    `svg` tag. This canvas is always rectangular, even though the shapes inside it
    can be of any shape that can be created by any of the primitives. Also, the canvas
    has its own coordinate system, which places the point origin at the top left corner
    of the canvas. The width and height of the canvas (determined by the parent `svg`
    tag) determines the dimensions of the drawing area, and all the (x, y) points
    reference inside the canvas (by all the child elements of `svg`) are relative
    to that point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SVG中的一切都是在SVG画布内绘制的，由父`svg`标签定义。这个画布总是矩形的，即使它内部的形状可以是由任何原始形状创建的任何形状。此外，画布有自己的坐标系，将原点放在画布的左上角。画布的宽度和高度（由父`svg`标签确定）决定了绘图区域的尺寸，所有`svg`的子元素内部的（x，y）点都是相对于该点的。
- en: 'As a boilerplate for the following examples, we''ll assume an external `svg`
    file, where we''ll set the canvas size to 1000 x 1000 pixels, and draw away inside
    it. To view the final result of each example, you can use any one of the methods
    described in the previous section on how to load an SVG image into an HTML file.
    the following code snippet shows how the `svg` tag is defined:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为以下示例的样板，我们将假设有一个外部的`svg`文件，我们将把画布大小设置为1000 x 1000像素，并在其中绘制。要查看每个示例的最终结果，你可以使用前一节中描述的任何一种方法来将SVG图像加载到HTML文件中。以下代码片段显示了如何定义`svg`标签：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Drawing a rectangle is as simple as it can get with SVG. Simply specify a width
    and height to a `rect` element, and that''s it. Optionally, we can specify a stroke
    width and stroke color (where a stroke is the same thing as a border), along with
    a background color. Take a look at the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用SVG绘制矩形就像它可以得到的那样简单。只需为`rect`元素指定宽度和高度，就可以了。可选地，我们可以指定描边宽度和描边颜色（其中描边就是边框），以及背景颜色。看一下下面的代码：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By default, every shape is rendered at the origin (x = 0, y = 0), with no stroke
    (`stroke-width = 0`), and a background color (fill) set to all black (hexadecimal
    value of #000000, and RGB value of 0, 0, 0).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个形状都在原点（x = 0，y = 0）处呈现，没有描边（`stroke-width = 0`），并且背景颜色（填充）设置为全黑（十六进制值为#000000，RGB值为0,
    0, 0）。
- en: The circle is drawn with a `circle` tag by specifying at least three attributes,
    namely an *x* and *y* position (denoted by `cx` and `cy`), along with a radius
    value (denoted by the letter `r`). The center of the circle is placed at position
    (`cx`, `cy`), and the radius length does not take into account the width of the
    stroke, if one is present.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 圆是通过指定至少三个属性来绘制的，即*x*和*y*位置（由`cx`和`cy`表示），以及半径值（由字母`r`表示）。圆的中心位于位置（`cx`，`cy`），半径长度不考虑描边的宽度，如果存在的话。
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will notice that by default, just like positioned DOM elements, every node
    has the same z-index. Thus, if two or more elements overlap, whatever element
    was drawn last (meaning that it is positioned farther from the parent than its
    sibling element) is rendered on top.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，默认情况下，就像定位的DOM元素一样，每个节点都具有相同的z-index。因此，如果两个或更多元素重叠，无论哪个元素最后被绘制（意味着它在父元素之外的位置更远），都会呈现在顶部。
- en: Ellipses are very similar to circles, with the only difference being that they
    have a radius for each direction (vertical and horizontal). Other than that minor
    detail, drawing an ellipse is the exact same as drawing a circle. Of course, we
    can simulate circles by drawing ellipses that have both radii of the same length.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆与圆非常相似，唯一的区别是它们在每个方向（垂直和水平）都有一个半径。除此之外，绘制椭圆与绘制圆是完全相同的。当然，我们可以通过绘制两个半径长度相同的椭圆来模拟圆。
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With those basic shapes out of the way, we will now proceed to drawing more
    complex shapes. Instead of just following a few predefined points and lengths,
    we now get to choose exactly where each point goes in the shapes we'll be drawing.
    While this makes it slightly harder to draw shapes by hand, it also makes the
    possibilities much more extensive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些基本形状，我们现在将继续绘制更复杂的形状。现在不仅仅是按照几个预定义的点和长度进行绘制，我们可以选择在我们将要绘制的形状中准确放置每个点。虽然这使得手工绘制形状稍微困难，但也使得可能性更加广泛。
- en: Drawing a line is both simple and fast. Simply specify two points within the
    SVG coordinate space, and you have a line. Each point is specified by an enumerated
    (x, y) pair.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一条线既简单又快速。只需在SVG坐标空间内指定两个点，就可以得到一条线。每个点由一个枚举的（x，y）对指定。
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next we'll cover the polyline, which is an extension of a regular line. The
    difference between a line and a polyline is that, as the name implies, a polyline
    is a collection of lines. While a regular line only takes in two coordinate points,
    a polyline takes two or more points, with a line connecting them in order. Also,
    if we specify a fill color for the polyline, the last point will be connected
    to the first, and the shape formed by that enclosed area will have the fill applied
    to it. Obviously, if no fill is specified, the polyline is rendered as a simple
    shape made out of nothing but straight lines.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将介绍折线，它是常规线的扩展。线和折线之间的区别在于，正如其名称所示，折线是一组线的集合。而常规线只接受两个坐标点，折线接受两个或更多点，并按顺序连接它们。此外，如果我们为折线指定了填充颜色，最后一个点将连接到第一个点，并且由该封闭区域形成的形状将应用填充。显然，如果没有指定填充，折线将呈现为由直线组成的简单形状。
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next shape we''ll look at is the polygon. Scarily similar to a polyline,
    the polygon is drawn exactly in the same way as a polyline, but with two very
    important distinctions. First, a polygon must have at least three points. Secondly,
    a polygon is always a closed shape. This means that the last point and the first
    point of the sequence are physically connected, whereas in a polyline, that connection
    is only made by the fill, if one is assigned to the polyline:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的下一个形状是多边形。与折线非常相似，多边形的绘制方式与折线完全相同，但有两个非常重要的区别。首先，多边形必须至少有三个点。其次，多边形总是一个封闭的形状。这意味着序列的最后一个点和第一个点在物理上是连接的，而在折线中，只有通过填充才会进行连接，如果为折线分配了填充的话：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![How to use it](img/6029OT_04_03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用](img/6029OT_04_03.jpg)'
- en: The polyline is shown on the left side of the preceding screenshot, while the
    shape on the right is a polygon that uses the exact same points to describe its
    position and orientation. The only difference between the two is that a polygon
    is forcefully closed. Of course, we can also simulate that behavior using a polyline
    by simply manually connecting the last point with the first.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图的左侧显示了折线，而右侧的形状是使用完全相同的点来描述其位置和方向的多边形。两者之间唯一的区别是多边形是强制闭合的。当然，我们也可以通过简单地手动连接最后一个点和第一个点来模拟这种行为，使用折线。
- en: SVG also allows us to draw very complex shapes with smooth curves, instead of
    the line-based shapes covered previously. To do so, we can use the path element,
    which might be a little complex at first, as it has several different attributes
    we can manipulate. One key feature of paths is that it allows us to either move
    the pointer to a location within the coordinate space, or to draw a line to a
    point.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SVG还允许我们使用平滑曲线来绘制非常复杂的形状，而不是之前介绍的基于线的形状。为此，我们可以使用路径元素，起初可能有点复杂，因为它有几个不同的属性可以操作。路径的一个关键特点是它允许我们将指针移动到坐标空间内的位置，或者画一条线到一个点。
- en: 'All path attributes that describe the path are put inside the `d` attribute.
    These attributes are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 描述路径的所有路径属性都放在`d`属性中。这些属性如下：
- en: '**M**: move to'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M**：移动到'
- en: '**L**: line to'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：线到'
- en: '**H**: horizontal line to'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H**：水平线到'
- en: '**V**: vertical line to'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**V**：垂直线到'
- en: 'C: curve to'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C**：曲线到'
- en: '**S**: smooth curve to'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：平滑曲线到'
- en: '**Q**: quadratic Bezier curve'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Q**：二次贝塞尔曲线'
- en: '**T**: smooth quadratic Bezier curve'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T**：平滑二次贝塞尔曲线'
- en: '**A**: elliptical arc'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**：椭圆弧'
- en: '**Z**: close path'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z**：关闭路径'
- en: 'These attributes can be repeated as many times as needed, although it may be
    a good idea to break down the overall drawing into multiple smaller paths. Some
    reasons to separate a larger drawing into multiple paths are to make the figure
    more manageable, easier to troubleshoot, and easier to understand. The code for
    this is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性可以根据需要重复多次，尽管将整体绘图分解为多个较小的路径可能是个好主意。将较大的绘图分成多个路径的一些原因是使图形更易管理，更易于故障排除和更易于理解。代码如下：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unless you practice and train yourself to look at path descriptions, it may
    be hard to just look at those codes and visualize the path. Take your time and
    look at each attribute individually. The preceding example first moves the pointer
    to point (100, 100), then a line is drawn from that point to another point (100,
    300). This makes a vertical line from the last position where the pointer was,
    to the point specified by the line to attribute. Next, the cursor is changed from
    where it was to a new position (250, 100). Note that simply moving the cursor
    doesn''t affect any previous drawing calls, nor does it do any drawing at that
    time. Finally, a second vertical line is drawn to point (250, 300). A third line
    is drawn at an equal distance from the first line. This can be seen in the following
    screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你练习并训练自己查看路径描述，否则很难仅凭这些代码来可视化路径。花点时间，逐个查看每个属性。前面的示例首先将指针移动到点(100, 100)，然后从该点画一条线到另一个点(100,
    300)。这样就从指针上次位置到由线条指定的点画了一条垂直线。接下来，光标从原来的位置改变到一个新位置(250, 100)。请注意，简单地移动光标不会影响任何以前的绘图调用，也不会在那时进行任何绘图。最后，画了第二条垂直线到点(250,
    300)。第三条线与第一条线的距离相等。这可以在以下截图中看到：
- en: '![How to use it](img/6029OT_04_04.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用](img/6029OT_04_04.jpg)'
- en: Note that whatever values we define for fill, stroke, stroke width, and so on,
    are applied to the entire path. The solution to the problem of wanting different
    fill and stroke values is to create additional paths.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们为填充、描边、描边宽度等定义的任何值都将应用于整个路径。想要不同的填充和描边值的解决方案是创建额外的路径。
- en: 'Drawing curves is still a bit more complicated. A curve requires three values,
    namely two control points, and the final point to which the line is drawn. To
    illustrate how control points work, observe the following example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制曲线仍然有点复杂。曲线需要三个值，即两个控制点和最终绘制线的点。为了说明控制点的工作原理，请观察以下示例：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While executing the preceding code as shown in the following screenshot, we
    can see the relationship between control points and the curvature of a line:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述代码时，如下截图所示，我们可以看到控制点与线的曲率之间的关系：
- en: '![How to use it](img/6029OT_04_05.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用](img/6029OT_04_05.jpg)'
- en: This is a cubic Bezier curve where the red lines show where the first and last
    curve points connect with the control points.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个三次贝塞尔曲线，红线显示了第一个和最后一个曲线点与控制点连接的位置。
- en: Drawing curves just the way you want is a rather complex problem to solve by
    hand. Different curve functions behave different from each other, so be sure to
    experiment with them all until you get a good feel for how they each work. Remember
    that although it is a good idea to have at least some understanding of how these
    curves and other drawing primitives work, it is highly recommended that you always
    use appropriate software to help you create your drawings. Ideally, we would use
    our creativity to create the drawing, and let the computer figure out how to represent
    that using SVG.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 手动绘制所需的曲线正是一个相当复杂的问题。不同的曲线函数之间的行为不同，因此一定要尝试它们，直到你对它们的工作方式有了很好的感觉。请记住，尽管至少要有一些了解这些曲线和其他绘图原语的工作方式是个好主意，但强烈建议您始终使用适当的软件来帮助您创建您的绘图。理想情况下，我们会利用我们的创造力来创建绘图，让计算机来找出如何使用SVG表示它。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The description attributes for paths can be specified using either a lowercase
    or an uppercase letter. The difference is that an uppercase letter means that
    the point is absolute, and a lowercase letter means that the point is relative.
    This concept of relative and absolute points is not quite the same as in HTML,
    where a relative offset means that the destination point is relative to its own
    original location, and an absolute point is one that's completely relative to
    the element's parent.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 路径的描述属性可以使用小写字母或大写字母来指定。区别在于大写字母表示点是绝对的，小写字母表示点是相对的。相对和绝对点的概念与HTML中的不完全相同，其中相对偏移意味着目标点相对于其自身原始位置的相对位置，而绝对点是完全相对于元素的父级的位置。
- en: In SVG world, an absolute point is relative to the canvas' origin, and a relative
    point is relative to the last point defined. For example, if you move the pointer
    to location (10, 10), then do a relative move with values of 10 15, the pointer
    will end up, not at location (10, 15), but 10 units away from the x position,
    and 15 units away from the y position. The new position of the pointer would then
    be location (20, 25).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在SVG世界中，绝对点是相对于画布的原点，而相对点是相对于上次定义的点。例如，如果将指针移动到位置(10, 10)，然后使用值为10 15进行相对移动，指针将最终停在位置(10,
    15)而不是位置(10, 15)，而是在x位置上离开10个单位，在y位置上离开15个单位。然后指针的新位置将是位置(20, 25)。
- en: Finally, SVG is capable of rendering text to the screen. Imagine how time consuming
    it would be to render each letter by hand using lines and paths. Thankfully, the
    SVG API specifies a very simple interface for text rendering.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，SVG能够将文本呈现到屏幕上。想象一下，如果要使用线条和路径手动渲染每个字母会耗费多少时间。幸运的是，SVG API规定了一个非常简单的文本呈现接口。
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, the SVG standard does much more than simply define shapes, lines, paths,
    and colors. The specification also defines groups of elements, whereby one may
    literally group a collection of nodes, so that they can possibly all be treated
    together as a single unit. There are also transformations, animations, gradients,
    and even photo filters, all of which can be applied to the simple primitives that
    are described previously. Take a look at the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SVG标准不仅仅是定义形状、线条、路径和颜色。规范还定义了元素组，可以将一组节点组合在一起，使它们可能作为一个单一单元一起处理。还有变换、动画、渐变，甚至是照片滤镜，所有这些都可以应用于之前描述的简单基元。看一下下面的代码：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Drag-and-drop
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放
- en: Although creating drag-and-drop functionality manually is not a very challenging
    ordeal, HTML5 takes drag-and-drop to a whole new level. With the new API, we're
    given the ability to do so much more than just let the browser handle the dragging
    and dropping actions. The interface allows for customizing the exact way that
    things are dragged, how the dragging action looks, what data is carried with the
    draggable object, and so on. Plus, not having to worry about how the low level
    events are tracked in different platforms and devices is a nice, welcome touch.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管手动创建拖放功能并不是一个非常具有挑战性的任务，但HTML5将拖放提升到了一个全新的水平。通过新的API，我们可以做的远不止让浏览器处理拖放操作。该接口允许自定义拖动的方式，拖动动作的外观，可拖动对象携带的数据等等。此外，不必担心在不同平台和设备上跟踪低级事件的方式是一个不错的、受欢迎的功能。
- en: For the curious reader, the way we could implement our own drag-and-drop behavior
    is really quite simple; first, we listen for a mouse down event on the element
    we want to drag. When that happens, we set a mouse down flag, which we unset once
    the mouse up event is fired, whether on the element we wish to drag or not. Next,
    we listen for a mouse movement event, where we check if the mouse is down. If
    the mouse is moving while the mouse down flag is set, we have a drag motion. One
    way to handle it is to update the position of the draggable element every time
    the mouse moves, then setting the element's position when the mouse up event is
    called. Of course, there are several small details that we'd need to keep track
    of, or at least be mindful of, such as how to detect where the draggable element
    was dropped, and how to move it back to its original position if needed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的读者来说，我们可以实现自己的拖放行为的方式实际上非常简单；首先，我们监听要拖动的元素上的鼠标按下事件。当这种情况发生时，我们设置一个鼠标按下标志，一旦鼠标抬起事件被触发，无论是在我们希望拖动的元素上还是其他地方，我们就取消这个标志。接下来，我们监听鼠标移动事件，检查鼠标是否按下。如果鼠标在鼠标按下标志被设置的情况下移动，我们就有了一个拖动动作。处理它的一种方式是每次鼠标移动时更新可拖动元素的位置，然后在鼠标抬起事件被调用时设置元素的位置。当然，还有一些小细节我们需要跟踪，或者至少要注意，比如如何检测可拖动元素被放置的位置，以及如何在需要时将其移回原来的位置。
- en: The good news is that the drag-and-drop API provided by the browser is very
    flexible, and extremely efficient. Since this feature was first introduced, a
    lot of developers continued to use JavaScript implementations of it for various
    reasons, but mostly because a lot of people felt that the native HTML5 version
    was a bit hard to use, buggy, or not quite as practical as the version provided
    by whatever other library they chose to use. However, today the API is widely
    supported, fairly polished, and highly recommended.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，浏览器提供的拖放API非常灵活和高效。自从这个功能首次引入以来，许多开发人员继续使用JavaScript实现它，原因有很多，但主要是因为很多人觉得原生的HTML5版本使用起来有点困难、有bug，或者不如他们选择使用的其他库提供的版本实用。然而，如今这个API得到了广泛支持，相当成熟，并且深受推荐。
- en: How to use it
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用它
- en: 'Now, the way that the drag-and-drop API works is very straight forward. First
    we need to mark one or more elements as draggable by setting the `draggable` attribute
    to true for those elements, as shown in the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拖放API的工作方式非常直接。首先，我们需要通过将`draggable`属性设置为true来标记一个或多个元素为可拖动，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Just this step alone will make those elements all draggable. Of course, that
    isn''t of any use unless we have a place to drop those elements. Believe it or
    not, we actually can drop a dragged element anywhere. The problem is that we don''t
    have any code in place to handle the event of something being dropped. We can
    register such events on any element, including the body tag, for example. This
    is shown in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅这一步就可以使这些元素都可拖动。当然，除非我们有一个放置这些元素的地方，否则这没有任何用处。信不信由你，我们实际上可以在任何地方放置一个被拖动的元素。问题在于，我们没有任何代码来处理放置元素的事件。我们可以在任何元素上注册这样的事件，包括body标签，例如。下面的代码中展示了这一点：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we append a new list element to the unordered list every time
    a list element is dropped anywhere on the page, since every element on the page
    is a child of the body node. Also, whenever a draggable element hovers over the
    body element, we add a CSS class called `dropme`, which is meant to give the user
    a visual feedback letting them know that the drag event is taking place. When
    the draggable is dropped, we remove that class from the body element indicating
    the end of the drag action.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每当一个列表元素在页面的任何地方被放置时，我们都会向无序列表追加一个新的列表元素，因为页面上的每个元素都是body节点的子元素。此外，每当可拖动的元素悬停在body元素上时，我们会添加一个名为`dropme`的CSS类，这是为了给用户提供一个视觉反馈，让他们知道拖动事件正在发生。当可拖动的元素被放置时，我们会从body元素中移除该类，表示拖动动作的结束。
- en: 'One thing we can do with the drag and drop API is transfer data between objects.
    This data can be a string, or any data type that can be converted into a string.
    We do this by setting the desired data to the `dataTransfer` object available
    to us during the drag action. The data must be set when the drag start function
    is fired by the system. The key associated with the `dataTransfer` data can be
    any string of our choosing as shown in the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拖放API的一种方法是在对象之间传输数据。这些数据可以是字符串，或者可以转换为字符串的任何数据类型。我们可以通过在拖动操作期间设置`dataTransfer`对象来实现这一点。数据必须在系统触发拖动开始函数时设置。与`dataTransfer`数据相关联的键可以是我们选择的任何字符串，如下面的代码所示。
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter touched on the very important topic of browser support and code
    portability. As productive and efficient developers, we should always strive to
    create maintainable code. Thus, the more browsers we can support with the same
    code base, the more efficient we are. In order to help us achieve this goal, we
    can create abstractions that encapsulate code that varies from browser to browser,
    as well as from device to device. Another alternative is to use existing polyfills
    that other people have written, and thus accomplish the same thing, but with possibly
    less effort and more reliability.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及了浏览器支持和代码可移植性这个非常重要的话题。作为高效的开发者，我们应该始终努力创建可维护的代码。因此，我们支持的浏览器越多，我们就越高效。为了帮助我们实现这个目标，我们可以创建封装了从浏览器到浏览器，从设备到设备都有所不同的代码的抽象。另一个选择是使用其他人编写的现有polyfill，从而以可能更少的工作量和更可靠地实现相同的功能。
- en: The game we built in this chapter makes use of three HTML5 APIs, namely drag-and-drop,
    web audio, and SVG. Native drag-and-drop provided in HTML5 is a lot more than
    simply dragging DOM elements around the screen. With it we can customize a lot
    of the visual elements related to the drag-and-drop action, as well as specify
    data that is carried through the draggable element and the target where it is
    dropped.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章构建的游戏利用了三个HTML5 API，即拖放、Web音频和SVG。HTML5提供的本机拖放远不止是在屏幕上拖动DOM元素。通过它，我们可以定制与拖放操作相关的许多可视元素，以及指定通过可拖动元素和放置目标携带的数据。
- en: Web audio allows us to manage multiple audio entities. Although most modern
    browsers support more than one audio format, there is not yet a single audio format
    that is supported by all of these modern web browsers. Because of that, it is
    recommended that we link at least two different versions of each audio file we
    wish to play through the API, so that all modern browsers are capable of playing
    that file. Although we can specify multiple sources for each audio element (where
    each source is a different version of the same file, but encoded in a different
    format), the browser is smart enough to only download the one file that it supports
    and knows how to play, or the one file that is most appropriate for it to playback.
    This makes load time shorter, and saves both the user and your server quite a
    bit of bandwidth.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Web音频允许我们管理多个音频实体。虽然大多数现代浏览器支持多种音频格式，但目前还没有一种音频格式被所有这些现代Web浏览器支持。因此，建议我们通过API链接每个音频文件的至少两种不同版本，以便所有现代浏览器都能播放该文件。虽然我们可以为每个音频元素指定多个来源（其中每个来源是相同文件的不同版本，但以不同格式编码），但浏览器足够智能，只下载它支持和知道如何播放的文件，或者对它来说最合适的文件。这样可以缩短加载时间，节省用户和服务器的带宽。
- en: Scalable Vector Graphics is an XML-based description language for two dimensional
    graphics, which can be embedded in a web page in a variety of ways. Since all
    of the graphical elements are nothing more than XML nodes rendered by the browser
    onto an SVG canvas, each of these graphical elements are managed by the browser,
    and can, therefore, be styled through CSS, and have user input events linked to
    them. We can also register callback functions with each SVG primitive for events
    generated by the browser, such as when the element is loaded, focused, blurred,
    and so on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩矢量图形是一种基于XML的二维图形描述语言，可以以多种方式嵌入到网页中。由于所有的图形元素都不过是由浏览器渲染到SVG画布上的XML节点，每个图形元素都由浏览器管理，因此可以通过CSS进行样式设置，并且可以与用户输入事件相关联。我们还可以为由浏览器生成的事件（比如元素加载、聚焦、失焦等）注册回调函数。
- en: Finally, we saw how none of the timer functions provided by JavaScript are at
    all appropriate for fast games. Thankfully, there is a new rendering API that
    we'll cover in the next chapter that can be used to overcome the deficiencies
    of JavaScript timers. Using the request animation frame interface allows us to
    render our games much more efficiently because the browser itself manages the
    timer that is used, as well as allows our games to be more CPU-friendly by not
    rendering a screen that is not visible (such as when the browser is minimized,
    or a different tab is focused).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到JavaScript提供的定时器函数都不适合快速游戏。幸运的是，有一个新的渲染API，我们将在下一章中介绍，可以用来克服JavaScript定时器的不足。使用请求动画帧接口可以让我们更有效地渲染游戏，因为浏览器本身管理所使用的定时器，并且可以使我们的游戏更加CPU友好，不会渲染不可见的屏幕（比如当浏览器最小化或者焦点在不同的标签页上时）。
- en: In the next chapter, we will write a traditional snake game, with the main focus
    points being rendering the entire game scene using the canvas API (as opposed
    to using raw DOM elements), application cache for offline game play, web workers,
    and the new and powerful JavaScript typed arrays. As alluded earlier in this chapter,
    we will also take a look at the new way to render very dynamic graphics in HTML5
    apps, using requestAnimationFrame to access the browser's very own rendering pipeline.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写一个传统的贪吃蛇游戏，主要关注点是使用Canvas API渲染整个游戏场景（而不是使用原始DOM元素），应用程序缓存以进行离线游戏，Web
    Workers以及新而强大的JavaScript类型数组。正如本章前面提到的，我们还将看一下在HTML5应用程序中以新的方式渲染非常动态的图形，使用requestAnimationFrame来访问浏览器自己的渲染管道。
