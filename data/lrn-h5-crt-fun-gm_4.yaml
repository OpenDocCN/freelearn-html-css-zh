- en: Chapter 4. Using HTML5 to Catch a Snake
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用HTML5捕捉蛇
- en: This chapter is the first part of a two-part series, where we'll build the first
    version of a game, and then spice it up with more HTML5 APIs in the next chapter.
    Both versions will be complete and playable, but since covering all of the APIs
    in the same game within one chapter would make for a very large chapter, we'll
    break things up into smaller chunks, and write two separate games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是一个两部分系列的第一部分，在这里我们将构建游戏的第一个版本，然后在下一章中使用更多的HTML5 API来增加趣味性。两个版本都是完整可玩的，但是在同一章节中涵盖所有API会使章节变得非常庞大，因此我们将事情分解成更小的块，并编写两个单独的游戏。
- en: The first version of the game will cover five new concepts, namely, **HTML5's
    2D canvas API**, **offline application cache**, **web workers**, **typed arrays**,
    and **requestAnimationFrame**. The canvas element allows us to draw 2D as well
    as 3D graphics, and manipulate image data at a very low level, gaining access
    to individual pixel information. Offline application cache, also known as app
    cache, allows us to cache specific assets from a server into the user's browser,
    so that the application can work even when no internet access is available. Web
    workers is a thread-like mechanism that allows us to execute JavaScript code in
    a separate thread from the main UI thread. This way, the user interface is never
    blocked, and users don't see a **page not responsive** warning. `Typed arrays`
    is a new native JavaScript data type similar to arrays, but much more efficient,
    and specifically designed to handle binary data. Finally, requestAnimationFrame
    is an API offered by the browser to help us perform time-based animation. Instead
    of using a JavaScript timer (`setTimeout` or `setInterval`) multiple times a second
    in order to perform animations, we can let the browser do the heavy lifting, optimizing
    the animation beyond what we could achieve in JavaScript alone.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的第一个版本将涵盖五个新概念，即**HTML5的2D画布API**，**离线应用缓存**，**Web Workers**，**类型数组**和**requestAnimationFrame**。画布元素允许我们绘制2D和3D图形，并以非常低的级别操作图像数据，获得对单个像素信息的访问。离线应用缓存，也称为应用缓存，允许我们将特定资产从服务器缓存到用户的浏览器中，以便应用程序即使在没有互联网访问时也能工作。Web
    Workers是一种类似线程的机制，允许我们在与主UI线程分离的单独线程中执行JavaScript代码。这样，用户界面永远不会被阻塞，用户也不会看到**页面无响应**的警告。`Typed
    arrays`是一种新的本机JavaScript数据类型，类似于数组，但效率更高，专门设计用于处理二进制数据。最后，requestAnimationFrame是浏览器提供的一个API，帮助我们执行基于时间的动画。我们可以让浏览器进行繁重的工作，优化动画，超出我们在JavaScript中单独实现的范围，而不是多次每秒使用JavaScript计时器（`setTimeout`或`setInterval`）来执行动画。
- en: The game
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: 'You''ve certainly seen or played this game before. You control a snake in a
    2D grid only moving up, down, left, or right. When you change the direction in
    which the snake''s head is moving, each part of the snake''s body gradually changes
    direction as well, following the head. If you run into a wall, or into the snake''s
    own body, you lose. If you guide the snake''s head over a fruit, the snake''s
    body gets larger. The larger the snake gets, the more challenging the game becomes.
    Additionally, the speed at which the snake moves can be increased for an extra
    challenge. In order to stay true to the old school nature of this classic game,
    we opted for old school graphics and typefaces, as shown in following screenshot:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定以前见过或玩过这个游戏。你在一个2D网格中控制一条蛇，只能向上、下、左或右移动。当你改变蛇头移动的方向时，蛇身的每一部分都会逐渐改变方向，跟随着头部。如果你撞到墙壁或蛇的身体，你就输了。如果你引导蛇头经过一个水果，蛇的身体就会变大。蛇变得越大，游戏就越具挑战性。此外，蛇移动的速度可以增加，增加额外的挑战。为了保持这个经典游戏的老派特性，我们选择了老派的图形和字体，如下面的截图所示：
- en: '![The game](img/6029OT_05_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![游戏](img/6029OT_05_01.jpg)'
- en: The image shows the look and feel of the game. When the game first starts, the
    snake has a total body length of zero—only the head is present. At first, the
    snake is randomly placed somewhere within the game grid, and is not given a starting
    direction to move towards. The player can control the snake with the arrow keys,
    and once the snake starts moving in a particular direction, the snake cannot be
    stopped. For example, if the snake is moving to the right, the player can move
    it up or down (but not backwards). If the player wishes to move the snake to the
    left (once it is currently moving to the right), the only possible ways are to
    first move the snake up, then to the left, or down, then left.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图像显示了游戏的外观和感觉。游戏刚开始时，蛇的总体长度为零——只有头部存在。一开始，蛇会随机放置在游戏网格的某个位置，并且没有给予一个初始移动方向。玩家可以用箭头键控制蛇，一旦蛇开始朝特定方向移动，就无法停止。例如，如果蛇向右移动，玩家可以将其向上或向下移动（但不能向后）。如果玩家希望将蛇向左移动（当它当前向右移动时），唯一可能的方法是先将蛇向上移动，然后向左移动，或者向下移动，然后向左移动。
- en: Whenever there are no fruits on the game grid, one is randomly added to the
    grid. That fruit stays there until the player eats it, at which point, a new fruit
    is added to the grid. For added difficulty, we could make a fruit disappear, if
    the snake can't get to it within so many seconds.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每当游戏网格上没有水果时，会随机添加一个水果到网格中。该水果会一直留在那里，直到玩家吃掉它，此时会在网格中添加一个新的水果。为增加难度，如果蛇在几秒内无法到达水果，我们可以让水果消失。
- en: API usage
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API使用
- en: A general description and demonstration of each of the APIs used in the game
    are given as follows. For an explanation of how each of the functionality was
    incorporated into the final game, look at the following code section. For the
    complete source code for this game, check out the book's page at the Packt Publishing
    website.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中使用的每个API的一般描述和演示如下。要了解每个功能是如何整合到最终游戏中的，请查看以下代码部分。有关此游戏的完整源代码，请查看Packt Publishing网站上的书页。
- en: Before `requestAnimationFrame` was introduced, the main method developers used
    to create animations in JavaScript was by using a timer to repeatedly call a function
    that gradually updated attributes of the element(s) being animated. While this
    is a straightforward method, what the browser provides through `requestAnimationFrame`
    has a couple of added benefits. First of all, the browser uses a single animation
    cycle to handle the rendering of a page, so any rendering we do using that same
    cycle will result in a smoother animation, since the browser can optimize the
    animation for us. Also, since the rendering would be done by the browser's internal
    rendering mechanism, our animation would not run when the browser tab running
    our animation is not shown. This way we don't waste battery life animating something
    that is not even visible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入`requestAnimationFrame`之前，开发人员在JavaScript中创建动画的主要方法是使用定时器重复调用一个逐渐更新正在动画的元素的属性的函数。虽然这是一种简单直接的方法，但浏览器通过`requestAnimationFrame`提供的一些额外好处。首先，浏览器使用单个动画周期来处理页面的渲染，因此我们使用相同的周期进行的任何渲染都将导致更平滑的动画，因为浏览器可以为我们优化动画。此外，由于渲染将由浏览器的内部渲染机制完成，我们的动画在运行我们的动画的浏览器选项卡未显示时不会运行。这样我们就不会浪费电池寿命来动画显示不可见的内容。
- en: How to use it
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用
- en: Using `requestAnimationFrame` is very simple, and similar to `setTimeout`. We
    call the `requestAnimationFrame` function on the global window object, passing
    a callback function that is executed whenever the browser is ready to run another
    animation cycle. When the callback is invoked, it is passed in a timestamp, which
    is normally used inside the animation function we register with `requestAnimationFrame`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`requestAnimationFrame`非常简单，类似于`setTimeout`。我们在全局窗口对象上调用`requestAnimationFrame`函数，传递一个回调函数，该函数在浏览器准备好再次运行动画周期时执行。当调用回调函数时，会传递一个时间戳，通常在我们使用`requestAnimationFrame`注册的动画函数内部使用。
- en: There are two common ways in which `requestAnimationFrame` is used, both of
    which achieve the same result. In the first method, you define your animation
    function with no references to `requestAnimationFrame`. Then, a second function
    calls that animation function, followed by a call to `requestAnimationFrame`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`有两种常见的使用方式，两种方式都能实现相同的结果。在第一种方法中，您定义动画函数时不引用`requestAnimationFrame`。然后，第二个函数调用该动画函数，然后调用`requestAnimationFrame`。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second pattern that is commonly used is very similar, except that it only
    includes the main animation function. That function itself takes care of calling
    `requestAnimationFrame` when needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的第二种模式非常相似，只包括主要的动画函数。该函数本身负责在需要时调用`requestAnimationFrame`。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reason that the time argument is useful is, because most of the time, you
    want the animation to run more or less at the same rate on different computers.
    `requestAnimationFrame` attempts to run as close to 60 times per second as possible.
    However, based on the code you execute inside it, that rate may drop significantly.
    Obviously, faster hardware would be able to execute your code much faster, and
    thus, display it to the screen more often than some slower hardware would. In
    order to make up for this possibility, we can use actual time to control how often
    the animation code runs. This way, we can specify a cap refresh rate, which, if
    a particular computer is able to run faster than this rate, can simply slowdown
    that computer, and all users experience about the same animation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 时间参数有用的原因是，因为大多数情况下，您希望动画在不同的计算机上以更多或更少相同的速度运行。`requestAnimationFrame`尝试以尽可能接近每秒60次的速度运行。但是，根据您在其中执行的代码，该速率可能会显著下降。显然，更快的硬件能够更快地执行您的代码，并因此比一些较慢的硬件更频繁地显示在屏幕上。为了弥补这种可能性，我们可以使用实际时间来控制动画代码运行的频率。这样，我们可以指定一个刷新率上限，如果特定计算机能够以比这个速率更快的速度运行，可以简单地减慢该计算机的速度，所有用户都能体验到大致相同的动画。
- en: 'One possible implementation of this technique is shown in the following steps.
    Although it may seem like a lot of steps, the concept is really quite simple.
    The gist of it is this: we set two variables, one that keeps track of the cap
    speed that the animation will run (measured in **frames per second** (**fps**)),
    and the other keeps track of when the last time was, that a frame was rendered.
    Then, whenever the animation function executes, we take the current time, subtract
    the last time that a frame was rendered, and check if their difference is greater
    than, or equal to the ideal fps we have chosen. If it is less than our desired
    fps, we don''t animate anything, but still register `requestAnimationFrame` to
    call us back in the future.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的一种可能实现如下所示。虽然这可能看起来像是很多步骤，但概念实际上非常简单。其要点是：我们设置两个变量，一个用于跟踪动画运行的速度上限（以**每秒帧数**（**fps**）为单位），另一个用于跟踪上次渲染帧的时间。然后，每当动画函数执行时，我们获取当前时间，减去上次渲染帧的时间，并检查它们的差是否大于或等于我们选择的理想fps。如果小于我们期望的fps，我们不会进行任何动画，但仍会注册`requestAnimationFrame`在未来回调我们。
- en: This we do until enough time has elapsed so that our frames per second rate
    can be achieved (in other words, so that the fastest frame rate we can possibly
    run would be our fps). If the system is running slower than that, there's nothing
    we can do about it. What this technique does is control the maximum speed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做直到经过足够的时间，以便我们可以实现每秒帧数（换句话说，我们可能运行的最快帧速率就是我们的fps）。如果系统运行速度比这慢，我们无能为力。这种技术的作用是控制最大速度。
- en: Once `requestAnimationFrame` has called our animation function, and enough time
    has passed since the last time a frame was rendered, we update all the data we
    need to, for the animation, render the animation to the screen (or let the browser
    do it, if it can), and update the variable that keeps track of when a frame was
    last updated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`requestAnimationFrame`调用了我们的动画函数，并且自上次渲染帧以来已经过了足够的时间，我们就会更新所有需要的数据，用于动画渲染到屏幕上（或者让浏览器完成，如果可以的话），并更新跟踪上次更新帧的变量。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This simple code snippet creates a **Document Object Model** (**DOM**) element,
    sets some text to it, and registers an onclick handler to it. When the click handler
    is called, we reset some styling properties of the element (namely, placing the
    element on the far left side of the screen), and get the animation routine started.
    The animation routine moves the element to the right a little bit every frame,
    until the element has reached the right side of the screen. If the element has
    not yet reached the right side of the screen, or in other words, if the animation
    is not yet completed, we perform the animation (move the element a few pixels),
    then register itself with `requestAnimationFrame`, thus continuing the cycle.
    Once the animation is complete, we simply stop calling `requestAnimationFrame`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的代码片段创建了一个**文档对象模型**（**DOM**）元素，为其设置一些文本，并为其注册了一个点击处理程序。当调用点击处理程序时，我们重置元素的一些样式属性（即将元素放在屏幕的最左侧），并启动动画例程。动画例程每帧将元素向右移动一点，直到元素到达屏幕的右侧。如果元素尚未到达屏幕的右侧，或者换句话说，如果动画尚未完成，我们执行动画（移动元素几个像素），然后将其自身注册到`requestAnimationFrame`，从而继续循环。一旦动画完成，我们就简单地停止调用`requestAnimationFrame`。
- en: A key point to remember is that, one of the major optimizations that the browser
    does with `requestAnimationFrame` is to only call it when there is anything to
    render (in other words, when the tab holding the page is active relative to other
    tabs). Thus, if the user switches tabs while the animation is in progress, the
    animation will be paused until the tab is selected again.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记住的一个关键点是，浏览器使用`requestAnimationFrame`的主要优化之一是只在有东西需要渲染时调用它（换句话说，当包含页面的选项卡相对于其他选项卡处于活动状态时）。因此，如果用户在动画进行中切换选项卡，动画将暂停，直到再次选择该选项卡。
- en: In other words, what we ought to do is have `requestAnimationFrame` call the
    code that handles the rendering of the game, but not the code that updates the
    game state. This way, even if the browser is not rendering, the values related
    to the animation still get animated, but we don't waste CPU and GPU power, rendering
    something not visible. But as soon as the browser tab becomes active again, the
    latest data state will be rendered, as if it had been rendering the whole time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们应该让`requestAnimationFrame`调用处理游戏渲染的代码，而不是更新游戏状态的代码。这样，即使浏览器没有渲染，与动画相关的值仍会被动画化，但我们不会浪费CPU和GPU的功率，渲染看不见的东西。但是一旦浏览器选项卡再次变为活动状态，最新的数据状态将被渲染，就好像它一直在渲染一样。
- en: This technique is especially useful for games, as we may not want the entire
    game to pause when a user switches browser tabs. Then again, we can always benefit
    from saving the user's battery, which we can achieve by not rendering data to
    the screen when we don't need to.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对游戏特别有用，因为我们可能不希望用户切换浏览器选项卡时整个游戏都暂停。另一方面，我们总是可以通过在不需要时不向屏幕渲染数据来节省用户的电池。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that `requestAnimationFrame` will, by definition, cap the frame
    rate of your animation loop to the refreshing rate of the monitor. Thus, `requestAnimationFrame`
    is not intended to replace native timer implementations, particularly in cases
    when we'd like the callback function to be invoked at a rate independent from,
    and possibly higher than a monitor's refresh rate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`requestAnimationFrame`将按定义将动画循环的帧速率限制为显示器的刷新速率。因此，`requestAnimationFrame`并不打算替代本机定时器实现，特别是在我们希望回调函数以与显示器刷新速率独立且可能更高的速率被调用的情况下。
- en: Typed arrays
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型化数组
- en: Over the years, JavaScript engines have become amazingly faster. However, simply
    being able to process data faster doesn't necessarily equate to being able to
    do more powerful things. Take WebGL, for example. Just because the browser now
    has the ability to understand OpenGL ES, it doesn't necessarily mean that it has
    all the tools we developers need to take advantage of that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，JavaScript引擎的速度变得惊人地快。然而，仅仅能够更快地处理数据并不一定等同于能够做更强大的事情。以WebGL为例。仅仅因为浏览器现在具有理解OpenGL
    ES的能力，并不一定意味着它具有我们开发人员需要利用的所有工具。
- en: 'The good news is that the JavaScript language has also made some progress in
    order to satisfy this, and other needs that have come about. One such addition
    to JavaScript in recent years is a new data type: typed arrays. In general, typed
    arrays offer a structure similar to the array type already in JavaScript. However,
    these new arrays are much more efficient, and were designed with binary data in
    mind.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，JavaScript语言也在一些方面取得了进展，以满足这一需求和其他需求。近年来JavaScript的一个新增内容是一种新的数据类型：类型化数组。一般来说，类型化数组提供了与JavaScript中已有的数组类型类似的结构。然而，这些新数组更加高效，并且是针对二进制数据设计的。
- en: Why and how are typed arrays more efficient than regular arrays, you ask? Well,
    let's look at a trivial example, where all we do is traverse an array of integers
    the old way. Although most JavaScript engines don't particularly struggle to get
    this task done fairly fast, let us not overlook all the work the engine needs
    to do in order to do this.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你问为什么和如何类型化数组比普通数组更高效？好吧，让我们看一个简单的例子，我们只是以旧的方式遍历一个整数数组。尽管大多数JavaScript引擎并不特别困难地快速完成这项任务，但我们不要忽视引擎需要做的所有工作。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since JavaScript is not strongly typed, the array `nums` is not restricted to
    holding data of any particular type. Furthermore, the `nums` array can store a
    different data type for each element in it. While this can sometimes be convenient
    for a programmer, the JavaScript engine needs to figure out where each element
    is stored, and what data type is being stored at said location. Contrary to what
    you may think, those five elements in the `nums` array may not be stored in a
    contiguous piece of memory, because, well, that's how JavaScript does it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript不是强类型的，数组`nums`不受限于保存任何特定类型的数据。此外，`nums`数组可以为其中的每个元素存储不同的数据类型。虽然这对程序员来说有时可能很方便，但JavaScript引擎需要弄清楚每个元素存储在哪里，以及存储在该位置的数据类型是什么。与您可能认为的相反，在`nums`数组中的这五个元素可能不是存储在连续的内存块中，因为JavaScript就是这样做的。
- en: With typed arrays, on the other hand, each element in the array can only be
    an `integer` or a `float`. Based on the type of array we choose, we can have a
    different type of `integer` or `float` (`signed`, `unsigned`, 8, 16, or 32 bits),
    but every element in the array is always the same data type we decide to use (integer
    or float). This way, the browser knows precisely and instantly, where in memory
    element `nums[3]` is found which is at memory address `nums + 3`. This can be
    done because typed arrays are stored in a continuous chunk of memory, much like
    it does in array structures in C and C++ (which, by the way, is the language used
    to implement most, if not all JavaScript engines).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用类型化数组，数组中的每个元素只能是`整数`或`浮点数`。根据我们选择的数组类型，我们可以有不同类型的`整数`或`浮点数`（`有符号`，`无符号`，8、16或32位），但数组中的每个元素始终是我们决定使用的相同数据类型（整数或浮点数）。这样，浏览器就可以准确并立即知道`nums[3]`元素在内存中的位置，即在内存地址`nums
    + 3`处。这是因为类型化数组存储在连续的内存块中，就像C和C++中的数组结构一样（顺便说一句，这是实现大多数，如果不是所有JavaScript引擎的语言）。
- en: The major use case for typed arrays is, as hinted earlier, WebGL (which we'll
    cover in [Chapter 6](ch06.html "Chapter 6. Adding Features to Your Game"), *Adding
    Features to Your Game*). In WebGL, where we can perform 3D rendering right from
    JavaScript, we may need to process `integer` buffers, over a million elements
    long. These buffers can be used to represent a 3D model that we wish to draw to
    the screen. Now, imagine how long it would take for the browser to iterate through
    one such array. For each and every element, it would have to follow a memory location,
    check the value at that location, make sure the value is a number, attempt to
    convert the value into a number, and then finally use that value. Sounds like
    a lot of work? Well, that's because it is. With typed arrays, it can just run
    through that array as fast as it can, knowing that each element is indeed a number,
    and knowing exactly how much memory each element takes, so that jumping to the
    next memory address is a consistent and predictable process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化数组的主要用例是，正如之前暗示的那样，WebGL（我们将在[第6章](ch06.html "第6章。为您的游戏添加功能")中介绍，*为您的游戏添加功能*）。在WebGL中，我们可以直接从JavaScript执行3D渲染，可能需要处理超过一百万个元素的`整数`缓冲区。这些缓冲区可以用来表示我们希望绘制到屏幕上的3D模型。现在，想象一下浏览器需要遍历这样一个数组需要多长时间。对于每个元素，它都必须跟随一个内存位置，检查该位置的值，确保该值是一个数字，尝试将该值转换为数字，然后最终使用该值。听起来是不是很多工作？那是因为确实是。有了类型化数组，它可以以尽可能快的速度运行整个数组，知道每个元素确实是一个数字，并且确切地知道每个元素占用多少内存，因此跳转到下一个内存地址是一个一致和可预测的过程。
- en: Typed arrays are also used in the 2D canvas context. As we'll see in the canvas
    API section later in the chapter, there is a way that we can get the pixel data
    from whatever is drawn into a canvas. All that this pixel data is, is a long array
    of 8bits clamped `unsigned integers`. What that means is that each element in
    this array can only be an `integer` value between 0 and 255, which is precisely
    what the acceptable values are for a pixel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化数组也用于2D画布上下文。正如我们将在本章后面的画布API部分中看到的，我们可以从画布中绘制的任何内容中获取像素数据的方法。所有这些像素数据只是一个8位夹紧的`无符号整数`的长数组。这意味着该数组中的每个元素只能是介于0和255之间的`整数`值，这正是像素的可接受值。
- en: How to use it
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用它
- en: Using typed arrays is really simple. It may be easier to understand how they
    work if you have at least some experience with C or C++. The easiest way to create
    a typed array is to declare our array variable, and assign it an instance of a
    particular typed array type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型化数组非常简单。如果您至少有一些C或C++的经验，那么了解它们的工作原理可能会更容易。创建类型化数组的最简单方法是声明我们的数组变量，并为它分配特定类型的类型化数组实例。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the example, we have created an instance of an `integer` array, where each
    element can be either positive or negative (`signed`). Each element will be stored
    as a 32 bits number. The `integer` argument that we pass in, indicates the size
    of the array. Once this array is created, its size cannot be changed. Any values
    assigned to it outside its bounds are silently ignored by the browser, as well
    as any illegal values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`整数`数组的实例，其中每个元素可以是正数或负数（`有符号`）。每个元素将以32位数字的形式存储。我们传递的`整数`参数表示数组的大小。创建了这个数组之后，它的大小就不能改变了。浏览器会悄悄地忽略分配给它的任何超出其范围的值，以及任何非法值。
- en: Other than the restrictions on what can be stored in this special array, it
    all may seem just as an ordinary JavaScript array to the untrained eye. But if
    we look a bit deeper into it, we'll notice a couple more distinctions between
    an array and a typed array.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对这种特殊数组中可以存储什么的限制之外，对于未经训练的人来说，它可能看起来就像是一个普通的JavaScript数组。但是，如果我们深入研究一下，我们会注意到数组和类型化数组之间还有一些区别。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first thing we notice is that the array is indeed an `Int32Array`, and
    not an Array. Next, we''re happy to know that the length property is still there.
    So far so good. Then, things start to separate, as simple methods associated with
    regular arrays are no longer present. Not only that, but there''s also a new attribute
    in the typed array object named `buffer`. This buffer object is of type `ArrayBuffer`,
    which has a `byteLength` property. In this case, we can see that the buffer''s
    length is `40`. It''s easy to see where this `40` came from: `buffer` holds 10
    elements (`typedArr.length`), and each element is 32 bits long (4 bytes), for
    a total of `40` bytes in the `ArrayBuffer` (hence the property name of `byteLength`).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第一件事是，数组确实是一个`Int32Array`，而不是一个数组。接下来，我们很高兴地知道`length`属性仍然存在。到目前为止一切顺利。然后，事情开始分开，与普通数组相关的简单方法不再存在。不仅如此，类型化数组对象中还有一个名为`buffer`的新属性。这个缓冲区对象是`ArrayBuffer`类型，它有一个`byteLength`属性。在这种情况下，我们可以看到缓冲区的长度是`40`。很容易看出这个`40`是从哪里来的：`buffer`包含10个元素（`typedArr.length`），每个元素都是32位长（4字节），总共在`ArrayBuffer`中有`40`字节（因此属性名为`byteLength`）。
- en: Since typed arrays don't come with helper functions such as regular JavaScript
    arrays do, we read and write data to them using the old array notation, where
    we index into the array in order to read or write a value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型化数组没有像普通JavaScript数组那样的辅助函数，我们使用旧的数组表示法来读取和写入数据，其中我们通过索引进入数组以读取或写入一个值。
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, just to reinforce the fact that no helper functions or shortcuts related
    to ordinary JavaScript arrays work with typed arrays, notice that an attempt to
    access an element without providing an index will provide an exception being thrown
    by the browser.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调一点，与普通JavaScript数组相关的任何辅助函数或快捷方式都不适用于类型化数组，注意，尝试在不提供索引的情况下访问元素将导致浏览器抛出异常。
- en: ArrayBuffer and ArrayBufferView
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArrayBuffer和ArrayBufferView
- en: Although, all the previous examples used a specific kind of typed array directly,
    the way that typed arrays work is slightly more involved than that. The implementation
    is broken down into two separate parts, namely, an array buffer and a view (or
    more specifically, an array buffer view). The array buffer is simply a chunk of
    memory that is allocated, so we can store our data there. The thing about this
    buffer is that it has no type associated with it, so we can't access that memory
    to store data to, or read data from it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有先前的例子都直接使用了特定类型的数组，但类型化数组的工作方式要比那更复杂一些。实现被分解为两个单独的部分，即数组缓冲区和视图（或更具体地说，数组缓冲区视图）。数组缓冲区只是分配的一块内存，所以我们可以在那里存储我们的数据。关于这个缓冲区的事情是，它没有与之关联的类型，所以我们无法访问该内存来存储数据，或者从中读取数据。
- en: In order to be able to use the memory space allocated by the array buffer, we
    need a view. Although the base type for this view is `ArrayBufferView`, we actually
    need a subclass of `ArrayBufferView`, which defines a specific type to the data
    stored in the array buffer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用数组缓冲区分配的内存空间，我们需要一个视图。尽管这个视图的基本类型是`ArrayBufferView`，但我们实际上需要`ArrayBufferView`的一个子类，它为数组缓冲区中存储的数据定义了一个特定的类型。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here's where things can get a bit confusing. The array buffer works in terms
    of bytes. As a refresher, a byte is made up of 8 bits. A bit is a single binary
    digit, which can have a value of either zero or one. This is how data is represented
    at its most basic format in computers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事情可能变得有点混乱的地方。数组缓冲区以字节为单位工作。作为复习，一个字节由8位组成。一个位是一个单一的二进制数字，它可以有一个值，要么是零，要么是一。这是数据在计算机中以最基本的格式表示的方式。
- en: 'Now, if a buffer works in terms of bytes, when we created our buffer in the
    example, we created a block of `32` bytes. The view that we create to hold and
    use the buffer can be one of nine possible types, each of which specifies a different
    data size (in terms of bits, not bytes). Thus, a view of type `Int32` represents
    a buffer where each element is an `integer`, 32 bits long. In other words, a 32
    bits view can hold exactly 8 bytes (1 byte = 8 bits; 32 bits = 8 bytes), as illustrated
    in following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个缓冲区以字节为单位工作，当我们在示例中创建我们的缓冲区时，我们创建了一个`32`字节的块。我们创建的视图可以是九种可能类型之一，每种类型都指定了不同的数据大小（以位而不是字节为单位）。因此，类型为`Int32`的视图表示一个每个元素都是32位长的`整数`的缓冲区。换句话说，32位视图可以恰好容纳8个字节（1字节=8位；32位=8字节），如下面的屏幕截图所示：
- en: '![ArrayBuffer and ArrayBufferView](img/6029OT_05_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![ArrayBuffer and ArrayBufferView](img/6029OT_05_03.jpg)'
- en: Array buffers work in terms of bytes. In the image, there are 4 bytes, although
    view types work in terms of bits. Thus, if we use a 32 bits view, it will result
    in an array that has a length of exactly one element. If the view uses a 16 bits
    data type, then the array will have 2 elements (4 bytes divided by 16 bits). Finally,
    if the view uses an 8 bits data type, the array stored in the 4 bytes buffer will
    have 4 elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数组缓冲区以字节为单位工作。在图中，有4个字节，尽管视图类型是以位为单位工作的。因此，如果我们使用32位视图，将导致一个长度恰好为一个元素的数组。如果视图使用16位数据类型，那么数组将有2个元素（4个字节除以16位）。最后，如果视图使用8位数据类型，那么存储在4个字节缓冲区中的数组将有4个元素。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One important thing to always remember is that when you create an array buffer,
    the length you choose to make the buffer must divide perfectly into however large
    you make the array buffer view. If there is not enough room in the buffer to fit
    entire bytes, the JavaScript will throw an error of type `RangeError`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 始终要记住的一件重要的事情是，当你创建一个数组缓冲区时，你选择的长度必须完全能够被你创建的数组缓冲区视图的大小整除。如果缓冲区中没有足够的空间来容纳整个字节，JavaScript将抛出一个`RangeError`类型的错误。
- en: In the following image, the buffer is only big enough for 8 bits, all of which
    must be occupied by whole bytes. Thus, a view is an 8 bits number which would
    fit exactly one whole element, which would be fine. A 16 bits element would only
    fit half of an element, which is not possible. A 32 bits element would likewise
    only fit a portion of it, which is also not allowed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，缓冲区只足够大以容纳8位，所有位都必须由整个字节占用。因此，视图是一个8位数，恰好可以容纳一个整个元素，这是可以的。16位元素只能容纳一半的元素，这是不可能的。32位元素同样只能容纳一部分，这也是不允许的。
- en: '![ArrayBuffer and ArrayBufferView](img/6029OT_05_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![ArrayBuffer和ArrayBufferView](img/6029OT_05_04.jpg)'
- en: As you can see, as long as the array buffer has a bit length that is a multiple
    of the bit size of the data type used in the view, things work out fine. If the
    view is 8 bits long, then an array buffer of 8, 16, 24, 32, or 40, would work
    out fine. If the view is 32 bits long, then the buffer must be at least 4 bytes
    long (32 bits), 8 bytes (64 bits), 24 bytes (96 bits), and so on. Then, by dividing
    the amount of bytes in the buffer by the amount of bytes in the data type represented
    by the view, we can calculate the total number of elements that we can fit in
    said array.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，只要数组缓冲区的位长度是视图中使用的数据类型的位大小的倍数，事情就会很顺利。如果视图为8位长，则8、16、24、32或40字节的数组缓冲区都可以很好地工作。如果视图为32位长，则缓冲区必须至少为4字节长（32位）、8字节（64位）、24字节（96位）等。然后，通过将缓冲区中的字节数除以视图表示的数据类型的字节数，我们可以计算出我们可以放入所述数组的总元素数。
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Typed array view types
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化数组视图类型
- en: As a summary, a plain old array buffer has no actual size. Although it wouldn't
    make sense to create an array buffer of a byte length of say 5 bytes, we are more
    than welcome to do so. Only after the array buffer is created can we create a
    view to hold the buffer. Based on the byte size of the buffer, we can determine
    how many elements the array buffer view can access by selecting an appropriate
    data type. Currently, there are nine data types that we can choose from for the
    array buffer view.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，一个普通的数组缓冲区没有实际大小。虽然创建一个长度为5字节的数组缓冲区没有意义，但我们可以这样做。只有在创建了数组缓冲区后，我们才能创建一个视图来保存缓冲区。根据缓冲区的字节大小，我们可以通过选择适当的数据类型来确定数组缓冲区视图可以访问多少元素。目前，我们可以从九种数据类型中为数组缓冲区视图选择。
- en: '**Int8Array**: It is a `signed integer`, 8 bits long, ranging from 32,768 to
    32,767'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int8Array**：它是一个8位长的`有符号整数`，范围从32,768到32,767'
- en: '**Uint8Array**: It is an `unsigned integer`, 8 bits long, ranging from 0 to
    65,535'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uint8Array**：它是一个8位长的`无符号整数`，范围从0到65,535'
- en: '**Uint8ClampedArray**: It is an `unsigned integer`, 8 bits long, ranging from
    0 to 255'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uint8ClampedArray**：它是一个8位长的`无符号整数`，范围从0到255'
- en: '**Int16Array**: It is a `signed integer`, 16 bits long, ranging from 2,147,483,648
    to 2,147,483,647'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int16Array**：它是一个16位长的`有符号整数`，范围从2,147,483,648到2,147,483,647'
- en: '**Uint16Array**: It is an `unsigned integer`, 16 bits long, ranging from 0
    to 4,294,967,295'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uint16Array**：它是一个16位长的`无符号整数`，范围从0到4,294,967,295'
- en: '**Int32Array**: It is a `signed integer`, 32 bits long, ranging from 9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int32Array**：它是一个32位长的`有符号整数`，范围从9,223,372,036,854,775,808到9,223,372,036,854,775,807'
- en: '**Uint32Array**: It is an `unsigned integer`, 32 bits long, ranging from 0
    to 18,446,744,073,709,551,615'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uint32Array**：它是一个32位长的`无符号整数`，范围从0到18,446,744,073,709,551,615'
- en: '**Float32Array**: It is a `signed float`, 32 bits long, with a range of 3.4E
    +/- 38 (7 digits)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Float32Array**：它是一个32位长的`有符号浮点数`，范围为3.4E +/- 38（7位数）'
- en: '**Float64Array**: It is a `signed float`, 64 bits long, with a range of 1.7E
    +/- 308 (15 digits)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Float64Array**：它是一个64位长的`有符号浮点数`，范围为1.7E +/- 308（15位数）'
- en: It goes without saying that the larger the view type, the larger the buffer
    will need to be to hold the data. Obviously, it follows that the larger the buffer
    you create, the more memory the browser will need to set aside for you, whether
    or not you end up using that memory. Thus, we should always pay attention to how
    much memory we might actually need, and try to allocate no more than that. It
    would be an awesome waste of resources to allocate an array of 10,000 elements,
    each of which are 64 bits long, just to represent a snake in a game, such as the
    one that we're building in the chapter, where the maximum snake size might be
    no larger than 50 or so elements, and where each element needs not hold a value
    larger than say 10.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，视图类型越大，缓冲区就需要越大来容纳数据。显然，创建的缓冲区越大，浏览器就需要为您设置更多的内存，无论您最终是否使用该内存。因此，我们应该始终注意我们实际可能需要多少内存，并尽量不要分配超过这个数量。如果为了表示游戏中的蛇而分配了一个64位长的10,000个元素的数组，这将是一种可怕的资源浪费，比如我们在本章中正在构建的游戏中，蛇的最大大小可能不会超过50个元素，每个元素的值也不会超过10。
- en: Given such constraints, we could calculate a rough, yet optimistic array size
    of 50, where each element only needs 8 bits (since we'll only need around 10 unique
    values). Thus, 50 elements times one byte each, gives us a total buffer size of
    50 bytes. This should be more than enough for our purposes, while the memory consumption
    for this buffer alone should stay around 0.05 KB. Not bad.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些限制，我们可以计算出一个粗略但乐观的数组大小为50，其中每个元素只需要8位（因为我们只需要大约10个唯一的值）。因此，50个元素乘以每个一个字节，给我们一个总缓冲区大小为50字节。这应该足够我们的目的，而仅此缓冲区的内存消耗应该保持在0.05
    KB左右。不错。
- en: Finally, you may have noticed, the first part of this section demonstrated typed
    array creation without using the `ArrayBuffer` construct explicitly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能已经注意到，本节的第一部分演示了不使用显式`ArrayBuffer`构造来创建类型化数组。
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While the two typed arrays above, refer to two separate and unique memory locations,
    they are identical at run time, and cannot be told apart (unless the actual arrays
    hold different values, of course); the point here being that an array buffer view
    constructor can take an `ArrayBuffer`, or simply an `integer`. If you use an `ArrayBuffer`,
    all of the restrictions just mentioned apply, and must be handled with care. If
    you only supply an `integer`, the browser will create an array buffer of the appropriate
    size for you automatically. In practice, there are rare occasions and reasons,
    where you'd want to manually create an array buffer separately. It is noteworthy,
    however, that it is totally legal to create multiple array buffer views for the
    same array buffer, even if each view is of a different data type. Remember that,
    since the buffer refers to a single memory location, so all views bound to the
    same buffer are sharing that memory space.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上面的两个类型化数组指向两个独立的内存位置，但在运行时它们是相同的，无法区分（除非实际的数组保存了不同的值，当然）；这里的重点是数组缓冲器视图构造函数可以接受`ArrayBuffer`，或者简单的`integer`。如果使用`ArrayBuffer`，所有上面提到的限制都适用，并且必须小心处理。如果只提供一个`integer`，浏览器将自动为您创建一个适当大小的数组缓冲器。在实践中，有时候会有少数情况和原因，您会想要手动创建一个独立的数组缓冲器。然而，值得注意的是，即使每个视图是不同的数据类型，也完全可以为同一个数组缓冲器创建多个数组缓冲器视图。请记住，由于缓冲器指向单个内存位置，因此绑定到同一个缓冲器的所有视图都共享该内存空间。
- en: Canvas
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布
- en: Perhaps no other HTML5 feature is as powerful as the canvas API with regards
    to game development for the web platform. Although we may have every other feature
    currently in the specification, as well as any forthcoming feature that the browser
    can possibly support, it would be nearly impossible to produce a high quality,
    engaging, fun game using HTML and JavaScript. The canvas API allows us to create
    2D, as well as 3D graphics right on the browser. It also lets us manipulate the
    graphical data stored in the canvas context, down to the individual pixel level.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 也许没有其他HTML5功能像画布API一样强大，特别是对于Web平台的游戏开发。尽管我们可能已经拥有规范中的每一个功能，以及浏览器可能支持的任何即将推出的功能，但要使用HTML和JavaScript制作高质量、引人入胜、有趣的游戏几乎是不可能的。画布API允许我们在浏览器上创建2D和3D图形。它还允许我们操纵画布上存储的图形数据，甚至可以到像素级别。
- en: One major difference between a canvas graphic and an SVG graphic, apart from
    the fact that SVG graphics are vector-based, and canvas graphics are always raster
    graphics, is that the canvas is a single HTML element, and everything drawn in
    it is, for all practical purposes, non-existent to the browser. Thus, any event
    handling on individual entities drawn on a canvas must be handled at the application
    level. There are generic events on the canvas that we can observe and respond
    to, such as clicks, move events, and keyboard events. Beyond that, we are free
    to do as we please.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 画布图形和SVG图形之间的一个主要区别是，SVG图形是基于矢量的，而画布图形始终是光栅图形，另外一个区别是画布是一个单一的HTML元素，其中绘制的所有内容在实际上对浏览器来说都是不存在的。因此，画布上绘制的任何实体的事件处理必须在应用程序级别进行处理。画布上有一些通用事件，我们可以观察和响应，比如点击、移动事件和键盘事件。除此之外，我们可以自由地做任何我们想做的事情。
- en: 'Beyond the shape-based drawing that we can do on an HTML5 canvas, there are
    three major use cases for the API. We can create 2D, sprite-based games, full-blown
    3D games (using WebGL with the help of the canvas), and manipulating photographs.
    The last use case mentioned: photo manipulation, is especially interesting. The
    API has a very handy function that allows us to not only export the data in the
    canvas as a PNG or JPG image, but it also supports various types of compression.
    That means, we can draw on a canvas, load graphics on it (for example photographs),
    manipulate that data at a pixel level (for example apply Photoshop-like filters
    to it), rotate, stretch, scale, and otherwise, play with the data. Then, the API
    allows us to export that data as a compressed file that can be saved to the file
    system.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在HTML5画布上可以进行基于形状的绘制之外，API还有三个主要用例。我们可以创建基于精灵的2D游戏，完整的3D游戏（使用WebGL和画布的帮助），以及操纵照片。最后一个提到的用例：照片处理，尤其有趣。API有一个非常方便的函数，不仅允许我们将画布中的数据导出为PNG或JPG图像，而且还支持各种类型的压缩。这意味着我们可以在画布上绘制，加载图形（例如照片），以像素级别操纵数据（例如应用类似Photoshop的滤镜），旋转、拉伸、缩放，或者以其他方式玩弄数据。然后，API允许我们将这些数据导出为一个可以保存到文件系统的压缩文件。
- en: For the purposes of this book, we'll focus on the aspects of the canvas API
    that we can best use for game development. Although WebGL is a very exciting aspect
    of the canvas element, but we will cover a very basic introduction to it in [Chapter
    6](ch06.html "Chapter 6. Adding Features to Your Game"), *Adding Features to Your
    Game*. For other capabilities available on the canvas API, we will cover them
    briefly with a few examples in the following section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的目的，我们将重点关注画布API的方面，这些方面对游戏开发最有用。尽管WebGL是画布元素的一个非常令人兴奋的方面，但我们将在[第6章](ch06.html
    "第6章。为您的游戏添加功能")中简要介绍它，*为您的游戏添加功能*。对于画布API上其他可用的功能，我们将在下一节中简要介绍并举例说明。
- en: How to use it
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用它
- en: The first thing we need to understand about the canvas element is that there
    are two parts to it. One is the physical canvas element, and the other is the
    rendering context through which we can draw to the canvas. As of this writing,
    there are two rendering contexts that we can use in modern browsers, namely, `CanvasRenderingContext2D`
    and `WebGLRenderingContext`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解关于画布元素的第一件事是，它有两个部分。一个是物理画布元素，另一个是我们可以通过它绘制到画布的渲染上下文。截至目前，我们可以在现代浏览器中使用两个渲染上下文，即`CanvasRenderingContext2D`和`WebGLRenderingContext`。
- en: To obtain a reference to the rendering context of a canvas, we call a `factory`
    method on the canvas element itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取画布的渲染上下文的引用，我们需要在画布元素本身上调用一个`factory`方法。
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the use of a fallback context is aimed at the prefixed `experimentalwebgl`
    context. As of this writing, most browsers that support WebGL will do so through
    the experimental tag.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用备用上下文是针对带有前缀的`experimentalwebgl`上下文。截至目前，大多数支持WebGL的浏览器都会通过实验标签来支持它。
- en: The rest of the section will relate exclusively to the `CanvasRenderingContext2D`
    API. While it is technically possible to do everything that the 2D canvas context
    can, using the 3D canvas context of WebGL, the only thing that these two APIs
    have in common is their link to the HTML5 canvas element. WebGL is an entire programming
    language in and of itself, and a single chapter dedicated to it would not be enough
    to even scratch the surface.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将专门涉及`CanvasRenderingContext2D` API。虽然从技术上讲，可以使用WebGL的3D画布上下文来完成2D画布上下文可以做的一切，但这两个API共同之处仅在于它们与HTML5画布元素的关联。WebGL本身就是一种完整的编程语言，单独的一章是远远不够的。
- en: Now, a very important aspect of the 2D rendering context is its coordinate space.
    Similar to most coordinate system in computers, the origin is located at the top
    left corner of the canvas. The horizontal axis increases to the right, while the
    vertical axis increases downwards. The size of the grid held in memory to represent
    the canvas is determined by the physical size of the canvas that generates the
    rendering context, and not the styled size of the canvas. This is a key principle
    that can't be emphasized enough. By default, a canvas is 300 x 150 pixels. Even
    if we resize the canvas through **Cascading Style Sheets** (**CSS**), the rendering
    context that it generates will be that size (unless we physically resize the canvas,
    of course). Once the rendering context has been created, it cannot be resized.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，2D渲染上下文的一个非常重要的方面是它的坐标空间。与大多数计算机坐标系统类似，原点位于画布的左上角。水平轴向右增加，垂直轴向下增加。用于表示画布的内存中的网格大小由生成渲染上下文的画布的物理大小决定，而不是画布的样式大小。这是一个无法过分强调的关键原则。默认情况下，画布是300
    x 150像素。即使我们通过**层叠样式表**（**CSS**）调整了画布的大小，它生成的渲染上下文仍然是那个大小（除非我们物理调整了画布的大小）。一旦渲染上下文被创建，它就无法调整大小。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How to use it](img/6029OT_05_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用](img/6029OT_05_05.jpg)'
- en: The border was added in order to make the canvas somewhat visible to us, as
    by default, the canvas is transparent.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 边框是为了使画布对我们有些可见，因为默认情况下，画布是透明的。
- en: You will observe that the CSS rule is indeed applied to the canvas element,
    even though the canvas' real size is still the default 300 x 150 pixels. If we
    were to draw a circle in the middle of that canvas, the circle would seem distorted,
    because the actual coordinate space where the circle is actually drawn, would
    be stretched by the styling applied to the canvas.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到CSS规则确实应用于画布元素，即使画布的实际大小仍然是默认的300 x 150像素。如果我们在画布中间画一个圆，圆看起来会变形，因为应用于画布的样式会拉伸实际绘制圆的坐标空间。
- en: clearRect
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: clearRect
- en: The first drawing function we'll look at is `clearRect`. All that this function
    does is, clear a rectangular area of the canvas. This function is called on the
    context object, as do all drawing calls that we'll be making on the 2D canvas.
    The four parameters it takes, represent, in order, the x and y offset from the
    canvas' origin, plus a width and a height distance to clear. Keep in mind that
    unlike other popular drawing APIs in other programming languages, the last two
    parameters are not measured from the origin—they are displacement distances from
    the point specified by the first two parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个绘图函数是`clearRect`。这个函数所做的就是清除画布的一个矩形区域。这个函数是在上下文对象上调用的，就像我们将在2D画布上进行的所有绘图调用一样。它所需要的四个参数依次代表了从画布原点的x和y偏移量，以及要清除的宽度和高度距离。请记住，与其他流行的绘图API不同，最后两个参数不是从原点开始测量的——它们是从由前两个参数指定的点的位移距离。
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Normally, when rendering many frames every second, we'd be calling this function
    to clear out the entire canvas before drawing the next frame. Luckily, in most
    JavaScript engines, this function performs fairly well; so that we don't need
    to worry too much about optimizing the precise area to clear out on a regular
    basis.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当每秒渲染许多帧时，我们会在绘制下一帧之前调用此函数来清除整个画布。幸运的是，在大多数JavaScript引擎中，这个函数的性能表现相当不错；因此，我们不需要过多担心定期优化要清除的精确区域。
- en: Fill and stroke
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充和描边
- en: When drawing native objects such as lines, paths, text, and other shapes, we'll
    deal with the concept of strokes and fills; just as in SVG, a stroke refers to
    the outline of a primitive (such as a border or sorts), and the fill is the content
    that covers the inside of the shape.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制诸如线条、路径、文本和其他形状等本机对象时，我们将处理描边和填充的概念；就像在SVG中一样，描边是指原始图形的轮廓（如边框或类似物），而填充是覆盖形状内部的内容。
- en: The way we can change the color that is used to fill a shape, or the color used
    to stroke the shape, is by assigning any color to the `fillStyle` or `strokeStyle`
    properties. The color can be any string valid for a CSS color.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将任何颜色分配给`fillStyle`或`strokeStyle`属性来更改用于填充形状的颜色，或者用于描边形状的颜色。颜色可以是任何有效的CSS颜色字符串。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Fill and stroke](img/6029OT_05_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![填充和描边](img/6029OT_05_06.jpg)'
- en: Any valid CSS color string can be assigned to color properties in the 2D rendering
    context, including colors with opacity.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有效的CSS颜色字符串都可以分配给2D渲染上下文中的颜色属性，包括带有不透明度的颜色。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pay special attention to the fact that the rendering context acts much like
    a state machine. Once you set a fill or stroke style, as well as any other property,
    that property will maintain that value until you change it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意渲染上下文的行为很像一个状态机。一旦设置了填充或描边样式，以及任何其他属性，该属性将保持该值，直到您更改它。
- en: Also, note that each subsequent drawing call that you issue, draws on top of
    whatever is already on the canvas. Thus, we can layer shapes and images by carefully
    arranging the drawing calls in just the right order.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，您发出的每个后续绘图调用都会绘制在画布上已有的内容之上。因此，我们可以通过仔细安排绘图调用的顺序来分层形状和图像。
- en: Lines
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线条
- en: Drawing lines is as easy as calling the function `lineTo`, which only takes
    two parameters, indicating the point where the line is going to. Subsequent calls
    to `lineTo` will draw a line to the point specified by the function call, starting
    the line at the last point where the line was. More specifically, the line starts
    where the current drawing pointer is.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线条就像调用`lineTo`函数一样简单，它只接受两个参数，表示线条的终点。对`lineTo`的后续调用将绘制一条线到函数调用指定的点，从上一次绘制线条的地方开始。更具体地说，线条从当前绘制指针的位置开始。
- en: By default, the pointer is not defined anywhere, so drawing a line to some other
    point makes little sense. To help with that, we can make use of the function `moveTo`,
    which moves the drawing pointer without drawing anything.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，指针没有定义在任何地方，因此将线条绘制到其他点几乎没有意义。为了解决这个问题，我们可以使用`moveTo`函数，它可以移动绘制指针而不绘制任何东西。
- en: Finally, any calls to `lineTo` only set the points in memory. In order to eventually
    draw the line, we need to make a quick call to the stroke function. Once this
    call is made, whatever attributes are currently set (such as line width and stroke
    style), will be drawn. Thus, changing line properties before actually stroking
    the line does little good, and can negatively influence performance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对`lineTo`的任何调用只是在内存中设置点。为了最终绘制线条，我们需要快速调用stroke函数。一旦进行了这个调用，当前设置的任何属性（如线宽和描边样式）都会被绘制。因此，在实际描边线条之前更改线条属性没有什么好处，而且可能会对性能产生负面影响。
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Lines](img/6029OT_05_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![线条](img/6029OT_05_07.jpg)'
- en: Shapes are only drawn after the call to stroke(), at which point the current
    style attributes are used.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 形状只有在调用`stroke()`之后才会被绘制，此时会使用当前的样式属性。
- en: Shapes
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状
- en: There are a couple of different shapes we can draw very effortlessly. These
    are rectangles and circles. While, there is no circle function as there is a `rect`
    function for drawing rectangles. There is, however, an `arc` function, from which
    we can draw circles.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常轻松地绘制几种不同的形状。这些是矩形和圆。虽然没有像绘制矩形的`rect`函数那样的圆函数。但是，有一个`arc`函数，我们可以从中绘制圆。
- en: The `rect` function takes four parameters, exactly as `fillRect`. `arc` takes
    an x and a y coordinate, followed by a radius, a starting angle (in radians, not
    degrees), an ending angle, and a Boolean, specifying, if the arc is to be drawn
    clockwise. To draw a circle, we can just draw an arc that goes from 0 to PI times
    2, which is the same as 360 degrees.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`rect`函数接受四个参数，与`fillRect`完全相同。`arc`接受一个x和一个y坐标，然后是半径、起始角度（以弧度而不是度数表示）、结束角度和一个布尔值，指定弧是顺时针绘制还是逆时针绘制。要绘制一个圆，我们可以绘制一个从0到PI乘以2的弧，这与360度相同。'
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Shapes](img/6029OT_05_08.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![形状](img/6029OT_05_08.jpg)'
- en: Arcs (including circles) are drawn from their center and not from some point
    on their outline.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 弧（包括圆）是从它们的中心绘制的，而不是从轮廓上的某一点开始。
- en: Text
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本
- en: Drawing text on an HTML5 canvas is also pretty straightforward. The function
    `fillText` takes a string (the text to be drawn), and an x and y coordinate, where
    the text begins to draw. Additionally, we can style the text the same way that
    text can be styled through CSS. This can be done by setting the text style property
    string to the font attribute.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5画布上绘制文本也非常简单。函数`fillText`接受一个字符串（要绘制的文本），以及一个x和y坐标，文本开始绘制的位置。此外，我们可以通过设置文本样式属性字符串到字体属性来对文本进行样式设置，就像通过CSS对文本进行样式设置一样。
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Transformations
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换
- en: The canvas API also defines a few transformation functions that allow us to
    translate, scale, and rotate the context's coordinate system. After transforming
    the coordinate system, we can draw onto the canvas just as we normally would,
    and the transformations would apply.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 画布API还定义了一些变换函数，允许我们对上下文的坐标系进行平移、缩放和旋转。在变换坐标系之后，我们可以像平常一样在画布上绘制，变换会应用到绘制上。
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Rotation and scaling also works the same way. The `scale` function takes a value
    to scale the coordinate system by, on each axis. The `rotation` function takes
    a single parameter, which is the angle (in radian) to rotate the coordinate system
    by.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转和缩放也是一样的。`scale`函数接受一个值，用于在每个轴上缩放坐标系。`rotation`函数接受一个参数，即要将坐标系旋转的角度（以弧度表示）。
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Transformations](img/6029OT_05_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![变换](img/6029OT_05_09.jpg)'
- en: With transformations, order is very important.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在变换中，顺序非常重要。
- en: Drawing images
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制图像
- en: Probably the most exciting and useful feature of the 2D canvas API from a game
    development perspective, is its ability to draw images onto it. Thankfully, for
    us, there are several ways to draw a regular JPG, GIF, or PNG image right on the
    canvas, including functions that handle scaling images from source to destination.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从游戏开发的角度来看，2D画布API最令人兴奋和有用的功能可能就是它能够在上面绘制图像。对我们来说，幸运的是，有几种方法可以直接在画布上绘制常规的JPG、GIF或PNG图像，包括处理从源到目标的图像缩放的函数。
- en: One other note that we need to make about the canvas element is that it follows
    the same origin policy. That means, in order for us to be able to draw an image
    onto a canvas context, the script attempting to draw the image must be served
    from the same domain (along with the same protocol and port number) as the image.
    Any attempt to load an image from a different domain into the canvas context and
    the browser will throw an exception.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于画布元素，我们需要注意的另一点是它遵循相同的源策略。这意味着，为了能够在画布上绘制图像，尝试绘制图像的脚本必须与图像来自相同的域（以及相同的协议和端口号）。任何尝试从不同域加载图像到画布上下文的操作都会导致浏览器抛出异常。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The simplest call to draw an image only takes five parameters. The first is
    a reference to an image. The next two parameters are the x and y position where
    that image will be drawn onto the canvas, and the last two parameters are the
    width and height to paint the image onto the canvas. If the last two parameters
    don''t maintain the aspect ratio of the original image, the result will be distortion,
    rather than clipping. Also, note that, if the original image is larger than the
    canvas, or if the image is drawn from an offset such that part of the image runs
    off the canvas, that extra data will simply not be drawn (obviously), and the
    canvas will just ignore those pixels outside the viewable area:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制图像的最简单调用只需要五个参数。第一个是图像的引用。接下来的两个参数是图像将被绘制到画布上的x和y位置，最后两个参数是将图像绘制到画布上的宽度和高度。如果最后两个参数不保持原始图像的宽高比，结果将是扭曲而不是裁剪。另外，请注意，如果原始图像大于画布，或者如果图像是从偏移处绘制的，以至于图像的一部分超出了画布，那么额外的数据将不会被绘制（显然），画布将忽略视图区域外的像素：
- en: '![Drawing images](img/6029OT_05_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![绘制图像](img/6029OT_05_10.jpg)'
- en: The HTML5 logo drawn inside a canvas rendering context.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布渲染上绘制的HTML5标志。
- en: A very important observation is that if the browser has not yet finished downloading
    the image resource from the server by the time the call is made to `drawImage`,
    the canvas will simply not draw anything, since the image passed to be drawn onto
    it has not loaded yet. In the case where we draw the same image onto the canvas
    multiple times per second using a game loop of some sort, this is not really a
    problem, because whenever the image finally loads, the next pass through the game
    loop will successfully draw the image. However, in cases where the call to draw
    the image is only done once (as in the example above), we only get one chance
    to draw the image. Thus, it is very important that we don't make that call until
    the image is in fact loaded into memory, and ready to be drawn into the canvas.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的观察是，如果浏览器在调用`drawImage`时尚未完成从服务器下载图像资源，那么画布将不会绘制任何东西，因为要绘制到画布上的图像尚未加载。在使用某种游戏循环多次每秒绘制相同图像到画布的情况下，这并不是一个问题，因为图像最终加载时，游戏循环的下一次通过将成功绘制图像。然而，在只调用一次绘制图像的情况下（就像上面的例子一样），我们只有一次机会来绘制图像。因此，非常重要的是，我们不要在图像实际加载到内存并准备好绘制到画布之前进行调用。
- en: In order to ensure that the call to draw the image into the canvas only happens
    after the image has been fully downloaded from the server, we can simply register
    a callback function on the load event of the image. This way, as soon as the image
    is done downloading, the browser can fire that callback, and the call can finally
    be made to draw the image. This way, we can be sure that the image will indeed
    be ready by the time we want to have it rendered in the canvas.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在图像从服务器完全下载后才调用将图像绘制到画布的操作，我们可以简单地在图像的加载事件上注册一个回调函数。这样，一旦图像下载完成，浏览器就可以触发回调，最终可以调用绘制图像的操作。这样，我们可以确保在我们想要在画布中呈现图像时，图像确实已经准备好了。
- en: There is also another version of the same function, which takes into account,
    scaling from source to destination. In the case above, the source image is larger
    than the canvas. Instead of resizing the image using a photo editing software
    program, we can instead tell the canvas to draw the whole image into a smaller
    area of the canvas. The scaling is done by the canvas automatically. We could
    also draw the image into a larger area than the image itself, but doing so will
    result in pixilation depending on how much we scale the image.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个版本的相同函数，它考虑了从源到目的地的缩放。在上面的情况下，源图像大于画布。我们可以告诉画布将整个图像绘制到画布的较小区域，而不是使用照片编辑软件调整图像的大小。缩放由画布自动完成。我们还可以将图像绘制到比图像本身更大的区域，但这样做将根据我们缩放图像的程度而导致像素化。
- en: The parameters for this function are the source image, the source x and y coordinates
    (in other words, where to start sampling the source image relative to the image
    itself), the source width and height (in other words, how much to sample the source
    image), and the destination x and y, followed by width and height.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的参数是源图像，源x和y坐标（换句话说，从图像本身开始采样源图像的位置），源宽度和高度（换句话说，采样源图像的量），以及目标x和y，然后是宽度和高度。
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Drawing images](img/6029OT_05_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![绘制图像](img/6029OT_05_11.jpg)'
- en: Part of the HTML5 logo drawn inside a canvas rendering context, with some intentional
    stretching.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布渲染上绘制的HTML5标志的一部分，有一些故意的拉伸。
- en: Manipulating pixels
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作像素
- en: Now that we know how to draw images into a canvas, let's take things to the
    next step, and work with the individual pixels drawn in the canvas. There are
    two functions that we can use in order to accomplish this. One function allows
    us to retrieve the pixel data from the canvas context, and the other lets us put
    a pixel buffer back into the canvas context. Additionally, there is a function
    that allows us to retrieve the pixel data as a data URL, meaning, that we can
    save the image data from the canvas right to the user's file system, just as we
    can with a regular image from an `<img />` tag.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何将图像绘制到画布中，让我们将事情推进一步，处理在画布中绘制的单个像素。有两个函数可以用来实现这一点。一个函数允许我们从画布上下文中检索像素数据，另一个函数允许我们将像素缓冲区放回到画布上下文中。此外，还有一个函数允许我们将像素数据作为数据URL检索出来，这意味着我们可以将画布中的图像数据保存到用户的文件系统中，就像我们可以使用`<img
    />`标签中的常规图像一样。
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To get the pixel data representing whatever is currently drawn in the canvas,
    we can use the function `getImageData`. The four parameters are the x and y offset
    on the source image, along with the width and height to be extracted. Note that
    the output from this function is an object of type `ImageData`, which has three
    attributes, namely, width, height, and a typed array with the actual pixel information.
    As mentioned earlier in the chapter, this typed array is of type `Uint8ClampedArray`,
    where each element can only be an `integer` with a value between 0 and 255 inclusive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取表示当前在画布上绘制的内容的像素数据，我们可以使用`getImageData`函数。四个参数是源图像上的x和y偏移量，以及要提取的宽度和高度。请注意，这个函数的输出是一个`ImageData`类型的对象，它有三个属性，即宽度、高度和包含实际像素信息的类型化数组。正如本章前面提到的，这个类型化数组是`Uint8ClampedArray`类型的，其中每个元素只能是一个值在0到255之间的整数。
- en: The pixel data is a buffer of length (`canvas.width x canvas.height x 4`). That
    is, each four elements represent one pixel, representing the red, green, blue,
    and alpha channels of the pixel in this order. Thus, in order to manipulate an
    image through this canvas API, we perform various calculations on this pixel buffer,
    which we can then put back in the canvas using the `putImageData` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 像素数据是一个长度为(`canvas.width x canvas.height x 4`)的缓冲区。也就是说，每四个元素代表一个像素，按照红色、绿色、蓝色和alpha通道的顺序表示像素。因此，为了通过这个画布API操纵图像，我们对这个像素缓冲区进行各种计算，然后可以使用`putImageData`函数将其放回画布。
- en: The three parameters of `putImageData` are the `ImageData` object, along with
    the x and y offset on the destination canvas. From there, the canvas will render
    the image data as far as it can, clipping any extra data that would otherwise
    be drawn outside the canvas.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`putImageData`的三个参数是`ImageData`对象，以及目标画布上的x和y偏移量。从那里，画布将尽可能地呈现图像数据，裁剪任何多余的数据，否则会被绘制在画布外部。'
- en: As an example of what we can do with an image, we'll take the HTML5 logo that
    we drew into the canvas, and apply a gray scale function to the pixel data representing
    it. If this sounds like a complex task, fear not. While there are several different
    formulas to turn a color image into gray scale, the easiest way to do this is
    to simply average the red, green, and blue values of each pixel.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们可以用图像做的一个例子，我们将取出我们在画布上绘制的HTML5标志，并对代表它的像素数据应用灰度函数。如果这听起来像一个复杂的任务，不用担心。虽然有几种不同的公式可以将彩色图像转换为灰度图像，但最简单的方法是简单地对每个像素的红色、绿色和蓝色值求平均值。
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Manipulating pixels](img/6029OT_05_12.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![操作像素](img/6029OT_05_12.jpg)'
- en: Manipulating an image is no more complex than performing various calculations
    on each pixel of the pixel buffer that represents an image.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵图像并不比对代表图像的像素缓冲区中的每个像素进行各种计算更复杂。
- en: Finally, the way we can export the image from a canvas is as simple as calling
    the `toDataURL` function. Make a special note that this function is called on
    the canvas object, and not on the rendering context object. The `toDataURL` function
    of the canvas object takes two optional parameters, namely, a string representing
    the MIME type of the output image, and a `float` between `0.0` and `1.0`, representing
    the quality of the output image. If the output image type is anything other than
    `"image/jpeg"`, the quality parameter is ignored.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过调用`toDataURL`函数来从画布中导出图像。特别注意，这个函数是在画布对象上调用的，而不是在渲染上下文对象上调用的。画布对象的`toDataURL`函数接受两个可选参数，即表示输出图像的MIME类型的字符串，以及一个介于`0.0`和`1.0`之间的`float`，表示输出图像的质量。如果输出图像类型不是`"image/jpeg"`，则忽略质量参数。
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Web workers
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web workers
- en: Web workers bring the ability to execute code outside the main UI thread. This
    thread-like behavior allows us to perform long lasting tasks without blocking
    the user interface. When a JavaScript task takes too long to complete, the browser
    displays an alert to the user, letting the user know that the page is not responsive.
    Using web workers, we can solve this problem.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Web workers带来了在主UI线程之外执行代码的能力。这种类似线程的行为使我们能够执行长时间的任务而不阻塞用户界面。当一个JavaScript任务花费太长时间来完成时，浏览器会向用户显示一个警报，让用户知道页面没有响应。使用web
    workers，我们可以解决这个问题。
- en: There are a few restrictions with web workers that we need to keep in mind.
    First, workers run outside the DOM, so any functionality related to that is not
    available inside worker threads. Also, there is no concept of shared memory with
    workers—any data that is passed to and from a worker is copied into its own memory
    space. Finally, any objects passed to and from a worker can contain any data types,
    except for functions. If you attempt to pass a function to or from a worker (or
    an object holding a reference to a function), the browser will throw a **DataCloneError**
    (DOM Exception 25).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于web workers，我们需要牢记一些限制。首先，workers在DOM之外运行，因此任何与DOM相关的功能在worker线程内不可用。此外，workers没有共享内存的概念——传递给worker的任何数据都会被复制到它自己的内存空间中。最后，传递给和从worker传递的任何对象都可以包含任何数据类型，除了函数。如果尝试传递函数给worker（或者包含对函数引用的对象），浏览器将抛出一个**DataCloneError**（DOM
    Exception 25）。
- en: On the other hand, workers are completely capable of firing XHR requests (Ajax
    calls), starting other workers, and stopping other workers, including themselves.
    Once a worker is terminated, it can no longer be started, similar to other threading
    constructs available in other languages such as Java.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，workers完全能够发起XHR请求（Ajax调用），启动其他workers，并停止其他workers，包括它们自己。一旦worker被终止，它就不能再启动，类似于其他语言中可用的其他线程构造。
- en: How to use it
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用它
- en: In this section, we'll create a sample mini application that generates prime
    numbers in a worker thread. The user can input a number into the application,
    and the application will return a list of primes up to that number. Those prime
    numbers will then be passed back to the main application, which will then list
    the prime numbers back to the user.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个示例迷你应用程序，该应用程序在一个工作线程中生成素数。用户可以在应用程序中输入一个数字，应用程序将返回一个小于该数字的素数列表。然后这些素数将被传回主应用程序，主应用程序将把素数列表返回给用户。
- en: To get started with web workers, we must first create a separate JavaScript
    file that will be run in the worker thread. The way this script will communicate
    with its parent thread is through messages. In order to receive messages from
    a parent thread, the worker needs to register a callback function that is called
    whenever a message is passed to it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Web Workers，我们必须首先创建一个单独的JavaScript文件，该文件将在工作线程中运行。该脚本将通过消息与其父线程通信。为了从父线程接收消息，工作线程需要注册一个回调函数，每当有消息传递给它时就会被调用。
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function is called when a message is received, both in the worker thread
    and in its parent thread, and a `MessageEvent` object is passed to the function.
    This object contains many attributes, including a timestamp, and most importantly,
    a data attribute, which contains any data passed into the worker.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到消息时，该函数在工作线程和其父线程中都会被调用，并且会传递一个`MessageEvent`对象。该对象包含许多属性，包括时间戳，最重要的是一个数据属性，其中包含传递给工作线程的任何数据。
- en: To post a message to a worker or back to its parent, we simply call the function
    `postMessage` on the appropriate object (either the worker object, or on the self-object,
    if inside a worker), passing the data along with the function call. This data
    can be a single value, an array, or an object of any type, as long as no functions
    are included.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要向工作线程或其父级发送消息，我们只需在适当的对象上调用`postMessage`函数（无论是工作对象还是在工作线程中的self对象），并将数据与函数调用一起传递。这些数据可以是单个值、数组或任何类型的对象，只要不包括函数。
- en: 'Finally, to create a `worker` object, we simply create an instance of the class
    `Worker`, passing the path to the worker script as a constructor parameter. This
    `worker` object will need to register callback functions for whatever events it
    wants to observe: `onMessage` or `onError`. To kill the worker thread, we can
    either call the `terminate` function directly on the worker object, or the `close`
    function on the worker script.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要创建一个`worker`对象，我们只需创建`Worker`类的一个实例，并将工作脚本的路径作为构造函数参数传递。这个`worker`对象将需要为它想要观察的任何事件注册回调函数：`onMessage`或`onError`。要终止工作线程，我们可以直接在工作对象上调用`terminate`函数，或者在工作脚本上调用`close`函数。
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the above snippet, we set up two things: a worker and an input field. We
    then set up a `keydown` listener on the input field, which we use so the user
    can input a number to send to the worker. To send this number to the worker, the
    user must press the **Enter** key. When that happens, the number in the input
    field will be the highest possible prime number generated by the worker. If the
    user inputs the number `-1`, the worker is terminated, and the input field is
    removed from the DOM.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们设置了两件事：一个工作线程和一个输入字段。然后我们在输入字段上设置了一个`keydown`监听器，这样用户就可以输入一个数字发送到工作线程。要将这个数字发送到工作线程，用户必须按下**Enter**键。当发生这种情况时，输入字段中的数字将是工作线程生成的最大可能的素数。如果用户输入数字`-1`，则工作线程将被终止，并且输入字段将从DOM中移除。
- en: For simplicity, the worker thread will use the **Sieve of Eratosthenes** to
    find the primes. Keep in mind that this exercise is only a proof of concept to
    illustrate how web workers work, and not a lesson on advanced mathematics.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，工作线程将使用**埃拉托斯特尼筛法**来查找素数。请记住，这个练习只是一个概念验证，用来说明Web Workers的工作原理，而不是高级数学课程。
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![How to use it](img/6029OT_05_13.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: 如何使用它
- en: The worker can be invoked an infinite amount of times, as long as it is not
    terminated. Once terminated, the worker can be deleted, as it serves no useful
    purpose from that point on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 只要工作线程没有被终止，就可以无限次地调用工作线程。一旦终止，工作线程就可以被删除，因为从那时起它就没有任何有用的目的了。
- en: Offline application cache
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线应用程序缓存
- en: Offline application cache is a way to store assets on the browser for use when
    the user is not connected to the internet. This API further breaks down any barriers
    between a native application and a web application, since it does away with the
    major characteristic that sets a web application apart from a native one—the need
    for a connection to the World Wide Web. Although the user will obviously still
    need to be connected to the network at some point, so the application can be downloaded
    initially; after that, the application can run completely from the user's cache.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 离线应用程序缓存是一种在浏览器上存储资产以供用户在未连接到互联网时使用的方法。这个API进一步消除了本地应用程序和Web应用程序之间的任何障碍，因为它消除了将Web应用程序与本地应用程序区分开来的主要特征——对全球网络的连接需求。尽管用户显然仍然需要在某个时候连接到网络，以便可以最初下载应用程序；之后，应用程序可以完全从用户的缓存中运行。
- en: Probably the main use case for offline application cache is when the user's
    connection is not stable, consistent, or simply not on every time the application
    is used. This is especially true with games, as the user may choose to play a
    certain online game some of the time, but offline later on. Similarly, if the
    game needs to connect to a backend server, in order to perform whatever task (such
    as to retrieve new game data), this can be done whenever the user is connected,
    the resources can be again cached locally, and the new data can be used again,
    if and when the user's connectivity becomes unavailable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 离线应用程序缓存的主要用例可能是当用户的连接不稳定、一致或者在每次使用应用程序时都不连接的情况。这在游戏中尤其如此，因为用户可能选择在某些时间玩某个在线游戏，但之后离线。同样，如果游戏需要连接到后端服务器，以执行任何任务（例如检索新的游戏数据），只要用户连接，资源就可以再次被缓存在本地，新数据可以在用户的连接不可用时再次使用。
- en: How to use it
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用它
- en: The backbone of the offline application cache API is the manifest file, which
    specifies to the browser which resources should be cached for offline use, which
    resources must never be cached, and what the browser should do when an attempt
    is made to connect to the server, but no connection is found.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 离线应用程序缓存API的核心是清单文件，它指定了浏览器应该为离线使用缓存哪些资源，哪些资源绝对不能被缓存，以及当尝试连接到服务器但找不到连接时浏览器应该做什么。
- en: The manifest file is served with the HTML file that the user requests, when
    loading your application. More specifically, the host HTML file specifies the
    path to the manifest file, which the browser then fetches and processes in parallel,
    with the download and processing of the main application. This is done with the
    `manifest` attribute in the root `html` tag.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载应用程序时，清单文件与用户请求的HTML文件一起提供。更具体地说，主机HTML文件指定了清单文件的路径，然后浏览器并行获取和处理主应用程序的下载和处理。这是通过根`html`标记中的`manifest`属性完成的。
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Observe that the above snippet specifies a manifest file named `manifest.appcache`,
    located in the same directory as the HTML file specifying the manifest. The name
    of the file, along with its extension, is completely arbitrary. By convention,
    many developers named the manifest simply `manifest.appcache`, `manifest` (without
    an extension), or `appcache.manifest`. However, this file could very well be named
    `manifest.php?id=2642`, `my-manifest-file.txt`, or `the_file.json`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面的片段指定了一个名为`manifest.appcache`的清单文件，位于指定清单的HTML文件相同的目录中。文件的名称和扩展名完全是任意的。按照惯例，许多开发人员简单地将清单命名为`manifest.appcache`、`manifest`（没有扩展名）或`appcache.manifest`。但是，这个文件也可以被命名为`manifest.php?id=2642`、`my-manifest-file.txt`或`the_file.json`。
- en: An important thing to remember is that the manifest file be served with the
    proper MIME type. If the browser attempts to fetch whatever file is listed in
    the `manifest` attribute of the root HTML tag, and the MIME type is not `text/cache-manifest`,
    then the browser will reject the manifest, and no offline application cache will
    take place.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一件重要的事情是，清单文件必须以正确的MIME类型提供。如果浏览器尝试获取根HTML标记中`manifest`属性中列出的任何文件，并且MIME类型不是`text/cache-manifest`，那么浏览器将拒绝清单，并且不会发生离线应用程序缓存。
- en: 'There are many ways to set the MIME type to a file, but generally this is a
    server setting. If using an Apache server, such as the one we are using with WAMP,
    MAMP, or LAMP (see the online chapter, *Setting Up the Environment*), we can easily
    do this with a `.htaccess` file. For example, in the root directory of our project,
    we can create a file named `.htaccess` containing the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设置文件的MIME类型有很多种方法，但通常这是服务器设置。如果使用Apache服务器，比如我们在WAMP、MAMP或LAMP中使用的服务器（请参阅在线章节《设置环境》），我们可以通过`.htaccess`文件轻松实现这一点。例如，在我们项目的根目录中，我们可以创建一个名为`.htaccess`的文件，其中包含以下代码：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This would tell the server to add the right MIME type to any file with an extension
    of `.appcache`. Of course, if you decide to tweak the `htaccess` file to serve
    the `cache-manifest` MIME type to other file extensions, you could possibly run
    into issues if the extension you choose is already associated with other MIME
    types (such as `.json`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉服务器为任何扩展名为`.appcache`的文件添加正确的MIME类型。当然，如果您决定调整`htaccess`文件以为其他文件扩展名提供`cache-manifest`
    MIME类型，如果您选择的扩展名已经与其他MIME类型相关联（例如`.json`），可能会遇到问题。
- en: 'The first line of the manifest file must be the following string:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件的第一行必须是以下字符串：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If this line isn''t present again, the entire API will take no effect. If there
    is as much as an extra white space before the string listed above, the browser
    will throw the following error, indicating that the file manifest is invalid,
    and nothing will be cached:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一行不存在，整个API将不起作用。如果在上述列出的字符串之前有多余的空格，浏览器将抛出以下错误，指示文件清单无效，并且不会被缓存：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using offline application cache on your games, make sure to keep an open
    eye on your browser's JavaScript console. If anything goes wrong at all, such
    as finding the manifest file, parsing the manifest, or loading any of the resources
    described in the manifest, the browser will let you know that something went wrong
    by raising an exception, but it will go on. Unlike most fatal JavaScript exceptions,
    a fatal offline application cache exception doesn't stop or influence the execution
    of the script that initiated the caching process. Thus, you may be getting app
    cache exceptions and not know it, so get acquainted with whatever developer tools
    your browser supports, and make good of it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中使用离线应用程序缓存时，请确保密切关注浏览器的JavaScript控制台。如果出现任何问题，比如找不到清单文件、解析清单或加载清单中描述的任何资源，浏览器会通过引发异常来告诉您发生了错误，但它会继续执行。与大多数致命的JavaScript异常不同，致命的离线应用程序缓存异常不会停止或影响启动缓存过程的脚本的执行。因此，您可能会遇到应用程序缓存异常而不知道，因此熟悉浏览器支持的任何开发人员工具，并充分利用它。
- en: The rest of the manifest can be divided into three main categories, namely,
    assets to be cached, assets to never be cached, and the fallback asset. Comments
    can be placed anywhere within the file, and are denoted by a pound sign. The entire
    line following a pound sign is ignored by the manifest parser.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 清单的其余部分可以分为三个主要类别，即要缓存的资产、永远不要缓存的资产和回退资产。注释可以放置在文件的任何位置，并以井号表示。井号后的整行将被清单解析器忽略。
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: By using the wild card under the network section, we indicate that any resource
    not specified under cache, qualified under the network section, meaning that those
    resources are not to be cached. Any attempt to load those resources when network
    access is not available will result in the fallback file being loaded instead.
    This is a good option to let the user know that network access is needed without
    needing to special case any extra code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在网络部分使用通配符，我们指示任何未在缓存下指定的资源都属于网络部分，这意味着这些资源不会被缓存。在没有网络访问时尝试加载这些资源将导致加载回退文件。这是一个很好的选择，可以让用户知道需要网络访问，而无需特殊处理任何额外的代码。
- en: Once the manifest is parsed and all the resources are cached, all of the resources
    will remain cached, until the user deletes the offline application cache data
    (or all of the data cached by the browser), or the manifest is changed. Even if
    only a single character changes in the manifest file, the browser will consider
    it to be an update, thus, all of the resources are cached anew. Because of this,
    many developers write a comment line right at the top of the manifest file that,
    among other optional things, they include some sort of version number that identifies
    a unique version of the manifest. This way, if one or more assets changes, we
    can force the browser to re-cache those assets by simply changing the version
    number listed in the manifest file. Remember, the browser will only check the
    text in the manifest file in order to determine if it needs to download new assets.
    If assets change (say, you update JavaScript code listed in the manifest, or some
    graphics, or any other resource), but the manifest text doesn't, those resources
    will not be pulled from the server, and the user will continue to use an outdated
    asset in his or her application, since the assets are loaded only from the cache.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清单被解析并且所有资源都被缓存，所有资源将保持缓存，直到用户删除离线应用程序缓存数据（或浏览器缓存的所有数据），或者清单被更改。即使清单文件中只有一个字符发生变化，浏览器也会认为它是一个更新，因此所有资源都会被重新缓存。因此，许多开发人员在清单文件的顶部写下了一行注释，其中包括一些版本号，用于标识清单的唯一版本。这样，如果一个或多个资产发生变化，我们可以通过简单地更改清单文件中列出的版本号来强制浏览器重新缓存这些资产。请记住，浏览器只会检查清单文件中的文本，以确定是否需要下载新的资源。如果资源发生变化（比如，您更新了清单中列出的
    JavaScript 代码，或者一些图形，或者任何其他资源），但清单文本没有变化，这些资源将不会从服务器上拉取，用户将继续使用应用程序中过时的资产，因为资产只从缓存中加载。
- en: The code
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'The way this game was laid out is actually quite simple. The HTML has only
    three widgets: the title of the game, a score board for the player''s current
    score, and a score board for the overall high score across multiple games. This
    last score board is not used in this version of the game, and we''ll get more
    into it in the next game (see [Chapter 5](ch05.html "Chapter 5. Improving the
    Snake Game"), *Improving the Snake Game*).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的布局实际上非常简单。HTML 只有三个小部件：游戏的标题，玩家当前得分的计分板，以及跨多个游戏的总高分计分板。这个最后的计分板在这个版本的游戏中没有使用，我们将在下一个游戏中更深入地讨论它（参见[第5章](ch05.html
    "第5章。改进蛇游戏")，“改进蛇游戏”）。
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In order to separate the various responsibilities from all the different components
    in the game, we abstracted out all the rendering for the entire game into a single
    `Renderer` class. This class is in charge of drawing data to a `canvas` reference
    that is given to it. The data that it draws, be it a snake or any other objects,
    is passed in to it as a typed array, representing the coordinates where the entity
    is to be drawn, along with the image resource that is drawn at the location specified
    by the typed array. The `Renderer` class also includes a few helper functions
    to help us easily clear the canvas, and convert an `x` and `y` point into an index
    used to traverse the flat array representing a 2D one.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将游戏中所有不同组件的各种责任分开，我们将整个游戏的渲染抽象成一个单独的“Renderer”类。这个类负责向给定的“canvas”引用绘制数据。它绘制的数据，无论是蛇还是其他对象，都以类型化数组的形式传递给它，表示实体要绘制的坐标，以及在类型化数组指定的位置绘制的图像资源。
    “Renderer”类还包括一些辅助函数，帮助我们轻松清除画布，并将“x”和“y”点转换为用于遍历表示2D数组的扁平数组的索引。
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we create a `Snake` class that encapsulates all of the data and behavior
    associated with the snake. The data that this class stores is the current position
    of the snake's head, the current length of the snake's body, the image that is
    to be drawn representing the snake, and whether the snake is alive or not. The
    behavior that it handles includes the moving of the snake and the handling of
    user input (which is included in this class for simplicity and brevity). There
    are a few helper functions that allow us to delegate other behaviors to the client.
    For example, through the API exposed, the client can check at each frame whether
    the snake has gone outside the world grid, if it has eaten a fruit, or if the
    snake ran into its own body. The client can also use the API provided, to take
    action on the snake, such as setting its life attribute (dead or alive), as well
    as reset the image used to draw the snake, or any other attribute of it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个“Snake”类，它封装了与蛇相关的所有数据和行为。这个类存储的数据包括蛇头的当前位置，蛇身的当前长度，代表蛇的绘制图像，以及蛇是否存活。它处理的行为包括移动蛇和处理用户输入（为简单起见，这些都包含在这个类中）。还有一些辅助函数，允许我们将其他行为委托给客户端。例如，通过公开的
    API，客户端可以在每一帧检查蛇是否超出了世界网格，它是否吃了水果，或者蛇是否撞到了自己的身体。客户端还可以使用提供的 API 对蛇采取行动，比如设置它的生命属性（死或活），以及重置用于绘制蛇的图像，或者它的任何其他属性。
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Similar to the `snake` class, we also create a class to encapsulate the fruit
    that the snake will eat. The only difference between the `snake` class and the
    `fruit` class is that the `fruit` class will not do anything other than show up
    in the map. For all practical purposes, the `fruit` class shares a common entity
    interface with the `snake` class, which allows them to be reset to a default state,
    set their position, and check for collision.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与`snake`类类似，我们还创建了一个类来封装蛇将要吃的水果。`snake`类和`fruit`类之间唯一的区别是`fruit`类除了出现在地图上之外不会做任何其他事情。在实际目的上，`fruit`类与`snake`类共享一个公共实体接口，允许它们被重置为默认状态，设置它们的位置，并检查碰撞。
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, in the main code, we perform the following setup task:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在主代码中，我们执行以下设置任务：
- en: Create a canvas element and attach it to the DOM.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个canvas元素并将其附加到DOM。
- en: Instantiate the `renderer`, `snake`, and `fruit` objects.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化`renderer`、`snake`和`fruit`对象。
- en: Create a game loop that places a fruit on the grid when one is not present,
    update the snake's position, check where the snake is, and render the game state
    to the canvas.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个游戏循环，在没有水果存在时在网格上放置一个水果，更新蛇的位置，检查蛇的位置，并将游戏状态渲染到画布上。
- en: We also use the game loop to hook into the score board widgets, to add to the
    user experience. The complete source code for the game available at the book's
    page on the website of Packt Publishing also includes extra menus, but these have
    been left out of the code snippets shown here for brevity.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用游戏循环来连接记分牌小部件，以增强用户体验。游戏的完整源代码可在Packt Publishing网站上的书页上找到，还包括额外的菜单，但由于简洁起见，这些菜单已经从这里显示的代码片段中删除。
- en: The other thing we take advantage of in this game loop is the `requestAnimationFrame`
    API. In order to assure that different CPUs and GPUs, all render the game at the
    same pace, we added a simple frame rate controller inside the game loop. The frame
    rate is controlled by a variable that specified how many fps the game should attempt
    to run.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏循环中，我们还利用了`requestAnimationFrame`API。为了确保不同的CPU和GPU以相同的速度渲染游戏，我们在游戏循环内添加了一个简单的帧速率控制器。帧速率由一个变量控制，指定游戏应该尝试以多少fps运行。
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the chapter we got started with 2D rendering using the long-awaited canvas
    API. We looked at the various drawing functions available to us through the canvas
    rendering context, which includes drawing simple lines and shapes, drawing images
    from an external image source, pixel manipulation, and image extraction, which
    allows us to save the image from the canvas back to the user's file system.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始使用备受期待的canvas API进行2D渲染。我们研究了通过canvas渲染上下文可用的各种绘图函数，包括绘制简单的线条和形状，从外部图像源绘制图像，像素操作和图像提取，这使我们能够将画布上的图像保存回用户的文件系统。
- en: We also looked at the new threading system available to us through the web worker
    interface. This allows us to free up the user interface thread, while we perform
    long lasting tasks that would otherwise lock up the interface, and cause the browser
    to display a non-responsive page alert. Unfortunately, there are a few limitations
    to web workers, since there is no shared memory between workers, and no DOM associated
    with, or allowed in a worker thread. Still, much can be done with this magnificent
    new feature of HTML5.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了通过Web Worker接口可用的新线程系统。这使我们能够释放用户界面线程，同时执行长时间运行的任务，否则会锁定界面，并导致浏览器显示非响应页面警报。不幸的是，Web
    Worker存在一些限制，因为工作线程之间没有共享内存，也不允许在工作线程中关联或允许DOM。尽管如此，HTML5的这一壮丽新功能仍然可以完成许多工作。
- en: The other HTML5 specific API that we covered in the chapter was the offline
    application cache. Through this mechanism, we can save specific assets from a
    web server, storing it as a fast, highly available cache, powered by the user's
    browser. The specific assets that are saved by the browser are specified by a
    manifest file, while it is a simple text-based file, and must be served by the
    server with the `text/cache-manifest` MIME type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖的另一个HTML5特定API是离线应用程序缓存。通过这种机制，我们可以从Web服务器保存特定资产，将其存储为快速、高可用的缓存，由用户的浏览器提供支持。浏览器保存的特定资产由清单文件指定，虽然它是一个简单的基于文本的文件，并且必须由服务器以`text/cache-manifest`
    MIME类型提供。
- en: Finally, we looked at two new additions to the JavaScript language that make
    game development more efficient and exciting. The first of these two features
    is `requestAnimationFrame`, which allows us to render all of our content in a
    single, synchronized call, managed by the browser itself. This is often the best
    way possible to render all of our graphics, since the browser can highly optimize
    the rendering process. The second feature is the typed array data type, which
    allows for much efficient data storage and access. This is especially attractive
    to game development because of the extra boost in performance we can get, just
    by using this new data type, even though it looks and behaves almost 100% the
    same as regular arrays. Thus, writing new code using typed arrays should include
    no learning curve whatsoever, as porting existing code that uses arrays is a real
    treat.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还研究了JavaScript语言的两个新功能，使游戏开发更加高效和令人兴奋。这两个功能中的第一个是`requestAnimationFrame`，它允许我们在单个同步调用中渲染所有内容，由浏览器自己管理。这通常是渲染所有图形的最佳方式，因为浏览器可以高度优化渲染过程。第二个功能是类型化数组数据类型，它允许更高效的数据存储和访问。这对游戏开发特别有吸引力，因为我们可以通过使用这种新的数据类型获得额外的性能提升，即使它看起来和行为几乎与常规数组完全相同。因此，使用类型化数组编写新代码应该完全没有学习曲线，因为迁移使用数组的现有代码是一种真正的享受。
- en: In the next chapter we continue working on the Snake game, making it more robust
    and feature rich. We'll learn about four more HTML5 APIs, namely sessionStorage,
    localStorage, IndexedDB, and web messaging.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续改进Snake游戏，使其更加健壮和功能丰富。我们将学习另外四个HTML5 API，即sessionStorage、localStorage、IndexedDB和web
    messaging。
