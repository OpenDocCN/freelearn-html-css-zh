- en: Chapter 5. Improving the Snake Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。改进贪吃蛇游戏
- en: This chapter is the second and final part of the series where we're building
    a more robust snake game. In this chapter, we'll take what we already had from
    [Chapter 3](ch03.html "Chapter 3. Understanding the Gravity of HTML5"), *Understanding
    the Gravity of HTML5*, and add more HTML5 APIs to it, so as to make the game more
    feature rich, providing an even more engaging user experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是我们构建更健壮的贪吃蛇游戏系列的第二部分，也是最后一部分。在本章中，我们将继续使用[第3章](ch03.html "第3章。理解HTML5的重要性")中已有的内容，*理解HTML5的重要性*，并向其中添加更多的HTML5
    API，以使游戏更加丰富，提供更加引人入胜的用户体验。
- en: The first version of the game used five HTML5 concepts, namely 2D canvas rendering,
    offline application cache, web workers, typed arrays, and requestAnimationFrame.
    In this version, we'll include two features from the new web storage API, namely
    local storage and session storage. We'll also look at a third API that is part
    of web storage, IndexedDB, as well as the web messaging feature, which includes
    cross-domain messaging.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的第一个版本使用了五个HTML5概念，即2D画布渲染、离线应用程序缓存、Web Workers、类型化数组和requestAnimationFrame。在这个版本中，我们将包括来自新Web存储API的两个功能，即本地存储和会话存储。我们还将研究Web存储的一部分，即IndexedDB，以及包括跨域消息传递的Web消息传递功能。
- en: Local storage and session storage are two mechanisms that allow us to save data
    on the user's browser using a key-value strategy. This is similar to a cookie,
    where every value must be a string. The difference between these two storage options
    and a cookie, first and foremost, is that a cookie is always sent back to the
    server through HTTP requests. This can be especially undesirable when we have
    larger amounts of data that we would like to store, since that data would be traveling
    around consuming extra bandwidth, and there is nothing that we can do about it.
    With HTML5's web storage, we can save more data locally, and that data never leaves
    the user's machine, though HTTP components like cookies do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储和会话存储是两种机制，允许我们使用键值策略在用户的浏览器上保存数据。这类似于cookie，其中每个值必须是一个字符串。这两种存储选项与cookie之间的区别首先是，cookie始终通过HTTP请求发送回服务器。当我们希望存储更多数据时，这可能特别不希望发生，因为数据会在网络中传输，消耗额外的带宽，而我们无能为力。使用HTML5的Web存储，我们可以在本地保存更多数据，而这些数据永远不会离开用户的机器，尽管像cookie这样的HTTP组件会离开。
- en: IndexedDB, also part of web storage, is similar to local and session storage,
    where data is stored in a key-value manner, but instead of values being limited
    to strings only, IndexedDB is more of an object store, where we can store entire
    JavaScript objects. Of course, IndexedDB is much more than a mere hash map that
    holds objects for us. As the name implies, this new API allows us to index these
    stored objects with the purpose of being able to search for them through a query
    system. In summary, IndexedDB is a NoSQL database accessed through an asynchronous
    programming interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB，也是Web存储的一部分，类似于本地和会话存储，数据以键值方式存储，但是与仅限于字符串的值不同，IndexedDB更像是一个对象存储，我们可以存储整个JavaScript对象。当然，IndexedDB远不止是一个简单的哈希映射，用于为我们保存对象。正如其名称所示，这个新的API允许我们对这些存储的对象进行索引，以便通过查询系统进行搜索。总之，IndexedDB是一个通过异步编程接口访问的NoSQL数据库。
- en: Finally, the web messaging API provides an interface through which an HTML document
    can communicate with other HTML contexts. These documents can be related by iframes,
    in separate windows, and even in different domains.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Web消息传递API提供了一个接口，通过该接口，HTML文档可以与其他HTML上下文进行通信。这些文档可以通过iframe相关联，在单独的窗口中，甚至在不同的域中。
- en: The game
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: 'Two new features were added to this second version of the game. First, we now
    keep track of the highest score achieved by a player, saving it through local
    storage. Even if the player closes the browser application, or turns off the computer,
    that value will still be safely stored in the player''s hard drive, and will be
    loaded when the game starts again. Second, we use session storage to save the
    game state every time the player eats a fruit in the game, and whenever the player
    kills the snake. This is used as an extra touch of awesomeness, where after the
    player loses, we display a snapshot of all the individual level ups the player
    achieved in that game, as well as a snapshot of when the player hit a wall or
    run the snake into itself, as shown in the following screenshot:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏的第二个版本中添加了两个新功能。首先，我们现在可以跟踪玩家获得的最高分，并通过本地存储保存它。即使玩家关闭浏览器应用程序或关闭计算机，该值仍将安全地存储在玩家的硬盘上，并在游戏重新开始时加载。其次，我们使用会话存储在玩家在游戏中吃水果时以及玩家杀死蛇时保存游戏状态。这被用作额外的精彩之处，当玩家失败时，我们会显示玩家在游戏中实现的所有单独的升级，以及玩家撞墙或撞到蛇时的快照，如下图所示：
- en: '![The game](img/6029OT_06_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![游戏](img/6029OT_06_01.jpg)'
- en: At the end of each game, an image is shown of each moment when the player acquired
    a level up, as well as a snapshot of when the player eventually died. This images
    are created through the canvas API (calling the `toDataURL` function), and the
    data that composes each image is saved throughout the game, and stored using the
    web storage API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在每局游戏结束时，会显示玩家获得升级的瞬间图像，以及玩家最终死亡的快照。这些图像是通过canvas API（调用`toDataURL`函数）创建的，并且组成每个图像的数据在整个游戏中都会被保存，并使用Web存储API进行存储。
- en: With a feature such as this in place, we make the game much more fun, and potentially
    much more social. Imagine how powerful it would be if the player could post, not
    only his or her high score to their favorite social network website, but also
    pictures of their game at key moments. Of course, only the foundation of this
    feature is implemented in this chapter (in other words, we only take the snapshots
    of these critical moments in the game). Adding the actual functionality to send
    that data to a real social network application is left as an exercise for the
    reader.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样一个功能，我们可以使游戏变得更加有趣，可能也更加社交化。想象一下，如果玩家不仅可以将他们的最高分发布到他们最喜欢的社交网络网站，还可以在关键时刻发布游戏的图片，那将会有多么强大。当然，这个功能的基础只是在本章中实现了（换句话说，我们只是在游戏的关键时刻拍摄了快照）。将实际功能添加到将这些数据发送到真正的社交网络应用程序中，留给读者作为练习。
- en: API usage
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API使用
- en: A general description and demonstration of each of the APIs used in the game
    are given in the following sections. For an explanation of how each piece of functionality
    was incorporated into the final game, look at the code section. For the complete
    source code for this game, check out the book's page from Packt Publishing's website.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中使用的每个API的一般描述和演示在以下部分中给出。要了解每个功能是如何被整合到最终游戏中的，请查看代码部分。要获取此游戏的完整源代码，请查看Packt
    Publishing网站上的书页。
- en: Web messaging
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web消息传递
- en: Web messaging allows us to communicate with other HTML document instances, even
    if they're not in the same domain. For example, suppose our snake game, hosted
    at [http://snake.fun-html5-games.com](http://snake.fun-html5-games.com), is embedded
    into a social website through `iframe` (let's say this social website is hosted
    at [http://www.awesome-html5-games.net](http://www.awesome-html5-games.net)).
    When the player achieves a new high score, we want to post that data from the
    snake game directly into the host page (the page with `iframe` from which the
    game is loaded). With the web messaging API, this can be done natively, without
    the need for any server-side scripting whatsoever.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Web消息传递允许我们与其他HTML文档实例进行通信，即使它们不在同一个域中。例如，假设我们的贪吃蛇游戏托管在[http://snake.fun-html5-games.com](http://snake.fun-html5-games.com)，通过`iframe`嵌入到一个社交网站中（假设这个社交网站托管在[http://www.awesome-html5-games.net](http://www.awesome-html5-games.net)）。当玩家获得新的最高分时，我们希望将来自贪吃蛇游戏的数据直接发布到主页（加载游戏的`iframe`页面）。使用Web消息传递API，这可以在本地完成，而无需任何服务器端脚本。
- en: Before web messaging, documents were not allowed to communicate with documents
    in other domains mostly because of security. Of course, web applications can still
    be vulnerable to malicious external applications if we just blindly take messages
    from any application. However, the web messaging API provides some solid security
    measures to protect the page receiving the message. For example, we can specify
    the domains that the message is going to, so that other domains cannot intercept
    the message. On the receiving end, we can also check the origin from whence the
    message came, thus ignoring messages from any untrusted domains. Finally, the
    DOM is never directly exposed through this API, providing yet another layer of
    security.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web消息传递之前，文档通常不允许与其他域中的文档通信，主要是因为安全性的原因。当然，如果我们盲目地接受来自任何应用程序的消息，Web应用程序仍然可能容易受到恶意外部应用程序的攻击。然而，Web消息传递API提供了一些可靠的安全措施来保护接收消息的页面。例如，我们可以指定消息要发送到的域，以便其他域无法拦截消息。在接收端，我们还可以检查消息的来源，从而忽略来自任何不受信任域的消息。最后，DOM永远不会直接通过此API暴露，提供了另一层安全性。
- en: How to use it
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用它
- en: 'Similar to web workers, the way in which two or more HTML contexts can communicate
    through the web messaging API is by registering an event handler for the on-message
    event, and sending messages out by using the `postMessage` function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web Workers类似，两个或多个HTML上下文之间通过Web消息传递API进行通信的方式是注册`on-message`事件的事件处理程序，并使用`postMessage`函数发送消息：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first step to using the web messaging API is to get a reference to some
    document with whom we wish to communicate. This can be done by getting the `contentWindow`
    property of an `iframe` reference, or by opening a new window and holding on to
    that reference. The document that holds this reference is called the parent document,
    since this is where the communication is initiated. Although a child window can
    communicate with its parent, this can only happen when and for as long as this
    relationship holds true. In other words, a window cannot communicate with just
    any window; it needs a reference to it, either through a parent-child relationship,
    or through a child-parent relationship.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web消息传递API的第一步是获取要与之通信的某个文档的引用。这可以通过获取`iframe`引用的`contentWindow`属性，或者打开一个新窗口并保留该引用来完成。持有此引用的文档称为父文档，因为这是通信发起的地方。尽管子窗口可以与其父窗口通信，但这只能在这种关系成立的情况下发生。换句话说，窗口不能与任何窗口通信；它需要一个引用，无论是通过父子关系还是通过子父关系。
- en: Once the child window has been referenced, the parent can fire messages to its
    children through the `postMessage` function. Of course, if the child window hasn't
    defined a callback function to capture and process the incoming messages, there
    is little purpose in sending those messages in the first place. Still, the parent
    has no way of knowing if a child window has defined a callback to process incoming
    messages, so the best we can do is assume (and hope) that the child window is
    ready to receive our messages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引用了子窗口，父窗口就可以通过`postMessage`函数向其子窗口发送消息。当然，如果子窗口没有定义回调函数来捕获和处理传入的消息，那么发送这些消息就没有什么意义。但是，父窗口无法知道子窗口是否定义了回调函数来处理传入的消息，所以我们能做的最好的事情就是假设（并希望）子窗口已经准备好接收我们的消息。
- en: 'The parameters used in the `postMessage` function are fairly similar to the
    version used in web workers. That is, any JavaScript value can be sent (numbers,
    strings, Boolean values, object literals, and arrays, including typed arrays).
    If a function is sent as the first parameter of `postMessage` (either directly,
    or as part of an object), the browser will raise a `DATA_CLONE_ERR: DOM Exception
    25` error. The second parameter is a string, and represents the domain that we
    allow our message to be received by. This can be an absolute domain, a forward
    slash (representing the same origin domain as the document sending the message),
    or a wild card character (*), representing any domain. If the message is received
    by a domain that doesn''t match the second parameter in `postMessage`, the entire
    message fails.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`postMessage`函数中使用的参数与Web Workers中使用的版本非常相似。也就是说，可以发送任何JavaScript值（数字、字符串、布尔值、对象文字和数组，包括类型化数组）。如果将函数作为`postMessage`的第一个参数发送（直接发送或作为对象的一部分），浏览器将引发`DATA_CLONE_ERR:
    DOM Exception 25`错误。第二个参数是一个字符串，表示我们允许消息被接收的域。这可以是绝对域，一个斜杠（表示与发送消息的文档相同的源域），或一个通配符字符（*），表示任何域。如果消息被不匹配`postMessage`中的第二个参数的域接收，整个消息将失败。'
- en: 'When receiving the message, the child window first registers a callback on
    the message event. This function is passed a `MessageEvent` object, which contains
    the following attributes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收消息时，子窗口首先在消息事件上注册一个回调。这个函数传递了一个`MessageEvent`对象，其中包含以下属性：
- en: '`event.data`: It returns the data of the message'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.data`：它返回消息的数据'
- en: '`event.origin`: It returns the origin of the message, for server-sent events
    and cross-document messaging'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.origin`：它返回消息的来源，用于服务器发送的事件和跨文档消息'
- en: '`event.lastEventId`: It returns the last event ID string, for server-sent events'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.lastEventId`：它返回最后一个事件ID字符串，用于服务器发送的事件'
- en: '`event.sourceReturns`: It is the WindowProxy of the source window, for cross-document
    messaging'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.sourceReturns`：它是源窗口的WindowProxy，用于跨文档消息'
- en: '`event.portsReturns`: It is the MessagePort array sent with the message, for
    cross-document messaging and channel messaging'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event.portsReturns`：这是与消息一起发送的MessagePort数组，用于跨文档消息和通道消息'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Source: [http://www.w3.org/TR/webmessaging/#messageevent](http://www.w3.org/TR/webmessaging/#messageevent)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://www.w3.org/TR/webmessaging/#messageevent](http://www.w3.org/TR/webmessaging/#messageevent)
- en: As an example of the sort of things we could use this feature for in the real
    world, and in terms of game development, imagine being able to play our snake
    game, but where the snake moves through a couple of windows. How creative is that?!
    Of course, in terms of being practical, this may not be the best way to play a
    game, but I find it hard to argue with the fact that this would indeed be a very
    unique and engaging presentation of an otherwise common game.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以在现实世界中使用这个功能，就游戏开发而言，想象一下能够玩我们的贪吃蛇游戏，但蛇可以穿过几个窗口。多有创意啊！当然，从实际角度来看，这可能不是玩游戏的最佳方式，但我很难反驳这样的事实，即这确实是对一个普通游戏非常独特和引人入胜的呈现。
- en: '![How to use it](img/6029OT_06_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用](img/6029OT_06_04.jpg)'
- en: With the help of the web messaging API, we can set up a snake, where the snake
    is not constrained to a single window. Imagine the possibilities when we combine
    this clever API with another very powerful HTML5 feature, which just happens to
    lend itself incredibly well to games – web sockets. By combining web messaging
    with web sockets, we could play a game of snake, not only across multiple windows,
    but also with multiple players at the same time. Perhaps each player would control
    the snake when it got inside a given window, and all players could see all windows
    at the same time, even though they are each using a separate computer. The possibilities
    are endless, really.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 借助Web消息传递API的帮助，我们可以设置一个贪吃蛇，其中贪吃蛇不受限于单个窗口。想象一下，当我们将这个巧妙的API与另一个非常强大的HTML5功能结合起来时，这个功能非常适合游戏
    - Web套接字。通过将Web消息传递与Web套接字结合起来，我们不仅可以在多个窗口中玩贪吃蛇，还可以同时与多个玩家玩游戏。也许每个玩家在蛇进入给定窗口时都可以控制蛇，并且所有玩家可以同时看到所有窗口，即使他们每个人都在使用不同的计算机。这些可能性是无穷无尽的。
- en: Surprisingly, the code used to set up a multi-window port of snake is incredibly
    simple. The basic setup is the same, we have a snake that only moves in one direction
    at a time. We also have one or more windows where the snake can go. If we store
    each window in an array, we can calculate which screen the snake needs to be rendered
    in, given its current position. Finding out which screen the snake is supposed
    to be in, given its world position, is the trickiest part.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，用于设置贪吃蛇的多窗口端口的代码非常简单。基本设置是相同的，我们有一个一次只能朝一个方向移动的蛇。我们还有一个或多个蛇可以移动的窗口。如果我们将每个窗口存储在一个数组中，我们可以计算蛇需要呈现在哪个屏幕上，给定其当前位置。找出蛇应该呈现在哪个屏幕上，给定其世界位置，是最棘手的部分。
- en: For example, imagine that each window is 200 pixels wide. Now, suppose there
    are three windows opened. Each window's canvas is only 200 pixels wide as well,
    so when the snake is at position 350, it would be printed too far to the right
    in all of the canvases. So what we need to do is first determine the total world
    width (canvas width multiplied by the total number of canvases), calculate which
    window the snake is at (position/canvas width), then convert the position from
    world space down to canvas space, given the canvas the snake is in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设每个窗口宽度为200像素。现在，假设有三个打开的窗口。每个窗口的画布也只有200像素宽，所以当蛇在位置350时，在所有画布中都会打印得太靠右。所以我们首先需要确定总世界宽度（画布宽度乘以画布的总数），计算蛇所在的窗口（位置/画布宽度），然后将位置从世界空间转换到画布空间，给定蛇所在的画布。
- en: 'First, lets define our structures in the parent document. The code for this
    is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在父文档中定义我们的结构。代码如下：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When this script loads, we''ll need a way to create new windows, where the
    snake will be able to move about. This can easily be done with a button that spawns
    a new window when clicked, then adding that window to our array of frames, so
    that we can iterate through that array, and tell every window where the snake
    is. The code for this is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当此脚本加载时，我们需要一种方法来创建新窗口，蛇将能够在其中移动。这可以通过单击按钮轻松完成，然后将该窗口添加到我们的帧数组中，以便我们可以遍历该数组，并告诉每个窗口蛇在哪里。此代码如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, the real magic happens in the following method. All that we'll do is update
    the snake's position, then tell each window where the snake is. This will be done
    by converting the snake's position from world coordinates to canvas coordinates
    (since every canvas has the same width, this is easy to do for every canvas),
    then telling every window where the snake should be rendered within a canvas.
    Since that position is valid for every window, we also tell each window individually
    whether or not they should render the information we're sending them. Only the
    window that we calculate the snake is in, is told to go ahead and render.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，真正的魔法发生在以下方法中。我们要做的就是更新蛇的位置，然后告诉每个窗口蛇在哪里。这将通过将蛇的位置从世界坐标转换为画布坐标（因为每个画布的宽度都相同，这对于每个画布来说很容易），然后告诉每个窗口蛇应该在画布中的哪个位置呈现。由于该位置对每个窗口都有效，我们还单独告诉每个窗口是否应该呈现我们发送给它们的信息。只有我们计算出蛇在其中的窗口才会被告知继续呈现。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's really all there is to it. The code that makes up all the other windows
    is the same for all of them. In fact, we only open a bunch of windows pointing
    to the exact same script. As far as each window is concerned, they are the only
    window opened. All they do is take a bunch of data through the messaging API,
    then render that data if the `shouldDraw` flag is set. Otherwise, they just clear
    their canvas, and sit tight waiting for further instructions from their parent
    window.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。构成所有其他窗口的代码对于它们所有来说都是相同的。实际上，我们只打开了指向完全相同脚本的一堆窗口。就每个窗口而言，它们是唯一打开的窗口。它们所做的就是通过消息API接收一堆数据，然后在`shouldDraw`标志设置时呈现该数据。否则，它们只清除它们的画布，并静静地等待来自其父窗口的进一步指示。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Web storage
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web存储
- en: Before HTML5 came along, the only way web developers had to store data on the
    client was through cookies. While limited in scope, cookies did what they were
    meant to, although they had several limitations. For one thing, whenever a cookie
    was saved to the client, every HTTP request after that included the data for that
    cookie. This meant that the data was always explicitly exposed, and each of those
    HTTP requests were heavily laden with extra data that didn't belong there. This
    is especially inefficient when considering web applications that may need to store
    relatively large amounts of data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5出现之前，Web开发人员在客户端上存储数据的唯一方法是通过cookie。虽然范围有限，但cookie确实做到了它们的本意，尽管它们有一些限制。首先，每当将cookie保存到客户端时，此后的每个HTTP请求都会包含该cookie的数据。这意味着数据总是明确暴露，而且每个HTTP请求都会带有不属于其中的额外数据。在考虑可能需要存储相对大量数据的Web应用程序时，这种效率特别低下。
- en: With the new web storage API, these issues have been addressed and satisfied.
    There are now three different options for client storage, all of which solve a
    different problem. Keep in mind, however, that any and all data stored in the
    client is still exposed to the client in plain text, and is therefore not meant
    for a secure storage solution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过新的Web存储API，这些问题已得到解决和满足。现在有三种不同的客户端存储选项，它们都解决了不同的问题。但请记住，客户端存储的所有数据仍然以纯文本形式暴露给客户端，因此并不适合作为安全存储解决方案。
- en: These three storage solutions are session storage, local storage, and the IndexedDB
    NoSQL data store. Session storage allows us to store key-value data pairs that
    persist until the browser is closed (in other words, until the session finishes).
    Local storage is similar to session storage in every way, except that the duration
    that the data persists is longer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种存储解决方案是会话存储、本地存储和IndexedDB NoSQL数据存储。会话存储允许我们存储键值数据对，这些数据对在浏览器关闭之前（换句话说，在会话结束之前）都会持续存在。本地存储在每个方面都类似于会话存储，只是数据持续存在的时间更长。
- en: Even when a session is closed, data stored in a local storage still persists.
    That data in local storage is only cleared when the user specifically tells the
    browser to do so, or when the application itself deletes data from the storage.
    Finally, IndexedDB is a robust data store that allows us to store custom objects
    (not including objects that contains functions), then query the database for those
    objects. Of course, with much robustness comes great complexity. Although having
    a dedicated NoSQL database built in right into the browser may sound exciting,
    but don't be fooled. While using IndexedDB can be a fascinating addition to the
    world of HTML, it is also by no means a trivial task for beginners. Compared to
    local storage and session storage, IndexedDB has somewhat of a steep learning
    curve, since it involves mastering some complex database concepts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使会话关闭，存储在本地存储中的数据仍然存在。只有当用户明确告诉浏览器这样做，或者应用程序本身从存储中删除数据时，本地存储中的数据才会被清除。最后，IndexedDB是一个强大的数据存储，允许我们存储自定义对象（不包括包含函数的对象），然后查询数据库以获取这些对象。当然，强大性带来了复杂性。虽然在浏览器中内置了专用的NoSQL数据库听起来很激动人心，但不要被愚弄。虽然使用IndexedDB可以成为HTML世界的迷人补充，但对于初学者来说绝不是一项微不足道的任务。与本地存储和会话存储相比，IndexedDB具有相当陡峭的学习曲线，因为它涉及掌握一些复杂的数据库概念。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned earlier, the only real difference between local storage and session
    storage is the fact that session storage clears itself whenever the browser closes
    down. Besides that, everything about the two is exactly the same. Thus, learning
    how to use both will be a simple experience, since learning one also means learning
    the other. However, knowing when to use one over the other might take a bit more
    thinking on your part. For best results, try to focus on the unique characteristics
    and needs of your own application before deciding which one to use. More importantly,
    realize that it is perfectly legal to use both storage systems in the same application.
    The key is to focus on a unique feature, and decide what storage API best suits
    those specific needs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本地存储和会话存储之间唯一的区别在于会话存储在浏览器关闭时会自动清除。除此之外，两者的所有内容都完全相同。因此，学习如何使用两者将是一个简单的经验，因为学习其中一个也意味着学习另一个。然而，在决定何时使用其中一个时可能需要您多花一些时间思考。为了获得最佳结果，请在决定使用哪种存储API之前专注于您自己应用程序的独特特性和需求。更重要的是，要意识到在同一个应用程序中同时使用这两种存储系统是完全合法的。关键是专注于一个独特的特性，并决定哪种存储API最适合这些特定需求。
- en: 'Both the local storage and session storage objects are instances of the class
    `Storage`. The interface defined by the `storage` class, through which we can
    interact with these storage objects, is defined as follows (source: Web Storage
    W3C Candidate Recommendation, December 08, 2011, [http://www.w3.org/TR/webstorage/](http://www.w3.org/TR/webstorage/)):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储和会话存储对象都是`Storage`类的实例。通过`storage`类定义的接口，我们可以与这些存储对象进行交互，其定义如下（来源：Web Storage
    W3C候选推荐，2011年12月08日，[http://www.w3.org/TR/webstorage/](http://www.w3.org/TR/webstorage/)）：
- en: '`getItem(key)`: It returns the current value associated with the given key.
    If the given key does not exist in the list associated with the object then this
    method must return null.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getItem(key)`: 返回与给定键关联的当前值。如果给定键在与对象关联的列表中不存在，则该方法必须返回null。'
- en: '`setItem(key, value)`: It first checks if a key/value pair with the given key
    already exists in the list associated with the object. If it does not, then a
    new key/value pair must be added to the list, with the given key and with its
    value set to `value`. If the given key does exist in the list, then it must have
    its value updated to `value`. If it couldn''t set the new value, the method must
    throw a `QuotaExceededError` exception. (Setting could fail if, for example, the
    user has disabled storage for the site, or if the quota has been exceeded.)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setItem(key, value)`: 首先检查与对象关联的列表中是否已经存在具有给定键的键/值对。如果不存在，则必须向列表中添加一个新的键/值对，其中给定的键及其值设置为`value`。如果给定的键在列表中存在，则必须将其值更新为`value`。如果无法设置新值，则该方法必须抛出`QuotaExceededError`异常。（例如，如果用户已禁用了站点的存储，或者已超出配额，则设置可能会失败。）'
- en: '`removeItem(key)`: It causes the key/value pair with the given key to be removed
    from the list associated with the object, if it exists. If no item with that key
    exists, the method must do nothing.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeItem(key)`: 如果存在具有给定键的键/值对，则导致该键/值对从与对象关联的列表中被移除。如果不存在具有该键的项目，则该方法不执行任何操作。'
- en: '`clear()`: It automatically causes the list associated with the object to be
    emptied of all key/value pairs, if there are any. If there are none, then the
    method must do nothing.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 当与对象关联的列表中存在任何键/值对时，它会自动导致该列表被清空。如果没有任何键/值对，则该方法不执行任何操作。'
- en: '`key(n)`: It returns the name of the nth key in the list. The order of keys
    is user-agent defined, but must be consistent within an object so long as the
    number of keys doesn''t change. (Thus, adding or removing a key may change the
    order of the keys, but merely changing the value of an existing key must not.)
    If n is greater than or equal to the number of key/value pairs in the object,
    then this method must return null. The supported property names on a Storage object
    are the keys of each key/value pair currently present in the list associated with
    the object.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key(n)`: 返回列表中第n个键的名称。键的顺序由用户代理定义，但在对象内部必须保持一致，只要键的数量不变。（因此，添加或删除键可能会改变键的顺序，但仅更改现有键的值不得改变。）如果n大于或等于对象中键/值对的数量，则该方法必须返回null。Storage对象上支持的属性名称是与对象关联的列表中当前存在的每个键/值对的键。'
- en: '`length`: It returns the number of key/value pairs currently present in the
    list associated with the object.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`: 返回与对象关联的列表中当前存在的键/值对的数量。'
- en: Local storage
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地存储
- en: The local storage mechanism is accessed through a property of the global object,
    which on browsers is the `window` object. Thus, we can access the storage property
    explicitly through `window.localStorage`, or implicitly as simply `localStorage`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储机制通过全局对象的属性访问，浏览器上是`window`对象。因此，我们可以通过`window.localStorage`显式访问存储属性，也可以隐式地简单地使用`localStorage`。
- en: '`window.localStorage.clear();`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.localStorage.clear();`'
- en: '`localStorage.length == 0; // True`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage.length == 0; // True`'
- en: Since only DOMString values are allowed to be stored in localStorage, any other
    values other than strings are converted into a string before being stored in localStorage.
    That is, we can't store arrays, objects, functions, and so on in `localStorage`.
    Only plain JavaScript strings are allowed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于localStorage只允许存储DOMString值，因此除字符串之外的任何其他值在存储到localStorage之前都会被转换为字符串。也就是说，我们不能在`localStorage`中存储数组、对象、函数等。只允许存储普通的JavaScript字符串。
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, while this might seem like a limitation to the storage API, this is in
    fact done by design. If your goal is to store complex data types for later use,
    localStorage wasn't necessarily designed to solve this problem. In those situations,
    we have a much more powerful and convenient storage solution, which we'll look
    at soon (that is, IndexedDB). However, there is a way to store complex data (including
    arrays, typed arrays, objects, and so on) in localStorage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然这可能看起来像是存储API的限制，但实际上这是有意设计的。如果您的目标是存储复杂数据类型以供以后使用，localStorage并不一定是为解决这个问题而设计的。在这种情况下，我们有一个更强大和方便的存储解决方案，我们很快就会看到（即IndexedDB）。然而，有一种方法可以在localStorage中存储复杂数据（包括数组、类型化数组、对象等）。
- en: The key lies in the wonderful `JSON` data format. Modern browsers have the very
    handy `JSON` object available in the global scope, where we can access two important
    functions, namely `JSON.stringify` and `JSON.parse`. With these two methods, we
    can serialize complex data, store that in `localStorage`, then unserialize the
    data retrieved from the storage, and continue using it in the application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于美妙的`JSON`数据格式。现代浏览器在全局范围内有非常方便的`JSON`对象，我们可以访问两个重要的函数，即`JSON.stringify`和`JSON.parse`。使用这两种方法，我们可以序列化复杂数据，将其存储在`localStorage`中，然后从存储中反序列化检索到的数据，并继续在应用程序中使用它。
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While this is a nice little trick, you will notice what can be a major limitation:
    `JSON stringify` does not serialize functions. Also, if you pay close attention
    to the way that JSON.stringify works, you will realize that class instances lose
    all of their "identity", and only the hard data is maintained. In other words,
    after we serialize and unserialize an instance of `Person`, the result will be
    a simple object literal with no constructor or prototype information. Still, given
    that localStorage was never intended to fill the role of object persistence (but
    rather, simple key-value string pairs), this should be seen as nothing more than
    a limited, yet very neat trick.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个不错的小技巧，但你会注意到可能存在一个主要限制：`JSON stringify`不会序列化函数。此外，如果你仔细观察JSON.stringify的工作方式，你会意识到类实例会失去所有的“身份”，只保留硬数据。换句话说，当我们序列化和反序列化`Person`的实例后，结果将是一个简单的对象文字，没有构造函数或原型信息。尽管localStorage从未打算填补对象持久性的角色（而是简单的键值字符串对），但这应该被视为一个有限但非常巧妙的技巧。
- en: Session storage
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话存储
- en: Since the sessionStorage interface is identical to that of localStorage, there
    is no reason to repeat all of the information just described. For a more in-depth
    discussion about sessionStorage, look at the two previous sections, and replace
    the word "local" with "session". Everything mentioned above that applies to local
    storage is also true for session storage. Again, the only difference between the
    two is that any data saved on `sessionStorage` is erased when the session with
    the client ends (that is, whenever the browser is shut down).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于sessionStorage接口与localStorage的接口相同，因此没有理由重复刚才描述的所有信息。有关sessionStorage的更深入讨论，请查看前两节，并将“local”替换为“session”。上面提到的适用于本地存储的所有内容也适用于会话存储。再次强调，两者之间唯一的区别是在与客户端结束会话时（即，每当浏览器关闭时）擦除`sessionStorage`上保存的任何数据。
- en: Some examples of how to use sessionStorage will be shown below. In the example,
    we will attempt to store a value in the sessionStorage if that value doesn't already
    exist. Remember, when we set a key-value pair to the storage, if that key already
    exists in the storage, then whatever value was associated with that key will be
    overwritten. If the key doesn't exist, it gets created automatically.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面将展示如何使用sessionStorage的一些示例。在示例中，我们将尝试在sessionStorage中存储一个值，如果该值尚不存在。请记住，当我们将键值对设置为存储时，如果该键已经存在于存储中，那么与该键关联的任何值都将被覆盖。如果键不存在，它将自动创建。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that we can also query the sessionStorage object for a specific key using
    the `in` operator, which returns a Boolean value shown as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还可以使用`in`运算符查询sessionStorage对象的特定键，该运算符返回如下所示的布尔值：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, although we can check the total amount of keys in the storage through
    `sessionStorage.length`, that by itself may not be very useful if we don't know
    what all the different keys are. Thankfully, the `sessionStorage.key` function
    allows us to get a specific key, through which we can then get a hold of the value
    stored with that key.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管我们可以通过`sessionStorage.length`检查存储中的键的总数，但如果我们不知道所有不同的键是什么，那本身可能并不是非常有用。幸运的是，`sessionStorage.key`函数允许我们获取特定的键，通过它我们可以获得与该键存储的值。
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Thus, we can query `sessionStorage` for a key at a given position, and receive
    the string key representing that key. Then, with the key we can get a hold of
    the value stored with that key. Note, however, that the order in which items are
    stored within the `sessionStorage` object is totally arbitrary. While some browsers
    may keep the list of stored items sorted alphabetically by key value, this is
    clearly specified in the HTML5 spec as a decision to be left up to browser makers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以查询`sessionStorage`中给定位置的键，并接收表示该键的字符串键。然后，使用该键，我们可以获得存储在该键下的值。然而，请注意，`sessionStorage`对象中存储项的顺序是完全任意的。虽然一些浏览器可能会按键值按字母顺序对存储的项目列表进行排序，但这在HTML5规范中明确规定为留给浏览器制造商决定的决定。
- en: IndexedDB
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IndexedDB
- en: 'As exciting as the web storage API might seem so far, there are cases when
    our needs might be such that serializing and unserializing data, as we use local
    or session storage, might not be quite sufficient. For example, imagine we have
    a few hundred (or perhaps, several thousand) similar records stored in local storage
    (say we''re storing enemy description cards that are part of an RPG game). Think
    about how you would do the following using local storage:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管到目前为止Web存储API可能看起来很令人兴奋，但在某些情况下，我们的需求可能是序列化和反序列化数据，使用本地或会话存储可能不够。例如，想象一下，我们在本地存储中存储了几百（或者，几千）个类似的记录（比如我们正在存储RPG游戏中的敌人描述卡）。考虑如何使用本地存储来完成以下操作：
- en: Retrieve, in alphabetical order, the first five records stored
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按字母顺序检索存储的前五条记录
- en: Delete all records stored that contain a particular characteristic (such as
    an enemy that doesn't survive in water, for example)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除所有存储的记录，这些记录包含特定特征（例如，不能在水中生存的敌人）
- en: Retrieve up to three records stored that contain a particular characteristic
    (for example, the enemy has a Hit Point score of 42,000 or more)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索存储的最多三条记录，这些记录包含特定特征（例如，敌人的生命值得分为42,000或更高）
- en: 'The point is this: any querying that we may want to make against the data stored
    in local storage or session storage, must be handled by our own code. In other
    words, we''d be spending a lot of time and effort writing code just to help us
    get to some data. Let alone the fact that any complex data stored in local or
    session storage is converted to literal objects, and any and all functions that
    were once part of those objects are now gone, unless we write even more code to
    handle some sort of custom unserializing.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是：我们可能想要对本地存储或会话存储中存储的数据进行任何查询，都必须由我们自己的代码处理。换句话说，我们将花费大量时间和精力编写代码，只是为了帮助我们获取一些数据。更不用说本地或会话存储中存储的任何复杂数据都会被转换为文字对象，而曾经属于这些对象的任何和所有函数现在都消失了，除非我们编写更多的代码来处理某种自定义的反序列化。
- en: In case you have not guessed it by now, IndexedDB solves these and other problems
    very beautifully. At its heart, IndexedDB is a NoSQL database engine that allows
    us to store whole objects and index them for fast insertions, deletions, and retrievals.
    The database system also provides us with a powerful querying engine, so that
    we can perform very advanced computations on the data that we have persisted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还没有猜到，IndexedDB非常漂亮地解决了这些问题和其他问题。在其核心，IndexedDB是一个NoSQL数据库引擎，允许我们存储整个对象并对其进行索引，以实现快速插入、删除和检索。数据库系统还为我们提供了强大的查询引擎，这样我们就可以对已持久化的数据执行非常高级的计算。
- en: The following figure shows some of the similarities between IndexedDB and a
    traditional relational database. In relational databases, data is stored as a
    group of rows within a specific table structure. In IndexedDB, on the other hand,
    data is grouped in broadly-defined buckets known as data stores.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了IndexedDB和传统关系数据库之间的一些相似之处。在关系数据库中，数据存储为特定表结构内的一组行。而在IndexedDB中，数据则是分组存储在被称为数据存储的广义定义的桶中。
- en: '![IndexedDB](img/6029OT_06_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![IndexedDB](img/6029OT_06_03.jpg)'
- en: The architecture of IndexedDB is somewhat similar to the popular relational
    database systems used in most web development projects today. One core difference
    is that, whereas relational databases store data in a database, which is a collection
    of related tables, an IndexedDB system groups data in databases, which is a collection
    of data stores. While conceptually similar, in practice these two architectures
    are actually quite different.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB的架构在某种程度上类似于当今大多数Web开发项目中使用的流行关系数据库系统。一个核心区别是，关系数据库存储数据在数据库中，这是一组相关表的集合，而IndexedDB系统将数据分组存储在数据库中，这是一组数据存储的集合。虽然在概念上相似，但在实践中，这两种架构实际上是非常不同的。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you come from a relational database background, and the concept of databases,
    tables, columns, and rows makes sense to you, then you're well on your way to
    becoming an IndexedDB expert. As you'll see, there are some significant distinctions
    between both systems and methodologies. While you might be tempted to simply replace
    the words data store with tables, know that the difference between the two concepts
    extends beyond a name difference.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自关系数据库背景，并且数据库、表、列和行的概念对你来说是有意义的，那么你已经在成为IndexedDB专家的路上了。正如你将看到的，这两种系统和方法之间有一些重要的区别。虽然你可能会倾向于简单地用数据存储替换表这个词，但要知道这两个概念之间的差异不仅仅是名称上的区别。
- en: One key feature of data stores is that they don't have any specific schema associated
    with them. In relational databases, a table is defined by its very particular
    structure. Each column is specified ahead of time, when the table is first created.
    Then, every record saved in such a table follows the exact same format. In NoSQL
    databases (which IndexedDB is a type of), a data store can hold any object, with
    whatever format they may have. Essentially, this concept would be the same as
    having a relational database table that has a different schema for each record
    in it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储的一个关键特性是它们没有与之关联的特定模式。在关系数据库中，表由其非常特定的结构定义。每个列在表首次创建时就被指定。然后，在这样的表中保存的每条记录都遵循完全相同的格式。在NoSQL数据库（其中IndexedDB是一种类型）中，数据存储可以保存任何对象，无论它们的格式是什么。基本上，这个概念与在关系数据库表中为每条记录定义不同的模式是相同的。
- en: IDBFactory
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDBFactory
- en: To get started with IndexedDB, we first need to create a database. This is done
    through an implementation of IDBFactory, which in the browser, is the `window.indexedDB`
    object. Deleting a database is also done through the indexedDB object, as we'll
    see soon.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用IndexedDB，我们首先需要创建一个数据库。这是通过IDBFactory的实现来完成的，在浏览器中，就是`window.indexedDB`对象。删除数据库也是通过indexedDB对象来完成的，我们很快就会看到。
- en: 'In order to open a database (or create one if it doesn''t exist yet), we simply
    call the `indexedDB.open` method, passing in a database name, along with a version
    number. If no version number is supplied, the default version number of one will
    be used as shown in the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打开一个数据库（或者如果它还不存在的话创建一个），我们只需调用`indexedDB.open`方法，传入数据库名称和版本号。如果没有提供版本号，将使用默认版本号1，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you''ll soon notice, every method for asynchronous requests in IndexedDB
    (such as `indexedDB.open`, for example), will return a request object of type
    IDBRequest, or an implementation of it. Once we have that request object, we can
    set up callback functions on its properties, which get executed as the various
    events related to them are fired, as shown in the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你很快会注意到的，IndexedDB中用于异步请求的每个方法（例如`indexedDB.open`）都会返回一个IDBRequest类型的请求对象，或者它的实现。一旦我们有了那个请求对象，我们就可以在其属性上设置回调函数，当与它们相关的各种事件被触发时，这些回调函数就会被执行，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: IDBOpenDBRequest
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDBOpenDBRequest
- en: 'As mentioned in the previous section, once we make an asynchronous request
    to the IndexedDB API, the immediately returned object will be of type IDBRequest.
    In the particular case of an open request, the object that is returned to us is
    of type IDBOpenDBRequest. Two events that we might want to listen to on this object
    were shown in the preceding code snippet (`onerror` and `onsuccess`). There is
    also a very important event, wherein we can create an object store, which is the
    foundation of this storage system. This event is the `onupgradeneeded` (that is,
    on upgrade needed) event. This will be fired when the database is first created
    and, as you might expect, whenever the version number used to open the database
    is higher than the last value used when the database was opened, as shown in the
    following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在前一节中提到的，一旦我们对IndexedDB API进行了异步请求，立即返回的对象将是IDBRequest类型。在打开请求的特定情况下，返回给我们的对象是IDBOpenDBRequest类型。我们可能想要在这个对象上监听的两个事件在前面的代码片段中已经显示出来了（`onerror`和`onsuccess`）。还有一个非常重要的事件，我们可以在这个事件中创建一个对象存储，这是这个存储系统的基础。这个事件是`onupgradeneeded`（即需要升级）事件。当数据库首次创建时，以及当打开数据库时使用的版本号高于上次打开数据库时使用的版本号时，这个事件将被触发，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The call to `createObjectStore` made on the database object takes two parameters.
    The first is a string representing the name of the object store. This store can
    be thought of as a table in the world of relational databases. Of course, instead
    of inserting records into columns from a table, we insert whole objects into the
    data store. The second parameter is an object defining properties of the data
    store. One important attribute that this object must define is the `keyPath` object,
    which is what makes each object we store unique. The value assigned to this property
    can be anything we choose.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库对象上进行的`createObjectStore`调用需要两个参数。第一个是表示对象存储名称的字符串。这个存储可以被认为是在关系数据库世界中的一个表。当然，我们不是将记录插入到表中的列中，而是将整个对象插入到数据存储中。第二个参数是定义数据存储属性的对象。这个对象必须定义的一个重要属性是`keyPath`对象，它使我们存储的每个对象都是唯一的。分配给这个属性的值可以是我们选择的任何东西。
- en: Now, any objects that we persist in this data store must have an attribute with
    the same name as the one assigned to `keyPath`. In this example, our objects will
    need to have an attribute of `myKey`. If a new object is persisted, it will be
    indexed by the value of this property.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在这个数据存储中持久化的任何对象都必须具有与分配给`keyPath`相同的名称的属性。在这个例子中，我们的对象将需要一个`myKey`属性。如果持久化了一个新对象，它将根据这个属性的值进行索引。
- en: Any additional objects stored that have the same value for `myKey` will replace
    any old objects with that same key. Thus, we must provide a unique value for this
    object every time we want a unique object persisted.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的任何额外对象，如果具有相同的`myKey`值，将替换具有相同键的任何旧对象。因此，每次我们想要持久化一个唯一对象时，我们必须为这个对象提供一个唯一值。
- en: 'Alternatively, we can let the browser provide a unique value for this key for
    us. Again, comparing this concept to a relational database, we can think of the
    `keyPath` object as being the same thing as a unique ID for a particular element.
    Just as most relational database systems will support some sort of auto increment,
    so does IndexedDB. To specify that we want auto-incremented values, we simply
    add the flag to the object store properties object when the data store is first
    created (or upgraded) as shown in the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以让浏览器为我们提供这个键的唯一值。同样地，将这个概念与关系数据库进行比较，我们可以将`keyPath`对象看作是特定元素的唯一ID。就像大多数关系数据库系统都支持某种自动增量一样，IndexedDB也是如此。为了指定我们想要自动增加的值，我们只需在数据存储首次创建（或升级）时将该标志添加到对象存储属性对象中，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can persist an object without having to provide a unique value for the
    property `myKey`. As a matter of fact, we don''t even need to provide this attribute
    at all as part of any objects we store here. IndexedDB will handle that for us.
    Take a look at the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以持久化一个对象，而无需为属性`myKey`提供唯一值。事实上，我们甚至不需要在存储在这里的任何对象中提供这个属性。IndexedDB会为我们处理这个问题。看一下下面的图表：
- en: '![IDBOpenDBRequest](img/6029OT_06_02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![IDBOpenDBRequest](img/6029OT_06_02.jpg)'
- en: Using Google Chrome's developer tools, we can see all of the databases and data
    stores we have created for our domain. Note that the primary object key, which
    has whatever name we give it during the creation of our data store, has IndexedDB-generated
    values, which, as we have specified, are incremented over the last value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用谷歌Chrome的开发者工具，我们可以看到我们为我们的域创建的所有数据库和数据存储。请注意，主对象键，即我们在创建数据存储时给它的任何名称，都具有IndexedDB生成的值，正如我们所指定的，这些值是相对于上一个值递增的。
- en: With this simple, yet verbose boilerplate code in place, we can now start using
    our databases and data stores. From this point on, the actions we take on the
    database will be done on the individual data store objects, which are accessed
    through the database objects that created them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个简单但冗长的样板代码，我们现在可以开始使用我们的数据库和数据存储了。从这一点开始，我们对数据库所采取的操作将在通过创建它们的数据库对象上访问的个别数据存储对象上进行。
- en: IDBTransaction
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDBTransaction
- en: The last general thing we need to remember when dealing with IndexDB, is that
    every interaction we have with the data store is done inside transactions. If
    something goes wrong during a transaction, the entire transaction is rolled back,
    and nothing takes effect. Similarly, if the transaction is successful, IndexedDB
    will automatically commit the transaction for us, which is a pretty handy bonus.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理IndexDB时，我们需要记住的最后一件一般的事情是，我们与数据存储的每一次交互都是在事务内完成的。如果在事务过程中出现问题，整个事务将被回滚，没有任何效果。同样地，如果事务成功，IndexedDB将自动为我们提交事务，这是一个非常方便的奖励。
- en: To use transaction, we need to get a reference to our database, then request
    a transaction for a particular data store. Once we have a reference to a data
    store, we can perform the various functions related to the data store, such as
    putting data into it, reading data from it, updating data, and finally, deleting
    data from a data store.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用事务，我们需要获取对数据库的引用，然后请求特定数据存储的事务。一旦我们获得了对数据存储的引用，我们就可以执行与数据存储相关的各种功能，例如将数据放入其中，从中读取数据，更新数据，最后从数据存储中删除数据。
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To store an item in our data store we need to follow a couple of steps. Note
    that if anything goes wrong during this transaction, we simply catch whatever
    error is thrown by the browser, and execution continues uninterrupted because
    of the try/catch block.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要将项目存储到我们的数据存储中，我们需要遵循几个步骤。请注意，如果在此事务期间发生任何错误，我们只需捕获浏览器抛出的任何错误，并且由于try/catch块的存在，执行将继续不受中断。
- en: 'The first step to persisting objects in IndexedDB is to start a transaction.
    This is done by requesting a transaction object from the database we have opened
    earlier. A transaction is always related to a particular data store. Also, when
    requesting a transaction, we can specify what type of transaction we''d like to
    start. The possible types of transactions in IndexedDB are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在IndexedDB中持久化对象的第一步是启动一个事务。这是通过从我们之前打开的数据库中请求一个事务对象来完成的。事务始终与特定的数据存储相关联。此外，在请求事务时，我们可以指定要启动的事务类型。IndexedDB中可能的事务类型如下：
- en: readwrite
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读写
- en: This transaction mode allows for objects to be stored into the data store, retrieved
    from it, updated, and deleted. In other words, readwrite mode allows for full
    CRUD functionality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种事务模式允许将对象存储到数据存储中，从中检索，更新和删除。换句话说，readwrite模式允许进行完整的CRUD功能。
- en: readonly
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读
- en: This transaction mode is similar to readwrite, but clearly restricts the interactions
    with the data store to only reading. Anything that would modify the data store
    is not allowed, so any attempt to create a new record (in other words, persisting
    a new object into the data store), update an existing object (in other words,
    trying to save an object that was already in the data store), or delete an object
    from the data store will result in the transaction failing, and an exception being
    raised.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种事务模式类似于readwrite，但明确限制了与数据存储的交互仅限于读取。不允许修改数据存储的任何内容，因此任何尝试创建新记录（换句话说，将新对象持久化到数据存储中），更新现有对象（换句话说，尝试保存已经在数据存储中的对象）或从数据存储中删除对象都将导致事务失败，并引发异常。
- en: versionchange
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: versionchange
- en: This transaction mode allows us to create or modify an object store or indexes
    used in the data store. Within a transaction of this mode, we can perform any
    action or operation, including modifying the structure of the database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种事务模式允许我们创建或修改数据存储中使用的对象存储或索引。在这种模式的事务中，我们可以执行任何操作或操作，包括修改数据库的结构。
- en: Getting elements
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取元素
- en: Simply storing data into a black box is not at all useful if we're not able
    to retrieve that data at a later point in time. With IndexedDB, this can be done
    in several different ways. More commonly, the data store where we persist the
    data is set up with one or more indexes, which keep the objects organized by a
    particular field. Again, for those accustomed to relational databases, this would
    be similar to indexing/applying a key to a particular table column. If we want
    to get to an object, we can query it by its unique ID, or we can search the data
    store for objects that fit particular characteristics, which we can do through
    indexed values of that object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法在以后的某个时间点检索数据，那么简单地将数据存储到黑匣子中是毫无用处的。使用IndexedDB，可以通过几种不同的方式来实现这一点。更常见的是，我们持久化数据的数据存储设置了一个或多个索引，这些索引通过特定字段对对象进行组织。对于习惯于关系数据库的人来说，这类似于对特定表列进行索引/应用键。如果我们想要获取一个对象，我们可以通过其唯一ID进行查询，或者我们可以搜索符合特定特征的对象的数据存储，这可以通过该对象的索引值来实现。
- en: 'To create an index on a data store, we must specify our intentions during the
    creation of the data store (inside the `onupgradeneeded` callback when the store
    is first created, or inside a transaction mode versionchange). The code for this
    is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据存储上创建索引，我们必须在创建数据存储时指定我们的意图（在首次创建存储时的`onupgradeneeded`回调内，或者在事务模式`versionchange`内）。代码如下：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we create an index for the task attribute of our
    objects. The name of this index can be anything we want, and commonly is the same
    name as the object property to which it applies. In our case, we simply named
    it taskIndex. The possible settings we can configure are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们为对象的task属性创建了一个索引。这个索引的名称可以是任何我们想要的，通常与它适用的对象属性的名称相同。在我们的例子中，我们只是将其命名为taskIndex。我们可以配置的可能设置如下：
- en: unique – if true, an object being stored with a duplicate value for the same
    attribute is rejected
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: unique - 如果为true，则存储具有相同属性的重复值的对象将被拒绝
- en: multiEntry – if true, and the indexed attribute is an array, each element will
    be indexed
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: multiEntry - 如果为true，并且索引属性是一个数组，则每个元素都将被索引
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that zero or more indexes can be created for a data store. Just like any
    other database system, indexing your database/data store can really boost the
    performance of the storage container. However, just adding indexes for the fun
    it provides is not a good idea, as the size of your data store will grow accordingly.
    A good data store design is one where the specific context of the data store with
    respect to the application is taken into account, and each indexed field is carefully
    considered. The phrase to keep in mind when designing your data stores is the
    following: measure it twice, cut it once.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以为数据存储创建零个或多个索引。与任何其他数据库系统一样，对数据库/数据存储进行索引可以真正提高存储容器的性能。但是，仅仅为了提供乐趣而添加索引并不是一个好主意，因为数据存储的大小会相应增长。一个良好的数据存储设计是考虑到数据存储与应用程序的特定上下文，并且每个索引字段都经过仔细考虑。在设计数据存储时要牢记的短语是：量一次，切一次。
- en: Although any object can be saved in a data store (as opposed to a relational
    database, where the data stored must carefully follow the table structure, as
    defined by the table's schema), in order to optimize the performance of your application,
    try to build your data stores with the data that it will store in mind. It is
    true that any data can be smacked into any data store, but a wise developer considers
    the data being stored very carefully before committing it to a database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管任何对象都可以保存在数据存储中（与关系数据库相反，在关系数据库中，存储的数据必须严格遵循表结构，由表的模式定义），为了优化应用程序的性能，尝试构建数据存储时要考虑存储的数据。任何数据都可以储存在任何数据存储中，但明智的开发人员在将数据提交到数据库之前会非常谨慎地考虑存储的数据。
- en: 'Once the data store is set up, and we have at least one meaningful index, we
    can start to pull data out of the data store. The easiest way to retrieve objects
    from a data store is to use an index, and query for a specific object, as shown
    in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据存储设置好，并且至少有一个有意义的索引，我们就可以开始从数据存储中提取数据。从数据存储中检索对象的最简单方法是使用索引，并查询特定对象，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding function attempts to retrieve a single saved object from our data
    store. The search is made for an object with its task property that matches the
    task name supplied to the function. If one is found, it will be retrieved from
    the data store, and passed to the store object's request through the event object
    passed in to the callback function. If an error occurs in the process (for example,
    if the index supplied doesn't exist), the `onerror` event is triggered. Finally,
    if no objects in the data store match the search criteria, the resulting property
    passed in through the request parameter object will be null.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数尝试从我们的数据存储中检索单个保存的对象。搜索是针对具有与函数提供的任务名称匹配的任务属性的对象进行的。如果找到一个，它将从数据存储中检索出来，并通过传递给回调函数的事件对象传递给存储对象的请求。如果在过程中发生错误（例如，如果提供的索引不存在），则会触发`onerror`事件。最后，如果数据存储中没有对象与搜索条件匹配，通过请求参数对象传递的结果属性将为null。
- en: Now, to search for multiple items, we can take a similar approach, but instead
    we request an `IndexedDBCursor` object. A cursor is basically a pointer to a particular
    result from a result set of zero or more objects. We can use the cursor to iterate
    through every object in the result set, until the current cursor points at no
    object (null), indicating that there are no more objects in the result set.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要搜索多个项目，我们可以采用类似的方法，但是我们请求一个`IndexedDBCursor`对象。游标基本上是指向零个或多个对象结果集中特定结果的指针。我们可以使用游标遍历结果集中的每个对象，直到当前游标指向没有对象（null），表示结果集中没有更多对象了。
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You will note a few things with the above code snippet. First, any object that
    goes into our IndexedDB data store is stripped of its DNA, and only a simple hash
    is stored in its stead. Thus, if the prototype information of each object we retrieve
    from the data store is important to the application, we will need to manually
    reconstruct each object from the data that we get back from the data store.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到上面的代码片段中有一些事情。首先，进入我们的IndexedDB数据存储的任何对象都被剥去了其DNA，而只是存储了一个简单的哈希值。因此，如果我们从数据存储中检索到的每个对象的原型信息对应用程序很重要，我们将需要手动从我们从数据存储中获取的数据中重建每个对象。
- en: Second, observe that we can filter the subset of the data store that we would
    like to take out of it. This is done with an IndexedDB Key Range object, which
    specifies the offset from which to start fetching data. In our case, we specified
    a lower bound of zero, meaning that the lowest primary key value we want is zero.
    In other words, this particular query requests all of the records in the data
    store.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，观察到我们可以过滤数据存储的子集，我们想从中取出。这是通过一个IndexedDB Key Range对象来实现的，它指定了从哪里开始获取数据的偏移量。在我们的情况下，我们指定了一个下限为零，意味着我们想要的最低主键值是零。换句话说，这个特定的查询请求数据存储中的所有记录。
- en: Finally, remember that the result from the request is not a single result or
    an array of results. Instead, all of the results are returned one at a time in
    the form of a cursor. We can check for the presence of a cursor altogether, then
    use the cursor if one is indeed present. Then, the way we request the next cursor
    is by calling the `continue()` function on the cursor itself.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记住请求的结果不是单个结果或结果数组。相反，所有结果都以游标的形式一个接一个地返回。我们可以一起检查游标的存在，然后如果确实存在游标，就使用游标。然后，我们请求下一个游标的方式是在游标本身上调用`continue()`函数。
- en: Another way to think of cursors is by imagining a spreadsheet application. Pretend
    that the 10 objects returned from our request each represent a row in this spreadsheet.
    So IndexedDB will fetch all 10 of those objects to memory, and send a pointer
    to the first result through the `event.target.result` property in the `onsuccess`
    callback. By calling `cursor.continue()`, we simply tell IndexedDB to now give
    us a reference to the next object in the result set (or, in other words, we ask
    for the next row in the spreadsheet). This goes on until the tenth object, after
    which no more objects exist in the result set (again, to go along with the spreadsheet
    metaphor, after we fetch the last row, the next row after that is null – it doesn't
    exist). As a result, the data store will call the `onsuccess` callback, and pass
    in a null object. If we attempt to read properties in this null reference, as
    though we were working with a real object returned from the cursor, the browser
    will throw a null pointer exception.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考游标的方式是想象一个电子表格应用程序。假设我们从请求中返回的10个对象中的每个对象都代表电子表格中的一行。因此，IndexedDB将把这10个对象都取到内存中，并通过`event.target.result`属性在`onsuccess`回调中发送指向第一个结果的指针。通过调用`cursor.continue()`，我们只是告诉IndexedDB现在给我们一个指向结果集中下一个对象的引用（换句话说，我们要求电子表格中的下一行）。这将一直持续到第十个对象，之后结果集中就不再存在对象了（再次配合电子表格的比喻，在我们获取了最后一行之后，下一行就是null-它不存在）。因此，数据存储将调用`onsuccess`回调，并传入一个null对象。如果我们尝试读取这个空引用中的属性，就好像我们正在处理从游标返回的真实对象一样，浏览器将抛出一个空指针异常。
- en: 'Instead of trying to reconstruct an object from a cursor one property at a
    time, we could abstract this functionality away in a generic form. Since objects
    being persisted into the object store can''t have any functions, we''re not allowed
    to keep such functionality inside the object itself. However, thanks to JavaScript''s
    ability to build an object from a reference to a constructor function, we can
    create a very generic object builder function as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与其尝试一次从游标重建一个对象的属性，我们可以以通用形式将此功能抽象化。由于被持久化到对象存储中的对象不能有任何函数，我们不允许在对象本身内部保留这样的功能。然而，由于JavaScript能够从对构造函数的引用构建对象，我们可以创建一个非常通用的对象构建函数，如下所示：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Deleting elements
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除元素
- en: To remove specific elements from a data store, the same principles involved
    in retrieving data apply. In fact, the entire process looks fairly identical to
    retrieving data, only we call the delete function on the object store object.
    Needless to say, the transaction used in this action must be readwrite, since
    readonly limits the object so that no changes can be done to it (including deletion).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据存储中删除特定元素，与检索数据涉及的原则相同。实际上，整个过程看起来与检索数据非常相似，只是我们在对象存储对象上调用删除函数。不用说，此操作中使用的事务必须是readwrite，因为readonly会限制对象，使其无法进行任何更改（包括删除）。
- en: 'The first way to delete an object is by passing the object''s primary key to
    the `delete` function. This is shown as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 删除对象的第一种方法是将对象的主键传递给`delete`函数。如下所示：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The difficulty with this first approach is that we need to know the ID of the
    object. In some cases, this would involve a prior transaction request where we'd
    retrieve the object based on some easier to get data. For example, if we want
    to delete all tasks with the attribute of complete set to true, we'd need to query
    the data store for those objects first, then use the IDs associated with each
    result, and use those values in the transaction where the objects are deleted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第一种方法的困难在于我们需要知道对象的ID。在某些情况下，这将涉及到先前的事务请求，我们将根据一些更容易获得的数据检索对象。例如，如果我们想要删除所有属性设置为true的任务，我们首先需要查询数据存储以获取这些对象，然后使用每个结果关联的ID，并在删除对象的事务中使用这些值。
- en: 'A second way to remove data from the data store is to simply call `clear()`
    on the object store object. Again, the transaction must be set to readwrite. Doing
    this will obliterate every last object in the data store, even if they''re all
    of different types as shown in the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据存储中删除数据的第二种方法是简单地在对象存储对象上调用`clear()`。同样，事务必须设置为readwrite。这将消除数据存储中的每一个对象，即使它们都是不同类型的，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can delete multiple records using a cursor. This is similar to
    the way we retrieve objects. As we iterate through the result set using the cursor,
    we can simply delete the object at whatever position the cursor is currently on.
    Upon deletion, the reference from the cursor object is set to null as shown in
    the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用游标删除多条记录。这类似于我们检索对象的方式。当我们使用游标遍历结果集时，我们可以简单地删除游标当前所在位置的对象。在删除时，游标对象的引用被设置为null，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is pretty much the same routine as fetching data. The only detail is that
    we absolutely need to supply an object's key. The key is the value stored in the
    object's `keyPath` attribute, which can be user-provided, or auto-generated. Fortunately
    for us, the cursor object returns at least two references to this key through
    the `cursor.primaryKey` property, as well as through the object's own property
    that references that value (in our case, we chose the `keyPath` attribute to be
    named `myKey`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与获取数据的过程相同。唯一的细节是我们绝对需要提供对象的键。键是存储在对象的`keyPath`属性中的值，可以是用户提供的，也可以是自动生成的。幸运的是，游标对象通过`cursor.primaryKey`属性返回至少两个对这个键的引用，以及通过对象自己的属性引用该值（在我们的情况下，我们选择将`keyPath`属性命名为`myKey`）。
- en: The code
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: The two upgrades we added to this second version of the game are simple, yet
    they add a lot of value to the game. We added a persistent high score engine,
    so users can actually keep track of their latest record, and have a sticky record
    of past successes. We also added a pretty nifty feature that takes a snapshot
    of the game board each time the player scores, as well as whenever the player
    ultimately dies out. Once the player dies, we display all of the snapshots we
    had collected throughout the game, allowing the player to save those images, and
    possibly share it with his or her friends.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在游戏的第二个版本中添加的两个升级非常简单，但它们为游戏增添了很多价值。我们添加了一个持久化的最高分引擎，因此用户实际上可以跟踪他们的最新记录，并且可以保留过去的成功记录。我们还添加了一个非常巧妙的功能，每当玩家得分时，以及玩家最终死亡时，都会拍摄游戏板的快照。一旦玩家死亡，我们会显示在游戏中收集到的所有快照，允许玩家保存这些图像，并可能与他或她的朋友分享。
- en: Saving the high score
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存最高分
- en: The first thing you probably noticed about the previous version of this game
    was that we had a placeholder for a high score, but that number never changed.
    Now that we know how to persist data, we can very easily take advantage of this,
    and persist a player's high score through various games. In a more realistic scenario,
    we'd probably send the high score data to a backend server, where every time the
    game is served, we can keep track of the overall high score, and every user playing
    the game would know about this global score. However, in our situation, the high
    score is local to a browser only, since none of the persistence APIs (local and
    session storage, as well as IndexedDB) share data across other browsers, or natively
    to a remote server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到这个游戏的上一个版本的第一件事是，我们有一个高分的占位符，但那个数字从未改变过。现在我们知道如何持久保存数据，我们可以非常容易地利用这一点，并通过各种游戏持久保存玩家的最高分。在更现实的情况下，我们可能会将最高分数据发送到后端服务器，在那里每次提供游戏时，我们可以跟踪整体最高分，并且每个玩游戏的用户都会知道这个全局分数。然而，在我们的情况下，高分仅限于浏览器，因为持久性API（本地和会话存储，以及IndexedDB）不会在其他浏览器之间共享数据，也不会本地到远程服务器。
- en: 'Since we want the high score to still exist in a player''s browser even a month
    from now, after the computer has been powered off (along with the browser, of
    course) multiple times, storing this high score data on sessionStorage would be
    silly. We could store this single number either in IndexedDB or in localStorage.
    Since we don''t care about any other information associated with this score (such
    as the date when the score was achieved, and so on), all we''re storing really
    is just the one number. For this reason, I think localStorage is a much better
    choice, because it can all be done in as few as 5 lines of code. Using IndexedDB
    would work, but would be like using a cannon to kill a mosquito:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望高分即使在一个月后，当计算机已经多次关闭电源（当然还有浏览器）后，仍然存在于玩家的浏览器中，将这个高分数据存储在sessionStorage中是愚蠢的。我们可以将这个单个数字存储在IndexedDB或localStorage中。由于我们不关心与该分数相关的任何其他信息（例如获得分数的日期等），我们实际上只是存储了一个数字。因此，我认为localStorage是一个更好的选择，因为可以只用5行代码就可以完成。使用IndexedDB也可以，但就像用大炮打蚊子一样：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function is pretty straight forward. The two values we pass it are the
    actual score to set as the new high score (this value will be both saved to localStorage,
    as well as displayed to the user), and the HTML element where the value will be
    shown.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能非常直接了当。我们传递给它的两个值是要设置为新高分的实际分数（这个值将被保存到localStorage，并显示给用户），以及要显示该值的HTML元素。
- en: First, we retrieve the existing value saved under the key high-score, and convert
    it to a number. We could have used the function `parseInt()`, but multiplying
    a string by a number does the same thing, but with a slightly faster execution.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索保存在键高分下的现有值，并将其转换为数字。我们可以使用函数`parseInt()`，但将字符串乘以数字会以稍微更快的执行速度执行相同的操作。
- en: Next, we check if that value evaluated to something real. In other words, if
    there was no high-score value saved in local storage, then the variable score
    would have been evaluated to undefined multiplied by one, which is not a number.
    If there is a value saved with the key high-score, but that value is not something
    that can be converted into a number (such as a string of letters and such), we
    know that it is not a valid value. In this case, we set the incoming score as
    the new high score. This would work out in the case where the current persisted
    value is invalid, or not there (which would be the case the very first time the
    game loads).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查该值是否评估为真实的东西。换句话说，如果本地存储中没有保存高分值，那么变量分数将被评估为未定义乘以一，这不是一个数字。如果保存了与键高分相关的值，但该值不是可以转换为数字的东西（例如一串字母等），我们知道这不是一个有效的值。在这种情况下，我们将传入的分数设置为新的最高分。这将适用于当前持久值无效或不存在的情况（这将是游戏加载的第一次情况）。
- en: Next, once we have a valid score retried from local storage, we check if the
    new value is higher than the old, persisted value. If we have a higher score,
    we persist that value, and display it to the screen. If the new value is not higher
    than the existing value, we don't persist anything, but display the saved value,
    since that is the real high score at the time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一旦我们从本地存储中检索到有效的分数，我们就会检查新值是否高于旧的持久值。如果我们有更高的分数，我们就会持久保存该值，并在屏幕上显示它。如果新值不高于现有值，我们就不会持久保存任何东西，而是显示保存的值，因为那是当时的真正最高分。
- en: Taking screenshots of the game
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拍摄游戏的屏幕截图
- en: This feature is not as trivial as saving the user's high score, but is nonetheless
    very straightforward to implement. Since we don't care about snapshots that we
    captured more than one game ago, we'll use `sessionStorage` to save data from
    the game, in real time as the player progresses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能不像保存用户的最高分那么琐碎，但实施起来同样非常直接了当。因为我们不关心超过一个游戏之前捕获的快照，所以我们将使用`sessionStorage`实时保存玩家在游戏中的数据。
- en: 'Behind the scenes, all we do to take these snapshots is save the game state
    into `sessionStorage`, then at the end of the game we retrieve all of the pieces
    that we''d been saving, and reconstruct the game at those points in time into
    an invisible canvas. We then use the `canvas.toDataURL()` function to extract
    that data as an image:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们所做的一切只是将游戏状态保存到`sessionStorage`中，然后在游戏结束时检索我们一直在保存的所有片段，并在不可见的画布中重建游戏。然后我们使用`canvas.toDataURL()`函数将该数据提取为图像。
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each time the player eats a fruit, we call this function, passing it a reference
    to the `snake` (our hero in this game), and the `fruit` (the goal of this game)
    objects. What we do is really quite simple: we create an array representing the
    state of the snake and of the fruit at each event that we capture. Each element
    in this array is a string representing the serialized array that keeps track of
    where the fruit was, and where each body part of the snake was located as well.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家吃掉水果时，我们调用这个函数，将`snake`（我们游戏中的主角）和`fruit`（游戏目标）对象的引用传递给它。我们所做的实际上非常简单：我们创建一个表示蛇和水果状态的数组，每次捕获事件时都会更新。数组中的每个元素都是一个字符串，表示序列化数组，跟踪水果的位置以及蛇的每个身体部分的位置。
- en: First, we check if this object currently exists in `sessionStorage`. For the
    first time we start the game, this object will not yet exist. Thus, we create
    an object that references those two objects, namely the `snake` and the `fruit`
    object. Next, we stringify the buffers keeping track of the locations of the elements
    we want to track. Each time we add a new event, we simply append to those two
    buffers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查这个对象当前是否存在于`sessionStorage`中。在我们开始游戏的第一次，这个对象还不存在。因此，我们创建一个引用这两个对象的对象，即`snake`和`fruit`对象。接下来，我们对跟踪元素位置的缓冲区进行字符串化。每次添加新事件时，我们只需将其附加到这两个缓冲区中。
- en: Of course, if the user closes down the browser, that data will be erased by
    the browser itself, since that's how `sessionStorage` works. However, we probably
    don't want to hold on to data from a previous game, so we also need a way to clear
    out our own data after each game.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果用户关闭浏览器，那些数据将被浏览器自己擦除，因为这就是`sessionStorage`的工作原理。然而，我们可能不想保留上一局游戏的数据，所以我们还需要一种方法在每局游戏结束后清除我们自己的数据。
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Easy enough. All we need is to know the name of the key that we use to hold
    each element. For our purposes, we simply call the snapshots of the snake eating
    `"eat"`, and the buffer with the snapshot of the snake dying `"die"`. So before
    each game starts, we can simply call `clearEvent()` with those two global key
    values, and the cache will be cleared a new each time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单。我们只需要知道我们用来保存每个元素的键的名称。对于我们的目的，我们简单地将蛇吃的快照称为`"eat"`，将蛇死亡的快照的缓冲区称为`"die"`。因此，在每局游戏开始之前，我们可以简单地使用这两个全局键值调用`clearEvent()`，缓存将在每次清除后重新清除。
- en: 'Next, as each event takes place, we simply call the first function we defined,
    sending it the appropriate data as shown in the following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，每当发生事件时，我们只需调用我们定义的第一个函数，向其发送适当的数据，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, whenever we wish to display all of these snapshots, we just need to
    create a separate canvas with the same dimensions as the one used in the game
    (so that the buffers we saved don''t go out of bounds), and draw the buffers to
    that canvas. The reason we need a separate canvas element is because we don''t
    want to draw on the same canvas that the player can see. This way, the process
    of producing these snapshots is more seamless and natural. Once each state is
    drawn, we can extract each image, resize it, and display it back to the user as
    shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每当我们希望显示所有这些快照时，我们只需要创建一个与游戏中使用的画布具有相同尺寸的单独画布，并将缓冲区绘制到该画布上。我们需要一个单独的画布元素的原因是因为我们不希望在玩家可以看到的同一个画布上绘制。这样，生成这些快照的过程就更加流畅和自然。一旦每个状态被绘制，我们可以提取每个图像，调整大小，并按照下面的代码显示给用户：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Observe that we simply draw the points representing the snake and the fruit
    into that canvas. All of the other points in the canvas are ignored, meaning that
    we generate a transparent image. If we want the image to have an actual background
    color (even if it is just white), we can either call `fillRect()` over the entire
    canvas surface before drawing the snake and the fruit, or we can traverse each
    pixel in the `pixelData` array from the rendering context, and set the alpha channel
    to 100 percent opaque. Even if we set a color to each pixel by hand, but leave
    off the alpha channel, we'd have colorful pixels, but 100 percent transparent.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只是将表示蛇和水果的点绘制到画布上。画布中的所有其他点都被忽略，这意味着我们生成了一个透明的图像。如果我们想要图像有一个实际的背景颜色（即使只是白色），我们可以在绘制蛇和水果之前调用`fillRect()`覆盖整个画布表面，或者我们可以遍历渲染上下文中的`pixelData`数组中的每个像素，并将alpha通道设置为100%不透明。即使我们手动为每个像素设置颜色，但没有设置alpha通道，我们会得到有颜色的像素，但是100%透明。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we took a few extra steps into the fascinating world of 2D rendering
    using the long-awaited canvas API. We took advantage of the canvas' ability to
    export images to make our game more engaging, and potentially more social. We
    also made the game more engaging and social by adding a persistence layer on top
    of the game, whereby we were able to save a player's high score.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在引人入胜的2D渲染世界中迈出了一些额外的步伐，使用了期待已久的画布API。我们利用了画布导出图像的能力，使我们的游戏更具吸引力，可能也更具社交性。我们还通过在游戏之上添加持久层，使游戏更具吸引力和社交性，从而能够保存玩家的最高分。
- en: Two other new powerful features of HTML5, web messaging and IndexedDB, were
    explored in this chapter, although there were no uses for these features in this
    version of the game. The web messaging API provides a mechanism for two or more
    windows to communicate directly through message passing. The exciting bit is that
    these windows (or HTML contexts) do not need to be in the same domain. Although
    this could sound like a security issue, there are several systems in place to
    ensure that cross-document and cross-domain messaging is secure and efficient.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5的另外两个强大功能，即Web消息传递和IndexedDB，在本章中进行了探讨，尽管在游戏的这个版本中并没有使用这些功能。Web消息传递API提供了一个机制，使两个或更多窗口可以通过消息传递直接进行通信。令人兴奋的是，这些窗口（或HTML上下文）不需要在同一个域中。尽管这可能听起来像一个安全问题，但有几个系统可以确保跨文档和跨域消息传递是安全和高效的。
- en: The web storage interface brings with it three distinct solutions for long term
    data persistence on the client. These are session storage, local storage, and
    IndexedDB. While IndexedDB is a full-blown, built-in, fully transactional and
    asynchronous NoSQL object store, local and session storage provide a very simple
    key-value pair storage for simpler needs. All three of these systems introduce
    great benefits and gains over the traditional cookie-based data storage, including
    the fact that the total amount of data that can be persisted in the browser is
    much greater, and none of the data saved in the user's browser ever travels back
    and forth between the server and the client through HTTP requests.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储接口带来了三种不同的解决方案，用于客户端的长期数据持久性。这些是会话存储、本地存储和IndexedDB。虽然IndexedDB是一个完整的、内置的、完全事务性和异步的NoSQL对象存储，但本地和会话存储为简单的需求提供了一个非常简单的键值对存储。这三种系统都比传统的基于cookie的数据存储引入了巨大的好处和收益，包括可以在浏览器中持久保存的数据总量更大，而且用户浏览器中保存的数据从未通过HTTP请求在服务器和客户端之间来回传输。
- en: In the next chapter we will look at some advanced HTML5 topics, including the
    next step beyond canvas' 2D rendering context – WebGL. While these topics will
    be covered in good detail, none of the features that follow will be added to a
    game. In fact, [Chapter 6](ch06.html "Chapter 6. Adding Features to Your Game"),
    *Adding Features to Your Game*, is another rare game in this book that is not
    built upon a fun HTML5 game, as we have being building together. We will pick
    up the game building projects in [Chapter 7](ch07.html "Chapter 7. HTML5 and Mobile
    Game Development"), *HTML5 and Mobile Game Development*, where we conclude the
    book with a mobile space shooter game.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些高级的HTML5主题，包括超越画布2D渲染上下文的下一步 - WebGL。虽然这些主题将被详细介绍，但随后添加的功能都不会被添加到游戏中。事实上，《第6章》《向您的游戏添加功能》，是本书中另一个罕见的游戏，它不是建立在一款有趣的HTML5游戏之上，因为我们一直在一起构建。我们将在《第7章》《HTML5和移动游戏开发》中继续游戏开发项目，最后在移动空间射击游戏中结束本书。
