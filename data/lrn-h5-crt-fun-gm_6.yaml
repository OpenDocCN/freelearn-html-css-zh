- en: Chapter 6. Adding Features to Your Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。为您的游戏添加功能
- en: This chapter is slightly different than the previous several chapters, in that
    there is no game associated with this chapter. The reason that we're not building
    a game with the concepts from this chapter is that the concepts covered are either
    way too complex for a single chapter (there are entire books dedicated to the
    topic of WebGL, for example) or they're not a particularly good match for use
    in a game. Also, some of the features mentioned at the end of the chapter are
    so new that browser support is still minimal (if any) and the stability of the
    APIs may not be too reliable. For this reason, we'll simply explain each API,
    provide meaningful examples, and hope this skin-deep introduction is enough to
    get you excited about the prospects involved with each API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章与前几章略有不同，因为本章没有与之相关的游戏。我们之所以不使用本章的概念构建游戏，是因为所涵盖的概念要么对于单独的一章来说过于复杂（例如，整本书都致力于WebGL的主题），要么它们并不是游戏中特别好的匹配。此外，本章末尾提到的一些功能在浏览器支持方面仍然很少（如果有的话），API的稳定性可能也不太可靠。因此，我们将简单解释每个API，提供有意义的示例，并希望这种肤浅的介绍足以让您对每个API所涉及的前景感到兴奋。
- en: The first part of the chapter will cover *four* HTML5 APIs that are very exciting
    and powerful additions to the browser platform. First and foremost, we'll cover
    **WebGL** , which brings the power of **OpenGL ES** to the browser, allowing for
    hardware accelerated 3D graphics rendering without any need for a single plugin.
    Next, we will discuss how we can use web sockets for a thread-like experience,
    the video API for native video playback and manipulation right from JavaScript,
    and geolocation, which allows JavaScript to determine the physical location (geographical
    location) of a user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分将涵盖*四个*非常令人兴奋和强大的HTML5 API，它们是浏览器平台的重要补充。首先，我们将介绍**WebGL**，它将**OpenGL
    ES**的强大功能带入浏览器，实现了硬件加速的3D图形渲染，而无需任何插件。接下来，我们将讨论如何使用Web套接字实现类似线程的体验，视频API实现原生视频播放和操作，以及地理位置信息，它允许JavaScript确定用户的物理位置（地理位置）。
- en: Lastly, we'll wrap up the chapter by looking at the absolute latest features
    in the HTML5 evolution. These features take CSS to the next level, taking it away
    from being a mere rectangular-based rendering engine. The first new feature that
    we'll study is CSS shaders, which allows us to specify how each pixel is to be
    rendered. This is done using GLSL shaders, which, as we'll see during the WebGL
    discussion, are independent programs that we write and are run on the GPU, controlling
    at the lowest level possible how something is to be rendered. With custom shaders,
    we can do so much more than simple, pre-baked CSS transformations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过查看HTML5演变中的最新功能来结束本章。这些功能将CSS提升到一个新的水平，使其不再仅仅是一个基于矩形的渲染引擎。我们将学习的第一个新功能是CSS着色器，它允许我们指定每个像素的渲染方式。这是使用GLSL着色器完成的，正如我们在WebGL讨论中将看到的那样，它们是我们编写并在GPU上运行的独立程序，以尽可能低的层次控制渲染方式。通过自定义着色器，我们可以做的远远超出简单的预设CSS变换。
- en: Other new CSS features, covered in the second half of the chapter, are CSS columns
    and CSS regions and exclusions. CSS columns make it beautifully easy to dynamically
    adjust how many columns of text a container displays. For example, if we want
    a block of text to be displayed in 3 equal width or height columns, we would normally
    set up three different containers, then float each container to the left. With
    columns, we can simply store all of the text inside a single container, then use
    CSS to generate the columns. Finally, CSS regions and exclusions make it possible
    to render text inside or around complex patterns, instead of the traditional rectangular
    shape. Surely you have seen magazines doing this, where a block of text wraps
    around some shape like the outline of a car or some other object. In the past,
    doing this effect with plain text (as opposed to using images) has very rarely
    been attempted in HTML because of the extreme complexity required to pull this
    off. Now it only takes a few lines of CSS code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后半部分涵盖的其他新的CSS功能是CSS列和CSS区域和排除。CSS列使得动态调整容器显示多少列文本变得非常容易。例如，如果我们希望一块文本以3个等宽或等高列显示，通常需要设置三个不同的容器，然后将每个容器浮动到左侧。使用列，我们可以简单地将所有文本存储在单个容器中，然后使用CSS生成列。最后，CSS区域和排除使得在复杂图案内或周围呈现文本成为可能，而不是传统的矩形形状。您肯定见过杂志这样做，其中一块文本围绕着汽车轮廓或其他物体的轮廓。过去，使用纯文本（而不是使用图像）实现这种效果在HTML中几乎没有尝试，因为这需要极其复杂的操作。现在只需要几行CSS代码。
- en: Advanced HTML5 APIs
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级HTML5 API
- en: Although the following APIs and features vary greatly in complexity and learning
    curve steepness, our goal is to provide at least a thorough introduction to each
    of these topics. In order to gain a deeper understanding of, and working experience
    with each topic, it is recommended that you supplement the introduction provided
    here with other sources.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管以下API和功能在复杂性和学习曲线陡度上有很大差异，但我们的目标是至少对每个主题进行彻底介绍。为了更深入地了解和实践每个主题，建议您在这里提供的介绍中补充其他来源。
- en: Since parts of the HTML5 specs and features have not yet reached full maturity,
    some APIs may not be fully supported in all browsers, even the latest modern browsers.
    Since this chapter will cover the absolute latest features of HTML5 (as at the
    time of writing), there is a chance some browsers might not be suitable for the
    examples covered in the chapter. For this reason, it is recommended that you work
    on the latest version of whatever the most advanced web browser is. Not only that,
    but you must also make certain that you check whatever experimental feature and/or
    security flags your browser has available. The following code snippets were written
    specifically for, and aimed at Google Chrome, since all of the features described
    are supported by it. We will make a note of any specific configuration settings
    required for a feature to work properly but these may or may not be needed as
    new updates are deployed for new web browsers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTML5规范和功能的部分尚未完全成熟，一些API可能在所有浏览器中都不完全支持，即使是最新的现代浏览器也是如此。由于本章将涵盖HTML5的绝对最新功能（在撰写时），有可能一些浏览器可能不适合本章涵盖的示例。因此，建议您使用最先进的网络浏览器的最新版本。不仅如此，您还必须确保检查您的浏览器可用的任何实验性功能和/或安全标志。以下代码片段是专门针对谷歌Chrome编写的，因为它支持所有描述的功能。我们将注意到任何特定的配置设置，以确保功能正常工作，但随着新的Web浏览器更新的部署，这些可能需要或不需要。
- en: WebGL
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL
- en: Perhaps no other HTML5 feature is as exciting for game developers as WebGL.
    This new JavaScript API allows us to render high performance, hardware accelerated
    2D and 3D graphics. The API is a flavor of OpenGL ES 2.0 and makes use of the
    HTML5 canvas element in order to bridge the gap between the browser and the graphics
    processing unit in the user's computer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 也许没有其他HTML5功能对游戏开发人员来说像WebGL那样令人兴奋。这个新的JavaScript API允许我们渲染高性能、硬件加速的2D和3D图形。该API是OpenGL
    ES 2.0的一种变体，并利用HTML5画布元素来弥合浏览器和用户计算机中的图形处理单元之间的差距。
- en: While 3D programming is a topic worthy of its own book, the following overview
    is sufficient to get us started on the most important concepts, and will allow
    us to get started with 3D game development for the browser platform. For those
    looking for a good learning resource for OpenGL ES 2, take a look at *OpenGL ES
    2.0 Programming Guide by Munshi, Ginsburg, and Shreiner*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然3D编程是一个值得一本书的话题，但以下概述足以让我们开始学习最重要的概念，并且将允许我们开始使用浏览器平台进行3D游戏开发。对于那些寻找OpenGL
    ES 2的良好学习资源的人，可以看看*Munshi，Ginsburg和Shreiner的OpenGL ES 2.0编程指南*。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since WebGL is heavily based on OpenGL ES 2.0, you may be tempted to look for
    reference and supplemental material about it from OpenGL books and other sources.
    Keep in mind that OpenGL Version 1.5 and earlier is significantly different than
    OpenGL 2.0 (as well as OpenGL ES 2.0, from which came WebGL) and may not be a
    complete source of learning, although it may be a decent starting point.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WebGL在很大程度上基于OpenGL ES 2.0，您可能会想要从OpenGL书籍和其他来源寻找关于它的参考和补充材料。请记住，OpenGL版本1.5及更早版本与OpenGL
    2.0（以及由此产生的WebGL的OpenGL ES 2.0）有很大不同，可能不是一个完整的学习来源，尽管它可能是一个不错的起点。
- en: The major difference between the two versions is the rendering pipeline. In
    earlier versions, the API used a fixed pipeline, where the heavy lifting was done
    for us behind the scenes. The newer versions expose a fully programmable pipeline,
    where we need to provide our own **shader** programs in order to render our models
    to the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本之间的主要区别是渲染管线。在早期版本中，API使用了一个固定的管线，重活由幕后完成。新版本暴露了一个完全可编程的管线，我们需要提供自己的**着色器**程序来将我们的模型渲染到屏幕上。
- en: Hello, World!
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: Before going any further into the theoretical side of WebGL and 3D programming,
    let's take a quick look at the simplest possible WebGL application, where we'll
    simply render a yellow triangle against a green background. You will notice that
    this takes quite a few lines of code. Keep in mind that the problem that WebGL
    solves is not a trivial one. The purpose of WebGL is to render the most complex
    of three dimensional, interactive scenes, and not simple, static two dimensional
    shapes, as illustrated by the following example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步探讨WebGL和3D编程的理论方面之前，让我们快速看一下最简单的可能的WebGL应用程序，在这里我们将简单地渲染一个黄色三角形在绿色背景上。您会注意到这需要相当多的代码行。请记住，WebGL解决的问题并不是一个微不足道的问题。WebGL的目的是渲染最复杂的三维交互场景，而不是简单的静态二维形状，正如下面的例子所示。
- en: In order to avoid a large code snippet, we'll break down the example into a
    few separate chunks. Each chunk will be presented in the order in which they are
    executed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免大段的代码片段，我们将把示例分解成几个单独的部分。每个部分将按照它们执行的顺序呈现。
- en: The first thing we need to do is set up the page where our example will run.
    The two components here are the two shader programs (more information on what
    a shader program is will follow) and the initialization of the `WebGLRenderingContext`
    object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是设置我们的示例将运行的页面。这里有两个组件，两个着色器程序（关于着色器程序是什么的更多信息将在后面介绍）和`WebGLRenderingContext`对象的初始化。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `script` tags of type `glsl-shader/x-vertex` and `glsl-shader/x-fragment`
    make use of how HTML renders unknown tags. When a browser parses a `script` tag
    with a `type` attribute that it does not understand (namely a made up type, such
    as `glsl-shader/x-vertex`), it simply ignores all of the contents of the tag.
    Since we want to define the contents of our shader programs within our HTML file,
    but we don't want that text to show up in the HTML file, this slight hack comes
    in very handy. This way we can define those scripts, have access to them, and
    not worry about the browser not knowing how to handle that particular language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`glsl-shader/x-vertex`和`glsl-shader/x-fragment`类型的`script`标签利用了HTML如何渲染未知标签。当浏览器解析一个带有它不理解的`type`属性的`script`标签（即一个虚构的类型，比如`glsl-shader/x-vertex`）时，它会简单地忽略标签的所有内容。由于我们想要在HTML文件中定义着色器程序的内容，但又不希望该文本显示在HTML文件中，这种小技巧非常方便。这样我们就可以定义这些脚本，访问它们，而不用担心浏览器不知道如何处理那种特定的语言。'
- en: As mentioned earlier, in WebGL we need to provide the GPU with a so-called shader
    program, which is an actual compiled program written in a language called **GLSL**
    (OpenGL Shading Language), which gives the GPU the instructions required to render
    our models just the way we want. The variables `shaderFrag` and `shaderVert` hold
    a reference to the source code of each of these shader programs, which is itself
    contained inside our custom `script` tags.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在WebGL中，我们需要向GPU提供所谓的着色器程序，这是用一种称为**GLSL**（OpenGL着色语言）的语言编写的实际编译程序，它为GPU提供了渲染我们的模型所需的指令。变量`shaderFrag`和`shaderVert`保存了每个着色器程序的源代码的引用，这些源代码本身包含在我们自定义的`script`标签中。
- en: Next, we create a regular HTML5 canvas element, inject it into the DOM, and
    create a `gl` object. Note the similarities between WebGL and the 2D canvas. Of
    course, beyond this point the two APIs are one from Mars and one from Venus, but
    until then, the initialization of them is identical. Instead of requesting a 2D
    Rendering Context object from the canvas object, we simply request a WebGL Rendering
    Context. Since most browsers (Google Chrome included) are still in experimental
    stages with WebGL, we must supply the `webgl` string with the experimental prefix
    when requesting the context. The Boolean `OR` operator separating the two `getContext`
    calls indicates that we're requesting the context from the experimental prefix,
    or without the prefix. Whichever call the browser supports, is the call that succeeds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个常规的HTML5画布元素，将其注入到DOM中，并创建一个`gl`对象。注意WebGL和2D画布之间的相似之处。当然，在这一点之后，这两个API一个来自火星，一个来自金星，但在那之前，它们的初始化是相同的。我们不是从画布对象请求2D渲染上下文对象，而是简单地请求WebGL渲染上下文。由于大多数浏览器（包括谷歌Chrome）在WebGL方面仍处于实验阶段，因此在请求上下文时，我们必须使用实验前缀提供`webgl`字符串。分隔两个`getContext`调用的布尔`OR`运算符表示我们正在从实验前缀请求上下文，或者不使用前缀。浏览器支持的调用将成功。
- en: From this point on, every API call to WebGL is done from this `gl` object. If
    the call to the canvas that returns the `WebGLRenderingContext` object fails,
    we can make absolutely no calls to WebGL and we might as well halt execution.
    Otherwise, we can continue on with our program, passing around this object so
    that we may interact with WebGL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，对WebGL的每个API调用都是通过这个`gl`对象完成的。如果返回`WebGLRenderingContext`对象的对画布的调用失败，我们就无法对WebGL进行任何调用，最好是停止执行。否则，我们可以继续进行我们的程序，传递这个对象，以便我们可以与WebGL交互。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next step in this process is to create a vertex and fragment shader, which
    are then combined into a single shader program. The entire job of the vertex shader
    is to specify the position of a vertex in the final rendered model and the fragment
    shader's job is to specify the color of each pixel between two or more vertices.
    Since these two shaders are needed for any rendering to take place, WebGL combines
    them into a single shader program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的下一步是创建顶点和片段着色器，然后将它们组合成一个单一的着色器程序。顶点着色器的整个工作是指定最终渲染模型中顶点的位置，片段着色器的工作是指定两个或多个顶点之间每个像素的颜色。由于任何渲染都需要这两个着色器，WebGL将它们合并成一个单一的着色器程序。
- en: After the shader program is successfully compiled, it will be sent to the GPU
    where the processing of fragments and vertices take place. The way we can send
    input into our shaders is through pointer locations that we specify in the shader
    program before sending it to the GPU. This step is done by calling the `get*Location`
    method on the `gl` object (the `WebGLRenderingContext` object). Once we have a
    reference to those locations, we can later assign a value to them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序成功编译后，它将被发送到GPU，其中处理片段和顶点。我们可以通过在发送到GPU之前在着色器程序中指定的指针位置来将输入发送到我们的着色器中。这一步是通过在`gl`对象（`WebGLRenderingContext`对象）上调用`get*Location`方法来完成的。一旦我们有了对这些位置的引用，我们可以稍后为它们分配一个值。
- en: Notice that our shader scripts declare variables of type `vec4` and `mat4`.
    In strongly typed languages such as C or C++, a variable can have a type of `int`
    (for integers), `float` (for floating point numbers), `bool` (for Boolean values),
    or `char` (for characters). In GLSL, there are a few new data types that are native
    to the language, which are specially useful in graphics programming. These types
    are vectors and matrices. We can create a vector with two components by using
    the data type `vec2`, or `vec4` for a vector with four components. Similarly,
    we can create a 3 x 3 matrix by calling `mat3`, which essentially creates an array-like
    structure with three `vec3` elements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的着色器脚本声明了`vec4`和`mat4`类型的变量。在诸如C或C++之类的强类型语言中，变量可以具有`int`（整数）、`float`（浮点数）、`bool`（布尔值）或`char`（字符）类型。在GLSL中，有一些新的数据类型是该语言的本机类型，这些类型在图形编程中特别有用。这些类型是向量和矩阵。我们可以使用数据类型`vec2`创建一个具有两个分量的向量，或者使用`vec4`创建一个具有四个分量的向量。同样，我们可以通过调用`mat3`创建一个3
    x 3矩阵，它实质上创建了一个具有三个`vec3`元素的类似数组的结构。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After we have a shader program in place, which will tell the graphics card how
    to draw whatever points we give it to draw for us, it follows that we now need
    a few points to draw. Thus, this next step creates a buffer of points that we
    will draw in a little bit. If you remember [Chapter 4](ch04.html "Chapter 4. Using
    HTML5 to Catch a Snake"), *Using HTML5 to Catch a Snake*, where we introduced
    the new typed arrays, then this will look familiar to you. The way WebGL stores
    vertex data is by using those typed arrays, but more specifically, 32 bit floating
    point arrays.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们放置了一个着色器程序之后，这个程序将告诉显卡如何为我们绘制的点进行绘制，接下来我们需要一些点来绘制。因此，下一步创建了一个我们稍后将要绘制的点的缓冲区。如果您还记得[第4章](ch04.html
    "第4章。使用HTML5捕捉蛇")，*使用HTML5捕捉蛇*，在那里我们介绍了新的类型化数组，那么这对您来说将是熟悉的。WebGL存储顶点数据的方式是使用这些类型化数组，但更具体地说，是32位浮点数组。
- en: In this particular case where we're only drawing a triangle, calculating, and
    keeping track of what all the points are is a trivial task. However, 3D models
    are not normally drawn by hand. After we draw a complex model using some 3D modeling
    software of one kind or another, we will be exporting anywhere from a few hundred
    to several thousand individual vertices that represent the model. In such cases,
    we will need to calculate how many vertices our model has and it would be a good
    idea to store that data somewhere. Since JavaScript allows us to add properties
    to objects dynamically, we take advantage of that and store these two calculations
    on the buffer object itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只绘制一个三角形，计算和跟踪所有点是一个微不足道的任务。然而，3D模型通常不是手工绘制的。在使用某种3D建模软件绘制复杂模型之后，我们将导出代表模型的几百到几千个单独顶点。在这种情况下，我们需要计算模型有多少个顶点，并且最好将这些数据存储在某个地方。由于JavaScript允许我们动态地向对象添加属性，我们利用这一点将这两个计算存储在缓冲对象本身上。
- en: Finally, let's actually draw our triangle to the screen. Of course, if we haven't
    written enough boilerplate code already, let's talk about one major component
    of 3D programming, and write just a little bit of extra code to allow us to finally
    render our model.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们实际将我们的三角形绘制到屏幕上。当然，如果我们还没有写足够的样板代码，让我们谈谈3D编程的一个主要组成部分，并写一点额外的代码来允许我们最终渲染我们的模型。
- en: Without getting too deep into the topic of 3D coordinate space and transformation
    matrices, one key aspect of rendering 3D shapes into a 2D screen (for instance,
    your computer monitor), we need to perform some linear algebra to convert the
    points that represent our models from 3D space into a simple 2D space (think x
    and y coordinates). This is done by creating a couple of matrix structures and
    performing some matrix multiplication. Then, we just need to multiply each point
    in our 3D model (our triangle buffer, in this example) by a matrix called the
    **MVP matrix** (which is a matrix composed of three individual matrices, namely
    the model, view, and projection matrices). This matrix is constructed by the multiplication
    of the individual matrices, each representing a step in the transformation process
    from 3D to 2D.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要深入讨论3D坐标空间和转换矩阵的话题，将3D形状渲染到2D屏幕（例如您的计算机显示器）的一个关键方面是，我们需要执行一些线性代数来将表示我们模型的点从3D空间转换为简单的2D空间（考虑x和y坐标）。这是通过创建一对矩阵结构并执行一些矩阵乘法来完成的。然后，我们只需要将我们3D模型中的每个点（在这个例子中是我们的三角形缓冲区）乘以一个称为**MVP矩阵**的矩阵（这是由三个单独的矩阵组成的矩阵，即模型、视图和投影矩阵）。这个矩阵是通过乘以单独的矩阵构建的，每个矩阵代表从3D到2D的转换过程中的一步。
- en: If you have taken any linear algebra classes before, you will know that multiplying
    matrices is not as simple as multiplying two numbers. You will also notice that
    representing a matrix in JavaScript is also not as trivial as defining a variable
    to type integer. In order to simplify and solve this problem, we can use one of
    the many matrix utility libraries available in JavaScript. The particular library
    we'll use in this example is a very powerful one called **GL-Matrix** , which
    is an open source library created by Brandon Jones and Colin MacKenzie IV.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前上过任何线性代数课程，您会知道矩阵相乘并不像乘以两个数字那么简单。您还会注意到，在JavaScript中表示矩阵也不像定义一个整数类型的变量那么微不足道。为了简化和解决这个问题，我们可以使用JavaScript中提供的许多矩阵实用程序库之一。在这个例子中，我们将使用一个非常强大的名为**GL-Matrix**的库，这是由Brandon
    Jones和Colin MacKenzie IV创建的开源库。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A couple of things about the preceding code are noteworthy. First, you will
    notice that this is a single frame that's only drawn once. Had we decided to animate
    our scene (which we most definitely would in a real game), we would need to run
    the `drawScene` function inside a request animation frame loop. This loop would
    involve all of the steps shown, including all of the matrix math that generates
    our MVP matrix for each and every model that we would render on the scene. Yes,
    that is a lot of computations to perform multiple times per second, especially
    on more complex scenes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码有几点值得注意。首先，您会注意到这是一个只绘制一次的单帧。如果我们决定在场景中进行动画（在真正的游戏中肯定会这样做），我们需要在请求动画帧循环中运行`drawScene`函数。这个循环将涉及到所有显示的步骤，包括生成我们的MVP矩阵的所有模型的矩阵数学。是的，这是要在更复杂的场景上多次每秒执行的大量计算。
- en: Second, observe the usage of our model-view-projection matrices. We first create
    them as 4 x 4 matrices, then instantiate each of them. The projection matrix's
    job is to do just that—project the 3D points onto a 2D space (the canvas rendering
    context), stretching the points as needed in order to maintain the specified aspect
    ratio of the canvas. In WebGL, the coordinate system of the rendering context
    goes from zero to one on both axis (the vertical and horizontal axis). The projection
    matrix makes it possible to map points beyond that limited range.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，观察我们的模型视图投影矩阵的使用。我们首先将它们创建为4x4矩阵，然后实例化每一个。投影矩阵的作用就是这样——将3D点投影到2D空间（画布渲染上下文），根据需要拉伸点以保持画布指定的纵横比。在WebGL中，渲染上下文的坐标系在两个轴（垂直和水平轴）上从零到一。投影矩阵使得可能将点映射到超出该有限范围的点。
- en: The model and view matrices allow us to model points relative to the object's
    center (its own coordinate system) onto the world's coordinate system. For example,
    say we're modeling a robot. Suppose the robot's head is centered at point (0,
    0, 0). From that point, the robot's arms would be, say, at points (-5, 1, 0) and
    (5, 1, 0) respectively, both relative to the robot's head. But where exactly is
    the robot placed with respect to the world? And what if we had another robot in
    this scene, how are they positioned relative to each other? Through the model
    and view matrices, we can put them both on the same global coordinate system.
    In our example, we moved the triangle to the point (0, 0, -0.5, -3.0), which is
    a point somewhere close to the origin of the world coordinate system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和视图矩阵使我们能够将点建模为相对于对象中心（其自己的坐标系）到世界坐标系的点。例如，假设我们正在建模一个机器人。假设机器人的头部位于点（0, 0,
    0）的中心。从那个点开始，机器人的手臂可能分别位于相对于机器人头部的点（-5, 1, 0）和（5, 1, 0）。但是机器人在世界上的位置究竟在哪里？如果我们在这个场景中有另一个机器人，它们相对于彼此的位置是如何的？通过模型和视图矩阵，我们可以将它们都放在同一个全局坐标系上。在我们的例子中，我们将三角形移动到点（0,
    0, -0.5, -3.0），这是一个接近世界坐标系原点的点。
- en: Finally, we bind our matrices to the graphics card, where we later render our
    scene by calling the draw functions defined in the `WebGLRenderingContext` object.
    If you look closely at the end of the `drawScene` function, we send some values
    to the `shader` object. Looking at the two shader programs we wrote earlier (using
    GLSL), we specified three variables that are used as input into the programs.
    The observant student will ask where those variables came from (the variables
    are defined in the vertex shader and are named `aVertPos`, `uMVMat`, and `uPMat`,
    which are special data types defined in the GLSL language). They come from our
    JavaScript code and are passed to the shader program in the GPU through calls
    to `gl.vertexAttribPointer` and `gl.uniformMatrix4fv`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的矩阵绑定到显卡上，在那里我们通过调用`WebGLRenderingContext`对象中定义的绘制函数来渲染我们的场景。如果您仔细观察`drawScene`函数的末尾，我们会向`shader`对象发送一些值。查看我们之前编写的两个着色器程序（使用GLSL），我们指定了三个变量，这些变量作为程序的输入。细心的学生会问这些变量来自哪里（这些变量在顶点着色器中定义，命名为`aVertPos`、`uMVMat`和`uPMat`，这些是GLSL语言中定义的特殊数据类型）。它们来自我们的JavaScript代码，并通过调用`gl.vertexAttribPointer`和`gl.uniformMatrix4fv`将它们传递到GPU中的着色器程序。
- en: About 150 lines of code later, we have a yellow triangle rendered against a
    green background that looks like the following screenshot. Again, I remind you
    that WebGL is by no means a trivial programming interface and is not the tool
    of choice for simple drawing that could be done with easier tools, such as the
    2DRenderingContext of the canvas element, SVG, and possibly just a simple piece
    of photo editing software.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大约150行代码后，我们有一个黄色三角形在绿色背景上渲染，如下面的截图所示。再次提醒您，WebGL绝不是一个简单的编程接口，也不是用于可以使用更简单工具完成的简单绘图的首选工具，比如画布元素的2DRenderingContext、SVG，甚至只是一个简单的图片编辑软件。
- en: Although WebGL takes a lot of boilerplate code to render a very simple shape,
    as shown in the following screenshot, rendering and animating complex scenes is
    not much more complicated than that. The same basic steps required to setup a
    rendering context, create a shader program, and load buffers, are used in creating
    extremely complicated scenes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管WebGL需要大量样板代码来渲染一个非常简单的形状，如下面的截图所示，但渲染和动画复杂场景并不比这复杂多少。设置渲染上下文、创建着色器程序和加载缓冲区所需的基本步骤，在创建极其复杂的场景时也是一样的。
- en: '![Hello, World!](img/6029OT_07_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Hello, World!](img/6029OT_07_01.jpg)'
- en: In conclusion, even though WebGL can be a beast of its own for developers just
    coming in to HTML5 or even game development, the fundamentals are fairly straight
    forward. For those seeking to deepen their understanding of WebGL (or 3D graphics
    programming in general), it is recommended that you study up on the subject of
    three dimensional programming and linear algebra, as well as the principles that
    are unique to, and a part of, WebGL. As a bonus, go ahead and get acquainted with
    the GLSL shading language as well, since this is what lies at the heart of WebGL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，尽管WebGL对于刚接触HTML5甚至游戏开发的开发人员来说可能是一个难题，但其基本原理是相当简单的。对于那些希望加深对WebGL（或3D图形编程）理解的人，建议您学习三维编程和线性代数的相关主题，以及WebGL独有的原则。作为奖励，可以继续熟悉GLSL着色语言，因为这是WebGL的核心所在。
- en: Web sockets
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web套接字
- en: 'If you''ve ever thought about creating a high performance multiplayer game
    in HTML5 then the new web sockets API is just the thing you''ve been looking for.
    If you haven''t done much with socket programming before, this is what you''ve
    been missing: instead of establishing a connection to a server each and every
    time a resource needs to be requested, a socket simply creates a connection once,
    then the client and server can communicate back and forth over that same connection.
    To put it another way, imagine making a phone call to someone, saying "Hello",
    then hanging up the phone after the other person says "Hello" back to you. Then,
    you call that person again, wait for them to pick up the phone and once you''re
    both ready, you ask the person on the other side of the line how he or she is
    doing. After receiving an answer, you again hang up the phone. This continues
    for the duration of the conversation, where you only ask a question at a time
    (or make a single statement at a time), and most of the time is spent with both
    of you waiting for the call to come in and connecting the phones.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经考虑过在HTML5中创建高性能的多人游戏，那么新的Web套接字API正是你一直在寻找的东西。如果你以前没有做过太多套接字编程，那么你一直缺少的就是这个：不是每次需要请求资源时都要建立与服务器的连接，而是套接字只需创建一次连接，然后客户端和服务器可以在同一连接上来回通信。换句话说，想象一下给某人打电话，说“你好”，然后在对方回答“你好”后挂断电话。然后，你再次给那个人打电话，等待他们接听电话，一旦你们都准备好了，你就问对方在电话那头怎么样。收到答案后，你再次挂断电话。这种情况持续了整个对话的时间，你每次只问一个问题（或者一次只做一个陈述），大部分时间都是你们两个在等待电话响起并连接电话。
- en: Now, with socket programming, the above scenario would be like making one phone
    call, then having the entire conversation without ever hanging up the phone. The
    only time you would hang up the phone would be when the conversation is finally
    over, and you and the other person have said good bye, and agreed to put down
    the phone. In this situation, there is virtually no delay between question and
    answer—only whatever intrinsic delay is involved in the sound traveling from one
    phone to another.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过套接字编程，上述情景就像是打一个电话，然后在不挂断电话的情况下进行整个对话。你只有在对话最终结束，你和对方说再见，并同意挂断电话时才会挂断电话。在这种情况下，问题和答案之间几乎没有延迟，只有声音从一个电话传到另一个电话所涉及的固有延迟。
- en: In HTML5, the sockets API is divided into two parts, namely a server part and
    a client part. The server side of the socket is something we will not discuss
    too much in this book, given the nature of what's involved. The client-side interface
    is where we will spend most of the discussion, although you will be happy to know
    that the JavaScript interface for web sockets and web workers is nearly identical.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5中，套接字API分为两部分，即服务器部分和客户端部分。套接字的服务器端是我们在本书中不会过多讨论的，考虑到所涉及的性质。客户端接口是我们将大部分讨论的地方，尽管你会高兴地知道，Web套接字和Web工作者的JavaScript接口几乎是相同的。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see from the preceding code snippet, there aren't too many differences
    between the web socket interface and the web worker interface. Most notably, perhaps,
    is the actual interface through which we can post a message to the server. Whereas
    a web worker uses the `postMessage` function, a web socket uses the `send` function.
    The traditional event handling functions work the exact same way as with workers.
    There are four events associated with a socket, namely `onOpen` , `onClose` ,
    `onError` , and `onMessage`. The first two events, `onOpen` and `onClose`, are
    called when the server successfully validates the request and upgrades the connection
    with the browser and when the server somehow closes a connection with the particular
    socket, respectively. The `onError` event is fired when an error occurs on the
    server application. Finally, when the server pushes a message to the client, the
    JavaScript handle to the socket is alerted through the `onMessage` callback function.
    The event object that is passed to the function, similar to a web worker `onMessage`
    event object, has a `data` attribute with the actual data sent to it, as well
    as a `timestamp` attribute indicating when the message was sent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中可以看出，Web套接字接口和Web工作者接口之间没有太多的区别。也许最显著的区别是我们可以通过哪个接口向服务器发送消息。Web工作者使用`postMessage`函数，而Web套接字使用`send`函数。传统的事件处理函数与工作者的工作方式完全相同。套接字有四个与之关联的事件，分别是`onOpen`，`onClose`，`onError`和`onMessage`。前两个事件`onOpen`和`onClose`在服务器成功验证请求并升级与浏览器的连接时以及服务器以某种方式关闭与特定套接字的连接时被调用。`onError`事件在服务器应用程序发生错误时触发。最后，当服务器向客户端推送消息时，JavaScript套接字的句柄通过`onMessage`回调函数被警告。传递给函数的事件对象与Web工作者`onMessage`事件对象类似，具有一个`data`属性，其中包含实际发送的数据，以及一个`timestamp`属性，指示消息发送的时间。
- en: The connection
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: 'Understanding the way a web application connects to a backend server through
    a web socket is fundamental to learning how the socket API works. The first point
    to remember is that the protocol that connects the browser to the server is different
    from the usual HTTP connection. The way a browser keeps the connection open with
    the server is by using the new `WebSocket` protocol, which is done by following
    a few steps. The `WebSocket` protocol is based on the traditional TCP and uses
    HTTP to upgrade the connection between a browser and a backend server, as illustrated
    in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Web应用程序如何通过Web套接字连接到后端服务器对于学习套接字API的工作原理至关重要。首先要记住的是，连接浏览器与服务器的协议与通常的HTTP连接不同。浏览器保持与服务器的连接方式是通过使用新的`WebSocket`协议，这是通过以下几个步骤完成的。`WebSocket`协议基于传统的TCP，并使用HTTP来升级浏览器和后端服务器之间的连接，如下面的屏幕截图所示：
- en: '![The connection](img/6029OT_07_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![连接](img/6029OT_07_02.jpg)'
- en: When we create an instance of the `WebSocket` class in JavaScript, the browser
    attempts to establish the persistent socket connection with the server. The first
    thing that happens is that the browser sends an HTTP request to the URI specified
    in the `WebSocket` constructor. This request contains an upgrade header, specifying
    that it wishes to upgrade the connection to using the `WebSocket` protocol. The
    server and the browser then perform a typical handshake, which, for the purposes
    of this book will not be explained in any great detail. If you're interested in
    implementing your own backend server application to handle this low-level handshake,
    you can refer to the official web socket documentation online.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在JavaScript中创建`WebSocket`类的实例时，浏览器会尝试与服务器建立持久的套接字连接。首先发生的事情是浏览器向`WebSocket`构造函数中指定的URI发送HTTP请求。此请求包含一个升级标头，指定它希望将连接升级到使用`WebSocket`协议。然后服务器和浏览器执行典型的握手，对于本书的目的，不会详细解释。如果您有兴趣实现自己的后端服务器应用程序来处理这个低级握手，可以参考在线官方Web套接字文档。
- en: To be brief, the client sends this HTTP request to the server, including a header
    containing a key, which is a simple text string. The server then hashes and encodes
    that string and sends back an HTTP response, which the browser then validates,
    and accepts the protocol upgrade if everything is right. If this handshake is
    successful, the browser proceeds to instantiate the `WebSocket` object, which
    we can then use to communicate with the server over the same connection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，客户端将此HTTP请求发送到服务器，包括一个包含密钥的标头，这是一个简单的文本字符串。然后服务器对该字符串进行哈希和编码，并发送回一个HTTP响应，浏览器验证并接受协议升级是否一切正常。如果这个握手成功，浏览器将实例化`WebSocket`对象，然后我们可以使用它通过相同的连接与服务器通信。
- en: The server-side code
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端代码
- en: A typical use case for web sockets is a multiplayer game where two or more players
    either play against each other or otherwise share the same game, in real time,
    but from different locations. One way such a game could be implemented (say, a
    fighting game such as Street Fighter or Mortal Kombat) is by having two players
    connecting to the server from separate computers, then the server would receive
    input from both players and send them the output computed from their actions.
    Each player's client application would then simply render the data received from
    the server. For example, player A presses a key on the keyboard that makes the
    character controlled by player A jump. That data is sent to the server, which
    is keeping track of where the character is and whether it can jump, and so on.
    After the server computes what is to be done based on the input it received from
    player A (in this example, the server determines that player A's character is
    now performing a jump), it sends the updated state of player A's character to
    both player A and player B. Their application then simply renders player A's character
    up in the air. Of course, each player's local instance of the game also renders
    the state it calculates from a local player's actions in order to provide instant
    feedback. However, the server-side instance of the game has the ability to invalidate
    any game state resulting from input from either player, if it is determined to
    be invalid. This way, both players can experience a very smooth, responsive multiplayer
    gaming experience, while the integrity of the game remains in check.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Web套接字的典型用例是多人游戏，其中两个或更多玩家要么相互对战，要么共享同一游戏，但来自不同的地点。这样的游戏可以通过两个玩家从不同的计算机连接到服务器，然后服务器接收来自两个玩家的输入并发送计算出的输出来实现。然后，每个玩家的客户端应用程序只需渲染从服务器接收到的数据。例如，玩家A按下键盘上的一个键，使由玩家A控制的角色跳跃。这些数据被发送到服务器，服务器会跟踪角色的位置以及是否可以跳跃等。服务器根据从玩家A接收到的输入计算要执行的操作（在这个例子中，服务器确定玩家A的角色现在正在执行跳跃），然后将玩家A的角色的更新状态发送给玩家A和玩家B。他们的应用程序然后只需渲染玩家A的角色在空中。当然，每个玩家的游戏本地实例也会根据本地玩家的操作渲染其计算出的状态，以提供即时反馈。但是，游戏的服务器端实例有能力使来自任一玩家的输入导致的任何游戏状态无效。这样，两个玩家都可以体验非常流畅、响应迅速的多人游戏体验，同时保持游戏的完整性。
- en: Now, depending on the specific language in which the server-side code is implemented,
    this could either be a trivial task or a real nightmare. Overall, the main thing
    that this server-side code needs to keep track of is all of the sockets connected
    to it. Obviously, the complexity of the application will be relative to the goals
    of the game. However, as far as the web sockets API is concerned, the main point
    is to pass data back to the client using the `send` interface function and check
    on input from the `onMessage` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据服务器端代码实现的具体语言，这可能是一个微不足道的任务，也可能是一个真正的噩梦。总的来说，这个服务器端代码需要跟踪连接到它的所有套接字。显然，应用程序的复杂性将与游戏的目标相关。然而，就Web套接字API而言，主要的重点是使用`send`接口函数将数据传递回客户端，并通过`onMessage`函数检查输入。
- en: The client-side code
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端代码
- en: 'As we saw in the previous code snippet, working with the JavaScript `WebSocket`
    object is very straightforward. Two things to keep in mind, however, are that
    every call to `WebSocket.send` is asynchronous and whatever data is padded to
    `WebSocket.send` must be (or will be converted to) a `DOMString`. That means that
    if we send an object, a function, or anything else to the server, it will be available
    to the server as a UTF-16 encoded string. If we send a JSON string to the server
    then all we need to do is parse the data and access the specifics. However, if
    we simply send an actual object, such as a literal JSON object, the server will
    receive something such as the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码片段中看到的，使用JavaScript的`WebSocket`对象非常简单。但是需要记住的两件事是，对`WebSocket.send`的每次调用都是异步的，并且传递给`WebSocket.send`的任何数据必须是（或将被转换为）`DOMString`。这意味着如果我们向服务器发送对象、函数或其他任何内容，服务器将以UTF-16编码的字符串形式接收。如果我们向服务器发送JSON字符串，那么我们只需要解析数据并访问具体内容。但是，如果我们只是发送一个实际的对象，比如一个字面的JSON对象，服务器将收到以下代码片段中的内容：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Thus, when sending objects through a web socket, JavaScript will not attempt
    to encode the object, but will instead simply call the object's `toString` function
    and send the output of that along to the socket.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过Web套接字发送对象时，JavaScript不会尝试对对象进行编码，而是简单地调用对象的`toString`函数，并将其输出发送到套接字。
- en: Video
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频
- en: 'Being able to play videos directly inside a browser without having to worry
    about plugins is quite a joyous experience. Not only that, but since the video
    element is actually a native part of the DOM, that means we can also deal with
    it the same way as we do with all other DOM elements. In other words, we can apply
    CSS styles to a video element and the browser is more than happy to make things
    work for us. For example, suppose we want to create the effect of the video being
    played on a shiny surface, where the video reflects vertically and the reflection
    fades out, blending into the background, as in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 能够直接在浏览器内播放视频而无需担心插件是一种愉快的体验。不仅如此，由于视频元素实际上是DOM的一个本机部分，这意味着我们也可以像处理所有其他DOM元素一样处理它。换句话说，我们可以对视频元素应用CSS样式，浏览器会很乐意为我们解决问题。例如，假设我们想要创建视频在闪亮表面上播放的效果，其中视频在垂直方向反射，反射渐隐，融入背景，如下面的截图所示：
- en: '![Video](img/6029OT_07_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Video](img/6029OT_07_03.jpg)'
- en: Since the browser is in charge of rendering the video, as well as applying CSS
    styles and effects to all elements being managed by it, we don't have to worry
    about the logic involved in rendering a video with special effects added to it.
    Keep in mind, however, that the more CSS we throw on top of the video, the more
    work the browser will have to do to make the video look the way we want, which
    may quickly affect performance. However, if all we're adding to the video is a
    simple detail here and there, then most modern web browsers will have no problem
    rendering everything at full speed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器负责渲染视频，以及对其管理的所有元素应用CSS样式和效果，我们不必担心渲染带有特殊效果的视频所涉及的逻辑。但是请记住，我们在视频上添加的CSS越多，浏览器就需要越多的工作来使视频看起来符合我们的要求，这可能会迅速影响性能。但是，如果我们在视频中添加的只是一些简单的细节，那么大多数现代Web浏览器都不会在渲染时出现问题。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similar to the new HTML5 audio element, there are more or less two ways we can
    use the tag. One way is to simply create the HTML node, specify the same properties
    as the `audio` tag, specify one or more `source` nodes, and call it a day. Alternatively,
    we can use the JavaScript API available to us and programmatically manipulate
    the playback of the video file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与新的HTML5音频元素类似，我们可以更多或更少地使用标签的两种方式。一种方法是简单地创建HTML节点，指定与`audio`标签相同的属性，指定一个或多个`source`节点，然后结束。或者，我们可以使用可用的JavaScript
    API，并以编程方式操纵视频文件的播放。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also ignore the default controls and manage the playing, pausing, volume
    adjusting, and so on, on our own by taking advantage of the attributes available
    to the JavaScript object that references the video element. The following is a
    list of attributes and functions we can call on a video object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以忽略默认控件，并通过利用引用视频元素的JavaScript对象上可用的属性来自行管理播放、暂停、调整音量等操作。以下是我们可以在视频对象上调用的属性和函数列表。
- en: Attributes
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: '`autoplay`(Boolean)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoplay`（布尔值）'
- en: '`currentTime`(float—in seconds)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentTime`（浮点数—以秒为单位）'
- en: '`paused` (Boolean)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paused`（布尔值）'
- en: '`controls` (Boolean)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controls`（布尔值）'
- en: '`muted` (Boolean)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`muted`（布尔值）'
- en: '`width` (integer)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`（整数）'
- en: '`height` (integer)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`（整数）'
- en: '`videoWidth` (integer—read only)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`videoWidth`（整数—只读）'
- en: '`videoHeight` (integer—read only)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`videoHeight`（整数—只读）'
- en: '`poster` (string—an image uri)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poster`（字符串—图像URI）'
- en: '`duration` (int—read only)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`（整数—只读）'
- en: '`loop` (Boolean)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`（布尔值）'
- en: '`currentSrc` (string)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentSrc`（字符串）'
- en: '`preload` (Boolean)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preload`（布尔值）'
- en: '`seeking` (Boolean)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seeking`（布尔值）'
- en: '`playbackRange` (integer)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbackRange`（整数）'
- en: '`ended` (Boolean)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ended`（布尔值）'
- en: '`volume` (integer—between 0 and 100 exclusive)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`（整数—介于0和100之间，不包括0和100）'
- en: Events
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: '| `loadstart` | The user agent begins looking for media data, as part of the
    resource selection algorithm. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `loadstart` | 用户代理开始查找媒体数据，作为资源选择算法的一部分。 |'
- en: '| `progress` | The user agent is fetching media data. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `progress` | 用户代理正在获取媒体数据。 |'
- en: '| `suspend` | The user agent is intentionally not currently fetching media
    data. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `suspend` | 用户代理有意不获取媒体数据。 |'
- en: '| `abort` | The user agent stops fetching the media data before it is completely
    downloaded, but not due to an error. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `abort` | 用户代理在完全下载之前停止获取媒体数据，但不是由于错误。 |'
- en: '| `error` | An error occurs while fetching the media data. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `error` | 在获取媒体数据时发生错误。 |'
- en: '| `emptied` | A media element whose networkState was previously not in the
    `NETWORK_EMPTY` state has just switched to that state (either because of a fatal
    error during load that''s about to be reported, or because the `load()` method
    was invoked while the resource selection algorithm was already running). |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `emptied` | 其网络状态先前不处于`NETWORK_EMPTY`状态的媒体元素刚刚切换到该状态（要么是因为在加载过程中发生了致命错误，即将报告，要么是因为在资源选择算法已经运行时调用了`load()`方法）。
    |'
- en: '| `stalled` | The user agent is trying to fetch media data, but data is unexpectedly
    not forthcoming. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `stalled` | 用户代理正在尝试获取媒体数据，但数据出乎意料地没有出现。 |'
- en: '| `loadedmetadata` | The user agent has just determined the duration and dimensions
    of the media resource and the text tracks are ready. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `loadedmetadata` | 用户代理刚刚确定了媒体资源的持续时间和尺寸，文本轨道已准备就绪。 |'
- en: '| `loadeddata` | The user agent can render the media data at the current playback
    position for the first time. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `loadeddata` | 用户代理可以首次在当前播放位置渲染媒体数据。 |'
- en: '| `canplay` | The user agent can resume playback of the media data, but estimates
    that if playback were to be started now, the media resource could not be rendered
    at the current playback rate up to its end without having to stop for further
    buffering of content. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `canplay` | 用户代理可以恢复播放媒体数据，但估计如果现在开始播放，媒体资源无法以当前播放速率一直播放到结束，而无需停止进行进一步的内容缓冲。
    |'
- en: '| `canplaythrough` | The user agent estimates that if playback were to be started
    now, the media resource could be rendered at the current playback rate all the
    way to its end without having to stop for further buffering. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `canplaythrough` | 用户代理估计，如果现在开始播放，媒体资源可以以当前播放速率一直播放到结束，而无需停止进行进一步的缓冲。 |'
- en: '| `playing` | Playback is ready to start after having been paused or delayed
    due to lack of media data. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `playing` | 经过暂停或由于缺乏媒体数据而延迟后，播放已准备好开始。 |'
- en: '| `waiting` | Playback has stopped because the next frame is not available,
    but the user agent expects that frame to become available in due course. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `waiting` | 播放已经停止，因为下一帧尚未准备好，但用户代理预计该帧将及时准备好。 |'
- en: '| `seeking` | The seeking IDL attribute changed to true. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `seeking` | 寻找的IDL属性已更改为true。 |'
- en: '| `seeked` | The seeking IDL attribute changed to false. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `seeked` | 寻找的IDL属性已更改为false。 |'
- en: '| `ended` | Playback has stopped because the end of the media resource was
    reached. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `ended` | 播放已停止，因为媒体资源的结束已经到达。 |'
- en: '| `durationchange` | The duration attribute has just been updated. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `durationchange` | 持续时间属性刚刚被更新。 |'
- en: '| `timeupdate` | The current playback position changed as part of normal playback
    or in an especially interesting way, for example, discontinuously. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `timeupdate` | 当前播放位置因正常播放或特别有趣的方式（例如不连续地）而发生了变化。 |'
- en: '| `play` | The element is no longer paused. Fired after the `play()` method
    has returned, or when the `autoplay` attribute has caused playback to begin. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `play` | 元素不再暂停。在`play()`方法返回后触发，或者`autoplay`属性导致播放开始时触发。 |'
- en: '| `pause` | The element has been paused. Fired after the `pause()` method has
    returned. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `pause` | 元素已暂停。在`pause()`方法返回后触发。 |'
- en: '| `ratechange` | Either the default `Playback Rate` or the `playback Rate`
    attribute has just been updated. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `ratechange` | 默认的`Playback Rate`或`playback Rate`属性刚刚被更新。 |'
- en: '| `volumechange` | Either the `volume` attribute or the `muted` attribute has
    changed. Fired after the relevant attribute''s setter has returned. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `volumechange` | `volume`属性或`muted`属性已更改。在相关属性的setter返回后触发。 |'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: For more information on events, visit W3C Candidate Recommendation Media Events
    at [http://www.w3.org/TR/html5/embedded-content-0.html#mediaevents](http://www.w3.org/TR/html5/embedded-content-0.html#mediaevents)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关事件的更多信息，请访问W3C候选推荐媒体事件[http://www.w3.org/TR/html5/embedded-content-0.html#mediaevents](http://www.w3.org/TR/html5/embedded-content-0.html#mediaevents)
- en: One final reason that you should be excited about the new HTML5 video element
    is that each frame of the video can be rendered right into a canvas 2D rendering
    context, just as if a single frame was a standalone image. This way, we are able
    to do video processing right on the browser. Unfortunately, there is no `video.toDataURL`
    equivalent where we could export the video created by our JavaScript application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对新的HTML5视频元素感到兴奋的另一个原因是，视频的每一帧都可以直接渲染到画布2D渲染上下文中，就像单独的一帧是一个独立的图像一样。这样，我们就能够在浏览器上进行视频处理。不幸的是，我们无法导出由我们的JavaScript应用程序创建的视频的`video.toDataURL`等价物。
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The idea is to play the video offscreen, meaning that the actual video player
    is never attached to the DOM. The video still plays, but the browser never needs
    to blitz each frame to the screen (it only plays in memory). As each frame is
    played, we draw that frame to a canvas context (just like we do with images),
    take the pixels from the canvas context, manipulate the pixel data, then finally
    draw it back on to the canvas.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是在屏幕外播放视频，这意味着实际的视频播放器从未附加到DOM。视频仍在播放，但浏览器从不需要将每一帧闪电般地显示在屏幕上（它只在内存中播放）。当每一帧播放时，我们将该帧绘制到画布上下文中（就像我们对图像做的那样），从画布上下文中获取像素，操纵像素数据，然后最终将其重新绘制到画布上。
- en: 'Since a video is nothing more than a sequence of frames played one after the
    other, giving the illusion of animation, we can extract each frame from an HTML5
    video and use it with the canvas API just like any other image. Since there isn''t
    a way to draw to the video element, we simply keep on drawing each frame from
    the video player into a plain canvas object, achieving the same result—but with
    carefully crafted pixels. The following screenshot illustrates the result of this
    technique:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视频只不过是一个接着一个播放的帧序列，给人以动画的错觉，我们可以从HTML5视频中提取每一帧，并像处理其他图像一样使用它与画布API。由于没有办法绘制到视频元素，我们只需将视频播放器中的每一帧绘制到一个普通的画布对象中，就能达到相同的效果——但是像素经过精心设计。以下截图展示了这种技术的结果：
- en: '![Events](img/6029OT_07_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Events](img/6029OT_07_04.jpg)'
- en: One way to achieve this result is to create two canvas elements. If we only
    draw to the same canvas (draw the frame from the video, then manipulate that frame,
    then draw the next frame, and so on), the customized frame would only be visible
    for a fraction of a second. It would only be visible until we quickly drew the
    next incoming frame. In turn, this next frame would only be visible for as long
    as we looped through that frame's pixel data and redrew that frame again. You
    get the idea, the result would be messy, and not at all what we want.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一结果的一种方法是创建两个画布元素。如果我们只绘制到同一个画布上（绘制视频帧，然后处理该帧，然后绘制下一帧，依此类推），定制帧将只在屏幕上显示一小部分时间。只有在我们迅速绘制下一个传入帧之前才会可见。反过来，这个下一个帧只会在我们循环遍历该帧的像素数据并重新绘制该帧时才会可见。你明白了，结果会很混乱，一点也不是我们想要的。
- en: So instead we use two canvas contexts. One context will be in charge of only
    displaying the pixels we work on (also known as, the manipulated pixels) and the
    other context will never be visible to the user and will serve the purpose of
    holding each frame as it comes straight from the video. This way, we're only drawing
    to our main, visible canvas once per iteration and all that's ever displayed in
    this canvas context is the manipulated pixels. The original pixels (also known
    as, the pixels from the original video that's playing in memory) will continue
    to be streamed to the offscreen canvas context as fast as they can.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用两个画布上下文。一个上下文负责仅显示我们正在处理的像素（也称为处理后的像素），另一个上下文对用户永远不可见，其目的是保存每一帧从视频中直接传来的像素。这样，我们每次迭代只在主画布上绘制一次，而在这个画布上显示的只有处理后的像素。原始像素（也称为内存中播放的原始视频的像素）将继续以尽可能快的速度流到离屏画布上下文。
- en: Geolocation
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理位置
- en: Although 3D graphics are awesome, as is a socket-based, multiplayer game, neither
    technology is necessarily new. Geolocation, on the other hand, is somewhat of
    a more recent phenomenon. With it, we are able to use JavaScript to determine
    the physical location (geographical location) of a user. Having such a tool at
    our disposal opens up new possibilities of awesome, highly innovative game concepts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管3D图形很棒，基于套接字的多人游戏也很棒，但这两种技术都不一定是新的。另一方面，地理位置是一种较新的现象。有了它，我们能够使用JavaScript来确定用户的物理位置（地理位置）。拥有这样的工具使我们能够开发出令人惊叹的、高度创新的游戏概念。
- en: Now, whenever a new feature comes out that promises to be able to track down
    exactly where a user is physically located, most people (except for developers,
    of course) get at least a little scared about it. After all, how creepy would
    it be to play a very dark, survival horror game, knowing that other people playing
    the game can see exactly where you live. Luckily for us, the entire geolocation
    API is opt-in-based, meaning that the user is prompted about the application attempting
    to capture the user's location and the browser only allows the application to
    continue to capture the GPS location of the user if and when the user accepts
    the request from the application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当有一个新功能出现，承诺能够准确追踪用户的物理位置，大多数人（除了开发人员）都会对此感到至少有点害怕。毕竟，如果玩一个非常黑暗的生存恐怖游戏，知道其他玩家可以准确看到你的住址，那将是多么可怕。幸运的是，整个地理位置API都是基于用户选择的，这意味着用户会被提示应用程序尝试捕获用户的位置，只有当用户接受应用程序的请求时，浏览器才允许应用程序继续捕获用户的GPS位置。
- en: As shown in the following screenshot, when attempting to use the geolocation
    API, the browser will somehow alert the user about it and ask for permission to
    continue. If the user decides not to share his or her location with the application,
    the browser will not share the location with the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，当尝试使用地理位置API时，浏览器会以某种方式向用户发出警报，并请求继续。如果用户决定不与应用程序共享他/她的位置，浏览器将不会与应用程序共享位置。
- en: '![Geolocation](img/6029OT_07_05.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![地理位置](img/6029OT_07_05.jpg)'
- en: Although each browser implements this request step slightly differently, especially
    with regards to how this notification and request is graphically conveyed to the
    user, there is no way for the application to use the geolocation API to forcefully
    or secretly collect this piece of information.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个浏览器在请求步骤上的实现略有不同，特别是关于如何向用户图形化传达此通知和请求的方式，但应用程序无法强制或秘密收集此信息。
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first part of the API involves asking the user for permission to get his
    or her location. This is done by calling the `getCurrentPosition` function on
    the `geolocation` attribute of the global navigator object. The function takes
    two arguments, namely a callback function to be called if the user allows the
    browser to share the user's location and a callback function to be called if the
    user denies the application's request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: API的第一部分涉及请求用户允许获取他/她的位置。这是通过在全局navigator对象的`geolocation`属性上调用`getCurrentPosition`函数来完成的。该函数接受两个参数，即一个回调函数，如果用户允许浏览器共享用户的位置，则调用该函数，以及一个回调函数，如果用户拒绝应用程序的请求，则调用该函数。
- en: 'If the user accepts the request from the application to share the geolocation,
    the callback is invoked with a `Geoposition` object passed in to it. This object
    has *nine* properties that we can use:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户接受了应用程序的请求来共享地理位置，回调函数将被调用，并传入一个`Geoposition`对象。该对象有*九*个我们可以使用的属性：
- en: '`timestamp`: When the callback function was invoked'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp`: 回调函数被调用时'
- en: '`coords`: An instance of class `Coordinates`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coords`: 一个`Coordinates`类的实例'
- en: '`accuracy`: How accurate the GPS coordinate is (in meters)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accuracy`: GPS坐标的准确度（以米为单位）'
- en: '`altitude`: In meters'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`altitude`: 以米为单位'
- en: '`altitudeAccuracy`: How accurate the altitude is (in meters)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`altitudeAccuracy`: 海拔的准确度（以米为单位）'
- en: '`heading`: In degrees clockwise from north'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heading`: 以顺时针方向的度数'
- en: '`latitude`: As a double'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`latitude`: 作为双精度'
- en: '`longitude`: As a double'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longitude`: 作为双精度'
- en: '`speed`: In meters per second'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speed`: 以米/秒为单位'
- en: There are only three attributes in the position object that are required to
    be present. These are the `latitude` and `longitude` values, along with the `accuracy`
    attribute. All other values are optional and will be available if the hardware
    in use supports them. Keep in mind, also, that this feature is equally available
    on mobile devices, so it is possible and likely that the user's position changes
    somewhat during the course of the application's usage. Thankfully, once the user
    has agreed to have his or her position shared with the application, any subsequent
    calls to get the current position will be successful right away. Of course, the
    user can just as well clear the permissions for a given domain right from the
    browser, so any subsequent calls to get the position may fail (if the user has
    disabled the feature altogether) or result in a new request for permission (in
    case the user simply cleared the permissions cache on the browser).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 位置对象中只有三个属性是必须存在的。这些是`纬度`和`经度`值，以及`精度`属性。如果使用的硬件支持，所有其他值都是可选的并且可用。还要记住，这个功能在移动设备上同样可用，因此用户的位置在应用程序使用过程中可能会有所变化。幸运的是，一旦用户同意与应用程序共享他或她的位置，任何后续调用获取当前位置的操作都将立即成功。当然，用户也可以从浏览器中清除对特定域的权限，因此任何后续获取位置的调用可能会失败（如果用户已经完全禁用了该功能），或者导致新的权限请求（如果用户只是清除了浏览器上的权限缓存）。
- en: As you can see from the following screenshot, Google Chrome displays a different
    icon on the address bar when a page is using geolocation to let the user know
    about it. By clicking this special icon, the user can reset the permissions, or
    block or allow the application on a more long term basis.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从下面的屏幕截图中可以看出，当页面使用地理位置时，谷歌浏览器在地址栏上显示不同的图标，以通知用户。通过点击这个特殊的图标，用户可以重置权限，或者在更长时间的基础上阻止或允许应用程序。
- en: '![Geolocation](img/6029OT_07_06.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![地理位置](img/6029OT_07_06.jpg)'
- en: A Google Maps example
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个谷歌地图示例
- en: Possibly the most common use case for geolocation these days involves rendering
    a position to a map. Thankfully, Google offers a terrific, free API that we can
    tap into for the purposes of doing just that. With this mapping service, we can
    capture a user's geolocation, then render a marker on the map right where the
    user is located (or somewhere within the accuracy distance of where the user is).
    While the Google Maps API is rather robust, we will simply cover a fairly trivial
    example of how we can go about obtaining the user's location then render that
    coordinate point on a map.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，地理位置最常见的用例可能涉及将位置呈现到地图上。幸运的是，谷歌提供了一个出色的免费API，我们可以利用它来实现这一目的。通过这个地图服务，我们可以捕获用户的地理位置，然后在地图上渲染一个标记，就在用户所在的位置（或者在用户所在位置的精度距离内的某个地方）。虽然谷歌地图API相当强大，但我们只会简单介绍如何获取用户的位置，然后在地图上呈现该坐标点的一个相当琐碎的例子。
- en: 'The general idea where the maps API is based is simple: create a map object
    to be rendered inside some HTML container object, specify where this map is to
    be centered (so that we can know the general area within the map that is immediately
    visible to the user), and add markers to it. Marker objects take at least two
    attributes, namely a reference to a map object and a GPS coordinate point. In
    our example, we''ll center the map on the user''s GPS coordinate and also place
    a marker on that same location.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 地图API的基本思想很简单：创建一个地图对象，将其呈现在某个HTML容器对象内，指定地图的中心位置（以便我们知道地图中用户立即可见的一般区域），并在地图上添加标记。标记对象至少需要两个属性，即对地图对象的引用和GPS坐标点。在我们的示例中，我们将把地图的中心放在用户的GPS坐标上，并在同一位置放置一个标记。
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While the preceding example might not be the most exciting piece of software
    you've seen, it does a great job illustrating two powerful points. First, the
    geolocation API is powerful, yet, it is also possibly the easiest of all other
    HTML5 APIs in terms of all the functionality it offers and everything you need
    to know in order to use it. Second, the preceding snippet shows how open the web
    platform is and how much we can potentially accomplish simply by taking advantage
    of other people's work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子可能不是你见过的最激动人心的软件，但它很好地说明了两个重要的观点。首先，地理位置API很强大，但也可能是所有其他HTML5 API中最容易使用的，因为它提供了所有功能和你需要知道的一切。其次，前面的片段展示了Web平台是多么开放，以及我们可以通过利用他人的工作来实现多少潜力。
- en: Running the preceding code will result in a very nice looking map covering the
    entirety of the screen, with the central point of the map being the user's current
    location, as shown in the following screenshot. Keep in mind that Google Maps
    is just one example of the many free APIs that we can use in conjunction with
    such powerful HTML5 features as geolocation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将导致一个非常漂亮的地图覆盖整个屏幕，地图的中心点是用户当前的位置，如下面的屏幕截图所示。请记住，谷歌地图只是许多免费API中的一个例子，我们可以与地理位置等强大的HTML5功能一起使用。
- en: '![A Google Maps example](img/6029OT_07_07.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![一个谷歌地图示例](img/6029OT_07_07.jpg)'
- en: Upcoming CSS features
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将推出的CSS功能
- en: One of my favorite things about the Open Web is that it is also a living web.
    As new ideas arise and as new needs manifest themselves, it becomes a matter of
    time until new features are introduced into a spec. A perfect example of this
    is CSS, where recently there have been a few new features added to the spec. Best
    of all, most browser vendors are quite proactive at bringing these new features
    to their browsers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的关于开放网络的事情之一是它也是一个活跃的网络。随着新的想法的出现和新的需求的显现，新功能被引入到规范中只是时间问题。CSS就是一个完美的例子，最近规范中添加了一些新功能。最重要的是，大多数浏览器供应商都非常积极地将这些新功能引入到他们的浏览器中。
- en: In this next section we will look at three new features of CSS, namely CSS shaders,
    CSS columns, and CSS regions and exclusions. To give you an idea of how active
    the development of these features is, we will discuss the first feature **CSS
    shaders**, which was recently renamed as CSS custom filters. Talk about a fast
    moving development life cycle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将介绍CSS的三个新功能，即CSS着色器、CSS列和CSS区域和排除。为了让您了解这些功能的开发活跃程度，我们将讨论第一个功能**CSS着色器**，它最近更名为CSS自定义滤镜。谈论一个快速发展的开发生命周期。
- en: Programming in the bleeding edge
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在最前沿编程
- en: Although most of the content in this book is somewhat new and state of the art,
    the majority of the HTML5 features and APIs discussed so far are fairly stable.
    By that, I mean that just about any major browser should be able to handle these
    features without any problems. However, the following CSS features are literally
    fresh out of the oven. To be more specific, all three of these features are still
    being baked, with the recipe being worked on until it reaches a more stable level
    of refinement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书中的大部分内容都是新的和最先进的，但到目前为止，讨论的大多数HTML5功能和API都是相当稳定的。我的意思是，几乎任何主要的浏览器都应该能够处理这些功能而不会出现任何问题。然而，以下CSS功能刚刚出炉。更具体地说，这三个功能仍在烘烤中，配方正在不断完善，直到达到更稳定的水平。
- en: 'With that said, this section may require that you use the absolute most recent
    browsers, using the latest possible version, and you may even be required to delve
    into the settings section of your browser of choice so that any advanced flags
    are set in order for these new and experimental features to work. All of the code
    examples for the rest of this chapter were written for and tested in Google Chrome
    Canary (nightly builds). As of this writing, after a fresh install of Google Chrome
    Canary, the following flags had to be manually enabled:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个说法，这一部分可能需要您使用绝对最新的浏览器，使用最新的可能版本，甚至可能需要您深入您选择的浏览器的设置部分，以便设置任何高级标志，以便这些新的实验性功能能够工作。本章的所有代码示例都是为Google
    Chrome Canary（夜间构建）编写和测试的。在我写这篇文章时，安装Google Chrome Canary后，必须手动启用以下标志：
- en: Enable `experimental WebKit features`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用`实验性WebKit功能`
- en: Enable `CSS shaders`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用`CSS着色器`
- en: 'You likely won''t need to enable the `WebGL` flag, as this particular flag
    has been enabled by default for a while, but in case the flag is disabled, you
    can make it available in the same manner. To view all the available flags that
    can be set on Google Chrome, simply type the following command in the browser''s
    address bar (where you normally enter a website''s URL): `chrome://flags`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不需要启用`WebGL`标志，因为这个特定的标志已经默认启用了一段时间，但是如果该标志被禁用，您可以以相同的方式使其可用。要查看可以在Google
    Chrome上设置的所有可用标志，只需在浏览器的地址栏中输入以下命令（通常在那里输入网站的URL）：`chrome://flags`。
- en: Once in the flags page, you will see a list of flags, along with a description
    of what each flag does. Look for the two flags related to `experimental WebKit
    features` and `CSS shaders`, and be sure that they are enabled. As you can tell
    from the following screenshot, beware that carelessly setting and unsetting flags
    may affect the way that Google Chrome behaves and performs. Be sure to change
    the least amount of flags to avoid doing anything to cause the browser to work
    less than optimally and make sure you keep track of any flags you change, so that
    you can revert your changes, should anything bad happen as a result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在标志页中，您将看到一个标志列表，以及每个标志的描述。查找与`实验性WebKit功能`和`CSS着色器`相关的两个标志，并确保它们已启用。如下截图所示，要注意的是，粗心地设置和取消标志可能会影响Google
    Chrome的行为和性能。确保更改最少的标志，以避免使浏览器的工作不够理想，并确保跟踪您更改的任何标志，以便在发生任何不良情况时可以恢复更改。
- en: '![Programming in the bleeding edge](img/6029OT_07_08.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: 在最前沿编程
- en: One final note about developing with these absolute bleeding edge APIs is that,
    given the nature of an experimental API, there may be browser specific syntax
    and features as well as significant performance differences between different
    browsers. Since not all browsers start adopting new APIs at the same time, a great
    percentage of users are not able to view your latest and greatest code until APIs
    become stable enough—which sometimes takes longer than we'd like them to.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用这些绝对最新的实验性API进行开发的最后一点说明是，由于实验性API的性质，不同浏览器之间可能存在特定的语法和功能，以及显著的性能差异。由于并非所有浏览器同时开始采用新的API，因此很大一部分用户无法查看您的最新和最棒的代码，直到API变得足够稳定——有时需要的时间比我们希望的长。
- en: CSS shaders
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS着色器
- en: Currently, this is the absolute latest feature added to CSS. The original idea
    behind CSS shaders was to allow a designer to use GLSL shaders to render arbitrary
    HTML elements. Instead of simply specifying an element's background color, border
    style, box shadow, and so on, we can now take care of how each pixel of an element
    is rendered.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这是CSS中添加的绝对最新功能。CSS着色器背后的最初想法是允许设计师使用GLSL着色器来渲染任意HTML元素。现在，我们不仅可以指定元素的背景颜色、边框样式、框阴影等，还可以处理元素的每个像素是如何渲染的。
- en: More recently, this feature was merged into the existing CSS filters spec, which
    specifing a handful of pre-baked filters that we can apply to an element. For
    example, we can apply a blur filter to an image element, letting the browser process
    the image dynamically, as it gets served from the server to the web application.
    However, instead of relying only on whatever filters a browser decides to make,
    we can now cook our own filters and have the CSS rendering engine use those. Thus,
    the current name of this new CSS API is (for now, anyway) **custom CSS filters**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，这个功能已经合并到现有的CSS滤镜规范中，该规范规定了一些预先制作的滤镜，我们可以应用到一个元素上。例如，我们可以将模糊滤镜应用到图像元素上，让浏览器在从服务器传送到Web应用程序时动态处理图像。然而，我们现在不仅仅依赖于浏览器决定使用哪些滤镜，而是可以自己制作滤镜，并让CSS渲染引擎使用它们。因此，这个新的CSS
    API的当前名称（无论如何）是**自定义CSS滤镜**。
- en: Using CSS filters is pretty easy. After all, they are nothing more than a regular
    CSS property. As of this writing, there are *nine* different filters that we can
    apply, not only to images, but also to anything that can receive CSS styling.
    If a filter is added to an element with one or more children nodes in it, as is
    the nature of CSS, the filter effect will cascade down to any and all child elements,
    unless one or more of them specify their own filters, or deliberately specify
    that no filtering should be applied to it and its children.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS滤镜非常容易。毕竟，它们只是一个常规的CSS属性。截至目前，我们可以应用*九种*不同的滤镜，不仅适用于图像，还适用于任何可以接收CSS样式的东西。如果将滤镜添加到具有一个或多个子节点的元素中，正如CSS的性质一样，滤镜效果将传播到任何和所有子元素，除非其中一个或多个指定了自己的滤镜，或者故意指定不应该对其和其子元素应用任何滤镜。
- en: 'The current list of CSS filters that can be used are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: CSS滤镜的当前列表如下：
- en: '`blur`: Applies a Gaussian blur'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur`：应用高斯模糊'
- en: '`brightness`: Increases the brightness of the element by applying more or less
    white color'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brightness`：通过应用更多或更少的白色颜色来增加元素的亮度'
- en: '`contrast`: Adjusts the contrast of the element'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contrast`：调整元素的对比度'
- en: '`drop-shadow`: Applies a drop shadow effect to the element'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop-shadow`：对元素应用阴影效果'
- en: '`grayscale`: Converts the colors of the element into grayscale'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grayscale`：将元素的颜色转换为灰度'
- en: '`hue-rotate`: Applies a hue rotation in degrees based on a color circle'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hue-rotate`：根据颜色圆对元素应用色相旋转'
- en: '`invert`: Inverts the colors of the element'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invert`：反转元素的颜色'
- en: '`opacity`: Applies transparency to the element'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opacity`：对元素应用透明度'
- en: '`saturate`: Increases the saturation of the element'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saturate`：增加元素的饱和度'
- en: '`sepia`: Converts the colors of the element into sepia'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepia`：将元素的颜色转换为棕褐色'
- en: Keep in mind that, although these filters are in fact mere CSS attributes, in
    reality they are each a separate function that the browser performs on the elements
    matched by the CSS query. Thus, each filter function takes one or more arguments,
    which, behind the scenes, are variables being passed to pre-defined shader programs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管这些滤镜实际上只是CSS属性，但实际上它们是浏览器在CSS查询匹配的元素上执行的单独函数。因此，每个滤镜函数都需要一个或多个参数，在幕后，这些参数是传递给预定义的着色器程序的变量。
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following screenshot, the image on the left is a regular piece of HTML,
    with a heading and an image. On the right, we applied a CSS filter that inverted
    the colors. That entire effect was achieved with a single line of code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，左侧的图像是一个常规的HTML元素，带有一个标题和一个图像。在右侧，我们应用了一个CSS滤镜，反转了颜色。整个效果是用一行代码实现的。
- en: '![CSS shaders](img/6029OT_07_14.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![CSS着色器](img/6029OT_07_14.jpg)'
- en: Note that we can apply multiple filters to the same element by just simply listing
    additional filters as the value of the CSS property. Also, keep in mind that even
    though it only takes a single line of code to add one of these exciting filters
    to our applications, each filter used means work that the browser will need to
    do on top of all that it's already doing. Thus, the more we use these filters,
    the more we can expect performance to drop accordingly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以通过简单地将其他滤镜列为CSS属性的值来将多个滤镜应用于同一元素。此外，请记住，即使只需一行代码就可以将这些令人兴奋的滤镜之一添加到我们的应用程序中，每个使用的滤镜都意味着浏览器需要在其已经在做的所有工作之上进行更多的工作。因此，我们使用这些滤镜越多，我们就可以预期性能相应地下降。
- en: Using custom filters
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义滤镜
- en: In order to input our own filtering functions for the browser to use when rendering
    our application, we need to create the shader program that does what we want.
    Thankfully, these shader programs are written in the same shading language that
    we use in WebGL. If you thought learning JavaScript, CSS, and HTML was a lot of
    work already, I'm sorry to say, but go ahead and add GLSL to the list of languages
    you must master (or find someone who's already mastered it) in order to take full
    advantage of the HTML5 revolution.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在渲染我们的应用程序时输入自己的过滤函数，我们需要创建执行我们想要的操作的着色器程序。值得庆幸的是，这些着色器程序是用我们在WebGL中使用的相同的着色语言编写的。如果你认为学习JavaScript、CSS和HTML已经是很多工作了，我很抱歉地说，但是请继续将GLSL添加到你必须掌握的语言列表中（或者找到已经掌握它的人），以充分利用HTML5革命。
- en: To specify custom shaders to be used for our CSS filters, we simply call the
    custom function as the value of the filter attribute, pass in our vertex and fragment
    shaders, followed by any possible variables to be used by the vertex shader. External
    variables used by the fragment shader are passed in from the vertex shader, so
    we can't pass anything into it directly from CSS.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定用于CSS滤镜的自定义着色器，我们只需将自定义函数作为filter属性的值调用，传入我们的顶点和片段着色器，然后是顶点着色器要使用的任何可能的变量。片段着色器使用的外部变量是从顶点着色器传入的，因此我们无法直接从CSS中传入任何内容。
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are three parts to the preceding filter definition. First, we call `custom`
    to indicate that we'll be using our own shaders. The first argument we pass to
    this function is the vertex shader. The extension of this file is not important,
    as the contents of the file will be compiled and sent to the GPU. A lot of the
    time, you will see other developers using file extensions for their shaders such
    as `.glsl` or `.vs` and `.fs` (for vertex shader and fragment shader, respectively).
    Note that the fragment shader is sent through the `mix()` function, as opposed
    to just being sent directly through the `url()` function, as is the case with
    the vertex shader. Lastly, we specify the number of rows and columns that will
    make up the element's content mesh. The vertices that make up this mesh are created
    by the browser automatically. Finally, the last set of arguments passed with our
    custom filter are uniform values (accompanied by their names) for the vertex shader
    to use.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的滤镜定义有三个部分。首先，我们调用`custom`表示我们将使用自己的着色器。我们传递给这个函数的第一个参数是顶点着色器。这个文件的扩展名并不重要，因为文件的内容将被编译并发送到GPU。很多时候，你会看到其他开发人员为他们的着色器使用文件扩展名，比如`.glsl`或`.vs`和`.fs`（分别用于顶点着色器和片段着色器）。请注意，片段着色器通过`mix()`函数发送，而不是直接通过`url()`函数发送，这与顶点着色器的情况不同。最后，我们指定将构成元素内容网格的行数和列数。构成这个网格的顶点是浏览器自动创建的。最后，与我们自定义滤镜一起传递的最后一组参数是顶点着色器使用的uniform值（附带它们的名称）。
- en: Since GLSL itself is beyond the scope of this book, we will stay away from a
    thorough example of these custom shaders. Instead, we will look at a symbolic
    example, which will use dummy shaders. Without the proper background knowledge
    and experience with graphics programming, shader programming, and other 3D graphics
    topics, it would be rather challenging to explain our way through a custom shader
    program.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GLSL本身超出了本书的范围，我们将避免对这些自定义着色器进行彻底的示例。相反，我们将看一个象征性的例子，它将使用虚拟着色器。如果没有正确的背景知识和图形编程、着色器编程和其他3D图形主题的经验，解释自定义着色器程序将是相当具有挑战性的。
- en: 'The following shader programs take three inputs from CSS, namely a value between
    0.0 and 1.0 representing the amount of red, green, and blue to be applied to each
    pixel in the image. As a quick and brief crash course in OpenGL Shading Language
    (GLSL), I''ll just say this: a uniform is like a global variable that we can pass
    in to the vertex shader. The vertex shader is called once per vertex and determines
    where each vertex is positioned. In order to send values to the fragment shader,
    the vertex shader can use a varying variable. If we define a variable of whatever
    type in the vertex shader that has the `varying` keyword before it, that means
    that whatever value is assigned to it will be available to the fragment shader,
    provided that the fragment shader also defines a varying variable of the same
    name and type. Thus, if we want a value to be passed to the fragment shader directly
    from CSS, we can simply send the value to the vertex shader, then use `varying`
    to pass the value through to the fragment shader. The fragment shader is called
    once per pixel and determines what color to apply to that pixel.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下着色器程序从CSS中获取三个输入，即表示图像中每个像素应用的红色、绿色和蓝色的量的值，介绍OpenGL着色语言（GLSL）的快速简要入门课程，我只想说：uniform就像是一个全局变量，我们可以传递给顶点着色器。顶点着色器每个顶点调用一次，并确定每个顶点的位置。为了将值发送到片段着色器，顶点着色器可以使用varying变量。如果我们在顶点着色器中定义了一个带有`varying`关键字的任何类型的变量，这意味着分配给它的任何值将可供片段着色器使用，前提是片段着色器还定义了相同名称和类型的varying变量。因此，如果我们希望从CSS直接将一个值传递到片段着色器，我们可以简单地将值发送到顶点着色器，然后使用`varying`将该值传递到片段着色器。片段着色器每个像素调用一次，并确定要应用于该像素的颜色。
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only two things the preceding vertex shader does are pass our values from
    CSS to the fragment shader and set the vertex position of each vertex on our content
    mesh.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的顶点着色器所做的只有两件事：将我们的值从CSS传递到片段着色器，并设置内容网格上每个顶点的顶点位置。
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With that shader program in place, all we need to do is call it from within
    our HTML file. The three parameters we need to pay attention to are the red, green,
    and blue uniforms. Whatever values we send in for those three color channels,
    it will reflect on the rendering of whatever elements we apply this filter to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个着色器程序，我们只需要在HTML文件中调用它。我们需要注意的三个参数是红色、绿色和蓝色的uniform值。无论我们为这三个颜色通道发送什么值，它都会反映在我们应用这个滤镜的任何元素的渲染上。
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this setup in place, our `div` element will render one particular way by
    default. In this case, we only turn on the red channel on every pixel within the
    DOM node. When we hover over the element, however, we apply the same shader, but
    with a completely different color. This time we make every pixel look extra yellow.
    With the help of CSS transitions, we can smoothly gradate those two states, giving
    a simple, yet quite cozy effect. Of course, the more you know about GLSL, the
    more fancy and powerful you can make these custom shaders. And as an added bonus,
    we don't have to worry about all of the setup work involved in using shaders in
    WebGL. The default abstraction provided by the browser is quite useful, making
    custom shaders very reusable, since people using our shaders only need to keep
    track of a couple of CSS attributes. Best of all, since shader programs are, at
    least at this CSS level, pure text files, we can learn how other people's shaders
    work by inspecting their source code. By using our custom shader, we can easily
    control which color channels are turned on or off at an individual pixel level,
    as shown in the following screenshot. This pixel by pixel manipulation is not
    only limited to images, but is rather performed on each pixel of whatever DOM
    element we apply the filter to—text, images, containers, and so on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们的`div`元素将默认以一种特定的方式呈现。在这种情况下，我们只在DOM节点内的每个像素上打开红色通道。然而，当我们悬停在元素上时，我们应用相同的着色器，但颜色完全不同。这次我们让每个像素看起来更加黄色。借助CSS过渡，我们可以平滑地过渡这两种状态，产生一个简单而非常舒适的效果。当然，您对GLSL了解得越多，您就可以使这些自定义着色器变得更加花哨和强大。而且作为额外的奖励，我们不必担心在WebGL中使用着色器所涉及的所有设置工作。浏览器提供的默认抽象非常有用，使得自定义着色器非常可重用，因为使用我们的着色器的人只需要跟踪几个CSS属性。最重要的是，由于着色器程序在这个CSS级别上至少是纯文本文件，我们可以通过检查其源代码来了解其他人的着色器是如何工作的。通过使用我们的自定义着色器，我们可以轻松地控制哪些颜色通道在单个像素级别上打开或关闭，如下面的屏幕截图所示。这种像素级别的操作不仅限于图像，而是在我们将滤镜应用于的每个DOM元素的每个像素上执行。文字、图像、容器等。
- en: '![Using custom filters](img/6029OT_07_15.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义滤镜](img/6029OT_07_15.jpg)'
- en: Beware, however, that since this technology is so hot off the oven, there are
    very few tools, if any, to help us develop, debug, and maintain GLSL shaders.
    You will quickly notice that when an error is found within your shaders, you will
    simply see an unfiltered HTML document. If your shader programs fail to compile,
    for example, the browser will not bother letting you know what happened, or where,
    or maybe even why. Thus, writing custom CSS filters can be the most challenging
    aspect of web development at the moment, since browsers are not yet very useful
    in offering a hand in the process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，由于这项技术是最新的，几乎没有工具可以帮助我们开发、调试和维护GLSL着色器。您很快会注意到，当在您的着色器中发现错误时，您将只会看到一个未经过滤的HTML文档。例如，如果您的着色器程序无法编译，浏览器将不会告诉您发生了什么，或者在哪里，甚至可能为什么。因此，编写自定义CSS滤镜可能是目前网页开发中最具挑战性的方面，因为浏览器尚未在这个过程中提供很有用的帮助。
- en: CSS columns
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS列
- en: If you have been using the internet for at least a few weeks, or if you have
    seen at least a couple of dozen different websites, you will certainly have noticed
    the rectangular nature of HTML documents. Although it is possible to use a combination
    of HTML, JavaScript, and CSS to create very robust designs, web designers have
    been waiting for many moons for a simple solution to create multicolumn designs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您至少使用互联网几周，或者至少看过几十个不同的网站，您肯定会注意到HTML文档的矩形特性。虽然可以使用HTML、JavaScript和CSS的组合来创建非常健壮的设计，但网页设计师已经等待了很长时间，以寻找一个简单的解决方案来创建多列设计。
- en: With the new CSS columns feature, we can create a regular block of text, then
    tell the CSS engine to display that block in two or more columns. Everything else
    is handled by the browser very efficiently. For example, say we want a block of
    text to be displayed into four equal width columns, with 20 pixels between each
    column. This can be achieved with two intuitive lines of code (vendor prefix may
    be required, but is deliberately ignored in this example).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过新的CSS列功能，我们可以创建一个常规的文本块，然后告诉CSS引擎将该块显示为两列或更多列。其他所有事情都由浏览器非常高效地处理。例如，假设我们希望将一个文本块显示为四个等宽的列，每列之间间隔20像素。这可以通过两行直观的代码实现（可能需要供应商前缀，但在这个例子中被故意忽略）。
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the preceding setup, the browser knows that we wish to render our text
    into four columns, with 20 pixels separating each column on the sides. Observe
    that no mention is ever made about how wide to make each column. In this case,
    the browser calculates the space available inside the `div` container, subtracts
    the total width needed for the column gap (the space between two columns, not
    including the space between a column and the container), then divides the remaining
    width into the total number of columns. This way, as we resize the browser window,
    the columns will automatically resize and everything else will retain its dimensions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述设置，浏览器知道我们希望将文本渲染成四列，每列之间间隔20像素。请注意，从来没有提到过每列的宽度。在这种情况下，浏览器计算出`div`容器内的可用空间，减去列间隙所需的总宽度（两列之间的空间，不包括列与容器之间的空间），然后将剩余宽度分成总列数。这样，当我们调整浏览器窗口大小时，列将自动调整大小，其他所有内容将保持其尺寸。
- en: After we specify a column gap width, the browser can determine how wide to make
    each column (if we specify a fixed number of columns) or a number of columns to
    display (if we specify a width for each column) based on the available space for
    the columns, as shown in the following screenshot. It doesn't normally make sense
    to specify both a column width and a number of columns.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们指定列间距宽度之后，浏览器可以根据列的可用空间确定每一列的宽度（如果我们指定了固定数量的列），或者确定要显示的列数（如果我们为每一列指定了宽度），如下面的屏幕截图所示。通常情况下，指定列宽和列数是没有意义的。
- en: '![CSS columns](img/6029OT_07_09.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![CSS列](img/6029OT_07_09.jpg)'
- en: Alternatively, we can simply tell the browser how wide we want each column,
    and optionally how much gap to have between two columns. What the browser would
    do in this situation is the opposite. It would calculate the remaining space available
    for rendering the columns, then render as many columns as it can in that space,
    given the width constraint we have specified.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以简单地告诉浏览器我们希望每列有多宽，以及两列之间有多少间隙。在这种情况下，浏览器会做相反的事情。它会计算剩余的可用空间来呈现列，然后在给定我们指定的宽度约束的情况下，尽可能多地呈现列。
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The column rule
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列规则
- en: 'Similar to the concept of a border around a box, as in border: 1px solid #333,
    CSS columns come with the concept of a rule. Simply put, a column rule is a single
    border that is drawn vertically between two columns. A rule can be styled much
    like a border and is rendered right between the two columns, making use of the
    space provided by a column-gap. If the space available for a column rule is greater
    than the space provided by a column gap, the gap is rendered properly and the
    rule is ignored.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '与围绕在盒子周围的边框的概念类似，如border: 1px solid #333，CSS列带有规则的概念。简单地说，列规则是在两列之间垂直绘制的单个边框。规则可以像边框一样进行样式设置，并且在两列之间正确渲染，利用列间隙提供的空间。如果列规则的可用空间大于列间隙提供的空间，间隙将被正确渲染，规则将被忽略。'
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Again, similar to a border property, we can specify each attribute related
    to a column rule, or short hand the definition in the same order as a border (width,
    style, and color, respectively). Valid values for a border style include the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类似于边框属性，我们可以指定与列规则相关的每个属性，或者按照与边框相同的顺序简写定义（宽度、样式和颜色）。边框样式的有效值包括以下内容：
- en: '`none`: No border'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`: 无边框'
- en: '`dotted`: The border is a series of dots'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotted`: 边框是一系列点'
- en: '`dashed`: The border is a series of short line segments'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashed`: 边框是一系列短线段'
- en: '`solid`: The border is a single line segment'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`solid`: 边框是单一线段'
- en: '`double`: The border is two solid lines. The sum of the two lines and the space
    between them equals the value of ''border-width'''
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`: 边框是两条实线。两条线和它们之间的空间之和等于''border-width''的值'
- en: '`groove`: The border looks as though it were carved into the canvas'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groove`: 边框看起来像是雕刻在画布上'
- en: '`ridge`: The opposite of ''groove'': the border looks as though it were coming
    out of the canvas'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ridge`: 与''groove''相反：边框看起来像是从画布中出来的'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the table border styles, you can visit [http://www.w3.org/TR/CSS2/tables.html#table-border-styles](http://www.w3.org/TR/CSS2/tables.html#table-border-styles)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有关表格边框样式的更多信息，您可以访问[http://www.w3.org/TR/CSS2/tables.html#table-border-styles](http://www.w3.org/TR/CSS2/tables.html#table-border-styles)
- en: Column breaks
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列断
- en: Sometimes, we may want a bit of control over where exactly the content breaks
    into a new column. For example, if we have several blocks of text, each preceded
    by heading of some sort. It may not look too good if the last line in a column
    is a lonely heading meant to introduce the next section. The column break property
    gives us this ability where we can specify column breaks before or after an element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望对内容在哪里断开成新的列有一些控制。例如，如果我们有几个文本块，每个文本块前面都有某种标题。如果列的最后一行是一个孤立的标题，用来介绍下一节，那看起来可能不太好。列断属性给了我们这种能力，我们可以在元素之前或之后指定列断。
- en: 'By specifying where a column should or should not break into the next column,
    we can have more control over how each column is rendered and populated, as demonstrated
    in the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定列应该在何处断开成下一列，我们可以更好地控制每列的呈现和填充，如下截图所示：
- en: '![Column breaks](img/6029OT_07_10.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![列断](img/6029OT_07_10.jpg)'
- en: The same properties used to control page breaks in CSS are also used to control
    the breaking of columns. There are three properties we can use to control column
    break, namely `break-before`, `break-after`, and `break-inside`. The first two
    are fairly self-explanatory—we can use break before or after to indicate the behavior
    before or after a particular element, such as always break the column, never break,
    or insert the column break where it should normally be inserted. Break inside,
    on the other hand, specifies what should be the behavior inside a multiline block
    of text, instead of simply at its beginning or end.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中用于控制分页的相同属性也用于控制列的断开。我们可以使用三个属性来控制列断，即`break-before`、`break-after`和`break-inside`。前两个属性相当直观——我们可以使用break
    before或after来指示特定元素之前或之后的行为，例如总是断开列、永不断开，或者在应该正常插入的地方插入列断。另一方面，break inside指定多行文本内部的行为，而不仅仅是在其开始或结束处。
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note how the column break property is applied to the `h2` tag, which now becomes
    the element that controls the breaking of each column. Of course, if we had specified
    a greater number of columns in this block of text than there were headings tags,
    then obviously the text inside the paragraph tags would end up breaking into new
    columns. This behavior can also be controlled, although in this particular case
    we simply set the `column-break-inside` property to `auto`, making it clear that
    we would like the content of each paragraph tag to spill over into other columns
    if needed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列断属性应用于`h2`标签，现在它成为控制每列断的元素。当然，如果我们在这个文本块中指定的列数比标题标签多，那么段落标签中的文本显然会分成新的列。这种行为也可以被控制，尽管在这种情况下，我们只是将`column-break-inside`属性设置为`auto`，明确表示我们希望每个段落标签的内容如果需要的话可以溢出到其他列中。
- en: CSS regions and exclusions
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS区域和排除
- en: Two new text-related features of CSS are regions and exclusions. Regions behave
    somewhat similar to columns, in that we specify how a particular block of text
    is to render and flow. The main difference between regions and columns is that
    columns are restricted to equal width implied rectangles, whereas regions specify
    a separate content source and define where that content is to flow. For example,
    we can tell CSS to render text from a given source into three separate `div` elements,
    along with an arbitrary SVG polygon. Each of these elements need not be related
    in any particular way—one can be absolutely positioned, one can be transformed,
    and so on. The text would then flow from one element into the next, following
    the order in which each element is defined within the HTML file. Exclusions, on
    the other hand, do the exact opposite. Instead of defining areas where text flows
    into, they describe areas or shapes where text is to go around.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: CSS的两个新的与文本相关的特性是区域和排除。区域的行为与列有些相似，因为我们指定了特定文本块的呈现和流动方式。区域和列之间的主要区别在于，列被限制为等宽的隐含矩形，而区域指定了一个单独的内容源，并定义了该内容的流动位置。例如，我们可以告诉CSS将来自给定源的文本呈现到三个独立的`div`元素中，以及一个任意的SVG多边形。这些元素中的每一个都不需要以任何特定的方式相关联
    - 一个可以是绝对定位的，一个可以被转换，等等。然后文本将从一个元素流向下一个元素，按照每个元素在HTML文件中定义的顺序。另一方面，排除则完全相反。它不是定义文本流入的区域，而是描述文本应该绕过的区域或形状。
- en: The whole reason for these two separate, yet closely related APIs, is to push
    the envelope of where we can take the visual design of web applications. Until
    now, the only way to achieve this sort of effect was through external software,
    and hopefully a very specific plugin that allowed such software or technology
    to be executed inside a browser. Now that the browser has grown a bit more mature,
    we can pull off these magazine-like effects right from the stylesheet.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个分开但又密切相关的API的整个原因是推动我们可以将Web应用程序的视觉设计推向何方。直到现在，实现这种效果的唯一方法是通过外部软件，希望有一个非常特定的插件，允许在浏览器内执行这样的软件或技术。现在浏览器已经变得更加成熟，我们可以直接从样式表中实现这些类似杂志的效果。
- en: Regions
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区域
- en: The way regions work is somewhat similar to columns, yet it is fundamentally
    different. In general, all that regions do is specify a content source, then assign
    a CSS expression as the destination of that content. The content is moved from
    the element specified as the source and flowed into all elements assigned as destinations.
    If one or more elements don't receive any content because there wasn't enough
    content, these elements will behave just like a regular *empty* element. Other
    than the CSS property that identifies an element as a destination, there is nothing
    else about that element that is different from any other regular HTML elements.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 区域的工作方式与列有些相似，但基本上是不同的。总的来说，区域所做的就是指定一个内容源，然后将CSS表达式分配为该内容的目的地。内容从指定为源的元素移动，并流入所有分配为目的地的元素。如果一个或多个元素由于内容不足而没有接收到任何内容，这些元素将表现得就像一个普通的*空*元素一样。除了将元素标识为目的地的CSS属性之外，该元素与任何其他常规HTML元素没有任何不同。
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we assign the contents of the element with an `id` property of `src` as
    the content provider, so to speak. This is done by assigning the new CSS property
    `flow-into`, which is assigned a string that we can use to identify this particular
    region content source. That means that the contents of that element will not be
    rendered where they are within the DOM, but will instead be distributed among
    all elements with a CSS property of `flow-from`, with a value matching the keyword
    used by the element with the `flow-into` property.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将具有`id`属性为`src`的元素的内容分配为内容提供者，可以这么说。这是通过分配新的CSS属性`flow-into`来完成的，该属性分配了一个字符串，我们可以用它来标识这个特定的区域内容源。这意味着该元素的内容不会在DOM中呈现，而是会分布在所有具有`flow-from`
    CSS属性的元素中，其值与具有`flow-into`属性的元素使用的关键字匹配。
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once a region source is defined, and a region chain is created, the browser
    takes care of distributing the contents throughout all the regions. Each region
    can be uniquely styled and can be a unique element altogether. For example, a
    region source can be defined and two targets can be created. One target can be
    a standard `div` element and the other can be an SVG shape. CSS regions can also
    be combined with exclusions, which we'll discuss in the next section.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了区域源，并创建了区域链，浏览器就会负责将内容分发到所有区域中。每个区域都可以有独特的样式，也可以是一个独特的元素。例如，可以定义一个区域源并创建两个目标。一个目标可以是标准的`div`元素，另一个可以是SVG形状。CSS区域还可以与排除相结合，我们将在下一节讨论。
- en: As illustrated in the following screenshot, four elements are styled and floated
    about, while a region source is put in charge of filling up those regions. In
    case of region resizing, because of the browser window itself being resized, the
    user agent takes care of refreshing the content, flowing into the newly resized
    regions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，四个元素被样式化并浮动，同时一个区域源负责填充这些区域。在区域调整大小的情况下，由于浏览器窗口本身被调整大小，用户代理会负责刷新内容，流入新调整大小的区域。
- en: '![Regions](img/6029OT_07_13.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![区域](img/6029OT_07_13.jpg)'
- en: Exclusions
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排除
- en: The way exclusions work is very similar to how we normally make text flow around
    images or any other inline elements. The main difference is that we can take it
    a step further and specify a few details in CSS that tells the text exactly how
    to flow.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 排除的工作方式与我们通常使文本围绕图像或任何其他内联元素流动的方式非常相似。主要区别在于，我们可以进一步指定一些CSS细节，告诉文本如何流动。
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This trivial snippet simply tells the rest of the content inside that `div`
    element to flow around the image from its right side. Even if we had an SVG object
    in the place of that image, and this object was a polygon shaped like a triangle
    pointing to the right, the text would wrap around the object treating it like
    a rectangle.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个琐碎的片段只是告诉`div`元素内的其余内容围绕图像的右侧流动。即使我们在那个图像的位置放置了一个SVG对象，而这个对象是一个指向右侧的三角形形状的多边形，文本也会围绕该对象进行换行，将其视为矩形。
- en: However, with the magic of CSS exclusions, we can add properties to the image
    tag or the SVG object that would alter the way its outer shape is interpreted.
    By default, since any HTML element has an x and y position, along with a `width`
    and `height` attribute, every element is treated like a rectangle. Using the shape
    property changes that.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过CSS排除的魔力，我们可以向图像标签或SVG对象添加属性，以改变其外部形状的解释方式。默认情况下，由于任何HTML元素都有x和y位置，以及`width`和`height`属性，每个元素都被视为一个矩形。使用形状属性会改变这一点。
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: One thing that might be a bit tricky about CSS exclusions is that it simply
    defines a shape or path for the text to flow around and not necessarily a shape
    or path to be rendered. In other words, the two highlighted lines of code in the
    previous code example are completely independent. The only reason that the two
    polygon definitions resemble each other closely is for visual effects. If we had
    used an image, a `div`, or any other HTML element inside that block of text, the
    CSS `shape-outside` property would still cause the text to flow around that element
    the same way, no matter what physical shape that element has. Simply adding a
    CSS `shape` attribute to an element will not alter its own visual properties.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 关于CSS排除的一个棘手之处是它只是定义了文本流动的形状或路径，而不一定是要呈现的形状或路径。换句话说，前面代码示例中突出显示的两行代码是完全独立的。这两个多边形定义之所以如此相似，只是为了视觉效果。如果我们在文本块中使用了图像、`div`或任何其他HTML元素，CSS的`shape-outside`属性仍然会导致文本以相同的方式围绕该元素流动，无论该元素具有什么物理形状。仅仅添加CSS的`shape`属性到一个元素并不会改变它自己的视觉属性。
- en: 'Running the previous code example produces an output similar to the following
    screenshot. Again, remember that the relationship between the path that the text
    follows and the shape of the element displayed, where no text is allowed to enter,
    is purely coincidental and intentional. If instead of an SVG polygon we had an
    image element, the text would still follow that arrow shape, but the rectangular
    image would float on top of any text that followed a path intersecting the image''s
    boundaries. Strictly speaking, exclusions only deal with how text flows within
    a given block of text. Whether anything is rendered along the path that the text
    follows is up to the designer, and is a separate issue from exclusions, as shown
    in the following screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码示例会产生类似以下截图的输出。再次记住，文本遵循的路径与显示的元素形状之间的关系，即不允许文本进入的形状，纯粹是巧合和有意为之。如果我们不是一个SVG多边形，而是一个图像元素，文本仍然会遵循那个箭头形状，但是矩形图像会浮在遵循与图像边界相交路径的任何文本上方。严格来说，排除只涉及文本在给定文本块内的流动方式。文本沿着路径的任何东西是否被呈现，取决于设计师，这是排除之外的一个单独问题，如下图所示：
- en: '![Exclusions](img/6029OT_07_11.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![排除](img/6029OT_07_11.jpg)'
- en: If the ultimate goal is to simply define a path for text to follow, such as
    in the previous example, we don't need to use SVG, or any specific HTML element.
    Simply having an element present and assigning basic floating attributes to that
    element is enough for exclusions to work with. Remember, the only significant
    part of exclusions is the shape attribute.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最终目标只是简单地定义文本要遵循的路径，就像前面的例子一样，我们不需要使用SVG或任何特定的HTML元素。只要有一个元素存在，并为该元素分配基本的浮动属性，排除就足够工作了。记住，排除的唯一重要部分是形状属性。
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Alternatively, we can use the companion property to `shape-outside`, namely
    `shape-inside`. Intuitively, this property defines the opposite as its counterpart.
    Whereas a `shape-outside` property tells the browser where text needs to flow
    around (outside), a `shape-inside` property tells the browser the area where the
    text must stay within. All property values are the same for both attributes. The
    only difference between the two attributes is that in `shape-outside`, text is
    placed well outside of the placeholder element. With `shape-inside`, any text
    to be guided within the shape defined is placed as a descendant node of the shape
    element.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`shape-outside`的伴随属性，即`shape-inside`。直观地，这个属性定义了与其对应属性相反的作用。`shape-outside`属性告诉浏览器文本需要围绕（外部）的地方，而`shape-inside`属性告诉浏览器文本必须留在其中的区域。两个属性的所有属性值都是相同的。两个属性之间唯一的区别在于，在`shape-outside`中，文本被放置在占位元素的外部。而在`shape-inside`中，任何要在定义的形状内部引导的文本都被放置为形状元素的后代节点。
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In comparison with `shape-outside`, the `shape-inside` property contains its
    own contents within itself, as opposed to `shape-outside`, which is nothing but
    a block around which its sibling elements must flow, as shown in the following
    screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与`shape-outside`相比，`shape-inside`属性将其自身的内容包含在内部，而`shape-outside`则只是一个其兄弟元素必须围绕的块，如下图所示：
- en: '![Exclusions](img/6029OT_07_12.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![排除](img/6029OT_07_12.jpg)'
- en: Finally, in anticipation of the question that these two properties beg to be
    asked, yes, we could very well combine an exclusion that defines a `shape-outside`
    property, and one that defines a `shape-inside` property. Observe that a `shape-inside`
    exclusion is nothing more than a block level element, just like any other. Viewing
    the source code of an HTML file without any CSS instructions will make a `shape-inside`
    exclusion impossible to be told apart from an ordinary block of text. Thus, we
    could very well use a `shape-inside` excluded element as a `shape-outside` exclusion.
    The same element can have both CSS attributes, since their effect is mutually
    exclusive. Any text inside the element would be bound to the `shape-inside` exclusion
    declaration, whereas any content around the element would be associated with the
    effects of the `shape-outside` attribute.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了预料到这两个属性可能引发的问题，是的，我们很可能结合定义`shape-outside`属性的排除和定义`shape-inside`属性的排除。请注意，`shape-inside`排除只是一个块级元素，就像任何其他元素一样。在没有任何CSS指令的HTML文件的源代码中，`shape-inside`排除将无法与普通文本块区分开。因此，我们很可能将`shape-inside`排除的元素用作`shape-outside`排除。同一个元素可以具有两个CSS属性，因为它们的效果是互斥的。元素内的任何文本将与`shape-inside`排除声明绑定，而元素周围的任何内容将与`shape-outside`属性的效果相关联。
- en: '[PRE26]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Defining shapes
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义形状
- en: 'Conveniently, possible values for shape properties are the same as basic SVG
    shapes. The four available shapes are rectangle, ellipse, circle, and polygon.
    Point values can be represented as length values or percentage values. The syntax
    for each of these shapes is very consistent and is of the form `<shape>([value]{?})`.
    For example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，形状属性的可能值与基本SVG形状相同。四种可用的形状是矩形、椭圆、圆和多边形。点值可以表示为长度值或百分比值。每种形状的语法非常一致，形式为`<shape>([value]{?})`。例如：
- en: '`rectangle(x, y, width, height)`: Defines a sharp rectangle with the top left
    corner of the shape being positioned at point x, y'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rectangle(x, y, width, height)`: 定义一个尖锐的矩形，形状的左上角位于点x，y处'
- en: '`rectangle(x, y, width, height, round-x, round-y)`: Defines a rectangle with
    the option of rounding its corners'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rectangle(x, y, width, height, round-x, round-y)`: 定义一个矩形，并可以选择圆角'
- en: '`ellipse(x, y, radius-x, radius-y)`: Defines an ellipse centered at point x,
    y'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ellipse(x, y, radius-x, radius-y)`: 定义一个以点x，y为中心的椭圆'
- en: '`circle(x, y, radius)`: Defines a circle of a given radius, center at point
    x, y'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circle(x, y, radius)`: 定义一个给定半径的圆，以点x，y为中心'
- en: '`polygon(p1-x p1-y, p2-x p2-y, (…))`: Defines a polygon given three or more
    pairs of x, y positions'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polygon(p1-x p1-y, p2-x p2-y, (…))`: 给定三个或更多对x，y位置，定义一个多边形'
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter presented some of the more complex and cutting edge HTML5 APIs.
    The major highlight was the new 3D rendering and graphics programming API—WebGL.
    We also took a look at HTML5's new video playback capabilities as well as the
    ability to manipulate each frame of a video played natively on the browser. Finally,
    we got our feet wet with the latest and greatest CSS improvements and additions.
    This involved such APIs as CSS shaders, columns, and regions and exclusions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些更复杂和尖端的HTML5 API。主要亮点是新的3D渲染和图形编程API—WebGL。我们还研究了HTML5的新视频播放能力，以及在浏览器上本地播放视频的每一帧的操作能力。最后，我们涉足了最新和最伟大的CSS改进和增加。这涉及到CSS着色器、列和区域以及排除等API。
- en: In the next chapter, we conclude our journey into the fascinating world of HTML5
    game development by delving into mobile web development with HTML5\. We will learn
    what makes mobile game development different from the traditional desktop application
    development. We will also learn two HTML5 APIs to help us along the way. The game
    that we will build to illustrate these concepts is a 2D space shooter that is
    completely mobile-friendly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过深入研究使用HTML5进行移动网络开发来结束我们对HTML5游戏开发这个迷人世界的探索。我们将学习移动游戏开发与传统桌面应用程序开发的不同之处。我们还将学习两个HTML5
    API来帮助我们。我们将构建一个完全适合移动设备的2D太空射击游戏来说明这些概念。
