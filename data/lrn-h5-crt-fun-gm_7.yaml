- en: Chapter 7. HTML5 and Mobile Game Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 HTML5和移动游戏开发
- en: In this last chapter we will take a look at the ever so important concept of
    not only developing for multiple browsers and platforms, but also of developing
    an application with multiple devices in mind. It used to be that web development
    was all about supporting multiple browsers. Then it became all about taking advantage
    of the latest technologies available and creating applications that resembled
    a native desktop application. Today, we must not only remember those same concepts
    that allow us to make our applications available to as many people as possible,
    but we must also remember that the standard desktop computer is not the only machine
    accessing our web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下不仅要为多个浏览器和平台开发，还要考虑多个设备的应用程序开发的非常重要的概念。过去，网页开发主要是关于支持多个浏览器。然后，它变成了利用最新技术并创建类似本机台式应用程序的应用程序。今天，我们不仅要记住那些允许我们使我们的应用程序尽可能多地面向人们的概念，还要记住标准台式电脑不是唯一访问我们的网络应用程序的设备。
- en: While creating an HTML5-based game or application, we must be able to envision
    our users connecting through the desktop computer, net-books, HTML5-ready video
    game systems, smart phones, tables, television sets, and soon their smart watches,
    smart glasses, and possibly their smart toasters, fish tanks, and so on. Needless
    to say, there are quite a few differences between these devices, other than their
    size, shape, and suggested retail price.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建基于HTML5的游戏或应用程序时，我们必须能够设想我们的用户通过台式电脑、上网本、支持HTML5的视频游戏系统、智能手机、平板电脑、电视机，以及很快他们的智能手表、智能眼镜，可能还有智能烤面包机、鱼缸等等进行连接。不用说，除了它们的大小、形状和建议零售价格之外，这些设备之间有相当多的差异。
- en: As we develop the last game in this book, lets take a look at some of the most
    important concepts related to mobile game development with HTML5\. We'll first
    look at fundamental differences between a desktop machine and a mobile device
    (specifically, a smart phone and a tablet). The two HTML5-related APIs discussed
    in the chapter are media queries (which allows us to adjust CSS properties based
    on the current state of the device viewing the application) and JavaScript touch
    events, with their corresponding event handlers. Finally, we'll conclude the chapter
    with a discussion on how to go about developing and optimizing a game for a desktop
    browser as well as a mobile device, with a single code base.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发本书中的最后一个游戏时，让我们来看看与HTML5移动游戏开发相关的一些最重要的概念。我们首先将看一下台式机和移动设备（特别是智能手机和平板电脑）之间的基本差异。本章讨论的两个与HTML5相关的API是媒体查询（它允许我们根据查看应用程序的设备的当前状态来调整CSS属性）和JavaScript触摸事件，以及它们对应的事件处理程序。最后，我们将结束本章，讨论如何开发和优化一款游戏，使其适用于台式浏览器和移动设备，只需一个代码库。
- en: Desktop versus mobile
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 台式机与移动设备
- en: At first sight, the careless web developer might be led to believe that, because
    many of today's smart phones are in fact quite a lot smarter than most fifth graders,
    that their fancy web applications and games will run just fine on a mobile device.
    Do not be deceived! Although it is true that your smart phone is indeed smarter
    than you were when in fifth grade (in fact, most not-so-smart phones today have
    more computer power than the hardware that NASA used to take Neil A. Armstrong,
    Michael Collins, and Edwin E. Aldrin to the moon in 1969), it is in many instances
    no match to the average desktop computer from which most people surf the internet
    and play games online.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，粗心的网页开发者可能会误以为，因为如今许多智能手机实际上比大多数五年级学生聪明得多，他们的花哨网页应用和游戏在移动设备上会运行得很好。不要被欺骗！虽然你的智能手机确实比你五年级时聪明（事实上，今天大多数不那么聪明的手机的计算能力比NASA在1969年用来将尼尔·阿姆斯特朗、迈克尔·柯林斯和爱德温·艾尔德林送上月球的硬件还要强大），但在许多情况下，它并不是大多数人上网和在线游戏的平均台式电脑的对手。
- en: There are several significant differences between a desktop browser and a mobile
    browser. For this reason, we need to develop our applications with these differences
    in mind. After all, no matter how large the group of people only using the internet
    strictly from a mobile device or from a desktop browser, we have no reason to
    limit our reach to only one of those groups.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 台式浏览器和移动浏览器之间存在一些重大差异。因此，我们需要考虑这些差异来开发我们的应用程序。毕竟，无论只有多少人仅仅使用移动设备或台式浏览器上网，我们没有理由将我们的覆盖范围限制在其中的任何一个群体。
- en: One key aspect of mobile-friendly development that we must keep in mind, which
    doesn't always apply to games, is that one's mobile strategy is often inherently
    different from a desktop strategy for reasons beyond hardware limitations and
    differences. For example, use case on a mobile device is substantially different
    than the use case on a desktop version of a journal application. Since it is much
    harder and slower to type on a small device, users are less likely to spend hours
    typing a journal entry on a phone application as opposed to its desktop counterpart,
    where a full-sized keyboard is available. Thus, the entire mobile experience must
    be considered with a different persona in mind.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 移动友好开发的一个关键方面是，我们必须牢记的是，这并不总是适用于游戏，即一个人的移动策略通常在硬件限制和差异之外有固有的不同原因。例如，在移动设备上的使用情况与日记应用程序的台式机版本上的使用情况有很大不同。由于在小设备上打字更困难和慢，用户不太可能像在台式机上那样在手机应用程序上花几个小时输入日记条目，因为台式机上有全尺寸键盘可用。因此，整个移动体验必须考虑到不同的用户角色。
- en: Finally, because the human-computer interaction is different in a mobile device,
    the presentation of the application must be considered with these features in
    mind. For example, while navigating a website, most people would generously move
    the mouse cursor about the screen in an attempt to discover what can be clicked
    and what can be interacted with. Every time an action element is hovered, the
    mouse pointer changes (normally from an arrow icon to a pointing index finger)
    hinting to the user that an action can be initiated by clicking on such item.
    On a mobile device, however, no such thing exists. Thus, the design must take
    this into account, so that users aren't confused, intimidated, or worse yet, hesitant
    to use your game or application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于移动设备的人机交互方式不同，应用程序的呈现必须考虑到这些特点。例如，在浏览网站时，大多数人会慷慨地在屏幕上移动鼠标指针，试图发现可以点击和可以交互的内容。每当悬停在一个动作元素上时，鼠标指针会发生变化（通常从箭头图标变为指向手指），提示用户可以通过点击该项来启动操作。然而，在移动设备上，这样的操作并不存在。因此，设计必须考虑到这一点，以免用户感到困惑、害怕，甚至犹豫使用您的游戏或应用程序。
- en: The rest of this section will present a few major implementation considerations
    for your mobile strategy as well as a couple of current best practices. Both sections
    apply equally well to mobile games and mobile applications (non-gaming applications,
    that is). Albeit not extensive, this list of considerations and best practices
    should be sufficient to get you thinking in the right direction, and pointed towards
    a successful mobile campaign.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将介绍移动策略的一些主要实施考虑因素以及一些当前的最佳实践。这两个部分同样适用于移动游戏和移动应用程序（非游戏应用程序）。尽管不是很全面，但这些考虑因素和最佳实践清单应该足以让您朝着正确的方向思考，并指向一个成功的移动运营。
- en: Major implementation considerations
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要实施考虑因素
- en: Perhaps the most distinguishing feature that sets a mobile device apart from
    a desktop computer is the fact that the mobile device is always accessible. Once
    the user has left his or her house, the desktop machine is parked until possibly
    many hours later. The mobile device, on the other hand, can be as far away from
    the user as his or her pocket. So at any moment, the user can pull out the mobile
    device and start playing your game or using your application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最明显的区别是移动设备与台式电脑的区别在于移动设备始终可以访问。一旦用户离开家，台式机可能要停放很多小时。另一方面，移动设备可以离用户的口袋很远。因此，用户随时可以拿出移动设备开始玩游戏或使用应用程序。
- en: Very importantly, a continuation of this always accessible use case is that
    a user will play your game for a very small amount of time—while waiting for the
    elevator, while standing in line at the store, or while trying to drown out an
    awkward moment during a first date. Thus, your game must accommodate these brief,
    very brief, playing sessions and it must do so in a way that the player can still
    make progress in the game while playing it in sessions of 30 to 120 seconds at
    a time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，始终可以访问的使用情况是，用户将在非常短的时间内玩游戏——在等待电梯时，在商店排队时，或者在第一次约会时试图消磨尴尬时刻。因此，您的游戏必须适应这些短暂、非常短暂的游戏时间，并且必须以一种方式来做到，玩家在每次30到120秒的游戏时间内仍然可以取得进展。
- en: Some important considerations for your mobile game that are more related to
    the physical nature of mobile devices include its limited screen size, the possibility
    to change screen orientation effortlessly, limited computing power (relative to
    a desktop computer, of course), limited battery power, and browser differences
    (no, those haven't gone away yet on mobile devices, either).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与移动设备的物理特性更相关的您的移动游戏的一些重要考虑因素包括其有限的屏幕尺寸，轻松改变屏幕方向的可能性，有限的计算能力（相对于台式电脑），有限的电池电量和浏览器差异（是的，在移动设备上这些问题还没有消失）。
- en: Screen size and orientation
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕尺寸和方向
- en: The most obvious difference between a desktop computer and a mobile device is
    its size. Even though most modern devices can simulate large screen resolutions,
    the physical screen size is still rather limited. Not only that, but also at any
    moment the user can rotate the device sideways, expecting a responsive feedback
    of some sort from the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 台式电脑和移动设备之间最明显的区别是大小。尽管大多数现代设备可以模拟大屏幕分辨率，但物理屏幕尺寸仍然相当有限。而且，用户随时可以将设备旋转，期望应用程序能够做出响应。
- en: In web design in general, the standard solution to the problem of smaller and
    varying screen sizes is a technique called responsive design. The main tool used
    today to implement responsive design is the new CSS media query API (which we
    discuss later in the chapter). Simply put, this API allows us to load different
    stylesheets or sets of CSS rules based on, among other things, screen size, proportions,
    and orientation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页设计中，解决较小和不同屏幕尺寸问题的标准解决方案是一种称为响应式设计的技术。如今用于实现响应式设计的主要工具是新的CSS媒体查询API（我们稍后在本章中讨论）。简而言之，这个API允许我们根据屏幕尺寸、比例和方向等因素加载不同的样式表或一组CSS规则。
- en: For example, we can define a CSS stylesheet for the case when the screen is
    wider than it is taller (which, by definition, would make it a landscape viewport)
    and have a second style sheet designed for the case when the screen is taller
    than it is wider (making it a portrait view). Media queries would allow us to
    automatically and dynamically load one of these two stylesheets based on the current
    screen state. That is, if the user was to manually resize the browser window,
    the style sheet would trigger in real time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为屏幕宽度大于高度的情况定义一个CSS样式表（根据定义，这将使其成为横向视口），并设计第二个样式表，用于屏幕高度大于宽度的情况（使其成为纵向视图）。媒体查询将允许我们根据当前屏幕状态自动动态加载这两个样式表中的一个。也就是说，如果用户手动调整浏览器窗口大小，样式表将实时触发。
- en: As for screen orientation changes, DOM-based web applications have it easier,
    because the browser itself if able to rotate everything, so it faces the right
    direction. On a canvas-based application (either 2D canvas or WebGL), a screen
    rotation also rotates the browser's coordinate system, but not the canvas'. Thus,
    if you want a particular game to play horizontally on a landscape view, and vertically
    on a portrait view, you'll need to manage the rotation of the canvas' coordinate
    system by hand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 至于屏幕方向的变化，基于DOM的Web应用程序更容易，因为浏览器本身能够旋转一切，使其面向正确的方向。在基于画布的应用程序（无论是2D画布还是WebGL）中，屏幕旋转也会旋转浏览器的坐标系统，但不会旋转画布的坐标系统。因此，如果你希望特定游戏在横向视图上水平播放，在纵向视图上垂直播放，你需要手动管理画布的坐标系统的旋转。
- en: Most importantly, however, is the fact that when designing a mobile-friendly,
    or a mobile version of a game, the screen size will be significantly smaller.
    That means that fewer elements can be crammed into a particular view. Less information
    needs to be presented, since less information can be conveyed at once.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，当设计移动友好或游戏的移动版本时，屏幕尺寸将会显著较小。这意味着较少的元素可以塞进特定的视图中。需要呈现的信息较少，因为一次传达的信息较少。
- en: The two common solutions to this problem are to develop one application with
    two separate presentation layers (or two separate views or templates), only serving
    the view that's appropriate to the device requesting it (serving the mobile template
    when a template accesses the application and the full template when a desktop
    browser requests the application) and developing a single application with a single
    template, but making this template responsive, as described previously. The less
    popular alternative is to develop two separate applications altogether, where
    each application focuses on a given paradigm (mobile and desktop).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的两种常见方法是开发一个应用程序，具有两个单独的呈现层（或两个单独的视图或模板），只为请求它的设备提供适当的视图（当模板访问应用程序时提供移动模板，当桌面浏览器请求应用程序时提供完整模板），以及开发一个单一应用程序，具有单一模板，但使该模板具有响应性，如前所述。较不受欢迎的选择是完全开发两个单独的应用程序，其中每个应用程序专注于特定的范例（移动和桌面）。
- en: 'Normally, the mobile template is a shrunk down version of the full template
    where not all elements are necessarily displayed, as represented by the following
    illustration:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，移动模板是完整模板的缩小版本，其中并非一定显示所有元素，如下图所示：
- en: '![Screen size and orientation](img/6029OT_08_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕尺寸和方向](img/6029OT_08_01.jpg)'
- en: Computing power
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算能力
- en: As mentioned before, today's mobile devices have gotten quite powerful. Even
    more amazing is the fact that the tendency is for them to continue to improve,
    jamming more computing power into less physical space. However, the best smart
    phone today is no match against even an average power gaming PC. For most web
    applications, this difference can often be neglected but certainly not for more
    complex games.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，今天的移动设备变得非常强大。更令人惊讶的是，它们的趋势是继续改进，将更多的计算能力塞进更小的物理空间。然而，即使是今天最好的智能手机也无法与平均性能的游戏PC相媲美。对于大多数Web应用程序来说，这种差异通常可以忽略，但对于更复杂的游戏来说绝对不能忽略。
- en: One specific disadvantage that mobile devices have against desktop computers
    in this area is that the gap between the computing power of a lower-end mobile
    device and an average mobile device is quite large, as compared to a low-end desktop
    computer and a mere average one. Thus, when considering the capabilities of your
    game's users, remember that a large amount of those players will have very limited
    devices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备在这方面与桌面计算机相比具有一个特定的劣势，即低端移动设备和普通移动设备之间的计算能力差距相当大，而低端桌面计算机和普通桌面计算机之间的差距则较小。因此，在考虑游戏用户的能力时，请记住大多数玩家将拥有非常有限的设备。
- en: Battery life
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电池寿命
- en: Believe it or not, the most used feature of a smart phone is, well, to make
    and receive phone calls. With such an important function being the mobile device's
    primary use, it would be quite tragic to keep the device from performing such
    a task because a game uses up all of the device's battery power. For this reason,
    one very important characteristic of a mobile application (including games and
    mobile web applications) is how well it conserves power.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，智能手机最常用的功能是，嗯，打电话和接电话。由于这样一个重要的功能是移动设备的主要用途，如果因为一个游戏耗尽了设备的电量而无法执行这样的任务，那将是相当悲剧的。因此，移动应用程序（包括游戏和移动Web应用程序）的一个非常重要的特征是它如何节约电力。
- en: The more data the application needs to process, the more electricity it will
    require to do so. If the game spends much of its time performing complex calculations,
    it is likely to quickly drain the device's battery sooner than one would like
    it to. It is imperative that your mobile games use the least possible amount of
    power so that the player can enjoy the game as much as possible, while still saving
    enough battery power so that the device can serve its most fundamental purpose—to
    make phone calls.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要处理的数据越多，它所需的电力就越多。如果游戏大部分时间都在执行复杂的计算，它很可能会比人们希望的更快地耗尽设备的电量。你的移动游戏必须尽可能地节约电力，以便玩家能够尽可能地享受游戏，同时又能节省足够的电量，以便设备能够履行其最基本的任务——打电话。
- en: Browser differences
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器差异
- en: If you thought all your browser compatibility issues would go away once you
    started focusing your web development efforts on mobile devices, think again.
    Not only are there differences between the various mobile browsers themselves
    (just as there are differences on their desktop counterparts), but also not every
    HTML5 API and feature available on a given desktop browser is available on the
    same browser's mobile version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为一旦开始将网页开发工作重点放在移动设备上，所有浏览器兼容性问题都会消失，那就大错特错了。不仅各种移动浏览器之间存在差异（就像它们的桌面对应物上一样），而且并非每个HTML5
    API和功能在给定桌面浏览器上可用时也在同一浏览器的移动版本上可用。
- en: Some features are in fact available on a mobile browser, but the performance
    is still a very long way from being acceptable. One simple example that we will
    see in the game developed in this chapter is CSS animations. Depending on how
    creative you get with the animation, the mobile browser might have a very hard
    time handling the animation, while on a desktop browser the computations and rendering
    power needed to display the animation smoothly and consistently are quite trivial.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些功能实际上在移动浏览器上是可用的，但性能仍然远远不够好。一个简单的例子是我们将在本章开发的游戏中看到的CSS动画。根据动画的创意程度，移动浏览器可能很难处理动画，而在桌面浏览器上，显示动画所需的计算和渲染能力是相当微不足道的。
- en: In summary, when defining the concrete way in which your mobile application
    is to be implemented, keep in mind that some APIs and features will simply have
    to be thrown out, lest the application performs at unacceptable levels.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当定义移动应用程序的具体实现方式时，要记住一些API和功能必须被抛弃，否则应用程序的性能将无法接受。
- en: Best practices
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Now that you're ready to take the theory just discussed, where the rubber meets
    the road, let's discuss a few best practices on how to do just that. While a complete
    book could be dedicated to this topic, the following selection covers what I believe
    to be the top five most important best practices for mobile web development. Again,
    these concepts apply to generic web applications as well as games.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好将刚讨论的理论付诸实践，让我们讨论一下如何做到这一点的一些最佳实践。虽然可以专门撰写一本完整的书来讨论这个主题，但以下选择涵盖了我认为对移动Web开发最重要的五个最佳实践。同样，这些概念也适用于通用的Web应用程序以及游戏。
- en: Degrade gracefully and enhance progressively
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优雅降级和渐进增强
- en: Up to a couple of years ago, any discussion about adding new and cutting edge
    functionality to a web application was built around the topic of graceful degradation.
    More recently, that ideology has shifted more towards the other end of the spectrum,
    where the suggested way of building multiplatform and multidevice applications
    is with progressive enhancement.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 直到几年前，关于向Web应用程序添加新的尖端功能的讨论都是围绕着优雅降级的话题展开的。最近，这种思想已经更多地转向了另一端，即建议构建多平台和多设备应用程序的方式是采用渐进增强。
- en: In this context, graceful degradation refers to building the full-blown application
    first (the latest and greatest desktop browser), then scaling it down so that
    it works on a less capable browser as well as on mobile devices. Similarly, progressive
    enhancement refers to building the mobile version of the application first, then
    making it work on the desktop browser. Whichever approach is taken, the end result
    is the same—one application that functions equally well on both platforms.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，优雅降级是指首先构建完整的应用程序（最新和最先进的桌面浏览器），然后将其缩小，使其在性能较差的浏览器以及移动设备上运行。同样，渐进增强是指首先构建应用程序的移动版本，然后使其在桌面浏览器上运行。无论采取哪种方法，最终结果都是相同的——一个在两个平台上都能很好运行的应用程序。
- en: While much can be said about both of these approaches, in practice none is particularly
    better than the other. The only difference is simply where you start. Hopefully,
    the application is well planned for, so that each version is already envisioned
    before construction begins, so that starting at either end will take the application
    to the same place. Normally, however, the ideal approach to take depends largely
    on the type of project in question.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于这两种方法都可以说很多，但在实践中，没有一种特别比另一种更好。唯一的区别就是你从哪里开始。希望应用程序经过良好规划，以便在开始构建之前已经设想了每个版本，这样无论从哪一端开始，应用程序都会达到同样的地方。然而，通常情况下，采取的理想方法很大程度上取决于所涉及的项目类型。
- en: In the case of most games, as was indeed the case with the 2D space shooter
    game built for this chapter, it is much easier to develop the desktop version
    first then remove whatever functionality is not supported by, or appropriate for,
    mobile devices.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数游戏的情况下，正如在本章中为之构建的2D太空射击游戏中所发生的那样，首先开发桌面版本，然后删除移动设备不支持或不适用的功能会更容易一些。
- en: For example, the main rendering loop of our game is based on the new `requestAnimationFrame`
    function. Now, not all browsers expose this function yet, while others expose
    it through a different interface. Gracefully degrading this functionality would
    mean to use the function where available and use a fallback where it isn't available.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们游戏的主要渲染循环是基于新的`requestAnimationFrame`函数。现在，并非所有浏览器都暴露出这个函数，而其他浏览器则通过不同的接口暴露出来。优雅地降级这个功能意味着在可用的地方使用该函数，在不可用的地方使用备用方案。
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the other hand, a progressive enhancement approach would start out with the
    lowest common denominator first, not promising any special bells and whistles
    to anyone, but adding those in as permitted by the client technology.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，渐进增强的方法将首先从最低公共分母开始，不向任何人承诺任何特殊的功能，但在客户端技术允许的情况下添加这些功能。
- en: For example, suppose we want to make extensive use of CSS animations. Specifically,
    we wish to use a very large image for the background, then animate its position
    and size continually using keyframe animation. On a mobile device, this could
    consume a lot of processing power, causing severe performance problems. Thus,
    we decide not to use these animations in such cases.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要广泛使用CSS动画。具体来说，我们希望使用一个非常大的图像作为背景，然后使用关键帧动画不断地改变其位置和大小。在移动设备上，这可能会消耗大量的处理能力，导致严重的性能问题。因此，在这种情况下，我们决定不使用这些动画。
- en: Enhancing the application progressively in this case would mean that we start
    out with a static image for the background. The CSS file defining the animation
    and applying it to the application is not loaded by default.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，逐步增强应用程序意味着我们首先使用静态图像作为背景。默认情况下不加载定义动画并将其应用于应用程序的CSS文件。
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once that minimum functionality is in place, we can test the environment in
    order to determine if we should load the CSS file, injecting the more robust functionality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦最低功能得到满足，我们可以测试环境，以确定是否应该加载CSS文件，注入更强大的功能。
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, it wouldn't be particularly difficult to build the game with the animated
    background first, then remove it when a particular device was detected. There
    wouldn't necessarily be any added value taking this approach either.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先构建具有动画背景的游戏，然后在检测到特定设备时将其删除并不特别困难。采取这种方法也不一定会增加任何附加值。
- en: In summary, whatever approach makes more sense to your specific application
    and design goals and objectives, the key principle is to keep user experience
    in mind. Never present the user of your game or application with an unusable product
    or feature. Either downgrade the feature to something useful or upgrade it when
    you are sure that the user's environment can make proper use of the feature.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，无论哪种方法更符合你特定的应用程序和设计目标，关键原则是要考虑用户体验。永远不要向你的游戏或应用程序的用户呈现无法使用的产品或功能。要么将功能降级为有用的东西，要么在确定用户的环境可以正确使用该功能时将其升级。
- en: Finger-friendly design
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手指友好设计
- en: Another very important design consideration that is so easy to overlook is the
    size of the various elements. Although making text large enough is important,
    this is somewhat easier to get right. Plus, text size is fairly easy to adjust
    dynamically, so users can tweak things until they're comfortable with the exact
    size of the text in your application. However, coming from the point-and-click
    world, where action targets are big enough if the mouse pointer can fit on top
    of it, we may not realize that different people have vastly different finger sizes.
    Nothing can possibly be more frustrating to a big-fingered user, than to miss
    a click target because the target is too small. When the first touch-sensitive
    mobile applications came out several years ago, users probably considered carrying
    a finger sharpener along with their device, so that those tiny touch targets could
    be reached.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的设计考虑因素是各种元素的大小。尽管确保文本足够大很重要，但这相对容易做到。而且，文本大小相对容易动态调整，因此用户可以调整直到他们对应用程序中文本的确切大小感到舒适为止。然而，来自点按式世界的我们可能没有意识到不同的人有着截然不同的手指大小。对于手指较大的用户来说，没有什么比因为目标太小而错过点击目标更令人沮丧的了。几年前第一批触摸敏感的移动应用程序推出时，用户可能会考虑随身携带一个手指磨刀石，以便触及那些微小的触摸目标。
- en: In the following illustration, the screenshot on the left is an example of items
    that are too small for a user to touch, as well as items that are too close together.
    The better solution, as shown on the screenshot on the right, makes the interface
    more forgiving and harder for the user to mess up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的插图中，左侧的屏幕截图是用户无法触摸的项目的示例，以及太靠近在一起的项目。右侧的屏幕截图显示了更好的解决方案，使界面更容易操作，用户更难出错。
- en: '![Finger-friendly design](img/6029OT_08_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: 手指友好设计
- en: If you look at the developer guides published by the various mobile platform
    makers, you will find specific pixel dimensions that are suggested as the minimum
    size for widgets that can be touched as well as minimum distances between two
    or more touchable elements. While there is no perfect size of any particular widget,
    we must always design with this issue in mind.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看各种移动平台制造商发布的开发者指南，你会发现建议的小部件的最小像素尺寸以及两个或更多可触摸元素之间的最小距离。虽然没有任何特定小部件的完美尺寸，但我们必须始终以这个问题为考虑设计。
- en: Save battery life
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节省电池寿命
- en: No matter how amazing your mobile game might be, the minute that users realize
    that the game is rudely demanding on their device's battery, the game will immediately
    be frowned upon. If the user is running low on power, but they know that your
    game is very friendly with power consumption, your application will definitely
    get extra love.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的移动游戏有多么惊人，一旦用户意识到游戏对设备电池的需求过高，游戏就会立即受到指责。如果用户电量不足，但他们知道你的游戏对电量消耗非常友好，你的应用程序肯定会得到额外的喜爱。
- en: Now, the main source of energy inefficiencies in mobile apps is extensive, unnecessary
    hardware use. For example, if an application pulls the GPS multiple times per
    second, it will probably run down the battery fairly quickly. However, in an HTML5
    application, direct hardware access is not as readily available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，移动应用程序中能源效率的主要来源是过度、不必要的硬件使用。例如，如果一个应用程序每秒多次获取GPS，它可能会很快耗尽电池。然而，在HTML5应用程序中，直接硬件访问并不那么容易获得。
- en: In the case of a web application, the main way to save energy is to do as much
    caching as possible. The main point of caching here would be to avoid extra network
    activity. Not only would the extra processing require more energy, but it would
    also force the user to spend what is often limited bandwidth. As an added bonus,
    caching would also make your application behave much faster.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序的情况下，节省能源的主要方法是尽可能多地进行缓存。这里缓存的主要目的是避免额外的网络活动。额外的处理不仅需要更多的能量，而且还会迫使用户花费通常有限的带宽。作为额外的奖励，缓存还会使你的应用程序表现得更快。
- en: Plan for offline
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离线计划
- en: A very large amount of mobile gamers today have a limited amount of internet
    access from their mobile device. Any extra use of that precious data plan might
    be a costly deal for the user. As a result, many users actively disable internet
    access on their device. As a result of that, you should never make the assumption
    that your games will have continuous access to the internet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有很多移动游戏玩家在他们的移动设备上有限的互联网访问。任何额外使用宝贵的数据计划可能会对用户造成昂贵的损失。因此，许多用户会主动禁用设备上的互联网访问。因此，你不应该假设你的游戏会持续访问互联网。
- en: Again, the best solution to this use case is to use caching to your benefit.
    First, by making fewer server round trips, even if each batch is larger, you will
    be saving expensive bandwidth that the user is trying to save. Second, the application
    can seem much faster and more responsive if HTTP requests are saved up for a moment
    when the application is not doing anything meaningful (such as displaying a game-related
    message or waiting for the user to input information).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这种用例的最佳解决方案是利用缓存。首先，通过减少服务器往返次数，即使每个批次更大，也会节省用户试图节省的昂贵带宽。其次，如果HTTP请求被保存到应用程序没有做任何有意义的事情（比如显示游戏相关消息或等待用户输入信息）的时刻，应用程序看起来会更快速和更具响应性。
- en: Offering a desktop version
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供桌面版本
- en: There are many reasons why a user might want to checkout a mobile application's
    non-mobile version. Perhaps it is because of missing functionality, maybe the
    user has a good enough mobile device that can actually handle the full version
    just fine or maybe the user wants to access the full version from a mobile device
    just out of curiosity. Whatever the reason, adding a link to the full-sized version
    of your application is perhaps the easiest thing you can do, so why not do it
    for the minority of users who might actually use it!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因可能会导致用户想要查看移动应用的非移动版本。也许是因为缺少功能，也许是因为用户有一个足够好的移动设备可以很好地处理完整版本，或者可能是用户只是出于好奇想要从移动设备访问完整版本。无论原因是什么，添加一个指向应用程序完整版本的链接可能是你可以做的最简单的事情，那么为什么不为那些可能真正使用它的少数用户做呢！
- en: Understanding media queries
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解媒体查询
- en: Media queries have been around since HTML4 and CSS2\. Originally, the CSS media
    attribute was used to specify a different stylesheet to be loaded based on the
    media type loading the page, such as screen, TV, projection, or handheld. In HTML5,
    media queries also allow for expressions that check for other properties of the
    user agent viewing the document such as viewport width, height, resolution, and
    so on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询自HTML4和CSS2以来就存在。最初，CSS媒体属性用于根据加载页面的媒体类型（如屏幕、电视、投影或手持设备）指定要加载的不同样式表。在HTML5中，媒体查询还允许检查文档查看用户代理的其他属性，如视口宽度、高度、分辨率等。
- en: A **media query** is made up of two parts, namely a media type declaration and
    one or more expressions that evaluate to either true or false. Any CSS rules contained
    nested within the media query declaration are applied whenever any of the media
    query expressions evaluate to true. Alternatively, every CSS rule inside a stylesheet
    referenced by a link tag whose media attribute contains a **truthy** media query
    expression is applied to the specified media type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**媒体查询**由两部分组成，即媒体类型声明和一个或多个表达式，这些表达式评估为真或假。只要媒体查询表达式中的任何一个表达式评估为真，嵌套在媒体查询声明中的任何CSS规则都会被应用。或者，如果链接标签的媒体属性包含一个**真值**媒体查询表达式，那么被引用的样式表中的每个CSS规则都会应用到指定的媒体类型。'
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to the specification, a browser is expected to, but not required to,
    continue to evaluate the expressions in media queries and update the CSS rules
    as changes take place in the browser environment. In other words, if two media
    queries are specified in a page—one for a window with a width below a certain
    size and one with a width above that value—the browser is not required to load
    the corresponding style sheet if the user manually resizes the browser width without
    refreshing the page. However, since this isn't a very common use case, it should
    not be of much concern to web designers. Besides, most modern browsers do in fact
    re-evaluate media query expressions in real time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，浏览器预期会继续评估媒体查询中的表达式，并在浏览器环境发生变化时更新CSS规则，但不是必须的。换句话说，如果页面中指定了两个媒体查询——一个用于宽度小于某个值的窗口，另一个用于宽度大于该值的窗口——如果用户手动调整浏览器宽度而不刷新页面，浏览器不需要加载相应的样式表。然而，由于这不是一个非常常见的用例，这对网页设计师来说应该不是太大的问题。此外，大多数现代浏览器实际上会实时重新评估媒体查询表达式。
- en: 'There are nine media types that can be specified and targeted from a media
    query. Alternatively, the keyword `all` can be used to indicate all media types.
    The allowed media types in CSS media types are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从媒体查询中指定和定位的媒体类型有九种。或者，关键字`all`可以用来表示所有媒体类型。CSS媒体类型中允许的媒体类型如下：
- en: '`braille`: Used for braille tactile feedback devices'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`盲文`: 用于盲文触觉反馈设备'
- en: '`handheld`: Used for handheld devices'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`手持设备`: 用于手持设备'
- en: '`print`: Used for printers'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`打印`: 用于打印机'
- en: '`projection`: Used for projectors'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projection`: 用于投影仪'
- en: '`screen`: Used for computer screens'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`屏幕`: 用于计算机屏幕'
- en: '`tty`: Used for media using a fixed-pitch character grid'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tty`: 用于使用固定间距字符网格的媒体'
- en: '`tv`: Used for televisions'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电视`: 用于电视'
- en: '`embossed`: Used for paged braille printers'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`浮雕`: 用于分页盲文打印机'
- en: '`speech`: Used for speech synthesizers'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`语音`: 用于语音合成器'
- en: The two operators that can be used to connect two or more expressions are the
    logical `AND` and `OR` operators, indicated by the `and` keyword and a `comma`
    character respectively. Additionally, the logical `NOT` operator can be used to
    negate an expression. This operator is indicated by the `not` keyword.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于连接两个或多个表达式的两个运算符是逻辑`AND`和`OR`运算符，分别由`and`关键字和逗号字符表示。此外，逻辑`NOT`运算符可以用于否定一个表达式。这个运算符由`not`关键字表示。
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The 13 values that can be checked inside media query expressions are width,
    height, device-width, device-height, orientation, aspect-ratio, device-aspect-ratio,
    color, color-index, monochrome, resolution, scan, and grid. So long as the expression
    makes sense, any combination of these values can be used in an expression. This
    is when some basic Boolean logic comes in handy as well as a bit of common sense.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询表达式中可以检查的13个值是宽度、高度、设备宽度、设备高度、方向、宽高比、设备宽高比、颜色、颜色索引、单色、分辨率、扫描和网格。只要表达式有意义，这些值的任意组合都可以在表达式中使用。这时一些基本的布尔逻辑以及一点常识就会派上用场。
- en: 'Finally, the units that can be used along with each expression are the same
    as CSS units. We can use fixed units (such as pixels, centimeters, or inches)
    or relative units (such as percentages or ems). As a refresher, the following
    list describes the possible units used in CSS, and thus, in media query expressions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以与每个表达式一起使用的单位与CSS单位相同。我们可以使用固定单位（如像素、厘米或英寸）或相对单位（如百分比或em）。作为复习，以下列表描述了CSS中可能使用的单位，因此也适用于媒体查询表达式：
- en: '`%`: percentage'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`: 百分比'
- en: '`in`: inch'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`: 英寸'
- en: '`cm`: centimeter'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cm`: 厘米'
- en: '`mm`: millimeter'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mm`: 毫米'
- en: '`em`: em (1 em = height of current font size)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`em`: em（1 em = 当前字体大小的高度）'
- en: '`ex`: ex (1 ex = height of a font)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ex`: ex（1 ex = 字体的高度）'
- en: '`pt`: point (1 point = 1/72 inch)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pt`: 点（1 点 = 1/72 英寸）'
- en: '`pc`: pica (1 pica = 12 points)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pc`: 琴（1 琴 = 12 点）'
- en: '`px`: CSS pixels'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`px`: CSS像素'
- en: The rest of this section will contain a more detailed explanation of each of
    the valid values used in media queries, along with examples for each.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将包含对媒体查询中使用的每个有效值的更详细解释，以及每个值的示例。
- en: width
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宽度
- en: When queried against a continuous media type, the value refers to the total
    viewport (visible window area) width of the device, including any rendered scroll
    bars. When queried against a paged media type, the total width measured against
    is the width of the output page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当针对连续媒体类型进行查询时，该值指的是设备的总视口（可见窗口区域）宽度，包括任何渲染的滚动条。当针对分页媒体类型进行查询时，总宽度是针对输出页面的宽度。
- en: Optionally, the prefixes `min` and `max` can be used with the `width` keyword,
    allowing us to specify ranges, rather than discrete values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，前缀`min`和`max`可以与`width`关键字一起使用，允许我们指定范围，而不是离散值。
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding snipped specifies two media queries that apply to all media types.
    When the output width is less than 250 (exclusive), the background color is set
    to blue. Otherwise, the background color becomes red. As is the case with most
    modern browsers, we can resize the browser window manually and the new CSS rules
    will apply automatically. Otherwise, the properties are tested and set at the
    time the browser renders the page the first time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段指定了适用于所有媒体类型的两个媒体查询。当输出宽度小于250（不包括250）时，背景颜色设置为蓝色。否则，背景颜色变为红色。与大多数现代浏览器一样，我们可以手动调整浏览器窗口大小，新的CSS规则将自动应用。否则，属性将在浏览器首次渲染页面时进行测试和设置。
- en: In the following illustration, the window on the left is not quite wide enough
    to trigger the first media query on the previous snippet, which causes the second
    snippet to evaluate to true. By simply resizing the browser window (which can
    be done by maximizing the browser or possibly by simply turning the mobile device
    into landscape mode), the second media query will be invalidated and the first
    one will become enabled.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，左侧窗口的宽度不足以触发前面片段中的第一个媒体查询，导致第二个片段的评估结果为true。通过简单地调整浏览器窗口大小（可以通过最大化浏览器或可能通过将移动设备转为横向模式来完成），第二个媒体查询将被作废，第一个将被启用。
- en: '![width](img/6029OT_08_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![width](img/6029OT_08_03.jpg）'
- en: 'Note that the units used in the previous media query evaluation are CSS pixels.
    When setting special rules for media types where pixels don''t apply very easily,
    we can use other units such as `in` (inches) or `cm` (centimeters), as seen in
    the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面媒体查询评估中使用的单位是CSS像素。在为像素不太容易应用的媒体类型设置特殊规则时，我们可以使用其他单位，如`in`（英寸）或`cm`（厘米），如下例所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output of the previous code snippet can be seen in the following screenshot.
    Note that the minimum and maximum width in question is not necessarily the width
    of the page in which the printing takes place, but rather the width of the box
    formed by the paper width minus any margins set by the printer. In this case,
    a sheet of paper of 8.5 inches in width, minus a single inch from the left and
    right margins, makes an effective width of 6.5 inches in portrait mode. The landscape
    version of that same page, which is 11 inches wide, produces a box width of 9
    inches, which is wide enough to trigger the first media query.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的输出可以在以下截图中看到。请注意，问题中的最小宽度和最大宽度不一定是打印所在页面的宽度，而是纸张宽度减去打印机设置的任何边距所形成的盒子宽度。在这种情况下，宽度为8.5英寸的纸张，减去左右边距各一英寸，形成了6.5英寸的有效宽度。同一页面的横向版本宽度为11英寸，产生了9英寸的盒子宽度，足够宽以触发第一个媒体查询。
- en: The top print preview on the following screenshot represents a page being printed
    in portrait mode. That is, its width (in this case) is no more than 6.5 inches.
    The preview on the bottom is wider than 7.0 inches which causes a different media
    query to enable, thus changing the stylesheet settings for the page to be printed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图中的顶部打印预览表示以纵向模式打印的页面。也就是说，其宽度（在本例中）不超过6.5英寸。底部的预览宽度超过7.0英寸，导致启用了不同的媒体查询，从而改变了要打印页面的样式设置。
- en: '![width](img/6029OT_08_04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![width](img/6029OT_08_04.jpg)'
- en: height
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高度
- en: Similar to the `width` property, the `height` property refers to the viewport
    height of a continuous media type, including rendered scroll bars. For paged media
    types, this refers to the effective page box available to the output media. Needless
    to say, the value of a height property cannot be a negative unit. Again, just
    like the `width` property described previously, we can also add the modifier prefixes
    `min` and `max` to this property in order to specify ranges of values, rather
    than unit-perfect single values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与`width`属性类似，`height`属性指的是连续媒体类型的视口高度，包括渲染的滚动条。对于分页媒体类型，这指的是输出媒体可用的有效页面框。不用说，高度属性的值不能是负单位。与前面描述的`width`属性一样，我们还可以在此属性上添加修饰符前缀`min`和`max`，以便指定值的范围，而不是单位完美的单个值。
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: device-width
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备宽度
- en: Similar to the `width` property, the device-width refers to the entire physical
    window or page, regardless of the current browser window's width or available
    output width of a paged media.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与`width`属性类似，设备宽度指的是整个物理窗口或页面，而不管当前浏览器窗口的宽度或分页媒体的可用输出宽度如何。
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous code example, if the screen width (not browser width) is exactly
    1600px, the last media query will be active, regardless of any browser resizing.
    The same goes for a page—if the entire width of the page calculates to exactly
    1600px wide, the corresponding media query will match. Anything more or less than
    that and one of the other two media queries will be used instead. Again, the keywords
    `min` and `max` are valid modifiers that we can use in conjunction with this property.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，如果屏幕宽度（而不是浏览器宽度）恰好为1600px，最后一个媒体查询将激活，而不考虑任何浏览器调整大小。对于页面也是一样——如果整个页面的宽度计算恰好为1600px，相应的媒体查询将匹配。如果大于或小于该值，将使用其他两个媒体查询中的一个。同样，关键字`min`和`max`是我们可以与此属性结合使用的有效修饰符。
- en: 'The answer to the question about when to choose device-width or width and vice-versa
    is simple: whenever the design of your application calls for it. In most cases,
    the end result is the same. The only time when width is more appropriate than
    device-width is when the user might use their browser windowing in a customized
    size (not maximized) and the design is intended to reflow and auto adjust to the
    current width of the browser. On the other hand, if a design is meant to remain
    the same on a certain monitor width (or range of widths) regardless of the current
    browser state, then device width might be a more elegant and efficient way to
    go about it.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于何时选择设备宽度或宽度以及反之的问题的答案很简单：每当您的应用程序设计需要时。在大多数情况下，最终结果是相同的。唯一的情况是当宽度比设备宽度更合适的时候，那就是当用户可能使用自定义大小的浏览器窗口（而不是最大化），并且设计意图重新流动并自动调整到浏览器的当前宽度时。另一方面，如果设计意味着在特定监视器宽度（或一系列宽度）上保持不变，而不考虑当前浏览器状态，则设备宽度可能是更优雅和高效的方式。
- en: device-height
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备高度
- en: Finally, the last possibility with querying the rectangular sides of a display,
    device-height works exactly the same as device-width (other than the size measured).
    Although the same result can be achieved with the other viewport queries described
    so far, out of the four queries described so far, device-height might be the ideal
    candidate (along with device-width) to identify mobile orientation (portrait or
    landscape).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，查询显示器矩形边的最后一个可能性，设备高度与设备宽度完全相同（除了测量的尺寸）。虽然到目前为止描述的其他视口查询也可以实现相同的结果，但在到目前为止描述的四个查询中，设备高度可能是理想的选择（与设备宽度一起）来识别移动设备的方向（纵向或横向）。
- en: orientation
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方向
- en: Since media queries don't allow for comparison between two attributes (for example,
    if width is greater than or equal to height), orientation allows us to determine
    which way a media type is rotated. Had there been comparison operators included
    in the CSS media query engine, we could easily determine if a page was in landscape
    mode. To do that, we simply need to determine if the width is greater than the
    height. If the two sides are of the same length (a square viewport), the specification
    determines the media to be in portrait mode. However, since such an approach is
    not possible directly with media queries, we can instead use the much more intuitive
    orientation attribute.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于媒体查询不允许比较两个属性（例如，如果宽度大于或等于高度），方向允许我们确定媒体类型旋转的方式。如果CSS媒体查询引擎中包含比较运算符，我们可以轻松确定页面是否处于横向模式。为此，我们只需确定宽度是否大于高度。如果两边长度相同（视口为正方形），规范确定媒体处于纵向模式。然而，由于媒体查询不直接支持这种方法，我们可以使用更直观的方向属性。
- en: The two possible values for the attribute are, with little surprise, `portrait`
    and `landscape`. The prefixes `min` and `max` are not allowed with this query,
    since it doesn't make sense to classify something as being at least landscape
    or no more than portrait.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性的两个可能值是`纵向`和`横向`。前缀`min`和`max`在此查询中不允许，因为将某物分类为至少横向或最多纵向是没有意义的。
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous example, we check if the media is either landscape or portrait.
    Whatever the orientation evaluates, the media query becomes activated. Note that
    the third query attempts to set a third orientation based on erroneous conclusions.
    One might imagine that the way to determine if something is landscape or portrait
    is to take the ratio between the two—if the width is greater than the height then
    the media is in landscape mode, otherwise it is in portrait mode. You can imagine
    how someone might conclude that if both sides (width and height) are the same,
    that the orientation is neither landscape nor portrait. However, it is important
    to remember that a square figure is not landscape, but is indeed portrait. The
    key is to remember that there are only two possible values for this property,
    precisely because there are only two possible states that a media can be in at
    a time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们检查媒体是横向还是纵向。无论方向如何评估，媒体查询都会被激活。请注意，第三个查询试图基于错误的结论设置第三个方向。有人可能会想象，确定某物是横向还是纵向的方法是通过两者之间的比率来确定——如果宽度大于高度，则媒体处于横向模式，否则处于纵向模式。您可以想象有人可能会得出结论，如果两边（宽度和高度）相同，那么方向既不是横向也不是纵向。然而，重要的是要记住，正方形不是横向，而是纵向。关键是要记住，该属性只有两个可能的值，因为媒体一次只能处于两种可能的状态中的一种。
- en: aspect-ratio
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纵横比
- en: The aspect ratio property allows us to check for the proportion of the media's
    width relative to its height (in this order). This property takes into account
    the actual ratio between the `width` and `height` media query values, meaning
    that dynamic changes to the viewport width and height affect this property directly.
    The `min` and `max` keywords can be used in the evaluation of this property.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 纵横比属性允许我们检查媒体宽度相对于高度的比例（按照这个顺序）。该属性考虑了`宽度`和`高度`媒体查询值之间的实际比率，这意味着视口宽度和高度的动态变化会直接影响该属性。`min`和`max`关键字可以用于评估此属性。
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code snippet demonstrates various ways to calculate aspect ratio.
    Keep in mind that the value of this attribute must always read as a single fraction,
    with no floating point numbers involved. Simply said, the value must be in the
    form of an integer, followed by a slash, followed by a second integer. The first
    integer refers to the width value and the second to the height. Together, they
    form a ratio.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段演示了计算宽高比的各种方法。请记住，该属性的值必须始终读作一个分数，不涉及浮点数。简单地说，该值必须以整数形式表示，后跟斜杠，后跟第二个整数。第一个整数是宽度值，第二个是高度值。它们一起形成一个比例。
- en: The first media query in the previous example tests for a viewport that is exactly
    two width units for every one width unit. Put it another way, that expression
    checks for a viewport that is twice as high as it is tall or half as wide as it
    is wide. In contrast, the last media query attempts to generate the same result,
    but in reverse. The attempt there was to query a media type that was at most twice
    as wide as it is tall. This expression would raise a silent expression (the expression
    would be ignored), because the format is not appropriate. Instead of checking
    for 1/0.5, the proper way would be to make it 2/1, making the width length twice
    as large as the height.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例中的第一个媒体查询测试的是每个宽度单位正好两个宽度单位的视口。换句话说，该表达式检查的是一个高度是宽度的两倍或宽度的一半的视口。相比之下，最后一个媒体查询试图以相反的方式生成相同的结果。那里的尝试是查询一个最多是宽度的两倍的媒体类型。这个表达式会引发一个静默表达式（该表达式将被忽略），因为格式不合适。与其检查1/0.5，正确的方式是将其设为2/1，使宽度长度是高度的两倍。
- en: When specifying a desired value for a media query aspect-ratio expression, the
    number on the left refers to the width relative to the height, which is represented
    by the value on the right. Both numbers must be positive integers and the larger
    of the two values can be on either side. Alternatively, both values can be the
    same, which would test for a square aspect ratio (1/1).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定媒体查询宽高比表达式的期望值时，左边的数字表示宽度相对于高度，右边的数字表示高度。两个数字必须是正整数，较大的值可以在任一侧。或者，两个值可以相同，这将测试一个正方形宽高比（1/1）。
- en: '![aspect-ratio](img/6029OT_08_05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![宽高比](img/6029OT_08_05.jpg)'
- en: device-aspect-ratio
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备宽高比
- en: Checking for device-aspect-ratio works the exact same way as the aspect-ratio,
    as explained previously, with the only difference being that the `width` and `height`
    references are based on the device-width and device-height, as explained in their
    respective sections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 检查设备宽高比的方式与宽高比相同，如前所述，唯一的区别在于`width`和`height`的参考是基于设备宽度和设备高度的，如各自部分所述。
- en: Again, as with device-width and device-height, this is a great way to check
    for the underlying fingerprinting of the device accessing the application, which
    is independent of the current state of the browser window at the time the media
    query is tested. As far as responding to user actions, testing for aspect-ratio
    might be a better solution than device-aspect-ratio as the user might change the
    dimensions of the browser window independently of the device-screen-ratio. However,
    in order to determine the device's true aspect ratio, the alternative would be
    to use device-aspect-ratio.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与设备宽度和设备高度一样，这是一种检查设备访问应用程序的底层指纹的好方法，这与测试媒体查询时浏览器窗口的当前状态无关。就响应用户操作而言，测试宽高比可能比设备宽高比更好，因为用户可能会独立于设备屏幕比例改变浏览器窗口的尺寸。然而，为了确定设备的真实宽高比，另一种选择是使用设备宽高比。
- en: Also, keep in mind that it is quite possible to define redundant media queries
    when querying the aspect ratio. In a case such as this, as is the case with CSS,
    the last matching expression overrules previous duplicated expressions and values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请记住，在查询宽高比时很可能定义多余的媒体查询。在这种情况下，与CSS一样，最后匹配的表达式将覆盖先前重复的表达式和值。
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The previous code example shows six media query expressions, all of which evaluate
    to the same aspect ratio. Whether the original expressed ratio is a duplicate
    of a previous value or a different value that reduces to the same ratio, the end
    result is the same. When equal ratios are found and no other expression breaks
    the tie by further qualifying the whole expression, then the last occurrence of
    the duplicate expression becomes the only active query for values not unique to
    the previous expressions. For example, if two or more expressions evaluate to
    the same aspect ratio, whatever CSS attributes that both expressions had in common
    are given priority to the last occurrence of the query. Unique values between
    each expression get cascaded to the final evaluation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例显示了六个媒体查询表达式，所有这些表达式都评估为相同的宽高比。无论原始表达的比例是先前值的重复还是缩减为相同比例的不同值，最终结果都是相同的。当发现相等的比例并且没有其他表达式通过进一步限定整个表达式来打破平局时，那么重复表达式的最后一次出现就成为唯一激活的查询，用于不是先前表达式唯一的值。例如，如果两个或更多表达式评估为相同的宽高比，那么两个表达式共有的任何CSS属性都优先于查询的最后一次出现。每个表达式之间的唯一值被级联到最终评估中。
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous code snippet, three separate media queries evaluate to the same
    aspect ratio. The last query also uses a `min` modifier, meaning that it matches
    any aspect ratio that is not 1/1 (as well as any aspect ratio that is exactly
    1/1), but the device width is still larger than the height (in other words, any
    media types of aspect ratio 1/1 and any media types of orientation landscape).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，三个单独的媒体查询评估为相同的宽高比。最后一个查询还使用了`min`修饰符，这意味着它匹配任何不是1/1的宽高比（以及任何正好是1/1的宽高比），但设备宽度仍然大于高度（换句话说，任何宽高比为1/1和任何横向方向的媒体类型）。
- en: In this case, when a media type is `landscape` (remember a square or 1/1 aspect
    ratio is never considered landscape), only the third query matches the current
    state. Thus, only the color attribute is assigned to the `h1` tag specified in
    that media query. However, when the aspect ratio is in fact 1/1, then all three
    of media queries evaluate to true, thus all three queries are applied to the elements
    they specify.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当媒体类型为`landscape`（记住正方形或1/1宽高比从不被认为是横向的）时，只有第三个查询匹配当前状态。因此，只有颜色属性被分配给该媒体查询中指定的`h1`标签。然而，当宽高比实际上是1/1时，那么所有三个媒体查询都会评估为true，因此所有三个查询都会应用到它们指定的元素上。
- en: The first query only sets a color of the tag to green. The second query resets
    that tag color and additionally applies a few more attributes to the tag. Finally,
    the third query again resets the tag color, but doesn't touch any other property.
    The final result for these composite queries for a media type with a 1/1 aspect
    ratio can be seen in the following code snippet.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个查询只将标签的颜色设置为绿色。第二个查询重置该标签颜色，并另外应用一些属性到该标签。最后，第三个查询再次重置标签颜色，但不影响任何其他属性。这些复合查询对于1/1宽高比的媒体类型的最终结果可以在以下代码片段中看到。
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: color
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色
- en: This media query attribute checks for the number of bits per color component
    used by the output device. For example, if the output device uses an 8-bit color
    system, where it uses 2 bits to represent the red, green, blue, and alpha components,
    then the color attribute in the media query expression is 2\. The `min` and `max`
    modifiers can also be used to test for this as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此媒体查询属性检查输出设备使用的每个颜色分量的位数。例如，如果输出设备使用8位颜色系统，其中使用2位表示红色、绿色、蓝色和alpha分量，则媒体查询表达式中的颜色属性为2。`min`和`max`修饰符也可以用于测试这一点。
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the output device is not a color device then the value of the color attribute
    will be zero.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出设备不是彩色设备，则颜色属性的值将为零。
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In some instances, where the output device uses different bit counts per color
    component, the color attribute refers to the smallest value of bits per component.
    For example, if the output device uses an 8-bit color system and it uses 3 bits
    for the red component, 3 for the green component, and 2 for the blue component
    then the value used as the color attribute for the media query will be 2.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，输出设备使用不同的颜色分量位数，颜色属性指的是每个分量的最小位数值。例如，如果输出设备使用8位颜色系统，并且红色分量使用3位，绿色分量使用3位，蓝色分量使用2位，那么用作媒体查询颜色属性的值将是2。
- en: color-index
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色索引
- en: 'The `color-index` attribute returns the number of colors used by the output
    device. For example, a device with 256 colors would match the following media
    query exactly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`color-index`属性返回输出设备使用的颜色数。例如，具有256种颜色的设备将完全匹配以下媒体查询：'
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As with the color attribute, values specified for the color-index attribute
    cannot be negative. Also, if the output device does not use a color lookup table,
    the value for color-index is zero.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与颜色属性一样，颜色索引属性指定的值不能为负数。此外，如果输出设备不使用颜色查找表，则颜色索引的值为零。
- en: monochrome
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单色
- en: If an output device is monochrome, this media query attribute refers to the
    number of bits per pixel used by device. This is similar to color, but only applies
    to monochrome devices and, for obvious reasons, only for a single pixel, as opposed
    to the lowest color component.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出设备是单色的，此媒体查询属性指的是设备使用的每像素位数。这类似于颜色，但仅适用于单色设备，并且出于明显的原因，仅适用于单个像素，而不是最低的颜色分量。
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the device is not monochrome, this attribute will match a value of zero.
    Also, we can use the `min` and `max` modifier keyword to target ranges. Alternatively,
    a single Boolean expression can be used to determine whether the device is monochrome
    or not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备不是单色的，则此属性将匹配值为零。此外，我们可以使用`min`和`max`修饰符关键字来定位范围。或者，可以使用单个布尔表达式来确定设备是否为单色设备。
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: resolution
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分辨率
- en: Contrary to what one might be led to believe, the resolution attribute does
    not query the screen resolution as in the resolution we can set to our monitor
    through the operating system. Instead, the resolution attribute queries the pixel
    density (or dot density in the case of a printer) measured in dpi (dots per inch
    or pixels per inch) as well as dpcm (dots or pixels per centimeter).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与人们可能认为的相反，分辨率属性并不是查询屏幕分辨率，就像我们可以通过操作系统设置监视器的分辨率一样。相反，分辨率属性查询以 dpi（每英寸点数或每英寸像素）和
    dpcm（每厘米点数或像素）表示的像素密度（或打印机的点密度）。
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `min` and `max` modifiers are valid in this query expression. If the output
    device does not use square pixels, using `min-resolution` queries against the
    least dense dimension of the output device. When a `max-resolution` query is issued,
    the most dense dimension of the output device is used to evaluate the expression.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`min`和`max`修饰符在此查询表达式中有效。如果输出设备不使用方形像素，则使用`min-resolution`查询来针对输出设备的最不密集的维度。当发出`max-resolution`查询时，将使用输出设备的最密集维度来评估表达式。'
- en: scan
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描
- en: When rendering on a television, the scan attribute queries the scanning of the
    device. The only possible values are `progressive` and `interlace`. Using the
    `min` and `max` modifiers does not make sense in the context of a television's
    scan process and thus makes an invalid expressions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在电视上渲染时，扫描属性查询设备的扫描。可能的值只有`progressive`和`interlace`。在电视扫描过程的上下文中使用`min`和`max`修饰符是没有意义的，因此会导致无效表达式。
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: grid
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: A grid output device is one that is not a bitmap-based device. Querying the
    `grid` attribute returns true when the output device is not bitmap-based. The
    only possible values to query against are 1 and 0\. The `min` and `max` modifiers
    are not valid in this query.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 网格输出设备是指非基于位图的设备。查询`grid`属性在输出设备不是基于位图时返回true。可以查询的唯一可能值是1和0。`min`和`max`修饰符在此查询中无效。
- en: Examples of grid-based devices include any device that uses a character grid,
    such as those older calculators or even older model cell phones with fixed fonts.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网格的设备的示例包括使用字符网格的任何设备，例如那些旧计算器或甚至具有固定字体的旧型号手机。
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Understanding touch events
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解触摸事件
- en: Although similar in nature to an ordinary mouse click, a touch event allows
    us to interact with the computer primarily through a point and respond manner.
    However, touches are far more flexible than clicks and thus open up the stage
    for a whole new type of game.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与普通鼠标点击类似，触摸事件允许我们主要通过点和响应的方式与计算机进行交互。然而，触摸比点击更灵活，因此为全新类型的游戏打开了舞台。
- en: Fundamentally, a touch is different than a click in that more than one touch
    is possible on the same surface, at the same time. Also, a touch is generally
    different than a click in that it allows for a larger target area as well as varying
    pressure. I say generally because not all devices detect the touch area with high
    precision (or with any precision at all) or touch pressure. Similarly, some mouse
    or other equivalent input devices actually do offer pressure sensitivity, although
    most browsers don't have use of such a feature, neither do they expose that data
    through a click event object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，触摸与点击不同之处在于在同一表面上可以同时进行多次触摸。此外，触摸通常与点击不同，因为它允许更大的目标区域以及不同的压力。我说通常是因为并非所有设备都能高精度地检测触摸区域（或根本没有精度）或触摸压力。同样，一些鼠标或其他等效输入设备实际上确实提供了压力灵敏度，尽管大多数浏览器都没有使用这样的功能，也不会通过点击事件对象公开这些数据。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For compatibility purposes, most mobile browsers respond to touch events when
    JavaScript code expects a touch. In other words, a click handler can be triggered
    by the user touching the screen. In this case, a regular click event object is
    passed to the registered `callback` function and not a touch event object. Furthermore,
    the experience might differ between a drag event (the `dragMove` event) and a
    touch move event. Finally, multiple touches may or may not trigger simultaneous
    click event listeners.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 出于兼容性目的，大多数移动浏览器在JavaScript代码期望触摸时会响应触摸事件。换句话说，用户触摸屏幕可以触发点击处理程序。在这种情况下，常规点击事件对象被传递给注册的`callback`函数，而不是触摸事件对象。此外，拖动事件（`dragMove`事件）和触摸移动事件之间的体验可能会有所不同。最后，多个触摸可能会触发同时的点击事件监听器，也可能不会。
- en: There are three events related to touch, namely touch start, touch move, and
    touch end. Touch start and touch end can be related to the mouse down and mouse
    up events respectively, while a touch move event is similar to a drag move event.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个与触摸相关的事件，即触摸开始、触摸移动和触摸结束。触摸开始和触摸结束分别可以与鼠标按下和鼠标松开事件相关联，而触摸移动事件类似于拖动移动事件。
- en: touchstart
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: touchstart
- en: This event is triggered when the touch area detects a new touch, whether or
    not one or more touch events have already started and have not yet ended.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当触摸区域检测到新的触摸时，无论一个或多个触摸事件是否已经开始并且尚未结束，都会触发此事件。
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The object passed into the registered `callback` function is an instance of
    the `TouchEvent` class, which contains the following attributes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给注册的`callback`函数的对象是`TouchEvent`类的一个实例，其中包含以下属性：
- en: touches
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触摸
- en: An instance of the `TouchList` class which looks like an ordinary array and
    contains a list of all touches that have been touched down on the touch device
    and have not yet been removed, even if other active touches have moved about the
    screen or input device. Each element in this list is an instance of type `Touch`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`TouchList`类的一个实例，看起来像一个普通数组，包含了所有已经在触摸设备上触摸并且尚未被移除的触摸的列表，即使其他活动的触摸已经在屏幕或输入设备上移动。该列表中的每个元素都是`Touch`类型的实例。'
- en: changedTouches
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: changedTouches
- en: An instance of the `TouchList` class containing a list of touch objects representing
    all new touch points that have been introduced since the last touch event. For
    example, if two touch objects have already been detected (in other words, two
    fingers have been pressed against the touch device) and a third touch is detected,
    only this third touch is present in this touch list. Again, every touch-related
    element contained by this touch list is of type `Touch`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`TouchList`类的一个实例，包含了自上一个触摸事件以来引入的所有新触摸点的触摸对象列表。例如，如果已经检测到两个触摸对象（换句话说，两个手指已经按在触摸设备上），并且检测到第三个触摸，那么只有这第三个触摸存在于这个触摸列表中。同样，该触摸列表中包含的每个与触摸相关的元素都是`Touch`类型的。'
- en: targetTouches
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: targetTouches
- en: An instance of the `TouchList` class containing a list of touch objects representing
    all touch points that have been captured by a given DOM node. For example, if
    multiple touches have been detected throughout the screen but a particular element
    registered for a touch start event and captured this event (either from the capture
    or bubble stage), only touch events captured by this node will be present in this
    touch list. Again, every touch-related element contained by this touch list is
    of type `Touch`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`TouchList`类的一个实例，包含了代表已被给定DOM节点捕获的所有触摸点的触摸对象列表。例如，如果在整个屏幕上检测到了多个触摸，但是特定元素注册了触摸开始事件并捕获了此事件（无论是从捕获还是冒泡阶段），那么只有该节点捕获的触摸事件会出现在这个触摸列表中。同样，该触摸列表中包含的每个与触摸相关的元素都是`Touch`类型的。'
- en: touchend
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: touchend
- en: Similar to a mouse up event, a `touchend` event is fired when any of the registered
    touch events leave the input touch device.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于鼠标松开事件，当任何已注册的触摸事件离开输入触摸设备时，会触发`touchend`事件。
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just like a `touchstart` event, the object passed into the registered `callback`
    function is an instance of the `TouchEvent` class, which contains the same three
    `TouchList` attributes. The context of the `touches` and `targetTouches` attributes
    are the exact same as their version found in `touchstart`. However, the `changedTouches`
    touch list has a slightly different meaning in this event.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`touchstart`事件一样，传递给注册的`callback`函数的对象是`TouchEvent`类的一个实例，其中包含相同的三个`TouchList`属性。`touches`和`targetTouches`属性的上下文与它们在`touchstart`中的版本完全相同。然而，在此事件中，`changedTouches`触摸列表的含义略有不同。
- en: Although the `TouchList` object inside a `touchend` event is the exact same
    as the one in `touchstart`, the list of touch objects contained here represents
    touches that have left the touch input device.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`touchend`事件中的`TouchList`对象与`touchstart`中的完全相同，但这里包含的触摸对象列表代表已离开触摸输入设备的触摸。
- en: touchmove
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: touchmove
- en: The `touchmove` event, analogous to a `drag` event, is fired whenever at least
    one of the registered touch objects changes position without triggering a `touchend`
    event. As we'll soon see each touch object is uniquely tracked so that it is possible
    to determine if any of the registered touch objects have moved and which ones
    have actually displaced.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`touchmove`事件类似于`drag`事件，当至少一个注册的触摸对象改变位置而不触发`touchend`事件时触发。正如我们将很快看到的，每个触摸对象都是唯一跟踪的，因此可以确定是否有任何已注册的触摸对象移动，以及哪些实际上已经移动。'
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, just like a `touchend` event, the object passed into the registered `callback`
    function is an instance of the `TouchEvent` class, which contains the same three
    `TouchList` attributes. The context of the `touches` and `targetTouches` attributes
    are the exact same as their version found in `touchstart`. The touch objects in
    the `changedTouches` list in the `touchmove` event represent previously registered
    touches that have moved about the input device.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与`touchend`事件一样，传递到注册的`callback`函数中的对象是`TouchEvent`类的实例，其中包含相同的三个`TouchList`属性。`touches`和`targetTouches`属性的上下文与它们在`touchstart`中的版本完全相同。`touchmove`事件中`changedTouches`列表中的触摸对象代表先前注册的触摸在输入设备上移动的情况。
- en: One important thing about the `touchmove` event is that it can be associated
    with a `drag` event. If you notice, the default behavior for a `drag` event is
    to scroll the page in the direction of the scroll. In some applications involving
    dragging across the screen with a finger, this behavior may not be desired. For
    this reason, the `event.preventDefault()` method is called, which produces the
    effect of alerting the browser that no scrolling is desired. If, however, the
    intention is to scroll the screen with a `touchmove` event, provided that the
    element being touched supports such behavior, this can be accomplished by omitting
    the call to the prevent default function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`touchmove`事件的一个重要事项是它可以与`drag`事件相关联。如果注意到，默认情况下`drag`事件的行为是沿滚动方向滚动页面。在一些涉及用手指在屏幕上拖动的应用程序中，可能不希望出现这种行为。因此，调用`event.preventDefault()`方法，产生的效果是告诉浏览器不需要滚动。然而，如果意图是使用`touchmove`事件滚动屏幕，只要被触摸的元素支持这种行为，可以通过省略调用prevent
    default函数来实现这一点。
- en: The touch object
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸对象
- en: Now, you may have noticed that each `TouchList` object holds instances of a
    very specific object which is an instance of the `Touch` class. This is important
    because the input device needs to keep track of individual touches. Otherwise,
    the list of `changedTouches` would not be accurate thus limiting what we can accomplish
    with the API.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能已经注意到，每个`TouchList`对象都包含一个非常特定的对象的实例，这是`Touch`类的一个实例。这很重要，因为输入设备需要跟踪单独的触摸。否则，`changedTouches`列表将不准确，从而限制我们可以通过API实现的功能。
- en: The way that each touch can be uniquely identified is by having the input device
    assign a unique ID to each event it captures. This ID remains the same for the
    same touch object until that object is released (in other words, when that particular
    touch leaves the input device).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个触摸可以通过输入设备分配一个唯一的ID来唯一标识。这个ID对于相同的触摸对象保持不变，直到该对象被释放（换句话说，当该特定触摸离开输入设备时）。
- en: Lets take a look at all the other properties of the `Touch` class and see what
    other important information is contained therein.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Touch`类的所有其他属性，并了解其中包含的其他重要信息。
- en: identifier
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标识符
- en: A unique integer identifier for a particular touch event contained in the current
    touches `TouchList`. This number remains the same until a touch event leaves the
    input device, which allows us to track each touch individually even if many other
    touch objects are starting, moving, and ending while the one particular touch
    object can be singled out and kept appropriately.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当前触摸`TouchList`中包含的特定触摸事件的唯一整数标识符。这个数字保持不变，直到触摸事件离开输入设备，这样我们可以跟踪每个触摸，即使在一个特定的触摸对象开始、移动和结束时，其他许多触摸对象也可以被单独找出并适当地保持。
- en: Note that sometimes the value of this attribute may match the array index value
    of the touch object within a `TouchList` object. Sometimes the identifier property
    might even match the order in which each touch was detected by the input device.
    As an attentive programmer, you must never assume that these two values will always
    be the same.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有时此属性的值可能与`TouchList`对象中的触摸对象的数组索引值匹配。有时标识符属性甚至可能与输入设备检测到每次触摸的顺序匹配。作为一个细心的程序员，你绝不能假设这两个值总是相同的。
- en: For example, suppose that the first time a touch is detected by the device it
    has an identifier ID of zero (and since this is the first touch in the **TouchList**,
    it will obviously be indexed into the list with an index value of zero). Now a
    second touch is detected, making it the second object in the **TouchList** array,
    which would give it an index key of one. Suppose this touch also receives an identifier
    of one so that all three values match (touch order, array order, and identifier
    value). Now, after moving these two touches around the input device, suppose the
    first touch object is released and a new touch event is detected. Now there are
    again two touch objects in the **TouchList**, but their values are completely
    different than the first two touch elements. While the second touch event still
    has the same identifier (in this example, the identifier was one), it's now (possibly)
    the first element in the **TouchList**.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设设备第一次检测到触摸时具有标识符ID为零（由于这是** TouchList **中的第一个触摸，它显然将被索引为零）。现在检测到第二次触摸，使其成为**
    TouchList **数组中的第二个对象，这将使其索引键为一。假设这个触摸也收到标识符为一，以便所有三个值匹配（触摸顺序，数组顺序和标识符值）。现在，在移动这两个触摸设备后，假设释放第一个触摸对象并检测到新的触摸事件。现在**
    TouchList **中再次有两个触摸对象，但它们的值与前两个触摸元素完全不同。虽然第二次触摸事件仍具有相同的标识符（在这个例子中，标识符为一），但它现在（可能）是**
    TouchList **中的第一个元素。
- en: Although at times the order in which a touch is detected, the touch's position
    in the **TouchList** array, and the touch's unique identifier number may all match
    (assuming that the input device even assigns specific identifier values), you
    should never use any of these assumptions to track individual touches. A touch
    should always be tracked by its unique identifier attribute when more than one
    touch is being tracked. If only a single touch is tracked, that touch will always
    be the first element in the `TouchList` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有时检测到触摸的顺序，触摸在** TouchList **数组中的位置和触摸的唯一标识号可能都匹配（假设输入设备甚至分配特定的标识符值），但您永远不应该使用这些假设来跟踪单个触摸。当跟踪多个触摸时，应始终通过其唯一标识符属性来跟踪触摸。如果只跟踪单个触摸，该触摸将始终是`TouchList`对象中的第一个元素。
- en: '![identifier](img/6029OT_08_06.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![identifier](img/6029OT_08_06.jpg)'
- en: In summary, the order in which touches are detected and assigned to the `TouchList`
    object is unpredictable and should never be assumed. The proper way to track individual
    touch objects is through the identifier property assigned to each object. Once
    a touch event is released, the value of its former identifier property can be
    reassigned to a consequent touch, so be sure to keep that in mind as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，检测触摸并将其分配给`TouchList`对象的顺序是不可预测的，永远不应该假设。跟踪单个触摸对象的正确方法是通过分配给每个对象的标识符属性。一旦触摸事件被释放，其先前的标识符属性的值可以重新分配给后续的触摸，因此请务必记住这一点。
- en: screenX
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: screenX
- en: The `screenX` coordinate refers to the point in the browser viewport that was
    touched relative to the origin of the system display. The origin of the browser's
    viewport is not taken into account in this calculation at all. Point (0, 0) is
    the upper left corner of the monitor, and however many pixels to the right of
    it is touched, that's where this attribute will refer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`screenX`坐标是指相对于系统显示器原点触摸的浏览器视口中的点。浏览器视口的原点在这个计算中根本没有考虑。点（0，0）是显示器的左上角，无论向右移动多少像素，该属性都将引用该点的位置。'
- en: screenY
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: screenY
- en: The `screenY` coordinate refers to the point down from the system's screen (monitor),
    independent of where the browser is relative to that. If the screen is, say, 800
    pixels in height and the browser is set up with a height of, say, 100 pixels located
    exactly 100 pixels below the top of the screen, then at touch a the half-way point
    between the browser's viewport's top and bottom left corners would result in the
    touch's `screenY` coordinate being 150.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`screenY`坐标是指从系统屏幕（显示器）向下的点，与浏览器相对位置无关。如果屏幕高度为800像素，浏览器设置为高度为100像素，位于屏幕顶部正下方100像素处，那么在触摸浏览器视口顶部和底部左上角之间的中点将导致触摸的`screenY`坐标为150。'
- en: Think about it, the browser's viewport has 100 pixels in height so that it's
    midpoint is exactly 50 pixels below its origin. If the browser is exactly 100
    pixels below the screen's origin, that midpoint is 150 pixels below the screen's
    vertical origin.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看，浏览器的视口高度为100像素，因此其中点恰好在其原点下方50像素。如果浏览器恰好在屏幕原点下方100像素，那么该中点就在屏幕垂直原点下方150像素。
- en: The `screenX` and `screenY` attributes almost look like they don't take the
    browser's coordinate system into account whatsoever. With that, since the origin
    the browser bases its calculations off of its screen's origin, then it follows
    that a point returned by `screenX` and `screenY` will never be less than zero,
    since there is no way we can touch a point outside the screen's surface area and
    still have the screen detect that point.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`screenX`和`screenY`属性几乎看起来根本不考虑浏览器的坐标系统。因此，由于浏览器基于其屏幕的原点进行计算，因此`screenX`和`screenY`返回的点永远不会小于零，因为我们无法触摸屏幕范围之外的点，而屏幕仍然能够检测到该点。'
- en: clientX
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: clientX
- en: Similar to `screenX`, `clientX` coordinate refers to the offset from a touch
    location from the browser's viewport's origin, independent of any scrolling within
    the page. In other words, since the origin of the browser's viewport is its upper
    left corner, a touch 100 pixels to the right of that point corresponds to a `clientX`
    value of 100\. Now, if the user scrolls that page, say, 500 pixels to the right,
    then a touch to the right of the browser's left border by 100 pixels would still
    result in a `clientX` value of 100, even though the touch occurred at point 600
    within the page.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`screenX`类似于`clientX`坐标，指的是触摸位置距离浏览器视口原点的偏移量，与页面内的任何滚动无关。换句话说，由于浏览器视口的原点是其左上角，距离该点右侧100像素的触摸对应于`clientX`值为100。现在，如果用户将页面向右滚动了500像素，那么在浏览器左边框右侧100像素处的触摸仍将导致`clientX`值为100，即使触摸发生在页面内的第600个点。'
- en: clientY
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: clientY
- en: The `clientY` coordinate refers to the point down from the browser's viewport
    origin, independent of where within the page the touch occurred. If the page scrolls
    an arbitrary amount of pixels to the right and to the bottom and a touch is detected
    at the very first pixel to the right of the upper left corner of the browser's
    viewport and exactly one pixel down, the `clientY` value would be calculated as
    1.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`clientY`坐标指的是距离浏览器视口原点向下的位置，与触摸发生在页面内的具体位置无关。如果页面向右和向下滚动了任意数量的像素，并且在浏览器视口的左上角右侧的第一个像素处检测到触摸，并且向下正好一个像素，那么`clientY`值将被计算为1。'
- en: The `clientX` and `clientY` attributes don't take the web page's coordinate
    system into account whatsoever. With that, because this point is calculated relative
    to the browser's frame, it follows that a point returned by `clientX` and `clientY`
    will never be less than zero since there is no way we can touch a point outside
    the browser's viewport surface area and still have the browser detect that point.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`clientX`和`clientY`属性根本不考虑网页的坐标系。因此，由于这一点是相对于浏览器框架计算的，因此`clientX`和`clientY`返回的点永远不会小于零，因为我们无法触摸到浏览器视口外的点，而浏览器仍然能够检测到该点。'
- en: pageX
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pageX
- en: Finally, the coordinate represented by `pageX` refers to the point within the
    actual page where the touch was detected. In other words, if a browser is only,
    say, 500 pixels wide but the application is 3000 pixels wide (meaning that we
    can scroll the application's content to the right by 2500 pixels), a touch detected
    exactly 2000 pixels from the browser's viewport's origin would result in a `pageX`
    value of 2000.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`pageX`表示的坐标指的是触摸被检测到的实际页面内的位置。换句话说，如果浏览器只有500像素宽，但应用程序有3000像素宽（这意味着我们可以将应用程序的内容向右滚动2500像素），那么在距离浏览器视口原点2000像素的地方检测到的触摸将导致`pageX`值为2000。
- en: In the world of gaming, a better name for `pageX` would probably be `worldCoordinateX`
    since the touch takes into account where within the world the touch event took
    place. Of course, this only works when the web page physically scrolls, not when
    a representation of a scroll has taken place. For example, say we render a world
    onto a 2D canvas and the world is actually much larger than the width and height
    of the canvas element. If we scroll the virtual map by an arbitrary amount of
    pixels but the canvas element itself never actually moved, then the `pageX` value
    will be meaningless with respect to the game's map's offset.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏世界中，`pageX`的更好名称可能是`worldCoordinateX`，因为触摸事件发生的世界位置会被考虑在内。当网页实际滚动时，这才有效，而不是当滚动的表示已经发生时。例如，假设我们将一个世界渲染到一个2D画布上，而世界实际上比画布元素的宽度和高度要大得多。如果我们以任意数量的像素滚动虚拟地图，但是画布元素本身实际上并没有移动，那么`pageX`值将与游戏地图的偏移量无关。
- en: pageY
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pageY
- en: And to conclude, the `pageY` coordinate refers to the point where the touch
    was detected below the browser's viewport's origin, plus any scrolled offsets.
    As with the other touch point locations, it is impossible to obtain a negative
    value for the `pageX` and `pageY` attributes since there is no way to touch a
    point in the page that has not been scrolled to yet, especially a point behind
    the origin of the page where we cannot ever scroll to.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`pageY`坐标指的是触摸被检测到的位置在浏览器视口原点下方的点，再加上任何滚动偏移量。与其他触摸点位置一样，`pageX`和`pageY`属性不可能获得负值，因为我们无法触摸到尚未滚动到的页面上的点，尤其是页面原点后面的点，我们永远无法滚动到那里。
- en: The following illustration shows the difference between screen, client, and
    page location. The screen location refers to the location within the screen (not
    browser window), with the origin being the upper left corner of the display. Client
    location is similar to screen location, but places the origin at the top left
    corner of the browser viewport. Even if the browser is resized and moved half
    way across the screen, the first pixel to the right of the browser viewport will
    be point (0, 0). Page location is similar to client location but takes into account
    any scrolling within the browser viewport. If the page is scrolled down 100 pixels
    vertically and none horizontally, the first pixel to the right of the left margin
    of the browser viewport will be (100, 1).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了屏幕、客户端和页面位置之间的差异。屏幕位置指的是屏幕内的位置（而不是浏览器窗口），原点是显示器的左上角。客户端位置类似于屏幕位置，但将原点放在浏览器视口的左上角。即使浏览器被调整大小并移动到屏幕的一半，浏览器视口右侧的第一个像素仍将是点（0,
    0）。页面位置类似于客户端位置，但考虑了浏览器视口内的任何滚动。如果页面垂直滚动了100像素，水平没有滚动，那么浏览器视口左边距右侧的第一个像素将是（100,
    1）。
- en: '![pageY](img/6029OT_08_08.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![pageY](img/6029OT_08_08.jpg)'
- en: radiusX
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: radiusX
- en: When a touch is detected by the input device, an ellipse is drawn around the
    touch area by the input device. The radius of that ellipse can be accessed through
    the `radiusX` and `radiusY` attributes, hinting at how much area is covered by
    the touch. Keep in mind that the accuracy of the ellipse that describes the area
    touched is determined by the device used, so mileage may vary greatly here.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入设备检测到触摸时，输入设备会在触摸区域周围绘制一个椭圆。可以通过`radiusX`和`radiusY`属性访问该椭圆的半径，暗示了触摸覆盖的面积。请记住，描述触摸区域的椭圆的准确性取决于所使用的设备，因此在这里可能会有很大的差异。
- en: radiusY
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: radiusY
- en: In order to get the radius across the horizontal axis of the ellipse formed
    by the touch detected by the input device, we can use the `radiusY` attribute.
    With that information, we can add an extra depth to the types of applications
    we can create using touch as input.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得输入设备检测到的触摸形成的椭圆在水平轴上的半径，我们可以使用`radiusY`属性。有了这些信息，我们可以为使用触摸作为输入的应用程序增加额外的深度。
- en: As an example application, the following code snippet detects as many touches
    as the input device can handle simultaneously, keeping track of the radius of
    each touch, then displaying each touch at its approximate size.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例应用程序，以下代码片段检测输入设备可以同时处理的触摸数量，跟踪每个触摸的半径，然后显示每个触摸的大致大小。
- en: First, we need to set up the document viewport to be the same width and height
    as the device as well as set initial zoom levels. We also want to disable pinching
    gestures, because in this particular sample application, we want that gesture
    to act as any other touch movement and not have any special meaning.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置文档视口与设备的宽度和高度相同，并设置初始缩放级别。我们还希望禁用捏合手势，因为在这个特定的示例应用程序中，我们希望该手势像其他触摸移动一样，没有任何特殊含义。
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The meta viewport tag allows us to define specific width and height values for
    the viewport, or use the optional device-width and device-height attributes. If
    only a width or height value is specified, the other is inferred by the user agent.
    The tag also allows us to specify a default zoom level as well as disable zooming
    through gestures or other means.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: meta视口标签允许我们为视口定义特定的宽度和高度值，或者使用可选的device-width和device-height属性。如果只指定了宽度或高度值，则用户代理会推断另一个值。该标签还允许我们指定默认的缩放级别，以及通过手势或其他方式禁用缩放。
- en: Next, we need to make sure the root DOM node in the application stretches the
    entire width and height of the display so that we can capture all touch events
    within it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保应用程序中的根DOM节点能够延伸到整个显示屏的宽度和高度，以便我们可以在其中捕获所有的触摸事件。
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We set the `body` tag to be as wide as the viewport and remove any margin and
    padding from it so that touches near the edge of the screen would not be missed
    by the element's event handling. We also style the `div` elements to look round,
    have a red background color, and be absolutely positioned so that we can place
    one anywhere a touch is detected. We could have used a canvas element instead
    of rendering multiple `div` tags to represent each touch but that is an insignificant
    detail for this demo.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`body`标签设置为与视口一样宽，并从中删除任何边距和填充，以便屏幕边缘附近的触摸不会被元素的事件处理所忽略。我们还将`div`元素样式设置为圆形，具有红色背景颜色，并且绝对定位，以便我们可以在检测到触摸的任何位置放置一个。我们可以使用画布元素而不是渲染多个`div`标签来表示每个触摸，但对于这个演示来说，这是一个微不足道的细节。
- en: Finally, we get down to the JavaScript logic of the application. To summarize
    the structure of this demonstration, we simply use a global array where each touch
    is stored. Whenever any touch event is detected on the document, we flush that
    global array that keeps track of each touch, create a `div` element for each active
    touch, and push that new node to the global array. At the same time as this is
    happening, we use a request animation frame look to continuously render all the
    DOM nodes contained in the global touches array.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到应用程序的JavaScript逻辑。为了总结这个演示的结构，我们简单地使用一个全局数组来存储每个触摸。每当文档上检测到任何触摸事件时，我们都会清空跟踪每个触摸的全局数组，为每个活动触摸创建一个`div`元素，并将新节点推送到全局数组中。与此同时，我们使用请求动画帧来持续渲染全局触摸数组中包含的所有DOM节点。
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: An example of multi touch taking into account the radius of each touch is illustrated
    as follows. By touching the side of a closed fist to a mobile device, we can see
    how each part of the hand that touches the screen is detected with their relative
    size and area of contact.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到每个触摸的半径，多点触摸的示例如下所示。通过将封闭拳头的一侧触摸到移动设备上，我们可以看到手部触摸屏幕的每个部分都以其相对大小和接触面积被检测到。
- en: '![radiusY](img/6029OT_08_07.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![radiusY](img/6029OT_08_07.jpg)'
- en: rotationAngle
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rotationAngle
- en: Depending on the way a touch is detected, the ellipse that represents the touch
    might be rotated. The `rotationAngle` attribute associated with each touch object
    is the clockwise angle in degrees that rotates the ellipse to most closely match
    the touch.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 根据触摸检测的方式，表示触摸的椭圆可能会旋转。与每个触摸对象相关联的`rotationAngle`属性是将椭圆顺时针旋转以最接近触摸的角度（以度为单位）。
- en: force
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: force
- en: Some touch devices are capable of detecting the amount of pressure applied to
    the surface of the input surface by the user. When this is the case, the force
    attribute represents that pressure with a variable between 0.0 and 1.0, where
    1.0 represents the maximum pressure that the device can handle. When a device
    doesn't support force sensitivity, this attribute will always return 1.0.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一些触摸设备能够检测用户对输入表面施加的压力量。在这种情况下，力量属性表示该压力量，取值范围在0.0到1.0之间，其中1.0表示设备可以处理的最大压力量。当设备不支持力量灵敏度时，该属性将始终返回1.0。
- en: Since the value of the force attribute is always between zero and one, we can
    conveniently use this to render elements with a varying degree of opacity (with
    zero being a completely transparent—invisible—element and one being completely
    rendered).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于力量属性的值始终在零和一之间，我们可以方便地使用它来渲染具有不同透明度的元素（其中零表示完全透明，即不可见的元素，而一表示完全渲染的元素）。
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: target
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: When a touch event is detected, the DOM element, where the touch was first detected,
    is referenced through the `target` attribute. Since a touch object is tracked
    until the touch ends, the target attribute will reference the original DOM element
    where the touch was first started for the duration of the touch life cycle.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到触摸事件时，通过`target`属性引用触摸最初被检测到的DOM元素。由于触摸对象在触摸结束之前被跟踪，所以`target`属性将在整个触摸生命周期内引用触摸最初开始的原始DOM元素。
- en: The game
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: As we discussed at the beginning of this chapter, there are several considerations
    that must be kept in mind when designing and building a game to be played on a
    mobile device as well as on a desktop browser. As we write this final game in
    this book, we will apply those principles and best practices making a game to
    be playable on both a mobile device and an HTML5-ready browser.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头讨论的那样，在设计和构建适用于移动设备和桌面浏览器的游戏时，必须牢记几个考虑因素。在本书的最后一个游戏中，我们将应用这些原则和最佳实践，制作一个可以在移动设备和支持HTML5的浏览器上玩的游戏。
- en: The approach taken in this particular project is to design for desktop first
    then add mobile-specific APIs and functionality later. The number one reason for
    this decision was because it is much easier to test and debug an application on
    a desktop browser using existing tools and common practices, then add the things
    needed to make the code run smoothly on mobile as well.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目采取的方法是首先为桌面设计，然后稍后添加特定于移动设备的API和功能。这个决定的主要原因是因为在桌面浏览器上使用现有工具和常见做法进行测试和调试应用要容易得多，然后再添加必要的东西，使代码在移动设备上运行顺畅。
- en: The final game is a traditional two-dimensional space shooter, where the player
    controls a single ship that can move around the screen and always shoots up in
    the same direction. Random enemy space ships come from all sides of the screen,
    attempting to hit the player's ship, thus giving damage to the player's ship until
    it explodes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的游戏是一个传统的二维太空射击游戏，玩家控制一艘飞船在屏幕上移动，并始终向上射击。随机的敌人太空船从屏幕的各个方向出现，试图击中玩家的飞船，给玩家的飞船造成伤害，直到爆炸。
- en: '![The game](img/6029OT_08_09.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![游戏](img/6029OT_08_09.jpg)'
- en: Code structure
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码结构
- en: Given the complexity of this game, the structure of the code has to be carefully
    considered. For simplicity, we will use a component-based approach so that adding
    feature upon feature is much easier, especially when it comes down dynamically
    adding the input handling mechanism. Since the game needs to be played equally
    well on a mobile device as well as on a desktop (in other words, the game needs
    to take and handle mouse and keyboard input as well as touch input, depending
    on the environment in which it is played), being able to add a specific component
    to the game on the fly is a very important feature.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个游戏的复杂性，代码结构必须经过仔细考虑。为了简单起见，我们将采用基于组件的方法，这样添加功能就会更容易，特别是在动态添加输入处理机制时。由于游戏需要在移动设备和桌面上同样出色地运行（换句话说，游戏需要接受和处理鼠标和键盘输入以及触摸输入，取决于游戏所在的环境），能够在游戏中动态添加特定组件是一个非常重要的功能。
- en: If you're not familiar with component-based game development, don't worry too
    much about it. The general idea of component-based development is to separate
    each piece of functionality from a class and make that functionality its own class.
    What this allows us to do is to create individual objects that represent individual
    pieces of functionality, such as moving, rendering, and so on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对基于组件的游戏开发不太熟悉，不用太担心。基于组件的开发的一般思想是将每个功能模块从一个类中分离出来，使其成为自己的类。这样可以让我们创建代表各个功能模块的单独对象，比如移动、渲染等等。
- en: 'The final project structure for this game is as follows, where the list of
    files and directories shows the root of the project folder:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的最终项目结构如下，文件和目录列表显示了项目文件夹的根目录：
- en: /css
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /css
- en: This is where the single stylesheet file is stored. This stylesheet defines
    all the styling for both the desktop and mobile versions, although there are very
    few differences between the two. The way to add CSS features to a version of the
    game is to declare these features inside CSS classes then assign those classes
    to DOM elements when appropriate.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是存储单个样式表文件的地方。这个样式表定义了桌面和移动版本的所有样式，尽管两者之间几乎没有什么区别。向游戏版本添加CSS功能的方法是在CSS类中声明这些功能，然后在适当的时候将这些类分配给DOM元素。
- en: The first thing we want to declare in this stylesheet is the viewport, making
    sure that every pixel within the screen is part of the document, so that we can
    capture input events everywhere on our document. We also want to keep the document
    from somehow growing larger than the viewport which would introduce scrollbars
    to the game, which in this case is not desired.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在这个样式表中首先声明的是视口，确保屏幕上的每个像素都是文档的一部分，这样我们就可以在文档的任何地方捕获输入事件。我们还希望保持文档不会以某种方式变得比视口更大，这样就不会为游戏引入滚动条，这在这种情况下是不希望的。
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Two features that we want in our game, if the device running it supports it,
    are transitioned effects of DOM elements as well as animating the background image.
    In order to add that functionality only where appropriate (for example, adding
    this feature to some mobile devices might slow down the game play to unplayable
    levels, given the amount of processing the mobile browser would need to do in
    order to produce the CSS animation and transitions), we create the CSS animation
    and add it to a custom class. When we determine that the device can handle the
    animation, we simply add the class to the document.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望游戏具有两个功能，如果运行游戏的设备支持的话，那就是DOM元素的过渡效果以及背景图片的动画效果。为了只在适当的情况下添加这些功能（例如，将这些功能添加到某些移动设备可能会减慢游戏速度，因为移动浏览器需要进行大量处理才能产生CSS动画和过渡效果），我们创建CSS动画并将其添加到自定义类中。当我们确定设备可以处理动画时，我们只需将该类添加到文档中。
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, in order to simplify some of the game user interface, we create some
    of the game elements as ordinary DOM elements, as opposed to rendering equivalent
    elements directly in the canvas where the rest of the game is rendered.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了简化一些游戏用户界面，我们将一些游戏元素创建为普通的DOM元素，而不是直接在画布中渲染等效的元素。
- en: The only game element we're building as a DOM element is the energy bar for
    the player's ship, which indicates how much energy the ship has left. This energy
    bar is composed of a container element containing a `div` element inside of it.
    The width of this nested `div` represents the amount of energy the player has
    left, which can be a value between 0-100%.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建为DOM元素的唯一游戏元素是玩家飞船的能量条，它表示飞船剩余的能量。这个能量条由一个包含在其中的`div`元素的容器元素组成。这个嵌套的`div`的宽度表示玩家剩余的能量，可以是0-100%之间的值。
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: /img
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /img
- en: Inside this folder we store all the image assets used in the game. Since all
    of these images are rendered inside a canvas, we could have very well combined
    all of the images into a single image atlas. This would be a very nice optimization,
    especially as the game grows and the number of image assets grows. Since most
    browsers limit the number of parallel HTTP requests that an application makes
    to the same server, we can only fetch a limited amount of images at the same time.
    This means that if there are too many individual image files being fetched from
    the same server, the first 4-8 requests are processed (the default number of parallel
    connections to the same server varies from browser to browser but is usually around
    6 or so) while the rest of them wait in a queue.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，我们存储了游戏中使用的所有图像资产。由于所有这些图像都是在画布内渲染的，我们完全可以将所有图像合并成一个单一的图像图集。这将是一个非常好的优化，特别是当游戏增长和图像资产的数量增长时。由于大多数浏览器限制了应用程序对同一服务器发出的并行HTTP请求的数量，我们只能同时获取有限数量的图像。这意味着如果有太多个别的图像文件从同一服务器获取，前4-8个请求会被处理（默认的并行连接数因浏览器而异，但通常大约为6个左右），而其余的则会等待在队列中。
- en: Thus, it is easy to see how creating a single image atlas asset is a much better
    choice over downloading multiple individual image files. Even if the total image
    file size of the atlas is greater than the total size of all the other images
    combined, the big gain is in the transfer latency. Even if the game doubles in
    individual image assets at some point in time, we would still only have to download
    a single image atlas (or a few separate atlases which can all be downloaded simultaneously).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很容易看出，创建单个图像图集资产比下载多个单独的图像文件要好得多。即使图集的总图像文件大小大于所有其他图像的总大小，主要的收益在于传输延迟。即使游戏在某个时候以单独的图像资产翻倍，我们仍然只需要下载一个图像图集（或几个可以同时下载的单独图集）。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since not everybody is highly talented when it comes to creating awesome looking
    graphics for your games and even fewer people have the time to create each image
    to be used in the game. Many game developers find it worthwhile to buy graphics
    from digital artists.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非每个人在为游戏创建出色的图形方面都非常有天赋，甚至更少的人有时间为游戏创建每个要使用的图像。许多游戏开发者发现从数字艺术家那里购买图形是值得的。
- en: In this game, all of the graphics were downloaded from websites where artists
    share their creations for free or very low costs. The website address to this
    wonderful community is [http://opengameart.org](http://opengameart.org).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，所有的图形都是从网站上下载的，艺术家在这里免费或者成本很低地分享他们的作品。这个美妙社区的网站地址是[http://opengameart.org](http://opengameart.org)。
- en: /js
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /js
- en: As mentioned earlier, this game is built on a component-based model. The file
    structure is divided into four main categories; namely components, entities, widgets,
    and general purpose code. Each of these pieces of code are meant to be somewhat
    generic and reusable. The gluing together of all these pieces is done in a file
    called `main.js`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个游戏是基于组件的模型构建的。文件结构分为四个主要类别，即组件、实体、小部件和通用代码。这些代码的每个部分都意味着要相对通用和可重用。所有这些部分的粘合是在一个名为`main.js`的文件中完成的。
- en: /components
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /components
- en: The components directory is where we store all of the components used in the
    game. In the context of game development, a component is a very specific class
    that may contain its own data and performs a very specific function. For example,
    when designing a class to represent the player, instead of having this class handle
    the rendering of the player's ship, moving, performing collision detection, and
    so on, we can break down each piece of functionality from this class into many
    individual smaller classes—or components.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 组件目录是我们存储游戏中使用的所有组件的地方。在游戏开发的背景下，组件是一个非常具体的类，可能包含自己的数据并执行非常特定的功能。例如，当设计一个代表玩家的类时，我们可以将这个类的每个功能模块分解成许多单独的小类或组件，而不是让这个类处理玩家飞船的渲染、移动、执行碰撞检测等功能。
- en: Commonly, each component in your game implements a common interface so we can
    take advantage of object-oriented techniques. Although classical inheritance and
    other object-oriented techniques can be simulated in JavaScript, we simply copy
    the same base interface for each component and make the assumption in our client
    code that every component follows the same interface.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，游戏中的每个组件都实现一个共同的接口，这样我们就可以利用面向对象的技术。尽管在JavaScript中可以模拟经典继承和其他面向对象的技术，但我们只是为每个组件复制相同的基本接口，并在客户端代码中假设每个组件都遵循相同的接口。
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Every component in this game has two things in common. They all live within
    the `Pack.Components` object simulating a package-based structure and they all
    hold a reference to the parent entity that uses the service provided by the component.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，每个组件都有两个共同点。它们都存在于`Pack.Components`对象中，模拟了基于包的结构，并且它们都持有对使用组件提供的服务的父实体的引用。
- en: The first component that we'll create will be the `sprite` component, which
    is responsible for rendering an entity. As we'll see in our discussion about entities,
    an entity only keeps track of its own position in the game world and has no notion
    of its width and height. For this reason, the `sprite` component also keeps track
    of the entity's physical size as well as the image that represents the entity
    visually.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个组件将是“精灵”组件，它负责渲染实体。正如我们将在关于实体的讨论中看到的，实体只在游戏世界中跟踪自己的位置，并不知道自己的宽度和高度。因此，“精灵”组件还跟踪实体的物理大小以及代表实体的图像。
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once the functionality to render an entity is in place, we can now move on to
    adding a component to allow the player to move the entity about the screen. Now,
    the whole point of using components is to allow for maximum code reuse. In our
    case, we want to reuse the component that makes a player move so that we can have
    each enemy ship move about the game world using the same functionality.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦渲染实体的功能就位，我们现在可以继续添加一个组件，允许玩家在屏幕上移动实体。现在，使用组件的整个目的是允许最大程度地重用代码。在我们的情况下，我们希望重用使玩家移动的组件，以便我们可以使用相同的功能使每艘敌舰在游戏世界中移动。
- en: To make the entity move, we use a very standard `Move` component which moves
    the entity based on its direction vector and a constant speed at which the entity
    is to move in this given direction. The `Vec2` data type is a custom general purpose
    class discussed later in the chapter. Basically, this class represents a vector
    where it holds two variables representing the two components of a vector and defines
    a very handy function to normalize the vector when needed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使实体移动，我们使用一个非常标准的“Move”组件，它根据实体的方向向量和实体在给定方向上移动的恒定速度来移动实体。`Vec2`数据类型是本章后面讨论的一个自定义通用类。基本上，这个类表示一个向量，它包含两个表示向量两个分量的变量，并在需要时定义一个非常方便的函数来对向量进行归一化。
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, the way that both a player and an enemy can use this same `Move` component
    to move their entities is slightly different. In the case of an enemy, we can
    simply create some raw artificial intelligence to set the direction of the enemy's
    entity every so often and the `Move` component takes care of updating the entity's
    position as needed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家和敌人都可以使用相同的“Move”组件来移动它们的实体的方式略有不同。对于敌人，我们可以简单地创建一些原始的人工智能来定期设置敌人实体的方向，而“Move”组件负责根据需要更新实体的位置。
- en: In order to make the player's ship move, however, we want the player himself
    or herself to tell the entity where to go. To accomplish this, we simply create
    an input component that listens for human input. However, since the player might
    be playing this game from a device that may support either mouse events or direct
    touch events, we need to create two separate components to handle each case.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使玩家的飞船移动，我们希望玩家本人告诉实体要去哪里。为了实现这一点，我们简单地创建一个输入组件来监听人类输入。然而，由于玩家可能会从可能支持鼠标事件或直接触摸事件的设备玩这个游戏，我们需要创建两个单独的组件来处理每种情况。
- en: These components are identical in every way, except for the fact that one registers
    for mouse events and the other for touch events. While this could have been done
    inside a single component, and conditional statements dictated which events to
    listen for instead, we opted for separate components in order to make the code
    less coupled to any particular device.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件在每个方面都是相同的，唯一的区别是一个注册鼠标事件，另一个注册触摸事件。虽然这可以在单个组件内完成，并且有条件语句决定要监听哪些事件，但我们选择使用单独的组件，以使代码不与任何特定设备耦合。
- en: '[PRE35]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, let's look at a very crucial component of any game with moving entities,
    namely the `physics` components whose sole responsibility in life is to tell if
    two entities collide. This is done in a very simple and efficient fashion. In
    order for an entity to be able to use the `physics` component, it must also have
    a `sprite` component since the `physics` component needs to know where each entity
    is located as well as how tall and wide each entity is. With a `sprite` component,
    we're able to extract both pieces of information about each entity.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看任何具有移动实体的游戏中非常关键的组件，即“物理”组件，其唯一责任是告诉两个实体是否发生碰撞。这是以一种非常简单和高效的方式完成的。为了使实体能够使用“物理”组件，它还必须具有“精灵”组件，因为“物理”组件需要知道每个实体的位置以及每个实体的高度和宽度。有了“精灵”组件，我们能够提取关于每个实体的这两个信息。
- en: The way to check whether two entities collide is very simple. The component
    itself stores a reference to an entity so the function that performs the check
    needs to know the position and size of the entity we're checking against for collision.
    Once we have the location and dimensions of both entities, we simply check if
    one entity's right side is to the left of the other's left side, if one's left
    side is to the right of the other's right side, or if one's bottom is above the
    other's top, and if one's top is below the other entity's bottom. If any of these
    tests passes (in other words, the conditional check returns positive) then we
    know that there is no collision, since it is impossible for two rectangles to
    be intersecting each other, and yet any of those four statements are true about
    them. Similarly, if all of those tests fail, we know that the entities are intersecting
    each other and a collision has occurred.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个实体是否发生碰撞的方法非常简单。组件本身存储了对实体的引用，因此执行检查的函数需要知道我们要检查的实体的位置和大小。一旦我们有了两个实体的位置和尺寸，我们只需检查一个实体的右侧是否在另一个实体的左侧，一个实体的左侧是否在另一个实体的右侧，或者一个实体的底部是否在另一个实体的顶部，以及一个实体的顶部是否在另一个实体的底部之下。如果这些测试中有任何一个通过（换句话说，条件检查返回正值），那么我们知道没有发生碰撞，因为两个矩形不可能相交，但是关于它们的四个陈述中有任何一个是真的。同样，如果所有这些测试失败，我们知道实体相互交叉，并且发生了碰撞。
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The last two components used in the game are very simple and are slightly more
    unique to this particular type of game than the other components. These components
    are the `Strength` component and the `LaserGun` component, which gives entities
    the ability to shoot laser beams at other entities.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中使用的最后两个组件非常简单，与其他组件相比，它们对这种特定类型的游戏稍微更加独特。这些组件是“力量”组件和“激光枪”组件，它们赋予实体向其他实体发射激光束的能力。
- en: The `Strength` component isolates the management of the player's own energy
    as well as all enemy ships and everybody's lasers. This component is used to determine
    if an entity is still alive and how much damage it can cause on other entities
    upon contact. If an entity is no longer alive (if its strength has gotten below
    zero) then it is removed from the game altogether, as is the case with lasers
    every time they collide with another entity.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: “力量”组件隔离了玩家自己的能量管理以及所有敌人飞船和所有激光的管理。该组件用于确定实体是否仍然活着，以及它在接触其他实体时能够造成多少伤害。如果一个实体不再活着（如果它的力量已经降到零以下），那么它将被从游戏中移除，就像激光每次与另一个实体碰撞时一样。
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `LaserGun` component is slightly more involved because it contains a collection
    of entities that it manages. Each time a laser beam is fired by the entity containing
    the laser gun, a new entity is created to represent that laser beam. This entity
    is similar to all the other entities in the game since it also contains a `sprite`
    component to draw itself a `Move` component and a `physics` component as well.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: “激光枪”组件稍微复杂，因为它包含一个它管理的实体集合。每次包含激光枪的实体发射激光束时，都会创建一个新实体来表示该激光束。这个实体与游戏中的所有其他实体类似，因为它还包含一个“精灵”组件来绘制自己，一个“移动”组件和一个“物理”组件。
- en: Each time the laser gun updates itself, it needs to move all of its lasers forward
    and remove any of its laser beams from its control if the laser has gone outside
    the screen area.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 每次激光枪更新自身时，它需要将所有激光向前移动，并在激光超出屏幕范围时从其控制中移除任何激光束。
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With all of our major components in place, we're ready to take a look at the
    other classes in the game. Remember, though, that the whole purpose of using components
    is to simplify development and to loosen the coupling between individual pieces
    of functionality. Thus, if we wanted to add more components to the game, say,
    an explosion effect component, for example, all we'd need to do is follow the
    same basic structure of a component and we'd be ready to simply plug it into the
    main game logic script.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的主要组件，我们准备好看看游戏中的其他类了。不过，请记住，使用组件的整个目的是简化开发，并放松各个功能单元之间的耦合。因此，如果我们想要向游戏中添加更多组件，比如爆炸效果组件，我们只需要遵循相同的组件基本结构，就可以简单地将其插入到主游戏逻辑脚本中。
- en: /entities
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /entities
- en: Entities are the main building blocks of the game. They are the generalized
    representation of anything that we can interact with—the player's ship, enemy
    ships, or laser beams. Some people call their entities objects, characters, or
    actors, but the idea behind them is the same.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是游戏的主要构建块。它们是我们可以与之交互的任何东西的概括表示——玩家的飞船、敌人的飞船或激光束。有些人称它们的实体为对象、角色或者演员，但它们背后的理念是一样的。
- en: In our game, we don't extend the base entity class in order to create a distinction
    between ships and lasers. The only thing that sets them apart are the components
    they use and how those components are used.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们不扩展基本实体类，以区分飞船和激光。唯一区别它们的是它们使用的组件以及这些组件的使用方式。
- en: The structure of our game entities is basic and to the point. Each entity keeps
    track of its own position within the game world, a flag that indicates its state
    (whether the entity is active or not—dead or alive), a list of components, and
    an update function. Also, for simplicity, each entity declares a `draw` function
    which delegates the actual drawing to the `sprite` component, if the entity happens
    to have one. We also define a few general purpose functions inside each entity
    so as to make adding, removing, and using components a bit easier. Finally, each
    entity allows for a custom update function, so that each instantiated entity can
    update itself differently.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏实体的结构是基本且简洁的。每个实体都跟踪其在游戏世界中的位置，一个指示其状态的标志（实体是否活动或死亡），一个组件列表和一个更新函数。此外，为了简化，每个实体声明一个“绘制”函数，将实际绘制委托给“精灵”组件，如果实体恰好有一个。我们还在每个实体内定义了一些通用函数，以便更轻松地添加、移除和使用组件。最后，每个实体都允许自定义更新函数，以便每个实例化的实体可以以不同的方式更新自己。
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, this entity class is really quite bare bones. It takes into
    account what our game needs to do, what is used in the game, and it encapsulates
    the most common functionality based on that. From here we can instantiate an entity
    and add components to it, making it a very unique entity, based on all that it
    potentially can and cannot do.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个实体类实际上非常简单。它考虑了我们的游戏需要做什么，在游戏中使用了什么，并根据这些封装了最常见的功能。从这里，我们可以实例化一个实体并向其添加组件，使其成为一个非常独特的实体，基于它可能能够做和不能做的一切。
- en: /widgets
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /widgets
- en: The only widget used in this game is the `EnergyBar` widget. The whole point
    of widgets is to simplify the management of different user interface elements.
    The way in which each widget decides how to display the elements they represent
    is their own business and any client code using them should only be concerned
    about the interface through which it can communicate with the widget.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏中唯一使用的小部件是“能量条”小部件。小部件的整个目的是简化不同用户界面元素的管理。每个小部件决定如何显示它们代表的元素的方式是它们自己的事情，任何使用它们的客户端代码只需要关心与小部件进行通信的接口。
- en: What the `EnergyBar` widget does is display a horizontal bar across the top
    of the page representing how much energy the player has left. Each time the player
    is hit by an enemy ship, its energy levels drop by some amount. When that energy
    meter goes to zero, the player dies, and the game is over.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnergyBar`小部件的作用是在页面顶部显示一个横条，表示玩家剩余的能量。每次玩家被敌舰击中时，其能量水平都会下降一定量。当能量计归零时，玩家死亡，游戏结束。'
- en: One way this energy bar could have been rendered was through the canvas API,
    where the widget was rendered directly on the game canvas. While this is a very
    acceptable solution as well as a very common one, I decided to just use a plain
    old DOM element instead. This way the styling can be changed much more easily
    through CSS and nothing else would need to be changed within the code. In other
    words, while someone worked on the actual code, a second person could work on
    styling the widget and all they'd need to access would be the stylesheet associated
    with it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 能量条的另一种渲染方式是通过画布API，在游戏画布上直接渲染小部件。虽然这也是一个非常可接受的解决方案，也是一个非常常见的解决方案，但我决定只是使用一个普通的DOM元素。这样，样式可以更容易地通过CSS进行更改，而代码内部不需要进行任何更改。换句话说，当有人在实际代码上工作时，另一个人可以在小部件的样式上工作，他们需要访问的只是与之相关的样式表。
- en: '[PRE40]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When an `EnergyBar` widget is instantiated, it creates its own DOM element that
    represents the widget, adding any CSS classes and IDs associated with it. The
    member attribute energy represents the amount of energy that an entity has and
    the width of one of the DOM elements created by the widget matches to the percentage
    of energy it contains. After a widget's element has been added to the document,
    we can simply communicate with the widget class through its public interface and
    the DOM elements displayed on the document get updated accordingly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化`EnergyBar`小部件时，它会创建一个表示小部件的DOM元素，添加任何与之相关的CSS类和ID。成员属性energy表示实体的能量量，由小部件创建的DOM元素之一的宽度与其包含的能量百分比相匹配。在小部件的元素添加到文档后，我们可以通过其公共接口简单地与小部件类通信，文档上显示的DOM元素会相应地更新。
- en: Canvas.js
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Canvas.js
- en: With the exception of the `EnergyBar` widget, everything else rendered to the
    screen in this game is rendered through a canvas, using the 2D rendering context.
    In order to keep things together and make the code more organized, we create a
    very simple abstraction over the canvas API. Instead of keeping track of a canvas
    variable referencing some DOM element, along with its accompanying context reference,
    we encapsulate the canvas element, the JavaScript reference to it, and the reference
    to the rendering context all inside a single object.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`EnergyBar`小部件之外，游戏中渲染到屏幕上的其他所有内容都是通过画布使用2D渲染上下文渲染的。为了使代码更有条理并保持一致，我们在画布API上创建了一个非常简单的抽象。我们封装了画布元素、对其的JavaScript引用以及对渲染上下文的引用，而不是跟踪引用一些DOM元素的画布变量以及其相应的上下文引用，我们将所有这些都封装在一个对象中。
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We also hide some of the detailed functionality of the canvas API by adding
    a few helper functions, such as `getWidth`, `getHeight`, and `clear`, so that
    other areas in the code can interact with the canvas through this simplified interface.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过添加一些辅助函数（如`getWidth`、`getHeight`和`clear`）隐藏了画布API的一些详细功能，以便代码中的其他区域可以通过这个简化的接口与画布交互。
- en: One other reason that an abstraction such as this can be very handy is that
    it would greatly simplify things if we decided to use two or more canvases. Suppose
    we wanted to render a widget into its own canvas. Without an abstraction like
    this, we would now have four separate variables to keep track of in our code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个这样的抽象可以非常方便的原因是，如果我们决定使用两个或更多的画布，它将极大地简化事情。假设我们想要将一个小部件渲染到自己的画布中。如果没有这样的抽象，我们现在将在我们的代码中有四个单独的变量需要跟踪。
- en: A common optimization pattern in HTML5 game rendering with the 2D canvas is
    to separate the rendering into layers. For example, things that don't change very
    frequently from frame to frame (such as the background graphics of a level) can
    be re-rendered much less frequently than dynamic objects that may need to be rendered
    at a different location each frame (the player and the enemies that are trying
    to kill the hero). Instead of redrawing each and every pixel of the background
    graphics each frame, since most of those pixels are the exactly same as the previous
    frame, we can draw the entire background scene onto its own canvas and absolutely
    position it behind another canvas that only draws on smaller parts of it, making
    it much easier to redraw every frame.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用2D画布进行HTML5游戏渲染时，一个常见的优化模式是将渲染分成层。例如，很少从一帧到另一帧改变的东西（比如一个级别的背景图形）可以比需要在每一帧渲染到不同位置的动态对象（玩家和试图杀死英雄的敌人）更少地重新渲染。我们可以将整个背景场景绘制到自己的画布上，并将其绝对定位在另一个只在其较小部分上绘制的画布后面，这样更容易在每一帧重新绘制。
- en: Since the background layer doesn't change too often, if at all, we can render
    more complex graphics onto it and not have to worry about redrawing anything there
    very often. Although the foreground layer normally needs to be cleared and redrawn
    every single frame, we can still maintain a good frame rate because we're normally
    only rendering on a small portion of the foreground canvas, which doesn't take
    as much processing as it would to redraw the background layer every frame.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于背景层很少甚至根本不会改变，我们可以在其上渲染更复杂的图形，而不必担心经常重绘任何东西。虽然前景层通常需要在每一帧清除和重绘，但我们仍然可以保持良好的帧速率，因为我们通常只在前景画布的一小部分上进行渲染，这不需要像在每一帧重新绘制背景层那样多的处理。
- en: '![Canvas.js](img/6029OT_08_10.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas.js](img/6029OT_08_10.jpg)'
- en: Now it becomes easy to see how valuable a simple canvas abstraction can be when
    using more advanced rendering techniques. In most cases, even if we're just rendering
    on a single canvas, being able to encapsulate all the loose variables associated
    with a canvas often makes things more efficient, especially when you need to pass
    the canvas and the canvas context around to other functions and classes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易看出，当使用更高级的渲染技术时，一个简单的画布抽象是多么有价值。在大多数情况下，即使我们只是在一个画布上渲染，能够封装与画布相关的所有松散变量通常会使事情更有效，特别是当您需要将画布和画布上下文传递给其他函数和类时。
- en: EnemyManager.js
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EnemyManager.js
- en: Since the player of our game will only control a single entity throughout the
    entire game, creating an instance of the entity class and letting the player control
    that entity is trivial. The challenge is finding a way to create enemy entities,
    move them around, and manage them as the game progresses. To solve this problem,
    we create an `EnemyManager` class, whose job is to create enemy entities when
    needed and manage their existence.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏玩家在整个游戏过程中只控制一个实体，因此创建一个实体类的实例并让玩家控制该实体是微不足道的。挑战在于找到一种方法来创建敌人实体，移动它们，并在游戏进行时管理它们。为了解决这个问题，我们创建了一个“EnemyManager”类，其工作是在需要时创建敌人实体并管理它们的存在。
- en: While this may seem like a complex task, it becomes more manageable if we break
    down the task into smaller pieces. The responsibilities that the `EnemyManager`
    class has include creating a new enemy entity and adding it to a list of active
    entities that it stores, updating each entity individually, and removing any dead
    entities from the entity list it manages.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来是一个复杂的任务，但如果我们将任务分解成更小的部分，它就会变得更容易处理。“EnemyManager”类的职责包括创建一个新的敌人实体并将其添加到其存储的活动实体列表中，单独更新每个实体，并从其管理的实体列表中删除任何死亡实体。
- en: '[PRE42]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Because we are using a component-based architecture, these three tasks aren't
    complex at all. In order to create a new entity, we simply instantiate the class
    and add the necessary components it needs to function. To add variety to the game,
    we can randomly assign a different `sprite` to each entity created as well as
    randomly tweak the properties of each entity, such as making it move faster, cause
    more damage, look bigger, and so on.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用基于组件的架构，这三个任务一点也不复杂。为了创建一个新实体，我们只需实例化该类并添加它需要的必要组件。为了增加游戏的变化，我们可以随机为每个创建的实体分配不同的“sprite”，并随机调整每个实体的属性，比如使其移动更快，造成更多伤害，看起来更大等等。
- en: Removing dead entities is even easier. All we need to do is iterate over the
    list of active entities and remove them from the list if the active flag for an
    entity is unset. One thing we could also do is remove any entities that wander
    too far off the screen area, so that we don't need to manage entities that can't
    possibly be hit by the player's lasers.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 删除死亡实体更容易。我们只需要遍历活动实体列表，并在实体的活动标志未设置时将其从列表中删除。我们还可以做的一件事是删除任何漫游得太远的实体，这样我们就不需要管理玩家激光束不可能击中的实体。
- en: Finally, the update function takes the job of updating each active entity's
    position (or rather, it tells each entity to update its own position based on
    the direction they're headed), simulate some basic artificial intelligence by
    moving each entity forward, then removing any dead entities.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新函数负责更新每个活动实体的位置（或者说，它告诉每个实体根据它们的方向更新自己的位置），通过移动每个实体向前模拟一些基本的人工智能，然后删除任何死亡实体。
- en: GameLoop.js
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GameLoop.js
- en: The game loop class takes care of running the game's logic for each frame. The
    main added value that we get from using a class such as this is that we can encapsulate
    this boilerplate functionality and reuse it with different settings with minimal
    effort.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环类负责每帧运行游戏逻辑。使用这样的类的主要附加值是，我们可以封装这些样板功能，并以最小的努力重复使用不同设置。
- en: '[PRE43]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we create an instance of this class, we tell it how fast we want the game
    loop to run in terms of frames per second and the class takes care of the rest.
    Once this is set up, the class will class its own update class at whatever frequency
    we tell it to. As an added bonus, we can also specify our own update function
    to be executed every time the game loop ticks.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建这个类的实例时，我们告诉它我们希望游戏循环以每秒多少帧的速度运行，然后这个类会处理剩下的事情。设置好之后，类将以我们告诉它的任何频率调用自己的更新函数。作为额外的奖励，我们还可以指定我们自己的更新函数，在每次游戏循环滴答时执行。
- en: PhysicsManager.js
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PhysicsManager.js
- en: Similar to the `EnemyManager` class, the `PhysicsManager` class is responsible
    for isolating complex functionality so that the client code is cleaner and the
    functionality can be reused elsewhere. Since this class is a bit more involved,
    we won't be showing the complete source code for it in the book. As with the other
    chapters, check out Packt's website for this book.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 与“EnemyManager”类类似，“PhysicsManager”类负责隔离复杂功能，使客户端代码更清晰，并且功能可以在其他地方重复使用。由于这个类涉及的内容更多一些，我们不会在书中展示它的完整源代码。和其他章节一样，可以在Packt的网站上查看这本书的内容。
- en: In summary, the `PhysicsManager` class takes a reference to all of the enemy
    entities (which it can get from the `EnemyManager` object), all of the player's
    laser beams, and the player's entity itself. Then, inside its update method, it
    checks for collision between all of those entities.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，“PhysicsManager”类接受所有敌人实体的引用（它可以从“EnemyManager”对象中获取），所有玩家的激光束以及玩家的实体。然后，在其更新方法中，它检查所有这些实体之间的碰撞。
- en: Vec2.js
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vec2.js
- en: Since the `physics` engine of this game makes extensive use of vector structures
    and since JavaScript doesn't provide native vector data types, we decided to create
    our own. This simple class represents a vector with two components and provides
    a function to normalize the vector. This is especially useful when we want to
    move an entity in whichever direction it faces.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这款游戏的“物理”引擎大量使用向量结构，并且JavaScript不提供原生向量数据类型，因此我们决定创建自己的向量。这个简单的类表示一个具有两个分量的向量，并提供了一个规范化向量的函数。当我们想要以任何面向的方向移动实体时，这将特别有用。
- en: main.js
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: main.js
- en: 'Finally, we bring it all together in a file that we might as well call `main.js`.
    This file looks an awful lot like me when I go to a fast food restaurant: take
    one of everything and see how it all goes together. First we instantiate a canvas
    object, then the player entity, an `EnemyManager` object, a `PhysicsManager` object,
    and finally, a game loop object. After everything is wired up, we start the game
    loop and the game is set in motion.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有内容整合到一个文件中，我们也可以称之为“main.js”。这个文件看起来非常像我去快餐店时的样子：拿一切，看看它们如何组合在一起。首先我们实例化一个画布对象，然后是玩家实体，一个“EnemyManager”对象，一个“PhysicsManager”对象，最后是一个游戏循环对象。在一切都连接好之后，我们启动游戏循环，游戏就开始了。
- en: '[PRE44]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The main reason for the self-invoked main function is to privately scope all
    of the variables contained within the function is to prevent users from manipulating
    the game from a browser's JavaScript console. Had the game variables all been
    stored in the global scope, anyone with access to that would be able to manipulate
    the game state. Also, since this function is merely a setup function, this would
    be the perfect place to put any conditional logic to load alternate resources
    based on the user agent executing the script.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 自调用主函数的主要原因是将函数中包含的所有变量私有化，以防止用户从浏览器的JavaScript控制台操纵游戏。如果游戏变量都存储在全局范围内，任何有权访问的人都可以操纵游戏状态。此外，由于这个函数只是一个设置函数，这将是放置基于执行脚本的用户代理加载备用资源的任何条件逻辑的理想位置。
- en: index.html
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: index.html
- en: The host page for this game could not be any briefer. All that we do in this
    file is load all of our resources. Since different components sometimes depend
    on other components or other modules defined in our game (and since JavaScript
    provides no mechanism to load individual components into a script), the order
    in which our JavaScript resources are loaded is important.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏的主机页面不可能再简洁了。我们在这个文件中所做的就是加载所有资源。由于不同的组件有时依赖于我们游戏中定义的其他组件或模块（并且由于JavaScript没有加载单个组件到脚本的机制），我们JavaScript资源的加载顺序非常重要。
- en: '[PRE45]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Mobile optimizations
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动优化
- en: In this final section, let's take a look at a few aspects of the game that we
    could (and should) optimize particularly for deployment on mobile devices. Although
    some of the following optimizations discussed also overlap in terms of desktop
    optimizations, they are especially impactful in mobile web development.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，让我们看看游戏的一些方面，我们可以（也应该）特别针对移动设备进行优化。虽然下面讨论的一些优化也在桌面优化方面有重叠，但在移动Web开发中它们尤其有影响。
- en: Combine resources
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并资源
- en: Although it is a good practice to write loose, modular code, we must not stop
    there. Before deploying the application to a production server, we would be wise
    to at least combine all of those files into a single file. The easiest way to
    do this would be by simply concatenating each file and serving up that larger
    file instead of multiple ones.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写松散、模块化的代码是一个好习惯，但我们不能止步于此。在将应用程序部署到生产服务器之前，我们最好至少将所有这些文件合并成一个单一文件。最简单的方法就是简单地连接每个文件，并提供更大的文件而不是多个文件。
- en: The reason this is preferred over sending multiple individual files to the client
    is because after a certain amount of concurrent connection to the same server,
    the browser will queue consequent connections and the total time it will take
    to load all of the files will increase.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法优于向客户端发送多个单独的文件，因为在对同一服务器的一定数量的并发连接之后，浏览器将排队后续连接，并且加载所有文件所需的总时间将增加。
- en: Also, after all of the resources have been combined into a single resource,
    we should also use one of the many available tools that lets us compress, minify,
    obfuscate, and uglify our code. Anything we can do to reduce the code to the smallest
    possible amount of bytes is a big win for a mobile player. One particularly powerful
    tool for the job is the popular open source Closure Compiler developed by Google.
    Among its many features, the Closure Compiler also offers a function that analyzes
    the final code and removes any unreachable, dead code. Doing this will further
    reduce the final size of the application code making it especially handy for download
    over limited network connections, such as those found in most mobile devices today.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在所有资源合并成单一资源之后，我们还应该使用其中一种许多可用的工具，让我们压缩、缩小、混淆和丑化我们的代码。我们可以尽量减少代码的字节数，这对于移动玩家来说是一个巨大的胜利。其中一个特别强大的工具是由谷歌开发的流行的开源Closure编译器。在其众多功能中，Closure编译器还提供了一个分析最终代码并删除任何不可达、死代码的功能。这样做将进一步减少应用程序代码的最终大小，特别适用于在有限网络连接上下载，比如今天大多数移动设备上的连接。
- en: Track touches by IDs
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过ID跟踪触摸
- en: The way we wrote our component to handle user input through touch makes the
    assumption that only one touch will be used at all times. While this assumption
    may hold true for most of the time in our game, it may not be the case in other
    games. The `TouchDrag` component always looks for the touch information on the
    very first touch object found within the changed touches list. The only issue
    with that is that the original touch may not always be the first array element
    within its parent array.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的组件处理触摸用户输入的方式假设在任何时候只会使用一个触摸。虽然这种假设在我们的游戏中大部分时间可能是正确的，但在其他游戏中可能并非如此。 “TouchDrag”组件总是在更改的触摸列表中查找第一个触摸对象上的触摸信息。唯一的问题是原始触摸对象可能并不总是其父数组中的第一个数组元素。
- en: To change this, all we need to do is keep track of the touch ID of the finger
    that first touches the screen, then reference that touch based on its identification
    value.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变这一点，我们只需要跟踪首次触摸屏幕的手指的触摸ID，然后根据其识别值引用该触摸。
- en: '[PRE46]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By tracking the original touch and only responding to it, we can guarantee fidelity
    in the touch input, even if multiple touches are initiated on the screen. This
    would also be the proper way of tracking separate touches for the purposes of
    implementing gestures or other input triggers based on an arbitrary combination
    of touches.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通过跟踪原始触摸并仅对其做出响应，我们可以保证触摸输入的准确性，即使在屏幕上发起多次触摸。这也是跟踪单独触摸的正确方式，以实现基于触摸的手势或其他输入触发器的目的。
- en: Use CSS animations with caution
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谨慎使用CSS动画
- en: There is a strange phenomenon that sometimes happens in mobile browsers when
    we are too generous with some of the newer CSS properties. For example, if we
    add a box shadow to an element, we can still get pretty strong performance. Optionally,
    if we add a CSS transition to some other element, performance could still be maintained.
    However, if both of these properties are assigned together then performance all
    of a sudden drops down to barely playable conditions.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动浏览器中有时会出现一种奇怪的现象，当我们对一些较新的CSS属性过于慷慨时。例如，如果我们向一个元素添加一个盒子阴影，我们仍然可以获得相当强的性能。可选地，如果我们向另一个元素添加CSS过渡，性能仍然可以保持。然而，如果这两个属性都被同时分配，那么性能突然下降到几乎无法游玩的条件。
- en: Since there is no formula that describes which properties should and should
    not be used, and which combinations should be avoided, the advice here is to use
    the least amount of CSS properties possible and add them slowly. In the case of
    our game, where the desktop version makes heavy use of CSS animations to render
    the background, we need to consider the implications that this may have on a mobile
    device. After trying the effect on the two most popular mobile platforms today
    and seeing performance drop severely, we concluded that the particular animation
    we wanted, along with a constantly rendering canvas, was too much for a mobile
    processor to handle.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有一个描述应该使用哪些属性，不应该使用哪些属性，以及应该避免哪些组合的公式，因此这里的建议是尽可能少地使用CSS属性，并慢慢添加它们。在我们的游戏中，桌面版本大量使用CSS动画来渲染背景，我们需要考虑这对移动设备可能产生的影响。在今天最流行的两个移动平台上尝试效果后，看到性能严重下降，我们得出结论，我们想要的特定动画，以及不断渲染的画布，对移动处理器来说太过于繁重。
- en: One way to determine if a particular CSS animation is too demanding on a mobile
    device is to use profiling tools such as Google Developer Tools and take note
    of the sort of work that the browser needs to do in order to achieve the desired
    animation. In cases such as this game, where a background detail was so computationally
    intensive to generate that it conflicted with the calculations required to simply
    play the game, we might well opt for a less demanding alternative. In this game,
    instead of loading the CSS animation onto the document body, we simply display
    a still background graphic.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 确定特定的CSS动画在移动设备上是否过于苛刻的一种方法是使用诸如Google开发者工具之类的性能分析工具，并注意浏览器需要做的工作类型，以实现所需的动画。在这种情况下，例如在这个游戏中，一个背景细节的计算密集型生成与简单地玩游戏所需的计算发生冲突，我们可能会选择一个不那么苛刻的替代方案。在这个游戏中，我们不是将CSS动画加载到文档主体上，而是简单地显示一个静态背景图。
- en: Use separate canvases for each game layer
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为每个游戏层使用单独的画布
- en: As briefly discussed earlier, one powerful optimization technique in HTML5 rendering
    is to use more than one canvas. The point is to render less frequently those things
    that only need to be rendered every once in a while. Those things that need to
    be rendered much more often, we render by themselves in a dedicated canvas context
    so that no CPU (or CPU) power is used to render details around these elements.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面简要讨论的那样，在HTML5渲染中一个强大的优化技术是使用多个画布。重点是尽可能少地渲染那些只需要偶尔渲染的东西。那些需要更频繁渲染的东西，我们在专用的画布上单独渲染，这样就不会使用CPU（或CPU）功率来渲染这些元素周围的细节。
- en: For example, the background scene of a game generally stays the same for several
    frames. Instead of clearing the entire canvas context, only to redraw those exact
    same pixels, on their exact same prior location, we can just render a background
    scene on a dedicated canvas and only render that scene again when the screen scrolls,
    or the scene otherwise changes. Until then, that canvas need not be bothered.
    Any movable objects and entities that need to be rendered multiple times per second
    can just be rendered on a second canvas, with a transparent background, so that
    the background layer can be seen through.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，游戏的背景场景通常在几帧内保持不变。我们可以只在屏幕滚动或场景发生变化时再次渲染背景场景，而不是清除整个画布上的所有像素，然后再次绘制这些完全相同的像素。在此之前，这个画布就不需要被打扰。任何需要每秒渲染多次的可移动对象和实体都可以在第二个画布上渲染，带有透明背景，以便可以透过看到背景层。
- en: In this game, we could very well have rendered the image used as the background
    graphic onto a dedicated background layer, then provide the background animation
    to the canvas this way. However, since HTML5 provides a similar function that
    produces the same effect, we opted for that instead.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们完全可以将用作背景图形的图像渲染到一个专用的背景层上，然后以这种方式将背景动画提供给画布。然而，由于HTML5提供了一个产生相同效果的类似函数，我们选择了这个方法。
- en: Use image atlases
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图像图集
- en: The idea behind image atlases is really quite brilliant. Since the canvas API
    specifies a function that allows us to draw onto the canvas context from a source
    image specifying the area within the image that the pixel copying is to take place,
    we can simply use one master image from which all of our graphics assets can be
    drawn.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图像图集背后的想法真的非常聪明。由于画布API指定了一个允许我们从源图像绘制到画布上的函数，指定了像素复制将发生的图像区域，我们可以简单地使用一个主图像，从中可以绘制出所有我们的图形资产。
- en: Instead of sending multiple loose images from the server down to the client,
    we can simply bundle all of our images into a single atlas file then draw each
    asset from a certain section of this larger collage.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有图像捆绑到单个图集文件中，然后从较大的拼贴画的某个部分绘制每个资产，而不是将多个松散图像从服务器发送到客户端。
- en: Following is an image atlas with many smaller images inside it placed side by
    side, allowing us to retrieve each individual image from a single image asset.
    One of the main benefits of this technique is that we only need one HTTP request
    to the server in order to gain access to all of the images used within the atlas.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个图像地图集，其中包含许多较小的图像，这些图像并排放置，允许我们从单个图像资产中检索每个单独的图像。这种技术的主要好处之一是，我们只需要向服务器发送一个HTTP请求，即可访问图集中使用的所有图像。
- en: '![Use image atlases](img/6029OT_08_11.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![使用图像地图集](img/6029OT_08_11.jpg)'
- en: Of course, the challenge in using this technique is that we would need a way
    to know where each particular image is located within the atlas file. While doing
    this by hand might not seem too cumbersome on a small project such as this one,
    the complexity of this task gets unruly very fast.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用这种技术的挑战在于我们需要一种方法来知道图集文件中每个特定图像的位置。虽然在这样一个小项目上手工操作可能不会显得太麻烦，但这个任务的复杂性会非常快地变得混乱。
- en: There exist many open source tools available to solve this very problem. These
    tools take individual loose image files, bundle them up in the smallest possible
    atlas that can be generated from the list of images provided, and also generate
    a JSON file that we can use to map each loose image to their new representation
    within the atlas.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多开源工具可用于解决这个问题。这些工具将单独的松散图像文件捆绑在一起，生成可能从提供的图像列表中生成的最小图集，并生成一个JSON文件，我们可以使用它来将每个松散图像映射到它们在图集中的新表示。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was dedicated to mobile development with the new HTML5 APIs available.
    We talked about the huge opportunity for game developers in the open web platform
    with regards to mobile devices as well as some of the main challenges associated
    with it. We talked about some best practices with mobile web development, which
    include degrading gracefully and enhancing progressively, designing for all finger
    sizes, saving battery life wherever possible, planning for offline game play,
    and offering a desktop version of your application.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论了可用的新HTML5 API进行移动开发。我们谈到了在开放网络平台上针对移动设备的游戏开发者的巨大机会，以及与之相关的一些主要挑战。我们谈到了移动Web开发的一些最佳实践，包括优雅降级和渐进增强，为所有手指大小设计，尽可能节省电池寿命，规划离线游戏玩法，并提供应用程序的桌面版本。
- en: The final two APIs presented in this chapter were CSS media queries and JavaScript
    touch events. Media queries allow us to check for other properties of the user
    agent viewing the document, such as viewport width, height, resolution, orientation,
    and so on. Depending on the properties set on the user agent executing our application,
    we can use media queries to load different CSS rules and documents, effectively
    modifying the document style at run time. The new JavaScript touch events are
    different from mouse events, in that multiple touches are allowed at the same
    time as well as pressure detection, touch size, and rotation angle.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的最后两个API是CSS媒体查询和JavaScript触摸事件。媒体查询允许我们检查文档查看的用户代理的其他属性，例如视口宽度、高度、分辨率、方向等。根据执行我们的应用程序的用户代理上设置的属性，我们可以使用媒体查询来加载不同的CSS规则和文档，有效地在运行时修改文档样式。新的JavaScript触摸事件与鼠标事件不同，因为允许同时触摸多个触摸，以及压力检测、触摸大小和旋转角度。
- en: Now that you have been introduced to the new features of HTML5, including the
    latest CSS and JavaScript APIs, the next step is for you to get some keyboard
    time and start developing your own games for the largest and most exciting computing
    platform of all time—the open web. Happy gaming!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了HTML5的新功能，包括最新的CSS和JavaScript API，下一步就是让您进行一些键盘操作，开始为有史以来最大最激动人心的计算平台——开放网络开发您自己的游戏。祝您游戏愉快！
