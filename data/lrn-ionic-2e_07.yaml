- en: Building the Riderr App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Riderr应用程序
- en: 'With the knowledge we have gained so far, we will be building an app that helps
    users to book a ride. This app consumes the API exposed by Uber ([https://uber.com/](https://uber.com/)),
    a popular ride-hailing service provider, and integrates the same with an Ionic
    app. In this app, we are going to work on the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今所学的知识，我们将构建一个帮助用户预订行程的应用程序。该应用程序使用Uber提供的API（[https://uber.com/](https://uber.com/)），这是一个流行的叫车服务提供商，并将其与Ionic应用程序集成。在这个应用程序中，我们将处理以下内容：
- en: Integrating with Uber OAuth 2.0
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Uber OAuth 2.0
- en: Integrating REST APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成REST API
- en: Interacting with device features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与设备功能交互
- en: Working with Google APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google API
- en: And finally, booking a ride
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，预订行程
- en: The main purpose of this chapter is to show how one could use both REST APIs
    as well as device features such as Geolocation and InappBrowser, to build real-world
    apps using Ionic.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目的是展示如何同时使用REST API和设备功能，如地理位置和InappBrowser，来使用Ionic构建真实世界的应用程序。
- en: App overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序概述
- en: The app we are going to build is named Riderr. Riderr helps users to book a
    cab between two points. This app uses the APIs provided by Uber ([https://uber.com/](https://uber.com/))
    to book a ride. In this app, we are not going to integrate all the APIs of Uber.
    We will be implementing a few endpoints that display the user's information as
    well as the user's ride information, and a few endpoints that help us book a ride,
    view the current ride, and cancel a ride.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序名为Riderr。Riderr帮助用户在两个地点之间预订出租车。该应用程序使用Uber提供的API（[https://uber.com/](https://uber.com/)）来预订行程。在这个应用程序中，我们不会集成Uber的所有API。我们将实现一些端点，显示用户的信息以及用户的行程信息，以及一些帮助我们预订行程、查看当前行程和取消行程的端点。
- en: To achieve this, we will be using Uber's OAuth to authenticate the user so that
    we can display the user's information as well as book a ride on behalf of the
    user.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用Uber的OAuth来对用户进行认证，以便我们可以显示用户的信息并代表用户预订行程。
- en: 'Here is a quick preview of what the app is going to look like once we are done
    building the app:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速预览，一旦我们完成应用程序的构建，它将会是什么样子：
- en: '![](img/00094.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: 'Note: Neither the book publication company nor I take any responsibility for loss
    of money or account ban from Uber. Please read the API instructions clearly before
    using Uber Production APIs.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：无论是图书出版公司还是我都不对由于使用Uber生产API而导致的金钱损失或账户禁止负责。请在使用Uber生产API之前仔细阅读API说明。
- en: Uber APIs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Uber API
- en: In this section, we are going to go over the various APIs that we are going
    to consume in the Riderr app. We will also be generating a Client ID, a Client
    Secret, and a Server Token that we are going to use while making the requests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍我们将在Riderr应用程序中使用的各种API。我们还将生成一个客户端ID、客户端密钥和服务器令牌，我们将在发出请求时使用。
- en: Authentication
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: 'There are three authentication mechanisms for accessing the Uber API:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Uber API有三种认证机制：
- en: Server Token
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器令牌
- en: Single sign-on (SSO)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点登录（SSO）
- en: OAuth 2.0
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: For us to make requests on behalf of a user, access the user's personal information,
    and book rides on the user's behalf, we need an OAuth 2.0 access token. Hence
    we will be following the OAuth 2.0 mechanism.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了代表用户发出请求、访问用户的个人信息并代表用户预订行程，我们需要一个OAuth 2.0访问令牌。因此，我们将遵循OAuth 2.0机制。
- en: If you are new to the OAuth 2.0 mechanism, take a look at [http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/](http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/)
    or [https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对OAuth 2.0机制不熟悉，请参阅[http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/](http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/)或[https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)。
- en: Registering with Uber
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Uber注册
- en: Before we proceed further, we need to have an Uber account to log in and register
    a new app with Uber. If you don't have an account, you can create one quite easily
    using the Uber app.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，我们需要一个Uber账户来登录并在Uber注册一个新的应用程序。如果您没有账户，您可以使用Uber应用程序很容易地创建一个。
- en: 'Once you have created an Uber account, navigate to [https://developer.uber.com/dashboard/create](https://developer.uber.com/dashboard/create),
    log in, and fill in the form, which is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了Uber账户，导航至[https://developer.uber.com/dashboard/create](https://developer.uber.com/dashboard/create)，登录并填写以下表格：
- en: '![](img/00095.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: Then click on Create. This will register a new app with Uber and will create
    a Client ID, Client Secret, and Server Token for this app. Next, click on the
    Authorization tab on the same page (where we find the Client ID). Update the Redirect
    URL to `http://localhost/callback`. This is very important. If we don't, Uber
    does not know where to send the user after authentication.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击创建。这将在Uber注册一个新的应用程序，并为该应用程序创建一个客户端ID、客户端密钥和服务器令牌。接下来，在同一页面上点击授权选项卡（我们在那里找到客户端ID）。将重定向URL更新为`http://localhost/callback`。这非常重要。如果我们不这样做，Uber就不知道在认证后将用户发送到哪里。
- en: Using a combination of Client ID and Client Secret, we request an Access Token.
    Then, using this access token, we will be accessing Uber resources on behalf of
    a user.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端ID和客户端密钥的组合，我们请求访问令牌。然后，使用这个访问令牌，我们将代表用户访问Uber资源。
- en: To proceed further, you need to have a decent understanding of OAuth 2.0, as
    we will be implementing the same in our application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步进行，您需要对OAuth 2.0有一个相当好的理解，因为我们将在我们的应用程序中实现它。
- en: API
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API
- en: 'In this app, we are going to consume the following APIs from Uber:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将从Uber使用以下API：
- en: '`/authorize`: [https://developer.uber.com/docs/riders/references/api/v2/authorize-get](https://developer.uber.com/docs/riders/references/api/v2/authorize-get). This
    endpoint allows the app to redirect the user to the authorization page. We will
    go deeper into this endpoint when we start working with the app.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/authorize`：[https://developer.uber.com/docs/riders/references/api/v2/authorize-get](https://developer.uber.com/docs/riders/references/api/v2/authorize-get)。此端点允许应用将用户重定向到授权页面。当我们开始使用应用时，我们将深入研究此端点。'
- en: '`/token`: This endpoint uses the code returned by the `/authorize` endpoint
    and requests the access token. This token is then used to make further requests.
    API Doc: [https://developer.uber.com/docs/riders/references/api/v2/token-post](https://developer.uber.com/docs/riders/references/api/v2/token-post).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/token`：此端点使用`/authorize`端点返回的代码，并请求访问令牌。然后使用此令牌进行进一步的请求。API文档：[https://developer.uber.com/docs/riders/references/api/v2/token-post](https://developer.uber.com/docs/riders/references/api/v2/token-post)。'
- en: '`/me`: This endpoint returns the user information, taking the access token
    as the input. API Doc: [https://developer.uber.com/docs/riders/references/api/v1.2/me-get](https://developer.uber.com/docs/riders/references/api/v1.2/me-get).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/me`：此端点返回用户信息，以访问令牌作为输入。API文档：[https://developer.uber.com/docs/riders/references/api/v1.2/me-get](https://developer.uber.com/docs/riders/references/api/v1.2/me-get)。'
- en: '`/history`: This endpoint returns the Uber ride history of the user. This endpoint
    requires special permissions (Privileged Scope). But, for our example, since this
    is a development app, we will be using this endpoint with Full Access scope. But
    if you would like to make a production deployment of the app, refer to [https://developer.uber.com/docs/riders/guides/scopes](https://developer.uber.com/docs/riders/guides/scopes)
    for more information. API Doc: [https://developer.uber.com/docs/riders/references/api/v1.2/history-get](https://developer.uber.com/docs/riders/references/api/v1.2/history-get).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/history`：此端点返回用户的Uber乘车历史。此端点需要特殊权限（特权范围）。但是，对于我们的示例，由于这是一个开发应用程序，我们将使用具有完全访问权限范围的此端点。但是，如果您想要对应用程序进行生产部署，请参考[https://developer.uber.com/docs/riders/guides/scopes](https://developer.uber.com/docs/riders/guides/scopes)获取更多信息。API文档：[https://developer.uber.com/docs/riders/references/api/v1.2/history-get](https://developer.uber.com/docs/riders/references/api/v1.2/history-get)。'
- en: '`/payment-methods`: This endpoint returns the available payment options for
    the user. This endpoint also requires privileged scope. API Doc: [https://developer.uber.com/docs/riders/references/api/v1.2/payment-methods-get](https://developer.uber.com/docs/riders/references/api/v1.2/payment-methods-get).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/payment-methods`：此端点返回用户可用的付款选项。此端点还需要特权范围。API文档：[https://developer.uber.com/docs/riders/references/api/v1.2/payment-methods-get](https://developer.uber.com/docs/riders/references/api/v1.2/payment-methods-get)。'
- en: '`/products`: This endpoint returns the list of products supported in a given
    location. In the place where I live - Hyderabad, India - Uber offers Uber Pool,
    Uber Go, Uber X, and Uber SUV. These vary from place to place within the city
    as well. In some parts of the city, I have access to Uber Moto as well. Using
    this endpoint, we will fetch the products supported at a given location. API Doc:
    [https://developer.uber.com/docs/riders/references/api/v1.2/products-get](https://developer.uber.com/docs/riders/references/api/v1.2/products-get).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/products`：此端点返回在特定位置支持的产品列表。在我所居住的地方 - 印度海得拉巴 - Uber提供Uber Pool，Uber Go，Uber
    X和Uber SUV。这些在城市内的不同地方也有所不同。在城市的某些地方，我还可以使用Uber Moto。使用此端点，我们将获取在特定位置支持的产品。API文档：[https://developer.uber.com/docs/riders/references/api/v1.2/products-get](https://developer.uber.com/docs/riders/references/api/v1.2/products-get)。'
- en: '`/request/estimate`: Before we request a ride, we need to get a fare estimate
    from Uber. If the user is fine with the fare estimate, we will make the actual
    request. This endpoint accepts the required information and responds with a fare
    object. API Doc: [https://developer.uber.com/docs/riders/references/api/v1.2/requests-estimate-post](https://developer.uber.com/docs/riders/references/api/v1.2/requests-estimate-post).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/request/estimate`：在我们请求乘车之前，我们需要从Uber获取车费估算。如果用户对车费估算满意，我们将发出实际请求。此端点接受所需信息，并返回车费对象。API文档：[https://developer.uber.com/docs/riders/references/api/v1.2/requests-estimate-post](https://developer.uber.com/docs/riders/references/api/v1.2/requests-estimate-post)。'
- en: '`/requests`: This endpoint accepts the fare id, product id, from location,
    and to location, and books a ride. API Doc: [https://developer.uber.com/docs/riders/references/api/v1.2/requests-post](https://developer.uber.com/docs/riders/references/api/v1.2/requests-post).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/requests`：此端点接受车费ID，产品ID，出发地点和目的地点，并预订乘车。API文档：[https://developer.uber.com/docs/riders/references/api/v1.2/requests-post](https://developer.uber.com/docs/riders/references/api/v1.2/requests-post)。'
- en: '`/requests/current`: This endpoint will return the details of the current ride
    if any. API Doc: [https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-get](https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-get).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/requests/current`：如果有的话，此端点将返回当前乘车的详细信息。API文档：[https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-get](https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-get)。'
- en: '`/requests/current`: This endpoint will cancel/delete the current ride. API
    Doc: [https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-delete](https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-delete).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/requests/current`：如果有的话，此端点将取消/删除当前的乘车。API文档：[https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-delete](https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-delete)。'
- en: 'Note: You can refer to [https://developer.uber.com/docs/riders/introduction](https://developer.uber.com/docs/riders/introduction)
    for other available APIs.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以参考[https://developer.uber.com/docs/riders/introduction](https://developer.uber.com/docs/riders/introduction)获取其他可用的API。
- en: Building Riderr
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Riderr
- en: Now that we have an understanding of the list of APIs, we will start working
    with the Ionic app.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了API列表，我们将开始使用Ionic应用程序。
- en: Scaffolding the app
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的脚手架
- en: The next step in this chapter is to scaffold a new Ionic blank app and start
    integrating the Uber API with it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一步是搭建一个新的Ionic空白应用程序，并开始集成Uber API。
- en: 'Create a new folder named `chapter7`, open a new command prompt/terminal inside
    the `chapter7` folder, and run the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`chapter7`的新文件夹，在`chapter7`文件夹内打开一个新的命令提示符/终端，并运行以下命令：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will scaffold a new blank project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们搭建一个新的空白项目。
- en: Uber API service
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Uber API服务
- en: In this section, we are going to start working with the service layer that interfaces
    with the Uber API. We will be implementing the aforementioned endpoints inside
    the Ionic app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始使用与Uber API接口的服务层进行工作。我们将在Ionic应用程序内实现上述端点。
- en: Once the app has been scaffolded, navigate into the `src` folder and create
    a new folder named `services`. Inside the `services` folder, create a file named
    `uber.service.ts`. We will be writing all the Uber integration logic here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序搭建完成后，进入`src`文件夹并创建一个名为`services`的新文件夹。在`services`文件夹内，创建一个名为`uber.service.ts`的文件。我们将在这里编写所有Uber集成逻辑。
- en: 'Open the `riderr` project inside your favorite text editor and navigate to
    `riderr/src/services/uber.service.ts`. The first thing we are going to do is add
    the required imports. Add the following to the top of the `uber.services.ts` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中打开`riderr`项目，并导航到`riderr/src/services/uber.service.ts`。我们要做的第一件事是添加所需的导入。将以下内容添加到`uber.services.ts`文件的顶部：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have included
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包括
- en: '`Injectable`: To mark the current class as a provider'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Injectable`：将当前类标记为提供程序'
- en: '`LoadingController`: To show messages while making network requests; `Http`,
    `Headers`, `Response`, and `RequestOptions` for processing `http` requests'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadingController`：在进行网络请求时显示消息；`Http`，`Headers`，`Response`和`RequestOptions`用于处理`http`请求'
- en: '`InAppBrowser`: To achieve OAuth 2.0 without using a server to get the access
    token'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InAppBrowser`：实现OAuth 2.0而不使用服务器获取访问令牌'
- en: '`Storage`: For storing the access token'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`存储`：用于存储访问令牌'
- en: '`Observable`: For better processing of asynchronous requests'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable`：用于更好地处理异步请求'
- en: 'Next, we will define the class and class level variables:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义类和类级变量：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note: I will be deleting the preceding registered app once I am done with this
    example. So, please make sure you have your own `client_secret` and `client_id`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：完成此示例后，我将删除前面注册的应用程序。因此，请确保您拥有自己的`client_secret`和`client_id`。
- en: 'Next comes the constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是构造函数：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `constructor`, we have instantiated `Http`, `Storage`, and `LoadingController`
    classes, we are also fetching the access token stored in memory and saving it
    in-memory for future use.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`constructor`中，我们已经实例化了`Http`，`Storage`和`LoadingController`类，我们还从内存中获取访问令牌并将其保存在内存中以供将来使用。
- en: 'For every single request that we make to the Uber API (except for the authentication
    ones), we need to send the access token as part of the headers. We have the following
    method that will help us with this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们向Uber API发出的每个请求（除了认证请求），我们需要将访问令牌作为标头的一部分发送。我们有以下方法将帮助我们完成这一点：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need a method that returns a Boolean indicating whether the user is
    authenticated and we have a token to make requests to the Uber API:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个方法，返回一个布尔值，指示用户是否已经认证并且我们有一个令牌可以向Uber API发出请求：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method will query the storage for the existence of the token. If the token
    exists, the `observer` returns `true`, else `false`. We will be implementing `showLoader()`
    and `hideLoader()` at the end of all the APIs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将查询存储中是否存在令牌。如果令牌存在，`observer`返回`true`，否则返回`false`。我们将在所有API的末尾实现`showLoader()`和`hideLoader()`。
- en: 'If the user is authenticated, the user is logged in. That means we need to
    have an option where the user logs out. Since the API server is stateless, it
    does not maintain any session information to invalidate. Hence, by clearing the
    token from our storage, we invalidate the session from the client side:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已经认证，用户已登录。这意味着我们需要一个选项，用户退出登录。由于API服务器是无状态的，它不维护任何会话信息以使其失效。因此，通过从存储中清除令牌，我们使客户端端的会话失效：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we are going to write our first API method that interacts with the Uber
    API. This is the authentication method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写我们的第一个与Uber API交互的API方法。这是认证方法：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is a lot happening in this method. We are using the Ionic Native's InAppBrowser
    ([https://ionicframework.com/docs/native/in-app-browser/](https://ionicframework.com/docs/native/in-app-browser/))
    plugin to redirect the user to the Authorize endpoint. The Authorize endpoint
    (`https://login.uber.com/oauth/v2/authorize?client_id=${this.client_id}&response_type=code&scope=${this.scopes}&redirect_uri=${this.redirect_uri}`)
    takes the Client ID, scopes, and the redirect URL.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中发生了很多事情。我们使用Ionic Native的InAppBrowser（[https://ionicframework.com/docs/native/in-app-browser/](https://ionicframework.com/docs/native/in-app-browser/)）插件将用户重定向到授权端点。授权端点（`https://login.uber.com/oauth/v2/authorize?client_id=${this.client_id}&response_type=code&scope=${this.scopes}&redirect_uri=${this.redirect_uri}`）需要客户端ID，范围和重定向URL。
- en: The `redirect_uri` is an important parameter, as the Uber API redirects the
    app to that URL after authentication. And inside our app, we are listening for
    the URL change event via `browser.on('loadstart')`. And we are looking for a URL
    that starts with `http://localhost/callback`. If this URL is matched, we close
    the browser and extract the code from the URL.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect_uri`是一个重要的参数，因为Uber API在认证后将应用程序重定向到该URL。在我们的应用程序内部，我们通过`browser.on(''loadstart'')`监听URL更改事件。我们正在寻找以`http://localhost/callback`开头的URL。如果匹配此URL，我们将关闭浏览器并从URL中提取代码。'
- en: Once we have the code, we need to exchange the same for an Access Token. That
    would be the next part of the `auth()`, to fetch the token from `https://login.uber.com/oauth/v2/token`
    by passing in the `client_secret`, `client_id`, `redirect_uri`, and `code`. Once
    we receive the access token, we save it to the storage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得代码，我们需要交换相同的代码以获得访问令牌。这将是`auth()`的下一部分，通过传递`client_secret`，`client_id`，`redirect_uri`和`code`从`https://login.uber.com/oauth/v2/token`获取令牌。一旦我们收到访问令牌，我们将其保存到存储中。
- en: 'Note: To find out more about storage, refer to [https://ionicframework.com/docs/storage/](https://ionicframework.com/docs/storage/)
    or the *Storage service* section in [*Chapter 4*](part0079.html#2BASE0-9757c8e51afd47e0a7a9ced32db749b8),
    *Ionic Decorators and Services*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要了解更多关于存储的信息，请参考[https://ionicframework.com/docs/storage/](https://ionicframework.com/docs/storage)或[*第4章*](part0079.html#2BASE0-9757c8e51afd47e0a7a9ced32db749b8)中的*存储服务*部分。
- en: Now that we have the access token, we will be making a request to Uber APIs
    to get, post, and delete data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了访问令牌，我们将向Uber API发出请求以获取、发布和删除数据。
- en: 'The first API method we are going to implement is going to fetch the user''s
    information:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的第一个API方法将用于获取用户的信息：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do notice that I am making the API request to the Uber Sandbox API URL and not
    to the production service. This is always a good idea till you are confident in
    your implementation. The Uber Sandbox API and Uber API have a very similar implementation,
    except the data in the Sandbox environment is not real-time, it follows the same
    rules as the Uber API. When in production, do remember to update the API base.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我正在向Uber Sandbox API URL发出API请求，而不是向生产服务发出请求。在您对实施有信心之前，这总是一个好主意。Uber Sandbox
    API和Uber API具有非常相似的实施，除了沙箱环境中的数据不是实时的，它遵循与Uber API相同的规则。在生产环境中，请记住更新API基础。
- en: 'Next, comes the history API:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是历史API：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The headers will be passed to every request that will need an access token to
    process the request.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标头将传递给每个需要访问令牌来处理请求的请求。
- en: 'Next, comes the payment methods endpoint:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是支付方式端点：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding three endpoints will return the user and user ride information.
    The next endpoint will return the list of products supported at a given location:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面三个端点将返回用户和用户乘车信息。下一个端点将返回在给定位置支持的产品列表：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method will be used to display the list of products or ride types available.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将用于显示可用的产品或乘车类型的列表。
- en: 'Before making the actual ride booking, we need to first get a fare estimate.
    We will be using the `requestRideEstimates()` method for this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际预订行程之前，我们需要先获取费用估算。我们将使用`requestRideEstimates()`方法来实现这一点：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we get the fare estimate and the user accepts it, we will be initiating
    a booking request using `requestRide()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了费用估算并且用户接受了它，我们将使用`requestRide()`发起预订请求：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method returns the status of the booking. In the sandbox environment, no
    ride will be booked. If you are serious about booking an actual ride, you can
    change the API URL and initiate an actual booking. Do remember that an Uber driver
    will actually call you for your ride. And if you cancel the ride, appropriate
    cancellation fees will apply.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回预订的状态。在沙箱环境中，不会预订乘车。如果您真的想要预订实际的乘车，您可以更改API URL并发起实际的预订。请记住，Uber司机将真正给您打电话来接您。如果您取消乘车，将收取适当的取消费用。
- en: 'Note: Neither the book publication company nor I take any responsibility towards
    loss of money or account ban from Uber. Please read the API instructions clearly
    before using Uber Production APIs.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：图书出版公司和我都不对由Uber导致的金钱损失或帐户禁止负责。在使用Uber生产API之前，请仔细阅读API说明。
- en: 'Since Uber allows only one ride to be booked at a time from an account, we
    can get the current ride using `getCurrentRides()`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Uber只允许从一个帐户一次预订一次乘车，我们可以使用`getCurrentRides()`来获取当前乘车信息：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And finally, to cancel a ride, we will make a delete request using `cancelCurrentRide()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要取消乘车，我们将使用`cancelCurrentRide()`发出删除请求：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The two utility methods that show and hide the processing loader are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 显示和隐藏处理加载程序的两个实用方法如下：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this, we have added all the required APIs that we are going to use to interact
    with Uber APIs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经添加了所有我们将用来与Uber API交互的必需API。
- en: Integration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成
- en: Now that we have the required API services available, we will be creating the
    required views to represent that data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所需的API服务，我们将创建所需的视图来表示这些数据。
- en: 'When we scaffold the app, a page named `home` will be created for us. But since,
    in our app, everything starts with the authentication, we will first generate
    a login page. Then we will make that the first page of the app. To generate a
    new page, run the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们搭建应用程序时，将为我们创建一个名为`home`的页面。但是，由于在我们的应用程序中，一切都从认证开始，我们将首先生成一个登录页面。然后我们将使其成为应用程序的第一个页面。要生成一个新页面，请运行以下命令：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to update the page reference in `riderr/src/app/app.module.ts`.
    Update the `@NgModule` as shown:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`riderr/src/app/app.module.ts`中的页面引用。按照所示更新`@NgModule`。
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will generate and add the remaining pages as we go along.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进展，我们将生成并添加剩余的页面。
- en: 'Note: As Ionic keeps evolving, class names, and structures of pages might change.
    But the gist of developing an app in Ionic will remain the same.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：随着Ionic不断发展，页面的类名和结构可能会发生变化。但在Ionic中开发应用程序的要点将保持不变。
- en: 'Next, we will update `app.component.ts` to load the login page as the first
    one. Update `riderr/src/app/app.component.ts` as shown:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新`app.component.ts`以加载登录页面作为第一个页面。按照所示更新`riderr/src/app/app.component.ts`。
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we will update the `LoginPage` component. First, the `login.html` page.
    Update `riderr2/src/pages/login/login.html` as shown:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新`LoginPage`组件。首先是`login.html`页面。按照所示更新`riderr2/src/pages/login/login.html`。
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can find the `logo.png` here: [https://www.dropbox.com/s/8tdfgizjm24l3nx/logo.png?dl=0](https://www.dropbox.com/s/8tdfgizjm24l3nx/logo.png?dl=0).
    Once downloaded, move the image to the `assets/icon` folder.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到`logo.png`：[https://www.dropbox.com/s/8tdfgizjm24l3nx/logo.png?dl=0](https://www.dropbox.com/s/8tdfgizjm24l3nx/logo.png?dl=0)。下载后，将图像移动到`assets/icon`文件夹中。
- en: 'Next, update `riderr/src/pages/login/login.ts` as shown:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照所示更新`riderr/src/pages/login/login.ts`。
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we are including the required dependencies. In the constructor,
    we are checking whether the user is already authenticated using the `isAuthenticated()`
    that we created in the `UberAPI` class. If the user clicks on the Login with Uber
    button, we call the `auth()`, which in turn invokes the `auth()` of the `UberAPI`
    class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们包括了所需的依赖项。在构造函数中，我们使用`UberAPI`类中创建的`isAuthenticated()`来检查用户是否已经验证。如果用户点击了Uber登录按钮，我们调用`auth()`，这将调用`UberAPI`类的`auth()`。
- en: If the user is successfully authenticated, we redirect the user to the `home
    page`. Else we don't do anything.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功验证，我们将用户重定向到“主页”。否则我们什么也不做。
- en: Assuming that the user has been successfully authenticated, the user will be
    redirected to the Home page. We are going to make the home page side-menu-based.
    The side menu will have links to navigate to various pages in our app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户已成功验证，用户将被重定向到主页。我们将基于主页的侧边菜单进行操作。侧边菜单将包含导航到应用程序中各种页面的链接。
- en: 'We will update `riderr/src/pages/home/home.html` as shown:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`riderr/src/pages/home/home.html`如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code is self-explanatory. To find out more about the menu, refer
    to [https://ionicframework.com/docs/api/components/menu/Menu/](https://ionicframework.com/docs/api/components/menu/Menu/).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是不言自明的。要了解有关菜单的更多信息，请参阅[https://ionicframework.com/docs/api/components/menu/Menu/](https://ionicframework.com/docs/api/components/menu/Menu/)。
- en: 'Next, we will update the `HomePage` class. `Update riderr2/src/pages/home/home.ts`
    as shown:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新`HomePage`类。如下所示更新`riderr2/src/pages/home/home.ts`：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we have imported the required classes. We will be generating the missing
    pages in the next few steps. Do note the `@ViewChild()` decorator. We will be
    going through that and `ionOpened()` and `ionClosed()` when we work with Google
    Maps.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经导入了所需的类。我们将在接下来的几个步骤中生成缺失的页面。请注意`@ViewChild()`装饰器。当我们使用谷歌地图时，我们将通过它和`ionOpened()`和`ionClosed()`进行操作。
- en: Once the view has been initialized, we check whether the user is authenticated.
    If not, we redirect the user to the login page. `openPage()` sets the root page
    as the selected page from the menu. `logout()` cleans up the token and redirects
    the user to the login page.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 视图初始化后，我们检查用户是否已经验证。如果没有，我们将用户重定向到登录页面。`openPage()`将根页面设置为菜单中选择的页面。`logout()`清除令牌并将用户重定向到登录页面。
- en: Now we will create the required pages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建所需的页面。
- en: 'First, the page where most of the action happens - the `bookRide` page. Run
    the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，大部分操作发生的页面 - `bookRide`页面。运行以下命令：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will generate a new page. Once the page has been created, open `riderr/src/app/app.module.ts`
    and add `BookRidePage` to the `declarations` and `entryComponents` properties
    of `@NgModule()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个新页面。页面创建后，打开`riderr/src/app/app.module.ts`并将`BookRidePage`添加到`@NgModule()`的`declarations`和`entryComponents`属性中。
- en: '`BookRidePage` is one of the most complex pages in the entire app. First off,
    we show a Google Map with the user''s current location. We fetch the available
    products for that user at their location and display them.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookRidePage`是整个应用程序中最复杂的页面之一。首先，我们显示一个带有用户当前位置的谷歌地图。我们获取用户当前位置的可用产品并显示它们。'
- en: Before we proceed further, I need to mention a weird bug that happens when working
    with Google Maps and click events on the map, inside an Ionic app.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，我需要提到一个奇怪的bug，当在Ionic应用程序中使用谷歌地图和地图上的点击事件时会发生。
- en: 'On the Google Map, we show a marker and an info window with the user''s current
    location. Clicking on the marker or the info window will redirect the user to
    set the destination location to book a ride. For this, we need to listen to the
    click event on the map. This kind of causes a problem when working with click
    events on non-Google Map components such as side menus, alerts, and so on. You
    can read more about the issue here: [https://github.com/driftyco/ionic/issues/9942#issuecomment-280941997](https://github.com/driftyco/ionic/issues/9942#issuecomment-280941997).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌地图上，我们显示一个标记和一个带有用户当前位置的信息窗口。单击标记或信息窗口将重定向用户以设置目的地位置以预订乘车。为此，我们需要监听地图上的点击事件。当在非谷歌地图组件上工作时，如侧边菜单、警报等，这会导致问题。您可以在此处阅读有关该问题的更多信息：[https://github.com/driftyco/ionic/issues/9942#issuecomment-280941997](https://github.com/driftyco/ionic/issues/9942#issuecomment-280941997)。
- en: So, to overcome this bug, wherever there is a click interaction other than Google
    Map components, we need to disable the click listener on the Google Map and, once
    we are done, we need to re-enable it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这个bug，除了谷歌地图组件之外的任何点击交互，我们需要禁用谷歌地图上的点击监听器，一旦完成，我们需要重新启用它。
- en: Going back to the `ionOpened()` and `ionClosed()` in `riderr/src/pages/home/home.ts`,
    we are firing custom events from them whenever the menu is opened or closed. This
    way, we disable the click listener on the map when the menu is opened and enable
    the click listener after the user selects a menu item. In `ionOpened()` and `ionClosed()`,
    we have only fired the events. We will be handling the same in `riderr/src/pages/book-ride/book-ride.ts`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`riderr/src/pages/home/home.ts`中的`ionOpened()`和`ionClosed()`，每当菜单打开或关闭时，我们都会从中触发自定义事件。这样，当菜单打开时，我们会禁用地图上的点击监听器，并在用户选择菜单项后启用点击监听器。在`ionOpened()`和`ionClosed()`中，我们只触发了事件。我们将在`riderr/src/pages/book-ride/book-ride.ts`中处理相同的问题。
- en: 'Now that we are aware of the issue, we can proceed further. We will first implement
    the menu and the map HTML. Update `riderr/src/pages/book-ride/book-ride.html`
    as shown:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经意识到了问题，我们可以进一步进行。我们将首先实现菜单和地图HTML。更新`riderr/src/pages/book-ride/book-ride.html`如下所示：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the header, we have a button to cancel an ongoing ride. We will be populating
    the `isRideinProgress` property on the `BookRidePage` class, that manages the
    page state shown here. The `ion-grid` component displays the list of products
    that are supported for the current user at their location.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在页眉中，我们有一个取消进行中乘车的按钮。我们将填充`BookRidePage`类中的`isRideinProgress`属性，该属性管理此处显示的页面状态。`ion-grid`组件显示了当前用户位置支持的产品列表。
- en: 'Also notice that we have added `<div #map id="map"></div>`. This will be the
    place where the map appears.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '还要注意，我们已经添加了`<div #map id="map"></div>`。这将是地图出现的地方。'
- en: 'To clean up the UI a bit, we will be adding few styles. Update `riderr/src/pages/book-ride/book-ride.scss`
    as shown:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理UI，我们将添加一些样式。按照以下方式更新`riderr/src/pages/book-ride/book-ride.scss`：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we are going to update the `BookRidePage` class. There are quite a few
    methods, so I will be sharing them in parts, in the sequence of execution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新`BookRidePage`类。有很多方法，所以我将按照执行顺序分几部分分享它们。
- en: 'In `riderr/src/pages/book-ride/book-ride.ts`, we will first update the required
    imports:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`riderr/src/pages/book-ride/book-ride.ts`中，我们将首先更新所需的导入：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `@Component` decorator will be as is.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`装饰器将保持不变。'
- en: 'Next, we are going to declare some class-level variables:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明一些类级别的变量：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And then define the constructor:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义构造函数：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the view has been initialized, using the `ngAfterViewInit()` hook, we
    will start fetching the user''s Geolocation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦视图被初始化，使用`ngAfterViewInit()`钩子，我们将开始获取用户的地理位置：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But before we get the Geolocation, we need to request the user to permit us
    to access the location services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但在获取地理位置之前，我们需要请求用户允许我们访问位置服务。
- en: 'Also do notice the listeners implemented for the `menu:opened` and `menu:closed`
    events. This is how we disable a click on the map and re-enable it based on the
    state of the side menu. Continuing with our development:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意为`menu:opened`和`menu:closed`事件实现的监听器。这是我们如何根据侧边菜单的状态禁用地图上的点击并重新启用它。继续我们的开发：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using the Diagnostic plugin from `@ionic-native`/`diagnostic`, we request runtime
    permissions. This shows a popup asking the user whether the app can access the
    user''s Geolocation. If the user allows the app, we will receive `Diagnostic.permissionStatus.GRANTED`
    status in the success callback. Then, we will try and fetch the user''s coordinates.
    Other cases can be handled gracefully if needed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自`@ionic-native`/`diagnostic`的Diagnostic插件，我们请求运行时权限。这将显示一个弹出窗口，询问用户是否应用程序可以访问用户的地理位置。如果用户允许应用程序，我们将在成功回调中收到`Diagnostic.permissionStatus.GRANTED`状态。然后，我们将尝试获取用户的坐标。如果需要，其他情况可以得到优雅的处理：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`fetCords()` will use the Geolocation Ionic Native plugin to fetch the user''s
    coordinates. Once we receive the location, we will initiate a request to getProducts(),
    passing in the user''s latitude and longitude. In parallel, we check whether there
    are any rides in progress using the getCurrentRides() on the Uber API.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetCords()`将使用Geolocation Ionic Native插件来获取用户的坐标。一旦我们收到位置，我们将发起一个请求来获取产品，传入用户的纬度和经度。同时，我们使用Uber
    API的`getCurrentRides()`来检查是否有正在进行的乘车。'
- en: Once the response arrives, we call `loadMap()` to draw the required map.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦响应到达，我们将调用`loadMap()`来绘制所需的地图。
- en: 'We will be installing all the required Cordova plugins and Ionic Native modules
    after completing the code walk-through:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完成代码演示后，我们将安装所有必需的Cordova插件和Ionic Native模块：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`loadMap()` takes the Geolocation of the user, creates a marker at the location,
    and pans to that point using the camera API. The marker has a simple info text,
    Select Destination >, which, when clicked, takes the user to a screen to enter
    a destination to book a ride.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadMap()`获取用户的地理位置，创建一个标记在该位置，并使用相机API将视角移动到该点。标记上有一个简单的信息文本，选择目的地 >，当点击时，用户将进入一个屏幕以输入目的地来预订乘车。'
- en: '`infoClick()` and `markerClick()` register a callback to execute `selectDestination()`
    only there is no ride in progress:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`infoClick()`和`markerClick()`注册一个回调来执行`selectDestination()`，只有当没有正在进行的乘车时：'
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To book a ride, the user should select a product. `productClick()` takes care
    of that by setting a product as a selected product based on the user's selection
    from the home page.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要预订乘车，用户应该选择一个产品。`productClick()`通过根据用户在主页上的选择设置产品为所选产品来处理这个问题。
- en: 'Once the product is selected and the user''s location is available, we can
    ask the user to enter the destination location so we can check for fare estimates:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦产品被选择并且用户的位置可用，我们可以要求用户输入目的地位置，以便我们可以检查车费估算：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`selectDestination()` takes care of destination selection as well as getting
    the ride estimates. The first if condition inside `selectDestination()` is to
    make sure that the user has only one ride in progress. The second if condition
    checks whether there is at least one `selectedProduct`. If everything is good,
    we invoke the `AutoCompletePage` as a modal, where the user searches for a place
    using the Google Places Service. Once a place is selected using this service,
    we fetch the Geolocation of the destination. Then pass the required information
    to `requestRideEstimates()` to fetch the estimates.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectDestination()`负责目的地选择以及获取乘车估算。`selectDestination()`内部的第一个if条件是为了确保用户只有一个正在进行的乘车。第二个if条件检查是否至少有一个`selectedProduct`。如果一切顺利，我们将调用`AutoCompletePage`作为一个模态，用户可以使用Google
    Places服务搜索地点。一旦使用此服务选择了一个地点，我们将获取目的地的地理位置。然后将所需的信息传递给`requestRideEstimates()`来获取估算。'
- en: 'We will be working with `AutoCompletePage` once we are done with `BookRidePage`.
    When instead of once we get the fares from the `requestRideEstimates()`, we will
    be presenting the same to the user:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了`BookRidePage`，我们将开始处理`AutoCompletePage`。当我们从`requestRideEstimates()`获取车费时，我们将向用户呈现相同的信息：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`processRideFares()` takes the fare information as input and presents the fare
    to the user. If the user is okay with the fare and time estimate, we place a request
    to Uber to book a ride using `requestRide()`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`processRideFares()`以车费信息作为输入并向用户呈现车费。如果用户对车费和时间估计满意，我们会使用`requestRide()`向Uber发出预订乘车的请求。'
- en: 'And finally, if the user wants to cancel the current ride, we provide `cancelRide()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用户想要取消当前的乘车，我们提供`cancelRide()`：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This would be a call to `cancelCurrentRide()`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个调用`cancelCurrentRide()`。
- en: 'Now that we are done with the required logic for `BookRidePage`, we will create
    `AutoCompletePage`. Run the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`BookRidePage`所需的逻辑，我们将创建`AutoCompletePage`。运行以下命令：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once this is done, we need to add `AutoCompletePage` to `riderr/src/app/app.module.ts`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们需要将`AutoCompletePage`添加到`riderr/src/app/app.module.ts`中：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Add the `AutoCompletePage` reference to the `declarations` and `entryComponents`
    properties of `@NgModule()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将`AutoCompletePage`引用添加到`@NgModule()`的`declarations`和`entryComponents`属性中。
- en: 'The `AutoCompletePage` class will consist of the logic needed to work with
    the Google Places Service to search for a place. First, we will work with `auto-complete.html`.
    Open `riderr/src/pages/auto-complete/auto-complete.html` and update it as shown:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoCompletePage`类将包含与Google Places服务一起使用以搜索地点所需的逻辑。首先，我们将处理`auto-complete.html`。打开`riderr/src/pages/auto-complete/auto-complete.html`并按照以下方式更新它：'
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have a search bar and an `ion-list` to display the search results. Next,
    we will work on `auto-complete.ts`. Open `riderr/src/pages/auto-complete/auto-complete.ts`
    and update it as shown:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个搜索栏和一个`ion-list`来显示搜索结果。接下来，我们将处理`auto-complete.ts`。打开`riderr/src/pages/auto-complete/auto-complete.ts`并按照以下方式更新它：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we are using `google.maps.places.AutocompleteService` to fetch the predictions
    as the user searches.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`google.maps.places.AutocompleteService`来获取用户搜索时的预测。
- en: A very important point to note is that the places and Geocoder services are
    not available as an Ionic Native plugin. Hence, we will be using Google Maps JavaScript
    library to get access to the places and Geocoder services. For that, we will be
    installing typings and then Google Maps. We will be installing this at the end.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点要注意的是，地点和地理编码器服务不作为Ionic Native插件提供。因此，我们将使用Google Maps JavaScript库来访问地点和地理编码器服务。为此，我们将安装typings和Google
    Maps。我们将在最后安装这个。
- en: Once the user finds the place, they will tap on the location and this will trigger
    `chooseItem()`. Inside `chooseItem()`, we will take `place_id` and fetch the geo
    coordinates of the chosen location and pass it back to `modal.onDidDismiss()`
    inside `selectDestination()` in the `BookRidePage` class. Then the flow goes on
    as we have seen in the `BookRidePage` class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 用户找到地点后，他们将点击位置，这将触发`chooseItem()`。在`chooseItem()`内，我们将获取`place_id`并获取所选位置的地理坐标，并将其传递回`BookRidePage`类中`selectDestination()`内的`modal.onDidDismiss()`。然后流程就像我们在`BookRidePage`类中看到的那样。
- en: 'Now, we will implement the `profile`, `history`, and `paymentMethods` endpoints.
    To generate the required pages, run the following commands:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现`profile`，`history`和`paymentMethods`端点。要生成所需的页面，请运行以下命令：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we will add the same to `riderr/src/app/app.module.ts`. The final version
    of the `app.module.ts` will be as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将同样添加到`riderr/src/app/app.module.ts`中。`app.module.ts`的最终版本将如下所示：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now we are going to update the three pages we have scaffolded. Almost everything
    in these pages is quite self-explanatory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新我们已经搭建好的三个页面。这些页面中的几乎所有内容都相当容易理解。
- en: 'The HTML in `riderr/src/pages/profile/profile.html` will be as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`riderr/src/pages/profile/profile.html`中的HTML将如下所示：'
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The required logic will be in `riderr/src/pages/profile/profile.ts` as shown
    in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`riderr/src/pages/profile/profile.ts`中所需的逻辑如下所示：'
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we will work with `HistoryPage`. The HTML for `riderr/src/pages/history/history.html`
    will be as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理`HistoryPage`。`riderr/src/pages/history/history.html`中的HTML将如下所示：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And the associated logic would be in `riderr/src/pages/history/history.ts`
    as shown:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`riderr/src/pages/history/history.ts`中的相关逻辑如下所示：'
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we will implement the payment methods. The HTML for the same will
    be in `riderr/src/pages/payment-methods/payment-methods.html` as shown in the
    following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现支付方式。相同的HTML将在`riderr/src/pages/payment-methods/payment-methods.html`中如下所示：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And the required logic in `riderr/src/pages/payment-methods/payment-methods.ts`
    will be as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`riderr/src/pages/payment-methods/payment-methods.ts`中所需的逻辑如下所示：'
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With this, we complete the required code. Next, we will install the required
    plugins and libraries.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了所需的代码。接下来，我们将安装所需的插件和库。
- en: Installing dependencies
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: 'Run the following commands to install the Cordova plugins needed for this app:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令安装此应用所需的Cordova插件：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And their Ionic Native modules:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它们的Ionic Native模块：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we will be installing the Cordova plugin for Google Maps. But before
    we install that, we need to get an API key. Use the Get A Key button at [https://developers.google.com/maps/documentation/android-api/signup](https://developers.google.com/maps/documentation/android-api/signup)
    to enable the Google Maps API for Android apps and get a key. Go to the following
    page for iOS: [https://developers.google.com/maps/documentation/ios-sdk/get-api-key](https://developers.google.com/maps/documentation/ios-sdk/get-api-key).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装Google Maps的Cordova插件。但在安装之前，我们需要获取一个API密钥。使用[https://developers.google.com/maps/documentation/android-api/signup](https://developers.google.com/maps/documentation/android-api/signup)上的Get
    A Key按钮来启用Android应用的Google Maps API并获取一个密钥。对于iOS，请转到以下页面：[https://developers.google.com/maps/documentation/ios-sdk/get-api-key](https://developers.google.com/maps/documentation/ios-sdk/get-api-key)。
- en: 'Once you have the API key, run the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 获得API密钥后，运行以下命令：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note: Please update the preceding command with your keys.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请使用您的密钥更新上述命令。
- en: 'Next, for working with the Google Maps Places Service, we need to get an API
    key for accessing the Maps services via JavaScript. Navigate to [https://developers.google.com/maps/documentation/JavaScript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key)
    to get a key for JavaScript. Then open `riderr/src/index.html` and add the following
    reference in the header section of the document:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了使用Google Maps Places服务，我们需要获取一个用于通过JavaScript访问地图服务的API密钥。转到[https://developers.google.com/maps/documentation/JavaScript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key)获取JavaScript的密钥。然后打开`riderr/src/index.html`并在文档的头部添加以下引用：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, for the TypeScript Compiler not to complain about the use of the variable
    `google` in `riderr/src/pages/auto-complete/auto-complete.ts`, we need to add
    the required typings. Run the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了让TypeScript编译器不对`riderr/src/pages/auto-complete/auto-complete.ts`中的`google`变量抱怨，我们需要添加所需的typings。运行以下命令：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we run the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Open `riderr/tsconfig.json` and add `"typings/*.d.ts"` to the `"include"` array
    as shown in the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`riderr/tsconfig.json`并将`"typings/*.d.ts"`添加到`"include"`数组中，如下所示：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Refer to *How to install Typescript* typings for Google Maps: [http://stackoverflow.com/a/40854384/1015046](http://stackoverflow.com/a/40854384/1015046)
    for more information.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何安装Google地图的TypeScript typings，请参阅：[http://stackoverflow.com/a/40854384/1015046](http://stackoverflow.com/a/40854384/1015046)
    获取更多信息。
- en: 'Finally, we need to request permission for Internet access and network access.
    Open `riderr/config.xml` and update `<platform name="android"></ platform>` as
    shown:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要请求互联网访问和网络访问权限。打开`riderr/config.xml`并按照以下方式更新`<platform name="android"></platform>`：
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And then add `xmlns:android=http://schemas.android.com/apk/res/android` to
    the widget tag present at the top of the page, as shown:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在页面顶部的widget标签中添加`xmlns:android=http://schemas.android.com/apk/res/android`，如下所示：
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This wraps up the *Installing dependencies* section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了*安装依赖项*部分。
- en: Testing the app
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用
- en: Let's go ahead and test drive the app. First, we need to add the required platform.
    Run `ionic platform add android` or `ionic platform add ios`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续测试该应用。首先，我们需要添加所需的平台。运行`ionic platform add android`或`ionic platform add
    ios`。
- en: For testing the app, we need an emulator or an actual device.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试该应用程序，我们需要模拟器或实际设备。
- en: Once the device/emulator is set up, we can run either the command `ionic run
    android` or `ionic run ios`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备/模拟器设置好，我们可以运行`ionic run android`或`ionic run ios`命令。
- en: 'The flow would be as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 流程如下：
- en: 'First, the user launches the app. The login screen is presented, which is as
    follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户启动应用程序。将呈现登录屏幕，如下所示：
- en: '![](img/00096.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: 'Once the user clicks on LOGIN WITH UBER, we redirect the user to the Uber Auth
    Screen, where the user will log in using their Uber Account:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户点击“使用Uber登录”，我们将用户重定向到Uber授权屏幕，在那里用户将使用他们的Uber帐户登录：
- en: '![](img/00097.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: 'Once the authentication is successful, the consent screen will be shown with
    the list of permissions requested by the app:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 认证成功后，将显示同意屏幕，并列出应用程序请求的权限列表：
- en: '![](img/00098.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: Once the user allows the app to access the data, we redirect the user to the
    home page.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户允许应用访问数据，我们将用户重定向到主页。
- en: 'On the home page, we provide the consent popup for accessing the user''s location:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在主页上，我们提供了访问用户位置的同意弹出窗口：
- en: '![](img/00099.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)'
- en: Once approved, we get the Geolocation of the user and, using that, the products.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得批准，我们将获得用户的地理位置，并使用该位置获取产品。
- en: 'The following is the screenshot of the completely loaded home screen:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完全加载的主屏幕截图：
- en: '![](img/00100.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: 'The Menu will be as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单如下：
- en: '![](img/00101.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: 'From here, the user can view their profile:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，用户可以查看他们的个人资料：
- en: '![](img/00102.gif)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.gif)'
- en: 'They can view their ride history:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可以查看他们的乘车历史：
- en: '![](img/00103.gif)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.gif)'
- en: 'They can also review their payment methods:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还可以查看他们的付款方式：
- en: '![](img/00104.gif)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.gif)'
- en: 'Before the user selects a destination, they need to pick a product:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户选择目的地之前，他们需要选择一个产品：
- en: '![](img/00105.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: 'Once they have selected the product, they can choose a destination to ride
    to:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们选择了产品，他们可以选择要乘坐的目的地：
- en: '![](img/00106.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: 'Now, we make the fare details and display the same:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们制作车费明细并显示相同的内容：
- en: '![](img/00107.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'If the user agrees, we book the ride and display the ride information:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户同意，我们将预订乘车并显示乘车信息：
- en: '![](img/00108.jpeg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: Do notice the CANCEL RIDE button at the top-right corner of the app. This will
    cancel the current ride.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意应用程序右上角的取消乘车按钮。这将取消当前的乘车。
- en: Again, as a reminder, we are making calls to the Sandbox API URL. If you want
    to request an actual ride, update `UBERSANDBOXAPIURL` to `UBERAPIURL` in `riderr/src/services/uber.service.ts`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们正在调用沙盒API URL。如果您想请求实际乘车服务，请在`riderr/src/services/uber.service.ts`中将`UBERSANDBOXAPIURL`更新为`UBERAPIURL`。
- en: 'Using the Uber (production) API, when we request a ride, we receive a processing
    response. We can keep polling a couple of times to fetch the current ride information.
    And this is what the response will look like if you make an actual ride request:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Uber（生产）API时，当我们请求乘车时，我们会收到处理响应。我们可以继续轮询几次以获取当前乘车信息。如果您发出实际乘车请求，响应将如下所示：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can build your interface accordingly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以相应地构建您的界面。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone through building an app with Ionic and integrating
    the same with Uber API as well as device features using Ionic Native. We have
    also used the Google Places Service as a raw JavaScript library and integrated
    it with our Ionic app using typings.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经通过Ionic构建了一个应用，并将其与Uber API以及使用Ionic Native的设备功能集成。我们还使用了Google Places
    Service作为原始JavaScript库，并使用typings将其与我们的Ionic应用集成。
- en: In the next chapter, we are going to look at migrating Ionic 1 apps to Ionic
    2\. This will be applicable if you are moving from Ionic 1 to Ionic 3 as well.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下将Ionic 1应用迁移到Ionic 2。如果您从Ionic 1迁移到Ionic 3，这也适用。
