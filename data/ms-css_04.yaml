- en: Creating Buttons with Modular, Reusable CSS Classes, and CSS3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块化、可重用的CSS类和CSS3创建按钮
- en: Having CSS that is modular and reusable makes it organized and concise, thereby
    avoiding situations where you may feel like pulling your hair out. Wouldn't it
    be awesome to just add the class of `.button` to an anchor element, no matter
    where that anchor element is in your markup, and have it transform into a button?
    CSS is "reusable" if you're able to use its classes anywhere and don't need these
    classes to be qualified by parent elements as long descendant selectors. The term
    "modular" refers to the ability to add variations to the button by adding another
    class to it so that one element can have two classes that could come together
    to form something very different.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有模块化和可重用的CSS使其组织有序且简洁，从而避免出现让你抓狂的情况。如果能够在标记中的任何位置使用其类并且不需要这些类被父元素限定为后代选择器，那么CSS就是“可重用”的。术语“模块化”指的是通过向其添加另一个类来为按钮添加变化的能力，以便一个元素可以有两个类，这两个类可以组合在一起形成非常不同的东西。
- en: 'A good example of how to write modular and reusable CSS is this: creating buttons.
    However, this concept should be applied everywhere, across all components of your
    website. We have a lot to go over in this chapter. We will cover modular CSS and
    multiple classes in the first two sections, before we switch gears and talk about
    how selectors can overrule each other in the specificity rules section. We''ll
    then get into CSS3 pretty heavily with transitions, transforms, and gradients,
    and we''ll go through every step of creating and styling a big call-to-action
    button.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是如何编写模块化和可重用的CSS：创建按钮。然而，这个概念应该应用到网站的所有组件中。在本章中，我们有很多内容要讨论。在前两节中，我们将介绍模块化CSS和多个类，然后我们将转变话题，讨论选择器如何在特异性规则部分互相覆盖。然后，我们将深入研究CSS3的过渡、变换和渐变，并逐步介绍创建和样式化一个大的呼吁行动按钮的每个步骤。
- en: Creating buttons with modular CSS
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块化CSS创建按钮
- en: In this section, we'll create buttons with modular CSS classes. We'll find out
    what exactly modular CSS is and why it's useful. First, let's look at the final
    site we're going to create and explore the different button types we'll use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建具有模块化CSS类的按钮。我们将找出模块化CSS究竟是什么，以及为什么它很有用。首先，让我们看一下我们将要创建的最终网站，并探索我们将使用的不同按钮类型。
- en: Different button types
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的按钮类型
- en: 'At the very top, we have our enormous Go Premium call-to-action button:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们有一个巨大的“立即订阅”呼吁行动按钮：
- en: '![](img/00101.jpeg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: 'Scrolling down a bit on the home page and we''ll find these "ghost" buttons
    with a nice hover state:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在首页向下滚动一点，我们会发现这些带有漂亮悬停状态的“幽灵”按钮：
- en: '![](img/00102.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: 'On the movies page, we have that same standard button. It just has a different
    color and is positioned a little differently. This appears in all three movie
    sections:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影页面上，我们有相同的标准按钮。它只是颜色不同，并且位置有点不同。这出现在所有三个电影部分中：
- en: '![](img/00103.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.jpeg)'
- en: 'So, in this section, we''re going to build these standard buttons at the bottom
    of each of all three columns:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这一部分，我们将在所有三列的底部构建这些标准按钮：
- en: '![](img/00104.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: Building standard buttons
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建标准按钮
- en: 'Our starting point has us a long way to go, but it should be pretty easy:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点让我们走了很长一段路，但应该相当容易：
- en: '![](img/00105.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: 'Let''s jump into the HTML of our secondary section:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到我们次要部分的HTML中：
- en: '![](img/00106.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: I'll add the class of `button` to all three anchor elements at the bottom of
    each column.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在每个列底部的三个锚元素中添加`button`类。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, jumping down to the bottom of our CSS, let's add a huge comment for our
    new section and name "Buttons".
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，跳到我们CSS的底部，让我们为我们的新部分添加一个巨大的注释，并命名为“按钮”。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is where all our button styles will go.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们所有按钮样式的地方。
- en: 'What we want to do is create the `.button` selector. All the stylistic properties
    that are shared across buttons will go here. We won''t put any positioning properties
    in the button selector because buttons could be positioned anywhere:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是创建`.button`选择器。所有共享的样式属性都将放在这里。我们不会在按钮选择器中放置任何定位属性，因为按钮可以放置在任何位置：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s start by adding a border. We''ll go with two pixels solid and a dark
    gray color. We''ll apply the same color to the text:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加边框开始。我们将选择两像素实线和深灰色。我们将把相同的颜色应用于文本：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After saving and refreshing the browser it starts to ever so slightly resemble
    a button:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并刷新浏览器后，它开始略微类似按钮：
- en: '![](img/00107.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'We now need to add some padding. Let''s go back to our CSS and use the two-value
    padding shorthand: `10px` for the top and bottom, and `0px` for the left and right.
    This is because we''re going to end up centering the text. Let''s also change
    the display property to `block` because these are inline elements and we want
    them to behave like block-level elements:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加一些填充。让我们回到我们的CSS，并使用两个值的填充快捷方式：`10px`用于顶部和底部，`0px`用于左右。这是因为我们最终会将文本居中。让我们还将显示属性更改为`block`，因为这些是内联元素，我们希望它们的行为像块级元素一样：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save this, refresh the browser, and see the effect:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个，刷新浏览器，看看效果：
- en: '![](img/00108.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: 'As you can see, we now have to add some text-level properties. First, let''s
    add a font family. We''ll go with the typical `sans-serif` stack: `Arial, Helvetica,
    sans-serif`. Then, use the `text-align` property to align the text in the center
    of the element. We''ll also set the `font-weight` to `bold`, then use another
    property called `letter-spacing` and add a value of `1.5px`. If you''re not familiar
    with the `letter-spacing` property, it does pretty much what you think it does—it
    creates a horizontal space between each letter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在必须添加一些文本级属性。首先，让我们添加一个字体系列。我们将选择典型的`sans-serif`堆栈：`Arial, Helvetica,
    sans-serif`。然后，使用`text-align`属性将文本对齐到元素的中心。我们还将把`font-weight`设置为`bold`，然后使用另一个叫做`letter-spacing`的属性，并添加一个值`1.5px`。如果你不熟悉`letter-spacing`属性，它基本上就是你所想的——它在每个字母之间创建了水平空间：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we save this and refresh the site, we will have our button elements. There''s
    no hover state yet; we''ll get into that in another section:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并刷新网站后，我们将拥有我们的按钮元素。目前还没有悬停状态；我们将在另一节中介绍：
- en: '![](img/00109.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: 'If you go over to the movies page now, you will see the Learn More links there,
    which need to be buttons as well:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在转到电影页面，您将看到那里的“了解更多”链接，也需要成为按钮：
- en: '![](img/00110.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00110.jpeg)'
- en: 'So let''s jump over to that markup in the `shark-movies.html` file, and do
    the same thing. Add the class of `button` to each anchor tag at the bottom of
    each movie section:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到`shark-movies.html`文件中的标记，并做同样的事情。在每个电影部分底部的每个锚点标签中添加`button`类：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save this and refresh, and you''ll get a button instantly:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并刷新，您将立即得到一个按钮：
- en: '![](img/00111.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: It sort of works; we have a button, but not entirely. They look like buttons
    but they are of the wrong color, too wide, and not positioned to the right. Also,
    the text doesn't contrast well with the background, especially in darker sections.
    So there is some fixing we have to do, essentially because these buttons are different
    to the ones on the home page, which were full-width buttons.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它有点起作用；我们有一个按钮，但不完全。它们看起来像按钮，但颜色不对，太宽，而且没有定位到右侧。此外，文本与背景的对比度不佳，特别是在较暗的部分。因此，我们需要做一些修复，因为这些按钮与主页上的按钮不同，主页上的按钮是全宽的。
- en: Let's go ahead and fix those buttons now and look at how we can get even more
    modular and add multiple classes in order to vary the buttons.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在修复这些按钮，看看如何更加模块化，并添加多个类以变化按钮。
- en: Multiple classes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个类
- en: 'To recap, so far you''ve learned how to create a class that can be reused anywhere
    on our web page in order to create a button. However, buttons tend to vary across
    a website. You may have, for instance, buttons like: `Okay`, `Close`, `Cancel`,
    `Submit`, and `Add to cart`. All of which have different meanings so are all colored
    or styled slightly differently. In some scenarios, as in the case of our movies
    and index pages, the buttons just end up varying based on the page that they''re
    on because of the layout differences between the pages. In this section, we''ll
    get even more modular and learn how to use multiple classes in order to change
    the appearance of our buttons. We''ll look at a few examples of how multiple classes
    can provide us some affordances in regard to styling our buttons throughout the
    site.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，到目前为止，您已经学会了如何创建一个可以在网页的任何地方重复使用的类，以创建一个按钮。然而，按钮在网站上往往会有所不同。例如，您可能会有像“确定”、“关闭”、“取消”、“提交”和“添加到购物车”等按钮。所有这些按钮都有不同的含义，因此它们的颜色或样式略有不同。在某些情况下，例如我们的电影和索引页面，按钮最终会因页面布局的差异而有所不同。在本节中，我们将变得更加模块化，并学习如何使用多个类来改变我们按钮的外观。我们将看一些多个类如何为我们提供一些便利，以便在整个网站上样式化我们的按钮。
- en: 'The following screenshot illustrates the final site. We''re shooting for buttons
    that look like the Learn More button. They''re floated to the right, they''re
    white, they have a white border, and their width is narrower:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了最终的网站。我们希望按钮看起来像“了解更多”按钮。它们向右浮动，是白色的，有白色边框，宽度更窄：
- en: '![](img/00112.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.jpeg)'
- en: 'The following is where we stand with regard to our site at the moment. Our
    buttons are dark gray in color and have full width, they''re just not what we''re
    looking for here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的网站情况如下。我们的按钮是深灰色的，并且宽度全屏，但不符合我们的要求：
- en: '![](img/00113.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: Changing the width of the buttons
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改按钮的宽度
- en: 'First, let''s address the width issue by creating a new class called `button-narrow`.
    So in our CSS, where our button section is, below the `.button` rule set we created
    in the last section, create a new class called `.button-narrow`. Very simply,
    the width is going to be `25%`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过创建一个名为`button-narrow`的新类来解决宽度问题。在我们的CSS中，在上一节创建的`.button`规则集下面，创建一个名为`.button-narrow`的新类。非常简单，宽度将是`25%`：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save this. Next, go to the `shark-movies.html` file. Go to each of the three
    anchor tags with a class of button. I''ll just show the Learn More button here,
    but the code changes are the same for all of them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个。接下来，转到`shark-movies.html`文件。转到每个带有`button`类的三个锚点标签。我只会展示“了解更多”按钮的代码，但对于所有按钮，代码更改都是相同的：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s add our new `button-narrow` class to these elements:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将新的`button-narrow`类添加到这些元素中：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Save this, go to the browser, and you will see that the buttons are now much
    smaller in all three sections:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，转到浏览器，您会看到所有三个部分的按钮现在都变得更小了：
- en: '![](img/00114.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.jpeg)'
- en: Let's take this a step further and create another class called `button-alt`,
    which will control the border and font colors.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再进一步，创建另一个名为`button-alt`的类，用于控制边框和字体颜色。
- en: Changing the border and font colors of the buttons
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改按钮的边框和字体颜色
- en: Let's add the `button-alt` class as well to each of the 3 **Learn More** buttons.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将`button-alt`类添加到这3个“了解更多”按钮中。
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now go to the CSS and type `.button-alt` as our new selector beneath our `.button-narrow`
    selector. I chose `button-alt` as the class because this is an alternative button
    color. Then, specify `color` as white and the `border-color` as white:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到CSS，并在我们的`.button-narrow`选择器下方输入`.button-alt`作为我们的新选择器。我选择`button-alt`作为类，因为这是另一种按钮颜色。然后，指定`color`为白色，`border-color`为白色：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Save this, go to the site, and you will now see that we''re almost there:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，转到网站，您会看到我们几乎到达目标了：
- en: '![](img/00115.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.jpeg)'
- en: Positioning the button
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位按钮
- en: 'The final thing is the position of the button. It is currently on the left-hand
    side and it needs to sit on the right. Naturally, we could create a class called
    `button-right` that floats the buttons to the right. However, floating elements
    to the left or right is very common, even outside of buttons. It is preferable
    to keep the class names more generic, such as float right and float left. This
    way, we can float anything to the right or left. In my case, before the `Buttons`
    section in the CSS, I have my global styles:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事是按钮的位置。它目前位于左侧，需要位于右侧。当然，我们可以创建一个名为`button-right`的类，将按钮浮动到右侧。然而，将元素浮动到左侧或右侧是非常常见的，甚至在按钮之外也是如此。最好将类名保持更通用，例如`float
    right`和`float left`。这样，我们可以将任何东西浮动到右侧或左侧。在我的情况下，在CSS的`Buttons`部分之前，我有我的全局样式：
- en: '![](img/00116.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: 'Right below this global list, I''m going to copy my standard library of modular
    styles:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局列表下面，我将复制我的标准模块化样式库：
- en: '![](img/00117.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00117.jpeg)'
- en: 'This is part of the base boilerplate I''ve built over the years, and it has
    classes such as `float-left`, `float-right`, `clear`, `bold`, `hidden`, and some
    other common modular classes. You can see the full list in the download package.
    These can be reused throughout the site. Now, in the `shark-movies.html` file,
    let''s simply add the `float-right` class to our three anchor tags:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我多年来建立的基本样板的一部分，其中包括`float-left`、`float-right`、`clear`、`bold`、`hidden`和一些其他常见的模块化类。您可以在下载包中看到完整的列表。这些可以在整个网站中重复使用。现在，在`shark-movies.html`文件中，让我们简单地将`float-right`类添加到我们的三个锚标签中：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Save this and refresh the shark movie site. You''ll now see the buttons floated
    to the right:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并刷新鲨鱼电影网站。您现在将看到按钮向右浮动：
- en: '![](img/00118.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.jpeg)'
- en: 'I should also point out that our container that surrounds each of these sections
    is not going to collapse. Let''s go into DevTools to see why. The section highlighted
    in the following screenshot with a class of `content-block` has not collapsed
    because I added the clearfix `grouping` class to it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该指出，我们每个部分周围的容器不会坍塌。让我们进入DevTools看看原因。以下截图中突出显示的具有`content-block`类的部分之所以没有坍塌，是因为我向其中添加了clearfix
    `grouping`类：
- en: '![](img/00119.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.jpeg)'
- en: 'If I were to take this out and delete `grouping` from that line, you will see
    how the collapse would take effect. Because we have this `grouping` class, we
    make sure this section doesn''t collapse:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将这个删除并从那一行中删除`grouping`，您将看到坍塌会发生。因为我们有这个`grouping`类，我们确保这个部分不会坍塌：
- en: '![](img/00120.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.jpeg)'
- en: So, in conclusion, we followed a very modular and reusable approach to build
    our button and created a few modular button-related classes that can be used to
    vary the style of the button. There are other ways we could have done this. I
    could have used a descendant selector to style the buttons based on their parent.
    That way, all the buttons inside of content-block would always be floated to the
    right and be white instead of dark gray. This would have been a decent alternative
    if it would have provided other areas, besides content blocks, the same alternative
    button styles, which is highly likely. Next, let's talk about why a modular, reusable,
    and light approach to CSS is necessary. We'll do this by talking about the rules
    of specificity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总之，我们遵循了一种非常模块化和可重用的方法来构建我们的按钮，并创建了一些可以用来改变按钮样式的模块化按钮相关类。我们还有其他方法可以做到这一点。我可以使用后代选择器来根据它们的父级样式化按钮。这样，content-block内的所有按钮将始终向右浮动，并且是白色而不是深灰色。如果除了内容块之外的其他区域也提供了相同的替代按钮样式，这将是一个不错的选择。接下来，让我们谈谈为什么需要一种模块化、可重用和轻量级的CSS方法。我们将通过讨论特异性规则来做到这一点。
- en: Specificity rules
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特异性规则
- en: We're beginning to understand how a modular approach to CSS allows us to use
    classes as little chunks of CSS that can be used anywhere on the web page to style
    any element. This makes writing CSS very convenient. However, it only works if
    the CSS is kept lightweight. As you'll learn in this section, every CSS selector
    can be weighed on a scale, and the heaviest selector wins the style battle between
    two competing selectors. So, I'll start by explaining the weights of different
    selectors and how they can overrule one another. Then, we'll talk a bit about
    how the universal selector and the `!important` declaration fit into the weights
    of the selectors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始了解到，CSS的模块化方法使我们能够将类作为CSS的小块，可以在网页的任何地方使用来为任何元素设置样式。这使得编写CSS非常方便。然而，这仅在CSS保持轻量级时才有效。正如您将在本节中了解到的，每个CSS选择器都可以在一个规模上进行衡量，最重的选择器将赢得两个竞争选择器之间的样式战。因此，我将首先解释不同选择器的权重以及它们如何相互推翻。然后，我们将稍微讨论一下通用选择器和`!important`声明如何适用于选择器的权重。
- en: The weights of different selectors
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同选择器的权重
- en: 'All selectors are assigned a weight, and the heaviest selector takes precedence
    when conflicting CSS rules exist. It''s natural when architecting a website that
    you have general styles that get overridden with more specific styles in different
    circumstances. In the global area at the top of the style sheet, a very broad
    style has been set for all paragraph elements:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选择器都被分配了一个权重，最重的选择器在存在冲突的CSS规则时优先。在构建网站时，通常会出现一种情况，即通用样式会在不同情况下被更具体的样式覆盖。在样式表顶部的全局区域中，为所有段落元素设置了一个非常广泛的样式：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The font size is `16px`. There is a `line-height` property of `1.6` and `20px`
    of `margin-bottom`. Naturally, I might want to overwrite either `line-height`
    or `margin-bottom` under varying circumstances. Let''s try and override that with
    a new rule set with a selector of `.content-block p`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 字体大小为`16px`。有一个`line-height`属性为`1.6`和`margin-bottom`为`20px`。自然地，我可能想要在不同情况下覆盖`line-height`或`margin-bottom`。让我们尝试使用选择器`.content-block
    p`来覆盖它：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a descendant selector. Now let''s add a `line-height` of `1.8` and
    `margin-bottom` of `40px`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个后代选择器。现在让我们添加`line-height`为`1.8`和`margin-bottom`为`40px`：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Switch over to the website to view the original setup. This descendant selector
    should target any content or paragraph text in the main text area:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到网站上查看原始设置。这个后代选择器应该针对主文本区域中的任何内容或段落文本：
- en: '![](img/00121.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00121.jpeg)'
- en: 'When we save our CSS and refresh the site, we get more line height and margin
    bottom, as you can see in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存我们的CSS并刷新网站时，我们会得到更多的行高和底部边距，就像你在下面的截图中看到的那样：
- en: '![](img/00122.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00122.jpeg)'
- en: 'So how much does each selector weigh? Well, you can think of inline styles
    as worth 1,000 points, IDs as worth 100 points, classes as worth 10 points, and
    elements as worth one point each. In the example we have been looking at, the
    single `p` element selector is worth just 1 point, whereas `.content-block p`,
    which was a class and an element, is worth 11 points:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么每个选择器的权重是多少呢？嗯，你可以认为内联样式值为1000分，ID值为100分，类值为10分，元素值为1分。在我们一直在看的例子中，单个`p`元素选择器的值只有1分，而`.content-block
    p`，它是一个类和一个元素，值为11分：
- en: '![](img/00123.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00123.jpeg)'
- en: 'This point system figures out which selector is going to win. In this case,
    the selectors were both targeting the paragraph element; however, because `.content-block
    p` is worth 11 points, it''s going to trump the rule set above it which, as an
    element selector, is only worth one point:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分数系统决定了哪个选择器会获胜。在这种情况下，这两个选择器都是针对段落元素的；然而，因为`.content-block p`值为11分，它将击败它上面的规则集，因为作为元素选择器，它只值1分：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'IDs are worth 100 points, which is 10 times as much as a class. In our `shark-movies.html`
    file, you can see that the first section of Jaws has the `jaws` ID:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ID的权重是100分，是类的10倍。在我们的`shark-movies.html`文件中，你可以看到《大白鲨》的第一部分有`jaws` ID：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let''s switch back to our style sheet and create a new rule set, like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们切换回我们的样式表，并创建一个新的规则集，如下所示：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we refresh the browser, you will see that `line-height` of `3` does take
    effect:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们刷新浏览器时，你会看到`line-height`为`3`生效了：
- en: '![](img/00124.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00124.jpeg)'
- en: Our selector that uses an ID that's worth 101 points overrides the selector
    that has a class and an element worth just 11 points as well as the selector that's
    just an element worth just 1 point. The weight of the ID, in my case means I tend
    to stay away from them for styling purposes when I can. IDs are also less versatile
    than classes; they can only be used once on a page. I really try to avoid using
    them altogether because they're not very reusable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的ID值为101分的选择器将覆盖具有类和元素值仅为11分的选择器，以及仅具有1分元素值的选择器。ID的权重，在我的情况下意味着我倾向于在可以的情况下远离它们进行样式设置。ID也比类更不灵活；它们在页面上只能使用一次。我真的尽量避免使用它们，因为它们不太可重用。
- en: 'Another thing to avoid is inline styles, which we can think of as worth a whopping
    1,000 points. Inline styling will beat everything, including selectors with an
    ID. Let''s target the paragraph again to demonstrate this. We''ll jump right into
    the `shark-movies.html` file and actually add an inline style. Beneath the `h1`
    selector inside the `jaws` section, we have our paragraph, so let''s add our inline
    style to it. We''ll type `style="line-height: 1"`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '另一件要避免的事情是内联样式，我们可以认为它值1000分。内联样式将击败一切，包括具有ID的选择器。让我们再次定位段落来演示这一点。我们将直接进入`shark-movies.html`文件，并实际添加一个内联样式。在`jaws`部分的`h1`选择器下面，我们有我们的段落，所以让我们给它添加我们的内联样式。我们将输入`style="line-height:
    1"`：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we save this, we''ll return to our site and refresh the browser. Once
    we do this, we''ll see that `line-height` is using that inline style because it''s
    worth more. It''s heavier than all the other selectors we have in our style sheet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存这个时，我们会返回到我们的网站并刷新浏览器。一旦我们这样做，我们会看到`line-height`使用了内联样式，因为它的权重更大。它比我们样式表中的所有其他选择器都要重：
- en: '![](img/00125.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00125.jpeg)'
- en: 'So what beats inline styles? There is one ace up your sleeves: the `!important`
    declaration.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么能击败内联样式呢？你还有一个王牌：`!important`声明。
- en: The !important declaration
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '!important声明'
- en: 'Let''s see how the `!important` declaration works. We go back to this element
    selector in the CSS that''s just a paragraph:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`!important`声明是如何工作的。我们回到CSS中的这个元素选择器，它只是一个段落：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can go inside of the `line-height` value itself, then add `!important` to
    the end of that line. The line height will go up to `1.6`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进入`line-height`值本身，然后在该行的末尾添加`!important`。行高将增加到`1.6`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Following is the output of preceding code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![](img/00126.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00126.jpeg)'
- en: 'Let''s inspect this paragraph to make sure that it''s actually using the `!important`
    declaration. As you can see in Chrome''s DevTools, the inline style of 1 is being
    crossed out; we can see the ID worth 101 points with an element is also being
    crossed out:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这个段落，确保它实际上使用了`!important`声明。正如你在Chrome的DevTools中看到的那样，值为1的内联样式被划掉了；我们可以看到值为101分的ID与一个元素也被划掉了：
- en: '![](img/00127.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00127.jpeg)'
- en: 'If we scroll down the styles a little more, we see our class plus the element
    that is being crossed out too:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再往下滚动一点，我们会看到我们的类加上被划掉的元素：
- en: '![](img/00128.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00128.jpeg)'
- en: 'Scroll down a bit more and you''ll see that indeed it is using `line-height`
    from our element selector with the `!important` declaration:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再往下滚动一点，你会看到它确实是使用了带有`!important`声明的元素选择器的`line-height`：
- en: '![](img/00129.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00129.jpeg)'
- en: 'Adding the `!important` declaration can actually be thought of as being worth
    10,000 points, beating all the classes, IDs, and inline styles of that one property.
    Like you want to stay away from inline styles and IDs, you also want to stay away
    from using the `!important` declaration unless you have to for a really good reason.
    There is one other selector that is worth less than a point: the universal selector.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`!important`声明实际上可以被认为值为10,000分，击败了所有类、ID和内联样式的那个属性。就像你想远离内联样式和ID一样，你也想远离使用`!important`声明，除非你有一个非常好的理由。还有另一个选择器的权重小于1分：通用选择器。
- en: The universal selector
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用选择器
- en: 'The universal selector is just an asterisk. It''s worth zero points, so it
    only works when no other selector is in contention. Take out the `!important`
    declaration in our CSS. Above our other rule sets, let''s add a `*` as a selector
    and add a `font-size` of `9px` and `line-height` of `.5`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通用选择器只是一个星号。它值为零，因此只有在没有其他选择器竞争时才起作用。在我们的CSS中去掉`!important`声明。在我们的其他规则集之上，让我们添加一个`*`作为选择器，并添加`font-size`为`9px`和`line-height`为`.5`：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Technically, this star should apply to every element unless something more
    specific is defined. Anything beats the `*` selector. Now when you go to the site,
    you will see that once you take the `!important` declaration out, you fall back
    to your inline style''s `line-height` property:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这个星号应该应用于每个元素，除非定义了更具体的内容。任何东西都能打败`*`选择器。现在当您转到网站时，您会发现一旦去掉`!important`声明，您就会回到内联样式的`line-height`属性：
- en: '![](img/00130.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00130.jpeg)'
- en: 'In DevTools, we can see the universal selector is eventually getting crossed
    out. It''s not being applied to this paragraph text or really anything. It''s
    not being applied too much on the page:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevTools中，我们可以看到通用选择器最终被划掉了。它没有应用于这段文字或实际上任何东西。它在页面上没有被应用太多：
- en: '![](img/00131.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00131.jpeg)'
- en: 'Because its weight is worth so little, a lot of the times what you''ll see
    is the universal selector being used as a primitive reset. You could add the properties
    and values of `margin: 0` and `padding: 0` to the universal selector and something
    like that at the top of your style sheet. This would really reset the margin and
    padding down to zero for every single element:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '由于它的权重很少，很多时候你会看到通用选择器被用作原始重置。您可以将`margin: 0`和`padding: 0`的属性和值添加到通用选择器中，并将其放在样式表的顶部。这将真正将每个元素的边距和填充重置为零：'
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s revisit our chart showing the weights of different selectors. You''ve
    learned that you can think of `!important` as being worth 10,000 points and the
    universal selector as being worth zero points:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下显示不同选择器权重的图表。您已经学会了将`!important`视为价值10000分，通用选择器视为价值零分：
- en: '![](img/00132.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00132.jpeg)'
- en: Reality of the point system
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点系统的现实
- en: 'In reality though, the point system I''m describing is not completely truthful.
    Let''s say you have this selector of 11 elements: `div div p p p p p p p p p {
    ... }`. Using the system I already described, this is worth 11 points. And I described
    a class selector as being worth 10 points. However, the long element selector
    will never beat one single class: `.i-beat-any-number-of-elements`. So technically,
    elements are worth 0,0,0,1 and classes are worth 0,0,1,0, ID''s are worth 0,1,0,0,
    and inline styles are worth 1,0,0,0\. But! Pause for emphasis. You''d be having
    a pretty bad experience if you ever created a selector consisting of more than
    10 elements. That would be a very bad idea, and I recommend that you try not to
    go more that 3 or 4 at the very most. So, instead of thinking of elements as worth
    0,0,0,1 and classes as worth 0,0,1,0, we can think in the terms I described previously
    where classes are worth 10 points and elements are worth 1 point, and so on.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，我描述的点系统并不完全真实。假设您有这样一个选择器，包括11个元素：`div div p p p p p p p p p { ... }`。使用我已经描述的系统，这值得11分。我已经描述了类选择器的值为10分。然而，长元素选择器永远不会打败一个单一的类：`.i-beat-any-number-of-elements`。因此从技术上讲，元素的值为0,0,0,1，类的值为0,0,1,0，ID的值为0,1,0,0，内联样式的值为1,0,0,0。但是！停顿以强调。如果您创建了一个由超过10个元素组成的选择器，那么您将会有非常糟糕的体验。那将是一个非常糟糕的主意，我建议您尽量不要超过3或4个。因此，与其认为元素的值为0,0,0,1，类的值为0,0,1,0，我们可以根据我之前描述的术语来思考，其中类的值为10分，元素的值为1分，依此类推。
- en: Also, it is important to remember that authoring CSS at any reasonable scale
    is easier when you keep your selectors lightweight because you can then easily
    create modular, reusable classes in the form of a button. A big part of creating
    a modern website is overriding styles when you have to; you don't want to make
    this difficult. I strongly urge you to stick to classes and element selectors
    and be very conservative with your use of the `!important` declaration; steer
    clear of inline styles and IDs altogether.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，重要的是要记住，以任何合理的规模编写CSS都更容易，因为您可以轻松地创建模块化的可重用类，形式为按钮。创建现代网站的一个重要部分是在必要时覆盖样式；您不希望这变得困难。我强烈建议您坚持使用类和元素选择器，并且在使用`!important`声明时要非常保守；完全避免内联样式和ID。
- en: Transitions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡
- en: Understanding CSS specificity and how selectors overrule each other can alleviate
    a lot of frustration when using CSS. Now that we've got a better understanding
    of this, let's get back to our project and finish styling the buttons we have
    been working on. A button is incomplete unless it has a slick hover state with
    a smooth transition. We'll start this section by creating a hover state using
    the pseudo selector `:hover`. Then, we'll smooth it out with a transition before
    finally discussing when vendor prefixes are necessary.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 了解CSS的特异性以及选择器如何相互覆盖可以在使用CSS时减轻很多挫折感。现在我们对此有了更好的理解，让我们回到我们的项目，完成我们一直在工作的按钮的样式。按钮如果没有流畅的悬停状态和平滑的过渡就是不完整的。我们将通过使用伪选择器`:hover`来开始本节。然后，我们将通过过渡使其平滑，最后讨论供应商前缀何时是必要的。
- en: Creating a hover state
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建悬停状态
- en: 'At the moment, the buttons on our site are ghost buttons. They have no background
    color, a dark gray border, or dark gray text, as you can see in the following
    screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们网站上的按钮是幽灵按钮。它们没有背景颜色，有深灰色边框或深灰色文本，如下面的屏幕截图所示：
- en: '![](img/00133.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00133.jpeg)'
- en: 'We want to create a button that will have a dark gray background color and
    will show text in white when hovered. So let''s knock this out using the `:hover`
    pseudo class. Under the first existing `.button` rule set, add a new selector
    called `.button:hover`. Add `background-color: #333` and add the color of the
    text as white:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '我们想要创建一个按钮，当悬停时，它将具有深灰色背景颜色，并显示白色文本。因此，让我们使用`:hover`伪类来实现这一点。在第一个现有的`.button`规则集下，添加一个名为`.button:hover`的新选择器。添加`background-color:
    #333`，并将文本颜色设置为白色：'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice how I''m not using the full six characters of the hex code. If all six
    characters are the same, it''s alright if you use only three characters. Now if
    we save this and refresh, we will have our hover state when we hover the mouse
    over a button:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我没有使用十六进制代码的全部六个字符。如果所有六个字符都相同，只使用三个字符也是可以的。现在如果我们保存并刷新，当我们将鼠标悬停在按钮上时，我们将有悬停状态：
- en: '![](img/00134.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00134.jpeg)'
- en: The hover state's transition is very abrupt though; it's happening immediately.
    So the next step is to use the CSS3 transition property to smooth out the state
    change from no hover to hover.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，悬停状态的过渡非常突然；它立即发生。因此，下一步是使用CSS3过渡属性来平滑地从无悬停到悬停的状态变化。
- en: Using the transition property
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过渡属性
- en: 'We can choose which properties to transition, the duration of the transition,
    and the timing function of the transition. All three properties can be listed
    out separately as `transition-property`, `transition-duration`, and `transition-timing-function`;
    however, using the shorthand seems to be the easiest way. So we''ll type in `transition`
    as a new property in the `.button` rule set and use `.25s`, or a quarter of a
    second. And we''ll specify `all` for which properties we''ll be transitioning.
    We''ll use a `linear` timing function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择要过渡的属性、过渡的持续时间和过渡的时间函数。所有三个属性都可以分别列出为`transition-property`、`transition-duration`和`transition-timing-function`；然而，使用简写似乎是最简单的方法。因此，我们将在`.button`规则集中输入`transition`作为一个新属性，并使用`.25s`，或四分之一秒。我们将指定要过渡的所有属性。我们将使用`linear`时间函数：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now when we view this in the browser and as you move your mouse over each button,
    it is a much more gradual change:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们在浏览器中查看时，当你将鼠标移到每个按钮上时，变化会更加渐进：
- en: '![](img/00135.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00135.jpeg)'
- en: It takes 0.25 seconds to transition from dark gray to white text and the same
    thing for the background color and border. A quarter of a second seems to be just
    right, but you can experiment with a faster transition or a slower one. You could
    change it to one-tenth of a second and that would be good too, very fast, almost
    immediate. You could change it to one second, which would be ten times slower
    and probably way too slow. I find that 0.2 to 0.3 seconds tend to be that "Goldilocks-zone"
    for transitioning.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从深灰色过渡到白色文本以及背景颜色和边框需要0.25秒。四分之一秒似乎刚刚好，但你可以尝试更快或更慢的过渡。你可以将其更改为十分之一秒，那也很好，非常快，几乎立即。你可以将其更改为一秒，那将慢十倍，可能太慢了。我发现0.2到0.3秒似乎是过渡的“金发女孩区”。
- en: 'The next value we added after `0.25s` was `all`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0.25s`之后我们添加的下一个值是`all`：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This can be set to a certain property you want to transition or to all the
    properties. So, if you want to, you could set this to just `color`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以设置为你想要过渡的某个属性，或者所有属性。因此，如果你愿意，你可以将其设置为`color`：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The only thing that would transition would be the text color. If you try this,
    you''ll see how the button''s background color of dark gray transitions immediately,
    but the text color transitions over 0.25 seconds:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 只有文本颜色会过渡。如果你尝试这样做，你会看到按钮的深灰色背景立即过渡，但文本颜色会在0.25秒内过渡：
- en: '![](img/00136.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00136.jpeg)'
- en: If we wanted to, what we could add a comma separate list of properties to transition.
    In this case, I'm transitioning both `color` and `background-color`. One reason
    this is nice is if you need to transition more than one property, but not every
    property.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以添加一个逗号分隔的属性列表进行过渡。在这种情况下，我正在过渡`color`和`background-color`。这样做的一个原因是，如果你需要过渡多个属性，但不是每个属性。
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Because of this, both the background color and the text color will transition
    at the same speed. We accomplished this much more efficiently using the `all`
    keyword to transition both the text color and the background color. However, in
    some cases, it might be useful to keep properties'' transition at a different
    speed than the other. Let''s change the `background-color` to have a timing-function
    of 1.25 seconds:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，背景颜色和文本颜色将以相同的速度过渡。我们使用`all`关键字更有效地实现了这一点，以过渡文本颜色和背景颜色。然而，在某些情况下，保持属性的过渡速度与其他属性不同可能是有用的。让我们将`background-color`的过渡时间函数更改为1.25秒：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The color transition would now be faster than the background color transition.
    This is not super useful in our immediate situation, so let''s change it back
    to the way we had it earlier:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文本颜色的过渡速度将比背景颜色的过渡速度更快。在我们目前的情况下，这并不是特别有用，所以让我们改回到之前的方式：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In our case, the timing function is set to `linear`. We can also use `ease`,
    `ease-in`, `ease-out`, and `ease-in-out`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，时间函数设置为`linear`。我们还可以使用`ease`、`ease-in`、`ease-out`和`ease-in-out`：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For short transitions like the one we're using, the linear method or the default
    will work just fine; any of them will work just fine. It's actually quite difficult
    to tell the difference between `ease`, `ease-in`, `ease-in-out`, and `linear`
    with a really fast transition like this. I recommend experimenting with each one
    to determine which one suits your needs best. You may need to alter the duration
    of the transition to clearly see the effect.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们正在使用的短过渡，线性方法或默认方法都可以正常工作；任何一种都可以正常工作。在这种非常快的过渡中，实际上很难区分`ease`、`ease-in`、`ease-in-out`和`linear`之间的区别。我建议尝试每一种方法，以确定哪一种最适合你的需求。你可能需要改变过渡的持续时间才能清楚地看到效果。
- en: 'Okay, so the transition adds a nice little experience layer to our buttons
    when hovered. We can also transition the active and focus states. Focus is the
    state when your user tabs to the button using their *Tab* key instead of hovering
    their mouse pointer over the button. I like to make all hover states the same
    as the focus state. This is accomplished easily by adding the selector using a
    comma. So just like we have `.button:hover`, we can do `.button:focus`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以当悬停时，过渡为我们的按钮添加了一个很好的体验层。我们还可以过渡活动和焦点状态。焦点是当用户使用*Tab*键而不是将鼠标指针悬停在按钮上时，按钮的状态。我喜欢使所有悬停状态与焦点状态相同。这很容易通过添加逗号来添加选择器来实现。所以就像我们有`.button:hover`一样，我们可以做`.button:focus`：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you add this, the focus state will also be triggered. When you hit the *Tab*
    key and the *Shift* + *Tab* key to move from button to button, their hover states
    will also be their focus states. That's nice and good for accessibility reasons.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您添加这个，焦点状态也会被触发。当您按*Tab*键和*Shift* + *Tab*键从一个按钮移动到另一个按钮时，它们的悬停状态也将是它们的焦点状态。出于可访问性原因，这是很好的。
- en: Vendor prefixes
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商前缀
- en: 'As mentioned earlier, transitions are a CSS3 property. All modern (major) browsers
    support them: Chrome, Firefox, Safari, Internet Explorer, and Edge. Older browsers,
    such as IE9 and below, don''t support them. They still get the hover state, but
    it will be abrupt without any transition. This isn''t a problem as transitions
    typically aren''t a core feature of your website, but more of an added experience
    level. Still, they are CSS3, and we can get a little more mileage out of them
    by including the vendor prefixed versions. Traditionally, the `-webkit-` prefix
    was used for Safari and Chrome; `-moz-` was used for Firefox and `-o-` for Opera.
    However, Firefox and Opera also now use `-webkit-`, so technically you don''t
    need `-moz-` and `-o-` as much as you used to need them; however, for older versions
    of these browsers, you can still include them:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，过渡是CSS3的一个属性。所有现代（主要）浏览器都支持它们：Chrome、Firefox、Safari、Internet Explorer和Edge。旧版浏览器，如IE9及以下版本，不支持它们。它们仍然会得到悬停状态，但没有任何过渡，会显得突兀。这并不是一个问题，因为过渡通常不是您网站的核心功能，而更多的是一个附加的体验层。不过，它们是CSS3，我们可以通过包括供应商前缀版本来更多地利用它们。传统上，`-webkit-`前缀用于Safari和Chrome；`-moz-`用于Firefox和`-o-`用于Opera。然而，Firefox和Opera现在也使用`-webkit-`，所以从技术上讲，您不需要`-moz-`和`-o-`，就像您以前需要它们一样；然而，对于这些浏览器的旧版本，您仍然可以包括它们：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or you can get by with half the CSS and still have 99% of all users see your
    transition just with the `-webkit-` vendor prefix:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以通过一半的CSS，仍然让99%的用户看到您的过渡效果，只需使用`-webkit-`供应商前缀：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Transitions are a great feature of CSS3, and they add an extra layer of nice-ness
    to the user experience. So far, we''ve created a hover state for our ghost buttons
    and used the transition effect to smooth out the state change. We then added vendor
    prefixes to support older browsers. Next, we''ll look at another feature of CSS3:
    transforms.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡是CSS3的一个很棒的特性，它为用户体验增加了一个额外的层次。到目前为止，我们已经为我们的按钮创建了一个悬停状态，并使用过渡效果来平滑状态变化。然后，我们添加了供应商前缀以支持旧版浏览器。接下来，我们将看看CSS3的另一个特性：变换。
- en: Transforms
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换
- en: Like transitions, transforms are a feature of CSS3\. They have a little more
    support though as all major browsers, including IE9 and up, provide support. Transforms
    allow you to do several things, including rotate, scale, and translate. We'll
    look at a few practical examples in this section. First, we'll apply a scale to
    our button, then we'll do a translation, followed by a unique use of the rotate
    value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与过渡一样，变换是CSS3的一个特性。不过它们得到了更多的支持，因为所有主要的浏览器，包括IE9及以上版本，都提供了支持。变换允许您做一些事情，包括旋转、缩放和平移。在本节中，我们将看一些实际的例子。首先，我们将为我们的按钮应用一个比例，然后我们将进行平移，然后是对旋转值的独特使用。
- en: Applying a scale to our button
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将比例应用到我们的按钮
- en: 'Let''s jump right in where we left off with our button in the CSS. Underneath
    the transitions, let''s add a transform. We''ll add `transform: scale(.9, .9)`,
    like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们从我们在CSS中留下的按钮继续下去。在过渡下面，让我们添加一个transform。我们将添加`transform: scale(.9, .9)`，就像这样：'
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice that by using a value of `.9` for both the width and height, we''re
    actually making our buttons smaller, nine-tenths of their original size:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过使用`.9`作为宽度和高度的值，我们实际上使我们的按钮变小了，原始尺寸的九分之一：
- en: '![](img/00137.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00137.jpeg)'
- en: 'Let''s add the `scale` property again to the buttons'' hover/focus state to
    get even neater interaction:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次将`scale`属性添加到按钮的悬停/焦点状态，以获得更整洁的交互：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The scale value is a css function that takes a width and height respectively.
    1.1 being 1.1x the original size.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 比例值是一个css函数，分别采用宽度和高度。1.1表示原始尺寸的1.1倍。
- en: 'When you save and refresh, you will see that the button actually gets much
    bigger as you hover over it. It''s a nice smooth transition because we already
    have the transition property applied:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当您保存并刷新时，您会看到当您悬停在按钮上时，按钮实际上会变得更大。这是一个很好的平滑过渡，因为我们已经应用了过渡属性：
- en: '![](img/00138.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00138.jpeg)'
- en: Using the translate function
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用translate函数
- en: 'Let''s go one step further and also use the `translate` function. This will
    be added to the same line, or declaration, as the `transform: scale` code that
    we just wrote. The `translate` function can move the element to the left, right,
    top, or bottom. As you can see in the following line of code, the first value
    is for left and right movements. But we''re not going to move it to left or right,
    so we''ll use `0`. The second value is for the top and bottom movement. I''m actually
    going to push it up by `-5px`. If I were to use a positive value, that would push
    it down:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们再进一步，也使用`translate`函数。这将添加到与我们刚刚编写的`transform: scale`代码相同的行或声明中。`translate`函数可以将元素移动到左侧、右侧、顶部或底部。正如您在下一行代码中所看到的，第一个值是左右移动的值。但我们不打算将其向左或向右移动，所以我们将使用`0`。第二个值是上下移动的值。我实际上会将其向上推`-5px`。如果我使用正值，那将会将其向下推：'
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now when we refresh and hover over a button, we will see it does nudge up slightly,
    five pixels to be exact:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们刷新并悬停在按钮上时，我们会看到它确实稍微向上移动了，确切地说是五个像素：
- en: '![](img/00139.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00139.jpeg)'
- en: 'Notice that I separated the two functions with a space. The syntax is very
    important here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我用一个空格分隔了两个函数。这里的语法非常重要：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You might naturally reach to add a comma there, but if I were to actually add
    a comma between the two functions, `scale` and `translate`, we would get no interaction
    at all as far as the `transform` goes because this syntax is incorrect:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会自然地在这里添加一个逗号，但如果我实际上在两个函数`scale`和`translate`之间添加逗号，我们将得不到任何关于`transform`的交互，因为这个语法是不正确的：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using the rotate value
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用旋转值
- en: 'There is another transform function that I''d like to go over, but if we add
    anymore flair to these buttons they will be far too distracting. Instead, let''s
    add a very interesting hover effect to the movie images on the movie page. The
    images next to each movie title are actually external links to the movie:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个变换函数，我想介绍一下，但如果我们给这些按钮添加更多的装饰，它们将会分散注意力。相反，让我们在电影页面上的电影图像上添加一个非常有趣的悬停效果。每个电影标题旁边的图像实际上是指向电影的外部链接：
- en: '![](img/00140.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00140.jpeg)'
- en: 'However, I want a visual interaction to take place upon hover, which really
    indicates that this is a hyperlink, or at least letting the user know there is
    some type of action that can be performed. Let''s use `transform: rotate()` to
    make this happen.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，我希望在悬停时发生视觉交互，这真的表明这是一个超链接，或者至少让用户知道有一些可以执行的操作。让我们使用`transform: rotate()`来实现这一点。'
- en: 'This is what we''re aiming for in our final site. A white frame with an image
    inside of it, and the hover effect is a rotate inside of this white frame:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在最终网站中的目标。一个白色框架，里面有一张图像，悬停效果是在这个白色框架内旋转：
- en: '![](img/00141.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00141.jpeg)'
- en: 'As you can see in the following figure, when you hover over it, the image rotates
    and gets scaled slightly larger than normal - and - even though the image is scaling
    larger, it doesn''t overflow it''s parent container:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下图中所看到的，当你悬停在图像上时，图像会旋转并略微放大——即使图像放大了，它也不会溢出其父容器：
- en: '![](img/00142.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00142.jpeg)'
- en: 'We need to have an element that wraps around our image in order to accomplish
    this. We do have this—an anchor tag with the class of `figure` that is the parent
    of each image. This is where we''ll add this thick white border. We''re going
    to need to add `overflow: hidden` to the `a` tag because when we scale the image
    more and rotate it, the overflow hidden prevents it from popping out of its container.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要有一个元素来包裹我们的图像，以实现这一点。我们确实有这个——一个带有`figure`类的锚标签，它是每个图像的父元素。这就是我们将添加这个厚厚的白色边框的地方。我们需要在`a`标签中添加`overflow:
    hidden`，因为当我们对图像进行缩放和旋转时，溢出隐藏可以防止它从容器中弹出。'
- en: 'Let''s get to work. The `.content-block .figure` selector already exists, so
    let''s add the white border to it first. I''m going to wait to add the `overflow:
    hidden` until a little bit later. First, let''s make the `border` property `10px`,
    `solid`, and `white`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们开始工作。`.content-block .figure`选择器已经存在，所以让我们首先给它添加白色边框。我会稍后再添加`overflow: hidden`。首先，让我们将`border`属性设置为`10px`，`solid`和`white`：'
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Before we refresh our current site, this is what it looks like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刷新当前网站之前，它看起来是这样的：
- en: '![](img/00140.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00140.jpeg)'
- en: 'When we refresh the browser, we get the white border:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们刷新浏览器时，我们得到了白色边框：
- en: '![](img/00143.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00143.jpeg)'
- en: As you can see, we get a gap between the bottom of the image and the border.
    We can rectify this in two ways. We can set the container such that it has the
    exact height of the image; we can do this using the `height` property, which isn't
    the best solution. Alternatively, we can float the image to the left. To do this,
    we can use the `float` property as it's easy enough and a stronger solution. However,
    we want to target the image itself that's inside of `.content-block .figure`.
    So let's do that and float it left.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们得到了图像底部和边框之间的间隙。我们可以通过两种方式来纠正这个问题。我们可以设置容器的高度与图像的高度完全一致；我们可以使用`height`属性来实现这一点，但这并不是最好的解决方案。或者，我们可以将图像浮动到左侧。为此，我们可以使用`float`属性，因为这是足够简单和更强大的解决方案。但是，我们要针对的是`.content-block
    .figure`内部的图像本身。所以让我们这样做，并将其浮动到左侧。
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we refresh the browser now, we will see this gets rid of that gap between
    the image and the border:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新浏览器，我们将看到这样可以消除图像和边框之间的间隙：
- en: '![](img/00144.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00144.jpeg)'
- en: 'We''re going to add `rotate` and `scale` to the image as well. The `rotate`
    function is a little different than `scale` and `transition` as it doesn''t take
    two parameters inside the function. It just takes one: the number of degrees you
    want to rotate. In our case, this is `15deg`. So we''ll create a new selector
    for hovering over the image:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在图像上添加`rotate`和`scale`。`rotate`函数与`scale`和`transition`有些不同，因为它在函数内部不需要两个参数。它只需要一个：你想要旋转的角度。在我们的例子中，这是`15deg`。所以我们将创建一个新的选择器，用于悬停在图像上：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, add the scale: `1.25` horizontally and `1.25` vertically, remembering
    to *not* add a comma between the two functions. Here''s the code for this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在水平方向和垂直方向分别添加缩放：`1.25`，记住*不要*在两个函数之间添加逗号。这是这个代码：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Save all this, go to the site, and now when you hover, the image pops right
    out of its container:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有这些，转到网站，现在当你悬停时，图像会立即从容器中弹出：
- en: '![](img/00145.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00145.jpeg)'
- en: 'Let''s add the `overflow:hidden` to the `parent .figure` selector. This is
    exactly what `overflow:hidden` is for:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`parent .figure`选择器中添加`overflow:hidden`。这正是`overflow:hidden`的用途：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we go to the site now, we see that it works fine. We get the rotate and
    we get the scale a little bit larger and more contained inside of its container
    with no overflow:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在去网站，我们看到它工作正常。我们得到了旋转，我们得到了稍微放大并且更加包含在其容器内而没有溢出的缩放：
- en: '![](img/00146.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00146.jpeg)'
- en: 'The change from the default state to hover is still way too abrupt though.
    Let''s add a `transition` property in order to make it a lot smoother. We want
    to add the transition to the non-hover state of the image. Let''s add a transition
    of a quarter second:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从默认状态到悬停状态的变化仍然太突然了。让我们添加一个`transition`属性，以使其更加平滑。我们希望将过渡效果添加到图像的非悬停状态。让我们添加一个四分之一秒的过渡效果：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we have a smooth transition from the default state to the hover state:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从默认状态平稳过渡到悬停状态：
- en: '![](img/00142.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00142.jpeg)'
- en: Adding vendor prefixes and :focus states
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加供应商前缀和:focus状态
- en: The last thing we have to do is add vendor prefixes to our `transform` and `transition`
    properties. Like with transition, I'm going to add the `-webkit-` prefixed version
    of the declaration in order to support older versions of Chrome, Safari, Firefox,
    and Opera. And also I'm going to add in the `-ms-` prefixed version to support
    Internet Explorer 9.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是为我们的`transform`和`transition`属性添加供应商前缀。就像过渡一样，我将添加声明的`-webkit-`前缀版本，以支持较旧版本的Chrome、Safari、Firefox和Opera。而且我还将添加`-ms-`前缀版本，以支持Internet
    Explorer 9。
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Maybe it''s worth emphasizing that with the `transform` property, I added the
    `-ms-` vendor prefix. It just so happens that IE9 will support transforms if you
    provide it with the `-ms-` prefix:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 也许值得强调的是，使用`transform`属性时，我添加了`-ms-`供应商前缀。碰巧IE9将支持变换，如果您为其提供`-ms-`前缀：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: However, I didn't do this with transitions because adding the `-ms-` vendor
    prefix wouldn't make any difference as IE9 just wasn't built with transition support.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我没有使用过渡来做这个，因为添加`-ms-`供应商前缀不会有任何区别，因为IE9根本就不支持过渡。
- en: 'Let''s also add the `:focus` state to make it more web accessible:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也添加`:focus`状态，以使其更具网络可访问性：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Okay, that wraps up our brief look at transitions and transforms. We took our
    experience layer to another level by adding the different types of transforms
    coupled with transitions to smooth out transformations. There are other transforms
    available that we didn't go over, such as `skew`, `translate x`, `translate y`,
    `scale x`, `scale y`, and so on. There are also 3D transformations that really
    take it to another level that are totally worth exploring as browser support has
    gotten much better. Next, we'll continue on our style train by styling the main
    call-to-action button on our site.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就结束了我们对过渡和变换的简要介绍。通过添加不同类型的变换以及过渡来平滑转换，我们将我们的体验层提升到了另一个水平。还有其他可用的变换，我们没有介绍，比如`skew`、`translate
    x`、`translate y`、`scale x`、`scale y`等。还有真正将其提升到另一个水平的3D变换，这绝对值得探索，因为浏览器支持已经变得更好了。接下来，我们将继续通过为站点上的主要呼吁行动按钮进行样式设置来继续我们的样式培训。
- en: Styling the call-to-action button
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计呼吁行动的按钮
- en: We've really come a long way in this chapter with regard to styling buttons.
    Now it's time to add one more. In the final site, we also have a call-to-action
    button on the home page that needs to be built. In this section, let's walk through
    each step of styling the call-to-action button. First, we'll add the HTML, then
    position it properly and add the appropriate CSS; finally, we'll add a nice hover
    effect to it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们在样式化按钮方面取得了长足的进步。现在是时候再添加一个了。在最终站点中，我们还有一个需要构建的主页呼吁行动按钮。在本节中，让我们逐步介绍样式化呼吁行动按钮的每个步骤。首先，我们将添加HTML，然后正确定位它并添加适当的CSS；最后，我们将为其添加一个漂亮的悬停效果。
- en: 'Here''s our current site:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们当前的站点：
- en: '![](img/00147.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00147.jpeg)'
- en: 'The following is the final site that we''re aiming for, and the Go Premium
    call-to-action button is what we''ll be creating:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的最终目标站点，我们将创建Go Premium呼吁行动按钮：
- en: '![](img/00148.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00148.jpeg)'
- en: Adding the HTML
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加HTML
- en: 'Let''s add the markup t0 our `index.html` file. In the `Intro Section` use
    an anchor tag for the button with the text `Go Premium`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将标记添加到我们的`index.html`文件中。在`Intro Section`中使用一个按钮的锚标记，文本为`Go Premium`：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Right underneath this, add a `p` tag with the reasons why you need to click
    on this soon-to-be gigantic call-to-action button. This paragraph tag will also
    have an anchor in it to learn more about our fictional premium offerings:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在此下方，添加一个`p`标记，其中列出了您需要尽快单击的原因，即将成为巨大的呼吁行动按钮。这个段落标记也将有一个锚点，以了解有关我们虚构的高级产品的更多信息：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we''re really creating a two-column layout in this top section. We need
    to float the left chunk of the content to the left and the Go Premium section
    of content to the right. The best way to do this is to wrap both in a `div` tag
    with a unique class name, add widths to each, and float both of them. So start
    by adding the markup:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们真的在这个顶部部分创建了一个两列布局。我们需要将内容的左侧块浮动到左侧，将内容的高级部分浮动到右侧。这样做的最佳方法是将两者都包装在一个具有唯一类名的`div`标记中，为每个添加宽度，并将它们都浮动。所以首先添加标记：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When we apply this and have a look at our site, we see the call-to-action button
    lives where we''d expect it to, directly under the intro content because we haven''t
    added the layout-specific CSS yet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用这个并查看我们的网站时，我们看到呼吁行动的按钮位于我们期望的位置，直接在介绍内容下面，因为我们还没有添加特定于布局的CSS：
- en: '![](img/00149.jpeg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00149.jpeg)'
- en: Let's dive into the CSS and change this.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究CSS并进行更改。
- en: Positioning using CSS
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS定位
- en: 'Positioning should be nothing new for us here. Just create a `Go Premium` section
    in our CSS with the following rule sets:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里对于我们来说，定位应该不是什么新鲜事。只需在我们的CSS中创建一个`Go Premium`部分，其中包含以下规则集：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Both our `.intro-content` and `.go-premium` areas have a set width defined.
    We should also put `margin-right` on the intro content to add some space between
    the two. Both of them are floated to the left. So what this code really accomplishes
    is this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`.intro-content`和`.go-premium`区域都有定义的固定宽度。我们还应该在介绍内容上添加`margin-right`，以在两者之间添加一些空间。它们都向左浮动。所以这段代码真正实现的是这样的：
- en: '![](img/00150.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00150.jpeg)'
- en: We get our introductory content on the left-hand side and our `Go Premium` content
    on the right. We have a few problems here, though. The go premium stuff is way
    too high on the page and then below that, our content is encroaching and flowing
    to the right of the intro content. That's the problem we face with the float not
    clearing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在左侧获取我们的介绍性内容，右侧是我们的`Go Premium`内容。然而，我们在这里有一些问题。高级内容在页面上太高了，然后在下面，我们的内容侵入并流向介绍内容的右侧。这就是我们面临的浮动不清除的问题。
- en: 'A top margin should fix our first problem, so add `margin-top` of `125px` to
    the `.go-premium` selector:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部边距应该解决我们的第一个问题，所以在`.go-premium`选择器中添加`margin-top`为`125px`：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Following is the output of preceding code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![](img/00151.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00151.jpeg)'
- en: 'Our second problem is that the content is actually flowing around the floated
    element and kind of creeping up on our Go Premium button. We can solve this using
    the clearfix hack class on the container that wraps the entire top section. Look
    at the intro section in our `index.html` file. That entire top section, both the
    intro content and go premium, is wrapped inside of a wrapper:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个问题是内容实际上围绕浮动元素流动，并且在我们的Go Premium按钮上方有点侵入。我们可以在包裹整个顶部部分的容器上使用清除浮动hack类来解决这个问题。查看我们`index.html`文件中的介绍部分。整个顶部部分，包括介绍内容和go
    premium，都包裹在一个包装器内：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s add the clearfix hack to this wrapper, using our `grouping` class, which
    will fix the problem on our site:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个包装器中添加清除浮动的hack，使用我们的`grouping`类，这将解决我们网站上的问题：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Following is the output of preceding code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![](img/00152.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00152.jpeg)'
- en: Styling the button
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮样式
- en: 'Let''s go ahead and style the button. For styling purposes, let''s add a class
    of `call-to-action` to our go premium anchor tag:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续样式化按钮。为了样式化目的，让我们给我们的go premium锚点添加一个`call-to-action`类：
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Looking quickly at the final site, this is what we were aiming for with our
    Go Premium button. There''s a white border, white text, blue gradient, and plenty
    of padding around it:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看最终网站，这就是我们在Go Premium按钮上的目标。有一个白色边框，白色文本，蓝色渐变，并且周围有足够的填充：
- en: '![](img/00153.jpeg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00153.jpeg)'
- en: 'The hover state removes the gradient and changes the text color and border
    color to blue:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停状态去除了渐变，并将文本颜色和边框颜色更改为蓝色：
- en: '![](img/00154.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00154.jpeg)'
- en: Note that we won't be able to use this exact web font pictured above. We'll
    use a solid blue background instead of the gradient for now as we'll come back
    to it in the next section and add the gradient as well as return to the font later
    in this book.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将无法使用上面图片中的确切网络字体。我们暂时将使用纯蓝色背景代替渐变，因为我们将在下一节回到它，并在本书的后面再次添加渐变和字体。
- en: 'In the CSS, underneath the `.go-premium` rule set, add a `.call-to-action`
    selector and a 2px solid white border. We''ll also make the text color white and
    make the background color blue. Add padding of `25px` to the top and bottom and
    zero to the left and right positions because we''re going to end up centering
    the text:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，在`.go-premium`规则集下面，添加一个`.call-to-action`选择器和一个2像素的白色实线边框。我们还将使文本颜色为白色，背景颜色为蓝色。在顶部和底部添加`25px`的填充，左右位置为零，因为我们最终会将文本居中：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now our button is kind of funky looking because the anchor is an inline element,
    and its padding is not pushing down against the text below it. That''s just how
    inline elements roll:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的按钮看起来有点奇怪，因为锚点是内联元素，它的填充没有向下推挤下面的文本。这就是内联元素的工作方式：
- en: '![](img/00155.jpeg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00155.jpeg)'
- en: 'The easiest way to fix this is to change the display to `block`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方法是将显示更改为`block`：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Following is the output of preceding code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![](img/00156.jpeg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00156.jpeg)'
- en: 'We need to align the text to the center and add rounded corners now. Add these
    like so:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将文本对齐到中心并添加圆角。像这样添加：
- en: '[PRE59]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We don''t need to add vendor prefixes to the border radius anymore, as this
    CSS3 property specification is more mature than the transform and transition properties
    that both require vendor prefixes. Refresh the browser and you will see our button
    is starting to look pretty good:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要为边框半径添加供应商前缀，因为这个CSS3属性规范比变换和过渡属性更成熟。刷新浏览器，你会看到我们的按钮开始变得非常漂亮：
- en: '![](img/00157.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00157.jpeg)'
- en: 'Now we can increase the font size and font weight:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以增加字体大小和字重：
- en: '[PRE60]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Following is the output of preceding code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![](img/00158.jpeg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00158.jpeg)'
- en: 'Our button is looking awesome. Let''s add the hover styles. Add a `:hover`
    and `:focus` selector to the CSS. We need to change the color of the border and
    the text from white to blue; `border-color` will take care of this. Using the
    `background` property with the keyword of `none` will get rid of the background
    color:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的按钮看起来很棒。让我们添加悬停样式。在CSS中添加`:hover`和`:focus`选择器。我们需要将边框和文本的颜色从白色更改为蓝色；`border-color`会处理这个问题。使用关键字`none`的`background`属性将去除背景颜色：
- en: '[PRE61]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we now go to our site and hover over or focus our button, we will see a
    different treatment on our call-to-action button:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在转到我们的网站，并悬停或聚焦在我们的按钮上，我们将看到呼吁行动按钮的不同处理方式：
- en: '![](img/00159.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00159.jpeg)'
- en: 'Lastly, let''s add in a transition to make the state change more subtle. Add
    `transition: all .25s ease-in-out` with vendor prefixes to the non-hover state
    of the button in our CSS:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，让我们添加一个过渡效果，使状态变化更加微妙。在我们的CSS中，为按钮的非悬停状态添加`transition: all .25s ease-in-out`和供应商前缀：'
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With the transition added, we have a fully styled call-to-action button (minus
    the correct web font and the gradient).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了过渡效果后，我们有了一个完全样式的呼吁行动按钮（减去正确的网络字体和渐变）。
- en: We've now positioned our call-to-action area and styled the button itself to
    look extra awesome. Next, let's finish the call-to-action button and learn a little
    more about CSS gradients.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定位了我们的呼吁行动区域，并将按钮本身样式化得非常棒。接下来，让我们完成呼吁行动按钮，并学习更多关于CSS渐变的知识。
- en: Gradients
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐变
- en: Our big ol' call-to-action button is almost complete. We just need to add a
    gradient, which, like transforms, transitions, and border-radius, is a feature
    in CSS3.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大呼吁行动按钮几乎完成了。我们只需要添加一个渐变，就像变换、过渡和边框半径一样，这是CSS3中的一个特性。
- en: Using the ultimate CSS gradient generator
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用终极CSS渐变生成器
- en: 'Since the gradient specification and syntax is somewhat lengthy and isn''t
    consistent between browsers, the easiest way to use it is through an app that
    will create the CSS output for us. Normally, I shy away from things such as these,
    as I prefer to write my own code, but I will make an exception for gradients.
    The ultimate CSS gradient generator seems to work very well for me. The site is
    [www.colorzilla.com/gradient-editor/](http://www.colorzilla.com/gradient-editor/).
    The gradient that we''re shooting for is fairly simple. It goes from light blue
    at the top to darker blue at the bottom:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于渐变规范和语法有些冗长，并且在各个浏览器之间不一致，使用它的最简单方法是通过一个可以为我们创建CSS输出的应用程序。通常，我会避开诸如此类的东西，因为我更喜欢编写自己的代码，但是我会为渐变做个例外。最终的CSS渐变生成器似乎对我非常有效。该网站是[www.colorzilla.com/gradient-editor/](http://www.colorzilla.com/gradient-editor/)。我们要实现的渐变相当简单。它从顶部的浅蓝色到底部的深蓝色：
- en: '![](img/00160.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00160.jpeg)'
- en: 'Let''s go to [www.colorzilla.com/gradient-editor/](http://www.colorzilla.com/gradient-editor/).
    The tool defaults to something like this. At the top right, there is even a preview:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去[www.colorzilla.com/gradient-editor/](http://www.colorzilla.com/gradient-editor/)。该工具默认为以下内容。右上角甚至有一个预览：
- en: '![](img/00161.jpeg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00161.jpeg)'
- en: 'There are four color stops by default and all we need are two. So click on
    the two stops in the middle of the gradient bar and delete both of them. Clicking
    on a color stop reveals a new set of controls, including a delete button:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下有四个颜色停止点，我们只需要两个。因此，点击渐变条中间的两个停止点并删除它们。单击颜色停止点会显示一组新的控件，包括删除按钮：
- en: '![](img/00162.jpeg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00162.jpeg)'
- en: 'Our gradient bar should look as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的渐变条应该如下所示：
- en: '![](img/00163.jpeg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00163.jpeg)'
- en: 'Now double-click on the first stop. Your screen should look like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在双击第一个停止点。您的屏幕应该是这样的：
- en: '![](img/00164.jpeg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00164.jpeg)'
- en: 'Now we type in the color that we''re going to use, which is `33D3FF`, and hit
    OK. It''s a nice Photoshop-like interface all around:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们输入要使用的颜色，即`33D3FF`，然后点击确定。整体上是一个很好的类似Photoshop的界面：
- en: '![](img/00165.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00165.jpeg)'
- en: 'Now, double-click on the second color stop and add the `00718e` color:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，双击第二个颜色停止点，并添加`00718e`颜色：
- en: '![](img/00166.jpeg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00166.jpeg)'
- en: 'This color and gradient look like what we''ve been aiming for. But we can move
    the Color stop up and down the gradient bar a little bit to change the gradient.
    I''m going to drag it about a third of the way over:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这种颜色和渐变看起来像我们一直在追求的。但是我们可以稍微移动颜色停止点，改变渐变。我将它拖到大约三分之一的位置：
- en: '![](img/00167.jpeg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00167.jpeg)'
- en: 'We can also adjust the height of the preview display to look more like the
    height of our actual call-to-action button by changing the size to 370 x 100:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过更改大小为370 x 100来调整预览显示的高度，使其更像我们实际的CTA按钮的高度：
- en: '![](img/00168.jpeg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00168.jpeg)'
- en: 'The CSS output is right underneath the preview bar. We can just copy it by
    clicking on copy. Switch over to our CSS file and paste it inside of our call-to-action
    selector:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: CSS输出就在预览栏下面。我们只需点击复制即可复制它。切换到我们的CSS文件，并将其粘贴到我们的CTA选择器内：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The CSS output of the ultimate gradient generator
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终渐变生成器的CSS输出
- en: 'The ultimate gradient generator created eight different properties. Wow! The
    first is just the background color for older browsers that don''t support the
    gradient''s syntax:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的渐变生成器创建了八个不同的属性。哇！第一个只是旧版浏览器的背景颜色，不支持渐变的语法：
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We actually want to change that to `#0072AE` because that''s our official branded
    color for this site. So add that and delete the `background-color: #0072AE` property
    mentioned earlier in the declaration:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，我们想将其更改为`#0072AE`，因为这是我们网站的官方品牌颜色。因此添加并删除前面在声明中提到的`background-color: #0072AE`属性：'
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is a ton of generated CSS. If we take a closer look at some of these, I
    wonder how many folks out there are using Firefox 3-15, given that the current
    version is 55? And likewise for Chrome 10-25 when the current version is 60?
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大量生成的CSS。如果我们仔细看一些这些，我想知道有多少人在使用Firefox 3-15，考虑到当前版本是55？同样，对于Chrome 10-25，当前版本是60？
- en: '[PRE66]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Also, both Chrome and Firefox are evergreen browsers, meaning they automatically
    update themselves silently without prompting the user.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Chrome和Firefox都是无限期更新的浏览器，这意味着它们会在不提示用户的情况下自动更新自己。
- en: So, I need a second opinion on all these prefixed versions. Let's see what "Autoprefixer
    CSS Online" says about this, [https://autoprefixer.github.io/](https://autoprefixer.github.io/).
    Autoprefixer bills itself as a tool for managing vendor prefixes. It adds missing
    prefixes and deletes obsolete ones... based on current data on the popularity
    of browsers and support for vendor prefixes by those browsers.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我需要对所有这些前缀版本进行第二意见。让我们看看“Autoprefixer CSS Online”对此的看法，[https://autoprefixer.github.io/](https://autoprefixer.github.io/)。Autoprefixer自称为管理供应商前缀的工具。它根据当前浏览器的流行度和对供应商前缀的支持来添加缺少的前缀并删除过时的前缀。
- en: I'll type in the non-prefixed declaration on the left-side of the Autoprefixer
    tool and it will spit out what vendor prefixes are needed based on the browser
    popularity criteria I provide. I want my gradients to show up in all browsers
    with greater than .1% of market share.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在Autoprefixer工具的左侧输入非前缀声明，它将根据我提供的浏览器流行度标准输出需要的供应商前缀。我希望我的渐变在市场份额大于0.1%的所有浏览器中显示。
- en: '![](img/00169.jpeg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00169.jpeg)'
- en: 'All that leaves is the `-webkit-` vendor prefix and the non-prefixed or W3C
    standard version:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只有`-webkit-`供应商前缀和非前缀或W3C标准版本：
- en: '[PRE67]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'So let''s update our rule set:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们更新我们的规则集：
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: I don't know about you, but I feel really good about what we just did!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你，但我对我们刚刚做的事情感到非常满意！
- en: 'We''ll save this and go to our button. Before a browser refresh, you can see
    it''s a solid color:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存这个并转到我们的按钮。在浏览器刷新之前，您可以看到它是纯色的：
- en: '![](img/00170.jpeg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: When we refresh, we get our gradient, as shown in the following figure. This
    is very good. It is going to work in all browsers with more than .1% market share.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们刷新时，我们得到了我们的渐变，如下图所示。这非常好。它将在拥有超过0.1%市场份额的所有浏览器中运行。
- en: '![](img/00171.jpeg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00171.jpeg)'
- en: And just to be very clear, I didn't say 1% market share. I said .1% market share.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 并且要非常清楚，我并没有说1%的市场份额。我说的是0.1%的市场份额。
- en: In this section, we successfully styled the call-to-action button and applied
    the gradient using a program that handles the hard stuff for us, allowing us to
    work that much faster.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们成功地为呼吁行动的按钮添加了样式，并使用了一个处理繁重工作的程序来应用渐变，这让我们能够更快地工作。
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to create buttons with modular CSS and use
    multiple classes to change the appearance of our buttons. You also discovered
    how CSS specificity works and how selectors can overrule each other. You now know
    how to keep your CSS lightweight and manageable. Finally, you learned how to use
    transitions, hover states, transforms, and gradients to style our buttons.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何使用模块化CSS创建按钮，并使用多个类来改变按钮的外观。您还了解了CSS的特异性如何工作，以及选择器如何相互覆盖。您现在知道如何保持CSS的轻量和可管理性。最后，您学会了如何使用过渡、悬停状态、变换和渐变来为我们的按钮添加样式。
- en: In the next chapter, we'll move on to creating our primary navigation tool.
    By doing this, you'll learn about CSS positioning, CSS3 pseudo classes, CSS3 animations,
    and how you can create a drop-down menu purely in CSS. This was a lot of fun!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续创建我们的主要导航工具。通过这样做，您将学习有关CSS定位、CSS3伪类、CSS3动画以及如何纯粹使用CSS创建下拉菜单。这非常有趣！
