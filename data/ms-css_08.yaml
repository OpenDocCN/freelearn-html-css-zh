- en: Workflow for HiDPI Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HiDPI设备的工作流程
- en: Retina devices are now almost the default for Apple computers, tablets, and
    phones. Also, the word "retina" is actually trademarked by Apple for computer
    equipment, and is their branded way of describing double(or more)-density screens
    and devices. I'm going to use the word "retina" loosely to describe any device
    that has a high-density display, whether its made by Apple or not. Everything
    on a retina device is sharper and crisper because there are nearly four times
    the pixels as there are in a CSS device's display; for every "CSS pixel", there
    are now four "device pixels", allowing higher quality displays. The downside is
    that the images we've used so far are actually not going to look so good on such
    a device because we haven't accounted for higher density displays.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 视网膜设备现在几乎是苹果电脑、平板电脑和手机的默认设备。此外，“视网膜”一词实际上是苹果公司为计算机设备注册的商标，是他们品牌化描述双倍（或更多）密度屏幕和设备的方式。我将松散地使用“视网膜”一词来描述任何具有高密度显示屏的设备，无论是由苹果制造还是其他制造商。视网膜设备上的所有内容都更清晰，因为与CSS设备显示器上的像素相比，现在有近四倍的像素；对于每个“CSS像素”，现在有四个“设备像素”，从而实现更高质量的显示。不利的一面是，到目前为止我们使用的图像实际上在这样的设备上看起来不会那么好，因为我们没有考虑到更高密度的显示。
- en: In this chapter, we'll go over a number of techniques for images that take retina
    displays into account. This includes making images twice their size. We'll also
    look into the background image technique, using SVG, and using the `srcset` attribute
    on the image element to further account for retina.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些针对视网膜显示器的图像技术。这包括使图像放大两倍。我们还将研究背景图像技术，使用SVG，并在图像元素上使用`srcset`属性来进一步考虑视网膜。
- en: 2x images
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2x图像
- en: '2x images are twice the width and twice the height images. The basic idea is
    to make the image twice the width and height that we actually need. We''ll then
    add that image to our HTML. Then we''ll use CSS to constrain the image to the
    actual size that it will be on the screen. The way I like to do this is the same
    way I like to handle flexible images in responsive design: I like to make sure
    that the images will have a containing element with a set `width` and `height`
    value. Then, I make sure the image itself has its `max-width` set to 100%. Both
    these requirements are already in place. All my images typically have a container,
    and in CSS, and all my images have their `max-width` set to 100%.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2x图像是宽度和高度的两倍。基本思路是使图像的宽度和高度是我们实际需要的两倍。然后我们将该图像添加到我们的HTML中。然后我们将使用CSS将图像限制为屏幕上的实际大小。我喜欢处理响应式设计中的灵活图像的方式与此相同：我喜欢确保图像将具有具有设置的包含元素`width`和`height`值。然后，我确保图像本身的`max-width`设置为100%。这些要求已经具备。我的所有图像通常都有一个容器，在CSS中，我的所有图像都将其`max-width`设置为100%。
- en: Creating a retina size image (2x)
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视网膜大小的图像（2x）
- en: 'So let''s get started with the raster images on the shark movies page. Right-click
    on the Jaws movie image and inspect this element:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们从鲨鱼电影页面上的光影开始。右键单击“大白鲨”电影图像并检查此元素：
- en: '![](img/00333.jpeg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00333.jpeg)'
- en: 'We can see that these images on the shark movies page are 200 x 200 pixels.
    Our goal is to replace these with images that are 400 x 400 pixels. As you can
    see in my `images` folder, shown in the following screenshot, I''ve already created
    three images that are identical to the original images, except they are larger
    and suffixed with `@2x.jpg` to signify that these are the retina versions:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到鲨鱼电影页面上的这些图像是200 x 200像素。我们的目标是用尺寸为400 x 400像素的图像替换它们。如您在下面的屏幕截图中看到的，我已经创建了三个与原始图像相同的图像，只是它们更大，并且带有`@2x.jpg`后缀，表示这些是视网膜版本：
- en: '![](img/00334.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00334.jpeg)'
- en: 'Switching over to the HTML, you can see I''ve added `@2x` to the image filename
    for all three images and have saved it. This is what our `Open Water movie` filename
    should look like, for example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到HTML，您会看到我已经为所有三个图像的文件名添加了`@2x`并保存了。例如，这是我们“Open Water”电影的文件名应该是这样的：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sizing down the 2x image using CSS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS调整2x图像的大小
- en: 'Go over to the browser and refresh it. Now, when you look at this image of
    Jaws, you really wouldn''t see any noticeable difference:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 转到浏览器并刷新。现在，当您查看这张大白鲨的图像时，您实际上不会看到任何明显的区别：
- en: '![](img/00335.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00335.jpeg)'
- en: 'However, a quick inspection shows that a `@2x` image is being served, but it''s
    being constrained to a size of 200 x 200, so you can see that the original image
    is `400 x 400`, but it''s showing as `200 x 200`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，快速检查显示正在提供`@2x`图像，但它被限制为200 x 200的大小，因此您可以看到原始图像是`400 x 400`，但显示为`200 x 200`：
- en: '![](img/00336.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00336.jpeg)'
- en: 'Because of our foundation of responsive design, the immediate containing element
    `.figure` already has a width set of `23.958333333333` percent (as shown in the
    following code), which is equal to 200 pixels in the website''s widest context:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对响应式设计的基础，即时包含元素`.figure`已经设置了`23.958333333333`百分比的宽度（如下面的代码所示），这相当于网站最宽处的200像素：
- en: '![](img/00337.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00337.jpeg)'
- en: 'If we remove the `width` from the Styles pane of the Chrome DevTools, the image
    blows up to its actual size, which is `400 x 400`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从Chrome DevTools的样式窗格中删除`width`，图像将会放大到其实际大小，即`400 x 400`：
- en: '![](img/00338.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00338.jpeg)'
- en: 'So it''s the containing element, having a set `width`, along with the `max-width`
    set to 100%, that keeps the image constrained. If we remove this `max-width` from
    the Style pane of the Chrome DevTools, the image would no longer be constrained,
    as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是包含元素具有设置的`width`，以及`max-width`设置为100%，使图像受限。如果我们从Chrome DevTools的样式窗格中删除这个`max-width`，图像将不再受限，如下所示：
- en: '![](img/00339.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00339.jpeg)'
- en: The parent element has the overflow option set to hidden, which is why the image
    isn't getting any wider than 23.95 percent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 父元素的溢出选项设置为隐藏，这就是为什么图像的宽度不会超过23.95%。
- en: '![](img/00340.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00340.jpeg)'
- en: Checking the image quality on a retina device
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视网膜设备上检查图像质量
- en: 'Now how do we know that the image is going to look good on a retina device?
    The best thing to do is test it on a retina device, but we can also cheat a little
    bit and zoom Chrome to 200 percent. First, let''s set this width to 200px directly
    in the DevTools:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们怎么知道图像在视网膜设备上会看起来很好呢？最好的办法是在视网膜设备上测试它，但我们也可以在Chrome中作弊一点，将其缩放到200%。首先，让我们在DevTools中直接将宽度设置为200px：
- en: '![](img/00341.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00341.jpeg)'
- en: 'Then let''s go to the Chrome toolbar and zoom in to 200%:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们转到Chrome工具栏，并将缩放比例调整到200%：
- en: '![](img/00342.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00342.jpeg)'
- en: The preceding screenshot is supposed to demonstrate that at 200% zoom, the image
    is still very crisp, and this is kind of simulating a retina device.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图旨在演示在200%缩放时，图像仍然非常清晰，这有点类似于模拟视网膜设备。
- en: This doesn't seem like a bad way to get your images retina ready. Well, if it
    were only that easy. It turns out that making your images twice the height and
    width really makes them about three to four times bigger than their 1x counterparts.
    So if you look at the Jaws image in the `images` folder, the original is 28 KB
    and the 2x version (the double-density version) is 105 KB. That's four times as
    large!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎不是一个准备好视网膜的图像的坏方法。嗯，如果只是这么简单就好了。事实证明，使图像的高度和宽度增加一倍实际上使它们比1x版本大三到四倍。因此，如果你看一下`images`文件夹中的Jaws图像，原始大小为28
    KB，而2x版本（双倍密度版本）为105 KB。这是原始大小的四倍！
- en: '![](img/00343.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00343.jpeg)'
- en: So, in conclusion, this is just the beginning of our preparations for the retina
    web. Our biggest issue right now is that we are serving a huge retina-size image
    to all devices, even those that aren't retina. That's extra download and page
    weight to sites that won't get any benefit from it is not very responsible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总之，这只是我们为视网膜网站做准备的开始。我们目前最大的问题是，我们为所有设备提供了一个巨大的视网膜大小的图像，即使那些不是视网膜的设备也是如此。这对于那些不会从中受益的站点来说，是额外的下载和页面负担，这是不负责任的。
- en: In the next section, we'll look at a similar technique for background images.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍类似的背景图像技术。
- en: Background images
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景图像
- en: In order to handle background images, we can use a special media query to determine
    the pixel ratio and then modify the `background` property to serve up the retina
    image. In this section, we'll determine how we can account for background images
    in the sphere of retina. We'll first create a media query designed for determining
    the pixel ratio. Then, we'll update the image being served to be the retina version.
    The seaweed in the footer is a background image, and thus will be the perfect
    image for this task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理背景图像，我们可以使用特殊的媒体查询来确定像素比，然后修改`background`属性以提供视网膜图像。在这一节中，我们将确定如何在视网膜领域处理背景图像。我们首先创建一个专门用于确定像素比的媒体查询。然后，我们将更新正在提供的图像为视网膜版本。页脚中的海藻是一个背景图像，因此将是这项任务的完美图像。
- en: Targeting the seaweed in the footer
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对页脚中的海藻
- en: 'Here is the seaweed just above the footer on the movies page:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在电影页面页脚上方的海藻：
- en: '![](img/00344.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00344.jpeg)'
- en: 'If we look at the CSS, all that''s happening is that the footer has a repeating
    background image. The background is the seaweed, and we''re getting it to repeat
    along the *x* axis:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看CSS，发生的一切就是页脚有一个重复的背景图像。背景是海藻，我们让它沿着*x*轴重复：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So we need to have a retina-sized version of `seaweed.jpg`. I have that in
    my `images` folder, and I''ve named it `seaweed@2x.jpg`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要有一个视网膜大小的`seaweed.jpg`版本。我在我的`images`文件夹中有这个，我把它命名为`seaweed@2x.jpg`：
- en: '![](img/00345.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00345.jpeg)'
- en: 'At the very bottom of the style sheet, after all our media queries, let''s
    reserve a spot for retina background images:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式表的最底部，在所有我们的媒体查询之后，让我们为视网膜背景图像保留一个位置：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is where we'll have the special media query to detect retina.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用特殊媒体查询来检测视网膜的地方。
- en: Media query for device pixel ratio
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备像素比的媒体查询
- en: 'We remember media queries like this from [Chapter 6](part0133.html#3UQQQ0-a72d261cc09f412988422c8a08f12cd5),
    *Becoming Responsive*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第6章](part0133.html#3UQQQ0-a72d261cc09f412988422c8a08f12cd5)中记得这样的媒体查询，*变得响应式*：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are two parts to the media query, the media *type* and media *feature*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询有两个部分，媒体*类型*和媒体*特性*：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The media type can be keyword values such as *screen*, *print*, *speech*, and
    *all*. The media feature can be a number of things as well. In the responsive
    chapter, the feature was the `max-width` of the browser. For retina however, we
    want to query for the pixel-ratio of the screen:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体类型可以是关键字值，如*screen*、*print*、*speech*和*all*。媒体特性也可以是许多东西。在响应式章节中，特性是浏览器的`max-width`。然而，对于视网膜，我们要查询屏幕的像素比：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A lot is going on in the preceding sample. There are two different queries
    targeting two different media features. The comma separating these two queries
    is similar to saying "or." So the media query will take affect if either of the
    preceding two queries are true. But why have two queries? Well, the first query
    is for webkit browsers such as Safari and older Chrome on devices with `min-device-pixel-ratio`
    of `2`. Next, we target devices that have 192 dots per inch or greater. Instead
    of using a device pixel ratio, which is webkit-specific, it''s just using `min-resolution:
    192dpi`. This accounts for different browsers, such as a Windows mobile. Both
    media features are basically targeting retina.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的示例中发生了很多事情。有两个不同的查询针对两个不同的媒体特性。分隔这两个查询的逗号类似于说“或”。因此，如果前面的两个查询中的任何一个为真，则媒体查询将生效。但为什么要有两个查询？嗯，第一个查询是针对像Safari和旧版Chrome这样的webkit浏览器，设备的`min-device-pixel-ratio`为`2`。接下来，我们针对具有192像素每英寸或更高像素密度的设备。它不是使用设备像素比，而是使用`min-resolution:
    192dpi`，这考虑到了不同的浏览器，比如Windows手机。这两个媒体特性基本上都是针对视网膜。'
- en: 'Now inside of the media query, we will target the footer and change the background
    image to our retina version. I''ll type in the footer and add an opening curly
    brace and then `background-image`; the URL is going to be `../images/seaweed@2x.jpg`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在媒体查询中，我们将针对页脚并将背景图像更改为我们的视网膜版本。我会在页脚中输入一个开放的大括号，然后是`background-image`；URL将是`../images/seaweed@2x.jpg`：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We see no noticeable difference though in the browser. Let''s inspect the footer
    though, just to make sure that it''s still loading up the regular `seaweed.jpg`
    file, and not `seaweed@2x.jpg`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器中看不到明显的区别。不过，让我们检查一下页脚，以确保它仍然加载常规的`seaweed.jpg`文件，而不是`seaweed@2x.jpg`：
- en: '![](img/00346.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00346.jpeg)'
- en: 'The reason we are checking this is because I''m not on a retina device. We
    can use some trickery to make sure this is working. Let''s go to our CSS and change
    the device pixel ratio to `1`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查这个的原因是因为我不是在视网膜设备上。我们可以使用一些技巧来确保这个工作。让我们去我们的CSS并将设备像素比更改为`1`：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s see what that looks like in the browser:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在浏览器中是什么样子的：
- en: '![](img/00347.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00347.jpeg)'
- en: Now we are getting the 2x version, and we can see that it's noticeably larger.
    We have twice the size image; it visually looks like it's twice the size. It's
    not being constrained down to our intended display size. There's a property called
    `background-size` that we will use to fix this.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了2x版本，我们可以看到它明显更大。我们有两倍大小的图像；视觉上看起来是两倍大小。它没有被限制在我们预期的显示尺寸上。有一个名为`background-size`的属性，我们将使用它来解决这个问题。
- en: Serving the 2x image only to retina devices
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅向视网膜设备提供2x图像
- en: 'We have to use the `background-size` property in order to ensure the seaweed
    is constrained appropriately. We will put the `background-size` property right
    in the ruleset that holds the non-retina version at the top of our footer section,
    not inside the media query. We could easily put it in the media query and that
    would be fine and dandy, but this is going to apply to non-retina devices and
    retina devices, so we''ll just add a background size of `200px` horizontally and
    `100px` vertically, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`background-size`属性来确保海藻被适当地限制。我们将在页脚部分顶部持有非视网膜版本的规则集中放置`background-size`属性，而不是在媒体查询中。我们可以很容易地将其放在媒体查询中，这样也可以，但这将适用于非视网膜设备和视网膜设备，因此我们将添加水平`200px`和垂直`100px`的背景大小，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save this and go to the browser. When we refresh the site, the seaweed should
    shrink down to 200 x 100, back to its regular size:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个并转到浏览器。当我们刷新网站时，海藻应该缩小到200 x 100，恢复到其常规大小：
- en: '![](img/00348.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00348.jpeg)'
- en: If you look at our styles in the DevTools, you can see we're getting the `@2x`
    version. You can see the way the browser is loading in the CSS—it sees the media
    query on top. This is what's getting used. Below it is the non-media query version
    that is not getting loaded. This is exactly how we want it to work, which is good.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们在DevTools中的样式，您会看到我们得到了`@2x`版本。您可以看到浏览器加载CSS的方式-它在顶部看到了媒体查询。这是正在使用的。下面是未加载的非媒体查询版本。这正是我们希望它工作的方式，这很好。
- en: 'The last thing we need to do is revert the media query to a `device-pixel-ratio`
    of two instead of one, so, we''ll change that:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将媒体查询恢复为`device-pixel-ratio`为2而不是1，所以，我们将更改它：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now it''ll load the non-retina version because I''m on a non-retina device:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将加载非视网膜版本，因为我使用的是非视网膜设备：
- en: '![](img/00349.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00349.jpeg)'
- en: Only the retina-sized background image is downloaded by retina devices and the
    regular-sized background image is downloaded by non-retina devices. All is good,
    but this is still quite a bit of work. There's a better way that we can handle
    this seaweed that involves less work and only requires one image–using SVG instead
    of traditional raster graphics.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只有视网膜尺寸的背景图像才会被视网膜设备下载，非视网膜设备会下载常规尺寸的背景图像。一切都很好，但这仍然是相当多的工作。我们可以以更少的工作量处理这些海藻，只需要一张图片-使用SVG而不是传统的光栅图形。
- en: Scalable Vector Graphic (SVG)
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可伸缩矢量图形（SVG）
- en: A **Scalable Vector Graphic**(**SVG**) - is an XML-based image format for graphics.
    It's different than raster formats, like JPEG and PNG, because it SVG scale to
    any size without losing any resolution or looking pixelated. This means that we
    don't need multiple images for retina or responsive layouts! Another bonus with
    SVG's is that the file size is can be much smaller than that of the same image,
    saved as a JPEG or PNG. All major browsers support the SVG format as far back
    as IE9\. SVGs aren't a replacement for every image on your site–they are particularly
    suited for line drawings, which are typically generated through design software,
    such as Adobe Illustrator.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**可伸缩矢量图形**（**SVG**）-是一种基于XML的图形图像格式。它与JPEG和PNG等光栅格式不同，因为它可以在任何尺寸下缩放而不失去任何分辨率或出现像素化。这意味着我们不需要为视网膜或响应式布局使用多个图像！SVG的另一个好处是文件大小可以比保存为JPEG或PNG的相同图像要小得多。所有主要浏览器都支持SVG格式，甚至可以追溯到IE9。SVG并不是站点上每个图像的替代品-它们特别适用于线条图，通常是通过设计软件（如Adobe
    Illustrator）生成的。'
- en: 'In this section, we''re going to look at how to save an Adobe Illustrator file
    as an SVG, and three different ways in which we can add SVG''s to our website:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何将Adobe Illustrator文件保存为SVG，以及我们可以将SVG添加到网站的三种不同方式：
- en: Adding an SVG as a `background-image`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SVG添加为`background-image`
- en: Adding an SVG using the `<img>` tag
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`<img>`标签添加SVG
- en: Using an inline SVG
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内联SVG
- en: 'We''ve got plenty of images on our site that would lend themselves well to
    SVG, including the shark at the top of our site:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网站上有很多图像非常适合使用SVG，包括网站顶部的鲨鱼：
- en: '![](img/00350.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00350.jpeg)'
- en: 'All the different ocean species we have in the middle of our site will also
    work great as SVG:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网站中间的所有不同海洋物种也非常适合作为SVG：
- en: '![](img/00351.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00351.jpeg)'
- en: 'Even the seaweed we have in the footer, which we worked on in the last section
    is a great candidate for SVG:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在上一节中处理的页脚中的海藻也非常适合SVG：
- en: '![](img/00352.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00352.jpeg)'
- en: 'So what images aren''t great candidates for SVG? Well, our raster images on
    the movies page are definitely not:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么哪些图像不适合作为SVG？嗯，我们电影页面上的光栅图像绝对不适合：
- en: '![](img/00353.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00353.jpeg)'
- en: Saving an Illustrator file as an SVG
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Illustrator文件保存为SVG
- en: I have an Adobe Illustrator file called `seaweed.ai` open in Illustrator. A
    program like Illustrator is where SVG's can be created or drawn from scratch.
    Creating SVG's in Illustrator is far out of scope for this book, but I want to
    start here just to show where an SVG's *could* come from.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Illustrator中打开了一个名为`seaweed.ai`的Adobe Illustrator文件。像Illustrator这样的程序是可以创建SVG或从头开始绘制SVG的地方。在本书中，使用Illustrator创建SVG远远超出了范围，但我想从这里开始只是为了展示SVG可能来自何处。
- en: In *Illustrator CC 2017*, one of the best ways to save an AI file down to SVG
    for web is by using the File *>* Export *>* Export for Screens... option.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Illustrator CC 2017*中，将AI文件保存为SVG以供Web使用的最佳方法之一是使用文件* > *导出* > *屏幕导出...选项。
- en: 'This option uses the `artboard` name as the name of the file, so before we
    export as an SVG, let''s rename the artboard by going to Window *>* `Artboards`.
    Let''s rename from artboard1 to seaweed, as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项使用`artboard`名称作为文件名，所以在我们导出为SVG之前，让我们通过转到窗口* > * `画板`来重命名画板。让我们将artboard1重命名为seaweed，如下面的截图所示：
- en: '![](img/00354.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00354.jpeg)'
- en: 'Now, by going to the File *>* Export *>* Export for Screens... option, we''ll
    get an SVG file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过转到文件* > *导出* > *屏幕导出...选项，我们将获得一个SVG文件：
- en: '![](img/00355.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00355.jpeg)'
- en: 'That brings up screen with a few options. Using the Export to field, we''ll
    choose where to save this file, which will inevitably be in our `images` folder.
    We''ll also change the Format to `SVG` before clicking the Export Artboard button
    in the bottom right:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出一个带有几个选项的屏幕。使用“导出到”字段，我们将选择保存此文件的位置，这将不可避免地在我们的`images`文件夹中。在单击右下角的“导出画板”按钮之前，我们还将更改格式为`SVG`：
- en: '![](img/00356.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00356.jpeg)'
- en: After saving, you can see that the SVG is 1 KB. The `@2x` version we used in
    the last section was 13 KB!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，您会看到SVG为1 KB。我们在上一节中使用的`@2x`版本为13 KB！
- en: '![](img/00357.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00357.jpeg)'
- en: So not only is the SVG 13 times smaller than the `@2x` version, it's also six
    times smaller than the regular version, and that is truly amazing! Now let's integrate
    this into our CSS.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SVG不仅比`@2x`版本小13倍，而且比常规版本小6倍，这真是太神奇了！现在让我们将其整合到我们的CSS中。
- en: Adding the SVG file as a background image
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SVG文件添加为背景图像
- en: 'In our CSS, inside the rule set targeting the footer, all I''m going to do
    is change the format from `.jpg` to `.svg`—that is, from (`''.../images/seaweed.jpg''`)
    to (`''.../images/seaweed.svg''`), as shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CSS中，在针对页脚的规则集内部，我要做的就是将格式从`.jpg`更改为`.svg` - 也就是从（`'.../images/seaweed.jpg'`）更改为（`'.../images/seaweed.svg'`），如下面的代码所示：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since now we have an SVG that''s going to work for both non-retina and retina
    devices, we''ll go down to the very bottom and comment out this media query from
    our last section:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为现在我们有一个适用于非视网膜和视网膜设备的SVG，所以我们将转到底部，并注释掉我们上一节中的这个媒体查询：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is what we used in the last section to serve a larger image to retina devices,
    but we don't need all that extra code if we're using SVG. So I've gotten rid of
    it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在上一节中用来为视网膜设备提供更大图像的方法，但是如果我们使用SVG，我们就不需要所有这些额外的代码。所以我把它们都去掉了。
- en: I'll refresh the browser, and it looks exactly the same. Let's inspect the element,
    as shown in the following screenshot. We can see that it's serving up `seaweed.svg`.
    We went from 2 images to 1\. 13 KB to 1 KB. And we got rid of several lines of
    CSS in a complicated media query. Are you starting to understand why SVG is pure
    awesomeness?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我将刷新浏览器，它看起来完全一样。让我们检查元素，如下面的截图所示。我们可以看到它正在提供`seaweed.svg`。我们从2张图片变成了1张。13 KB变成了1
    KB。我们还去掉了一些复杂的媒体查询中的几行CSS。您开始明白为什么SVG是纯粹的令人敬畏了吗？
- en: '![](img/00358.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00358.jpeg)'
- en: Adding the SVG as a regular ol' <img>
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SVG添加为常规的<img>
- en: 'You can also use an SVG as a regular `<img>`. We happen to have a couple of
    images in the middle of our site—the different ocean species that will make perfect
    candidates for implementing SVG with this approach:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将SVG用作常规`<img>`。我们碰巧在网站中间有几张图片 - 不同的海洋物种，这些将是使用SVG实现的完美候选者：
- en: '![](img/00359.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00359.jpeg)'
- en: 'I''ve already saved a copy of the octopus, crab, and whale as an `.svg` file.
    So let''s go over to the HTML and simply change the octopus, crab, and whale images
    from `.png` to `.svg`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将章鱼、螃蟹和鲸鱼保存为`.svg`文件。所以让我们转到HTML，简单地将章鱼、螃蟹和鲸鱼的图像从`.png`更改为`.svg`：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The name of the files in the `images` folder are exactly the same. The only
    difference is that the suffix is `svg` instead of `png`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`images`文件夹中的文件名完全相同。唯一的区别是后缀是`svg`而不是`png`：'
- en: '![](img/00360.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00360.jpeg)'
- en: 'Save this. We''ll get the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个。我们将得到以下输出：
- en: '![](img/00361.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00361.jpeg)'
- en: In the preceding image, we can see that the files look good; the only problem
    is that they appear to have gotten a little bigger. So we'll constrain these down
    to the size we want.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到文件看起来不错；唯一的问题是它们似乎变大了一点。所以我们将它们缩小到我们想要的尺寸。
- en: You can't stop SVG's, you can only hope to constrain them!
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你无法阻止SVG，你只能希望限制它们！
- en: 'To constrain the size of images, we need to set a `width` and/or a `max-width`.
    We actually already did this but only inside of a media query so it isn''t firing
    on larger screens:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要限制图像的大小，我们需要设置`width`和/或`max-width`。我们实际上已经这样做了，但只是在媒体查询中，因此它不会在较大的屏幕上触发：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s remove that rule set from the media query and add it up where we originally
    defined the 3 columns outside of our responsive media queries:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从媒体查询中删除该规则集，并将其添加到我们最初定义响应式媒体查询之外的3列位置：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And all we did there is center the `figure` element using auto margins, make
    sure the width is 100% of its container, as long as the width is never more than
    250px (`max-width`).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的就是使用自动边距来居中`figure`元素，确保其宽度是其容器的100%，只要宽度不超过250px（`max-width`）。
- en: 'Now that we have this in the right place, this is what we get:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经将它放在了正确的位置，这就是我们得到的结果：
- en: '![](img/00362.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00362.jpeg)'
- en: We've constrained each SVG image to a maximum width of `250px`. Our crab, octopus,
    and whale look mighty good and are instantly retina ready.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个SVG图像限制为最大宽度为`250px`。我们的螃蟹、章鱼和鲸鱼看起来非常好，立即就准备好了。
- en: Using an inline SVG
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内联SVG
- en: We have one other option for SVG, called an inline SVG. Since an SVG is really
    just XML inside of a text file, we can actually embed the SVG code directly into
    our HTML. This makes it so that we don't need to have an additional HTTP request
    (good for performance). Also, it allows us to alter the SVG using CSS, for example,
    provides a cool hover state or an animation. This really gives us a huge advantage;
    it just can't be overstated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对SVG还有另一个选项，称为内联SVG。由于SVG实际上只是文本文件中的XML，我们实际上可以直接将SVG代码嵌入到我们的HTML中。这样就不需要额外的HTTP请求（对性能有好处）。此外，它允许我们使用CSS来改变SVG，例如提供一个酷炫的悬停状态或动画。这确实给了我们一个巨大的优势；它的重要性无法被过分强调。
- en: 'So what we''re going to do is go to the `images` folder in Sublime Text and
    open up `crab.svg`. But first, let''s look at what happens when I open `crab.png`,
    Sublime shows an image:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要做的是转到Sublime Text中的`images`文件夹，然后打开`crab.svg`。但首先，让我们看看当我打开`crab.png`时会发生什么，Sublime会显示一个图像：
- en: '![](img/00363.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00363.jpeg)'
- en: 'With the SVG, it actually shows the code! You can see it''s XML, which is similar
    to HTML:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SVG，它实际上显示了代码！你可以看到它是XML，与HTML类似：
- en: '![](img/00364.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00364.jpeg)'
- en: 'I''ll copy and paste all of the SVG code, and go over to our `index.html` file
    and get rid of the entire `img` tag:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我将复制并粘贴所有的SVG代码，并转到我们的`index.html`文件，然后删除整个`img`标签：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we''ll replace it with the SVG code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将其替换为SVG代码：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Woah, that's a lot of code... The downside of SVG is it's a lot of code you're
    putting directly into your markup. You're still going to get better performance,
    because you don't have an HTTP request for it, but we're adding close to 30 lines
    of code for that.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这是很多的代码... SVG的缺点是你直接将大量代码放入你的标记中。你仍然会获得更好的性能，因为你不需要为它发出HTTP请求，但我们为此添加了接近30行的代码。
- en: 'We see no change in the Chrome; the crab looks exactly the same. So we might
    as well inspect this element. Now we can see that it''s the inline SVG code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中我们看不到任何变化；螃蟹看起来完全一样。所以我们不妨检查一下这个元素。现在我们可以看到它是内联SVG代码：
- en: '![](img/00365.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00365.jpeg)'
- en: 'You can also see how you would think that you can use CSS to change these properties
    because each of these paths is literally a separate kind of node in the Dom:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到你可能会认为你可以使用CSS来改变这些属性，因为每个路径实际上都是Dom中的一个单独的节点：
- en: '![](img/00366.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00366.jpeg)'
- en: 'For instance, if we wanted to, we could change the fill color of this line
    of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想的话，我们可以改变这行代码的填充颜色：
- en: '![](img/00367.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00367.jpeg)'
- en: 'Let''s change it to green:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它变成绿色：
- en: '![](img/00368.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00368.jpeg)'
- en: 'Now you get a green claw:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你得到了一个绿色的爪子：
- en: '![](img/00369.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00369.jpeg)'
- en: So you can see how you might be able to change the properties of the SVG, animate
    it, or create a cool hover state. You can't do this with SVG as a `background-image`
    or an `img` tag, but you can do this with an inline SVGs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到你可能如何改变SVG的属性，对其进行动画处理，或者创建一个酷炫的悬停状态。你不能用SVG作为`background-image`或`img`标签来做到这一点，但你可以用内联SVG来做到这一点。
- en: 'Since this is a different media format, it''s not an `img` tag and not a `video`
    tag. It''s really an `SVG` tag. Let''s go to the top of the style sheet, into
    my reset. This is where we set `max-width: 100%` on our media as shown in the
    following code. We''ll also add an SVG to this list:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '由于这是一种不同的媒体格式，它不是`img`标签，也不是`video`标签。它实际上是一个`SVG`标签。让我们转到样式表的顶部，进入我的重置。这是我们在媒体上设置`max-width:
    100%`的地方，如下面的代码所示。我们还将向此列表添加一个SVG：'
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the next section, we'll go over how we can use the `srcset` attribute on
    an `img` tag to serve retina images to high-density displays and normal-sized
    images to normal density displays.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何在`img`标签上使用`srcset`属性，以向高密度显示器提供视网膜图像，并向普通密度显示器提供正常大小的图像。
- en: Source set attribute (srcset)
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源设置属性（srcset）
- en: SVG is still the most preferred way to serve retina images to HiDPI devices
    because the file size is nearly always smaller than JPG and PNG, and you only
    need one image for both retina and non- retina devices. But there is another,
    very good option that's emerged, called `srcset`. This option isn't meant to replace
    SVG, but rather complement it, since SVG can't be used for traditional raster
    images and photos, which are more suited for JPEG and PNG.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: SVG仍然是向HiDPI设备提供视网膜图像的最受欢迎的方式，因为文件大小几乎总是比JPG和PNG小，而且对于视网膜和非视网膜设备只需要一个图像。但还有另一个非常好的选择出现了，叫做`srcset`。这个选项并不是要取代SVG，而是要补充它，因为SVG不能用于传统的光栅图像和照片，这些更适合于JPEG和PNG。
- en: What is srcset?
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是srcset？
- en: The `srcset` attribute is simply just a set of images, just like the name implies.
    What we can do is provide not just one image for the browser to serve, but a set
    of images that the browser can choose from and only fetch whichever image the
    browser decides is most appropriate for the device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`srcset`属性只是一组图像，就像名称所暗示的那样。我们可以提供不止一个图像供浏览器选择，而是一组图像，浏览器可以从中选择，并且只获取浏览器认为最适合设备的图像。'
- en: 'We''re going to focus on the three movie images on our movies page, which are
    all raster, photographic images:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于我们电影页面上的三个电影图像，它们都是光栅的、摄影的图像。
- en: '![](img/00370.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00370.jpeg)'
- en: 'In `movies.html` we have an `img` tag and the appropriate image for each movie.
    So for Sharknado, we have `sharknado.jpg`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`movies.html`中，我们有一个`img`标签和每部电影的适当图片。所以对于Sharknado，我们有`sharknado.jpg`：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For Jaws, we have `jaws.jpg`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Jaws，我们有`jaws.jpg`：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s update the Jaws image and add a new attribute called `srcset` and we''ll
    put our Jaws image as the value of that attribute:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新Jaws图像，并添加一个名为`srcset`的新属性，然后将我们的Jaws图像作为该属性的值：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Like I mentioned, `srcset` is a set of image choices to provide to the browser
    so it can decide which is best suited for the situation. Let's add a set of images.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，`srcset`是一组图像选择，供浏览器决定哪个最适合情况。让我们添加一组图像。
- en: Adding a set of images to srcset
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向srcset添加一组图像
- en: 'To add a set of images to the `image` tag, comma separate each image. We''re
    providing the regular-sized image first. Then we''ll add `images/jaws@2x.jpg`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`image`标签添加一组图像，用逗号分隔每个图像。我们首先提供常规大小的图像。然后我们将添加`images/jaws@2x.jpg`：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The browser actually needs something else to let it know that it''s a larger
    image, something called the *pixel density descriptor,* or just the *X descriptor*.
    Let''s add that, as shown in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，浏览器需要其他东西来让它知道这是一个更大的图像，称为*像素密度描述符*，或者只是*X描述符*。让我们添加它，如下面的屏幕截图所示：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Following each image string, I'm going to provide a space and then the X descriptor.
    So the first image string will be `1x`, and the second one will be `2x`. The X
    descriptor is a hint we provide to the browser. This means we are using the `images/jaws.jpg`
    for `1x`, or normal pixel density, displays, and using `images/jaws@2x.jpg`, the
    larger image, for `2x`, or retina, displays.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个图像字符串后面，我将提供一个空格，然后是X描述符。因此，第一个图像字符串将是`1x`，第二个将是`2x`。X描述符是我们提供给浏览器的提示。这意味着我们在`1x`或正常像素密度显示器上使用`images/jaws.jpg`，在`2x`或retina显示器上使用更大的图像`images/jaws@2x.jpg`。
- en: Testing the image set
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试图像集
- en: 'Let''s see whether the image set is working. This would be tough without testing
    it on a retina display, which we''re not doing. But let''s see whether we can
    do some rough testing. Chrome has a nice feature where, if we inspect an image,
    we can see its `src` attribute and the `srcset` attribute. Check out the following
    code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看图像集是否起作用。如果没有在retina显示屏上测试，这将会很困难。但让我们看看是否可以进行一些粗略的测试。Chrome有一个很好的功能，如果我们检查一个图像，我们可以看到它的`src`属性和`srcset`属性。看看下面的代码：
- en: '![](img/00371.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00371.jpeg)'
- en: 'Here, if we hover the mouse over the path to each image, you can see that a
    popup appears over the image that''s being served. But when we hover over `jaws@2x`,
    no popup appears because that image is not being served:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们将鼠标悬停在每个图像的路径上，你会看到一个弹出窗口出现在正在提供的图像上。但是当我们悬停在`jaws@2x`上时，没有弹出窗口出现，因为该图像没有被提供：
- en: '![](img/00372.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00372.jpeg)'
- en: This makes sense as I'm not on a retina display, so it's using a non-retina
    image.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的，因为我不是在retina显示屏上，所以它正在使用非retina图像。
- en: 'Let''s use the browser zoom trick, which we used in earlier sections, to see
    whether we can fake a retina device. Let''s zoom up to 200 percent:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用浏览器缩放技巧，这是我们在前面的部分中使用的，看看是否可以伪造一个retina设备。让我们放大到200%：
- en: '![](img/00373.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00373.jpeg)'
- en: 'Then, refresh the page so that it goes and fetches the image it thinks is best:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，刷新页面，以便它获取它认为最好的图像：
- en: '![](img/00374.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00374.jpeg)'
- en: 'When I hover over `jaws.jpg` in the `src` and `srcset`, we don''t get a popup.
    But we do get it when we hover over the path to `jaws@2x.jpg`, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在`src`和`srcset`中悬停在`jaws.jpg`上时，我们没有弹出窗口。但是当我们悬停在`jaws@2x.jpg`的路径上时，我们就会看到，如下所示：
- en: '![](img/00375.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00375.jpeg)'
- en: This tells me that the larger image is getting fetched. That's good stuff.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我，更大的图像正在被获取。这是好东西。
- en: Simplifying the srcset attribute
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化srcset属性
- en: 'Let''s take a look at the code a little bit more to simplify the `srcset` attribute:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下代码，以简化`srcset`属性：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We need to keep the original `src` there as a fallback for browsers that don't
    support `srcset`. We'll talk about how awesomely good browser support is later
    in the section, but it's important to keep in mind that the `src` attribute is
    there so that unsupported browsers aren't left out in the lurch.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保留原始的`src`作为不支持`srcset`的浏览器的备用。我们稍后会在本节中讨论浏览器支持有多好，但重要的是要记住，`src`属性是为了让不支持的浏览器不被忽视。
- en: 'The one other thing to note is that we can simplify this code equation. The
    W3C spec mentions that for new user agents, the `src` attribute participates in
    the resource selection as if it were specified in the `srcset` with a `1x` descriptor.
    Since we have the traditional `src` attribute that will serve the `1x` version
    of the image, we can remove the first image string from our `srcset` attribute
    and simplify our markup:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是，我们可以简化这个代码方程式。W3C规范提到，对于新的用户代理，`src`属性参与资源选择，就好像它是在`srcset`中用`1x`描述符指定的一样。由于我们有传统的`src`属性，可以提供图像的`1x`版本，我们可以从`srcset`属性中删除第一个图像字符串，并简化我们的标记：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In other words, we can remove the regular size image string with the `1x` descriptor
    from the `srcset` attribute since this is already being specified in the `src`
    attribute. This simplifies it, which is good.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以从`srcset`属性中删除带有`1x`描述符的常规大小图像字符串，因为这已经在`src`属性中指定了。这样简化了它，这是好事。
- en: 'Now let''s update our other two movies with similar markup starting with Sharknado:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用类似的标记更新我们的另外两部电影，从《Sharknado》开始：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll do the same thing for the movie, Open Water:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对电影《Open Water》做同样的事情：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Browser support
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器支持
- en: 'Let''s discuss browser support [caniuse.com](http://caniuse.com/) shows an
    awful lot of green browsers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论浏览器支持[caniuse.com](http://caniuse.com/)显示了大量绿色浏览器：
- en: '![](img/00376.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00376.jpeg)'
- en: Microsoft Edge supports `srcset` and Chrome, Firefox, Safari, Opera, and starting
    with iOS Safari 8.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Edge支持`srcset`，Chrome，Firefox，Safari，Opera，以及iOS Safari 8及更高版本也支持。
- en: 'Changing the option to *Date Relative* shows the support goes farther back
    for iOS:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将选项更改为*日期相对*，显示支持在iOS上更早：
- en: '![](img/00377.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00377.jpeg)'
- en: It provides partial support from Safari 8.1 through to 8.4\. It supports "resolution
    switching", which is what we're doing using the X descriptor; however, it doesn't
    support the full syntax, which I'll talk about a little bit more later in the
    section. One notable non-supported browser is IE as recent as IE11\. But, Internet
    Explorer will get the regular-sized image we specified in the traditional source
    attribute.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它从Safari 8.1到8.4提供了部分支持。它支持"分辨率切换"，这就是我们使用X描述符所做的；然而，它不支持完整的语法，我稍后会在本节中详细讨论。一个值得注意的不支持的浏览器是IE，甚至是IE11。但是，Internet
    Explorer将获取我们在传统源属性中指定的常规大小图像。
- en: The nice part about this is that the overwhelming majority of high-density devices
    will ultimately end up getting the `2x` version, and unsupported browsers which
    are likely non-retina devices anyway, will receive the `1x` version.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于绝大多数高密度设备最终都会得到`2x`版本，而不支持的浏览器，很可能是非视网膜设备，将收到`1x`版本。
- en: 'I''m going to point out that you don''t have to use just one or two image paths.
    I''m going to copy and paste in three image paths, as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我要指出的是，你不一定只使用一个或两个图像路径。我将复制并粘贴三个图像路径，如下所示：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in the preceding code, I've specified an `image` that I can use
    for `4x` displays, `2x` displays, and `1.5x` displays. This brings me to another
    point–you don't necessarily have to use whole numbers. You can use 1.5 or 1.325
    if you want.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码中看到的，我已经指定了一个可以用于`4x`显示、`2x`显示和`1.5x`显示的`image`。这让我想到另一点——你不一定要使用整数。你可以使用1.5或1.325。
- en: Moreover, we're only providing hints to the browser, so even though we have
    what looks like a great amount of control over which image gets served, ultimately
    it's up to the browser to decide which is the most suitable to use. This is based
    on factors other than users' screen pixel density, for example, zoom level, as
    we saw already, and other factors, such as the user's network conditions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们只是向浏览器提供提示，所以即使我们看起来对哪个图像被服务有很大的控制，最终决定权还是在浏览器手中。这是基于除用户屏幕像素密度之外的因素，例如，缩放级别，正如我们已经看到的，以及其他因素，比如用户的网络条件。
- en: So, in theory, if a user has a retina device but poor internet, the browser
    would serve a smaller image because it would prioritize the speedy loading of
    images—the loading will be faster, but not as crisp. We've likely seen this type
    of prioritization in other technologies. For instance, a Netflix may show a fuzzy
    version of a movie until it gets enough bandwidth to show you the HD version of
    the same movie. We like this, because we'd rather get something to view faster
    than waiting for the best version of something to view.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理论上，如果用户有一个视网膜设备，但网络条件不佳，浏览器会提供一个较小的图像，因为它会优先考虑图像的快速加载——加载会更快，但不会那么清晰。我们很可能在其他技术中看到了这种优先级的情况。例如，Netflix可能会显示电影的模糊版本，直到它获得足够的带宽来向您展示同一部电影的高清版本。我们喜欢这样，因为我们宁愿快速得到一些东西来观看，而不是等待最好的版本来观看。
- en: Using the W descriptor and sizes attribute of the srcset attribute
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`srcset`属性的`W`描述符和sizes属性
- en: 'Note that the `srcset` attribute is not a one-trick pony; we have talked about
    how it works for handling retina images easily. But there is another use case
    of the `srcset` attribute that uses the `W` descriptor and the `sizes` attribute:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`srcset`属性不是一个单一的技巧；我们已经讨论了它如何轻松处理视网膜图像。但`srcset`属性还有另一个用例，它使用`W`描述符和`sizes`属性：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It allows you to handle the serving of different images based on the width of
    the browser. A gigantic, hero, full-page image looks beautiful on a desktop, but
    would be bad for performance, if you just shrink it down and serve it on much
    smaller mobile devices, since small devices don't need a super large image.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许你根据浏览器的宽度来处理不同图像的服务。在桌面上，一个巨大的、英雄式的、全屏的图像看起来很漂亮，但如果你把它缩小并在更小的移动设备上提供服务，那么它的性能就会很差，因为小设备不需要超大的图像。
- en: The `w` descriptor is a hint to the browser about the size of the image; here
    `w` stands for the width. The `sizes` attribute adds media queries and a dimension
    telling the browser our preferred render size of the image if the browser width
    matches the media query and finally the preferred render size of the image if
    the browser width doesn't match the media query.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`w`描述符是对浏览器关于图像大小的提示；这里的`w`代表宽度。`sizes`属性添加了媒体查询和一个维度，告诉浏览器我们首选的图像渲染大小，如果浏览器宽度与媒体查询匹配，最后是如果浏览器宽度不匹配媒体查询的首选渲染大小。'
- en: My intention isn't to explain the details, of this alternate usage of the `srcset`
    attribute but to let you know that there is more depth to the `srcset` attribute.
    If you'd like to dive deeper, I've written an article on my site at [richfinelli.com/srcset-part-2/](http://www.richfinelli.com/srcset-part-2/).
    I've also written an article on the X descriptor, available at [richfinelli.com/srcset-part-1/](http://www.richfinelli.com/srcset-part-1/)
    if you're still hungry to learn more about what we just talked about.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意图不是解释`srcset`属性的这种替代用法的细节，而是让你知道`srcset`属性有更深层次。如果你想深入了解，我在我的网站上写了一篇文章，网址是[richfinelli.com/srcset-part-2/](http://www.richfinelli.com/srcset-part-2/)。我还写了一篇关于X描述符的文章，网址是[richfinelli.com/srcset-part-1/](http://www.richfinelli.com/srcset-part-1/)，如果你还想更深入地了解我们刚才谈到的内容。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Developing for retina is extra effort. My recommendation is to use SVG when
    possible as your first choice for serving super crisp images to retina devices.
    In instances when SVG is not possible - that is photographs - use the `srcset`
    attribute of the `img` tag to enable your browser to make smart decisions about
    serving images. Browser support for `srcset` is great, and non-supporting browsers
    will fall back to the `src` attribute. The browser makes the final decision of
    which image is best to use, based on pixel density, zoom level, and other factors,
    such as network conditions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为视网膜设备开发需要额外的工作。我的建议是尽可能使用SVG作为为视网膜设备提供超清晰图像的首选。在SVG不可行的情况下——即照片——使用`img`标签的`srcset`属性，让浏览器能够智能地决定提供图像。`srcset`的浏览器支持很好，不支持的浏览器将退回到`src`属性。浏览器根据像素密度、缩放级别和其他因素，比如网络条件，最终决定使用哪个图像。
- en: In the next [Chapter 9](part0199.html#5TOVU0-a72d261cc09f412988422c8a08f12cd5),
    *Flexbox*, *Part 1*, we'll look at an alternate and better solution for laying
    out parts of our web page using flexible boxes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[第9章](part0199.html#5TOVU0-a72d261cc09f412988422c8a08f12cd5)，*Flexbox*，*Part
    1*，我们将看到一个用弹性盒子布局网页部分的替代和更好的解决方案。
