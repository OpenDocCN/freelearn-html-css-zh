- en: Flexbox, Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flexbox，第2部分
- en: 'Let''s carry on our exploration of flexbox and the power it offers. You should
    have the basics under your belt now, so in this chapter we''ll go ahead and build
    a new section—the product listing that you see below—to get some practical experience
    of building things with flexbox:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索伸缩盒和它所提供的功能。你现在应该已经掌握了基础知识，所以在本章中，我们将继续构建一个新的部分——下面你看到的产品列表，以便获得一些使用伸缩盒构建实际内容的实践经验：
- en: '![](img/00438.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00438.jpeg)'
- en: We'll also talk about what needs to be prefixed when using flexbox, and how
    to add prefixes in the easiest way possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论在使用伸缩盒时需要添加前缀的内容，以及如何以最简单的方式添加前缀。
- en: 'We are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Building a new section using flexbox
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用伸缩盒构建一个新的部分
- en: Using flex-wrap and align-content
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用flex-wrap和align-content
- en: Changing the display order of flex items
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改伸缩项的显示顺序
- en: Handling vendor prefixes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理供应商前缀
- en: Building the product listing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建产品列表
- en: 'Let''s build a product listing with flexbox. We''re going to see what else
    we can build with flexbox by creating a product listing. We''ll explore two new
    flexbox properties: `align-items` and `align-self`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用伸缩盒构建一个产品列表。我们将通过创建一个产品列表来看看我们还可以用伸缩盒构建什么。我们将探讨两个新的伸缩盒属性：`align-items`和`align-self`。
- en: Using align-items
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用align-items
- en: 'To build the product listing, we''re going to start with some new markup that
    will sit directly above the footer:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建产品列表，我们将从一些新的标记开始，这些标记将直接位于页脚上方：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's quite a bit of markup, but it's not very complex. There's an unordered
    list with six list items (`<li>` tags). Each list item has an SVG image (`<figure><img></figure>`),
    a headline (`<h2>`), a paragraph (`<p>`), and an anchor (`<a>`). In the previous
    code snippet, I've omitted the guts of all the list items except for the first
    one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 标记相当多，但并不是很复杂。有一个无序列表，其中包含六个列表项（`<li>`标签）。每个列表项都有一个SVG图像（`<figure><img></figure>`）、一个标题（`<h2>`）、一个段落（`<p>`）和一个锚点（`<a>`）。在前面的代码片段中，我省略了除第一个之外所有列表项的内容。
- en: 'We''re also starting with some CSS that bootstraps this section:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将从一些CSS开始引导这一部分：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s what we''re starting with in our product listing:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们产品列表的初始内容：
- en: '![](img/00439.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00439.jpeg)'
- en: 'We want each list item to have its contents laid out horizontally. We can target
    the class, `product-list-item`, and use `display: flex`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '我们希望每个列表项的内容都水平排列。我们可以选择类`product-list-item`，并使用`display: flex`：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This ruleset is targeting six different `li` tags with the class of `product-list-item`.
    This is important because we have six different flex containers. Adding `display:
    flex` should lay out all the different flex items in each flex container—horizontally.
    Because that''s what flexbox does. By default `flex-direction` is `row`, so everything
    is laid out in a row:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '这个规则集是针对具有`product-list-item`类的六个不同的`li`标签。这很重要，因为我们有六个不同的伸缩容器。添加`display:
    flex`应该会水平排列每个伸缩容器中的所有不同伸缩项。因为这就是伸缩盒的作用。默认情况下，`flex-direction`是`row`，所以一切都是水平排列的：'
- en: '![](img/00440.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00440.jpeg)'
- en: 'Alright, so things don''t look great. One of the things we can do is add `flex-basis`
    with a value of `250px` to the `h2`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，看起来不太好。我们可以做的一件事是给`h2`添加一个值为`250px`的`flex-basis`：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should add some semblance of organization and it does:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该增加一些组织性，而且确实做到了：
- en: '![](img/00441.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00441.jpeg)'
- en: 'Now, let''s use automatic margins to align the button to the far right edge:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用自动边距将按钮对齐到最右边缘：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Reviewing what we learned in the last section, `margin-left: auto` is going
    to auto calculate the amount of margin it has to the left of the button and push
    it all the way to the far right. This is much better, but still, things are a
    little tight:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '回顾我们在上一节学到的内容，`margin-left: auto`将自动计算按钮左侧的边距，并将其推到最右边。这好多了，但是仍然有点紧：'
- en: '![](img/00442.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00442.jpeg)'
- en: 'Let''s fix this with a new property called `align-items`. So these buttons
    are way too close to each other and this paragraph sits up high. We want the images,
    the headline, the paragraph and the button all centered vertically. The `align-items`
    is a property that can be used on flex containers that controls the positioning
    of flex items along the cross axis. Here''s that diagram again to remind us of
    where the cross axis runs when `flex-direction` is set to `row`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个叫做`align-items`的新属性来解决这个问题。所以这些按钮彼此之间太近了，而这段落却高高地坐着。我们希望图片、标题、段落和按钮都垂直居中。`align-items`是一个可以用在伸缩容器上的属性，它控制了伸缩项沿交叉轴的定位。这里再次提醒我们，当`flex-direction`设置为`row`时，交叉轴的方向是怎样的：
- en: '![](img/00443.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00443.jpeg)'
- en: 'As we can see, the cross axis runs from top to bottom when `flex-direction`
    is row. We''ll add `align-items` with a value of `center`. And that really won''t
    do much noticeably unless we add a `height` of `80px`. So let''s do that too:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，当`flex-direction`为行时，交叉轴从上到下。我们将添加一个值为`center`的`align-items`。这实际上不会有太明显的效果，除非我们添加一个`height`为`80px`。所以我们也来做这个：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, using `align-items: center` will align items in the middle of the cross
    axis:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，使用`align-items: center`将使项目在交叉轴中间对齐：'
- en: '![](img/00444.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00444.jpeg)'
- en: Okay, not bad! All our flex items are centered vertically, with one property,
    and each item has a different height. Also, I want to note that the default value
    of `align-items` is `stretch`, which forces the flex item to stretch from the
    start of the cross axis to the end of it. This is the reason why flexbox comes
    standard with equal height columns.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！我们所有的伸缩项都是垂直居中的，只用了一个属性，而且每个项目的高度都不同。另外，我想指出`align-items`的默认值是`stretch`，它会强制伸缩项从交叉轴的起始位置拉伸到结束位置。这就是为什么伸缩盒默认提供了等高列。
- en: 'We can also use `flex-start`, which aligns all the flex items to the top of
    the flex container or the start of the cross axis:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`flex-start`，它将所有伸缩项对齐到伸缩容器的顶部或交叉轴的起始位置：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Following is the output of preceding code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/00445.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00445.jpeg)'
- en: 'Let''s try `flex-end`, which will align all the flex items—you guessed it—to
    the bottom or the end of the cross axis:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试`flex-end`，这将使所有的伸缩项目对齐到底部或交叉轴的末尾：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our flex items are now aligned to the end of the cross axis—the bottom:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的伸缩项目现在对齐到了交叉轴的末尾——底部：
- en: '![](img/00446.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00446.jpeg)'
- en: 'Let''s change this back to `center`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个改回到`center`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s go back to our three columns; we still have problems with our images
    and headlines aligned to the left, and we want them to be centered:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到我们的三列；我们仍然有图片和标题对齐到左边的问题，我们希望它们居中：
- en: '![](img/00447.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00447.jpeg)'
- en: Let's see how we can use `align-items` to center our sea creatures and headlines,
    when the `flex-direction` is set to `column`. In this use case, the cross axis
    runs horizontally.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`align-items`来在`flex-direction`设置为`column`时居中我们的海洋生物和标题。在这种情况下，交叉轴是水平的。
- en: '![](img/00448.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00448.jpeg)'
- en: 'This is good news. Since `align-items` is used for alignment on the cross axis,
    which runs horizontally for `flex-direction: column`, this should center our sea
    creature images and headlines.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '这是个好消息。因为`align-items`用于在交叉轴上对齐，而对于`flex-direction: column`来说，交叉轴是水平的，这应该会使我们的海洋生物图片和标题居中。'
- en: 'Remembering that each `.column` is a flex item of `.columns`, but also its
    own flex container for its own flex items. Those flex items being things like
    the sea creature image, the headline, the paragraph, and the button. So each column
    is its own flex container. We can use `align-items: center`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '记住每个`.column`都是`.columns`的一个伸缩项目，但也是其自己的伸缩项目，拥有自己的伸缩项目。这些伸缩项目包括海洋生物图片、标题、段落和按钮等。所以每一列都是其自己的伸缩项目。我们可以使用`align-items:
    center`：'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So here''s what we end up with:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们最终得到的结果：
- en: '![](img/00449.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00449.jpeg)'
- en: 'Things are centered, like the headline and the button at the bottom, but our
    sea creature images have totally disappeared and our buttons have shrunk. Let''s
    tackle these problems one at a time, starting by thinking about why our sea creatures
    have disappeared. Let''s inspect in the general vicinity of where the sea creatures
    would be and find the images:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 事情都居中了，就像标题和底部的按钮一样，但我们的海洋生物图片完全消失了，我们的按钮也变小了。让我们逐个解决这些问题，首先考虑一下为什么我们的海洋生物消失了。让我们在海洋生物应该出现的地方附近检查并找到图片：
- en: '![](img/00450.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00450.jpeg)'
- en: Inspecting the `figure` element that holds the `img` element in the DevTools
    shows that the width is 0 and the height is 150\. So why would the width be 0
    if we have this CSS in place?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevTools中检查包含`img`元素的`figure`元素，显示宽度为0，高度为150。那么如果我们已经设置了这个CSS，为什么宽度会是0呢？
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Well, we don''t have an explicit `width` set for these SVGs. We have a `max-width`
    set but that really doesn''t force a width. Recall that `max-width` just says,
    "never be wider than x number of pixels", but doesn''t enforce any width below
    that threshold. And our `flex-basis` of `150px` is controlling the height because
    the `flex-direction` is `column`. We never set a true width at all. When we set
    `align-items: center`, it forces the elements to only take up as much width or
    height as they need, almost like when you `float` a block-level element to the
    `left` or `right`. Also, SVG is unique in the universe of images. Traditional
    images like PNG''s and JPG''s have set dimensions even if nothing is specified
    in the CSS. SVG''s, since they are scalable to any size big or small, don''t have
    a baseline size. Since there are never any widths or heights set for the `figure`
    or `img`, the `align-items` property kind of squeezes the width to 0, which is
    why they vanished on us.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '嗯，我们没有为这些SVG设置明确的`width`。我们设置了`max-width`，但这实际上并没有强制设置宽度。请记住，`max-width`只是说“永远不要超过x像素宽度”，但不会强制在该阈值以下设置任何宽度。我们的`flex-basis`是`150px`，因为`flex-direction`是`column`，所以它控制了高度。我们根本没有设置真正的宽度。当我们设置`align-items:
    center`时，它会强制元素只占据它们需要的宽度或高度，几乎就像当你将块级元素`float`到`left`或`right`时一样。此外，SVG在图像的宇宙中是独一无二的。传统的PNG和JPG图像即使在CSS中没有指定任何尺寸，也有固定的尺寸。而SVG可以按比例缩放到任何大小，因此没有基准尺寸。由于`figure`或`img`都没有设置宽度或高度，`align-items`属性会将宽度挤压为0，这就是它们消失的原因。'
- en: 'This is easily fixable; we''ll just add a `width`. Let''s make it even a little
    smaller than they were before, about 50 percent of their container:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易解决；我们只需要添加一个`width`。让它比以前的尺寸更小一点，大约是其容器的50%：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our sea creatures are back!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的海洋生物又回来了！
- en: '![](img/00451.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00451.jpeg)'
- en: The buttons at the bottom have the same problem as our images just had; they
    don't have any `padding` or `width` set, so `align-items` forces the width to
    only be as wide as the content, hence why they look all squished and small.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的按钮和我们刚刚遇到的图片有相同的问题；它们没有设置任何`padding`或`width`，所以`align-items`强制宽度只能与内容一样宽，这就是为什么它们看起来都被挤压得很小。
- en: 'The solution for this is the same: just set a `width`. Let''s have the `width`
    as `90%` in this case:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是一样的：只需设置一个`width`。在这种情况下，让`width`为`90%`：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That fixes that problem:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决了：
- en: '![](img/00452.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00452.jpeg)'
- en: Using the align-self Flexbox property
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`align-self`伸缩属性
- en: Looks good, but what if I don't want all the flex items to be centered? I might
    prefer the `h2` to be aligned to `flex-start` (in fact I do). The `align-items`
    is a property used on the flex container to control the cross axis alignment of
    all flex items. Another, flexbox property called `align-self` controls alignment
    along the cross axis but is a property used directly on flex items. This will
    help us aligning only our `h2` to the left.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，但如果我不想让所有的伸缩项目都居中怎么办？我可能更喜欢`h2`对齐到`flex-start`（事实上我是这样做的）。`align-items`是一个用于控制所有伸缩项目在交叉轴上对齐的属性。另一个名为`align-self`的flexbox属性控制沿交叉轴的对齐，但是直接用于伸缩项目。这将帮助我们只将我们的`h2`对齐到左边。
- en: 'Let''s create a new selector for the `h2` and add `align-self: flex-start`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们为`h2`创建一个新的选择器，并添加`align-self: flex-start`：'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that `align-self` is a property only for flex items; its default value
    is `auto`, which means tells it to check the value of `align-items` for cross
    axis alignment. It also accepts `stretch`, `flex-start`, `flex-end`, `center`,
    and `baseline`. It allows us to override the `align-items` value for a single
    flex item.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`align-self`是仅适用于flex项的属性；它的默认值是`auto`，这意味着它告诉它检查`align-items`的值以进行交叉轴对齐。它还接受`stretch`、`flex-start`、`flex-end`、`center`和`baseline`。它允许我们覆盖单个flex项的`align-items`值。
- en: 'If we refresh the browser now, we will see that our `h2` tags are aligned to
    the left - at their `flex-start`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在刷新浏览器，我们会看到我们的`h2`标签对齐到左侧-在它们的`flex-start`：
- en: '![](img/00453.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00453.jpeg)'
- en: We're looking good now. Let's take a minute to quickly fix a bug we created
    a little while back. We'll take a look at this bug as we inspect the page by right-clicking
    and choosing Inspect; we'll move the DevTools to the right in Chrome. I'll just
    resize it to tablet size; we can see the problem now, our sea creatures are out
    of control!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看起来不错。让我们花一分钟快速修复一下我们之前创建的一个错误。我们将通过右键单击并选择检查来查看这个错误；我们将在Chrome中将DevTools移动到右侧。我只是将它调整到平板尺寸；我们现在可以看到问题了，我们的海洋生物失控了！
- en: '![](img/00454.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00454.jpeg)'
- en: Our columns are all jumbled up on top of each other. So we've got to figure
    out why that's happening. This is because we have `flex-basis` set to `30%` for
    each column. It worked great when `flex-direction` was row, but as you may recall
    from the section *Floats to Flexbox*, we changed `flex-direction` to `column`
    inside a media query for smaller devices. When `flex-direction` is `column`, `flex-basis`
    controls the height instead of the width because the main axis runs vertically
    instead of horizontally in this scenario.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的列都堆叠在一起。所以我们必须弄清楚为什么会发生这种情况。这是因为我们为每列将`flex-basis`设置为`30%`。当`flex-direction`为行时，它运行得很好，但是您可能还记得从*Floats
    to Flexbox*部分，我们在较小设备的媒体查询中将`flex-direction`更改为`column`。当`flex-direction`为`column`时，`flex-basis`控制的是高度而不是宽度，因为在这种情况下，主轴是垂直而不是水平的。
- en: 'So let''s fix this inside of our media query. Let''s create a new selector
    and set `flex-basis` to `auto`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们在媒体查询中修复这个问题。让我们创建一个新的选择器并将`flex-basis`设置为`auto`：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You''ll recall that setting `flex-basis` to `auto` implies this: look at my
    width or height. Because we don''t have a height set explicitly; the height is
    determined by the content, exactly what we want—just have the height be the size
    of the content. Also, I snuck in a `margin-bottom` of `50px` to provide each one
    with a little breathing room between each other:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得，将`flex-basis`设置为`auto`意味着这样做：看看我的宽度或高度。因为我们没有明确设置高度；高度由内容确定，正是我们想要的——只需使高度成为内容的大小。此外，我偷偷加了`margin-bottom`为`50px`，以在它们之间提供一点间隙：
- en: '![](img/00455.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00455.jpeg)'
- en: 'In this section, we built our product listing using flexbox and introduced
    two new flex properties: `align-items` and `align-self`. In the next section,
    I''ll introduce two more properties: `flex-wrap` and `align-content`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用flexbox构建了我们的产品列表，并介绍了两个新的flex属性：`align-items`和`align-self`。在下一节中，我将介绍另外两个属性：`flex-wrap`和`align-content`。
- en: Using flex-wrap and align-content
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flex-wrap和align-content
- en: The `flex-wrap` property allows us to determine whether we are going to wrap
    our content to a second row or squeeze all the flex items into a single row; `align-content`
    determines the alignment of a row that is being wrapped to multiple lines, thus
    becoming multiple rows. They are basically best friends.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-wrap`属性允许我们确定我们是将内容包装到第二行还是将所有flex项挤入单行；`align-content`确定被包装到多行的行的对齐方式，从而变成多行。它们基本上是最好的朋友。'
- en: Using flex-wrap
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flex-wrap
- en: 'We''ll return and use our flexbox sample page (`flexbox.html`) as a playground
    for testing these properties. Here''s our CSS we ended up with in this area:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将返回并使用我们的flexbox示例页面（`flexbox.html`）作为测试这些属性的游乐场。这是我们在这个区域最终得到的CSS：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The flex container has all of the content justified to `flex-start`, or in
    our case, to the left. This is because `flex-direction` is not set, and hence
    it defaults to `row`. The last flex item is being pushed to the far right with
    `margin-left: auto;`. This is how our `flexbox.html` page should look at the moment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'flex容器将所有内容都对齐到`flex-start`，或者在我们的情况下是左侧。这是因为`flex-direction`没有设置，因此默认为`row`。最后一个flex项被推到最右边，使用`margin-left:
    auto;`。这是我们的`flexbox.html`页面目前应该看起来的样子：'
- en: '![](img/00456.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00456.jpeg)'
- en: 'In `flexbox.html`, let''s add quite a few more flex items and save them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`flexbox.html`中，让我们添加更多的flex项并保存它们：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we see how flexbox is really squishing the flex items to fit on one single
    row inside the flex container.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到flexbox是如何真正挤压flex项以适应在flex容器内的一行上的。
- en: '![](img/00457.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00457.jpeg)'
- en: 'So what we''ll do is wrap multiple rows by adding the `flex-wrap` property
    to the flex container with the value of `wrap`. Also, let''s get rid of `margin-left:
    auto` on our last flex item by just removing that entire rule set:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '所以我们将通过将`flex-wrap`属性添加到flex容器中并将值设置为`wrap`来包装多行。此外，让我们通过删除整个规则集来摆脱最后一个flex项上的`margin-left:
    auto`：'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So all the flex items, which were previously shrinking to fit on one row, now
    expand to their natural size; this implies the width of the text plus `20px` of
    `padding` on each side of the text. This creates two rows of content. Good, exactly
    what we want!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有先前收缩以适应一行的flex项现在会扩展到其自然大小；这意味着文本的宽度加上文本两侧的`padding`的`20px`。这创建了两行内容。很好，正是我们想要的！
- en: '![](img/00458.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00458.jpeg)'
- en: 'The default for `flex-wrap` is `nowrap;`. That makes sense because before we
    set it to `wrap` it was forcing all our flex items to fit on one row. As if we
    omitted `flex-wrap` altogether. Let''s swap in `nowrap` to test this out:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-wrap`的默认值是`nowrap;`。这是有道理的，因为在将其设置为`wrap`之前，它强制所有我们的flex项适合一行。就好像我们根本没有省略`flex-wrap`一样。让我们换成`nowrap`来测试一下：'
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As if we never specified a `flex-wrap` at all:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就好像我们根本没有指定`flex-wrap`一样：
- en: '![](img/00459.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00459.jpeg)'
- en: 'There''s also `wrap-reverse;` let''s try that:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`wrap-reverse;`让我们试试：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The last item is now the first, and the first item is the last. Technically,
    the last item is now the fourth on the first row:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个项目现在是第一个，第一个项目是最后一个。从技术上讲，最后一个项目现在是第一行的第四个：
- en: '![](img/00460.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00460.jpeg)'
- en: The cool thing about using `flex-wrap` is that each row now works independently
    of other rows when it comes to properties like `flex-grow`, `flex-shrink`, and
    `justify-content`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flex-wrap`的好处是，现在每一行在`flex-grow`、`flex-shrink`和`justify-content`等属性方面都可以独立工作。
- en: 'Let''s test it out and add `flex-grow: 1`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们测试一下，添加`flex-grow: 1`：'
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This redistributes any extra space between the flex items to make sure they
    fill all the leftover space:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这会重新分配任何额外的空间，以确保它们填满所有剩余的空间：
- en: '![](img/00461.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00461.jpeg)'
- en: Each row has their flex items expanded to occupy the extra space. As you can
    see, the first row has its flex items stretched farther to fill up the extra space
    than the row below. In these other two rows underneath it, the flex items are
    only stretched a tiny bit to fill up the extra space.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都将它们的flex项目扩展以占据额外的空间。正如你所看到的，第一行的flex项目被拉伸得更远，以填补比下面一行更多的额外空间。在它下面的另外两行中，flex项目只被拉伸了一点点来填补额外的空间。
- en: 'Let''s take another look at how these rows work independently of each other
    by changing `justify-content` to `space-between` the flex container. We''ll also
    get rid of `flex-grow` on the flex item:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看这些行如何独立于彼此地工作，通过将`justify-content`改为`space-between`在flex容器上。我们还将在flex项目上去掉`flex-grow`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So there''s this extra space allocated between each flex item:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在每个flex项目之间都有额外的空间分配：
- en: '![](img/00462.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00462.jpeg)'
- en: The first row has a lot of extra space, while the second row has only a little
    extra space between each flex item. Again, each row functions independently of
    each other on how to handle `flex-grow`, `flex-shrink`, and `justify-content`.
    This is the sort of stuff that works extremely well with dynamic, unknown quantities
    of content coming from a **content management system** (**CMS**).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行有很多额外的空间，而第二行在每个flex项目之间只有一点额外的空间。同样，每一行在处理`flex-grow`、`flex-shrink`和`justify-content`时都是独立的。这种情况非常适合来自**内容管理系统**（**CMS**）的动态、未知数量的内容。
- en: Using align-content
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用align-content
- en: Alright, let's take a look at another property called `align-content`. Like
    `flex-wrap`, `align-content` is a property that only works on the flex container;
    however, `align-content` is dependent on `flex-wrap` being set to `wrap` or `wrap-reverse`,
    which means `align-content` is ignored under all other scenarios. Also, `align-content`
    is similar to `align-items` because it controls arrangements or alignments along
    the cross axis. The only difference is that instead of redistributing each *flex
    item* along the cross axis, it redistributes each *row* along the cross axis.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们再看看另一个叫做`align-content`的属性。像`flex-wrap`一样，`align-content`是一个只在flex容器上工作的属性；然而，`align-content`依赖于`flex-wrap`被设置为`wrap`或`wrap-reverse`，这意味着在所有其他情况下`align-content`都会被忽略。此外，`align-content`类似于`align-items`，因为它控制沿交叉轴的排列或对齐。唯一的区别是，它不是在交叉轴上重新分配每个*flex项目*，而是在交叉轴上重新分配每个*行*。
- en: 'Let''s set a `align-content` to `space-between`. We''ll also give it a height
    of `300px` and a dark gray border:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`align-content`设置为`space-between`。我们还将其高度设置为`300px`，并给它一个深灰色的边框：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And I''m also going to double the number of flex items to keep things interesting:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要把flex项目的数量加倍，以保持事情的趣味性：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we have 3 rows and we have space between each row thanks to `align-content`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有3行，并且由于`align-content`，每行之间有空间：
- en: '![](img/00463.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00463.jpeg)'
- en: The `height` property is relevant because if omitted, the height of the flex
    container will only be as tall as its flex items; therefore, `align-content` wouldn't
    do anything because there wouldn't be any extra vertical space to play with. Other
    values aside from `space-between` for `align-items` include `flex-start`, `flex-end`,
    `center`, and `space-around`. These values should be familiar from when we studied
    the `justify-content` property. The default value is `stretch`. The `space-around`
    value redistributes the extra space around all the items evenly, including the
    first and the last.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`height`属性是相关的，因为如果省略，flex容器的高度只会和其flex项目一样高；因此，`align-content`不会起作用，因为没有额外的垂直空间可供使用。除了`space-between`之外，`align-items`的其他值包括`flex-start`、`flex-end`、`center`和`space-around`。这些值应该是我们在学习`justify-content`属性时熟悉的。默认值是`stretch`。`space-around`值会均匀地重新分配所有项目周围的额外空间，包括第一个和最后一个。'
- en: 'So let''s change it from `space-between` to `space-around`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们把它从`space-between`改为`space-around`：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can see with space-around, there is a space between the top of the flex
    container and the first row and the bottom of the container and the last row:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，使用`space-around`，在flex容器的顶部和第一行之间以及容器底部和最后一行之间有一些空间：
- en: '![](img/00464.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00464.jpeg)'
- en: Whereas `space-between` had the first and last rows hugging tightly to the flex
    container, which is a subtle difference. Again we've noticed this subtlety from
    before when we studied `justify-content`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 而`space-between`让第一行和最后一行紧紧贴着flex容器，这是一个细微的差别。我们之前在学习`justify-content`时也注意到了这种微妙之处。
- en: 'Now let''s change the value of `align-content` to `center`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`align-content`的值改为`center`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we would expect, our rows are centered:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，我们的行是居中的：
- en: '![](img/00465.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00465.jpeg)'
- en: 'Let''s change `flex-direction` to column now to see how `flex-wrap` and `align-content`
    work together in this use case:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`flex-direction`改为列，看看在这种情况下`flex-wrap`和`align-content`是如何一起工作的：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So there''s a lot going on here, and it''s hard to tell exactly what, but one
    thing we can say is we are centered horizontally:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，很难准确地说是什么，但我们可以说的一件事是我们在水平方向上是居中的：
- en: '![](img/00466.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00466.jpeg)'
- en: 'Let''s simplify this a little to comprehend what''s happening. First, let''s
    change `flex-wrap` from `wrap-reverse` back to just `wrap`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简化一下，以理解发生了什么。首先，让我们将`flex-wrap`从`wrap-reverse`改回`wrap`：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `flexbox.html`, we''ll reduce the number of flex items considerably:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`flexbox.html`中，我们将大大减少flex项目的数量：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, it''s a little easier to see that `flex-direction` is `column`, which
    forces two vertical columns because `flex-wrap` is set to `wrap` and we are out
    of available space for all 6 flex items:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更容易看到`flex-direction`是`column`，这会强制两个垂直列，因为`flex-wrap`设置为`wrap`，并且我们没有足够的空间容纳所有6个伸缩项目：
- en: '![](img/00467.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00467.jpeg)'
- en: Our `space-between` setting for `justify-content` is redistributing the extra
    space between each flex item. Notice how both the columns are getting their extra
    space redistributed independently, as shown in the following diagram.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`justify-content`设置的`space-between`正在在每个伸缩项目之间重新分配额外的空间。请注意，两列都独立地重新分配了它们的额外空间，如下图所示。
- en: When there is extra space along the cross axis and multiple rows, `align-content`
    is used to arrange rows along the cross axis. And as we know the cross axis runs
    from top to bottom when `flex-direction` is row.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当交叉轴上有额外空间和多行时，使用`align-content`来排列交叉轴上的行。正如我们所知，当`flex-direction`为行时，交叉轴从上到下运行。
- en: '![](img/00468.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00468.jpeg)'
- en: 'And, the cross axis runs from left to right when `flex-direction` is column:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当`flex-direction`为列时，交叉轴从左到右运行：
- en: '![](img/00469.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00469.jpeg)'
- en: My apologies, if I'm starting to sound like a broken record, but I feel it's
    important to over-communicate things that are important to how flexbox operates.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我开始听起来像一个重复的唱片，我很抱歉，但我觉得重复强调伸缩盒的运作方式是很重要的。
- en: Using the flex-flow shorthand
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`flex-flow`缩写
- en: 'Previously, we looked at how the `flex` shorthand combined `flex-grow`, `flex-shrink`,
    and `flex-basis` together. Let''s introduce another shorthand, `flex-flow`, which
    will allow us to cut down on our properties a bit by combining `flex-direction`
    and `flex-wrap` together. Anyway, this simplifies our CSS a little bit:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到`flex`缩写如何将`flex-grow`、`flex-shrink`和`flex-basis`组合在一起。让我们介绍另一个缩写，`flex-flow`，它将允许我们通过将`flex-direction`和`flex-wrap`组合在一起来减少一些属性。无论如何，这会简化我们的CSS代码：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Nothing changes, which is exactly what we want when we refactor using a shorthand:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 没有变化，这正是我们在使用缩写重构时想要的：
- en: '![](img/00470.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00470.jpeg)'
- en: Given how closely dependent `align-content` is on `flex-wrap`, I would expect
    `align-content` to be part of the `flex-flow` shorthand. However, `align-content`
    isn't part of the `flex-flow` shorthand with `flex-direction` and `flex-wrap`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`align-content`与`flex-wrap`的密切依赖，我期望`align-content`是`flex-flow`的一部分。然而，`align-content`并不是`flex-flow`的一部分，它与`flex-direction`和`flex-wrap`一起。
- en: In this section, you learned how `flex-wrap` allows us to create multiple streams—or
    rows—of content, while `align-items` positions those multiple rows within their
    container along the cross axis.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了`flex-wrap`如何允许我们创建多个流或行的内容，而`align-items`则将这些多行定位在其容器的交叉轴上。
- en: Changing the display order of flex items
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改伸缩项目的显示顺序
- en: In this section, we'll talk about how we can change the display order of flex
    items and how this can be helpful for responsive web design. We'll also talk about
    how this impacts web accessibility.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何更改伸缩项目的显示顺序以及这如何有助于响应式网页设计。我们还将讨论这如何影响网页可访问性。
- en: 'At wider screen widths, the content is displayed horizontally: first with the
    octopus, then the crab, and then the whale:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在较宽的屏幕宽度下，内容水平显示：首先是章鱼，然后是螃蟹，然后是鲸鱼：
- en: '![](img/00471.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00471.jpeg)'
- en: 'At narrower device widths, the content is displayed in the same order, just
    vertically, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在较窄的设备宽度下，内容以与源顺序相同的顺序显示，只是垂直显示，如下面的屏幕截图所示：
- en: '![](img/00472.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00472.jpeg)'
- en: In both the cases, the display order is identical to the source order, and this
    makes sense in this scenario.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，显示顺序与源顺序相同，在这种情况下是有意义的。
- en: 'Let''s do something different here. Let''s say we''re working with a designer
    who wants to feature the crab this week and give it visual priority over the octopus
    and whale. That''s what we have done here. I''ve added a little extra to the HTML
    and CSS to achieve this new featured treatment:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里做点不同的事情。假设我们正在与一位设计师合作，他希望本周突出显示螃蟹，并在视觉上优先于章鱼和鲸鱼。这就是我们在这里所做的。我在HTML和CSS中添加了一些额外的内容来实现这种新的特色处理：
- en: '![](img/00473.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00473.jpeg)'
- en: In the markup, I added a number to the headline of each column so we can easily
    remember the source order when viewing in the browser. Then, for the crab, I added
    a class called `featured` and a `div` tag with a class called `ribbon`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记中，我为每列的标题添加了一个数字，这样我们在浏览器中查看时就可以轻松记住源顺序。然后，对于螃蟹，我添加了一个名为`featured`的类和一个名为`ribbon`的`div`标签。
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I''ve added some CSS to style the ribbon:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一些CSS来样式化丝带。
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You may have noticed that the featured ribbon was stretched across the top;
    this was done using `align-self: stretch`. As we already discussed, `align- self`
    aligns flex items along the cross axis, which in our case runs from left to right
    since `flex-direction` is set to `column`. The `align-self` property is like `align-items`,
    except that it''s used on a flex item and overrides the `align-items` property.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '您可能已经注意到，特色丝带被拉伸横跨顶部；这是使用`align-self: stretch`完成的。正如我们已经讨论过的，`align-self`沿着交叉轴对齐伸缩项目，在我们的情况下，由于`flex-direction`设置为`column`，交叉轴从左到右。`align-self`属性类似于`align-items`，不同之处在于它用于伸缩项目并覆盖`align-items`属性。'
- en: On the desktop or a wider view, our business partners and designers are really
    happy when they see this. But on a mobile, they are saying, *"Mmmmm, I don't know,
    the crab is still showing second."* And they might be right, it's the featured
    content, so it should not only be visually featured, it should also appear first.
    Well, if our content was coming from a database, we could update it so the crab
    would appear first; alternatively, we could use some JavaScript to rearrange our
    featured content to put the crab first. Both of these solutions are, at a minimum,
    not ideal.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面或更宽的视图上，当我们的业务合作伙伴和设计师看到这一点时，他们真的很高兴。但在手机上，他们说，“嗯，我不知道，螃蟹仍然显示为第二。”他们可能是对的，这是特色内容，所以它不仅应该在视觉上突出，而且还应该首先出现。如果我们的内容来自数据库，我们可以更新它，使螃蟹首先出现；或者，我们可以使用一些JavaScript来重新排列我们的特色内容，使螃蟹首先出现。这两种解决方案，至少不是理想的。
- en: 'Flexbox comes to the rescue here. In our media query for smaller devices we
    can use a property for flex items called `order`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox在这里派上了用场。在我们针对较小设备的媒体查询中，我们可以使用一个名为`order`的flex项目属性：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Alright, when I refresh the browser, it instantly moves our crab to the first
    position, as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，当我刷新浏览器时，它立即将我们的螃蟹移动到了第一个位置，如下面的截图所示：
- en: '![](img/00474.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00474.jpeg)'
- en: By default, all flex items are given an `order` of `0`, so providing `-1` moved
    the crab to the top. The order of items runs with the main axis; the lowest-ordered
    flex item will be at the start of the main axis, while the highest-ordered flex
    items will appear at the end of the main axis.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有flex项目都被赋予`order`为`0`，所以提供`-1`将螃蟹移到了顶部。项目的顺序与主轴一起运行；最低顺序的flex项目将位于主轴的开始，而最高顺序的flex项目将出现在主轴的末尾。
- en: 'Again, in our case, since `flex-direction` is `column`, the main axis runs
    from top to bottom. Let''s change the `order` to `1`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在我们的情况下，由于`flex-direction`是`column`，主轴从上到下运行。让我们把`order`改为`1`：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This moves the crab to the bottom because since both the octopus and whale
    are, by default, `0` - and, we''ve specified the crab as `1`—so now it''s placed
    at the end:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将螃蟹移到底部，因为默认情况下章鱼和鲸鱼都是`0`，而我们已经指定螃蟹为`1`—所以现在它被放在了最后：
- en: '![](img/00475.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00475.jpeg)'
- en: 'Alright, let''s add two more rulesets:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们再添加两个规则集：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''re using the `nth-child` pseudo classes to mix up the order a bit. When
    we refresh the browser now, the crab is first in display order (second in the
    source order), the whale is second (but third in the source order), and the octopus
    is third (but first in the source order). This is what it should look like:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`nth-child`伪类来改变顺序。现在刷新浏览器后，螃蟹在显示顺序中是第一个（源顺序中是第二个），鲸鱼是第二个（但源顺序中是第三个），章鱼是第三个（但源顺序中是第一个）。这就是它应该看起来的样子：
- en: '![](img/00476.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00476.jpeg)'
- en: 'So I can also put them in reverse order. I already have the first one as third,
    and I can make the second one second, and the third one first:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我也可以按相反的顺序放置它们。我已经把第一个作为第三个，我可以把第二个作为第二个，第三个作为第一个：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is what we should see:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们应该看到的：
- en: '![](img/00477.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00477.jpeg)'
- en: 'Now we have the third as the first, second as second, and the first as third.
    Reverse order. But remember, I have an easier way to do this; I can actually just
    get rid of all three of these rulesets and just specify `flex-direction` as `column-reverse`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们把第三个作为第一个，第二个作为第二个，第一个作为第三个。相反的顺序。但请记住，我有一个更简单的方法来做到这一点；我实际上可以摆脱这三个规则集，只需指定`flex-direction`为`column-reverse`：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now when I refresh the browser, they''re still in reverse order:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我刷新浏览器时，它们仍然是相反的顺序：
- en: '![](img/00478.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00478.jpeg)'
- en: Accessibility impact
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无障碍影响
- en: 'One thing I want to mention is that there''s a downside to changing the display
    order that you may want to be aware of: tabbing through content. The tab order
    is still based on the source order, which becomes an accessibility issue. Now
    you might be thinking that in our example, the tab order is logical on a desktop
    but only becomes out of logic on smaller devices, such as phones, which most likely,
    but not always, will not be tabbing through fields. Perhaps that''s mostly true;
    however, changing the display order is also a problem for screen readers, such
    as JAWS, which read the content to visually impaired users based on the source
    order and not the display order. So, your content will still be announced by the
    screen reader based on the source order, which will not be in sync with the visual
    order. This could be an accessibility issue. So, it''s good to just keep this
    in mind if changing the order.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提一下的一件事是，改变显示顺序有一个缺点，你可能需要注意：通过内容进行制表。制表顺序仍然基于源顺序，这成为一个无障碍问题。现在你可能会认为在我们的例子中，制表顺序在桌面上是合乎逻辑的，但在较小的设备上，比如手机上，它可能会变得不合逻辑，尽管大多数情况下不会通过字段进行制表。也许这大多数是正确的；然而，改变显示顺序对于屏幕阅读器，比如JAWS，也是一个问题，它根据源顺序而不是显示顺序向视力受损的用户读取内容。因此，你的内容仍然会根据源顺序被屏幕阅读器宣布，这将与视觉顺序不同步。这可能是一个无障碍问题。因此，如果改变顺序，最好记住这一点。
- en: In this section, you learned how the `order` property can change the display
    order of flex items within a flex container and how that impacts tab sequence
    and accessibility.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你学会了`order`属性如何改变flex容器中flex项目的显示顺序，以及它对制表顺序和无障碍的影响。
- en: Vendor prefixes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商前缀
- en: Let's talk about vendor prefixes. In this section, we'll talk about browser
    support for flexbox and how we should add vendor prefixes to our flexbox CSS in
    order to get deeper flexbox support. We'll also talk about something called **Autoprefixer**,
    which helps us add those prefixes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈供应商前缀。在这一部分，我们将讨论flexbox的浏览器支持以及如何在我们的flexbox CSS中添加供应商前缀以获得更深入的flexbox支持。我们还将谈论一个叫做**Autoprefixer**的东西，它可以帮助我们添加这些前缀。
- en: Flexbox support starts at IE10 and later version if we use the `-ms-` vendor
    prefix. But this might not be the only vendor prefix you want to add since the
    W3C specification has actually changed since it was first implemented in browsers.
    When it was implemented, the syntax and property names were different from that
    they are today. To get deep browser support, we can use an older syntax combined
    with the newer syntax to support some of the early adopting browsers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox支持从IE10开始，如果我们使用`-ms-`供应商前缀。但这可能不是您想要添加的唯一供应商前缀，因为自从浏览器首次实现以来，W3C规范实际上已经发生了变化。当它被实现时，语法和属性名称与今天的不同。为了获得深度浏览器支持，我们可以使用旧语法结合新语法来支持一些早期采用的浏览器。
- en: 'Let''s update our original ruleset where we first added flexbox, which was
    our `.columns`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们最初添加flexbox的原始规则集，这是我们的`.columns`：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Wow! There''s a ton going on here. We''re not just adding `-ms-`, `-moz-`,
    and `-webkit-` to the beginning of the property. We''re adding the vendor prefix
    to the start of the value when it comes to the values for the `display` property.
    And the values themselves aren''t very different from our non-prefixed version.
    And there''s 2 `-webkit-`values! Chrome and Safari were really early adopters
    of flexbox, so there''s actually two different prefixes that WebKit browsers were
    supporting: `-webkit-box` and `-webkit-flex`. So, that''s a lot of prefixes and
    a lot of memorizing and it looks just as crazy for the `justify-content` property.
    This is a lot. The tricky part is learning and remembering the older syntax, especially
    since it''s not obvious which prefixes are still needed.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这里有很多事情。我们不仅仅是在属性的开头添加`-ms-`，`-moz-`和`-webkit-`。当涉及到`display`属性的值时，我们将供应商前缀添加到值的开头。值本身与我们的非前缀版本并没有太大不同。还有2个`-webkit-`值！Chrome和Safari真的是flexbox的早期采用者，所以实际上有两个不同的前缀，WebKit浏览器支持：`-webkit-box`和`-webkit-flex`。所以，这是很多前缀和很多记忆，对于`justify-content`属性看起来也很疯狂。这是很多。棘手的部分是学习和记住旧的语法，特别是因为不明显哪些前缀仍然是必需的。
- en: Autoprefixer
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Autoprefixer
- en: 'Here''s where a tool such as Autoprefixer CSS online ([https://autoprefixer.github.io/](https://autoprefixer.github.io/))
    can be super helpful. It provides the prefixes we need based on the total market
    share of the browsers and the number of versions we want to go back for each browser.
    Let''s update this filter to `.01%`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Autoprefixer CSS在线工具([https://autoprefixer.github.io/](https://autoprefixer.github.io/))可以非常有帮助的地方。它根据浏览器的总市场份额和我们想要为每个浏览器回溯的版本数量提供我们需要的前缀。让我们将这个过滤器更新为`.01%`：
- en: '![](img/00479.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00479.jpeg)'
- en: 'Let''s get rid of all these prefixes and just copy and paste this ruleset to
    the left box of the Autoprefixer tool:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们摆脱所有这些前缀，只需将这个规则集复制粘贴到Autoprefixer工具的左边框中：
- en: '![](img/00480.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00480.jpeg)'
- en: 'On the right-hand side, it provides the prefixes we should use:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，它提供了我们应该使用的前缀：
- en: '![](img/00481.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00481.jpeg)'
- en: 'Let''s copy that back over to our CSS:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它复制回我们的CSS：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is pretty sweet and much easier than memorizing the different syntaxes
    of all the flexbox properties. It would be nice if there were some way to automatically
    add vendor prefixes for us, without us having to do all this copying and pasting.
    One thing we can do is we can use a preprocessor, such as **Sass**, to write something
    called a **mixin** to add vendor prefixes for us, so we don't have to think about
    this as much. We'll look at Sass mixins in the next chapter
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，比记住所有flexbox属性的不同语法要容易得多。如果有一种方法可以自动为我们添加供应商前缀，而不必我们进行所有这些复制和粘贴，那将是很好的。我们可以做的一件事是使用预处理器，比如**Sass**，编写一个称为**mixin**的东西，为我们添加供应商前缀，这样我们就不必太在意这个了。我们将在下一章中看看Sass
    mixins
- en: Gulp
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gulp
- en: 'Now I want to mention something that you may have heard of: Gulp.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我想提一下你可能听说过的东西：Gulp。
- en: '![](img/00482.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00482.jpeg)'
- en: Gulp ([https://gulpjs.com/](https://gulpjs.com/)), and its friend Grunt([https://gruntjs.com/](https://gruntjs.com/)),
    allow us to create build processes that things like minify our CSS and JavaScript
    files, compile Sass into CSS, and even add vendor prefixes to CSS automatically,
    using Autoprefixer. Gulp runs on Node and requires you to download it and then
    download Gulp. You can then download individual tasks, such as Autoprefixer. Learning
    Gulp is far out of the scope of this book, but Gulp is really useful and I really
    like it a lot. In order to get started with it, I highly recommend that you read
    *Getting Started with Gulp*, *Travis Maynard*, *Packt Publishing*, which does
    an excellent job of explaining how to install Gulp, set it up, and use it. This
    is how I learned how to use Gulp, by reading this book.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp ([https://gulpjs.com/](https://gulpjs.com/))及其朋友Grunt([https://gruntjs.com/](https://gruntjs.com/))，允许我们创建构建流程，例如压缩我们的CSS和JavaScript文件，将Sass编译成CSS，甚至自动为CSS添加供应商前缀，使用Autoprefixer。Gulp在Node上运行，需要您下载它，然后下载Gulp。然后您可以下载单独的任务，比如Autoprefixer。学习Gulp远远超出了本书的范围，但Gulp真的非常有用，我非常喜欢它。为了开始使用它，我强烈建议您阅读*Getting
    Started with Gulp*，*Travis Maynard*，*Packt Publishing*，这本书非常好地解释了如何安装Gulp，设置它并使用它。这就是我学会如何使用Gulp的方式，通过阅读这本书。
- en: Gulp is a *command line* tool that you can configure to run Autoprefixer every
    time you save your CSS file. So if I write a flexbox property in my CSS and do
    a *Ctrl* + *S*, Gulp will be watching my file for any deltas and if it detects
    a change, it will tell Autoprefixer to run and update my CSS file with the necessary
    vendor prefixes. I know that sounds weird—update my CSS file with vendor prefixes—but
    technically, what it does is it creates a new CSS file that will have all the
    vendor prefixes. There's more to it than what I've explained here, but check out
    Travis Maynard's book to get it set up. This way, you'll never have to think about
    vendor prefixes again because Autoprefixer and Gulp will do the thinking for you.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp是一个*命令行*工具，你可以配置它在每次保存CSS文件时运行Autoprefixer。所以，如果我在我的CSS中写入一个flexbox属性并按下*Ctrl*
    + *S*，Gulp将会监视我的文件是否有任何变化，如果它检测到变化，它将告诉Autoprefixer运行并使用必要的供应商前缀更新我的CSS文件。我知道这听起来很奇怪——用供应商前缀更新我的CSS文件——但从技术上讲，它所做的是创建一个新的CSS文件，其中包含所有的供应商前缀。这里有比我解释的更多，但是查看Travis
    Maynard的书来设置它。这样，你就再也不用考虑供应商前缀了，因为Autoprefixer和Gulp会为你考虑这些事情。
- en: Flexbox homework assignment
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flexbox作业
- en: 'We''ve built one heck of a site:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了一个了不起的网站：
- en: '![](img/00483.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00483.jpeg)'
- en: 'However, it is not without its problems. One thing you may have noticed is,
    in the product listing section, when we shrink down our browser, it starts to
    look a little wonky, as shown in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它并非没有问题。你可能已经注意到，在产品列表部分，当我们缩小浏览器时，它开始看起来有点怪异，如下面的截图所示：
- en: '![](img/00484.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00484.jpeg)'
- en: One final take-home test for you would be to update the CSS inside a media query
    to make the display look good here in smaller device sizes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个带回家的测试是更新媒体查询内的CSS，使得在较小的设备尺寸下显示效果良好。
- en: In this section, we talked about how we need to add vendor prefixes to our flexbox
    properties in order to get deeper browser support. Vendor prefixes, though, can
    be tricky, and it's best to leave prefixing to a tool such as Autoprefixer. Better
    yet, it's best to automate Autoprefixer so it is executed every time you save
    your CSS file. You can use a task runner, such as Gulp or Grunt, for this.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们谈到了我们需要为我们的flexbox属性添加供应商前缀，以便获得更深层次的浏览器支持。然而，供应商前缀可能会很棘手，最好将前缀添加工具交给像Autoprefixer这样的工具。更好的是，最好自动化Autoprefixer，这样每次保存CSS文件时都会执行它。你可以使用任务运行器，比如Gulp或Grunt来实现这一点。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'That completes our journey through flexbox. We''ve now seen every single one
    of the properties associated with it, and put them into practice building a new
    product listing for our site. In the next chapter, we''ll look at the next steps
    for advancing your skillset and tooling around CSS in the finale: [Chapter 11](part0236.html#7124O0-a72d261cc09f412988422c8a08f12cd5),
    *Wrapping Up*.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对flexbox的探索。我们现在已经看到了与之相关的每一个属性，并将它们应用到了为我们的网站构建新产品列表中。在下一章中，我们将看看在结尾中关于CSS技能和工具的下一步：[第11章](part0236.html#7124O0-a72d261cc09f412988422c8a08f12cd5)，*总结*。
