- en: Chapter 6. Working with Images and Videos in Responsive Web Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。在响应式网页设计中使用图像和视频
- en: I've always called images the "ugly child" of **RWD**. Why? Until the last minute,
    I always tried to avoid having to deal with them. Do I use image sprites? If so,
    do I export my transparent PNG as an 8 bit or 24 bit, or 32 bit? Some legacy IEs
    don't support PNG with alpha channel, so I have to export a GIF sprite. I can
    use SVG instead, but IE8 and below don't support SVG. I can use icon fonts, but
    what happens if the icon font doesn't load? I'm going to have to look up some
    analytics then. There's a new *iDevice* with a new type of high-density screen?
    Now I have to export two (or more) images every single time. Great! But I can't
    serve a high-quality image that's more than double the size of the regular size
    image to small-screen devices! Yeah, it may look good but it'll take forever to
    download, they just might as well leave the site even before the first H1 loads.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直把图像称为**RWD**的“丑陋之子”。为什么？直到最后一刻，我总是试图避免处理它们。我要使用图像精灵吗？如果是的话，我应该将我的透明PNG导出为8位还是24位，或者32位？一些旧版IE不支持带有alpha通道的PNG，所以我必须导出一个GIF精灵。我可以使用SVG，但IE8及更早版本不支持SVG。我可以使用图标字体，但如果图标字体加载失败会怎么样？那我就得查一些分析数据。有一种新的高密度屏幕的*iDevice*？现在我每次都得导出两个（或更多）图像。太好了！但我不能为小屏设备提供超过正常尺寸图像两倍大小的高质量图像！是的，它可能看起来很好，但下载速度会很慢，他们甚至在第一个H1加载之前就可能离开网站。
- en: You get the picture. That's barely scratching the surface of working with media
    in RWD.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你明白了。这只是刚刚开始涉及响应式网页设计中媒体工作的冰山一角。
- en: Some of these thoughts are still very alive today, but I've learned through
    the years that with a bit of common sense and staying on top of the technologies
    that address all these issues, having a straightforward system to deal with images
    (and video) can go a long way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些想法今天仍然非常活跃，但多年来我学到了一些常识，并且紧跟解决所有这些问题的技术，拥有一个简单直接的处理图像（和视频）的系统可以走得更远。
- en: As in the other chapters, we are going to keep things simple but meaningful.
    There is no silver bullet when it comes to images, specifically in RWD, we can
    stay here all day long and that's certainly something we don't want with this
    book. I want you to go build awesome responsive sites as soon as possible. But
    I do encourage you to spend some time researching a bit more about images for
    RWD; it is truly a memorable topic among the web design and developer communities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他章节一样，我们将保持简单但有意义。在涉及图像时并没有银弹，特别是在响应式网页设计中，我们可能整天都在这里，这绝对不是我们这本书想要的。我希望你尽快构建出色的响应式网站。但我鼓励你花一些时间研究更多关于响应式网页设计中图像的内容；这确实是网页设计和开发者社区中一个令人难忘的话题。
- en: 'In this chapter, we''re going to address the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Tips for exporting images and considerably reducing their final file size while
    maintaining the image quality.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出图像并在保持图像质量的同时显著减小其最终文件大小的技巧。
- en: How and when to use the `srcset` and `sizes` attributes, and the `<picture>`
    element.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`srcset`和`sizes`属性，以及`<picture>`元素。
- en: Using `Retina.js`.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Retina.js`。
- en: Making videos responsive.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作响应式视频。
- en: Using `FitVids.js`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FitVids.js`。
- en: 'Using vector formats: Icon Fonts and SVGs.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用矢量格式：图标字体和SVG。
- en: Using the right CSS image replacement technique.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的CSS图像替换技术。
- en: 'Now, here''s the image we''re going to use in our examples:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是我们在示例中要使用的图像：
- en: '![Working with Images and Videos in Responsive Web Design](img/B02102_06_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![在响应式网页设计中使用图像和视频](img/B02102_06_01.jpg)'
- en: These awesome individuals are two Kung Fu grandmasters from the Shaolin Temple
    in China. Their names are Shi DeRu and Shi DeYang.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些了不起的人物是中国少林寺的两位功夫大师。他们的名字是释德如和释德阳。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Shi DeRu and Shi DeYang* by Shi Deru (Shawn Xiangyang Liu), who is the sole
    owner and copyright-holder of the authenticity of the picture taken at the Shaolin
    Temple''s front gate. It is licensed under CC BY-SA 3.0 via Wikipedia. It can
    be found at [http://en.wikipedia.org/wiki/Shaolin_Kung_Fu#/media/File:Shi_DeRu_and_Shi_DeYang.jpg](http://en.wikipedia.org/wiki/Shaolin_Kung_Fu#/media/File:Shi_DeRu_and_Shi_DeYang.jpg).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*释德如和释德阳*由释德如（刘祥阳）拍摄，他是这张照片的唯一所有者和版权持有者，该照片是在少林寺前门拍摄的。它在维基百科上以CC BY-SA 3.0许可证发布。可以在[http://en.wikipedia.org/wiki/Shaolin_Kung_Fu#/media/File:Shi_DeRu_and_Shi_DeYang.jpg](http://en.wikipedia.org/wiki/Shaolin_Kung_Fu#/media/File:Shi_DeRu_and_Shi_DeYang.jpg)找到。'
- en: Since we are also *mastering* RWD with HTML5 and CSS3, I thought this photo
    fit right in with our mission.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还在用HTML5和CSS3*精通*响应式网页设计，我觉得这张照片与我们的使命非常契合。
- en: The properties of the original image of the Kung Fu grandmasters I'm going to
    describe will help set a baseline to understand the before/after effect when optimizing
    images for RWD.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要描述的功夫大师的原始图像的属性将有助于理解为响应式网页设计优化图像前后效果设定基线。
- en: 'Here are the original image''s properties:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是原始图像的属性：
- en: It is a 24-bit JPG image.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一张24位JPG图像。
- en: The file size is 556KB, but it is compressed thanks to the magic of the JPG
    algorithm (about 12 MB decompressed).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小为556KB，但由于JPG算法的魔力而被压缩（解压后约为12MB）。
- en: The dimensions are 2496 x 1664 pixels, which is about 4.15 megapixels. To put
    it in perspective, this image has more resolution than my 55" LED TV in my living
    room.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尺寸为2496 x 1664像素，约为4.15百万像素。换个角度看，这张图像的分辨率比我客厅里的55英寸LED电视还要高。
- en: By the end of book, I assure you two things. One, you'll be absolutely ready
    to build responsive sites and apps. Two, when it's time to start a new project,
    you're going to get up from your seat and strike the same pose these grandmasters
    are doing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书结束时，我向你保证两件事。一，你将绝对准备好构建响应式网站和应用。二，当是时候开始一个新项目时，你将从座位上站起来，并摆出这些大师们正在做的同样的姿势。
- en: Image editing is out of scope of this book and the following steps will require
    image manipulation of some sort. At this point, you can use your favorite image
    editor of choice. I personally use Adobe Fireworks (indeed I do), but the vast
    majority uses Photoshop.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图像编辑超出了本书的范围，以下步骤将需要某种形式的图像处理。在这一点上，您可以使用您喜欢的图像编辑器。我个人使用Adobe Fireworks（确实如此），但绝大多数人使用Photoshop。
- en: 'If you don''t use any of those, you can always use **GNU Image Manipulation
    Software** (**GIMP**) or Paint.NET—both are free. You can download them from here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用其中任何一个，您可以随时使用**GNU图像处理软件**（**GIMP**）或Paint.NET-两者都是免费的。您可以从这里下载它们：
- en: 'GIMP: [http://www.gimp.org/](http://www.gimp.org/)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GIMP：[http://www.gimp.org/](http://www.gimp.org/)
- en: 'Paint.NET: [http://www.getpaint.net/](http://www.getpaint.net/)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paint.NET：[http://www.getpaint.net/](http://www.getpaint.net/)
- en: You can also use an online image editing tool. However, I have to admit though
    that I've never used any of them, so I can't recommend one. At this point what
    I can say is try some of them out and choose the one that best fits your needs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用在线图像编辑工具。但是，我必须承认，我从未使用过其中任何一个，所以我无法推荐任何一个。在这一点上，我可以说的是尝试其中一些，并选择最适合您需求的那个。
- en: Let's get started.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Tips for reducing the file size in images for RWD
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于RWD图像文件大小减小的提示
- en: In design, the rule of thumb when creating copies of an image is to go from
    large to small—never the other way around. In other words, the larger the image,
    the better its subsequent copies will be.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计中，创建图像副本的经验法则是从大到小进行，而不是相反。换句话说，图像越大，其后续副本的质量就越好。
- en: Resizing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整大小
- en: Just by resizing the image from 2496 x 1664 pixels to 1024 x 683 pixels, the
    file size is now 331 KB. This is nearly a 40 percent reduction in file size from
    556 KB. A huge improvement, but we're not there yet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过将图像从2496 x 1664像素调整为1024 x 683像素，文件大小现在为331 KB。与556 KB相比，这几乎是文件大小的40％减少。这是一个巨大的改进，但我们还没有到达目标。
- en: Blurring the background
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊背景
- en: 'Blurring the background is actually quite effective in itself, but it also
    has another benefit from the *art direction* point of view: It helps draw attention
    to the important part(s) of the image.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊背景实际上本身就非常有效，但从*艺术指导*的角度来看，它还有另一个好处：它有助于吸引对图像的重要部分的注意力。
- en: After blurring the background, the file now weighs 185 KB. That's about a 67
    percent reduction in file size from 556 KB. We're starting to get somewhere.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在模糊背景之后，文件现在重量为185 KB。与556 KB相比，文件大小减少了约67％。我们开始有所进展了。
- en: 'Here''s the new image with the blurred background:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有模糊背景的新图像：
- en: '![Blurring the background](img/B02102_06_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![模糊背景](img/B02102_06_02.jpg)'
- en: A huge win for optimization!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 优化的巨大胜利！
- en: Darkening or lightening the less important areas
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暗化或变亮不重要的区域
- en: Darkening or lightening the less important areas is very subjective and many
    may not necessarily agree with it. Under special circumstances, this process—just
    like the background blurring technique—can help reduce the file size and bring
    the important parts of the image out.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 暗化或变亮不重要的区域非常主观，许多人可能不一定同意。在特殊情况下，这个过程-就像背景模糊技术一样-可以帮助减小文件大小并突出图像的重要部分。
- en: What we're basically trying to accomplish by darkening or lightening an image
    is to reduce the amount of colors by creating *solid color* areas, or at least
    as solid as possible. In other words, we're reducing the contrast. Use this trick
    with discretion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上试图通过暗化或变亮图像来减少颜色的数量，从而创建*纯色*区域，或者至少尽可能纯色。换句话说，我们正在减少对比度。谨慎使用这个技巧。
- en: In the case of our Kung Fu grandmasters, after darkening the less important
    parts of the image in the background, the image now weighs 178 KB. Admittedly,
    that's not much different from the former process (only 7 KB difference), but
    any kilobyte we can extract from the image without affecting the quality is always
    a good thing, and 178 KB is about a 68 percent reduction in file size.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的功夫宗师的情况下，在暗化背景中不重要的部分后，图像现在重量为178 KB。诚然，这与以前的过程没有太大不同（只有7 KB的差异），但是我们可以从图像中提取的每一个千字节而不影响质量都是一件好事，178
    KB大约是文件大小的68％减少。
- en: 'This is how the image looks after darkening the background a little:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在稍微暗化背景后图像的外观：
- en: '![Darkening or lightening the less important areas](img/B02102_06_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![暗化或变亮不重要的区域](img/B02102_06_03.jpg)'
- en: Every kilobyte counts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个千字节都很重要。
- en: Optimizing an image
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化图像
- en: This is the last step in the process. This step can actually be divided in two
    smaller steps.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是过程的最后一步。这一步实际上可以分为两个较小的步骤。
- en: Using Adobe Fireworks (optional)
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Adobe Fireworks（可选）
- en: Save a JPG that balances quality versus file size well. There are no determined
    values that can always be applied to every single image. It all happens on the
    fly. When doing this step, you don't want to save the image with too much low
    quality since the image is going to go through another optimization step.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 保存一个在质量与文件大小之间平衡的JPG。没有确定的值可以始终应用于每个单独的图像。这一切都是即兴发生的。在执行此步骤时，您不希望以太低的质量保存图像，因为图像将经历另一个优化步骤。
- en: 'I''m actually going to use a software that Adobe stopped developing back in
    May 2013: Fireworks.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上要使用的是Adobe在2013年5月停止开发的软件：Fireworks。
- en: Fireworks has been known to have a superior image optimization engine than Photoshop,
    I've run tests myself and Fireworks compression versus. quality always showed
    the best results. Fireworks is as relevant to today's web design processes and
    workflows as any other image editing software out there today. So don't be afraid
    to use it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Fireworks以其优越的图像优化引擎而闻名，比起Photoshop，我自己进行了测试，Fireworks的压缩与质量总是表现最好。Fireworks对于今天的网页设计流程和工作流程与任何其他图像编辑软件一样相关。因此，请放心使用它。
- en: After exporting the image from Fireworks at 80 percent quality, the image of
    the Kung Fu grandmasters weighs now only 71 KB. That's about an 87 percent reduction
    in file size from the original 556 KB.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从Fireworks以80％的质量导出图像后，功夫宗师的图像现在只有71 KB。与原始的556 KB相比，文件大小减少了约87％。
- en: Compressing the image
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩图像
- en: Run the image through another image optimization tool, either a standalone application
    such as ImageOptim for Mac or Radical Image Optimization Tool (RIOT) for Windows,
    or through an online service such as [https://tinypng.com/](https://tinypng.com/)
    or [http://www.jpegmini.com/](http://www.jpegmini.com/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过另一个图像优化工具运行图像，可以是一个独立的应用程序，如Mac的ImageOptim或Windows的Radical Image Optimization
    Tool（RIOT），或者通过在线服务，如[https://tinypng.com/](https://tinypng.com/)或[http://www.jpegmini.com/](http://www.jpegmini.com/)。
- en: We're going to use the [https://tinypng.com/](https://tinypng.com/) online image
    compression service. After running the image exported from Fireworks through [https://tinypng.com/](https://tinypng.com/),
    the file size is now about 52 KB, that's about a 91 percent reduction in file
    size from the original 556 KB. This is a massive win for image optimization.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[https://tinypng.com/](https://tinypng.com/)在线图像压缩服务。在通过[https://tinypng.com/](https://tinypng.com/)从Fireworks导出的图像后，文件大小现在约为52
    KB，比原始的556 KB减少了约91%。这对于图像优化来说是一个巨大的胜利。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you didn't run the image through Fireworks first, don't worry. Even though
    your image may be a bit larger, it will still be incredibly optimized and that's
    the objective here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有先通过Fireworks运行图像，不要担心。即使您的图像可能会稍大一些，它仍然会被极大地优化，这是我们的目标。
- en: 'Here''s the before (left) and after (right) comparison between the 556 KB image
    and the final 52 KB image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是556 KB图像和最终52 KB图像之间的前（左）后（右）比较：
- en: '![Compressing the image](img/B02102_06_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![压缩图像](img/B02102_06_04.jpg)'
- en: Third-party image resizing services
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方图像调整服务
- en: We have to acknowledge that if the manual process of optimizing images can be
    quite tedious and time consuming in the scenario where many images need to be
    resized and optimized, doing it manually may not be the best idea.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认，如果手动优化图像的过程在需要调整大小和优化许多图像的情况下可能会非常乏味和耗时，那么手动操作可能不是最佳选择。
- en: There are a few third-party and server-side services out there that automate
    this process for us. We're going to leave the tutorials of how to implement these
    services for another book. However, we're going to list some of the most popular
    services so you can have a reference in case you want to dive deeper.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些第三方和服务器端服务可以自动为我们完成这个过程。我们将把如何实现这些服务的教程留给另一本书。但是，我们将列出一些最受欢迎的服务，以便您在需要深入了解时有一个参考。
- en: 'Here are a few examples of third-party image resizing services:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些第三方图像调整大小服务的示例：
- en: '**Sencha.io Src** from Sencha.com ([http://www.sencha.com/learn/how-to-use-src-sencha-io/](http://www.sencha.com/learn/how-to-use-src-sencha-io/))'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sencha.io Src**来自Sencha.com ([http://www.sencha.com/learn/how-to-use-src-sencha-io/](http://www.sencha.com/learn/how-to-use-src-sencha-io/))'
- en: '**ReSRC** by Dom Fee and Ed Thurgood ([http://www.resrc.it/](http://www.resrc.it/))'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReSRC**由Dom Fee和Ed Thurgood ([http://www.resrc.it/](http://www.resrc.it/))'
- en: '**WURFL** Image Tailor ([http://web.wurfl.io/#wit](http://web.wurfl.io/#wit))'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WURFL** Image Tailor ([http://web.wurfl.io/#wit](http://web.wurfl.io/#wit))'
- en: 'Here are a few examples of server-side (`.htaccess` and/or `.php`) image resizing
    services:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些服务器端（`.htaccess`和/或`.php`）图像调整大小服务的示例：
- en: Adaptive Images by Matt Wilcox ([http://adaptive-images.com/](http://adaptive-images.com/))
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matt Wilcox的自适应图像 ([http://adaptive-images.com/](http://adaptive-images.com/))
- en: RESS.io ([http://ress.io/](http://ress.io/))
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESS.io ([http://ress.io/](http://ress.io/))
- en: The <picture> element and the srcset and sizes attributes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <picture>元素和srcset和sizes属性
- en: Let me start by saying that there is no 100 percent optimal solution to the
    image issues in RWD. This is because of the current lack of support for the recommended
    properties, or because there's a double download of assets. Granted, Dave Newton's
    article in [http://ww1.smashingmagzine.com/](http://ww1.smashingmagzine.com/),
    *How To Avoid Duplicate Downloads In Responsive Images*, tries to address this
    issue ([http://www.smashingmagazine.com/2013/05/10/how-to-avoid-duplicate-downloads-in-responsive-images/](http://www.smashingmagazine.com/2013/05/10/how-to-avoid-duplicate-downloads-in-responsive-images/)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我要说的是，在RWD中没有100%的最佳解决方案。这是因为当前对推荐属性的支持不足，或者因为资产双重下载。尽管戴夫·牛顿在[http://ww1.smashingmagzine.com/](http://ww1.smashingmagzine.com/)的文章中，*如何避免响应式图像中的重复下载*，试图解决这个问题（[http://www.smashingmagazine.com/2013/05/10/how-to-avoid-duplicate-downloads-in-responsive-images/](http://www.smashingmagazine.com/2013/05/10/how-to-avoid-duplicate-downloads-in-responsive-images/)）。
- en: However, that solution is very verbose. If you have to work with many images,
    this solution may not be the best option and allowing a double download starts
    making more sense. Every project is different, so trying to make the most informed
    decisions possible is incredibly important.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种解决方案非常冗长。如果你必须处理许多图像，这种解决方案可能不是最佳选择，允许双重下载开始变得更有意义。每个项目都是不同的，因此尽可能做出最明智的决定非常重要。
- en: As soon as browser vendors decide to fully support any of the solutions mentioned
    here, there won't be a need to worry about double downloads or polyfills of any
    kind.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器供应商决定完全支持这里提到的任何解决方案，就不需要担心双重下载或任何类型的polyfill了。
- en: The `<picture>` element and the `srcset` and `sizes` attributes are maintained
    by the **Responsive Images Community Group** (**RICG**) and are now part of the
    HTML specification. In other words, we can use them without any type of polyfill
    and have the confidence that modern browsers will support them. Well, to some
    degree at least.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>元素和srcset和sizes属性由**响应式图像社区组**（**RICG**）维护，现在已成为HTML规范的一部分。换句话说，我们可以在没有任何类型的polyfill的情况下使用它们，并且可以确信现代浏览器将支持它们。至少在某种程度上是这样。
- en: The only reason we would need to use a polyfill is to support those browsers
    (legacy and modern) that haven't yet implemented support for them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用polyfill的唯一原因是为了支持那些（传统和现代的）尚未实现对它们的支持的浏览器。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Both the `<picture>` element and the `srcset` attribute have a fallback feature
    for those browsers that don't support them. You can opt to use a polyfill, but
    you are not required to do so. If you think using a polyfill enhances the user
    experience, by all means, go for it. Read this article about it from the creator
    of the Picturefill polyfill, Scott Jehl ([http://www.filamentgroup.com/lab/to-picturefill.html](http://www.filamentgroup.com/lab/to-picturefill.html)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`<picture>`元素和`srcset`属性都有一个针对不支持它们的浏览器的回退功能。您可以选择使用polyfill，但不是必须的。如果您认为使用polyfill可以增强用户体验，那就尽管使用。阅读Picturefill
    polyfill的创建者Scott Jehl的这篇文章（[http://www.filamentgroup.com/lab/to-picturefill.html](http://www.filamentgroup.com/lab/to-picturefill.html)）。'
- en: 'There are many polyfills out there, here''s a short list of the ones we can
    use today:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多polyfill，这里是我们今天可以使用的一些简要列表：
- en: 'Picturefill by Scott Jehl (recommended by the RICG: [http://scottjehl.github.io/picturefill/](http://scottjehl.github.io/picturefill/))'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Scott Jehl的Picturefill（由RICG推荐：[http://scottjehl.github.io/picturefill/](http://scottjehl.github.io/picturefill/)）提供支持
- en: PicturePolyfill by Andrea Verlicchi ([http://verlok.github.io/picturePolyfill/](http://verlok.github.io/picturePolyfill/))
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Andrea Verlicchi的PicturePolyfill（[http://verlok.github.io/picturePolyfill/](http://verlok.github.io/picturePolyfill/)）提供支持
- en: respimage by Alexander Farkas ([https://github.com/aFarkas/respimage](https://github.com/aFarkas/respimage))
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Alexander Farkas的respimage（[https://github.com/aFarkas/respimage](https://github.com/aFarkas/respimage)）提供支持
- en: Some people in the web design and web development communities feel strongly
    about considering that a new HTML element (`<picture>`) isn't the solution to
    the issues we are experiencing with images in RWD. They feel that the solution
    should come from within an already existing tag, the `<img>` tag.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web设计和Web开发社区中，一些人强烈认为，考虑到新的HTML元素（`<picture>`）并不是解决我们在RWD中遇到的图像问题的解决方案。他们认为解决方案应该来自已经存在的`<img>`标签。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `sizes` attribute can also be used with the `<picture>` element, but we're
    going to focus on using the `sizes` attribute with the `<img>` tag.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizes`属性也可以与`<picture>`元素一起使用，但我们将专注于在`<img>`标签中使用`sizes`属性。'
- en: Good for us, that the solutions come in both flavors. It doesn't matter which
    method you use to serve your images in a responsible way, what matters is that
    you should be using one of these methods. If you already are, that's awesome.
    If not, don't sweat it. The following explanations will help clear up any questions
    you have about this matter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说很好，解决方案有两种。使用哪种方法来负责负责您的图像并不重要，重要的是您应该使用其中一种方法。如果您已经在使用，那太棒了。如果没有，不要担心。以下的解释将帮助您解决任何关于这个问题的疑问。
- en: When to use <picture> and when to use srcset
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用<picture>，何时使用srcset
- en: When to use `<picture>` and when to use `srcset`? This is a very legit question
    that I myself couldn't wrap my head around when first heard these terms. So I
    decided to ask Brad Frost at a workshop he conducted in Dayton, OH.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用`<picture>`，何时使用`srcset`？这是一个非常合理的问题，我自己在第一次听到这些术语时也无法理解。所以我决定在俄亥俄州戴顿市的一次布拉德·弗罗斯特（Brad
    Frost）的研讨会上向他请教。
- en: 'The recommended approach boils down to this concept: art direction. In responsive
    images, art direction basically means that you have different images that are
    cropped a certain way so that less important parts of the image are left out in
    order to focus on the important ones.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的方法归结为这个概念：艺术指导。在响应式图像中，艺术指导基本上意味着您有不同的图像，以某种方式裁剪，以便图像的不太重要的部分被剔除，从而专注于重要的部分。
- en: This is different from just resizing the same image. Granted, you can use whatever
    method you want, but to keep things simple, you can use the `<picture>` element
    when you want to serve art directed images and the `srcset` attribute when you
    just want to serve resized versions of the same image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这与只调整相同的图像不同。当然，您可以使用任何您想要的方法，但为了保持简单，当您想要提供艺术指导图像时，可以使用`<picture>`元素，当您只想提供相同图像的调整版本时，可以使用`srcset`属性。
- en: 'Before we dive into the markup, let''s see a visual example of an art directed
    image versus a resized image using the photo of the Kung Fu grandmasters:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入标记之前，让我们看一个关于艺术指导图像与使用功夫宗师照片的调整图像的视觉示例：
- en: '![When to use <picture> and when to use srcset](img/B02102_06_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![何时使用<picture>，何时使用srcset](img/B02102_06_05.jpg)'
- en: 'Let''s see what happened here. The original image has a lot of space around
    the Kung Fu grandmasters: we can see the trees and the buildings in the back.
    The resized versions maintain all aspects and proportions 1:1 of the original
    image.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。原始图像周围有很多空间，我们可以看到后面的树和建筑物。调整大小的版本保持了原始图像的所有方面和比例1:1。
- en: However, the art directed images have a lot of differences. The first art directed
    image is cropped to show both grandmasters in a close up; the second art directed
    image has been cropped even more to accentuate the focus on Shi DeRu only (the
    grandmaster on the left). We could've cropped the image to focus on Shi DeYang
    (the grandmaster on the right), but this was the "art direction" I wanted to give
    the image. This is a subjective decision but based on a solid intent.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，艺术指导图像有很多不同之处。第一个艺术指导图像被裁剪以显示两位宗师的特写；第二个艺术指导图像被裁剪得更多，以突出对Shi DeRu（左侧的宗师）的关注。我们本可以裁剪图像以便关注Shi
    DeYang（右侧的宗师），但这是我想要给图像的“艺术指导”。这是一个主观的决定，但基于坚定的意图。
- en: Now, let's see the *Picturefill polyfill/script* in action.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看*Picturefill polyfill/script*的实际效果。
- en: Implementing the Picturefill polyfill
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施Picturefill polyfill
- en: The first thing we need to do is download the JavaScript file, which can be
    downloaded from [https://github.com/scottjehl/picturefill/blob/2.3.0/dist/picturefill.min.js](https://github.com/scottjehl/picturefill/blob/2.3.0/dist/picturefill.min.js)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是下载JavaScript文件，可以从[https://github.com/scottjehl/picturefill/blob/2.3.0/dist/picturefill.min.js](https://github.com/scottjehl/picturefill/blob/2.3.0/dist/picturefill.min.js)下载。
- en: 'Then, all we need to do is include it in the `<head>` section of our document:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要做的就是将它包含在文档的`<head>`部分中：
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the <picture> element
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用<picture>元素
- en: When using the `<picture>` element, you (the author) tell the browser which
    image to use at which breakpoint. The good thing about this is that we can define
    exactly when a certain image should be displayed by using media queries. The media
    queries work exactly the same as the media queries used in CSS, and they even
    look exactly the same.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<picture>`元素时，您（作者）告诉浏览器在哪个断点使用哪个图像。这样做的好处是，我们可以通过使用媒体查询来精确定义何时显示某个图像。媒体查询的工作方式与CSS中使用的媒体查询完全相同，甚至看起来完全相同。
- en: 'This is what a basic `<picture>` snippet looks like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的`<picture>`片段的样子：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, even with a polyfill, IE9 has issues with the `<picture>` element. As weird
    as it sounds, we need to inject a `<video>` tag within conditional comments for
    IE9 to work correctly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用了polyfill，IE9对`<picture>`元素也存在问题。尽管听起来很奇怪，但我们需要在IE9中插入一个`<video>`标签以正确工作。
- en: 'This is what the markup looks like after amending it for IE9:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为IE9修改后的标记样式：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, I also highlighted the `<img src="img/grandmasters-default.jpg"
    alt="Fallback image">` tag. This is the fallback image for those browsers that
    do not support the `<picture>` element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我还突出显示了`<img src="img/grandmasters-default.jpg" alt="Fallback image">`标签。这是那些不支持`<picture>`元素的浏览器的回退图像。
- en: One thing to keep in mind is that not so long ago, this fallback image caused
    double download in some modern browsers. My last tests showed that this was not
    the case in Chrome and Firefox, which do support the `<picture>` element. So make
    sure you run all necessary tests to see where you stand and then think of a solution
    if you need to support those legacy browsers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住的一件事是，不久之前，这个回退图像在一些现代浏览器中导致了双重下载。我的最后测试显示，在Chrome和Firefox中并非如此，它们支持`<picture>`元素。因此，请确保您运行所有必要的测试，以查看您的情况，然后考虑解决方案，如果您需要支持那些旧版浏览器。
- en: 'Here''s a demo I created for this in CodePen: [http://codepen.io/ricardozea/pen/cf6c0965785d552bad5e200acb761ffe](http://codepen.io/ricardozea/pen/cf6c0965785d552bad5e200acb761ffe)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上创建的演示：[http://codepen.io/ricardozea/pen/cf6c0965785d552bad5e200acb761ffe](http://codepen.io/ricardozea/pen/cf6c0965785d552bad5e200acb761ffe)
- en: Using the srcset and sizes attributes
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`srcset`和`sizes`属性
- en: The `srcset` and `sizes` attributes actually come from the `<picture>` specification,
    but are implemented in the `<img>` element. When using the `srcset` and `sizes`
    attributes, the browser does all the work of deciding which image to use for each
    specific circumstance. You can also use media queries if you want, although, not
    required. The word `vw` means *viewport width* and it's used to let the browser
    know that it should display an image at a certain percentage in relation to the
    width of the viewport. If you see something like `80vw`, it means that the image
    should be 80 percent of the width of the current viewport.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`srcset`和`sizes`属性实际上来自`<picture>`规范，但在`<img>`元素中实现。使用`srcset`和`sizes`属性时，浏览器会决定在每种特定情况下使用哪个图像。如果需要，您还可以使用媒体查询，尽管不是必需的。单词`vw`表示*视口宽度*，用于让浏览器知道它应该根据视口宽度的百分比显示图像。如果看到类似`80vw`的东西，这意味着图像应该是当前视口宽度的80%。'
- en: The `w` descriptor means *the width of the image*. If you see something like
    `255w`, it means the browser will understand that specific image is 255px wide.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`w`描述符表示*图像的宽度*。如果看到类似`255w`的东西，浏览器将了解特定图像的宽度为255px。'
- en: 'Let''s take a look at an `<img>` tag with the `srcset` and `sizes` attributes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看带有`srcset`和`sizes`属性的`<img>`标签：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The letters `rsz` are an abbreviation of the word *resize*. That's because for
    images that are just going to be resized in RWD, the `srcset` attribute keeps
    things a bit simpler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsz`这几个字母是*resize*一词的缩写。这是因为对于在RWD中只会被调整大小的图像，`srcset`属性使事情变得简单一些。'
- en: The following markup is truncated in order to focus on the specific explanations
    easily.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记被截断，以便更容易专注于特定的解释。
- en: 'The first thing we see is the already known `src` attribute which acts as the
    fallback image:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到的是已知的`src`属性，它充当回退图像：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Keep in mind that the image `grandmasters-default.jpg` *will not* be used by
    browsers that do understand `srcset`. In other words, the *default* image in browsers
    that support `srcset` is going to be first image in the list. In our case, it
    is `grandmasters-small-rsz.jpg`. Then, we see the `srcset` attribute.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，浏览器不理解`srcset`的话，将不会使用图像`grandmasters-default.jpg`。换句话说，在支持`srcset`的浏览器中，*默认*图像将是列表中的第一个图像。在我们的情况下，它是`grandmasters-small-rsz.jpg`。然后，我们看到`srcset`属性。
- en: 'This is where the magic starts happening:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是魔术开始发生的地方：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, our plan is to show two different image files in browsers
    that support `srcset`. This is accomplished by listing the images separated by
    commas. Also, the value defined after each image is the width of the image:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的计划是在支持`srcset`的浏览器中显示两个不同的图像文件。这是通过用逗号分隔的图像列表来实现的。此外，每个图像后面定义的值是图像的宽度：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'We can use height as well:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用高度：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, the most common use case is that dealing with the width and allowing
    the height to adjust proportionally gives authors a bit more control over the
    image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最常见的用例是处理宽度并允许高度按比例调整，这样作者对图像有更多的控制。
- en: 'Giving the size of the image to the browser will allow it to make a more informed
    decision about what image to use based on the media query in the `sizes` snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 向浏览器提供图像的大小将使其能够根据`sizes`片段中的媒体查询更明智地决定使用哪个图像：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Remember, `30em` is the same as 480px. With the media query `min-width: 30em`,
    the browser goes through the following process:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '记住，`30em`等同于480px。使用媒体查询`min-width: 30em`，浏览器经历以下过程：'
- en: If my viewport is 30em (480px) or less, I should show the image that's 255px
    wide. There's no need to show the image that's 511px in a viewport that's only
    480px. That's a waste of bandwidth!
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我的视口是30em（480px）或更小，则应显示宽度为255px的图像。在只有480px的视口中，没有必要显示宽度为511px的图像。这是浪费带宽！
- en: But if my viewport is *more* than 30em (480px), then I should show the image
    that's 511px wide.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，如果我的视口*大于*30em（480px），那么我应该显示宽度为511px的图像。
- en: 'The last part of the `sizes` attribute is the viewport widths: `80vw, 100vw`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizes`属性的最后部分是视口宽度：`80vw, 100vw`。'
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This means that if the viewport is 30em (480px) or less, the browser will show
    the image at 80 percent width. If it's more than 30em (480px), it will show the
    image at 100 percent width.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果视口是30em（480px）或更小，浏览器将以80%的宽度显示图像。如果超过30em（480px），它将以100%的宽度显示图像。
- en: 'Finally, we have the `alt` attribute:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`alt`属性：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding an `alt` attribute is always a good accessibility practice for users
    with assistive technology. Also, in case the images aren't loaded, browsers can
    display this text instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为图像添加`alt`属性对于使用辅助技术的用户来说总是一个良好的可访问性实践。此外，如果图像没有加载，浏览器可以显示这个文本。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The order of the attributes doesn't matter. In other words, you can have `srcset`
    first, then `alt`, then `sizes`, and then the `src` attribute (or vice versa).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的顺序并不重要。换句话说，你可以先使用`srcset`，然后是`alt`，然后是`sizes`，然后是`src`属性（或者反之亦然）。
- en: Targeting high-density screens with srcset
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用srcset定位高密度屏幕
- en: High-density screens will always be something in the RWD world that we'll never
    get away from. So if you can't defeat them, join them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 高密度屏幕将永远是RWD世界中我们无法摆脱的东西。所以如果你无法打败它们，就加入它们。
- en: 'Here''s a snippet that addresses normal and high-density screens:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个解决普通和高密度屏幕的片段：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, this is a much shorter and concise markup. It''s really self-explanatory:
    use a fallback image in case there''s no `srcset` support. If there is support,
    then use the `1x` image if the device has a normal density display. You will have
    to use the `2x` image if the device has a high-density display up to two times
    the density. If we are supporting even higher than 2x density devices, a 3x suffix
    should be added.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个更短更简洁的标记。它真的很简单明了：在没有`srcset`支持的情况下使用备用图像。如果有支持，那么如果设备具有普通密度显示，则使用`1x`图像。如果设备具有高密度显示，那么必须使用`2x`图像。如果我们支持的设备密度甚至更高，就应该添加一个3x后缀。
- en: The `sizes` attribute is not required. If your design or conditions merit the
    use of the `sizes` attribute, you're free to use it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizes`属性是不是必需的。如果你的设计或条件需要使用`sizes`属性，你可以自由使用它。'
- en: 'Here''s a demo I created for this in CodePen: [http://codepen.io/ricardozea/pen/a13993f05a4cdc5f714a311a94f48a69](http://codepen.io/ricardozea/pen/a13993f05a4cdc5f714a311a94f48a69)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上为此创建的演示：[http://codepen.io/ricardozea/pen/a13993f05a4cdc5f714a311a94f48a69](http://codepen.io/ricardozea/pen/a13993f05a4cdc5f714a311a94f48a69)
- en: <picture> versus srcset
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<picture>`与`srcset`'
- en: 'Some web designers and developers say that using media queries inside HTML
    like we saw with `<picture>` and `srcset` goes against the principle of separation
    of concerns: styling and markup should always remain as separated, independent
    assets.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网页设计师和开发人员表示，在HTML中使用媒体查询，就像我们在`<picture>`和`srcset`中看到的那样，违反了关注点分离的原则：样式和标记应始终保持分离，独立的资源。
- en: Others, as I mentioned before, think that a new HTML element is unnecessary
    and that any solutions should be based on enhancing and extending already existing
    elements like the `<img>` tag.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，其他人认为新的HTML元素是不必要的，任何解决方案都应该基于增强和扩展已经存在的元素，比如`<img>`标签。
- en: All I can say is that at the end, none of that matters. What matters is that
    as web designers and developers, we should be using anything we have at our disposal
    to make users happy and create memorable experiences, while adhering to the best
    practices for long lasting implementations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我只能说，在最后，这一切都无关紧要。重要的是，作为网页设计师和开发人员，我们应该利用我们手头的一切资源来让用户满意，创造令人难忘的体验，同时遵循持久实施的最佳实践。
- en: Replacing 1x images with 2x images on the fly with Retina.js
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Retina.js在运行时将1x图像替换为2x图像
- en: The `Retina.js` script is one of those scripts that makes things so much easier
    that sometimes you wonder why responsive images are so difficult.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Retina.js`脚本是那些使事情变得更简单的脚本之一，有时你会想为什么响应式图像如此困难。'
- en: If you don't feel ready to deal with the `<picture>` and/or `srcset` and `sizes`
    attributes, I don't blame you. It's scary but I recommend that you keep trying
    to understand these tools since that's the state of the art of responsive images.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有准备好处理`<picture>`和/或`srcset`和`sizes`属性，我不怪你。这很可怕，但我建议你继续努力理解这些工具，因为这是响应式图像的最新技术。
- en: The `Retina.js` script was developed by the folks at Imulus ([http://imulus.com/](http://imulus.com/)).
    The `Retina.js` script isn't a JavaScript-only solution; they also have a Sass
    mixin that produces the same results without the dependency on JavaScript.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Retina.js`脚本是由Imulus的人员开发的（[http://imulus.com/](http://imulus.com/)）。`Retina.js`脚本不仅仅是JavaScript解决方案；他们还有一个Sass
    mixin，可以在不依赖JavaScript的情况下产生相同的结果。'
- en: Let's take a look at the JavaScript solution first.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下JavaScript解决方案。
- en: Retina.js – a JavaScript solution
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Retina.js - 一个JavaScript解决方案
- en: Using the script couldn't be any simpler. We need to download the script from
    [https://github.com/imulus/retinajs/blob/master/dist/retina.min.js](https://github.com/imulus/retinajs/blob/master/dist/retina.min.js)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个脚本非常简单。我们需要从[https://github.com/imulus/retinajs/blob/master/dist/retina.min.js](https://github.com/imulus/retinajs/blob/master/dist/retina.min.js)下载脚本。
- en: 'Then, we place the script at the bottom of the HTML, right before the closing
    `<body>` tag:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将脚本放在HTML的底部，就在闭合的`<body>`标签之前：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `Retina.js` script is not framework dependent. In other words, it doesn't
    need jQuery or Mootools or Dojo or any framework to… well, work.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Retina.js`脚本不依赖于框架。换句话说，它不需要jQuery或Mootools或Dojo或任何框架来……嗯，工作。'
- en: 'Then, we add an image to our markup:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在我们的标记中添加一个图像：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's it! We don't have to do anything to the markup, unless we want to exclude
    an image from being replaced. I explain how to do this coming up next.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们不必对标记做任何事情，除非我们想要排除被替换的图像。我将在接下来的内容中解释如何做到这一点。
- en: The basic function of the JavaScript solution of `Retina.js` is that it looks
    for images in the page and replaces them with high-resolution versions if they
    exist on the server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Retina.js`的JavaScript解决方案的基本功能是查找页面中的图像，并在服务器上存在高分辨率版本时用高分辨率版本替换它们。'
- en: You need to name your high-resolution images with the `@2x` modifier right at
    the end of the name.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在高分辨率图像的名称末尾加上`@2x`修饰符。
- en: 'In other words, if you have the following image:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果您有以下图像：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Retina.js replaces it with the following one:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Retina.js用以下内容替换它：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As long as the `@2x` image exists on the server, `Retina.js` replaces it. If
    the image doesn't exist, then it won't replace it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 只要服务器上存在`@2x`图像，`Retina.js`就会替换它。如果图像不存在，它就不会替换。
- en: Excluding images
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不包括图片
- en: 'If you have excluded or want to exclude, images from being replaced by `Retina.js`,
    you can add the `data-no-retina` attribute to your images:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经排除或希望排除图像被`Retina.js`替换，您可以为图像添加`data-no-retina`属性：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Retina.js – a Sass mixin solution
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Retina.js——Sass mixin解决方案
- en: Well, this is weird—a JavaScript solution that somehow also happens to have
    a CSS solution? Sweet! Note that this Sass mixin is for applying background high-resolution
    images.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很奇怪——一个JavaScript解决方案，竟然也有CSS解决方案？太棒了！请注意，这个Sass mixin是用于应用背景高分辨率图片的。
- en: 'The Sass mixin looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Sass mixin如下所示：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The usage is quite simple:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法非常简单：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to declare the **file extension**, the **width**, and the **height**
    as comma-separated values. The preceding Sass snippet will compile to this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要声明**文件扩展名**、**宽度**和**高度**，用逗号分隔的值。前面的Sass代码片段将编译为这样：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s a demo I created for this in CodePen: [http://codepen.io/ricardozea/pen/c3af015b325da6ee56cf59e660f3cc03](http://codepen.io/ricardozea/pen/c3af015b325da6ee56cf59e660f3cc03)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上创建的演示：[http://codepen.io/ricardozea/pen/c3af015b325da6ee56cf59e660f3cc03](http://codepen.io/ricardozea/pen/c3af015b325da6ee56cf59e660f3cc03)
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'With `background-size: 100% auto;`, the background image will stretch to the
    maximum width of its parent container. However, if the container is wider, the
    image will be repeated.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`background-size: 100% auto;`，背景图像将拉伸到其父容器的最大宽度。但是，如果容器更宽，图像将被重复。'
- en: Making videos responsive
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使视频响应式
- en: The videos we're going to talk about are the videos that come inside our good
    old friend, the `<iframe>` element, such as videos from YouTube, Vimeo, Dailymotion,
    and so on. There are several ways to make videos responsive, some more involving
    than others. Let's break it down.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要讨论的视频是嵌入在我们的好朋友`<iframe>`元素中的视频，比如来自YouTube、Vimeo、Dailymotion等的视频。有几种方法可以使视频响应式，有些方法比其他方法更复杂。让我们来分解一下。
- en: Responsive videos with HTML and CSS
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTML和CSS创建响应式视频
- en: YouTube is an amazing video service that makes life easier for everyone—video
    authors, as well as web designers and developers. The fact that YouTube takes
    care of the hosting of the video, the streaming, and the technological conditions
    of browsers that don't support Flash (iOS), or browsers that don't support the
    `<video>` tag (legacy browsers), is just awesome.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: YouTube是一个令人惊叹的视频服务，使视频作者、网页设计师和开发人员的生活更加轻松。YouTube负责视频的托管、流媒体和技术条件，这些条件包括不支持Flash（iOS）或不支持`<video>`标签（旧版浏览器）的浏览器，这真是太棒了。
- en: 'The first thing we need to do is create a container that will hold the video.
    This container is the one we''re going to manipulate to give the video the width
    we want while maintaining its aspect ratio:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个容器来容纳视频。这个容器是我们将要操作的，以便在保持其宽高比的同时给视频所需的宽度：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we create a container for the video we''re going to embed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个用于嵌入视频的容器：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we embed the video, which is inside the `<iframe>` element:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们嵌入视频，视频位于`<iframe>`元素中：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ok, that's it for our markup. Now, let's tackle the CSS from inside out.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就是我们的标记。现在，让我们从内到外处理CSS。
- en: 'Let''s give the `<iframe>` element a few properties:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给`<iframe>`元素添加一些属性：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, let''s give the `.embed-container` wrapper some context:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们给`.embed-container`包装器添加一些上下文：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now the `<iframe>` element will be positioned correctly and take up all the
    space of its parent container. The parent container will make sure the video is
    visible and anything sticking out of it will be hidden.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`<iframe>`元素将被正确定位并占据其父容器的所有空间。父容器将确保视频可见，任何超出父容器的部分将被隐藏。
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'For videos with 16:9 aspect ratio, use `padding-bottom: 56.25%;`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '对于16:9宽高比的视频，请使用`padding-bottom: 56.25%;`。'
- en: 'For videos with 4:3 aspect ratio, use `padding-bottom: 75%;`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '对于4:3宽高比的视频，请使用`padding-bottom: 75%;`。'
- en: 'All we need to do now is define the width of the whole thing. We do that by
    adding a width to the outer container, the **.video-container** wrapper:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是定义整个东西的宽度。我们通过为外部容器**.video-container**添加宽度来实现这一点：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Responsive videos with jQuery
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery创建响应式视频
- en: If you're a jQuery fan, this plugin is for you. It may also come in handy when
    you have to retrofit already published videos on your site, or if there are too
    many of them to update manually.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是jQuery的粉丝，这个插件适合您。当您需要在网站上已经发布的视频上进行改装，或者需要手动更新太多视频时，它也可能会派上用场。
- en: 'The plugin is called FitVids.js. It was developed by Chris Coyer and the guys
    at Paravel. Using FitVids.js is pretty straightforward. First, we need to download
    the FitVids JavaScript file from the following URL: [https://github.com/davatron5000/FitVids.js/blob/master/jquery.fitvids.js](https://github.com/davatron5000/FitVids.js/blob/master/jquery.fitvids.js)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件叫做FitVids.js。它是由Chris Coyer和Paravel的人开发的。使用FitVids.js非常简单。首先，我们需要从以下URL下载FitVids
    JavaScript文件：[https://github.com/davatron5000/FitVids.js/blob/master/jquery.fitvids.js](https://github.com/davatron5000/FitVids.js/blob/master/jquery.fitvids.js)
- en: Then, we call jQuery and the FitVids.js files in the `<head>` of our document.
    Finally, we add a script at the bottom of our markup to call the `fitVids` function.
    That's pretty much all there is to it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在文档的`<head>`中调用jQuery和FitVids.js文件。最后，在我们的标记底部添加一个脚本来调用`fitVids`函数。基本上就是这样。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The actual file name of `FitVids.js` is `jquery.fitvids.js`. This is the file
    name we're going to see in the example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`FitVids.js`的实际文件名是`jquery.fitvids.js`。这是我们将在示例中看到的文件名。'
- en: 'Here''s an HTML snippet with two videos within `<iframe>`, one from YouTube
    and another one from Vimeo:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含两个视频的HTML片段，分别来自YouTube和Vimeo的`<iframe>`：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you''re curious about how `FitVids.js` modifies the DOM to make the videos
    responsive, here''s the markup:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对`FitVids.js`如何修改DOM以使视频响应式感兴趣，这是标记：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Document Object Model** (**DOM**): When you read, or hear, someone say *modify
    the DOM*, it basically means *modify the generated HTML*.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）：当你读到或听到有人说*修改DOM*时，基本上意味着*修改生成的HTML*。'
- en: 'Here''s a demo I created for this in CodePen: [http://codepen.io/ricardozea/pen/9e994c213c0eeb64ccd627e132778a42](http://codepen.io/ricardozea/pen/9e994c213c0eeb64ccd627e132778a42).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上为此创建的演示：[http://codepen.io/ricardozea/pen/9e994c213c0eeb64ccd627e132778a42](http://codepen.io/ricardozea/pen/9e994c213c0eeb64ccd627e132778a42)。
- en: Responsive videos with plain JavaScript
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纯JavaScript响应式视频
- en: 'If you are not using jQuery or don''t want any framework dependencies, but
    still need a simple JavaScript solution, the best option is to use a script developed
    by Todd Motto: `Fluidvids.js`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用jQuery或不想要任何框架依赖，但仍需要一个简单的JavaScript解决方案，最好的选择是使用Todd Motto开发的脚本：`Fluidvids.js`。
- en: 'Using it is very simple as well. First, we need to download the Fluidvids JavaScript
    file: [https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.min.js](https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.min.js)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它也很简单。首先，我们需要下载Fluidvids JavaScript文件：[https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.min.js](https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.min.js)
- en: Then, we need to call the `fluidvis.js` file in the `<head>` element of our
    document. Once we have that in place, we add a small script snippet at the bottom
    of our markup. That's it. The script will read through the markup, modify the
    DOM, and make any videos it finds *responsive*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在文档的`<head>`元素中调用`fluidvis.js`文件。一旦我们完成这一步，我们在标记底部添加一个小的脚本片段。就是这样。脚本将阅读标记，修改DOM，并使它找到的任何视频*响应式*。
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure to always give a `width` and `height` value to the `<iframe>` element.
    Otherwise you'll see a blank space on the page.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 确保始终为`<iframe>`元素提供`width`和`height`值。否则，页面上会出现空白空间。
- en: 'Here''s the HTML snippet you''ll need for this to work:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要使其工作的HTML片段：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here''s the modified DOM:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的DOM：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s a demo I created for this in CodePen: [http://codepen.io/ricardozea/pen/fda7c2c459392c934130f28cc092dbbe](http://codepen.io/ricardozea/pen/fda7c2c459392c934130f28cc092dbbe)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上为此创建的演示：[http://codepen.io/ricardozea/pen/fda7c2c459392c934130f28cc092dbbe](http://codepen.io/ricardozea/pen/fda7c2c459392c934130f28cc092dbbe)
- en: Third-party services to embed video
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方服务来嵌入视频
- en: What can I say? All you need to do is point your browser to [http://embedresponsively.com/](http://embedresponsively.com/)
    and select the tab of the video service you want to use. Let's choose Vimeo. Input
    the URL of the video you want to make responsive, press the **Embed** button,
    and voilà—the HTML and CSS that you need to use appears right below the example
    video.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我能说什么呢？你只需要将浏览器指向[http://embedresponsively.com/](http://embedresponsively.com/)，并选择你想要使用的视频服务的选项卡。让我们选择Vimeo。输入你想要使其响应式的视频的URL，点击**嵌入**按钮，然后，你需要使用的HTML和CSS就会出现在示例视频的正下方。
- en: 'Here are the HTML and CSS snippets produced by [embedresponsively.com](http://embedresponsively.com)
    for a video with the well-known Dan Mall about RWD (it has been formatted for
    easier reading):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由[embedresponsively.com](http://embedresponsively.com)生成的用于关于RWD的Dan Mall视频的HTML和CSS片段（已经格式化以便阅读）：
- en: 'The HTML is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: HTML如下：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The CSS is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: CSS如下：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, with the following snippets, the container of the video looks much
    higher than it should be. In order to make the preceding snippets work properly,
    we need to wrap the embed-container inside an outer container. Here are the amended
    markup and CSS.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用以下片段，视频的容器看起来比应该高得多。为了使前面的片段正常工作，我们需要将嵌入容器包装在外部容器内。这是修改后的标记和CSS。
- en: 'The HTML is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: HTML如下：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The CSS is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: CSS如下：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `.video-container` wrapper is what we manipulate in order to define any
    width we want while maintaining the aspect ratio of the video. Now, all we need
    to do is place the markup in our HTML document and the CSS snippet in our SCSS
    file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`.video-container`包装器是我们操纵的，以便定义任何我们想要的宽度，同时保持视频的纵横比。现在，我们只需要将标记放在我们的HTML文档中，将CSS片段放在我们的SCSS文件中。'
- en: 'Here''s a demo I created for this in CodePen: [http://codepen.io/ricardozea/pen/10262216eeb01fc9d3b3bedb9f27c908](http://codepen.io/ricardozea/pen/10262216eeb01fc9d3b3bedb9f27c908)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上为此创建的演示：[http://codepen.io/ricardozea/pen/10262216eeb01fc9d3b3bedb9f27c908](http://codepen.io/ricardozea/pen/10262216eeb01fc9d3b3bedb9f27c908)
- en: The Vector Formats
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矢量格式
- en: We're going to see some HTML and CSS/SCSS snippets to get an idea of how to
    work with icon fonts and **SVG**s, but we're not going to go through the creation
    of such assets since that process is out of the scope of this section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一些HTML和CSS/SCSS片段，以了解如何使用图标字体和**SVG**，但我们不会详细介绍这些资产的创建过程，因为这个过程超出了本节的范围。
- en: Vectors or bitmaps/raster images
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矢量或位图/光栅图像
- en: 'When people ask what the difference between vectors and bitmaps/raster images
    is, the answers I often hear are usually around the idea, "If you enlarge it,
    it won''t lose its quality. No worries for mobile devices." Although true, it
    doesn''t fully answer the question. So here are the differences:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们询问矢量和位图/光栅图像之间的区别时，我经常听到的答案通常围绕着“如果你放大它，它不会失去质量。对移动设备也不用担心。”虽然这是真的，但它并没有完全回答这个问题。所以这里是区别：
- en: A **vector image** is a file made out of mathematical equations. The results
    of these equations are represented by a graphic (lines, shapes, colors). If the
    size of the image changes in any way, the values of those equations are recalculated
    and the resulting graphic is painted again.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**矢量图像**是由数学方程组成的文件。这些方程的结果由图形（线条、形状、颜色）表示。如果图像的大小以任何方式改变，这些方程的值将被重新计算，生成的图形将被重新绘制。'
- en: A **bitmap or raster image** is a file made out of pixels. These pixels have
    a specific/defined width, height, and color. If an image is enlarged, the pixels
    are stretched and that's why the image looks blurry or pixelated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**位图或光栅图像**是由像素组成的文件。这些像素具有特定/定义的宽度、高度和颜色。如果图像被放大，像素就会被拉伸，这就是为什么图像看起来模糊或呈像素化的原因。'
- en: 'With those definitions out of the way, let''s talk about some of the vector
    formats used for RWD. Vector formats include:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义，让我们来谈谈用于RWD的一些矢量格式。矢量格式包括：
- en: Web fonts
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web字体
- en: Icon fonts
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标字体
- en: SVGs
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG
- en: Let's see how to rapidly implement icon fonts and SVGs; web fonts will be addressed
    in the next chapter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何快速实现图标字体和SVG；Web字体将在下一章中讨论。
- en: Icon fonts
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图标字体
- en: Icon fonts are basically a font file but instead of having letters as glyphs
    it has, well, icons. Some people love icon fonts (I do), and some aren't really
    too fond of them, especially since SVG has gained so much popularity.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图标字体基本上是一个字体文件，但它不是字母，而是图标。有些人喜欢图标字体（我喜欢），有些人对它们并不太喜欢，特别是因为SVG变得如此受欢迎。
- en: Let's see the pros and cons of icon fonts.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看图标字体的优缺点。
- en: 'Some advantages are:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一些优点是：
- en: Icon fonts are very likely smaller in file size than their SVGs counterparts.
    We can have many more icons in a single font file and it weighs a lot less than
    having an SVG sprite.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标字体的文件大小很可能比它们的SVG对应文件要小。我们可以在单个字体文件中有更多的图标，而且它的重量要比有一个SVG精灵要轻得多。
- en: The properties of icon fonts can be modified with any properties used to modify
    text, for example, color, font-family, font-weight, and so on. After all, it's
    a font. This means that we don't have to learn any new syntaxes or properties.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标字体的属性可以用于修改文本的任何属性，例如颜色、字体系列、字重等。毕竟，它是一个字体。这意味着我们不必学习任何新的语法或属性。
- en: They are relatively easy to implement. Once all the `@font-face` properties
    are set once, calling an icon font is a matter of adding a class to the HTML and
    calling a specific code called the Unicode Point in the CSS.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们相对容易实现。一旦所有的`@font-face`属性被设置，调用一个图标字体只是在HTML中添加一个类，并在CSS中调用一个特定的Unicode点代码。
- en: Icon fonts are vectors so they retain their optimum quality on any screen density,
    screen size, and zoom level.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标字体是矢量图形，因此它们在任何屏幕密度、屏幕尺寸和缩放级别上都保持最佳质量。
- en: They're very design-versatile. A single icon font can be wrapped in a colored
    container, have the icon reserved (knockout), and still be the same icon—no need
    for a separate file.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常适合设计。一个单独的图标字体可以被包裹在一个有颜色的容器中，图标可以被保留（挖空），但仍然是相同的图标，不需要单独的文件。
- en: 'Some disadvantages are:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一些缺点是：
- en: Updating a custom-designed icon can take some work, since we'd have to work
    with a third-party app to generate our icon font files.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新自定义设计的图标可能需要一些工作，因为我们需要使用第三方应用程序来生成我们的图标字体文件。
- en: Icon fonts can only use a single color. I honestly don't think this is a disadvantage.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标字体只能使用单一颜色。我真的不认为这是一个缺点。
- en: One of the main disadvantages of icon fonts is that implementing a fallback
    in case the font file doesn't load is a bit complex and if you ask me, verbose.
    The name of the pattern is "A Font Garde". If you want to read about it, check
    out Zach Leatherman's post *Bulletproof Accessible Icon Fonts* ([http://www.filamentgroup.com/lab/bulletproof_icon_fonts.html](http://www.filamentgroup.com/lab/bulletproof_icon_fonts.html)).
    The GitHub repo can be found at [https://github.com/filamentgroup/a-font-garde](https://github.com/filamentgroup/a-font-garde).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标字体的主要缺点之一是，实现一个备用方案以防字体文件加载失败有点复杂，而且如果你问我，有点啰嗦。这种模式的名称是“字体卫士”。如果你想了解更多，请查看Zach
    Leatherman的文章*Bulletproof Accessible Icon Fonts*（[http://www.filamentgroup.com/lab/bulletproof_icon_fonts.html](http://www.filamentgroup.com/lab/bulletproof_icon_fonts.html)）。GitHub仓库可以在[https://github.com/filamentgroup/a-font-garde](https://github.com/filamentgroup/a-font-garde)找到。
- en: 'Here are a few recommendations I can give you when using icon fonts:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用图标字体时，我可以给你一些建议：
- en: If possible, avoid using them for critical content.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，避免在关键内容中使用它们。
- en: Always provide a `title=""` attribute in the element you're using the icon font
    on. If the font file fails to load, at least the text in the title tag can be
    seen.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用图标字体的元素中始终提供一个`title=""`属性。如果字体文件加载失败，至少可以看到标题标签中的文本。
- en: If you're ok with it, use an extra HTML element to hold the icon. If the icon
    font file fails to load, users with and without assistive technologies can still
    use the feature the icon font represents.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你愿意，可以使用额外的HTML元素来容纳图标。如果图标字体文件加载失败，无论用户是否使用辅助技术，都可以使用图标字体代表的功能。
- en: In my years of experience, I have yet to see icon font files failed to load,
    but that doesn't mean it can't happen. So I recommend staying on top of your server
    logs to determine if the icon font file is or isn't being downloaded. If it's
    not, then you need to remedy the issue as soon as possible.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我的多年经验中，我从未见过图标字体文件加载失败，但这并不意味着它不可能发生。因此，我建议及时查看服务器日志，以确定图标字体文件是否被下载。如果没有，那么您需要尽快解决这个问题。
- en: Let's implement an icon font then.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们来实现一个图标字体。
- en: Implementing icon fonts
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现图标字体
- en: The fastest way to get icon font files is by using a third party web app like
    IcoMoon.io or Fontello.com. You can also get a copy of Font Awesome.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 获取图标字体文件的最快方法是使用像IcoMoon.io或Fontello.com这样的第三方网络应用程序。您也可以获得Font Awesome的副本。
- en: Tip
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful when considering using Font Awesome. Using a full font file with
    tenths of icons only to use a fraction of them is wasted bandwidth. If you're
    only going to use a handful of icon fonts, using IcoMoon.io or Fontello.com for
    custom icon selection is a better option.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑使用Font Awesome时要小心。使用一个包含数十个图标的完整字体文件，只使用其中的一小部分是浪费带宽的。如果你只打算使用少量图标字体，使用IcoMoon.io或Fontello.com进行自定义图标选择是一个更好的选择。
- en: Once you are able to unzip the provided files, the only file you're going to
    need is the `.woff` file. The reason you only need this file is because browser
    support for `.woff` files goes all the way back to IE9\. Unless you want/need
    to support legacy browsers (desktop and mobile), you can then use `.eot`, `.ttf`,
    and `.svg` files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能解压提供的文件，你唯一需要的文件就是`.woff`文件。你只需要这个文件的原因是因为浏览器对`.woff`文件的支持一直可以追溯到IE9。除非你想/需要支持旧版浏览器（桌面和移动端），你可以使用`.eot`、`.ttf`和`.svg`文件。
- en: Tip
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I recommend that you keep it simple and avoid unnecessary headaches when trying
    to support icon fonts in legacy browsers. All they get is the text instead of
    the icon, or display the text in the `title=""` attribute.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你保持简单，避免在尝试支持旧版浏览器中出现不必要的麻烦。他们只会得到文本而不是图标，或者在`title=""`属性中显示文本。
- en: 'Let''s name our icon font file `icon-font.woff`. Create a `/fonts` folder and
    save the `icon-font.woff` file in it. This is what we are going to try to accomplish:
    a soft-blue link with an icon on the left, no underline, and 40px Arial/Helvetica
    font:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将图标字体文件命名为`icon-font.woff`。创建一个`/fonts`文件夹，并将`icon-font.woff`文件保存在其中。这是我们要尝试实现的：一个带有左侧图标的浅蓝色链接，没有下划线，以及40px
    Arial/Helvetica字体：
- en: '![Implementing icon fonts](img/B02102_06_06.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![实现图标字体](img/B02102_06_06.jpg)'
- en: Using a pseudo-element
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用伪元素
- en: The great thing about using a pseudo-element is that our source markup always
    stays clean. In this case, we're going to use the `:before` pseudo-element, but
    this technique also works with an `:after` pseudo-element.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伪元素的好处是我们的源标记始终保持清晰。在这种情况下，我们将使用`:before`伪元素，但这种技术也适用于`:after`伪元素。
- en: Let's take a look at the build.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下构建。
- en: 'This is the HTML snippet:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTML片段：
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here''s the SCSS. The first thing we need is a mixin to handle any custom web
    fonts. In this case, it is an icon font:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SCSS。我们需要的第一件事是一个mixin来处理任何自定义网络字体。在这种情况下，它是一个图标字体：
- en: '[PRE35]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Notice the nested properties in the `font: {…}` block. By doing this, we keep
    things DRY and avoid repeating the term *font* for the following instances: `font-family`,
    `font-weight` and `font-style`.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '注意`font: {…}`块中的嵌套属性。通过这样做，我们保持代码的DRY，并避免重复术语*font*用于以下实例：`font-family`、`font-weight`和`font-style`。'
- en: 'Then, we create a rule using *attribute selectors* to handle the basic styling
    properties of the icon font:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用*属性选择器*创建一条规则来处理图标字体的基本样式属性：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice the `^` and `*` characters in the attribute selectors. The first one
    means *select elements starting with the term* `icon-` and the second *select
    elements containing the term* `icon-`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意属性选择器中的`^`和`*`字符。第一个意味着*选择以术语* `icon-` *开头的元素*，第二个*选择包含术语* `icon-` *的元素*。
- en: 'Then, we need to call the `fontFace` mixin in order to bring the font into
    the compiled CSS file:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要调用`fontFace` mixin来将字体引入编译后的CSS文件中：
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The great thing about the `fontFace` mixin is that all we need to do is declare
    the font name and then the file path. There is no need to declare the file extension;
    that's taken care of by the mixin.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`fontFace` mixin的好处是我们只需要声明字体名称，然后是文件路径。不需要声明文件扩展名；这由mixin来处理。'
- en: 'This will compile to:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译为：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the rule that makes the magic happen using `:before`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`:before`使魔法发生的规则：
- en: '[PRE39]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For basic styling enhancement, we create these other two rules. However, they
    are not required. The code is as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了基本的样式增强，我们创建了另外两条规则。但是，它们并不是必需的。代码如下：
- en: '[PRE40]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The final compiled CSS looks like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最终编译的CSS如下：
- en: '[PRE41]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here''s a demo I created for this in CodePen: [http://codepen.io/ricardozea/pen/e62b201350efe7f59f91c934f9fc30fa](http://codepen.io/ricardozea/pen/e62b201350efe7f59f91c934f9fc30fa)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上为此创建的演示：[http://codepen.io/ricardozea/pen/e62b201350efe7f59f91c934f9fc30fa](http://codepen.io/ricardozea/pen/e62b201350efe7f59f91c934f9fc30fa)
- en: 'Here''s another demo I created in CodePen with the icon fonts a bit more advanced:
    [http://codepen.io/ricardozea/pen/5a16adffb6565312506c47ca3df69358](http://codepen.io/ricardozea/pen/5a16adffb6565312506c47ca3df69358)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上创建的另一个演示，其中图标字体更加高级：[http://codepen.io/ricardozea/pen/5a16adffb6565312506c47ca3df69358](http://codepen.io/ricardozea/pen/5a16adffb6565312506c47ca3df69358)
- en: Using an extra HTML element
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用额外的HTML元素
- en: To be honest, using an extra HTML element goes a little against the principle
    of separating content from styling, since adding an extra HTML element for styling
    reasons is not something some developers recommend. However, we can also argue
    that the icon itself really is content, not styling. Either way, here's the run
    down.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，使用额外的HTML元素有点违背了将内容与样式分离的原则，因为出于样式原因添加额外的HTML元素并不是一些开发人员推荐的做法。然而，我们也可以说图标本身确实是内容，而不是样式。无论如何，这是概述。
- en: 'Here''s the HTML snippet:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTML片段：
- en: '[PRE42]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In order to hide irrelevant content from screen readers, we use the `aria-hidden="true"`
    directive.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏屏幕阅读器中的不相关内容，我们使用`aria-hidden="true"`指令。
- en: 'The SCSS code from the previous example is practically the same, except we
    move the `font-size: 10px;` declaration from the `.icon` class to the `a` rule
    and then delete the `.icon` class altogether. You will also see some extra properties
    but only for styling reasons.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '前面示例中的SCSS代码几乎相同，只是我们将`.icon`类中的`font-size: 10px;`声明移到`a`规则中，然后完全删除`.icon`类。你还会看到一些额外的属性，但只是出于样式原因。'
- en: 'The final SCSS looks like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的SCSS如下：
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The compiled CSS looks like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的CSS如下：
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here''s a demo I created for this in CodePen: [http://codepen.io/ricardozea/pen/8ca49cb06aeb070f4643f0a8e064126c](http://codepen.io/ricardozea/pen/8ca49cb06aeb070f4643f0a8e064126c).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上为此创建的演示：[http://codepen.io/ricardozea/pen/8ca49cb06aeb070f4643f0a8e064126c](http://codepen.io/ricardozea/pen/8ca49cb06aeb070f4643f0a8e064126c)。
- en: Scalable Vector Graphics
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可缩放矢量图形
- en: 'SVG graphics have gained incredible popularity very quickly. Browser support
    is 100 percent, even Opera Mini supports SVG images. Let''s discuss some pros
    and cons of SVG images:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: SVG图形非常快速地获得了令人难以置信的流行。浏览器支持度为100%，甚至Opera Mini也支持SVG图像。让我们讨论一些SVG图像的优缺点：
- en: 'The pros of SVGs:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: SVG的优点：
- en: They can be created and edited with a text editor.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用文本编辑器创建和编辑。
- en: They are 100 percent accessible.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们100%可访问。
- en: They can have multiple colors.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以有多种颜色。
- en: They are SEO-friendly since they can be indexed.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们对SEO友好，因为它们可以被索引。
- en: Since they are vectors, they maintain their quality on any screen density, screen
    size, or zoom level.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们是矢量图形，它们在任何屏幕密度、屏幕尺寸或缩放级别上都保持其质量。
- en: They can be animated, even the elements inside the `<svg>` tag.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被动画化，甚至是`<svg>`标签内的元素。
- en: The SVG spec is an actual, open standard developed by the W3C.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG规范是由W3C开发的一个实际的开放标准。
- en: It's arguably more semantic than using a font for graphics.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能比使用字体进行图形更语义化。
- en: Third-party online icon tools can also export to SVG in addition to icon font.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方在线图标工具也可以导出为SVG，除了图标字体。
- en: Browser support is 100 percent available in modern browsers.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代浏览器中支持度为100%。
- en: 'The cons of SVGs:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: SVG的缺点：
- en: An SVG sprite file can weigh more than its icon font counterpart.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SVG精灵文件可能比其图标字体对应文件更重。
- en: If legacy browser support is required (IE8 and below), an image fallback is
    required.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要支持旧版浏览器（IE8及以下），则需要图像回退。
- en: Software that can save as SVG usually adds extra unnecessary markup in the final
    file, so we either have to remove it manually or use a third-party optimization
    tool to do it for us for every file. This in turn adds another layer of complexity
    to development workflow.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常可以保存为SVG的软件会在最终文件中添加额外的不必要的标记，因此我们要么必须手动删除它，要么使用第三方优化工具为我们每个文件执行此操作。这反过来又给开发工作流程增加了另一层复杂性。
- en: Although SVGs are made with XML structure, it requires a pretty advanced level
    of understanding to perform edits in a text editor.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管SVG是用XML结构制作的，但需要相当高级的理解水平才能在文本编辑器中进行编辑。
- en: 'An SVG file is basically an XML-formatted file. This is what the markup of
    the headphones graphic looks like:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: SVG文件基本上是一个XML格式的文件。这是耳机图形的标记样式：
- en: '[PRE45]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There are many ways to use SVG images: inline via the `<img>`, `<object>`,
    `<use>`, or `<svg>` tags; as background images with CSS; using Modernizr in conditional
    classes to address fallbacks; or with jQuery or plain JavaScript, using third-party
    services such as grumpicon.com, you name it.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多使用SVG图像的方法：通过`<img>`、`<object>`、`<use>`或`<svg>`标签内联；作为CSS的背景图像；使用Modernizr在条件类中使用回退；或者使用jQuery或纯JavaScript，使用第三方服务如grumpicon.com等。
- en: 'To keep things simple, we''re going to focus on two methods:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将专注于两种方法：
- en: Inline via the `<svg>` tag.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`<svg>`标签内联。
- en: File-based with the `<img>` tag.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于文件的`<img>`标签。
- en: Inline via the <svg> tag
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过`<svg>`标签内联
- en: Inlining SVGs is the go-to method of many web designers and developers. The
    fact that we can control individual parts of the SVG with CSS and JavaScript makes
    it very appealing for animations.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 内联SVG是许多网页设计师和开发人员的首选方法。我们可以使用CSS和JavaScript控制SVG的各个部分，这使得它非常适合动画效果。
- en: One of the drawbacks of inlining SVG markup is that the image is not cacheable.
    In other words, every time the image appears, the browser has to read the XML
    of the SVG. If you have too many SVGs on your page, these can potentially be detrimental
    to the page speed and eventually the user experience. So be careful of the objective
    of the page and the types of visitors using your website/app.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 内联SVG标记的一个缺点是图像不可缓存。换句话说，每次图像出现时，浏览器都必须读取SVG的XML。如果页面上有太多的SVG，这可能对页面速度和最终用户体验造成潜在的危害。因此，请注意页面的目标和使用您的网站/应用程序的访问者类型。
- en: 'Here''s an HTML snippet of the SVG of the headphones inlined in a link tag:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SVG耳机的HTML片段，内联在链接标签中：
- en: '[PRE46]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To control its size, distance from the text, and appearance, we add the following
    CSS:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制其大小、与文本的距离和外观，我们添加以下CSS：
- en: '[PRE47]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: SVGs files called via the `<img>` tag *are not* affected by CSS. If you want
    to make any style changes to it, you have to either make them in the actual SVG
    file or place the SVG markup inline.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`<img>`标签调用的SVG文件*不受*CSS的影响。如果要对其进行任何样式更改，必须在实际的SVG文件中进行更改，或者将SVG标记内联。
- en: However, this markup has a problem. It doesn't provide a fallback for legacy
    browsers, specifically IE8 and below. Let's try to fix this.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个标记有一个问题。它没有为旧版浏览器提供回退，特别是IE8及以下版本。让我们试着解决这个问题。
- en: Providing fallback images to legacy browsers for inline SVGs
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为内联SVG提供回退图像给旧版浏览器
- en: There are two ways to provide fallback images to legacy browsers for inline
    SVGs.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为内联SVG提供回退图像的两种方法。
- en: Using the <foreignObject> and <img> tags
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`<foreignObject>`和`<img>`标签
- en: 'Create a `<foreignObject>` element inside the `<svg>` tag and include an `<img>`
    tag that calls the fallback image:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<svg>`标签内创建一个`<foreignObject>`元素，并包含调用回退图像的`<img>`标签：
- en: '[PRE48]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Using an <image> tag
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`<image>`标签
- en: 'As we all know, there''s isn''t an `<image>` tag… or is there? In the SVG world,
    there is! This solution is very similar to the first method. The two differences
    are that we do not use a `<foreignObject>` element and we use an `<image>` tag.
    This is all *inside* the `<svg>` tag:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，在SVG世界中没有`<image>`标签...或者有吗？在SVG世界中，是有的！这个解决方案与第一种方法非常相似。两个不同之处在于我们不使用`<foreignObject>`元素，并且使用`<image>`标签。这一切都在`<svg>`标签内部：
- en: '[PRE49]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, the reason this works is because we are combining a feature of SVGs and
    HTML into one element.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个方法有效的原因是因为我们将SVG和HTML的特性结合到一个元素中。
- en: The SVG feature is that the `<image>` tag is a valid element within the SVG
    world. Now, as weird it sounds, all browsers see the `<image>` tag as an out-of-standards
    tag that resembles the `<img>` tag from HTML.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: SVG的特点是`<image>`标签是SVG世界中的有效元素。现在，尽管听起来很奇怪，但所有浏览器都将`<image>`标签视为一个超出标准的标签，类似于HTML中的`<img>`标签。
- en: The HTML feature is that normally we use the `src` attribute to point to the
    asset's location. In the SVG world, assets are called with the `xlink:href` attribute.
    If we add a `src` attribute pointing to the asset and leave the `xlink:href` attribute
    empty, then legacy browsers will see the fallback image while modern ones won't
    because the `xlink:href` attribute is empty.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: HTML的特点是，通常我们使用`src`属性来指向资源的位置。在SVG世界中，资源被称为`xlink:href`属性。如果我们添加一个指向资源的`src`属性，并且将`xlink:href`属性留空，那么旧版浏览器将看到备用图像，而现代浏览器不会，因为`xlink:href`属性是空的。
- en: I recommend sticking with the second method; it's just more succinct and less
    hassle. Just remember that instead of `<img>`, we use `<image>`. Also, for the
    purpose of the book, I left the `xlink:href` attribute in the markup but this
    is optional. If it's empty, you can remove it altogether if you want.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议坚持第二种方法；它更简洁，更省事。只要记住，我们使用`<image>`而不是`<img>`。另外，为了本书的目的，我在标记中保留了`xlink:href`属性，但这是可选的。如果它是空的，你可以根据需要完全删除它。
- en: Tip
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Throughout the book, I've taken out the trailing slash `/>` on self-closing
    tags such as `<hr>` or `<img>` elements, for example. In HTML5, it is ok to go
    with or without it. However, the trailing slash **is required** in the `path`
    elements in SVGs, that's why you're seeing them here in these examples.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我已经删除了自闭合标签的尾部斜杠`/>`，比如`<hr>`或`<img>`元素。在HTML5中，可以选择带或不带。然而，在SVG的`path`元素中，尾部斜杠**是必需的**，这就是为什么你在这些示例中看到它们的原因。
- en: None of these methods I just mentioned cause double download on browsers that
    support SVG. That's a win-win situation if you ask me.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚提到的这些方法都不会在支持SVG的浏览器上导致双重下载。如果你问我，这是一个双赢的局面。
- en: File-based with the xlink:href and src attributes
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文件的xlink:href和src属性
- en: 'SVG is a type of image file, so calling it within an `<img>` is perfectly valid:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: SVG是一种图像文件，因此在`<img>`中调用它是完全有效的：
- en: '[PRE50]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We know that SVG has flawless support in modern browsers, but the prior image
    isn't displayed in legacy browsers (IE8 and below).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道SVG在现代浏览器中有无缺的支持，但在旧版浏览器（IE8及以下）中不显示先前的图像。
- en: Remember the previous explanation about the `xlink:href` and `src` attributes
    in SVG and HTML? Well, we're going to do pretty much exactly the same we did there.
    However, instead of inlining the SVG markup, we're just going to link to an SVG
    file while providing a fallback image for old browsers.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 记得之前关于SVG和HTML中`xlink:href`和`src`属性的解释吗？嗯，我们要做的基本上和之前一样。不过，与其内联SVG标记，我们只是链接到一个SVG文件，同时为旧浏览器提供一个备用图像。
- en: 'This clever trick was created by Alexey Ten. Here''s the markup:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这个聪明的技巧是由Alexey Ten创建的。这是标记：
- en: '[PRE51]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**There are issues here as well. Alexey''s technique is not the offender, it
    is the browsers—specifically IE9, 10 and 11 as well as iOS 3 and 4\. They download
    both the SVG and the fallback image.**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**这里也有问题。Alexey的技术不是问题，问题在于浏览器——特别是IE9、10和11以及iOS 3和4。它们会同时下载SVG和备用图像。**'
- en: '**If this double download is acceptable for you and you understand the consequences,
    go for it. Nonetheless, keep a mental note of where you can improve things like
    this for your next project.**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果这种双重下载对你来说是可以接受的，并且你理解后果，那就去做吧。尽管如此，记住在下一个项目中可以改进这样的事情。**'
- en: '**Here''s a demo I created for this in CodePen:**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是我在CodePen上为此创建的演示：**'
- en: '**[http://codepen.io/ricardozea/pen/594e718f36976f8e77d4f9cf1640e29a](http://codepen.io/ricardozea/pen/594e718f36976f8e77d4f9cf1640e29a)**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**[http://codepen.io/ricardozea/pen/594e718f36976f8e77d4f9cf1640e29a](http://codepen.io/ricardozea/pen/594e718f36976f8e77d4f9cf1640e29a)**'
- en: '**Other sources to learn about SVG**'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**学习SVG的其他来源**'
- en: '**We can''t talk about SVGs without referencing three of the most noticeable
    names in the web design and development industry today: Amelia Bellamy-Royds,
    Sara Soueidan, and Chris Coyer. Amelia and Chris created one of the most complete
    guides about how to use SVG with fallbacks that I''ve read, *A Complete Guide
    to SVG Fallbacks* ([https://css-tricks.com/a-complete-guide-to-svg-fallbacks/](https://css-tricks.com/a-complete-guide-to-svg-fallbacks/)).**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们谈论SVG时，不能不提到当今网络设计和开发行业中最引人注目的三个名字：Amelia Bellamy-Royds、Sara Soueidan和Chris
    Coyer。Amelia和Chris创建了我读过的关于如何使用带有备用的SVG的最完整指南之一，《A Complete Guide to SVG Fallbacks》([https://css-tricks.com/a-complete-guide-to-svg-fallbacks/](https://css-tricks.com/a-complete-guide-to-svg-fallbacks/))。**'
- en: '**Sara Soueidan''s blog is a must-read if you want to learn everything about
    SVG: [http://sarasoueidan.com/articles/](http://sarasoueidan.com/articles/).**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你想学习关于SVG的一切，Sara Soueidan的博客是必读的：[http://sarasoueidan.com/articles/](http://sarasoueidan.com/articles/)。**'
- en: '**# Summary'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 总结'
- en: Here we are, looking at the horizon and thinking something along the lines of
    `srcset` or `<picture>`? Resize or art direction? `Retina.js` or Sass mixin? FitVids
    or FluidVids? Icon fonts or SVG? Inline SVG of file-based SVG? What's the best
    way to offer our visitors the best experience?
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在看着地平线，思考着`srcset`或`<picture>`？调整大小还是艺术方向？`Retina.js`还是Sass mixin？FitVids还是FluidVids？图标字体还是SVG？内联SVG还是基于文件的SVG？什么是为我们的访客提供最佳体验的最佳方式？
- en: Yes, I know the feeling. And you know what? That's a good problem to have. Otherwise,
    we wouldn't be learning how to master RWD.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道这种感觉。你知道吗？这是一个好问题。否则，我们就不会学习如何掌握RWD了。
- en: Since most of the time we're just resizing images, `srcset` is the way to go.
    Wrapping our videos in a container and a few lines of CSS make those videos responsive
    in no time. Boom! Too many videos to make responsive? No problem, `FitVids.js`
    makes it happen with a single jQuery function. Icon fonts weigh less than their
    big brother SVGs, but keep an eye on those server logs in case the icon font files
    aren't downloading. Using SVGs is always going to be a win, even if there are
    double downloads, but keep leveling up by using different techniques and sharing
    your findings and experiences with others.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数时候我们只是调整图片大小，`srcset`是一个不错的选择。将我们的视频放入一个容器并加上几行CSS，这样视频就能立即响应。太多的视频需要响应？没问题，`FitVids.js`可以通过一个单独的jQuery函数实现。图标字体比它们的大哥SVG文件要轻，但要注意服务器日志，以防图标字体文件没有下载。使用SVG始终是一个胜利，即使有双重下载，但要通过使用不同的技术不断提升水平，并与他人分享你的发现和经验。
- en: 'Let''s change gears and talk about a fascinating subject that can make or break
    your responsive design: typography.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换个话题，谈谈一个迷人的主题，它可以决定你的响应式设计成败：排版。
- en: Let's ride!**
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们出发吧！**
