- en: Chapter 7. Meaningful Typography for Responsive Web Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。响应式网页设计的有意义的排版
- en: 'As I said in one of my talks at the Dayton Web Developers meeting:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在Dayton Web Developers会议上的一次演讲中所说的：
- en: '*"With a solid typographic scale you might even get away with not using a single
    image on your website."*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"有了稳固的排版比例，甚至可能不需要在网站上使用任何图片。"*'
- en: The power of typography has got to be one of the most underappreciated assets
    in web design. Admittedly, we are seeing more and more designs where typography
    has been strongly considered, playing a major role in creating the intended atmosphere
    of a website or app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 排版的力量一定是网页设计中最被低估的资产之一。诚然，我们看到越来越多的设计中，排版已经得到了充分考虑，在创建网站或应用程序预期氛围方面发挥了重要作用。
- en: In this chapter, our focus is going to be on a few aspects, tips, and tricks
    about the things we need to consider for RWD from a typography stand point.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的重点将放在从排版角度考虑RWD所需考虑的一些方面、技巧和窍门上。
- en: 'We''re going to talk about:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论：
- en: Pixels, ems or rems for typography?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素、ems或rems用于排版？
- en: Calculating relative font sizes.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算相对字体大小。
- en: Creating a Modular Scale for a harmonious typography.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为和谐的排版创建模块化比例。
- en: Using the Modular Scale for typography.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块化比例进行排版。
- en: Web fonts and how they affect RWD.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络字体及其对RWD的影响。
- en: Using `FitText.js` for fluid-size headings.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FitText.js`进行流式标题大小。
- en: Using `FlowType.js` to improve legibility.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FlowType.js`来提高可读性。
- en: Pixels, ems, or rems for typography?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素、ems或rems用于排版？
- en: It is difficult to decide whether to use pixels, ems, or rems for typography.
    It's a matter of style. Some web designers/developers still use pixels as their
    unit to declare font sizes. It's just a lot easier to wrap our heads around the
    sizes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很难决定是使用像素、ems还是rems进行排版。这是一个风格问题。一些网页设计师/开发人员仍然使用像素作为声明字体大小的单位。这样做只是更容易理解这些大小。
- en: The issues with setting font sizes in pixels were basically on legacy IEs, where,
    if the user wanted to zoom in on the page for whatever reason, the text would
    stay fixed at the pixel size it was given.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置像素字体大小方面的问题基本上出现在旧版IE上，如果用户因为任何原因想要放大页面，文本将保持在给定的像素大小不变。
- en: Now, that's a thing of the past as far as modern browsers are concerned. When
    you zoom in any modern browser, if it's zoomed in enough, it will trigger the
    media queries, hence showing the mobile version of the site.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于现代浏览器来说，这已经是过去的事情了。当你在任何现代浏览器中放大，如果放大到足够大，它将触发媒体查询，因此显示站点的移动版本。
- en: Another problem with pixel-based font sizing is that it's hard to scale and
    maintain. What this basically means is that we'd have to declare the font sizes
    of many more elements in every media query, over and over and over.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于像素的字体大小设置的另一个问题是很难进行缩放和维护。这基本上意味着我们需要在每个媒体查询中重复声明许多元素的字体大小。
- en: On the other hand, we have relative units, ems and rems, which are pretty much
    the recommended way of setting our font sizes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有相对单位，ems和rems，这基本上是设置我们的字体大小的推荐方式。
- en: However, the problem with ems is that we have to keep track (mentally, in CSS/HTML
    comments, or in a text file somewhere) of the sizes of the parent containers,
    which can easily turn into a font management nightmare. A font size in ems depends
    on the font size of its parent container. So if we have different levels of nested
    containers, things could get ugly really fast because keeping track of the parent
    container's font sizes is not easy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ems的问题在于我们必须跟踪（在脑海中、在CSS/HTML注释中或在某个文本文件中）父容器的大小，这很容易变成字体管理的噩梦。ems中的字体大小取决于其父容器的字体大小。因此，如果我们有不同级别的嵌套容器，情况可能会变得非常复杂，因为跟踪父容器的字体大小并不容易。
- en: But then *rem*s came along. Rem means *root em*. The *root* is the `<html>`
    element.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但后来出现了*rem*。Rem代表*根em*。*根*是`<html>`元素。
- en: 'Rems bring pretty much the best of both worlds: we can declare font sizes in
    rems with the same mental model that we declare pixels, but with the benefit of
    using relative units like ems. The only problem with using rems is that legacy
    browsers don''t support this unit, so a pixel-based, font size fallback value
    needs to be accounted for. This is where a short Sass mixin comes and saves the
    day.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Rems基本上融合了两者的优点：我们可以使用相对单位ems声明rems中的字体大小，但又能像使用像素一样轻松理解。使用rems的唯一问题是旧版浏览器不支持这个单位，因此需要考虑基于像素的字体大小回退值。这就是一个简短的Sass
    mixin出现并拯救一天的地方。
- en: But let's start with the core strategy of this chapter before trying any Sass
    tricks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但在尝试任何Sass技巧之前，让我们先从本章的核心策略开始。
- en: Calculating relative font sizes
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算相对字体大小
- en: 'Remember the RWD magic formula we mentioned in [Chapter 3](ch03.html "Chapter 3. Mobile-first
    or Desktop-first?"), *Mobile-first or Desktop-first?*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在[第3章](ch03.html "第3章。Mobile-first or Desktop-first?")中提到的RWD魔法公式吗，*Mobile-first
    or Desktop-first?*：
- en: (target ÷ context) x 100 = result %
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: （目标 ÷ 上下文）x 100 = 结果%
- en: There's also another similar magic formula to calculate relative font sizes
    (ems) when the font size has been set in pixels. The only difference is that we
    don't multiply by 100.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个类似的魔法公式，用于计算相对字体大小（ems），当字体大小已经以像素设置时。唯一的区别是我们不乘以100。
- en: 'This is that formula:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是那个公式：
- en: target ÷ context = result
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目标 ÷ 上下文 = 结果
- en: The *target* is the font size defined in pixels. The *context* is the font size
    defined in the parent container. The *result* is the value defined in ems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*是以像素定义的字体大小。*上下文*是在父容器中定义的字体大小。*结果*是以ems定义的值。'
- en: 'Here''s an example considering that the font size in the parent container,
    the body in this example, is 16px:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，假设父容器中的字体大小，在这个例子中是body，为16px：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To calculate the relative font size, we use the following formula:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算相对字体大小，我们使用以下公式：
- en: '*30px ÷ 16px = 1.875em*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*30px ÷ 16px = 1.875em*。'
- en: 'So our CSS rule will look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的CSS规则将如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We would have to do this for every font size in our design.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为设计中的每个字体大小都这样做。
- en: This is fine in terms of understanding the math. However, the real value is
    in the thought process that goes into creating those pixel-based values in the
    first place. This is where the Modular Scale comes in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解数学方面是可以的。然而，真正的价值在于创造这些基于像素的值的思考过程。这就是模块比例的价值所在。
- en: Creating a Modular Scale for a harmonious typography
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和谐的排版模块比例
- en: The Modular Scale was created by Tim Brown. There are different ways to create
    a Modular Scale for typography. In our example, we're going to create a Modular
    Scale using two base numbers and one ratio. The multiplication of these numbers
    creates a scale that's harmonious and proportional between all the values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模块比例是由Tim Brown创建的。有不同的方法来创建用于排版的模块比例。在我们的例子中，我们将使用两个基本数字和一个比例来创建一个模块比例。这些数字的乘积创建了一个在所有值之间和谐和成比例的比例。
- en: The most well-known ratio is the *golden ratio* also known as the *golden section*,
    *divine proportion*, and so on. Its value is *1.618*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的比例是*黄金比例*，也被称为*黄金分割*，*神圣比例*等等。它的值是*1.618*。
- en: 'Now, to avoid unnecessary mathematics, the golden ratio is based on the Fibonacci
    sequence: 1, 1, 2, 3, 5, 8, 13, 21, and so on.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了避免不必要的数学计算，黄金比例是基于斐波那契数列的：1, 1, 2, 3, 5, 8, 13, 21等等。
- en: 'These numbers have the following pattern: the next number is the result of
    adding up the two numbers before it. For example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字有以下的模式：下一个数字是前两个数字相加的结果。例如：
- en: 0 + **1** = 1 + **1** = 2 + **1** = 3 + **2** = 5 + **3** = 8 + **5** = 13 +
    **8** = 21…
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 0 + **1** = 1 + **1** = 2 + **1** = 3 + **2** = 5 + **3** = 8 + **5** = 13 +
    **8** = 21…
- en: The idea here is to understand the intent of creating a set of numbers that
    are harmonious when used together. We are going to do the same to create a typographic
    scale to use in our projects with the Modular Scale web app and forget about *manually*
    calculating the relative font sizes for your project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是理解创建一组数字的意图，当它们一起使用时是和谐的。我们将使用相同的方法来创建一个排版比例，以便在我们的项目中使用模块比例网页应用程序，并忘记*手动*计算项目的相对字体大小。
- en: 'So let''s check out the Modular Scale web app built by Tim Brown and Scott
    Kellum: [http://www.modularscale.com/](http://www.modularscale.com/).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来看看由Tim Brown和Scott Kellum构建的模块比例网页应用程序：[http://www.modularscale.com/](http://www.modularscale.com/)。
- en: 'Once the web app opens, there are three steps we need to do in order to create
    our Modular Scale:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网页应用程序打开，我们需要按照以下三个步骤来创建我们的模块比例：
- en: Define the first base number.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第一个基本数字。
- en: Define the second base number.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第二个基本数字。
- en: Choose a ratio.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个比例。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Modular Scale can be used in anything that uses a value of some sort, not
    only typography. It can be used for `padding`, `margin`, `line-height`, and so
    on. Our focus in this chapter is, however, on typography.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模块比例可以用于任何使用某种值的东西，不仅仅是排版。它可以用于`填充`，`边距`，`行高`等等。然而，我们在本章的重点是排版。
- en: Defining the first base number
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义第一个基本数字
- en: The recommended way to define this first number is to use the body text size,
    that is, the font size that is used in the paragraphs. But keep in mind that using
    the body text size as the first base number is not mandatory. We can use our typeface's
    x-height, or some other length within that typeface, that we think could be a
    good starting point.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 定义第一个基本数字的推荐方法是使用正文文本大小，也就是段落中使用的字体大小。但请记住，使用正文文本大小作为第一个基本数字并不是强制性的。我们可以使用我们字体的x高度，或者在该字体中的其他长度，我们认为可能是一个很好的起点。
- en: Although we can choose any font size, let's start with the default one we all
    know all browsers use, 16px. So we type `16px` in the first base field.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以选择任何字体大小，但让我们从我们都知道所有浏览器使用的默认字体大小开始，即16px。所以我们在第一个基本字段中输入`16px`。
- en: Click on the plus icon and add a second base field.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 点击加号图标并添加第二个基本字段。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't worry about the font size preview of the app yet, as you can see, as we
    type numbers for our base values, the font sizes on the right preview pane change.
    We'll get to that in the next step.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不用担心应用程序的字体大小预览，因为你可以看到，当我们为我们的基本值输入数字时，右侧预览窗格中的字体大小会改变。我们将在下一步中介绍这一点。
- en: Defining the second base number
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义第二个基本数字
- en: The second base field is what I call a *magic number* because this number is
    completely subjective and arbitrary, however, it's tightly related to the project
    we're working on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个基本字段是我称之为*魔术数字*，因为这个数字完全是主观和任意的，但它与我们正在进行的项目紧密相关。
- en: When I say *tightly related* I mean something like using the width of the main
    container, for example, 960px, 980px, 1140px, and so on. Alternatively, it can
    also be the number of columns used in the grid, such as 12 or 16\. It can also
    be the width of a column at the maximum width of the site, such as 60px, or even
    the gutter spacing, say 20px.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说*紧密相关*时，我的意思是例如使用主容器的宽度，例如960px，980px，1140px等。或者，它也可以是网格中使用的列数，例如12或16。它也可以是站点最大宽度处的列宽，例如60px，甚至是间距，比如20px。
- en: This *magic number* is anything we want it to be, but it's directly related
    to our project in one way or another. For this example, let's say we're going
    to target screens at a maximum width of 1280px, so our main container is going
    to have a maximum width of 1140px. So let's type `1140px` in the second base field.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*魔术数字*可以是我们想要的任何东西，但它与我们的项目有直接关系。在这个例子中，假设我们的目标是针对最大宽度为1280px的屏幕，所以我们的主容器将具有最大宽度为1140px。所以让我们在第二个基本字段中输入`1140px`。
- en: Choosing a ratio
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个比例
- en: This is where the magic takes place. Choosing a ratio means that this ratio
    will be multiplied by the base numbers creating a scale of values that are proportionally
    related.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是魔术发生的地方。选择一个比例意味着这个比例将与基本数字相乘，从而创建一个比例相关的值的比例。
- en: The ratios are based on musical scales, and in that list is the golden ratio
    (1.618) as well, if we decide to use it. From the **Ratios** dropdown, select
    **1:1.618 – golden section** ratio.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比例是基于音乐音阶的，列表中还包括黄金比例（1.618），如果我们决定使用它的话。从**比例**下拉菜单中，选择**1:1.618 - 黄金分割**比例。
- en: That's it! We have now created our first Modular Scale.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在已经创建了我们的第一个模块比例。
- en: 'The font sizes provided by this Modular Scale are totally harmonious because
    they are proportionate to each other based on relevant values that are directly
    related to our project:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由模块比例提供的字体大小完全和谐，因为它们是相对于彼此的比例值，这些比例值与我们项目直接相关：
- en: The ideal body font size is 16px
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想的正文字体大小是16px
- en: The maximum width of our main container is 1140px
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们主容器的最大宽度是1140px
- en: The Golden Ratio is 1.618
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄金比例是1.618
- en: Our typography now has a solid modular foundation, let's use it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的排版现在有了坚实的模块基础，让我们使用它。
- en: Using the Modular Scale for typography
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块比例进行排版
- en: If you click on the **Table** view, all the text is now gone and we're left
    with a list of font sizes—ranging from ridiculously small values to just as ridiculously
    large values. But that's ok. That's the power of a modular scale.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击**表格**视图，所有文本现在都消失了，我们只剩下一系列字体大小，范围从非常小的值到非常大的值。但没关系。这就是模块比例的力量。
- en: 'This is what we see:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们看到的：
- en: '![Using the Modular Scale for typography](img/B02102_07_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![使用模块比例进行排版](img/B02102_07_01.jpg)'
- en: 'As you can see in the preceding image, there are three columns:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图像所示，有三列：
- en: The first column shows the font size in pixels.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一列显示了像素单位的字体大小。
- en: The second column shows the font size in ems.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二列显示了em单位的字体大小。
- en: The third column shows the font size if the base was 16px.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三列显示了基准为16px时的字体大小。
- en: What we need to do is focus on the first and second columns only. The highlighted
    row that says 16px, or 1em, is going to be the font size of our paragraphs. 16px
    is the default font size in most browsers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要专注于第一列和第二列。突出显示的16px，或1em的行，将成为我们段落的字体大小。16px是大多数浏览器中的默认字体大小。
- en: 'Then, we define our header elements. Let''s say we define only `h1`, `h2` and
    `h3`. This means that we''re going to select the rows above 16px that have larger
    font sizes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的标题元素。假设我们只定义`h1`，`h2`和`h3`。这意味着我们将选择大于16px的行，具有更大的字体大小：
- en: '`<h1>`: **39.269px** that is 2.454em'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1>`：**39.269px**，即2.454em'
- en: '`<h2>`: **25.888px** that is 1.618em'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h2>`：**25.888px**，即1.618em'
- en: '`<h3>`: **24.57px** that is 1.517em'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h3>`：**24.57px**，即1.517em'
- en: 'For the `<small>` element, if we have any disclaimers on our site, we select
    the font size right below 16px:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`<small>`元素，如果网站上有任何免责声明，我们选择小于16px的字体大小：
- en: '`<small>`: **9.889px** that is 0.618em'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`<small>`：**9.889px**，即0.618em'
- en: That's it! All the numbers in this Modular Scale are harmonious and when used
    together will provide a clear visual hierarchy, and a relationship difficult to
    obtain through other methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！模块比例中的所有数字都是和谐的，当一起使用时将提供清晰的视觉层次结构，以及通过其他方法难以获得的关系。
- en: Here's an example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。
- en: 'This is the HTML:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTML：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the SCSS:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SCSS：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice how I'm including the mobile-first Sass mixin as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我也包含了移动优先的Sass mixin。
- en: 'Here''s the compiled CSS:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译后的CSS：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Modular Scale looks like this on small screens (510px wide):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在小屏幕上（宽510px）模块比例如下：
- en: '![Using the Modular Scale for typography](img/B02102_07_02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![使用模块比例进行排版](img/B02102_07_02.jpg)'
- en: 'And like this on large screens (850px wide):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在大屏幕上（宽850px）也是这样：
- en: '![Using the Modular Scale for typography](img/B02102_07_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用模块比例进行排版](img/B02102_07_03.jpg)'
- en: 'The only potential problem we have here is what I mentioned before about using
    ems: keeping track of the font size of the parent elements can turn into a font
    management nightmare.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里唯一可能遇到的问题是我之前提到的关于使用em的问题：跟踪父元素的字体大小可能会变成字体管理的噩梦。
- en: Using pixels is a no-go because of its scalability issues in legacy browsers.
    Using rems, however, keeps things in the "relative font size" realm, while providing
    a pixel-based mentality but without the scalability problems. This allows us to
    support legacy browsers that do not support rems.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像素是不可取的，因为在传统浏览器中存在可伸缩性问题。然而，使用rems可以保持在“相对字体大小”领域，同时提供基于像素的思维方式，但没有可伸缩性问题。这使我们能够支持不支持rems的传统浏览器。
- en: 'Here''s a demo I created for this in CodePen:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen为此创建的演示：
- en: '[http://codepen.io/ricardozea/pen/0b781bef63029bff6155c00ff3caed85](http://codepen.io/ricardozea/pen/0b781bef63029bff6155c00ff3caed85)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://codepen.io/ricardozea/pen/0b781bef63029bff6155c00ff3caed85](http://codepen.io/ricardozea/pen/0b781bef63029bff6155c00ff3caed85)'
- en: The rems-to-pixels Sass mixin
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rems-to-pixels Sass mixin
- en: All we need is a Sass mixin that allows us to set the font values without a
    specific unit and the mixin takes care of adding the font sizes for both rem-based
    for modern browsers, and the pixel-based for legacy browsers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个Sass mixin，允许我们设置没有特定单位的字体值，mixin会负责为现代浏览器添加rem单位的字体大小，为传统浏览器添加像素单位的字体大小。
- en: 'This is the Sass mixin created by Chris Coyer:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由Chris Coyer创建的Sass mixin：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I made a small modification to the original name of the mixin from using dash-separated
    to camelCase. The reason I did this is because it's easier to spot the name of
    a mixin from a class name when scanning the document.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我对mixin的原始名称进行了小修改，从使用破折号分隔改为驼峰命名法。我这样做的原因是因为在扫描文档时，从类名中更容易找到mixin的名称。
- en: 'The usage is like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 用法如下：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example uses the same markup used in an earlier chapter, so I'm going to
    show you only the SCSS and some screenshots.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了前一章节中使用的相同标记，所以我只会展示SCSS和一些截图。
- en: 'The SCSS is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SCSS如下：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Consider the following points:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下几点：
- en: We're setting the root font size to 62.5 percent, which reduces the font size
    to 10px. This makes declaring the font values a lot easier. For example, a font
    size of 1.2rem is the same as 12px, .8rem is 8px, and so on.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将根字体大小设置为62.5％，将字体大小减小到10px。这样声明字体值就容易得多。例如，1.2rem的字体大小等同于12px，.8rem等同于8px，依此类推。
- en: We need to move the decimal dot from the pixel-based values one spot to the
    left when declaring the font size in rems. For example, according to our Modular
    Scale the `<h1>` pixel size is 39.269px, so when declaring the font size in rems,
    we declare it as 3.9269, *without a unit*.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明rems的字体大小时，我们需要将小数点从基于像素的值向左移一位。例如，根据我们的模块化比例，`<h1>`像素大小为39.269px，所以在声明rems的字体大小时，我们声明为3.9269，*不带单位*。
- en: 'The compiled CSS is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的CSS如下：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is what the Modular Scale using the rems-to-pixels mixin looks like on
    small screens (510px wide):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在小屏幕上（510像素宽）使用rems-to-pixels mixin的模块化比例的样子：
- en: '![The rems-to-pixels Sass mixin](img/B02102_07_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![rems-to-pixels Sass mixin](img/B02102_07_04.jpg)'
- en: 'This is what it looks like on large screens (850px wide):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在大屏幕上（850像素宽）的样子：
- en: '![The rems-to-pixels Sass mixin](img/B02102_07_05.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![rems-to-pixels Sass mixin](img/B02102_07_05.jpg)'
- en: 'Here''s a demo I created for this in CodePen:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上创建的演示：
- en: '[http://codepen.io/ricardozea/pen/8a95403db5b73c995443720475fdd900](http://codepen.io/ricardozea/pen/8a95403db5b73c995443720475fdd900)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://codepen.io/ricardozea/pen/8a95403db5b73c995443720475fdd900](http://codepen.io/ricardozea/pen/8a95403db5b73c995443720475fdd900)'
- en: The examples we just saw are using the system font Arial. Let's go ahead and
    spruce these examples up with some web fonts to give them a bit more *character*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的示例使用了系统字体Arial。让我们继续使用一些网络字体来提升这些示例的*特色*。
- en: Web fonts and how they affect RWD
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络字体及其对RWD的影响
- en: Web fonts are almost mandatory to use nowadays, and I say *almost* because we
    need to be mindful of the implications they bring to our projects, and if necessary,
    we may actually not use them at all.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在几乎必须使用网络字体，我说*几乎*是因为我们需要注意它们对我们项目的影响，如果必要，我们实际上可能根本不使用它们。
- en: 'Before we get into the nitty gritty of how to work with web fonts, here are
    a few web font resources that may be helpful for many of you:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究如何使用网络字体之前，以下是一些可能对你们许多人有帮助的网络字体资源：
- en: '**Font Squirrel** ([http://www.fontsquirrel.com/](http://www.fontsquirrel.com/)):
    I''ve used this service extensively with great success. To use the fonts, you
    need to download the file(s) and then use with `@font-face` in your CSS. They
    have the best web font generator tool you''ll ever find ([http://www.fontsquirrel.com/tools/webfont-generator](http://www.fontsquirrel.com/tools/webfont-generator))'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Font Squirrel** ([http://www.fontsquirrel.com/](http://www.fontsquirrel.com/))：我已经广泛使用了这项服务并取得了巨大成功。要使用这些字体，你需要下载文件，然后在你的CSS中使用`@font-face`。他们有你能找到的最好的网络字体生成工具([http://www.fontsquirrel.com/tools/webfont-generator](http://www.fontsquirrel.com/tools/webfont-generator))'
- en: '**Google Fonts** ([https://www.google.com/fonts](https://www.google.com/fonts)):
    I can''t talk about web font resources without mentioning Google Fonts. If I can''t
    find it on Font Squirrel I come here, and vice versa. You can either download
    the font file(s) or use JavaScript. The fonts used in the following examples were
    downloaded from Google Fonts ([https://github.com/google/fonts/tree/master/ofl/oswald](https://github.com/google/fonts/tree/master/ofl/oswald)).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Fonts** ([https://www.google.com/fonts](https://www.google.com/fonts))：我不能谈论网络字体资源而不提到Google
    Fonts。如果我在Font Squirrel上找不到，我就来这里，反之亦然。你可以下载字体文件，或者使用JavaScript。以下示例中使用的字体是从Google
    Fonts下载的([https://github.com/google/fonts/tree/master/ofl/oswald](https://github.com/google/fonts/tree/master/ofl/oswald))。'
- en: '**Adobe Edge Web Fonts** ([https://edgewebfonts.adobe.com/](https://edgewebfonts.adobe.com/)):
    This is also a great tool. This service is powered by TypeKit (the first web font
    service). I''ve used TypeKit extensively as well. You can''t download the fonts
    though, you have to use JavaScript instead.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Adobe Edge Web Fonts** ([https://edgewebfonts.adobe.com/](https://edgewebfonts.adobe.com/))：这也是一个很棒的工具。这项服务由TypeKit（第一个网络字体服务）提供支持。我也广泛使用了TypeKit。但你不能下载字体，必须使用JavaScript。'
- en: 'Now, let''s see the pros and cons of using web fonts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用网络字体的利弊：
- en: 'The advantages are:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 优点包括：
- en: They help accentuate the brand and create consistency across different media.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有助于突出品牌，并在不同媒体上创建一致性。
- en: When used correctly, they make designs look more appealing.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确使用时，它们使设计看起来更吸引人。
- en: There is no need to use image replacement techniques anymore.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再需要使用图像替换技术。
- en: This keeps the text as HTML making the content more accessible and *indexable*.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使文本保持为HTML，使内容更易访问和*可索引*。
- en: Legacy browsers support web fonts.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧版浏览器支持网络字体。
- en: Great resources for free fonts.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费字体的绝佳资源。
- en: All these in turn help keep the markup cleaner.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些都有助于保持标记更清洁。
- en: 'The disadvantages are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点包括：
- en: They slow down the website/app due to HTTP requests or their dependency on third-party
    servers.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们由于HTTP请求或对第三方服务器的依赖而减慢网站/应用的速度。
- en: Not all web fonts are legible at small and/or large sizes.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有网络字体在小尺寸和/或大尺寸下都可读。
- en: If legacy browsers are required to support, there are more files to manage.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要支持旧版浏览器，则需要管理更多文件。
- en: 'Licensing the use of a font requires some sort of payment: monthly, per font
    family, per font style, and so on.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字体需要付费：每月、每个字体系列、每种字体样式等等。
- en: Some free fonts are not well built.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些免费字体制作不良。
- en: 'There are rendering side effects:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有渲染副作用：
- en: '**Flash Of Unstyled Text** (**FOUT**): On modern browsers, when the page loads,
    the text is first rendered on the screen with a system font, and then a second
    later it''s swapped and styled with the web font.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未样式文本的闪烁**（**FOUT**）：在现代浏览器上，当页面加载时，文本首先用系统字体呈现在屏幕上，然后一秒钟后被切换并用网络字体进行样式设置。'
- en: '**Flash Of Invisible Text** (**FOIT**): On legacy browsers, when the page loads,
    the text is not visible but a second later it''s rendered with the web font.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可见文本的闪烁**（**FOIT**）：在旧版浏览器上，当页面加载时，文本是不可见的，但一秒钟后它会用网络字体呈现出来。'
- en: There are others not worth getting into, such as **Flash Of Fallback Text**
    and **Flash Of Faux Text** (**FOFT**).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他不值得深入的，比如**备用文本的闪烁**和**伪文本的闪烁**（**FOFT**）。
- en: How to tackle all the "flash-of-whatever-texts" is not part of the scope of
    this section. However, I encourage you to read about Font Load Events in Zach
    Leatherman's article on the Opera blog called *Better @font-face with Font Load
    Events* ([https://dev.opera.com/articles/better-font-face/](https://dev.opera.com/articles/better-font-face/)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解决所有“闪烁文本”的问题不在本节的范围之内。但是，我鼓励您阅读Zach Leatherman在Opera博客上关于*使用字体加载事件改进@font-face*的文章（[https://dev.opera.com/articles/better-font-face/](https://dev.opera.com/articles/better-font-face/)）。
- en: Sass mixin for implementing web fonts
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于实现网络字体的Sass mixin
- en: To implement web fonts, we need to use the `@font-face` directive in our CSS…
    well, SCSS.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现网络字体，我们需要在我们的CSS中使用`@font-face`指令...嗯，SCSS。
- en: 'The `@font-face` declaration block looks like this in its vanilla CSS form:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`@font-face`声明块在其原始CSS形式中如下所示：'
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, if you're using more than one style or font family, you need to repeat
    the whole `@font-face` declaration block for each font file. This is not very
    DRY (Don't Repeat Yourself).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您使用多种样式或字体系列，您需要为每个字体文件重复整个`@font-face`声明块。这不是很干净（不要重复自己）。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Web fonts are expensive in terms of file size and server requests, so please
    use web fonts moderately. The more you use, the slower your website/web app will
    become.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 网络字体在文件大小和服务器请求方面都很昂贵，因此请适度使用网络字体。您使用的越多，您的网站/网络应用程序就会变得越慢。
- en: Yes that's a pretty hefty piece of CSS to handle web fonts, oh man.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，处理网络字体的CSS代码相当庞大，哦天啊。
- en: 'To keep our sanity, let''s turn the prior `@font-face` CSS declaration block
    to a Sass mixin:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持理智，让我们将先前的`@font-face` CSS声明块转换为Sass mixin：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The usage is a single line of code to call the font file. Let''s use the typeface
    Oswald:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一行代码调用字体文件。让我们使用Oswald字体：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using it on any element is a matter of adding the font name at the beginning
    of the font stack, as shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何元素上使用它只需在字体堆栈的开头添加字体名称，如下所示：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we need to include more than one font file, just add another line calling
    the mixin but specifying the other font name:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要包含多个字体文件，只需添加另一行调用mixin，但指定其他字体名称：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding two lines of code will compile to the following CSS:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行代码将编译为以下CSS：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s a pretty nifty way of creating all that CSS with a mere two lines of
    code, eh? However, if we want to make things right, let''s analyze what we''re
    doing here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常巧妙的方式，只需两行代码就可以创建所有这些CSS，是吧？然而，如果我们想做正确的事情，让我们分析一下我们在这里做什么：
- en: 'We''re supporting legacy browsers:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们支持旧版浏览器：
- en: IE8 and below with a `.eot` font.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IE8及以下版本使用`.eot`字体。
- en: Old Safari on Android in iOS with a `.ttf` font.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS上的旧版Safari和Android上使用`.ttf`字体。
- en: Old iOS for the, practically forgotten, iPhone 3 and below with a `.svg` file.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧版iOS适用于几乎被遗忘的iPhone 3及以下版本，使用`.svg`文件。
- en: Modern browsers only need a `.woff` font. According to CanIUse.com, `.woff`
    font files are 99 percent supported, with the exception of Opera Mini at the time
    of writing this book ([http://caniuse.com/#search=woff](http://caniuse.com/#search=woff)).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代浏览器只需要`.woff`字体。根据CanIUse.com的数据，`.woff`字体文件有99%的支持率，除了Opera Mini在撰写本书时（[http://caniuse.com/#search=woff](http://caniuse.com/#search=woff)）。
- en: 'So the question is: Can we gracefully degrade the experience for legacy browsers
    and OS''s and let them use a system font instead?'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题是：我们是否可以优雅地降级旧版浏览器和操作系统的体验，并让它们使用系统字体？
- en: Sure we can!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以！
- en: 'After optimizing the mixin to use only `.woff` fonts, this is what it looks
    like:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化mixin以仅使用`.woff`字体后，它看起来是这样的：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The usage is exactly the same:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式完全相同：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The compiled CSS is much shorter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的CSS要短得多：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using it on a couple of elements looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个元素上使用它看起来像这样：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Serving only the `.woff` font puts a lot less file management on our plate,
    which helps free our brains from unnecessary tasks and allow us to focus on what
    matters most: building a memorable experience. Not to mention, it makes our CSS
    code more streamlined and scalable.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 仅提供`.woff`字体可以减少我们的文件管理工作量，有助于解放我们的大脑，让我们专注于最重要的事情：构建一个令人难忘的体验。更不用说，它使我们的CSS代码更加简洁和可扩展。
- en: But wait, we're letting legacy browsers gracefully degrade to system fonts,
    and we still need to define the font sizes in pixels for them!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，我们让旧版浏览器优雅地降级到系统字体，我们仍然需要为它们定义像素字体大小！
- en: Pixels-to-rems Sass mixin to the rescue!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 像素到rems Sass mixin来拯救！
- en: 'Remember to see the base-10 model in the `<html>` tag for easier calculations:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`<html>`标签中查看十进制模型以便更容易计算：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then let''s declare the font sizes and font families:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们声明字体大小和字体系列：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The compiled CSS looks to this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的CSS如下所示：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We're declaring two separate font sizes in the same rule, therefore we can't
    use the font shorthand in this case.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在同一规则中声明了两个不同的字体大小，因此在这种情况下我们不能使用字体简写。
- en: Thus, by harnessing the superpowers of two simple Sass mixins, we can easily
    embed web fonts and use rems for our font-sizes while providing pixel-based font
    sizes for legacy browsers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过利用两个简单的Sass mixin的超能力，我们可以轻松嵌入网络字体，并为我们的字体大小使用rems，同时为旧版浏览器提供基于像素的字体大小。
- en: This is a great example of robust scalability.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大可扩展性的很好的例子。
- en: 'Here''s a demo I created for this in CodePen:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上创建的演示：
- en: '[http://codepen.io/ricardozea/pen/9c93240a3404f12ffad83fa88f14d6ef](http://codepen.io/ricardozea/pen/9c93240a3404f12ffad83fa88f14d6ef)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://codepen.io/ricardozea/pen/9c93240a3404f12ffad83fa88f14d6ef](http://codepen.io/ricardozea/pen/9c93240a3404f12ffad83fa88f14d6ef)'
- en: Without losing any momentum, let's change gears and talk about how to improve
    the legibility of our pages by accomplishing a minimum line length with the awesome
    FlowType.js jQuery plugin by Simple Focus.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在不失去任何动力的情况下，让我们转变思路，谈谈如何通过使用Simple Focus的强大FlowType.js jQuery插件来实现最小行长，从而提高页面的可读性。
- en: Using FlowType.js for increased legibility
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FlowType.js增加可读性
- en: One of the most compelling editorial principles states that the ideal line length
    for the most legible typography is between 45 and 75 characters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最具说服力的编辑原则之一是，最易读的排版的理想行长在45到75个字符之间。
- en: That's a pretty decent range if you ask me. However, actually making your paragraphs
    long enough, or short enough for that matter, is like a "blind leading the blind"
    game. How can we tell whether the combination of the width of a container and
    its font size actually meet the 45 to 75 characters recommendation? Also, on small
    or medium screens, how can you tell this is the case?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问我，这是一个相当不错的范围。然而，实际上让你的段落足够长，或者足够短，就像一个“盲人引导盲人”的游戏。我们怎么知道容器的宽度和字体大小的组合是否真正符合45到75个字符的建议？此外，在小屏幕或中等屏幕上，你怎么知道情况是这样的？
- en: Tricky one, eh?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 棘手的问题，对吧？
- en: Well, no need to worry because with FlowType.js, we can address these issues.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，不用担心，因为有了FlowType.js，我们可以解决这些问题。
- en: You can download the plugin from [http://simplefocus.com/flowtype/](http://simplefocus.com/flowtype/).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://simplefocus.com/flowtype/](http://simplefocus.com/flowtype/)下载这个插件。
- en: 'The first thing we need is the HTML, so here''s the markup we''re going to
    use:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一件事是HTML，所以这是我们将要使用的标记：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once you get comfortable with FlowType.js, you might actually start thinking,
    "If FlowType automatically modifies the font size at pretty much any viewport
    width, I don't think I need to declare any font sizes in my SCSS! After all, they
    are going to get overwritten by FlowType."
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了FlowType.js，你可能会开始思考，“如果FlowType自动在几乎任何视口宽度下修改字体大小，我觉得我不需要在我的SCSS中声明任何字体大小！毕竟，它们将被FlowType覆盖。”
- en: Well, we do need to set the font size regardless, because if FlowType.js doesn't
    load, we'd be left at the mercy of the browser's default styles, and we designers
    do not want that.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们确实需要设置字体大小，因为如果FlowType.js没有加载，我们将受制于浏览器的默认样式，而我们设计师不想要这样。
- en: 'With that being said, here''s the SCSS to declare the necessary font sizes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，这是声明必要字体大小的SCSS：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will compile to the following CSS:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译成以下CSS：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is where the magic happens. We create a jQuery function where we can specify
    which element(s) to target. This function can be placed either inside a separate
    JavaScript file or within the markup.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方。我们创建一个jQuery函数，可以指定要定位的元素。这个函数可以放在一个单独的JavaScript文件中，也可以放在标记中。
- en: In our example we're telling FlowType.js to apply the resizing of the font to
    the `<html>` element. Since we're using relative font size units, rems, all the
    text will automatically resize/adjust at any screen width, maintaining the ideal
    line length.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们告诉FlowType.js将字体的调整应用到`<html>`元素上。由于我们使用相对字体大小单位rems，所有文本将在任何屏幕宽度下自动调整大小，保持理想的行长度。
- en: 'Here''s the jQuery function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是jQuery函数：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Defining thresholds
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义阈值
- en: 'There''s a potential problem with the solution we just saw: FlowType.js will
    modify the font size of the paragraphs indefinitely. In other words, on small
    screens the text will be extremely small and on large screens it will be way too
    big.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的解决方案存在潜在问题：FlowType.js将无限期地修改段落的字体大小。换句话说，在小屏幕上，文本将变得非常小，在大屏幕上，文本将变得太大。
- en: We can solve this issue with two separate threshold approaches or a combination
    of both.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两种不同的阈值方法或两者结合来解决这个问题。
- en: Now, one thing we need to make clear is that this part will require some tweaking
    and adjusting in order to get the best results, there aren't specific values that
    will work for all situations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要澄清的一件事是，这部分需要一些调整和调整，以获得最佳结果，没有特定的值适用于所有情况。
- en: 'We are going to use the following approach:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用以下方法：
- en: Define the minimum and maximum widths of the container or element.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义容器或元素的最小和最大宽度。
- en: Define the minimum and maximum font sizes of the container or element.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义容器或元素的最小和最大字体大小。
- en: Threshold widths
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阈值宽度
- en: Defining the minimum and maximum widths will tell FlowType.js at which points
    it should stop resizing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 定义最小和最大宽度将告诉FlowType.js在哪些点停止调整大小。
- en: 'Let''s define the width thresholds:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义宽度阈值：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The thresholds I selected work specifically for this example and it may not
    necessarily work for other situations. Tweak and test until you get the ideal
    widths that work with the recommended 45-75 characters per line recommendation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择的阈值专门适用于这个示例，可能不适用于其他情况。调整和测试，直到你得到适合推荐的每行45-75个字符的理想宽度。
- en: Threshold font sizes
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阈值字体大小
- en: Just like with the width thresholds, defining the minimum and maximum font sizes
    will tell FlowType.js what the smallest and largest font sizes it should scale
    the text to.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 就像宽度阈值一样，定义最小和最大字体大小将告诉FlowType.js应该将文本缩放到的最小和最大字体大小。
- en: 'We''re also going to declare our own font size using the `fontRatio` variable;
    the higher the number, the smaller the font, and the lower the number, the larger
    the font. If this feels counterintuitive, look at it this way: the higher the
    number, the higher the compression (thus making it small) and the lower the number,
    the lower the compression (thus making it large).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`fontRatio`变量声明自己的字体大小；数字越大，字体越小，数字越小，字体越大。如果这感觉反直觉，可以这样理解：数字越大，压缩越大（因此变小），数字越小，压缩越小（因此变大）。
- en: Adjusting the `fontRatio` value is an *eyeballing* exercise, so tweak and test
    like there's no tomorrow.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 调整`fontRatio`值是一个*凭感觉*的练习，所以像没有明天一样调整和测试。
- en: 'Let''s take a look at the font sizes values:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下字体大小的值：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There's no need to include a comma after the last value in the list.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中的最后一个值后面不需要包含逗号。
- en: FlowType.js just plain rocks man!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: FlowType.js真的很棒！
- en: 'Here''s a demo I created for this in CodePen:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在CodePen上创建的演示：
- en: '[http://codepen.io/ricardozea/pen/c2e6abf545dbaa82a16ae84718c79d34](http://codepen.io/ricardozea/pen/c2e6abf545dbaa82a16ae84718c79d34)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://codepen.io/ricardozea/pen/c2e6abf545dbaa82a16ae84718c79d34](http://codepen.io/ricardozea/pen/c2e6abf545dbaa82a16ae84718c79d34)'
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So here we are, levelled up in typography for RWD. Is there more about typography?
    You bet! This amazing subject is a whole industry in itself, without it we wouldn't
    be reading this book.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里，我们在RWD的排版上升了一个层次。排版还有更多内容吗？当然有！这个令人惊叹的主题本身就是一个完整的行业，没有它我们就不会读到这本书。
- en: 'We can now say that we understand why using relative units for typography is
    a good approach: scalability. Also, using our little magic formula, we can calculate
    relative font sizes for each of our text elements in our design, but why go through
    all that trouble? Modular Scale for typography saves the day in that regard, and
    it injects our projects with awesome typographic harmony. Who knows, maybe we
    may not need to use images at all!'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以说，我们明白为什么使用相对单位进行排版是一个好方法：可伸缩性。此外，使用我们的小魔法公式，我们可以计算设计中每个文本元素的相对字体大小，但为什么要经历这么多麻烦呢？排版的模块化比例在这方面拯救了我们，并为我们的项目注入了令人惊叹的排版和谐。谁知道，也许我们根本不需要使用图片！
- en: Brands can now be extended to the web via web fonts, but we need to be careful
    and consider the impact of using them on our sites/apps. Also, as far as modern
    browsers go, we only need to use a single file type (WOFF font files), which make
    things a lot easier to manage—for browsers to download and for users to enjoy.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 品牌现在可以通过网络字体扩展到网络上，但我们需要谨慎考虑它们对我们网站/应用的影响。另外，就现代浏览器而言，我们只需要使用一种文件类型（WOFF字体文件），这样可以更容易地管理——对于浏览器下载和用户享受都更方便。
- en: FlowType.js enhances our headers and body text while maintaining a good level
    of legibility.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: FlowType.js增强了我们的标题和正文文本，同时保持了良好的可读性水平。
- en: Now, an important part of RWD is (believe it or not) doing things like we did
    many, many years ago. In the next chapter, we're going to keep things simple and
    we're going to talk about RWD in e-mail.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，RWD的一个重要部分是（信不信由你）做一些我们多年前做过的事情。在下一章中，我们将保持简单，讨论电子邮件中的RWD。
- en: Time to go back in time!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候回到过去了！
