- en: JavaScript and SVG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript和SVG
- en: You've learned quite a bit in this book so far about SVG. You've spent a lot
    of time looking at the details of the SVG specification and the different ways
    in which SVG can interact with CSS and HTML. Hopefully, it's been as interesting
    for you as it is for me.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经在本书中学到了很多关于SVG的知识。您花了很多时间研究SVG规范的细节，以及SVG与CSS和HTML交互的不同方式。希望对您来说和对我一样有趣。
- en: As interesting as it has all been, it's *this* chapter where we'll put *all *the
    tools together to really unlock the power of SVG. Adding JavaScript to the mix
    opens up a huge number of new possibilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一切都很有趣，但正是在这一章中，我们将把所有工具整合在一起，真正释放SVG的力量。将JavaScript添加到其中会开启大量新的可能性。
- en: Granted, there are many web developers and designers who will never do animation,
    dynamic visualizations, or other interactive work with SVG. For them, getting
    a full understanding of the way that SVG itself works as markup and how it fits
    in with other static web technologies is incredibly valuable. This is especially
    true of the intersection between SVG and CSS that we just learned about in detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定，有许多网页开发人员和设计师永远不会使用SVG进行动画、动态可视化或其他交互式工作。对于他们来说，全面了解SVG本身作为标记的工作方式以及它如何与其他静态网页技术结合是非常有价值的。这在我们刚刚详细了解的SVG和CSS的交集中尤为重要。
- en: That said, the most exciting thing about SVG is how easily it works with JavaScript
    to enhance the interactivity of your site. All of these open web technologies
    are designed to work together in ways that create something greater than the sum
    of the individual specifications. Even though there are separate experts working
    on all of these various technologies, they do so out in the open (for the most
    part) and are, generally, part of larger organizations such as Microsoft, Google,
    or Mozilla and therefore have a real desire to make sure that these technologies
    work together in the best possible way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，SVG最令人兴奋的是它如何轻松地与JavaScript一起工作，以增强您网站的交互性。所有这些开放网络技术都旨在以创造超越个别规范总和的方式相互配合。尽管有专门的专家在所有这些不同的技术上工作，但他们大多数情况下是公开的，并且通常是作为微软、谷歌或Mozilla等更大组织的一部分，因此他们真正希望确保这些技术以最佳方式相互配合。
- en: The intersection of SVG and JavaScript is definitely one such case.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SVG和JavaScript的交集绝对是这样一个案例。
- en: In this chapter, we'll learn about the low-level interface between JavaScript
    and SVG. This includes the DOM interface to SVG. This is important stuff, even
    though we're also going to learn about libraries and frameworks for working with
    SVG. Even if you've been doing web development for a while and are familiar with
    JavaScript and the DOM, the differences between the regular HTML DOM and the interface
    to SVG elements is important. If you're not so familiar with raw DOM manipulations
    (and many developers who started in the jQuery era and later are not), then this
    chapter will give you a whole set of useful skills.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习JavaScript和SVG之间的低级接口。这包括SVG的DOM接口。这是重要的内容，尽管我们也将学习使用SVG的库和框架。即使您已经从事网页开发一段时间，并熟悉JavaScript和DOM，了解常规HTML
    DOM和SVG元素接口之间的差异也是重要的。如果您对原始DOM操作不太熟悉（许多在jQuery时代及以后开始的开发人员并不熟悉），那么本章将为您提供一整套有用的技能。
- en: 'In this chapter, we''ll learn about the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The basic DOM interface to SVG-basic accessing and manipulating SVG elements
    in JavaScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG基本DOM接口-在JavaScript中访问和操作SVG元素
- en: SVG-specific DOM interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG特定的DOM接口
- en: Working with SVG and CSS dynamically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态处理SVG和CSS
- en: JavaScript Versions and tools
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript版本和工具
- en: Before we get into the code, I think it's important to go over different JavaScript
    Versions and how they'll be used in the book. I'd also like to go over how I'll
    present examples that require tooling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我认为重要的是了解不同的JavaScript版本以及它们在本书中的使用方式。我还想介绍一下我将如何呈现需要工具的示例。
- en: JavaScript Versions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript版本
- en: As you may be aware, there's been a lot of work over the past few years around
    evolving the JavaScript programming language. Some of this work is really, really
    great. So great, in fact, that the dominant libraries and frameworks on the web
    right now are idiomatically written in versions and variations of JavaScript that
    aren't universally available in web browsers. Working in bleeding-edge versions
    of the language, including framework-specific extensions, is possible because
    of the use of a transpiler ([https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them)),
    a piece of software that takes software code written in one language (or in this
    case, a version of a language) and outputs code in another language (in this case
    an older, fully supported version of the language). This transpilation step allows
    us to write our applications in whatever flavor of JavaScript we prefer and then
    convert it into browser-standard JavaScript that can run anywhere.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在过去几年中，围绕JavaScript编程语言的发展进行了大量工作。其中一些工作确实非常出色。事实上，目前网络上主要的库和框架都是用不同版本和变体的JavaScript写成的，这些JavaScript并不是在所有网络浏览器中都通用。使用最新版本的语言，包括特定于框架的扩展，是可能的，因为使用了转译器（[https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them)），这是一种软件，它将用一种语言（或在本例中是语言的一个版本）编写的软件代码转换为另一种语言（在本例中是语言的一个较旧但完全支持的版本）。这种转译步骤使我们能够用我们喜欢的JavaScript风格编写应用程序，然后将其转换为可以在任何地方运行的浏览器标准JavaScript。
- en: This section outlines the different Versions of JavaScript you will encounter
    in this book. The next section will talk a little bit about how we'll present
    the tooling required to use a transpiler in order to make your bleeding-edge code
    run in common web browsers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了您将在本书中遇到的不同JavaScript版本。下一节将简要介绍我们将如何呈现所需的工具，以使用转译器使您的最新代码在常见的网络浏览器中运行。
- en: As a note, this is the broadest possible introduction to this topic. Additional
    details, as they arise, will be covered in the course of the book, but even that
    will only scratch the surface of this far-ranging topic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这是对这个主题的最广泛的介绍。随着情况的出现，书中将涵盖更多细节，但即使如此，也只是触及了这个广泛主题的表面。
- en: While I have called and will continue to call the language JavaScript throughout
    the book, that trademarked name (trademarked by Oracle, which got the trademark
    from Sun Microsystems, who in turn got the trademark from Netscape) is not the
    official name of the language. The language is officially called **ECMAScript**,
    based on Ecma ([https://www.ecma-international.org/](https://www.ecma-international.org/)),
    the organization which hosts the standards body that writes the specification.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我在整本书中都称呼并将继续称呼这种语言为 JavaScript，但这个商标名称（由 Oracle 商标，后者从 Sun Microsystems 获得商标，后者又从
    Netscape 获得商标）并不是这种语言的官方名称。这种语言的官方名称是 **ECMAScript**，基于 Ecma ([https://www.ecma-international.org/](https://www.ecma-international.org/))，这个组织主持编写规范的标准机构。
- en: ECMAScript 5
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 5
- en: '**ECMAScript 5** (**ES5**) is the most fully supported version of the language
    in browsers today and is the version that is targeted by transpilers because it
    will run anywhere. Standardized in 2009, as of the time of writing this version
    has full support in over 90% of browsers out there and has partial support in
    around 97%. With the addition of ES5 polyfills ([https://github.com/es-shims/es5-shim](https://github.com/es-shims/es5-shim))
    you can get near-universal coverage targeting ES5\. Some code, specifically the
    Angular 1 and jQuery sections in [Chapter 7](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml),
    *Common JavaScript Libraries and SVG*, will be written directly as ES5\. This
    is because most people will be familiar with Angular 1 and jQuery as ES5 style
    interfaces. The comment at the top of the file, as follows, indicates this version
    is being used:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECMAScript 5** (**ES5**) 是当今浏览器中最完全支持的语言版本，也是转译器的目标版本，因为它可以在任何地方运行。标准化于2009年，截至撰写本文时，这个版本在超过90%的浏览器中得到了全面支持，在约97%的浏览器中得到了部分支持。通过添加
    ES5 polyfills ([https://github.com/es-shims/es5-shim](https://github.com/es-shims/es5-shim))，你可以几乎实现对
    ES5 的普遍覆盖。一些代码，特别是[第7章](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml)中的 Angular
    1 和 jQuery 部分，*常见的 JavaScript 库和 SVG*，将直接以 ES5 编写。这是因为大多数人对 Angular 1 和 jQuery
    都是以 ES5 风格的接口熟悉。文件顶部的注释如下所示，表示正在使用这个版本：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ECMAScript 2015
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 2015
- en: ECMAScript 2015 was formerly known as **ECMAScript 6** (**ES6**). This version,
    finalized in 2015, is the version making its way into browsers now. It's got partial
    support across all the latest versions of the major browsers (Edge, Firefox, Chrome,
    and Safari.) In general, the JavaScript code written in this book, with the exception
    of the previously mentioned examples, will use ES6\. With the exception of the
    *React* section, which uses more advanced features and some React-specific extensions,
    the features used are all supported in the latest Versions of Chrome, Edge, and
    Firefox. So if you're using one of those browsers, you won't have to actually
    run a transpiler for these samples. If you're looking to move this code into production,
    that's another story, which is outside the scope of this book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015 以前被称为 **ECMAScript 6** (**ES6**)。这个版本于2015年完成，现在正在进入浏览器。它在所有主要浏览器的最新版本（Edge、Firefox、Chrome
    和 Safari）中都有部分支持。一般来说，本书中编写的 JavaScript 代码（除了前面提到的例子）将使用 ES6。除了 *React* 部分，它使用了更高级的功能和一些
    React 特定的扩展，其他使用的功能都在最新版本的 Chrome、Edge 和 Firefox 中得到支持。因此，如果你使用这些浏览器之一，你不必为这些示例实际运行转译器。如果你想将这些代码投入生产，那就是另一回事，超出了本书的范围。
- en: 'The comment at the top of the file, as follows, indicates this version is being
    used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部的注释如下所示，表示正在使用这个版本：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: TypeScript
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript
- en: The Angular ([https://angular.io/](https://angular.io/)) section will be written
    in TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/)).
    Typescript is a superset of JavaScript that adds certain optional features, most
    notably static typing ([https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html)),
    through the use of type annotations. TypeScript is used by the Angular team to
    add some core features to the development environment for Angular. Because not
    everyone has experience in TypeScript, TypeScript language features in the examples
    will be pointed out, to keep confusion to a minimum.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Angular ([https://angular.io/](https://angular.io/)) 部分将使用 TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    编写。TypeScript 是 JavaScript 的一个超集，它通过类型注解添加了某些可选功能，最显著的是静态类型化。TypeScript 被 Angular
    团队用来为开发环境添加一些核心功能。因为并非每个人都有 TypeScript 的经验，所以示例中的 TypeScript 语言特性将被指出，以尽量减少混淆。
- en: The good news on that front is that once the script is up and running, the body
    of any Angular component can be written as plain old JavaScript.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面的好消息是，一旦脚本启动并运行，任何 Angular 组件的主体都可以用普通的旧 JavaScript 编写。
- en: Tooling
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具化
- en: Up until this point, we haven't had to do much in terms of tooling. Almost all
    the examples will work when served off the local file system, as written.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 直到目前为止，我们在工具方面没有做太多工作。几乎所有的例子在本地文件系统上提供服务时都可以正常工作。
- en: That won't necessarily be the case going forward. In the simplest case, any
    examples that require making HTTP requests, for example, will rely on the node
    package serve ([https://www.npmjs.com/package/serve](https://www.npmjs.com/package/serve)) in
    order to set up a simple local server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 未来情况可能不会如此。在最简单的情况下，例如任何需要进行 HTTP 请求的示例，都将依赖于 node 包 serve ([https://www.npmjs.com/package/serve](https://www.npmjs.com/package/serve))
    来建立一个简单的本地服务器。
- en: The React and Angular examples, in particular, require even more extensive tooling.
    At a minimum you will need to have Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
    installed and you'll have to follow a few steps to get set up. In the end you'll
    have a local web server running, and several processes which will watch for changes
    to your JavaScript or Typescript files. When you make changes, the related processes
    will catch the changes and perform actions (transpiling the code from Typescript
    to JavaScript, for example) to ensure that the code is updated on the local server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是React和Angular示例需要更广泛的工具。至少，您需要安装Node.js（[https://nodejs.org/en/](https://nodejs.org/en/)），并且您需要按照一些步骤进行设置。最终，您将运行一个本地Web服务器，并且将有几个进程监视您的JavaScript或Typescript文件的更改。当您进行更改时，相关进程将捕捉更改并执行操作（例如将代码从Typescript转换为JavaScript）以确保代码在本地服务器上更新。
- en: There'll be instructions for getting up and running with the code samples in
    each of the respective sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个相应部分都将提供有关如何使用代码示例的说明。
- en: Additionally, remember that all of the working code is available on GitHub ([https://github.com/roblarsen/mastering-svg-code](https://github.com/roblarsen/mastering-svg-code)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请记住所有工作代码都可以在GitHub上找到（[https://github.com/roblarsen/mastering-svg-code](https://github.com/roblarsen/mastering-svg-code)）。
- en: After all of that, let's look at some code that doesn't require anything other
    than a newer web browser to run locally.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，让我们看一些不需要除了较新的Web浏览器之外的任何东西就可以在本地运行的代码。
- en: The DOM interface to SVG
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG的DOM接口
- en: The DOM is an API for accessing, updating, creating, and deleting the elements,
    properties, and content of XML-based documents. This includes documents in related,
    but not strict XML, grammars such as the latest HTML specification.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: DOM是用于访问、更新、创建和删除基于XML的文档的元素、属性和内容的API。这包括相关但不严格符合XML语法的文档，例如最新的HTML规范。
- en: For the average developer, doing a ton of pure DOM manipulation is pretty rare
    these days. jQuery took care of that many years ago and it's never come back into
    fashion. I can say from experience that it's still useful to know how DOM manipulation
    works under the hood so that you can code yourself out of a bind when you run
    into something the library or framework you're using doesn't provide.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通开发人员来说，进行大量的纯DOM操作在今天是相当罕见的。多年前jQuery就解决了这个问题，而且从来没有再流行起来。我可以从经验中说，了解DOM操作的内部工作原理仍然很有用，这样当您遇到库或框架无法提供的东西时，您就可以自己编写代码来解决问题。
- en: It also illustrates the possibilities of what's available when working with
    different technologies. It's one thing to have access to something that a library
    or framework author finds interesting, but if you're familiar with the underlying
    code, you're only limited by your imagination and what's available in your target
    browsers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这也说明了在使用不同技术时可用的可能性。拥有对图书馆或框架作者感兴趣的东西的访问权限是一回事，但如果你熟悉底层代码，你只受你的想象力和目标浏览器中可用的东西的限制。
- en: The SVG DOM builds on the Dom Level 2 Specification ([https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html](https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html)). It
    supports most of what anyone with DOM and HTML experience would expect and adds
    several sets of SVG-specific interfaces that you can use to manipulate SVG documents.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SVG DOM基于Dom Level 2规范（[https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html](https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html)）。它支持大多数具有DOM和HTML经验的人所期望的内容，并添加了几组SVG特定接口，您可以使用这些接口来操作SVG文档。
- en: This section will go through the basic classes of SVG-specific DOM methods and
    illustrate their usage. Unless you're writing a library, you won't need to know
    everything about these lower-level tools. This chapter will serve as an introduction
    so you have a good introduction to them and know what to look for.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍SVG特定DOM方法的基本类，并说明它们的用法。除非您正在编写库，否则您不需要了解这些低级工具的所有内容。本章将作为一个介绍，让您对它们有一个良好的了解，并知道要寻找什么。
- en: Initial exploration
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始探索
- en: To get started, let's look at some DOM methods and properties that are available
    on an arbitrary (and common) SVG element, `rect`. To do this, you might go to
    the `SVGRectElement` element documentation ([https://developer.mozilla.org/en-US/docs/Web/API/SVGRectElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGRectElement)).
    That would be a good option.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们看一些DOM方法和属性，这些方法和属性可用于任意（常见的）SVG元素`rect`。为此，您可以查看`SVGRectElement`元素文档（[https://developer.mozilla.org/en-US/docs/Web/API/SVGRectElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGRectElement)）。那将是一个不错的选择。
- en: 'You might also inspect a `rect` element directly, using the developer tools
    of your browser of choice. That will look something like the following screenshot. 
    This will be the way many of you interface with the available methods and properties
    of SVG elements:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接检查`rect`元素，使用您选择的浏览器的开发人员工具。这将看起来像以下的屏幕截图。这将是您许多人接触SVG元素的可用方法和属性的方式：
- en: '![](img/0c5d8309-264d-45b1-bcb5-2ed63a3fdbd3.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c5d8309-264d-45b1-bcb5-2ed63a3fdbd3.png)'
- en: While these are common, you could also do something like the following, which
    is a nice step towards scripting SVG.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是常见的，但您也可以做一些像以下的事情，这是向脚本化SVG迈出的一大步。
- en: In this code sample we get access to the `rect` element with `document.getElementById` and
    store it in a variable, `rect`. `document.getElementById` is one of the common
    DOM accessor methods that you'll use to access DOM elements both in SVG and in
    HTML itself. You'll see more examples of its use throughout the chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们使用`document.getElementById`访问`rect`元素，并将其存储在变量`rect`中。`document.getElementById`是您将用于访问SVG和HTML本身中的DOM元素的常见DOM访问器方法之一。您将在本章中看到其更多用法示例。
- en: 'Following that, we then loop through the properties of the `rect` loop using
    a simple `for...in` loop, writing the variables and properties out to the console
    using bracket notation where `prop` is the name of a property or method on the
    `rect` element:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过简单的`for...in`循环遍历`rect`循环的属性，使用方括号表示法将变量和属性写入控制台，其中`prop`是`rect`元素上的属性或方法的名称：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output is shown in the following screenshot. You'll notice that the first
    few properties and methods are all SVG-specific. This list continues on for several
    screens past the ones in the following screenshot, but the first ones in the list
    are all SVG specific. This is because the `for...in` loop starts with the innermost
    properties of the `SVGRectElement` and then works its way up the prototype chain
    to the properties of the `SVGGeometryElement`, all the way up to `SVGElement`,
    `Element`, and `Node` (the most generic DOM interface). Of these properties, some
    are very obvious and immediately useful such as `x`, `y`, `width`, and `height`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下截图所示。您会注意到前几个属性和方法都是特定于SVG的。这个列表在下面的几个屏幕上继续，但列表中的第一个都是SVG特定的。这是因为`for...in`循环从`SVGRectElement`的最内部属性开始，然后沿着原型链向上工作，直到`SVGElement`、`Element`和`Node`的属性（最通用的DOM接口）。其中一些属性非常明显和立即有用，比如`x`、`y`、`width`和`height`。
- en: 'Others might not be as obviously useful, such as `getBBox` or `isPointInFill`
    (although you might be able to guess what they can do), but you can start to see
    that there''s a lot available for you to work with when you have access to an
    element:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能不那么明显有用，比如`getBBox`或`isPointInFill`（尽管您可能能够猜到它们的作用），但您可以开始看到当您访问一个元素时，有很多可用的内容：
- en: '![](img/8e8c0200-55c1-4a7d-bc41-ed89c3724924.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e8c0200-55c1-4a7d-bc41-ed89c3724924.png)'
- en: Taking that basic foundation and the idea of exploration, let's start to build
    a small application that lets you manipulate an SVG canvas in simple ways.  The
    next section will focus on building out a small tool, step-by-step, that will
    allow you to add simple SVG elements to an SVG canvas (`text`, `rect`, and `circle`)
    and manipulate them in different ways. This small demo will be easy to digest
    and will demonstrate a number of different ways to interact with SVG.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个基本的基础和探索的想法，让我们开始构建一个小型应用程序，让您以简单的方式操作SVG画布。接下来的部分将重点介绍逐步构建一个小工具，允许您向SVG画布添加简单的SVG元素（`text`、`rect`和`circle`）并以不同的方式操作它们。这个小演示将很容易理解，并将演示与SVG交互的许多不同方式。
- en: The SVG DOM manipulator
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG DOM操作器
- en: The app we're going to build will allow you to click and add three different
    kinds of SVG element to an SVG canvas. The interface will allow you to click on
    the item you want to add (`rect`, `circle`, or `text`) and then you will be able
    to click on the canvas and add that element to the screen at those particular
    `(x,y)` coordinates. With that element selected, you will then be able to edit
    it by changing several available properties.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的应用程序将允许您点击并向SVG画布添加三种不同类型的SVG元素。界面将允许您点击要添加的项目（`rect`、`circle`或`text`），然后您将能够点击画布并将该元素添加到特定的`(x,y)`坐标处。选择该元素后，您将能够通过更改几个可用的属性来编辑它。
- en: This example will use Bootstrap to simplify laying out the different form fields
    and to create a simple modal to edit the properties. Because of that, jQuery will
    also be included, although, for this version of the demo at least, jQuery interactions
    will be kept to a minimum; we'll focus on raw DOM manipulations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将使用Bootstrap来简化布局不同的表单字段，并创建一个简单的模态框来编辑属性。因此，jQuery也将被包含在内，尽管至少在这个演示版本中，jQuery的交互将被保持在最低限度；我们将专注于原始的DOM操作。
- en: 'When it''s complete, it will look as shown in the following screenshot, which
    shows the SVG canvas at the top of the screen, bordered in black. After that there
    are simple instructions and then at the bottom of the screen there are three buttons
    that allow you to select a rectangle, a circle, or a text element to add to the
    canvas:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，它将如下截图所示，显示了屏幕顶部的SVG画布，用黑色边框。之后是简单的说明，然后在屏幕底部有三个按钮，允许您选择要添加到画布的矩形、圆形或文本元素：
- en: '![](img/3719fc64-62cd-404d-9134-3b06ef2966b6.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3719fc64-62cd-404d-9134-3b06ef2966b6.png)'
- en: This time, instead of adding the entire code sample at once and explaining the
    whole thing, as we've been doing so far in the book, we are going to build the
    sample and discuss each code block as we go through the example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，与其一次性添加整个代码示例并解释整个内容，不如我们在示例中构建并讨论每个代码块。
- en: Let's start with the skeleton of the page. This initial state doesn't have any
    JavaScript in it at all, but it does provide us with some structure and some tools
    we'll use later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从页面的骨架开始。这个初始状态完全没有任何JavaScript，但它为我们提供了一些结构和一些稍后会用到的工具。
- en: In the `head` we link to Bootstrap from a **Content Delivery Network** (**CDN**),
    we link to the Raleway font from Google fonts and then set up some basic styles
    for our page, adding Raleway as the body font, putting a border around our canvas
    SVG element, and then changing the color of our SVG sprite buttons.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`head`中，我们从**内容传送网络**（**CDN**）链接到Bootstrap，从Google字体链接到Raleway字体，然后为我们的页面设置一些基本样式，将Raleway添加为正文字体，给我们的画布SVG元素加上边框，然后改变SVG精灵按钮的颜色。
- en: In the body, we set the page up to be responsive, using Bootstrap's utility
    classes to create a fluid layout that fills the entire screen width. The SVG element
    will scale to fit this Bootstrap container.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在body中，我们使用Bootstrap的实用类来创建一个填满整个屏幕宽度的流体布局。SVG元素将缩放以适应这个Bootstrap容器。
- en: 'The layout has two sections: the target SVG element, where the drawings will
    happen, and a second section for the UI controls. The UI controls, for now, are
    just three `button` elements wrapped around SVG sprites.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 布局分为两部分：目标SVG元素，用于绘图的地方，和第二部分用于UI控件。目前，UI控件只是包裹在SVG精灵周围的三个`button`元素。
- en: Next, we have a hidden SVG element featuring a series of `symbol` elements,
    defining our sprites.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个隐藏的SVG元素，其中包含一系列定义了我们精灵的`symbol`元素。
- en: 'Finally, we link out to some third party JavaScript in order to wire up some
    of the Bootstrap functionality:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们链接到一些第三方JavaScript，以便连接一些Bootstrap功能：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we've taken a look at the basics of the page, let's start to add some
    interactivity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了页面的基础知识，让我们开始添加一些交互性。
- en: Although we have jQuery on the page, I'm not going to use it for any of the
    DOM manipulations so that we can look at the raw interactions. We will look at
    jQuery and SVG in [Chapter 7](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml), *Common
    JavaScript Libraries and SVG*, so don't fret.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然页面上有jQuery，但我不打算在任何DOM操作中使用它，这样我们就可以看一下原始的交互。我们将在[第7章](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml)中看到jQuery和SVG，所以不要担心。
- en: The first thing we'll do is create a few event handlers to handle the different
    interactions. The first event handlers we'll add are `click` event handlers on
    the buttons. The idea is that you click on the button to load an SVG element onto
    your cursor, and then you click once more to place it on the canvas. This code
    doesn't yet handle adding the element to the SVG canvas, but it does illustrate
    a couple of wrinkles when working with SVG and JavaScript.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一些事件处理程序来处理不同的交互。我们将添加的第一个事件处理程序是按钮上的`click`事件处理程序。想法是你点击按钮将一个SVG元素加载到你的光标上，然后再点击一次将其放置在画布上。这段代码还没有处理将元素添加到SVG画布中，但它确实展示了在处理SVG和JavaScript时的一些问题。
- en: This is an instance where some things you might know from old-school DOM manipulation
    might fail you. If you've been manipulating the HTML DOM directly for any length
    of time, you might be used to working with the `Element.className` property. On
    HTML elements, the `className` property is a `read/write` string that maps to
    the `class` attribute on the HTML element. In that context, you can manipulate
    the string and changes are reflected in the DOM.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，有些你可能从老式DOM操作中知道的东西可能会让你失望。如果你一直在直接操作HTML DOM，你可能习惯于使用`Element.className`属性。在HTML元素上，`className`属性是一个`读/写`字符串，对应于HTML元素上的`class`属性。在这种情况下，你可以操作字符串，改变会反映在DOM中。
- en: The DOM interface `SVGElement` does have a `className` property, but it isn't
    a simple string. Its an `SVGAnimatedString` property with two string values, `AnimVal`
    and `BaseVal`. Because of that extra layer, and because the interface for my chosen
    alternative is modern and much clearer, I decided to use the `SVGElement.classList`
    property to manipulate the CSS classes instead. `classList` is a structured interface
    to the CSS classes on an element. Accessed directly, `classList` is `readonly`,
    but there are methods available to query and manipulate the list of classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: DOM接口`SVGElement`确实有一个`className`属性，但它不是一个简单的字符串。它是一个`SVGAnimatedString`属性，有两个字符串值，`AnimVal`和`BaseVal`。因为有了这一层额外的东西，而且因为我选择的替代接口现代化且更清晰，我决定使用`SVGElement.classList`属性来操作CSS类。`classList`是元素上CSS类的结构化接口。直接访问时，`classList`是`只读`的，但有可用的方法来查询和操作类列表。
- en: Let's dive into this code to see how that works.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这段代码是如何工作的。
- en: We start the whole thing by adding a function that fires on the `DOMContentLoaded`
    event. This event fires a function when the DOM has been read by the browser.
    This is the safest place to start to manipulate the DOM if you're looking to use
    an element on the page when the markup is read by the browser. Then we set two
    local references, one to `document` via the variable `doc` and the other to the
    SVG canvas itself, via the `canvas` variable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一个在`DOMContentLoaded`事件上触发的函数来开始整个过程。这个事件在DOM被浏览器读取时触发一个函数。如果你想在浏览器读取标记时在页面上使用一个元素，这是开始操作DOM的最安全的地方。然后我们设置了两个本地引用，一个是通过变量`doc`引用`document`，另一个是通过`canvas`变量引用SVG画布本身。
- en: We create local references to DOM properties and elements because DOM lookups
    can be slow. Saving a local reference to DOM properties and elements is a common
    performance pattern.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建本地引用DOM属性和元素，因为DOM查找可能很慢。保存本地引用DOM属性和元素是一种常见的性能模式。
- en: Then we get the collection of buttons, using `querySelectorAll`, and loop through
    each of them in turn, adding a click event handler to each button. Inside the
    body of the click event handlers, we initially set two local references, `classlist` as
    a reference to the target SVG element's `classList`, and a `const`, referencing
    the `type` of element that has been requested. This type is being passed in via
    a `data-*` attribute on the `use` element. `data-*` is a method for storing arbitrary
    data on a DOM element.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`querySelectorAll`获取按钮的集合，并依次循环遍历每个按钮，为每个按钮添加一个点击事件处理程序。在点击事件处理程序的主体中，我们最初设置了两个本地引用，`classlist`是指向目标SVG元素的`classList`的引用，还有一个`const`，引用了被请求的元素的`type`。这个类型是通过`use`元素上的`data-*`属性传递的。`data-*`是一种在DOM元素上存储任意数据的方法。
- en: 'We then use that type and a simple `if...else` statement to ensure that the
    proper classes are on the target SVG element. In the first `if` block, we test
    to see if the current classes match the current type and that it has the `active`
    class. If they match the current type and the element has the active class, we
    remove the classes. This action is for cases where we''ve already loaded the cursor
    with a specific type and want to reset it by clicking on the same button. The
    next block checks to see if the cursor is active but isn''t the currently selected
    type. In that case, we remove all of the type classes to ensure we clear the selected
    type, and then add the currently selected one back in. In the final block, the
    cursor isn''t active, so we just add the `active` class and the type class, loading
    up the cursor:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用该类型和一个简单的`if...else`语句来确保目标SVG元素上有适当的类。在第一个`if`块中，我们测试当前类是否与当前类型匹配，并且它具有`active`类。如果它们匹配当前类型并且元素具有活动类，我们将删除这些类。这个动作是为了在我们已经用特定类型加载了光标并且想要通过单击相同的按钮来重置它的情况。下一个块检查光标是否处于活动状态但不是当前选定的类型。在这种情况下，我们删除所有类型类以确保清除所选类型，然后再添加当前选定的类型。在最后一个块中，光标不活动，所以我们只是添加`active`类和类型类，加载光标：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The CSS for the active cursors is as follows. In the new CSS we simply pass
    a URL reference to a PNG to the cursor property for each of the active cursors:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 活动光标的CSS如下。在新的CSS中，我们简单地为每个活动光标的光标属性传递了一个PNG的URL引用：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A cursor loaded with a circle element looks like the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 加载了一个圆形元素的光标如下截图所示：
- en: '![](img/c46bf8db-e534-4b6b-be7d-fbef9eb946cc.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c46bf8db-e534-4b6b-be7d-fbef9eb946cc.png)'
- en: Next up we'll go through the process of adding elements on click to the target
    SVG element.  The function `add` is where the magic happens. In it we first set
    a number of variables. We start with five consts. The first is a reference to
    the `document`, stored as `doc`, the second is a reference to the target SVG element,
    stored as `canvas`, the third is the target SVG's `classList`, stored as `classes`,
    then there's a reference to the SVG namespace URL, stored as **namespace** (**NS**),
    and finally there's an `SVGpoint`, created and stored as `point`. The first three
    should be straightforward; the usage of the `NS` variable will be explained shortly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐步介绍在单击目标SVG元素时添加元素的过程。函数`add`是魔术发生的地方。首先我们设置了一些变量。我们首先使用五个常量。第一个是对`document`的引用，存储为`doc`，第二个是对目标SVG元素的引用，存储为`canvas`，第三个是目标SVG的`classList`，存储为`classes`，然后是SVG命名空间URL的引用，存储为**namespace**（**NS**），最后是创建并存储为`point`的`SVGpoint`。前三个应该很简单；`NS`变量的使用将很快解释。
- en: '`point` is used immediately. This is one major difference between regular DOM
    manipulation and working with the SVG DOM, so let''s take a look at what''s going
    on there. The basic purpose of this code is to transform the screen coordinates
    from the click event to the proper (potentially transformed or scaled) coordinates
    inside the SVG element. If you''ve been paying attention to the way that SVG scales,
    in general, and the way that transforms work with SVG elements, you should be
    able to see how, depending on the way the document is set up, the screen pixels
    may or may not match up to the user units within the  SVG document. Since we''ve
    got a static `viewbox` set to 500 user units and an SVG element that scales to
    fit the entire page, we are going to need to use some SVG tools to access the
    current transformation matrix and apply that matrix to the point of the click.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`point`立即被使用。这是常规DOM操作和处理SVG DOM之间的一个主要区别，所以让我们来看看发生了什么。这段代码的基本目的是将点击事件的屏幕坐标转换为SVG元素内的正确（可能是变换或缩放后的）坐标。如果你一直在关注SVG的一般缩放方式以及变换如何与SVG元素一起工作的方式，你应该能够看到，根据文档的设置方式，屏幕像素可能与SVG文档中的用户单位匹配或不匹配。由于我们有一个静态的`viewbox`设置为500个用户单位，并且一个SVG元素被缩放以适应整个页面，我们需要使用一些SVG工具来访问当前的变换矩阵，并将该矩阵应用到点击的点上。'
- en: To do this, we have a couple of steps that we need to go through. `point` is
    created via `createSVGPoint`, which is a method that returns a point in the current
    SVG coordinate system. The initial return value has two properties, `x` and `y`,
    set to zero. We immediately populate that variable with the mouse coordinates
    of the click event. These are available as part of the event object that's automatically
    passed in as an argument to the function as `event.offsetX` and  `event.offsetY`. Next
    we use the `getScreenCTM()` method to get the inverse of the **Current user unit
    Transformation Matrix** (**CTM**). The CTM represents the transformation steps
    required to convert from the screen coordinate system to the one in the SVG document.
    Calling the `inverse()` method returns the steps required to move from the SVG
    user unit coordinate system to the one on the screen. Applying that matrix to
    the `(x,y)` points defined in point, therefore, shifts the points to the correct
    place in the SVG document.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要经历一些步骤。`point`是通过`createSVGPoint`创建的，这是一个返回当前SVG坐标系中点的方法。初始返回值有两个属性，`x`和`y`，都设置为零。我们立即用点击事件的鼠标坐标填充该变量。这些坐标作为事件对象的一部分自动传递给函数作为`event.offsetX`和`event.offsetY`。接下来，我们使用`getScreenCTM()`方法来获取**当前用户单位变换矩阵**（**CTM**）的逆。CTM表示从屏幕坐标系转换到SVG文档中所需的变换步骤。调用`inverse()`方法返回从SVG用户单位坐标系转换到屏幕坐标系所需的步骤。因此，将该矩阵应用到point中定义的`(x,y)`点，将这些点移动到SVG文档中的正确位置。
- en: Finally, we create an empty variable, `elem`, which is going to be filled later
    with the element we're looking to add to the document.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个空变量`elem`，稍后将用要添加到文档中的元素填充。
- en: Next, we actually create the element.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实际创建元素。
- en: 'If the class active is on the target SVG element, then we''re going to add
    an element to it. No matter which type of element we''re trying to create, the
    pattern is the same:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标SVG元素上有活动类，那么我们将向其添加一个元素。无论我们要创建哪种类型的元素，模式都是相同的：
- en: We test which type of element is active.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试活动元素的类型。
- en: We create the element.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建元素。
- en: We set a couple of properties on it before adding it to the DOM.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将其添加到DOM之前，我们对其设置了一些属性。
- en: Again, if you're familiar with DOM manipulations, then you'll notice some differences
    here. This is where the `NS` variable comes into play. Since this isn't pure HTML
    and is, in fact, an entirely different document definition, we need to supply
    that namespace in order to create the element properly. So, instead of `document.createElement`,
    we have to use `document.createElementNS` and we pass in a second argument referencing
    the SVG namespace via the `NS` variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你熟悉DOM操作，你会注意到这里有一些不同。这就是`NS`变量发挥作用的地方。由于这不是纯HTML，实际上是一个完全不同的文档定义，我们需要提供该命名空间以正确创建元素。因此，我们不是使用`document.createElement`，而是必须使用`document.createElementNS`，并通过`NS`变量引用SVG命名空间的第二个参数。
- en: Once the element is created, we set the relevant attributes using `elem.setAttribute`.
    For the `rect` we set `x`, `y`, `width`, and `height`. For the `circle` we set
    `r`, `cx`, and `cy`. For the `text` element we set `x`, `y` and then set the text
    content using `elem.textContent`, which is a new wrinkle if you're used to updating
    text and/or HTML nodes with `innerHTML`. As mentioned previously, there is no
    `innerHTML` of an SVG element.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 元素创建后，我们使用`elem.setAttribute`设置相关属性。对于`rect`，我们设置`x`、`y`、`width`和`height`。对于`circle`，我们设置`r`、`cx`和`cy`。对于`text`元素，我们设置`x`、`y`，然后使用`elem.textContent`设置文本内容，如果你习惯使用`innerHTML`更新文本和/或HTML节点，这是一个新的变化。正如之前提到的，SVG元素没有`innerHTML`。
- en: 'Once the `elem` is defined with the baseline attributes, we insert it into
    the document using the `appendChild` method. Finally, we remove the `"active"`
    class from the target SVG element, which will prevent further elements being added
    accidentally:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`elem`使用基线属性定义，我们就使用`appendChild`方法将其插入到文档中。最后，我们从目标SVG元素中删除`"active"`类，这将防止意外添加更多元素：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a newly added square element on the SVG canvas as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SVG画布上新添加的正方形元素如下：
- en: '![](img/2089ef8b-202f-45e8-8501-c7e7e74fdf34.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2089ef8b-202f-45e8-8501-c7e7e74fdf34.png)'
- en: While we now have events bound to the document and can add elements to the screen,
    this demo isn't done just yet. What we need to do to finish this off is to allow
    the user to update the elements that have been placed on the target SVG element.
    While we could do that in increasingly complicated ways (clicking and dragging,
    drawing new elements with the mouse or with your finger, copying and pasting elements)
    for the sake of this demo, we're simply going to allow the user to click on the
    SVG element and open up a small Bootstrap modal which will allow them to edit
    basic SVG properties. This will illustrate manipulating the underlying DOM properties
    without getting into too much depth on any one set of interactions. This is especially
    key since many of the most complicated interactions are better handled by a separate
    library or framework anyway. As you'll see, doing this stuff entirely by hand
    can be cumbersome even in the best of circumstances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在已经将事件绑定到文档并可以向屏幕添加元素，但这个演示还没有完成。我们需要做的是允许用户更新放置在目标SVG元素上的元素。虽然我们可以以越来越复杂的方式来做到这一点（点击和拖动，用鼠标或手指绘制新元素，复制和粘贴元素），但为了这个演示，我们只是允许用户点击SVG元素并打开一个小的Bootstrap模态框，让他们可以编辑基本的SVG属性。这将说明在不深入研究任何一组交互的情况下操纵底层DOM属性。这是特别重要的，因为许多最复杂的交互都最好由单独的库或框架处理。正如你将看到的，即使在最好的情况下，完全手工完成这些工作也可能很麻烦。
- en: 'So let''s get that started. The first thing we''ll do is update the `add` function
    with one line. This line adds the click event handler to `elem`, which will fire
    the `edit` function. So, looking at the bottom of the `add` function, we can see
    the new code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始吧。我们要做的第一件事是更新`add`函数的一行。这一行将点击事件处理程序添加到`elem`，这将触发`edit`函数。因此，看一下`add`函数底部，我们可以看到新代码：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we look at the edit function, let's look at the modal markup. If you've
    worked with Bootstrap before, this should be familiar. If not, the basics are
    pretty straightforward. The pattern of the Bootstrap `modal` wrapper class and `modal-` classes
    adds the Bootstrap modal layout, and the classes also indicate that the Bootstrap
    JavaScript should bind Bootstrap-specific events to this particular element. We'll
    see one of these events in action shortly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看编辑功能之前，让我们先看一下模态框标记。如果你以前使用过Bootstrap，这应该很熟悉。如果没有，基本知识是相当简单的。Bootstrap `modal`包装器类和`modal-`类的模式添加了Bootstrap模态框布局，并且这些类还指示Bootstrap
    JavaScript应该将Bootstrap特定的事件绑定到这个特定元素。我们很快将看到其中一个事件的作用。
- en: Each of the modals has an `id` to reference from our functions as well as specific
    form fields required to update the selected elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模态框都有一个`id`，以便从我们的函数中引用，以及更新所选元素所需的特定表单字段。
- en: The first modal is used to edit the `rect` elements. It has an `input` of type
    `color` to allow the user to choose a new color for the background, two `inputs` of
    type `number` to update the `x` and `y` coordinates, and two `number` `inputs`
    to update the `height` and `width` of the element.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模态框用于编辑`rect`元素。它有一个`color`类型的`input`，允许用户选择新的背景颜色，两个`number`类型的`input`来更新`x`和`y`坐标，以及两个`number`类型的`input`来更新元素的`height`和`width`。
- en: Inputs of type `number` and type `color` are newer, HTML5 input types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`number`和`color`类型的输入是较新的HTML5输入类型。'
- en: The second modal is used to edit the `circle` elements. It provides a `color`
    `input` to change the background color, two `number` `inputs` to change the `cx`
    and `cy` attributes, and a final `number` `input` to change the radius of the
    circle.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模态框用于编辑`circle`元素。它提供了一个`color`输入来更改背景颜色，两个`number`输入来更改`cx`和`cy`属性，以及一个最终的`number`输入来更改圆的半径。
- en: 'The final modal is used to edit the `text` elements. It provides a `color`
    `input` to change the color of the text, two `number` `inputs` to change the `x`
    and `y` positions of the element, and a `text` `input` to change the actual text
    of the `text` element:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的模态框用于编辑`text`元素。它提供了一个`color` `input`来改变文本的颜色，两个`number` `inputs`来改变元素的`x`和`y`位置，以及一个`text`
    `input`来改变`text`元素的实际文本：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let's take a look at the `edit` function. Most of the interesting stuff
    here happens based on the `event argument`. `event` has references to all sorts
    of information about the event being fired. `edit` checks the `event.srcElement.nodeName`
    to see what kind of element has been clicked. The function then does three things
    for each of the element types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`edit`函数。这里大部分有趣的事情都是基于`event参数`。`event`引用了有关触发的事件的各种信息。`edit`检查`event.srcElement.nodeName`来查看点击了什么类型的元素。然后，函数对每种元素类型都做三件事。
- en: It opens the correct editing modal using the `$().modal` method called with
    the `"show"` option.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用带有`"show"`选项调用的`$().modal`方法打开正确的编辑模态框。
- en: It stores a reference to the current element using the jQuery `$().data()` method.
    `$().data` allows you to bind arbitrary data to an element. We'll look at more
    jQuery features in [Chapter 7](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml), *Common
    JavaScript Libraries and SVG*, but since we are already using jQuery to get to
    the Bootstrap methods, let's use `$().data()` here for the sake of convenience.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用jQuery的`$().data()`方法存储对当前元素的引用。`$().data`允许您将任意数据绑定到元素上。我们将在[第7章](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml)中查看更多jQuery功能，*常见的JavaScript库和SVG*，但由于我们已经在使用jQuery来获取Bootstrap方法，让我们在这里使用`$().data()`为了方便起见。
- en: It loads up the current values from the clicked element and loads them into
    the form fields. There are multiple instances of this, but for the most part they
    follow the same pattern. The `form` field is referenced via `id` and the value
    is set using the current value accessed by `event.srcElement.getAttribute`. The
    one exception is the text value of the text element that is accessed by the `event.srcElement.textContent`
    attribute.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从单击的元素中加载当前值并将其加载到表单字段中。这有多个实例，但在大多数情况下它们遵循相同的模式。`form`字段通过`id`引用，并使用`event.srcElement.getAttribute`访问的当前值进行设置。唯一的例外是通过`event.srcElement.textContent`属性访问的文本元素的文本值。
- en: 'So, as soon as the element is clicked, the modal is opened and populated with
    the current values ready to be manipulated:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦单击元素，模态框就会打开，并填充当前值，准备进行操作：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is what an opened modal looks like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是打开的模态框的样子：
- en: '![](img/a256e53c-283b-4153-8488-27544cfe6e6b.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a256e53c-283b-4153-8488-27544cfe6e6b.png)'
- en: To capture the changes, we need to add some more event handlers to the document
    and a few more functions to save the data. This is done by adding some click handlers
    to the three modals save buttons and defining three different functions to handle
    the changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获更改，我们需要向文档添加一些更多的事件处理程序和一些更多的函数来保存数据。这是通过向三个模态框保存按钮添加一些点击处理程序，并定义三个不同的函数来处理更改来完成的。
- en: 'As you can see in the next sample, the event handlers are straightforward.
    You get a reference to each of the save buttons with `document.getElementById`,
    and using `addEventListener` add the correct save handler to each of the elements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在下一个示例中所看到的，事件处理程序很简单。您可以使用`document.getElementById`获取每个保存按钮的引用，并使用`addEventListener`将正确的保存处理程序添加到每个元素中：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The various save functions are also pretty straightforward. They all initially
    hide the opened modal using the `$.modal()` method with the `hide` argument passed
    in. After that the function stores a reference to the currently clicked element
    using the get signature of the `$().data()` method and stores it as a local variable
    `elem`. Then, depending on the type, the function accesses values from the form
    and sets the new values on the selected element. `rectSave` accesses the `fill`, `x`, `y`, `height`,
    and `width` attributes. `circleSave` accesses the `fill`, `cx`, `cy`, and `r` attributes.
    `text``Save` accesses the `fill`, `x`, `y`, and `text` attributes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 各种保存函数也很简单。它们最初都使用`$.modal()`方法隐藏打开的模态框，并传递`hide`参数。之后，函数使用`$().data()`方法的get签名存储对当前单击元素的引用，并将其存储为本地变量`elem`。然后，根据类型，函数从表单中访问值，并在所选元素上设置新值。`rectSave`访问`fill`、`x`、`y`、`height`和`width`属性。`circleSave`访问`fill`、`cx`、`cy`和`r`属性。`text``Save`访问`fill`、`x`、`y`和`text`属性：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the edit function against a `text` element looks as shown in the following
    screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对`text`元素运行`edit`函数的效果如下截图所示：
- en: '![](img/c013c260-996f-449f-8e11-e6e48bfa6965.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c013c260-996f-449f-8e11-e6e48bfa6965.png)'
- en: 'Applying those values produces the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些值会产生以下输出：
- en: '![](img/86da3adf-b9df-4341-8580-65c8d1f2c132.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86da3adf-b9df-4341-8580-65c8d1f2c132.png)'
- en: While there are many, many more features we could add to this small SVG editing
    demo, this example is both simple enough to understand in a single chapter and
    also allows us to illustrate the basic patterns used to add, access, and update
    SVG elements on screen. If you've had some experience with raw DOM manipulations
    in the past, this should all be familiar to you. If you haven't, it's a useful
    set of skills to have, and the basic pattern you've seen here is the way that
    this all works in both the SVG and HTML realms. Once you have access to an element,
    you can then access and update its properties and call various methods on it to
    adjust it on the screen. With this foundation, you'll be able to solve problems
    that might not be easily solved by a library or framework in both SVG and HTML
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以为这个小的SVG编辑演示添加许多更多的功能，但这个例子既足够简单，可以在一个章节中理解，也可以让我们说明用于在屏幕上添加、访问和更新SVG元素的基本模式。如果您以前有一些原始DOM操作的经验，这对您来说应该是很熟悉的。如果没有，这是一组有用的技能，您在这里看到的基本模式是SVG和HTML领域中所有工作的方式。一旦您访问了一个元素，您就可以访问和更新它的属性，并在其上调用各种方法来调整它在屏幕上的位置。有了这个基础，您将能够解决一些可能不容易通过库或框架解决的问题，无论是在SVG还是HTML中。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you created a small application that allows you to add and
    edit SVG elements on a target SVG canvas. Working your way through this application,
    you learned about a wide variety of DOM features and functionality, including:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您创建了一个小型应用程序，允许您在目标SVG画布上添加和编辑SVG元素。通过这个应用程序，您学习了各种DOM功能和功能，包括：
- en: Two different ways to access DOM elements, using `document.getElementById` and
    `document.querySelectorAll`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`document.getElementById`和`document.querySelectorAll`两种不同的方式访问DOM元素
- en: How to insert SVG elements using `document.createElementNS` and `appendChild`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`document.createElementNS`和`appendChild`插入SVG元素
- en: How to bind events to HTML and SVG elements using `addEventListener`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`addEventListener`将事件绑定到HTML和SVG元素
- en: How to get, set, and remove CSS classes from an SVG element using the `classList`
    interface
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`classList`接口从SVG元素获取、设置和移除CSS类
- en: How to manipulate common SVG properties using `getAttribute` and `setAttribute`
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`getAttribute`和`setAttribute`操纵常见的SVG属性
- en: How to convert between the browser coordinate system and the SVG element coordinate
    system by using the `getScreenCTM` method to get the inverse of the *C*urrent
    user unit *T*ransformation *M*atrix
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`getScreenCTM`方法在浏览器坐标系和SVG元素坐标系之间进行转换，以获取*C*urrent用户单位* T *ransformation
    * M *atrix的逆
- en: How to set the text content of an SVG text element using  `textContent`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`textContent`设置SVG文本元素的文本内容
- en: Together with the lessons you've already learned in this book, the lessons you
    learned in this chapter will mean you are ready to work with SVG at a very high
    level across a large variety of tasks. If you're comfortable with the raw DOM
    interface, the patterns of creating, accessing, and manipulating DOM elements
    are all you need to build the most complicated web apps and visualizations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您已经在本书中学到的知识，本章学到的知识将使您能够在各种任务中以非常高的水平使用SVG。如果您熟悉原始DOM接口，创建、访问和操作DOM元素的模式就是您构建最复杂的Web应用程序和可视化所需的一切。
- en: Taking that foundation, we're going to now apply everything we've learned so
    far to other libraries and frameworks so that you can take advantage of the power
    and convenience that libraries such as jQuery, React, and D3, and frameworks such
    as Angular, provide on top of the raw DOM interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们将把到目前为止学到的所有知识应用到其他库和框架上，这样您就可以利用jQuery、React和D3等库以及Angular等框架在原始DOM接口之上提供的强大和便利功能。
