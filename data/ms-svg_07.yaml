- en: Common JavaScript Libraries and SVG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的JavaScript库和SVG
- en: Now that you've taken a look at the raw DOM interface to SVG, it's time to look
    at the interface between SVG and some of the more common JavaScript libraries
    and frameworks. Taking the lessons learned from [Chapter 6](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml), *JavaScript
    and SVG*, we'll look at some of the quirks present in getting SVG to work properly
    with jQuery, AngularJS (1.*), Angular (2+), and ReactJS. These examples will not
    be very deep, but should all illustrate the basic issues present in working with
    SVG and these other codebases. The goal here won't be to introduce you fully to
    these libraries and frameworks. There will be just enough of an introduction to
    get you up and running, and then each section will deal with the specifics of
    that library, or framework and SVG.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过了SVG的原始DOM接口，是时候看看SVG与一些更常见的JavaScript库和框架之间的接口了。借鉴于[第6章](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml)中学到的*JavaScript和SVG*的经验，我们将研究在使用jQuery、AngularJS（1.*）、Angular（2+）和ReactJS时使SVG正常工作时出现的一些特殊情况。这些示例不会很深入，但应该都能说明在处理SVG和这些其他代码库时存在的基本问题。这里的目标不是要完全向你介绍这些库和框架。只会有足够的介绍让你能够开始运行，然后每个部分都将处理该库或框架以及SVG的具体问题。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Working with the ever-popular jQuery library and SVG
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用广受欢迎的jQuery库和SVG
- en: The interface between Angular 1 and Angular (2+) and SVG
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 1和Angular（2+）与SVG之间的接口
- en: SVG and ReactJS, the popular library from Facebook
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG和ReactJS，这是Facebook的流行库
- en: Manipulating SVG with jQuery
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery操纵SVG
- en: The first library we'll look at is jQuery. jQuery isn't as hot as it once was,
    but it's still the most popular JavaScript library on the planet, and understanding
    the quirks of using SVG with jQuery is still potentially useful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看的库是jQuery。jQuery并不像以前那样热门，但它仍然是地球上最流行的JavaScript库，了解在SVG中使用jQuery的特殊情况仍然可能是有用的。
- en: Since jQuery functions as a friendly replacement for common DOM interactions,
    this section will feature a jQuery-based rewrite of the DOM manipulator demo we
    worked on in [Chapter 6](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml), JavaScript
    and SVG.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于jQuery作为常见DOM交互的友好替代，本节将展示我们在[第6章](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml)中进行的DOM操作演示的基于jQuery的重写，JavaScript和SVG。
- en: It uses the exact same markup, so the only place we need to look at in this
    chapter is the script block at the bottom.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用完全相同的标记，因此在本章中我们需要查看的唯一位置是底部的脚本块。
- en: This code will be written in idiomatic jQuery/ES5.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将以惯用的jQuery/ES5编写。
- en: The first thing we'll look at is the function we'll fire on jQuery's equivalent
    of the `DOMContentLoaded` event, `$(document).ready()`. `$(document).ready()`
    takes a function as an argument. As the name implies, that function will be executed
    when the document's DOM content has finished loading.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下我们将在jQuery的`DOMContentLoaded`事件的等价事件上触发的函数，即`$(document).ready()`。`$(document).ready()`接受一个函数作为参数。正如其名称所示，当文档的DOM内容加载完成时，该函数将被执行。
- en: While you could pass in a function expression, we're going to define a traditionally-named
    function called `init` to pass into `$(document).ready()`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以传入一个函数表达式，但我们将定义一个传递给`$(document).ready()`的传统命名的函数`init`。
- en: 'In it, we set a few event handlers. The first is a `click` event handler for
    our buttons. It fires the `loadCursor` function. The second through fourth event
    handlers create `save` events for each of the different SVG element types. The
    last one adds the `add` function to the `#canvas` element so that clicks on the
    canvas element will know to drop the chosen SVG elements onto the page:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们设置了一些事件处理程序。第一个是我们按钮的`click`事件处理程序。它触发`loadCursor`函数。第二到第四个事件处理程序为每种不同的SVG元素类型创建`save`事件。最后一个将`add`函数添加到`#canvas`元素中，以便在画布元素上单击时知道要将所选的SVG元素放到页面上：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we've taken a look at the function that kicks off the application,
    let's look at the other functions in turn. First we'll look at the new version
    of the `add` function. `add` has one major wrinkle and then several smaller ones.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了启动应用程序的函数，让我们依次看看其他函数。首先我们将看看`add`函数的新版本。`add`有一个主要的问题，然后还有几个较小的问题。
- en: We start off by grabbing a loaded jQuery reference to the `$("#canvas")` SVG
    element. After that, the initialization is similar to the vanilla JavaScript Version
    of the function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过获取一个加载了jQuery引用的`$("#canvas")` SVG元素来开始。之后，初始化与函数的纯JavaScript版本类似。
- en: This includes one major wrinkle, where the expected behavior from jQuery fails.
    While the common jQuery element creation methods like `$("<rect>")` work with
    SVG elements and will insert the `<rect>` element into the page, they still need
    to be created with the proper namespace. Without the namespace, as you learned
    in the previous chapter, they will be treated by browsers like arbitrary HTML
    elements and won't render as expected. So, like the vanilla JS example, we need
    to add the namespace to the element creation. So we do that with the same `elem
    = doc.createElementNS(NS, "rect");` pattern we used in the JavaScript-only example.
    Once the element is created, it can be inserted into the DOM and manipulated with
    jQuery as normal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括一个主要的问题，即jQuery的预期行为失败的地方。虽然常见的jQuery元素创建方法如`$("<rect>")`适用于SVG元素，并将`<rect>`元素插入页面，但它们仍然需要使用正确的命名空间进行创建。没有命名空间，就像你在上一章中学到的那样，它们将被浏览器视为任意的HTML元素，并不会按预期渲染。因此，就像纯JS示例中一样，我们需要向元素创建添加命名空间。因此，我们使用与仅JavaScript示例中相同的`elem
    = doc.createElementNS(NS, "rect");`模式来执行此操作。一旦元素被创建，它就可以像通常一样被插入到DOM中并用jQuery进行操作。
- en: After the elements are created, the individual options for the `square`, `circle`,
    and `text` are all handled similarly to the JavaScript-only example. In this case
    we just use the jQuery convenience methods `$().hasClass()` and `$().attr()` to
    test the class name and set the various attributes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 元素创建后，`square`、`circle`和`text`的各个选项都与仅JavaScript示例类似地处理。在这种情况下，我们只是使用jQuery的便利方法`$().hasClass()`和`$().attr()`来测试类名并设置各种属性。
- en: 'Finally, we use a few more jQuery convenience methods to add the element to
    the `$canvas` element, remove the `"active"` class, and add the `click` event
    handler to edit the elements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用更多的jQuery便利方法将元素添加到`$canvas`元素中，移除`"active"`类，并添加`click`事件处理程序来编辑元素：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The three edit functions again follow the same pattern as the vanilla JS example.
    In each function we get a loaded jQuery reference to the `target` element and
    store it as `$elem`. We then use the jQuery method `$().prop`, which looks up
    object properties, to test for the `nodeName` of the calling object. We then show
    the correct modal, with the Bootstrap modal method called with the `"show"` argument,
    and set the current element with the jQuery `$().data` method. `$().data`, as
    you''ll remember from [Chapter 6](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml), *JavaScript
    and SVG*, gets and sets arbitrary data on an element. We then use a combination
    of the `$().val()`  method, which gets or sets the value of form inputs, and the
    `$().attr()` method, which gets or sets an element attribute, to populate the
    form values. `$().val()` is used here to set the values of the forms by reading
    the value of the SVG elements with `$().attr()`, called a `getter` (with no arguments)
    and using that value as `$().val()`''s  argument:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 三个编辑函数再次遵循与普通JS示例相同的模式。在每个函数中，我们获取一个加载的jQuery引用到`target`元素，并将其存储为`$elem`。然后我们使用jQuery方法`$().prop`，它查找对象属性，以测试调用对象的`nodeName`。然后我们显示正确的模态，使用Bootstrap模态方法调用`"show"`参数，并使用jQuery
    `$().data`方法设置当前元素。`$().data`，正如你在[第6章](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml)中记得的，*JavaScript和SVG*，在元素上获取和设置任意数据。然后我们使用`$().val()`方法的组合，它获取或设置表单输入的值，和`$().attr()`方法，它获取或设置元素属性，来填充表单值。`$().val()`在这里用于通过读取SVG元素的值来设置表单的值，使用`$().attr()`调用`getter`（没有参数）并将该值作为`$().val()`的参数：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we have the various `save` methods. These follow the same pattern
    as the previous examples. It''s the same basic workflow as the vanilla JS example,
    but once again we are able to use the full suite of jQuery convenience methods
    against our SVG elements: using the Bootstrap method to hide the modal, grabbing
    a reference to the current element using the `$().data()` method, and then setting
    attributes with the `$().attr()` method, called a `setter`, and `$().val()` called
    a `getter`, as the argument:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有各种`save`方法。这些遵循与之前示例相同的模式。这与普通JS示例的基本工作流程相同，但我们再次能够使用完整的jQuery便利方法来操作我们的SVG元素：使用Bootstrap方法隐藏模态，使用`$().data()`方法获取对当前元素的引用，然后使用`$().attr()`方法设置属性，称为`setter`，和`$().val()`称为`getter`，作为参数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, with the exception of element creation, working with SVG and
    jQuery is straightforward. Element creation requires using a standard DOM method,
    but every other interaction with SVG elements can use the appropriate jQuery methods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，除了元素创建之外，使用SVG和jQuery是直接的。元素创建需要使用标准DOM方法，但与SVG元素的其他交互可以使用适当的jQuery方法。
- en: Working with AngularJS and SVG
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AngularJS和SVG
- en: Now it's time to look at using SVG inside more complete application frameworks.
    We're going to start with AngularJS, the original Version of Google's wildly popular
    application framework. While AngularJS (Angular  1.*) is old in the context of
    web frameworks, it remains popular and in use in many environments. It's also
    familiar to many people and is widely deployed, so taking a brief look at how
    to work with SVG inside an AngularJS application is useful from multiple perspectives.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看在更完整的应用程序框架中使用SVG。我们将从AngularJS开始，这是Google广受欢迎的应用程序框架的原始版本。虽然AngularJS（Angular
    1.*）在Web框架的背景下已经过时，但它仍然受欢迎，并在许多环境中使用。它也为许多人所熟悉，并且被广泛部署，因此从多个角度来看，了解如何在AngularJS应用程序中使用SVG是有用的。
- en: This and the following examples will be simpler than the jQuery and pure JavaScript
    demos. There are two reasons for this. The first is that you've seen a lot of
    details, under the hood, about how SVG and JavaScript interact in the DOM. You're
    actually ready to tackle SVG DOM manipulation on your own, so going over a wide
    number of variations in the different frameworks might not even be that beneficial.
    Covering the basics should give you enough to go off on your own.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个和接下来的示例将比jQuery和纯JavaScript演示更简单。这有两个原因。首先，你已经在SVG和JavaScript在DOM中的交互方面看到了很多细节。你实际上已经准备好自己处理SVG
    DOM操作，因此在不同框架中涵盖大量变化可能甚至不那么有益。覆盖基础知识应该足够让你自己去做。
- en: 'Secondly, we don''t want too much detail about the actual libraries and frameworks.
    Keeping the introduction to each to a minimum means we can focus on the SVG portion
    of the discussion. To that end, we''ll look at the simplest possible demo that
    will show the two most important aspects of working with an element in an application:
    inserting dynamic SVG elements into the DOM, and manipulating them via user interaction.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们不希望太多关于实际库和框架的细节。将每个介绍保持在最低限度意味着我们可以专注于讨论的SVG部分。为此，我们将看看最简单的演示，它将展示在应用程序中使用元素的两个最重要方面：将动态SVG元素插入DOM，并通过用户交互对其进行操作。
- en: 'The demos will look as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 演示将如下所示：
- en: '![](img/78f442d6-4ff8-45d9-bad1-4181bb70b9c4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78f442d6-4ff8-45d9-bad1-4181bb70b9c4.png)'
- en: This code will be written in idiomatic ES5.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将以惯用的ES5方式编写。
- en: The code follows. All the code for this example is in a single HTML file. This
    isn't normally the way that you'd build an AngularJS application, but it works
    fine for this example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码。这个示例的所有代码都在一个单独的HTML文件中。这通常不是您构建AngularJS应用程序的方式，但对于这个示例来说，它完全可以。
- en: 'The document `head` sets the application up with the necessary scripts and
    styles. We link to Bootstrap, jQuery and Angular:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 文档`head`使用必要的脚本和样式设置应用程序。我们链接到Bootstrap，jQuery和Angular：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The interesting stuff starts with the `body` element. That's where we set up
    our Angular application. The `ng-app` attribute indicates that Angular should
    process the `body` element and all of its children, applying Angular's special
    parsing rules to the markup contained within. We'll see more about what the `ng-app`
    value `"angularSVG"` references shortly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分从`body`元素开始。这是我们设置Angular应用程序的地方。`ng-app`属性表示Angular应该处理`body`元素及其所有子元素，并将Angular的特殊解析规则应用于其中包含的标记。我们很快会看到`ng-app`值`"angularSVG"`的引用指的是什么。
- en: The markup that follows is where we wire up the UI to use Angular features and
    functionality. Angular uses a combination of special attributes and custom HTML
    elements to create dynamic interfaces.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的标记是我们将UI与Angular功能和功能绑定在一起的地方。Angular使用特殊属性和自定义HTML元素的组合来创建动态界面。
- en: The most important piece, from our perspective, is the use of the `ng-attr`
    prefix to `fill`, `cx`, `cy`, and `r` attributes. Angular allows you to reference
    variables in the current controller's scope in the markup and, as long as it's
    wrapped in the `{{}}` pattern, Angular will replace that reference with the value
    from the model. It's a live reference and it will automatically update in a regular
    cycle.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的角度来看，最重要的部分是使用`ng-attr`前缀来处理`fill`、`cx`、`cy`和`r`属性。Angular允许您在标记中引用当前控制器作用域中的变量，只要它包含在`{{}}`模式中，Angular就会用模型中的值替换该引用。这是一个实时引用，它将在常规周期中自动更新。
- en: 'This very convenient feature *does not*play well with certain SVG attributes.
    While the following will eventually work after you play around with the applicationand
    the values are converted from the Angular tokens to numerical values,it will *error*
    when the document loads:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常方便的特性*不*与某些SVG属性兼容。虽然在您玩转应用程序并将值从Angular令牌转换为数值后，以下内容最终会起作用，但在文档加载时会出现错误：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The error can be seen in the following screenshot. The SVG parser is expecting
    a `length` value and is instead getting a string:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可以在以下截图中看到。SVG解析器期望一个`length`值，而实际上得到的是一个字符串：
- en: '![](img/e81c74fe-a429-4888-844f-5b0231f501e3.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e81c74fe-a429-4888-844f-5b0231f501e3.png)'
- en: Fixing this requires the use of the `ng-attr` prefix. This prefix indicates
    to Angular that the `allOrNothing` flag should be used during the interpolation
    step. In plain English, this means that if the value of the attribute is `undefined`,
    the attribute is not rendered into the document. Once it has a value it is rendered
    as normal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题需要使用`ng-attr`前缀。这个前缀告诉Angular在插值步骤中使用`allOrNothing`标志。简单来说，这意味着如果属性的值是`undefined`，则不会将属性呈现到文档中。一旦它有一个值，它就会像正常一样呈现。
- en: The second interesting part of this markup is the custom HTML element, `angular-rect`. `angular-rect`
    is what's called a **directive** in Angular. A directive is Angular's mechanism
    for creating custom HTML elements and attributes that allow you to expand and
    enhance common HTML elements and documents with reusable code blocks of your own
    design. While this one will be very simple, as you'll see shortly, this custom
    element will succinctly illustrate the way that Angular directives work with SVG.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标记的第二个有趣部分是自定义HTML元素`angular-rect`。`angular-rect`是Angular中所谓的**指令**。指令是Angular用来创建自定义HTML元素和属性的机制，允许您通过自己设计的可重用代码块来扩展和增强常见的HTML元素和文档。虽然这个很简单，但很快你会看到，这个自定义元素将简洁地说明Angular指令如何与SVG一起工作。
- en: 'The only other interesting part of the markup is the use of the `ng-model`
    attribute to bind JavaScript variable values to the elements in the form field.
    This special AngularJS attribute wires up two-way data-binding between the markup
    and the Angular controller. We''ll soon see the way these variables are set in
    the controller, but just keep in mind the idea that once this connection is set,
    AngularJS keeps it alive and will update the values in the SVG elements whenever
    the `form` field is updated:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标记中唯一有趣的部分是使用`ng-model`属性将JavaScript变量值绑定到表单字段中。这个特殊的AngularJS属性在标记和Angular控制器之间建立了双向数据绑定。我们很快会看到这些变量是如何在控制器中设置的，但请记住一点，一旦建立了这种连接，AngularJS会保持它的活力，并在`form`字段更新时自动更新SVG元素中的值：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The JavaScript is very simple. Just a few lines of JavaScript allow you to wire
    up the values of the form fields to dynamically adjust the height, width, and
    fill color of the circle. The first piece, the `angular.module()` method call,
    creates an Angular app called `"angularSVG"`. It's this reference that Angular
    looks for in the markup in order to know whether or not there's an Angular app
    on the page. If it finds that value in an `ng-app`, it parses that markup and
    applies Angular-based magic to the page.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript非常简单。只需几行JavaScript代码，就可以将表单字段的值动态调整为圆的高度、宽度和填充颜色。第一部分是`angular.module()`方法调用，创建了一个名为`"angularSVG"`的Angular应用程序。这个引用是Angular在标记中寻找的，以便知道页面上是否有一个Angular应用程序。如果它在`ng-app`中找到这个值，它会解析该标记并将基于Angular的魔术应用到页面上。
- en: Following that, there's our small controller definition, `circleController`.
    `circleController` has one argument, the angular `$scope` variable. `$scope`,
    if you're not familiar with Angular, can be thought of as a managed alias for
    the `this` value of a function. It's the internal state of the controller, and
    the properties and methods in `$scope` are available to both the JavaScript code
    and to the Angular aware markup.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们小的控制器定义，`circleController`。`circleController`有一个参数，即Angular的`$scope`变量。如果您对Angular不熟悉，可以将`$scope`视为函数的`this`值的受控别名。它是控制器的内部状态，`$scope`中的属性和方法对JavaScript代码和对Angular感知的标记都是可用的。
- en: Inside the controller, all we do is set some variables on the `$scope`. These
    serve as our baseline values for the circle, and because they're bound to the
    Angular `$scope`, they automatically become live, two-way links to the corresponding
    values in both the circle, and the form fields.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器内部，我们只是在`$scope`上设置了一些变量。这些变量作为圆的基线值，并且由于它们绑定到Angular的`$scope`，它们自动成为与圆和表单字段中相应值的活动、双向链接。
- en: 'After that we create a simple Angular directive, `angularRect`, which does
    nothing but insert a `rect` element into the SVG DOM. We won''t go into the complexities
    of Angular directives here, but there is one specific detail that is important
    for SVG elements. The `templateNamespace` property of the return object indicates
    to Angular that the directive should be treated as SVG. Without it, like jQuery''s
    common DOM creation pattern and the DOM method `document.createElement`, the directive will
    be inserted into the document, but it will not be created as a proper SVG element.
    It''ll be there, but it won''t actually show up as a square when it''s rendered:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了一个简单的Angular指令`angularRect`，它只是在SVG DOM中插入一个`rect`元素。我们不会在这里讨论Angular指令的复杂性，但有一个特定的细节对于SVG元素非常重要。返回对象的`templateNamespace`属性指示Angular应将该指令视为SVG。没有它，就像jQuery的常见DOM创建模式和DOM方法`document.createElement`一样，该指令将被插入文档，但它不会被创建为一个正确的SVG元素。它会存在，但在渲染时不会显示为一个正方形：
- en: Angular uses the JavaScript friendly camelCase inside JavaScript and then kebab
    case when the elements are inserted into the document.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在JavaScript中使用友好的驼峰命名法，然后在将元素插入文档时使用短横线命名法。
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running that in the browser and then adjusting the values looks like the following
    screenshots. The initial screenshot shows the demo loaded with the initial values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行并调整数值后，效果如下截图所示。初始截图显示了加载初始数值的演示：
- en: '![](img/679721ca-ec4c-472c-8dab-93db93e873f8.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/679721ca-ec4c-472c-8dab-93db93e873f8.png)'
- en: 'This second screenshot shows the values adjusted and the circle element changed
    in a corresponding manner:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个截图显示了调整后的数值和圆形元素相应地发生了变化：
- en: '![](img/61019910-73f6-4104-a8fe-b2d9f22c609b.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61019910-73f6-4104-a8fe-b2d9f22c609b.png)'
- en: Now that we've looked at AngularJS, let's take a look at the new evolution of
    Angular, Angular 2.+. Known as just Angular, this iteration of the framework is
    very different and very powerful.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了AngularJS，让我们来看看Angular的新进化，Angular 2.0+。这个版本的框架被称为Angular，与之前的版本非常不同，功能非常强大。
- en: Let's take a quick look.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下。
- en: Manipulating SVG with Angular
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular操作SVG
- en: Moving on from AngularJS, let's take a look at the modern evolution of Angular.
    Angular 2.+ (referred to *just as Angular*) is a thoroughly modern framework.
    It's traditionally written in TypeScript, a super-set of JavaScript that adds
    optional features that Angular takes advantage of to add some incredibly convenient
    features and functionality to the library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从AngularJS转向，让我们来看看Angular的现代进化。Angular 2.0+（简称为Angular）是一个非常现代的框架。它通常是用TypeScript编写的，这是JavaScript的一个超集，它添加了一些可选功能，Angular利用这些功能为库添加了一些非常方便的功能和功能。
- en: Getting started with Angular
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Angular
- en: Since Angular is a newer framework and has a much larger footprint, we'll go
    through a little bit of the setup to get you going. The code in the downloaded
    examples will work, but knowing how you get there is pretty useful. So, let's
    get set up.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular是一个较新的框架，占用的空间较大，我们将介绍一些设置步骤。下载示例中的代码将可以工作，但了解如何到达那里是非常有用的。所以，让我们开始设置。
- en: This Angular example will replicate the exact same demo that the AngularJS example
    provided redone using Angular code. As you've probably already sensed and will
    continue to learn, the basic issues with dynamic SVG are the same no matter what
    library or framework you're using; the solutions are just slightly different.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Angular示例将复制使用Angular代码重新制作的与AngularJS示例提供的完全相同的演示。正如您可能已经感觉到并将继续学习的那样，无论您使用哪种库或框架，动态SVG的基本问题都是相同的；解决方案只是略有不同。
- en: You can use whatever text editor you like for the Angular sample, but I suggest
    using Microsoft's VS Code. It's free, well-supported, updated frequently, and
    plays very well with TypeScript.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何您喜欢的文本编辑器来进行Angular示例，但我建议使用微软的VS Code。它是免费的，得到很好的支持，经常更新，并且与TypeScript非常兼容。
- en: Installing Node, npm, and Angular Cli
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node、npm和Angular Cli
- en: Before you can start to work with Angular, you need to be set up with the tools
    needed to actually run the code. The foundation of everything is Node.js and Node's
    package manager, `npm`. So you should install those first if you haven't already.
    The easiest way to do that is to head on over to [nodejs.org](http://nodejs.org)
    and download the installer for your operating system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始使用Angular之前，您需要设置好实际运行代码所需的工具。一切的基础是Node.js和Node的包管理器`npm`。因此，如果您还没有安装，您应该首先安装它们。最简单的方法是转到[nodejs.org](http://nodejs.org)并下载适用于您操作系统的安装程序。
- en: 'Once you''ve done that, you can go ahead and install the Angular **Command
    Line Utility** (**CLI**). Angular CLI makes it very easy to get up and running
    with an Angular project, as you''ll see in short order. The following command
    will install Angular CLI globally on your machine:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以继续安装Angular的**命令行工具**（**CLI**）。Angular CLI使得启动Angular项目变得非常容易，您很快就会看到。以下命令将在您的计算机上全局安装Angular
    CLI：
- en: '![](img/e6996342-dc66-40a8-aeca-cacbb33cd7b7.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6996342-dc66-40a8-aeca-cacbb33cd7b7.png)'
- en: 'Once it''s installed, it''s time to create a project using the `ng new` command.
    `ng new` will create a new folder with everything you need to get an Angular project
    up and running. We won''t go into all the details but after running this command,
    you should be all set to start working with your application:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，使用`ng new`命令创建一个项目。`ng new`将创建一个新的文件夹，其中包含启动Angular项目所需的一切。我们不会详细介绍，但运行此命令后，您应该已经准备好开始使用您的应用程序了：
- en: '![](img/69ce9e39-72c3-4440-91bb-e24b1e65ee66.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69ce9e39-72c3-4440-91bb-e24b1e65ee66.png)'
- en: 'The next step is to go into the folder you just created and run `npm install`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是进入您刚创建的文件夹并运行`npm install`：
- en: '![](img/4260a2d0-c0bf-4637-8a08-bce5d90db340.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4260a2d0-c0bf-4637-8a08-bce5d90db340.png)'
- en: '`npm install` will ensure that all your dependencies are installed in `node_modules`
    and your application will be ready to run.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install`将确保所有依赖项都安装在`node_modules`中，并且您的应用程序将准备就绪。'
- en: 'The following screenshot from VS Code shows the layout of the application after
    it''s been initialized and `npm` install has been run:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从VS Code的以下屏幕截图显示了初始化应用程序并运行`npm` install后的布局：
- en: '![](img/a23bd629-8d25-487a-b286-285ec1c0a6de.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a23bd629-8d25-487a-b286-285ec1c0a6de.png)'
- en: Since we're using Bootstrap for this Version of the Demo as well, we need to
    make sure that it's available. That's done by running
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在这个演示版本中也使用Bootstrap，因此需要确保它可用。通过运行以下命令完成：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'which will install Bootstrap into your `node_modules`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把Bootstrap安装到您的`node_modules`中：
- en: '![](img/d9e8b949-b4ea-493c-ba95-60fb6ede1ca3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9e8b949-b4ea-493c-ba95-60fb6ede1ca3.png)'
- en: 'You can then wire it up in `angular-cli.json`. `angular-cli.json` is where
    you configure different aspects of your Angular CLI installation. In this case
    all we need to do is add Bootstrap CSS to the styles property so that it will
    be bundled with the rest of the application:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在`angular-cli.json`中进行连接。`angular-cli.json`是您配置Angular CLI安装的不同方面的地方。在这种情况下，我们只需要将Bootstrap
    CSS添加到styles属性中，以便它将与应用程序的其余部分捆绑在一起：
- en: Under the hood, Angular CLI uses Webpack to bundle scripts and styles and process
    them in a number of ways to ready them for delivery to your development server
    as well as to production environments. One of the greatest benefits of using Angular
    CLI is that it smoothes out the complexity of working with Webpack. Webpack is
    incredibly powerful but has a steep learning curve. Angular CLI makes it just
    work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Angular CLI使用Webpack来捆绑脚本和样式，并以多种方式处理它们，以便将它们准备好交付到开发服务器以及生产环境。使用Angular
    CLI的最大好处之一是它简化了使用Webpack的复杂性。Webpack非常强大，但学习曲线陡峭。Angular CLI让它变得简单易用。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the application in this simple state will allow us to start developing
    the application and testing against a development server running locally. This
    is done using the `ng serve` command. It''s called here with the `--open` option
    which will open a web browser after the code is compiled:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种简单状态下运行应用程序将允许我们开始开发应用程序，并针对在本地运行的开发服务器进行测试。这是使用`ng serve`命令完成的。在编译代码后，使用`--open`选项将打开一个Web浏览器：
- en: '![](img/1be8b908-3865-4ae3-852d-ab260405e18a.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1be8b908-3865-4ae3-852d-ab260405e18a.png)'
- en: This will auto-reload the code in the browser whenever changes are made to the
    code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器中自动重新加载代码，每当对代码进行更改时。
- en: So, with that, it's time to actually start writing some TypeScript and interacting
    with SVG.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候开始编写一些TypeScript并与SVG进行交互了。
- en: 'The first thing we''ll do is edit the main module for the application. `app.module.ts`
    is the root module for the application and it''s where all the parts of the application
    are wired together. Most of this is automatically wired up by `Angular CLI`. All
    we need to do is import the `FormsModule` from an Angular core, using the new
    ES6 module pattern (`import` `module from src`). Then we add it to the `imports`
    array of the `@NgModule` decorator. This allows the directives and properties
    of the `FormsModule` to be available inside this application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是编辑应用程序的主模块。`app.module.ts`是应用程序的根模块，它是应用程序的所有部分连接在一起的地方。大部分都是由`Angular
    CLI`自动连接的。我们只需要使用新的ES6模块模式（`import` `module from src`）从Angular核心导入`FormsModule`。然后将其添加到`@NgModule`装饰器的`imports`数组中。这允许`FormsModule`的指令和属性在此应用程序中可用：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Following that, we''ll completely edit the `app.component.ts` file to represent
    our (simple) component. In it, we import `Component` and `FormsModule` from Angular,
    do some standard housekeeping in the `@Component` decorator, and then we export
    the `AppComponent` class which ships with four properties set. This pattern deserves
    some explanation since it''s probably familiar but different enough that it might
    be a head-scratcher. For starters, all of these are created with the `public`
    keyword. That indicates that these properties should be available outside the
    scope of the class. Next is the variable name itself, followed by a colon and
    a type annotation, indicating the expected type of the variable. TypeScript allows
    you to create custom types based on other TypeScript classes, but for our purposes,
    we''re just using standard JavaScript primitives, `number` and `string`. Finally
    we set default values for all of them so that our application has something to
    hang onto:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将完全编辑`app.component.ts`文件以表示我们的（简单）组件。在其中，我们从Angular导入`Component`和`FormsModule`，在`@Component`装饰器中进行一些标准的维护工作，然后导出`AppComponent`类，其中包含四个设置的属性。这种模式值得一些解释，因为它可能很熟悉，但又有足够的不同之处，可能会让人费解。首先，所有这些都是使用`public`关键字创建的。这表示这些属性应该在类的范围之外可用。接下来是变量名称本身，后跟冒号和类型注释，指示变量的预期类型。TypeScript允许您基于其他TypeScript类创建自定义类型，但对于我们的目的，我们只是使用标准的JavaScript原语，`number`和`string`。最后，我们为它们设置默认值，以便我们的应用程序有东西可以依靠：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next we have the markup, which is similar to the previous example. It's all
    contained in `app.component.html`. There are some similarities to the AngularJS
    Version. For example the dynamic attributes have to be similarly handled, you
    still can't bind directly to SVG attributes without causing an error, so you still
    have to manage them explicitly. In this case you use the `attr.` prefix instead
    of the `ng-attr-` prefix you used in AngularJS. You'll also notice the square
    brackets surrounding the attributes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是标记，与之前的示例类似。它都包含在`app.component.html`中。与AngularJS版本有一些相似之处。例如，动态属性必须以类似的方式处理，仍然不能直接绑定到SVG属性而不引起错误，因此仍然必须显式地管理它们。在这种情况下，您使用`attr.`前缀而不是在AngularJS中使用的`ng-attr-`前缀。您还会注意到属性周围的方括号。
- en: 'Using the simple square brackets `[]` indicates that this is a one-way data
    binding; the template reads from the component properties we previously defined.
    Later on, in the inputs, we see an example of explicit two-way data binding with
    the square bracket/parenthesis `[()]`  syntax surrounding the attribute. `ngModel`
    is the directive we were importing with `FormsModule`. It allows us to do two-way
    data binding from a form element to the properties of a component. This way the
    entries in the form are, once again, represented in the attributes of the SVG
    `circle` element and it displays changes as updates are made to the `form` fields:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的方括号`[]`表示这是单向数据绑定；模板从我们之前定义的组件属性中读取。稍后，在输入中，我们看到了使用方括号/括号`[()]`语法围绕属性的显式双向数据绑定的示例。`ngModel`是我们使用`FormsModule`导入的指令。它允许我们从表单元素到组件属性进行双向数据绑定。这样，表单中的条目再次表示为SVG
    `circle`元素的属性，并且随着对`form`字段的更改而显示更改。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There''s only one more thing we need to do to get this Angular example to match
    the previous example in AngularJS, and that is to add a sub-component that represents
    the small blue `rect` element. There are a couple of interesting wrinkles with
    this. The first is an illustration of the power of Angular CLI. With Angular CLI
    if you need to wire up a  component, you can do so with the `ng new` command.
    In our case we''ll run `ng new component angular-rect`, which will generate the
    various files that make up an Angular component and will actually wire the component
    up into `app.module.ts`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要做一件事情，就可以使这个Angular示例与之前的AngularJS示例匹配，那就是添加一个代表小蓝色`rect`元素的子组件。这里有一些有趣的地方。首先是展示了Angular
    CLI的强大之处。使用Angular CLI，如果需要连接一个组件，可以使用`ng new`命令。在我们的例子中，我们将运行`ng new component
    angular-rect`，这将生成组成Angular组件的各种文件，并将实际将组件连接到`app.module.ts`中：
- en: '![](img/4e746339-5776-421b-9d45-09f97e6b244b.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e746339-5776-421b-9d45-09f97e6b244b.png)'
- en: 'You can see what `app.module.ts` looks like in the following updated code sample
    where the new `AngularRectComponent` component is imported and added to the `@NgModule`
    declarations:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下更新的代码示例中看到`app.module.ts`的样子，其中导入了新的`AngularRectComponent`组件并将其添加到`@NgModule`声明中：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are a couple more wrinkles, related directly to SVG, that need pointing
    out to get this custom element onto the page. The first is the requirement of
    adding the `svg:` prefix to the elements in the `angular-rect` component. This
    indicates to Angular that, you guessed it, it should use the SVG namespace when
    creating these elements:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些与SVG直接相关的问题，需要指出才能将这个自定义元素放到页面上。首先是需要在`angular-rect`组件中的元素中添加`svg:`前缀。这告诉Angular，您猜对了，它应该在创建这些元素时使用SVG命名空间：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next wrinkle is a two-parter. With a component made up of simple HTML elements,
    you could do something like this, which is similar to what you saw in AngularJS.
    You would add the element to the page as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是一个两部分的问题。对于由简单HTML元素组成的组件，您可以像这样做，这与您在AngularJS中看到的类似。您可以按照以下方式将元素添加到页面中：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Which will render, in the live view in the Web Inspector, the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Web检查器中的实时视图中呈现如下：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That looks fine from a markup perspective, but in the browser, the blue rectangle
    is missing. The whole element isn't rendering, even though it's in the DOM.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从标记的角度来看，这看起来很好，但在浏览器中，蓝色矩形消失了。整个元素没有渲染，即使它在DOM中。
- en: In HTML5, this sort of thing will work because the HTML5 parser has been designed
    to be forgiving of unknown elements (as well as poorly formed markup) and you
    can manipulate custom elements with CSS.  SVG, on the other hand, remains a strict
    XML grammar, so unless the element is in the SVG specification, or you can point
    to an XML-based **Document Type Definition** (**DTD**) that defines that particular
    element, it won't render properly. Thankfully, there's an SVG-shaped solution
    that works perfectly well with a feature of Angular components. You can use Angular's
    ability to bind custom components to attributes with the generic `g` element to
    create much the same effect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5中，这种做法可以工作，因为HTML5解析器已经被设计成对未知元素（以及格式不正确的标记）宽容，并且您可以使用CSS操作自定义元素。另一方面，SVG仍然是严格的XML语法，因此除非元素在SVG规范中，或者您可以指向定义该特定元素的基于XML的**文档类型定义**（**DTD**），否则它不会正确渲染。幸运的是，有一个与Angular组件的功能完全兼容的SVG形状解决方案。您可以使用Angular绑定自定义组件到`g`元素的能力来创建几乎相同的效果。
- en: The following code sample shows how this is done.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了如何做到这一点。
- en: 'First, let''s look at the `angular-rect` component itself. The only thing to
    note, as most of the file is just boilerplate, is that the selector in the `@Component`
    decorator is wrapped in square brackets `[]`. Since it''s wrapped in square brackets,
    that indicates to the parser that it''s an attribute selector, as opposed to the
    common element selector you saw with the app component itself. That means that
    Angular will look for the presence of `angular-rect` as an attribute of an element
    and will replace that with our new custom component:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`angular-rect`组件本身。需要注意的是，大部分文件都是样板文件，唯一需要注意的是`@Component`装饰器中的选择器被包裹在方括号`[]`中。由于它被包裹在方括号中，这告诉解析器它是一个属性选择器，而不是您在应用程序组件本身中看到的常见元素选择器。这意味着Angular将查找元素的属性中是否存在`angular-rect`，并将其替换为我们的新自定义组件：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we''ll see how that works with the markup. We, once again, add the `svg:`
    prefix to the `g` element and then we simply add the `angular-rect` attribute
    and the component renders properly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在标记中使用。我们再次将`svg:`前缀添加到`g`元素，然后我们只需添加`angular-rect`属性，组件就会正确渲染：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And that's that for Angular.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular到此为止。
- en: Working with React and SVG
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React和SVG
- en: The final library we're going to look at is React. React is a very popular library
    that came along just as AngularJS was getting long in the tooth and before Angular
    was ready for prime-time. It's very popular in some circles. It's based on ES6
    with some extensions specific to React.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的最后一个库是React。React是一个非常流行的库，它在AngularJS变得陈旧之际出现，而在Angular准备好投入使用之前出现。在某些圈子里非常受欢迎。它基于ES6，并具有一些特定于React的扩展。
- en: Much of it will look familiar to you, just based on what you've seen so far
    in this chapter and especially if you've done any serious web application development.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其中许多内容对你来说可能很熟悉，仅仅基于你在本章中迄今所看到的内容，特别是如果你做过任何严肃的Web应用程序开发。
- en: Getting started with React is less straightforward than getting up and running
    with Angular. Angular, under the hood, is probably more complicated, but Angular
    CLI smooth out a lot of the issues so you never (or rarely) actually see the complexity
    as a developer. React is more of a library than a complete framework, so you can
    end up having to make a lot more decisions in order to get up and running. Thankfully,
    while there are many ways to get there and none are as central to the project
    as Angular CLI is to Angular (they're tightly coupled in the documentation and
    community), there are ways to do it just as simply as Angular CLI. Perhaps even
    simpler since there's nothing to even install.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用React并不像使用Angular那样直接。Angular在内部可能更复杂，但Angular CLI消除了许多问题，因此作为开发人员，你几乎不会（或很少）看到复杂性。React更像是一个库而不是一个完整的框架，因此为了启动和运行，你可能需要做出更多的决定。幸运的是，虽然有许多方法可以实现这一点，但没有任何方法像Angular
    CLI对Angular那样对项目至关重要（它们在文档和社区中紧密耦合），但有一些方法可以像Angular CLI一样简单地实现。也许甚至更简单，因为根本不需要安装任何东西。
- en: 'Assuming you have Node Version >6 installed on your machine, all you need to
    do to create the simple application used in the demo code is to run a single command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的机器上安装了Node版本>6，你只需要运行一个命令就可以创建演示代码中使用的简单应用程序：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`create-react-app` is a utility from Facebook that spins up a fully functional
    React app. Running it looks like the following two screenshots (the full scroll
    would take up many pages of the book).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app`是Facebook的一个实用工具，可以启动一个完全功能的React应用程序。运行它看起来像以下两个屏幕截图（完整滚动将占据书的许多页面）。'
- en: 'It''s very cool. It creates the folder, downloads all of the dependencies and
    installs everything, giving you a series of commands to run in order to interact
    with your newly minted React application:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷。它创建文件夹，下载所有的依赖项并安装所有内容，然后给你一系列命令，以便与你新创建的React应用程序进行交互：
- en: '![](img/a6f94d94-1a97-46a0-8436-e2e5318f92d0.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6f94d94-1a97-46a0-8436-e2e5318f92d0.png)'
- en: 'Continued result:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 持续结果：
- en: '![](img/1fe0854b-769e-4e42-9028-6600aa34dd1f.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fe0854b-769e-4e42-9028-6600aa34dd1f.png)'
- en: 'Looking deeper, it creates a directory that looks like the following screenshot.
    It contains the `node_modules` folder with all of the dependencies, `public`,
    which is where the transpiled files live (and are served from when you browse
    your working code) and `src`, which is where all the source files for your application
    live. The other files are all standard files for a `git/npm/yarn-based project`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入地看，它创建了一个看起来像以下屏幕截图的目录。它包含了`node_modules`文件夹和所有的依赖项，`public`是编译后文件的存放位置（当你浏览你的工作代码时，它们是从这里提供的），`src`是你的应用程序的所有源文件的存放位置。其他文件都是`git/npm/yarn-based
    project`的标准文件：
- en: Yarn is an alternative to `npm`. We won't go into the details of the differences
    between the two because it's out of the scope of this book and, to be honest,
    isn't all that interesting. Suffice to say, yarn is a parallel tool to `npm` so
    you will do the same things you would do with `npm` with yarn. The syntax is occasionally
    different and there is a different file created when doing `yarn install` (`yarn.lock`).
    But for the sake of this book you don't need to concern yourself with the differences.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn是`npm`的替代品。我们不会详细介绍两者之间的区别，因为这超出了本书的范围，而且说实话，也不是很有趣。可以说，yarn是`npm`的并行工具，因此你将使用yarn做与`npm`相同的事情。语法偶尔有所不同，在运行`yarn
    install`时会创建一个不同的文件（`yarn.lock`）。但就本书而言，你不需要关心这些区别。
- en: '![](img/b8d327e3-5bdf-48bf-9436-adf481b64ec3.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8d327e3-5bdf-48bf-9436-adf481b64ec3.png)'
- en: As previously mentioned, the application code is in `src`. You can see the layout
    of that folder in the following screenshot.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序代码在`src`中。你可以在以下屏幕截图中看到该文件夹的布局。
- en: '`App.css`, `App.js`, and `App.test.js` are where the heart of your application
    will live. The `index.js` file is the main entry point to your application and
    they Bootstrap your React application. `registerServiceWorker.js` is a file provided
    by the framework that serves assets from a local cache. However, you won''t actually
    touch it in this simple app:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.css`、`App.js`和`App.test.js`是你的应用程序的核心所在。`index.js`文件是你的应用程序的主要入口点，它会引导你的React应用程序。`registerServiceWorker.js`是框架提供的一个文件，用于从本地缓存中提供资源。但是，在这个简单的应用程序中，你实际上不会碰它：'
- en: '![](img/3d1c8368-67d7-4232-a3a3-9a3ab354ee50.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d1c8368-67d7-4232-a3a3-9a3ab354ee50.png)'
- en: 'Running `yarn start` from the root of the project folder will compile all of
    the React code, and CSS, and will spin up a development server available at localhost:`3000`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目文件夹的根目录运行`yarn start`将编译所有的React代码和CSS，并将启动一个可在localhost:`3000`访问的开发服务器：
- en: '![](img/39ac6a11-a210-4555-bddb-b0f7b913ad87.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39ac6a11-a210-4555-bddb-b0f7b913ad87.png)'
- en: 'The starter app looks as follows, in case you were wondering. We will quickly
    blow that away:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序如下，以防你想知道。我们将很快消除它：
- en: '![](img/22df7d11-f3c3-4a30-b55a-1b1f8f0c707a.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22df7d11-f3c3-4a30-b55a-1b1f8f0c707a.png)'
- en: Before we get started with our dive into SVG and React, let's take a look at
    the basic React component spit out by `create-react-app`. You've seen it rendered
    previously; let's look at how it works.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入研究SVG和React之前，让我们看一下`create-react-app`生成的基本React组件。你之前已经看到它的渲染；现在让我们看看它是如何工作的。
- en: The basic format of a React component is as follows. It's an ES6 module, with
    `import` statements, a class, and an export. There's one element specific to React
    that's worth noting.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的基本格式如下。它是一个ES6模块，带有`import`语句、一个类和一个导出。有一个特定于React的元素值得注意。
- en: The top of the file shows the ES6 imports. This can include CSS files (as we'll
    see in a minute) and SVG images. Webpack actually reads those import statements
    and optimizes those imports, much like Webpack worked with Angular decorators.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部显示了ES6导入。这可以包括CSS文件（我们马上就会看到）和SVG图像。Webpack实际上会读取这些导入语句并优化这些导入，就像Webpack与Angular装饰器一样工作。
- en: Following that we have the one class in the file. `App`, which extends the base
    `Component` class from React. It's got one method, `render()`, which uses an extension
    to JavaScript called JSX. JSX allows you to mix XML and JavaScript together. I
    honestly have never much liked this format and was practically shocked by it when
    they released it, but I've grown to appreciate the intent, even if I don't like
    it. JSX attributes are parsed as strings if they're quoted. Otherwise, they are
    treated as JavaScript expressions. In this case, the path to `logo.svg` is converted
    to a useful path and the logo is rendered in the browser.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是文件中的唯一一个类。`App`，它扩展自React的基本`Component`类。它有一个方法`render()`，它使用了一种称为JSX的JavaScript扩展。JSX允许您将XML和JavaScript混合在一起。老实说，我从来不太喜欢这种格式，当他们发布它时我几乎感到震惊，但我已经开始欣赏它的意图，即使我不喜欢它。如果JSX属性被引用，则它们被解析为字符串。否则，它们被视为JavaScript表达式。在这种情况下，`logo.svg`的路径被转换为有用的路径，并在浏览器中呈现出logo。
- en: 'Finally, we export the default class, `App`, which can then be imported by
    other applications:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导出默认类`App`，其他应用程序可以导入它：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Quickly, since there's not a lot that we actually do with it, let's take a look
    at `index.js`. This will show us how the application gets loaded.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览一下`index.js`，因为我们实际上没有做太多事情，这将展示应用程序如何加载。
- en: There are several ES6 module imports at the top of the file. React and ReactDOM
    are core, driving the basic React library and adding in the ReactDOM interface.
    They drive the majority of what we're going to do with this little demo.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部有几个ES6模块导入。React和ReactDOM是核心，驱动基本的React库并添加ReactDOM接口。它们主要驱动我们在这个小演示中要做的大部分工作。
- en: The imports also include the `index.css` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 导入还包括`index.css`文件。
- en: 'Other than that, we import two pieces of JavaScript: `App`, which is the module
    we''re going to do our work in, and the previously mentioned `registerServiceWorker`,
    which we won''t work with at all.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还导入了两个JavaScript模块：`App`，这是我们要进行工作的模块，以及之前提到的`registerServiceWorker`，我们将完全不使用它。
- en: 'Once everything is imported, we run two small functions. `ReactDOM.render`
    is called with two arguments, `<App />`, indicating the custom element created
    by the App component, and `document.getElementById("root")`, which indicates the
    node that should receive the new element:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有内容都被导入，我们运行两个小函数。`ReactDOM.render`被调用时带有两个参数，`<App />`表示由App组件创建的自定义元素，`document.getElementById("root")`表示应接收新元素的节点：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we've taken a quick look at the basic React architecture, let's take
    a look at our demo.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速浏览了基本的React架构，让我们来看看我们的演示。
- en: 'In addition to the basic React app, Bootstrap is also installed into this project
    by running the following command. We are going to do another version of the simple
    form / SVG demo we''ve been doing and it makes sense to continue to use the same
    markup:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的React应用程序之外，Bootstrap也通过运行以下命令安装到该项目中。我们将继续使用相同的标记来做另一个简单的表单/SVG演示，这是有道理的：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's look at our `App.js`. It starts with a couple of import statements. We
    pull in `React` and `component` from React. Then we pull in two CSS files, our
    own custom `App.css` and the `Bootstrap CSS` we just installed, linking to the
    files in the project's `node_modules`. Finally, we import our standalone `ReactRect`
    component from the `rect` module.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`App.js`。它以几个导入语句开始。我们从React中导入`React`和`component`。然后我们导入两个CSS文件，我们自己的自定义`App.css`和刚刚安装的`Bootstrap
    CSS`，链接到项目的`node_modules`中的文件。最后，我们从`rect`模块导入我们独立的`ReactRect`组件。
- en: Then we have the `App` class definition. It's really got just a couple of things
    going on. In the constructor, we create a base `state` object with default values
    of our standard SVG properties, `cx`, `cy`, `r`, and `color`.  And then we set
    a method, `handleChange`, to handle changes to the underlying model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`App`类的定义。它实际上只有几件事情。在构造函数中，我们创建一个基本的`state`对象，其中包含我们标准SVG属性`cx`、`cy`、`r`和`color`的默认值。然后我们设置一个方法`handleChange`来处理对底层模型的更改。
- en: The method is simple. It takes the `event` object in, creates a `target` constant
    with the `event.target`, and then further inspects that object to get the `name`
    and `value` of the input. It then uses the method `setState` (inherited from `props`)
    to set the value of the application's state.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很简单。它接收`event`对象，创建一个`target`常量，然后进一步检查该对象以获取输入的`name`和`value`。然后它使用`setState`方法（从`props`继承）来设置应用程序状态的值。
- en: Following that is the `render` function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`render`函数。
- en: Looking through it you'll notice there's not much that you need to do to get
    React to properly render the SVG.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览一下，您会注意到您不需要做太多工作就可以让React正确地呈现SVG。
- en: First we set local variables for the various properties using the ES6 destructuring
    assignment pattern. Once those variables are set it's a simple matter of adding
    the variables that we need to have interpreted by React into bracket pairs `{}`
    in the appropriate attribute. The variable references in both the SVG elements
    and the form inputs are handled exactly the same way and don't require any special
    handling.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用ES6解构赋值模式为各种属性设置本地变量。一旦这些变量设置好了，只需将需要由React解释的变量添加到适当属性的大括号`{}`中。SVG元素和表单输入中的变量引用以相同的方式处理，不需要任何特殊处理。
- en: We simply bind the `handleChange` method to the `onChange` event, directly in
    the markup, and everything behaves as expected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将`handleChange`方法直接绑定到标记中的`onChange`事件，一切都会如预期般运行。
- en: '`ReactRect`, which we imported, is added to the SVG element. React handles
    importing that component, which we''ll see shortly, and rendering it into the
    document:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的`ReactRect`被添加到SVG元素中。React负责导入该组件，我们很快就会看到它，并将其呈现到文档中。
- en: Custom components need to start with a capital letter. Markup starting with
    a lowercase letter is interpreted as an HTML element.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义组件需要以大写字母开头。以小写字母开头的标记被解释为HTML元素。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our custom element is very simple. It''s just a plain React component that
    returns our `rect` element:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义元素非常简单。它只是一个简单的React组件，返回我们的`rect`元素：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, working with dynamic SVG and React is very straightforward.
    There was a concerted effort by the React team to ensure that SVG elements and
    attributes all worked, so this is down to their hard work. Thanks, React team!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用动态SVG和React非常简单。React团队努力确保SVG元素和属性都能正常工作，因此这归功于他们的辛勤工作。谢谢，React团队！
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you worked with four common libraries and frameworks, integrating
    these powerful tools with SVG.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用四个常见的库和框架，将这些强大的工具与SVG集成在一起。
- en: Starting with jQuery and working your way through AngularJS, Angular, and React,
    you now have basic experience at integrating SVG with four of the most popular
    libraries and frameworks on the planet.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从jQuery开始，通过AngularJS、Angular和React，您现在具有将SVG与地球上四个最受欢迎的库和框架之一集成的基本经验。
- en: Specifically, you learned about setting up applications with each of the frameworks,
    how to create dynamic components that feature SVG elements and attributes, and
    how to manipulate those attributes in a dynamic way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，您学习了如何使用每个框架设置应用程序，如何创建具有SVG元素和属性的动态组件，以及如何以动态方式操纵这些属性。
- en: You also learned about the multiple gotchas when working with SVG and these
    libraries, including ways to ensure that elements are created properly in jQuery
    and ensuring that dynamic attributes are properly handled in the Angular frameworks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还了解了在使用SVG和这些库时的多个注意事项，包括确保元素在jQuery中正确创建以及确保在Angular框架中正确处理动态属性的方法。
