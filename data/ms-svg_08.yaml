- en: SVG Animation and Visualizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG动画和可视化
- en: 'This chapter addresses the most dynamic and impressive use case for SVG: using
    SVG for data visualizations and animations. The tools you''ve already learned
    about, SVG, JavaScript, and CSS, and some new tools, will come together to create
    powerful options for you to build dynamic sites and applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章讨论了SVG的最具动态和令人印象深刻的用例：使用SVG进行数据可视化和动画。您已经了解的工具，SVG、JavaScript和CSS，以及一些新工具，将汇集在一起，为您构建动态站点和应用程序提供强大的选择。
- en: 'In this chapter, we''ll learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学到以下内容：
- en: How to produce a static data visualization using SVG, JavaScript, and structured
    data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用SVG、JavaScript和结构化数据生成静态数据可视化
- en: An overview of the general techniques for animating SVG
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画SVG的一般技术概述
- en: Animating SVG with Vivus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vivus对SVG进行动画处理
- en: Animation with GSAP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GSAP进行动画
- en: After working through the examples in this chapter, you'll be able to create
    animations and data visualizations with SVG and will know about two of the best
    tools for working with SVG and animation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章中的示例后，您将能够使用SVG创建动画和数据可视化，并了解使用SVG和动画的两种最佳工具。
- en: Let's dive right in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Creating an SVG data visualization
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SVG数据可视化
- en: This first section is going to focus on putting together a basic data visualization
    using SVG and JavaScript. This particular visualization will focus on an illustration,
    the positive/negative variance from an average. In this case, it will illustrate
    the number of home runs hits, per season, by the baseball player David Ortiz in
    his career with the Boston Red Sox compared with his average number of home runs
    over his Red Sox career.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将专注于使用SVG和JavaScript组合基本数据可视化。这个特定的可视化将关注一个插图，即相对于平均值的正/负差异。在这种情况下，它将说明棒球选手大卫·奥尔蒂兹在波士顿红袜队生涯中每个赛季击出的本垒打数量与他在红袜队生涯中的平均本垒打数量的比较。
- en: From 2003 until 2016 David Ortiz hit a minimum of 23 and a maximum of 54 home
    runs in a season while playing for the Red Sox. He averaged 34.5 per season. This
    visualization will show the relative positive/negative variance of his home run
    totals for every year against that 34.5 average. Years in which he hit more than
    the average will be in green. Years, where he hit less, will be in red.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从2003年到2016年，大卫·奥尔蒂兹在为红袜队效力期间，每个赛季最少击出23个本垒打，最多击出54个。他的平均每个赛季34.5个。这个可视化将展示他每年本垒打总数相对于34.5平均值的正/负差异。他击出比平均值多的年份将以绿色显示。击出比平均值少的年份将以红色显示。
- en: 'The steps we''ll need to go through are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要经历的步骤如下：
- en: We will take the data and get the total number of years, the total number of
    home runs, and then calculate the average.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将获取数据并计算总年数、总本垒打数量，然后计算平均值。
- en: We will loop through the data and calculate the positive/negative offset for
    each year.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将循环遍历数据，并计算每年的正/负偏移量。
- en: We will calculate some metrics based on the available screen real estate.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将根据可用的屏幕空间计算一些指标。
- en: We will draw a baseline, centered vertically on the screen.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在屏幕上垂直居中绘制一个基准线。
- en: We will draw a series of rectangles in the appropriate place, with the appropriate
    height to indicate the positive/negative variance, along with some simple labels
    indicating the year and number of home runs.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在适当的位置绘制一系列矩形，其高度适当以指示正/负的差异，以及一些简单的标签指示年份和本垒打的数量。
- en: We will add a legend indicating the average number of home runs and number of
    years.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个图例，指示本垒打的平均数量和年数。
- en: 'The final visualization will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的可视化将如下所示：
- en: '![](img/eb90380e-2dd8-4c7d-92a3-facb795e4e45.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb90380e-2dd8-4c7d-92a3-facb795e4e45.png)'
- en: Now that we have the basics planned out, let's look at how this works in detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计划好了基础知识，让我们详细看看这是如何工作的。
- en: 'We''ll start with the markup, which is very simple. We first include Bootstrap
    and the Raleway font as part of our standard template. Following that, we set
    the background of the SVG element and set the font family, size, and color of
    two different types of text element. Then we just include the target SVG element
    and the JavaScript file that runs the visualization:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从标记开始，这非常简单。我们首先包括Bootstrap和Raleway字体作为我们标准模板的一部分。然后，我们设置SVG元素的背景，并设置两种不同类型文本元素的字体系列、大小和颜色。然后我们只需包括目标SVG元素和运行可视化的JavaScript文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The included JavaScript file is where the real work is done.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的JavaScript文件是真正的工作所在。
- en: This JavaScript file is written using several ES6 features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JavaScript文件使用了几个ES6特性。
- en: '`scripts.js` itself is basically one large function, `viz`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts.js`本身基本上是一个大函数，`viz`。'
- en: 'At the top of `viz` we have the `data` variable. This variable is an array
    of JavaScript objects. Each object has two properties, `year` and `hrs`, indicating
    the year in question and the number of home runs Ortiz hit that year:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`viz`的顶部，我们有`data`变量。这个变量是一个JavaScript对象数组。每个对象都有两个属性，`year`和`hrs`，表示相关年份和奥尔蒂兹在那一年击出的本垒打数量：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you were running this visualization interactively, either accepting input
    from a user or inserting the result of a web service call to a statistical database
    into the visualization, you would just need to have the right structure (an array
    of objects) and format (`hrs` and `year`) and everything else would work itself
    out. Keep that in mind as we look at the variables and methods that populate the
    rest of the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在交互式地运行此可视化，要么接受用户的输入，要么将Web服务调用的结果插入到可视化中，您只需要具有正确的结构（对象数组）和格式（`hrs`和`year`），其他一切都会自动完成。在查看填充文件的其余变量和方法时，请记住这一点。
- en: 'Starting after `data`, there are several different variables we set that we''ll
    use, in addition to `data`, throughout the visualization:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从`data`开始，我们设置了几个不同的变量，我们将在可视化过程中使用，除了`data`之外：
- en: '`doc`: A reference to the document'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc`：对文档的引用'
- en: '`canvas`: A reference the SVG element with an `id` of `#canvas`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas`：引用具有`id`为`#canvas`的SVG元素'
- en: '`NS`: A reference to the namespace derived from the `SVG` element'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NS`：从`SVG`元素派生的命名空间的引用'
- en: '`elem`: A placeholder variable for the elements we''ll create'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elem`：我们将创建的元素的占位符变量'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next up are several utility methods we use to populate the visualization with
    values and elements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们用来填充可视化值和元素的几个实用方法。
- en: The first, `addText`, lets us add the text labels to the visualization. It takes
    in a coordinates object, `coords`, the `text` to be entered, and then finally
    an optional CSS class, `cssClass`. We'll explore the use case for the CSS class
    argument in one of the examples. The first two arguments should be straightforward
    and are required.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`addText`让我们可以向可视化添加文本标签。它接受一个坐标对象`coords`，要输入的`text`，最后是一个可选的CSS类`cssClass`。我们将在一个示例中探讨CSS类参数的用例。前两个参数应该很简单，是必需的。
- en: Following `addText`, there is an `addLine` function that allows us to draw lines
    on the screen. It takes a coordinates object, `coords` (which in this case contains
    four coordinates) and an optional `stroke` color. You'll notice that the `stroke`
    is created with a default value in the function signature. If there is no stroke
    color provided, the `stroke` will be `#ff8000`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addText`之后，有一个`addLine`函数，它允许我们在屏幕上绘制线条。它接受一个坐标对象`coords`（在这种情况下包含四个坐标）和一个可选的`stroke`颜色。您会注意到`stroke`在函数签名中创建了一个默认值。如果没有提供描边颜色，`stroke`将是`#ff8000`。
- en: Next up is the `addRect` function that allows us to add rectangles to the screen.
    It accepts a coordinates object, `coords`, which contains `height` and `width`
    properties, as well as optional `stroke` and `fill` colors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`addRect`函数，它允许我们向屏幕添加矩形。它接受一个坐标对象`coords`，其中包含`height`和`width`属性，以及可选的`stroke`和`fill`颜色。
- en: 'Finally, there''s a function, `maxDiffer`, which figures out the maximum difference
    between a set of positive/negative numbers. Getting this range and then using
    this maximum difference ensures that no matter how the numbers are spread, the
    maximum height needed above or below the baseline will fit into the screen:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个函数`maxDiffer`，它计算出一组正负数之间的最大差值。获取这个范围，然后使用这个最大差确保无论数字如何分布，基线上方或下方所需的最大高度都能适应屏幕：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After those utility functions, we have the code that defines the heart of the
    visualization. It happens in a function that runs on the `DOMContentLoaded` event.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些实用函数之后，我们有定义可视化核心的代码。它发生在一个在`DOMContentLoaded`事件上运行的函数中。
- en: 'As the function runs, we create multiple variables, holding different properties
    that we need to generate the visualization. Here''s what they do:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数运行时，我们创建多个变量，保存我们需要生成可视化的不同属性。以下是它们的作用：
- en: '`viewBox` is a local reference to the SVG element''s `viewBox`. We store this
    and the following DOM references locally so that we can save on the number of
    DOM lookups of the `viewBox`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewBox`是SVG元素`viewBox`的本地引用。我们将这个和后续的DOM引用存储在本地，这样我们就可以节省`viewBox`的DOM查找次数。'
- en: '`width` is a local reference to the width from the SVG element''s `viewBox`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`是对SVG元素`viewBox`中宽度的本地引用。'
- en: '`height` is a local reference to the `height` from the `viewBox`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`是对`viewBox`中`height`的本地引用。'
- en: '`x` is a local reference to the `x` point from the `viewBox`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`是对`viewBox`中`x`点的本地引用。'
- en: '`y` is a local reference to the `y` point from the `viewBox`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`是对`viewBox`中`y`点的本地引用。'
- en: '`padding` is an arbitrary constant that creates several padding calculations.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding`是一个任意的常数，用于创建几个填充计算。'
- en: '`vizWidth` defines the visible width of the SVG canvas. This defines the area
    in which we can safely draw elements into the SVG element.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vizWidth`定义了SVG画布的可见宽度。这定义了我们可以安全地将元素绘制到SVG元素中的区域。'
- en: '`years` is a reference to the number of years in the data set.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`years`是数据集中的年数的引用。'
- en: '`total` is a calculated value that represents the total number of home runs
    hit over the full data set.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total`是一个计算出的值，代表整个数据集中击出的全垒打总数。'
- en: '`avg` is the average number of home runs hit per year, calculated by dividing
    the `total` by the number of `years`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`avg`是每年击出的全垒打的平均数，通过将`total`除以`years`得出。'
- en: '`verticalMidPoint` represents the vertical mid-point of the SVG element. This
    is the line on which positive or negative variances are drawn.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verticalMidPoint`表示SVG元素的垂直中点。这是正负差异绘制的基准线。'
- en: '`diffs` is an array holding the positive and negative difference between the
    average number of home runs and the number of home runs hit in every year.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`diffs`是一个数组，保存了每年击出的全垒打平均数和实际击出的全垒打数之间的正负差异。'
- en: '`maxDiff` is the maximum difference between the average number of home runs
    and the number of home runs hit in a given year.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxDiff`是每年击出的全垒打的平均数和实际击出的全垒打数之间的最大差异。'
- en: '`yInterval` is the number of pixels per home run. This ensures that the boxes
    scale properly, vertically, based on the number of home runs hit in any given
    year.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yInterval`是每个全垒打的像素数。这确保了方框在垂直方向上根据每年击出的全垒打数正确地进行缩放。'
- en: '`xInterval` is the number of pixels per year. This value allows us to evenly
    space boxes no matter how many years are in the data set:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xInterval`是每年的像素数。这个值允许我们均匀地在SVG元素中放置方框，无论数据集中有多少年：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Following the creation of all those variables, we get to the business of drawing
    the different boxes and adding the labels. To do so, we use a `for...in` loop
    to loop through the array of `diffs`, doing two calculations that create two new
    variables, the `newX` and the `newY`. The `newX` is a regular interval based on
    the value of `i` multiplied by the `intervalX` variable we previously created.
    The `newY` variable is calculated by multiplying the value of `diffs[i]`, the
    current diff, by the `yInterval` constant. This gives us a distance to use to
    calculate the height of the rectangle in order to represent the number of home
    runs in each year.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建所有这些变量之后，我们开始绘制不同的框并添加标签。为此，我们使用`for...in`循环来循环遍历`diffs`数组，进行两个计算以创建两个新变量`newX`和`newY`。`newX`是基于`i`的值乘以我们之前创建的`intervalX`变量的常规间隔。`newY`变量是通过将`diffs[i]`的值（当前差异）乘以`yInterval`常量来计算的。这为我们提供了一个距离，用于计算矩形的高度，以表示每年的本垒打数量。
- en: Next, we test whether or not the current `diff` is greater or less than zero.
    If it's greater than zero, we want to draw a box that goes up from the `verticalMidPoint`.
    If the current `diff` is less than zero, then we draw a box that goes `down` from
    the `verticalMidPoint`. Since the direction of the rectangle and the associated
    anchor points for the box are different in each case, we need to handle them differently.
    We will also use different colors for the two variations in order to highlight
    the differences with a secondary indication.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试当前`diff`是否大于或小于零。如果大于零，我们希望绘制一个从`verticalMidPoint`向上的框。如果当前`diff`小于零，则我们绘制一个从`verticalMidPoint`向下的框。由于矩形的方向和相关的锚点在每种情况下都不同，我们需要以不同的方式处理它们。我们还将使用不同的颜色来突出显示这两种变化，以便进行次要指示。
- en: While there are differences between the two branches of this `if`, both branches
    call `addRect` and `addText`. Let's look at the similarities and the differences
    between the two branches of the `if`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个`if`的两个分支之间存在差异，但两个分支都调用了`addRect`和`addText`。让我们看看`if`的两个分支之间的相似之处和差异之处。
- en: For starters, each call to `addRect` follows the same pattern for the `x` and
    `width` properties. `x` is always the `newX` value added to the `padding` and
    the `width` is the `xInterval` value plus the `padding`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每次调用`addRect`都遵循相同的模式，对于`x`和`width`属性。`x`始终是`newX`值加上`padding`，而`width`是`xInterval`值加上`padding`。
- en: The `y` and `height` values are handled differently by the two branches.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`和`height`值由两个分支处理。'
- en: If the current difference is less than zero, then the new `y` coordinate is
    `verticalMidpoint`. This anchors the top of the box to the line that represents
    zero on the visualization and indicates that the box will hang below that line.
    If the current difference is greater than zero, then the `y` coordinate is set
    to be `verticalMidPoint` minus the `newY`. This sets the top of the new rectangle
    to be the value of `newY` abovethe line that indicates zero.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前差异小于零，则新的`y`坐标为`verticalMidpoint`。这将使框的顶部锚定在可视化中表示零的线上，并指示框将悬挂在该线下方。如果当前差异大于零，则`y`坐标设置为`verticalMidPoint`减去`newY`。这将使新矩形的顶部值为`newY`在表示零的线上方。
- en: The `height`, if the current difference is less than zero, is the `newY` value
    passed into `Math.abs()`. You can't pass in a negative value to an SVG element,
    so the negative value needs to be converted to a positive value using `Math.abs()`.
    The `height`, in the case of a current diff, that's greater than zero, is just
    the `newY` value, since it's already a positive number.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前差异小于零，则`height`是传入`Math.abs()`的`newY`值。无法向SVG元素传递负值，因此需要使用`Math.abs()`将负值转换为正值。如果当前差异大于零，则`height`就是`newY`值，因为它已经是正数。
- en: The calls to `addText` in each branch of the `if` diverge on the placement of
    the `y` point. If the `newY` value is negative, then, once again, `Math.abs` has
    to convert the  `newY` value to a positive number. Otherwise, it's passed through
    unchanged.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`的每个分支中调用`addText`的位置不同。如果`newY`值为负数，则再次使用`Math.abs`将`newY`值转换为正数。否则，保持不变。
- en: Following that, we add the zero line to the vertical mid-point with a call to
    `addLine`. The arguments passed in are the unchanged  `x` and `width` from the
    `viewBox` for the leftmost and rightmost points and `verticalMidpint` for the
    `y` value for both points
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们使用`addLine`调用将零线添加到垂直中点。传入的参数是`viewBox`的未更改的`x`和`width`，左右两个点的`verticalMidpint`作为`y`值。
- en: Finally we add a little bit of text that explains the basics of the visualization.
    Here is where we use the optional `cssClass` argument to `addLine`, passing in
    `large` so that we can make slightly larger text. The `x` and `y` arguments leverage
    the `x` and `height` variables along with the `padding` variable to place the
    text slightly off the bottom left edge of the SVG element.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一些解释可视化基础知识的文本。在这里，我们使用了`cssClass`参数可选项来调用`addLine`，传入`large`，以便我们可以制作稍大一些的文本。`x`和`y`参数利用了`x`和`height`变量以及`padding`变量，将文本放置在SVG元素的左下角略微偏移。
- en: 'The final line of code simply calls the `viz()` function to kick off the visualization:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码只是调用`viz()`函数来启动可视化。
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If this were a visualization destined for production, or for more general-purpose
    use, then there are still things that we'd want to do with it. Eagle-eyed readers
    will spot that we don't actually deal with the case where the number of home runs
    exactly equals the average number of home runs, for example. That said, for the
    purposes of this book, the detail here is enough to illustrate how one works with
    JavaScript, SVG, and data to tell the story of a data-set visually.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个用于生产或更通用用途的可视化，那么我们仍然需要对其进行一些处理。敏锐的读者会发现，我们实际上并没有处理本垒打数量恰好等于平均本垒打数量的情况，例如。也就是说，对于本书的目的，这里的细节足以说明如何使用JavaScript、SVG和数据来以可视化的方式讲述数据集的故事。
- en: Now that we've looked at static visualizations, let's look at adding some movement
    to the screen. The next section will deal with multiple ways in which you can
    animate SVG in the browser.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过静态可视化了，让我们来看一下如何在屏幕上添加一些动作。下一节将介绍在浏览器中可以对SVG进行动画的多种方式。
- en: General techniques for animating SVG
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画SVG的一般技术
- en: This section will introduce various general techniques for animating SVG. While
    there are different tools available to do this work (you'll meet two later on
    in this chapter), it's useful to know how these things are done without the aid
    of frameworks or libraries. This section will provide that foundation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍各种用于动画SVG的一般技术。虽然有不同的工具可用于完成这项工作（您将在本章后面遇到两种），但了解在没有框架或库的帮助下如何完成这些工作是很有用的。本节将提供这方面的基础知识。
- en: You've already previously seen some of these techniques, but it's good to look
    at them again, solely in the context of animation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前已经看到了一些这些技术，但是在动画的上下文中再次查看它们是很好的。
- en: Animating with pure JavaScript
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯JavaScript进行动画
- en: Before there were CSS keyframe animations and CSS transitions, two techniques
    we'll look at later in this chapter, we had to produce all of our animations and
    interesting effects in the browser by hand using JavaScript; updating properties
    in a loop and optimizing frame rates manually. Eventually, libraries such as jQuery
    came along and removed the need to know how this worked, by presenting animations
    as part of their API. Thankfully, these days, in addition to the animation methods
    available in your tool of choice, you can leverage CSS animations for many things
    we used to use JavaScript for so there's less and less need for people to learn
    these skills these days.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS关键帧动画和CSS过渡出现之前，我们不得不手动使用JavaScript在浏览器中制作所有动画和有趣的效果；在循环中更新属性并手动优化帧速率。最终，诸如jQuery之类的库出现并消除了对了解这些工作原理的需求，通过将动画作为其API的一部分呈现出来。幸运的是，如今，除了您选择的工具中可用的动画方法之外，您还可以利用CSS动画来完成许多以前需要使用JavaScript的事情，因此现在越来越少需要人们学习这些技能。
- en: That said, there are places where CSS animations won't cut it, so there's some
    benefit to seeing how it works under the hood and without the aid of a library.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有些地方CSS动画无法胜任，因此了解它在幕后如何工作并且不依赖库是有好处的。
- en: This simple animation will animate a circle element across an SVG element from
    left to right. We will need to calculate several metrics to create the animation,
    so even though it's simple, it will illustrate many of the challenges you might
    run into doing this sort of coding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的动画将会将一个圆形元素从左到右地在SVG元素上移动。我们需要计算几个指标来创建动画，所以即使它很简单，它也会说明你在编写这种代码时可能遇到的许多挑战。
- en: Let's look at the code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下代码。
- en: 'There is nothing of interest in the `head`, so let''s skip straight to the
    `body` of the page. The `body` has the standard Bootstrap markup we''ve been working
    with throughout the book. Inside the main `div`, we have an `SVG` element that
    contains a single `circle` element at `75, 225` with a `50`-pixel radius. It''s
    got an `id` of `circle`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`中没有任何有趣的内容，所以让我们直接跳到页面的`body`。`body`中有我们在整本书中一直使用的标准Bootstrap标记。在主`div`内部，我们有一个包含单个`circle`元素的`SVG`元素，位于`75,
    225`，半径为`50`像素。它的`id`是`circle`：'
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The JavaScript is straightforward.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript很简单。
- en: It consists of a single function added to the `DOMContentLoaded` event. That
    function does some familiar things. It creates local references to `doc`, `canvas`,
    and `circle` so that we can reference those elements easily throughout the animation. Following
    that there are several variables created to store properties of the `viewBox`: `viewBox`
    itself, `height`, `width`, and `x`. We then set two constants representing the
    number of `seconds` for the animation to run and the number of **frames per second**
    (**fps**) we're aiming for with our animation).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括一个添加到`DOMContentLoaded`事件的函数。该函数执行一些熟悉的操作。它创建了对`doc`、`canvas`和`circle`的本地引用，以便我们可以在整个动画过程中轻松地引用这些元素。接下来创建了几个变量来存储`viewBox`的属性：`viewBox`本身，`height`，`width`和`x`。然后设置了两个常量，表示动画运行的秒数和我们动画的**每秒帧数**（**fps**）。
- en: Following that we grab the current `x` value of the circle element as a variable, `currX`. 
    After that we calculate the ending point, `newX`, by using the radius of the circle
    and multiplying it by 3\. That gives us a comfortable ending point, visually.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将当前圆形元素的`x`值作为变量`currX`。然后计算结束点`newX`，通过使用圆的半径乘以3来计算。这给我们一个舒适的结束点，视觉上。
- en: Next we create some variables to run the animation. The first, `diffX`, is a
    calculation of the difference between the current `x` value and the target, `newX`,
    value. Then we take the `diffX`, divide it by the number of seconds, and multiply
    it by the number of frames per second. This will create three seconds' worth of
    intervals to animate by.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一些变量来运行动画。首先，`diffX`是当前`x`值和目标`newX`值之间的差值的计算。然后我们将`diffX`除以秒数，再乘以每秒帧数。这将创建三秒的间隔来进行动画。
- en: Finally we create the animated variable, `animX`, which is the variable we will
    work with in every frame as we animate the element across the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了动画变量`animX`，这是我们在每一帧中将要处理的变量，因为我们要将元素动画移动到屏幕上。
- en: Following that, there's a function that adjusts the position of the element
    on the screen every frame. It does three things. It adds the interval to the `animX`
    to move the element over by that calculated interval. It then sets the `cx` property
    of the element, moving it to its new position. Finally it calls itself recursively
    using `window.requestAnimationFrame`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有一个函数会在每一帧调整元素在屏幕上的位置。它有三个作用。它将间隔添加到`animX`上，以通过计算的间隔移动元素。然后设置元素的`cx`属性，将其移动到新位置。最后，使用`window.requestAnimationFrame`递归调用自身。
- en: '`requestAnimationFrame` is a method that allows the browser to optimize the
    way that JavaScript animations are drawn onto the screen. The number of frames
    per second it''s optimized to is usually `60`, but technically it will match the
    display refresh rate of the device.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`是一种允许浏览器优化JavaScript动画绘制到屏幕上的方法。它通常优化到每秒`60`帧，但从技术上讲，它将匹配设备的显示刷新率。'
- en: 'All of that takes place inside an `if` block that stops the animation when
    it has completed. If `animX` is less than `newX`, then the code executes, calling
    `animate` again to kick off the next frame. If `animX`  is greater than or equal
    to `newX`, then the animation stops:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都发生在一个`if`块内，当动画完成时停止动画。如果`animX`小于`newX`，则执行代码，再次调用`animate`来启动下一帧。如果`animX`大于或等于`newX`，则动画停止：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This isn't the most complicated animation, but using `window.requestAnimationFrame`
    means that it looks pretty good in the browser.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最复杂的动画，但使用`window.requestAnimationFrame`意味着在浏览器中看起来相当不错。
- en: While there are other options for animating SVG, and you should learn about
    them and use them where appropriate, JavaScript is going to be the most powerful
    and ultimately the most flexible option out there. If your animation needs to
    work across the most possible browsers, then you're going to want to use JavaScript.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有其他选项可以对SVG进行动画，你应该了解它们并在适当的地方使用它们，但JavaScript将是最强大且最灵活的选择。如果你的动画需要在尽可能多的浏览器中运行，那么你需要使用JavaScript。
- en: The good news is, as you'll see later on in the chapter, there are excellent
    tools to simplify animating with JavaScript.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，正如你将在本章后面看到的，有很好的工具可以简化使用JavaScript进行动画。
- en: 'Before we look at the first of several JavaScript libraries for working with
    SVG, let''s look at the two other options for animating SVG, using core web technologies:
    CSS, and SMIL.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看几个用于处理SVG的JavaScript库之前，让我们看一下使用核心Web技术对SVG进行动画的另外两个选项：CSS和SMIL。
- en: Animating with CSS
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS进行动画
- en: Animating SVG with CSS is straightforward in that it works the same way that
    CSS animations and transitions work with regular HTML elements. You define some
    CSS properties and, depending on whether or not you're using keyframe animation
    or transitions, you create specific CSS rules that handle how they are rendered
    over a period of time. The problem with the idea of that process being straightforward
    is that only presentation attributes, which drive much of SVG, that are also available
    as CSS properties can be manipulated with CSS.  As you can see on the following
    website, the list, as defined in SVG 1.1, is missing many important properties: [https://www.w3.org/TR/SVG/propidx.html](https://www.w3.org/TR/SVG/propidx.html).
    SVG 2.0 adds many more properties, but support for those new properties is not
    universal and, unfortunately, there isn't a proper compendium of what properties
    are supported where.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS对SVG进行动画是直接的，它的工作方式与CSS动画和过渡与常规HTML元素的工作方式相同。你定义一些CSS属性，根据你是否使用关键帧动画或过渡，你创建特定的CSS规则来处理它们在一段时间内的渲染。这个过程的问题在于，只有演示属性，它们驱动了SVG的许多内容，也可以作为CSS属性使用，才能用CSS进行操作。正如你在下面的网站上看到的，根据SVG
    1.1的定义，缺少许多重要的属性：[https://www.w3.org/TR/SVG/propidx.html](https://www.w3.org/TR/SVG/propidx.html)。SVG
    2.0添加了更多属性，但对这些新属性的支持并不是普遍的，不幸的是，没有一个适当的手册来说明哪些属性在哪里得到支持。
- en: In other words, there are some potential rough edges using these technologies,
    depending on what your browser support matrix looks like.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，根据你的浏览器支持矩阵的情况，使用这些技术可能会有一些潜在的问题。
- en: Anyway, even with that somewhat rough story, it's still worth seeing these techniques
    in action.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，即使有这样一个有些粗糙的故事，看到这些技术的实际应用仍然是值得的。
- en: There are three examples here. Two show animations similar to the previous JavaScript
    animation; they move a blue circle across the screen. They're implemented in two
    different ways. This illustrates the implementation differences you might see
    depending on what browsers you're targeting. The first example uses CSS transforms
    and CSS animation to translate the element across the screen. This technique has
    broader browser support. The second example uses the simpler approach of setting
    a transition on the `cx` property and then changing the value on hover of the
    SVG element. `cx` is available as a CSS property in Chrome, so in that browser
    this is the easier approach.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个例子。两个显示了类似于之前的JavaScript动画的动画；它们将一个蓝色圆圈移动到屏幕上。它们以两种不同的方式实现。这说明了根据你的目标浏览器的不同，你可能会看到实现上的差异。第一个例子使用CSS变换和CSS动画来将元素沿屏幕移动。这种技术具有更广泛的浏览器支持。第二个例子使用更简单的方法，在SVG元素悬停时设置`cx`属性的过渡，然后更改值。在Chrome中，`cx`作为CSS属性可用，因此在该浏览器中，这是更简单的方法。
- en: The third example shows a transition on the `fill` on an element, to illustrate
    an example where leaving the calculations to the browser and CSS is of great benefit.
    If it's not clear how you would animate from one color value to another, then
    you can probably see at least one great use case for leaving the heavy lifting
    to the browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子展示了元素上`fill`的过渡，以说明在这种情况下将计算留给浏览器和CSS是非常有益的一个例子。如果不清楚如何从一个颜色值动画到另一个颜色值，那么你可能至少能看到一个将繁重的工作留给浏览器的绝佳用例。
- en: Let's look at the examples in order.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序看一下这些例子。
- en: 'The first example is simple. In it, we have the same markup as the previous
    JavaScript example, with one exception: setting the `cx` property via CSS. We
    do that in the `#circle` selector in the `head` of the document.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子很简单。在这个例子中，我们有与之前的JavaScript例子相同的标记，只有一个例外：通过CSS设置`cx`属性。我们在文档的`head`中的`#circle`选择器中这样做。
- en: 'Additionally, we set a `transition` property on that selector, watching the
    `cx` property for changes and transitioning for three seconds when it changes.
    In the next selector, `svg:hover #circle`, we trigger the animation via a hover
    event on the parent SVG element, which sets the `cx` value to the final destination,
    `875` pixels.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我们在该选择器上设置了一个`transition`属性，监视`cx`属性的变化，并在其变化时进行三秒的过渡。在下一个选择器`svg:hover
    #circle`中，我们通过父SVG元素上的悬停事件触发动画，将`cx`值设置为最终目的地`875`像素。'
- en: 'With this CSS in place, when you mouse over the SVG element, the new `cx` is
    set and the browser will animate across the screen between `75` and `875` pixels
    on the *x* axis of the SVG element:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个CSS，当你在SVG元素上悬停鼠标时，新的`cx`被设置，浏览器将在SVG元素的*X*轴上在`75`和`875`像素之间进行动画处理：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This next example is set up similarly. It has exactly the same SVG markup as
    the previous example animated by JavaScript. The differences are once again in
    the CSS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子设置类似。它与前一个例子具有完全相同的SVG标记，并由JavaScript进行动画处理。区别再次在于CSS。
- en: 'There are two sections of interest. The first section defines a two-keyframe
    animation called `animate-circle`. The first keyframe, at `0%,` has a `0px` translation
    across the *X* axis, using `transform: translateX`. The second keyframe, at `100%`,
    increases that transformation to `800px`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '有两个感兴趣的部分。第一部分定义了一个名为`animate-circle`的两关键帧动画。第一个关键帧，在`0%`处，使用`transform: translateX`在*X*轴上进行`0px`的平移。第二个关键帧，在`100%`处，将该变换增加到`800px`。'
- en: Then, in the `#circle` selector, we define the `animation` property with the
    named animation, a duration of three seconds and linear easing. Then we set the
    `animation-fill-mode` to forwards, which indicates that the animation should run
    forwards once and complete, keeping the animated element at its final state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`#circle`选择器中，我们使用命名动画定义`animation`属性，持续时间为三秒，线性缓动。然后我们将`animation-fill-mode`设置为forwards，表示动画应该向前运行一次并完成，保持动画元素处于最终状态。
- en: 'When this runs, the circle smoothly animates across the screen:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个运行时，圆圈会平滑地在屏幕上进行动画处理：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The final example also uses transitions, this time animating the `fill` property
    from blue to red. This property is one of the earlier presentation properties
    defined as being available in CSS, so it's got better support in browsers than
    a property such as `cx` at this present time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子也使用了过渡，这次是将`fill`属性从蓝色动画到红色。这个属性是早期在CSS中定义为可用的演示属性之一，因此在当前时间，它在浏览器中的支持要比`cx`等属性好得多。
- en: The CSS definition is very simple. There's a `fill` property set on the `#circle` definition,
    alongside a `transition` that watches for changes to `fill` and transitions the
    change over a 2-second duration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CSS定义非常简单。在`#circle`定义上设置了一个`fill`属性，以及一个`transition`，用于监视`fill`的变化，并在2秒内进行过渡。
- en: 'In `#circle:hover` we change the `fill` to blue. Running it in a browser and
    hovering over the circle will animate the color of the circle element, without
    using anyJavaScript and without figuring out how to animate from one named color
    to another:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#circle:hover`中，我们将`fill`更改为蓝色。在浏览器中运行并悬停在圆圈上，将会使圆圈元素的颜色进行动画处理，而无需使用任何JavaScript，并且无需弄清楚如何从一个命名颜色动画到另一个。
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All of these examples are intentionally basic and as mentioned, browser support
    for them is weak (none work in versions of IE older than Edge, for example); but
    they remain powerful. If your browser matrix support leans toward the latest and
    greatest browsers, then you can have a lot of fun with CSS and SVG.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些例子都是故意基本的，正如前面提到的，它们的浏览器支持很弱（例如，在IE旧版本中都不起作用）；但它们仍然很强大。如果你的浏览器支持矩阵偏向于最新和最好的浏览器，那么你可以在CSS和SVG中玩得很开心。
- en: Animating SVG with SMIL
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SMIL对SVG进行动画处理
- en: Another interesting and powerful option for animating SVG has a similarly frustrating
    support matrix to CSS. SMIL isn't supported at all in Microsoft browsers and was
    even deprecated briefly by Chrome.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SVG动画的另一个有趣且强大的选项与CSS具有类似令人沮丧的支持矩阵。SMIL在Microsoft浏览器中根本不受支持，甚至曾一度被Chrome弃用。
- en: This is a shame, as there are some nice things about SMIL. It's a clear, declarative
    way to animate elements. It's not as powerful as JavaScript or as commonly used
    as a general-purpose technology like CSS, but it's still pretty great.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件遗憾的事，因为SMIL有一些很好的特点。它是一种清晰的、声明式的动画元素的方式。它不像JavaScript那样强大，也不像CSS那样常用作通用技术，但它仍然相当不错。
- en: Take a look at an example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看一个例子。
- en: 'In it, we have our now familiar markup: a simple `circle` on an otherwise blank
    SVG element. This time there''s one small twist. There is an `animate` element
    as a child of the `circle` element. The `animate` element is where the animation
    is defined. It has several attributes that we need to look at:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们有我们现在熟悉的标记：一个简单的`circle`在一个空的SVG元素上。这次有一个小小的变化。`animate`元素作为`circle`元素的子元素。`animate`元素是动画定义的地方。它有几个属性，我们需要看一下：
- en: The `xlink:href` attribute points to the `#circle` element that will be animated.
    The fact that the `animate` element is a child of the `circle` element automatically
    associates the animation with it. Using the `xlink:href` attribute ensures that
    the connection is precisely defined.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xlink:href`属性指向将要进行动画处理的`#circle`元素。`animate`元素是`circle`元素的子元素，这样就自动将动画与其关联起来。使用`xlink:href`属性可以确保连接被准确定义。'
- en: '`attributeName` defines the attribute that will be animated. In this case it''s
    the `cx` attribute.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributeName`定义将要进行动画处理的属性。在这种情况下，它是`cx`属性。'
- en: The `from` and `to` attributes indicate the beginning and endpoint of the animation.
    In this case we'll be moving from `"75"` to `"900"`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`和`to`属性表示动画的起点和终点。在这种情况下，我们将从`"75"`移动到`"900"`。'
- en: '`dur` indicates the duration of the animation. In this case,  it''s defined
    as `"3s"`, for three seconds.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dur`指示动画的持续时间。在这种情况下，它被定义为`"3s"`，持续三秒。'
- en: The `begin` attribute indicates when the animation should begin. This lets you
    delay the animation as needed. In our case we start the animation immediately
    with `"0s"`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin`属性指示动画应该何时开始。这让你可以根据需要延迟动画。在我们的例子中，我们立即开始动画，设置为`"0s"`。'
- en: The `fill` attribute, confusingly named the same as the common `fill` attribute,
    indicates whether or not the animated values should remain on the element after
    the animation concludes. This value, `"freeze"`, indicates that the element should
    remain frozen at the state it reaches at the end of the animation.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`属性，与常见的`fill`属性同名，表示动画值在动画结束后是否保留在元素上。这个值`"freeze"`表示元素应该在动画结束时保持在达到的状态上。'
- en: There seems no good reason why `fill` is overloaded to do two separate, basically
    unrelated, tasks in the context of SVG. It's unfortunate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在SVG的上下文中，似乎没有很好的理由将`fill`重载为执行两个基本不相关的任务。这很不幸。
- en: 'Running this in the browser creates a similar animation to the one we''ve seen
    in several instances in this chapter; the ball starts on the left and over the
    course of three seconds moves over to the right:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行这个动画会创建一个类似于本章中几个实例中看到的动画；球从左边开始，在三秒内移动到右边。
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we've looked at manual methods for data visualization and animation
    in SVG, let's look at some tools that will help with animating elements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了SVG中数据可视化和动画的手动方法，让我们来看一些可以帮助动画元素的工具。
- en: Animating SVG with Vivus
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vivus对SVG进行动画
- en: Vivus is a library that does one thing and does it really well ([https://maxwellito.github.io/vivus/](https://maxwellito.github.io/vivus/)).
    Vivus allows you to "draw" the stroke of an SVG element across a period of time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Vivus是一个只做一件事情并且做得非常好的库([https://maxwellito.github.io/vivus/](https://maxwellito.github.io/vivus/))。Vivus允许您在一段时间内“绘制”SVG元素的描边。
- en: The following series of screenshots show how that will look. It's a nice effect.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列截图展示了它的效果。这是一个很好的效果。
- en: '![](img/ed8a7cc6-8324-4d72-b7ea-194f55650f43.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed8a7cc6-8324-4d72-b7ea-194f55650f43.png)'
- en: As a note, the same illustration is used in three samples in this chapter. The
    code samples printed in the book truncate the `d` attribute of each path element
    in order to shorten the code sample to a manageable length. If you'd like to see
    the full sample, please refer to the code on GitHub ([https://github.com/roblarsen/mastering-svg-code](https://github.com/roblarsen/mastering-svg-code)[). ](https://github.com/roblarsen/mastering-svg-code)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，本章中的三个示例都使用了相同的插图。书中打印的代码示例截断了每个路径元素的`d`属性，以缩短代码示例的长度。如果您想看完整的示例，请参考GitHub上的代码([https://github.com/roblarsen/mastering-svg-code](https://github.com/roblarsen/mastering-svg-code)[)。 ](https://github.com/roblarsen/mastering-svg-code)
- en: As long as the `stroke` is set with a value and the `fill` is set to `none`,
    simply including the Vivus JavaScript file (in this case we do so by running `npm
    install` in the Vivus folder and then linking to the JavaScript file located in
    the `node_modules` folder) and then creating a new Vivus instance are all it takes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`stroke`设置了一个值并且`fill`设置为`none`，只需包含Vivus JavaScript文件（在这种情况下，我们通过在Vivus文件夹中运行`npm
    install`，然后链接到`node_modules`文件夹中的JavaScript文件来实现），然后创建一个新的Vivus实例就可以了。
- en: Creating a new Vivus instance is very easy. Using the `new` keyword you can
    instantiate a new Vivus object with two arguments. The first is the `id` of the
    SVG element. The second is the configuration object. In this case, we're passing
    in just one option, the `duration` argument, setting the duration of the animation
    to three seconds (3,000 milliseconds).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Vivus实例非常容易。使用`new`关键字，您可以用两个参数实例化一个新的Vivus对象。第一个是SVG元素的`id`。第二个是配置对象。在这种情况下，我们只传入一个选项，即`duration`参数，将动画的持续时间设置为三秒（3,000毫秒）。
- en: 'The following code sample shows just how easy it is to work with Vivus:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了使用Vivus有多么容易：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are other configuration options available to Vivus, you can find them
    here: [https://github.com/maxwellito/vivus#option-list](https://github.com/maxwellito/vivus#option-list).
    We won''t go through them all, but we will illustrate one more, one that will
    be very useful, that of running a callback function once the animation is completed.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Vivus还有其他配置选项，您可以在这里找到它们：[https://github.com/maxwellito/vivus#option-list](https://github.com/maxwellito/vivus#option-list)。我们不会全部讨论，但我们将说明另一个非常有用的选项，即在动画完成后运行回调函数。
- en: Everything about it is the same as the previous Vivus example, except we define
    a simple callback function, called `callback`, that goes through all instances
    of elements with the class `stroke` and changes their stroke to a different color.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们定义一个简单的回调函数`callback`，它遍历所有具有类`stroke`的元素的实例并将它们的描边更改为不同的颜色，其他都与之前的Vivus示例相同。
- en: 'The end result looks like the following screenshot. The text will be red once
    the animation completes and the callback function is executed:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果看起来像以下的截图。一旦动画完成并且回调函数执行，文本将变为红色：
- en: '![](img/9e79b6c5-b695-4721-8f6c-a5f78f63d1e2.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e79b6c5-b695-4721-8f6c-a5f78f63d1e2.png)'
- en: The callback function is passed in as an optional third argument to the Vivus
    constructor. It then executes when the animation is completed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数作为可选的第三个参数传递给Vivus构造函数。然后在动画完成时执行。
- en: 'The following code sample shows how that works:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了它是如何工作的：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we've looked at an animation library that does one thing, let's take
    a look at a more full-featured animation library, **GreenSock Animation Platform
    (GSAP)**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了一个只做一件事的动画库，让我们来看看一个更全面的动画库**GreenSock Animation Platform (GSAP)**。
- en: Animating SVG with GSAP
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GSAP对SVG进行动画
- en: GSAP is a set of powerful JavaScript tools for animation on the web. It works
    very well with SVG.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: GSAP是用于Web动画的一组强大的JavaScript工具。它与SVG非常配合。
- en: GSAP is a powerful set of tools and exploring all it has to offer in depth would
    spread across multiple chapters. *And that's just the free version*. There's also
    a premium version which includes even more features and functionality.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GSAP是一组强大的工具，深入探索它所提供的所有内容需要跨越多个章节。*这还只是免费版本*。还有一个高级版本，其中包括更多功能和功能。
- en: The good news is that, even though it's incredibly powerful, the GSAP API is
    straightforward, so once you find your desired feature and get a look at the strong
    documentation ([https://greensock.com/docs](https://greensock.com/docs)), you're
    going to be able to do a lot very quickly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，尽管它非常强大，但GSAP API很简单，所以一旦找到所需的功能并查看了强大的文档（[https://greensock.com/docs](https://greensock.com/docs)），您将能够非常快速地做很多事情。
- en: Let's take a look at two separate examples to give you an intro to the sort
    of things that GSAP can do and how it does them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看两个单独的示例，为您介绍GSAP可以做什么以及它是如何做到的。
- en: This first example replicates the same animation we've done several times so
    far in this chapter. We're moving a ball from one side of the SVG element to the
    other. This one actually uses some familiar code from the initial JavaScript example
    to calculate the finishing position.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个示例复制了我们在本章中已经做过几次的相同动画。我们将一个球从SVG元素的一边移动到另一边。这个实际上使用了最初JavaScript示例中的一些熟悉代码来计算最终位置。
- en: The markup is the same as we've seen several times so far. It's a `circle` element
    with an `id` of `circle` alone in an SVG element.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 标记与我们迄今为止看到的一样。它是一个SVG元素中的一个`circle`元素，带有`circle`的`id`。
- en: To get started using GSAP, we need to include their JavaScript in our demo.
    In this case, we're including the TweenMax script. Running `npm install` in the
    project folder will install GSAP and then we can include it from the project's
    `node_modules` folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用GSAP，我们需要在演示中包含他们的JavaScript。在这种情况下，我们包含了TweenMax脚本。在项目文件夹中运行`npm install`将安装GSAP，然后我们可以从项目的`node_modules`文件夹中包含它。
- en: 'There are two different Tween* modules that GSAP provides: `TweenLite` and
    `TweenMax`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: GSAP提供了两个不同的Tween*模块：`TweenLite`和`TweenMax`。
- en: 'They are described as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的描述如下：
- en: TweenLite is an extremely fast, lightweight, and flexible animation tool that
    serves as the foundation of the GSAP. A TweenLite instance handles tweening one
    or more properties of any object (or array of objects) over time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: TweenLite是一个非常快速，轻量级和灵活的动画工具，它是GSAP的基础。TweenLite实例处理任何对象（或对象数组）的一个或多个属性随时间的变化。
- en: TweenMax extends TweenLite, adding many useful (but non-essential) features
    like repeat(), repeatDelay(), yoyo(), and more. It also includes many extra plugins
    by default, making it extremely full-featured.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: TweenMax扩展了TweenLite，添加了许多有用（但非必要）的功能，如repeat()，repeatDelay()，yoyo()等。它还默认包含许多额外的插件，使其功能非常齐全。
- en: We'll use TweenMax for this demo. If you're going to start to experiment with
    GSAP, TweenMax is going to offer you the largest footprint of tools to work with
    right off the bat. It's slightly slower but it's more powerful, and while you're
    experimenting with it, it's going to be more fun to have everything at your fingertips.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此演示中使用TweenMax。如果您要开始尝试GSAP，TweenMax将为您提供最大的工具集。它稍微慢一些，但更强大，而且在您尝试使用它时，拥有一切都会更有趣。
- en: Now that we have the JavaScript file loaded, let's work with it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了JavaScript文件，让我们开始使用它。
- en: The JavaScript should look familiar, at least to start with. We set several
    familiar consts: `doc` as an alias for the `document`, `canvas` as a reference
    to the SVG element,  `circle` as a local reference to the circle we're going to
    animate, `viewBox` as a local reference for the `viewBox` of the SVG element,
    `width` for the `viewBox.width`, and `newX` for the calculated finish position
    of the circle element.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应该看起来很熟悉，至少起初是这样。我们设置了几个熟悉的常量：`doc`作为`document`的别名，`canvas`作为SVG元素的引用，`circle`作为我们要动画的圆的本地引用，`viewBox`作为SVG元素的`viewBox`的本地引用，`width`作为`viewBox.width`，`newX`作为圆元素的计算完成位置。
- en: 'The new GSAP-specific code follows as we call `TweenMax.to.`  `TweenMax.to` is
    a method that animates an HTML element to a certain state. The arguments are as
    follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: GSAP特定的新代码如下，当我们调用`TweenMax.to`时。`TweenMax.to`是一个方法，用于将HTML元素动画到特定状态。参数如下：
- en: '`"#circle"` is the CSS selector to use to match the element we''re going to
    animate.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"#circle"`是用于匹配我们要动画的元素的CSS选择器。'
- en: '`1` is the number of times the animation will run.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`是动画将运行的次数。'
- en: Finally, there is a configuration object to define the animation. In our example
    we're passing in the `newX` variable as the new value of the `cx` element.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，有一个配置对象来定义动画。在我们的示例中，我们将`newX`变量作为`cx`元素的新值传入。
- en: 'And that''s all it takes; GSAP handles the rest, smoothly animating the circle
    from one end of the screen to the other:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；GSAP处理剩下的部分，平滑地将圆圈从屏幕的一端移动到另一端：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This next example has the same setup, but changes the arguments that are passed
    into `TweenMax.to` and adds another chained method call to change the duration
    of the animation. In this example we pass in four separate attributes to animate
    the element against, `cx`, `cy`,  `r`, and `fill`.  This example illustrates one
    of the real powers of GSAP. You don't have to figure out anything about the timing
    of those multiple property animations, what the individual intervals look like,
    or how to sync them and parse them out so that they run smoothly. You just give
    GSAP an end state and watch it do its magic.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例具有相同的设置，但更改了传递到`TweenMax.to`的参数，并添加了另一个链接方法调用以更改动画的持续时间。在这个示例中，我们传入四个单独的属性来对元素进行动画处理，`cx`，`cy`，`r`和`fill`。这个示例展示了GSAP的真正力量之一。您不必弄清楚关于这些多个属性动画的时间，各个间隔的样子，或者如何同步它们并解析它们以使它们平稳运行。您只需给GSAP一个最终状态，然后观察它的魔力。
- en: 'Additionally, we''re adding a new method, chained to the end of the call to TweenMax.to.
    Calling `TweenMax.duration` changes the duration of the animation. Here we''re
    passing in `5` to extend the animation to last a full five seconds. This chained
    interface allows you to work with animations in a manner similar to working with
    jQuery and many other JavaScript libraries. It''s a powerful, friendly, interface:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们正在添加一个新的方法，链接到对`TweenMax.to`的调用的末尾。调用`TweenMax.duration`会改变动画的持续时间。在这里，我们传入`5`，以延长动画的持续时间为整整五秒。这种链接的接口允许您以类似于使用jQuery和许多其他JavaScript库的方式处理动画。这是一个强大而友好的接口。
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the previous code in a browser produces the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行上面的代码会产生以下输出：
- en: '![](img/775b243b-51ae-4631-a379-da143bb5840e.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/775b243b-51ae-4631-a379-da143bb5840e.png)'
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about visualizations and animations with SVG.
    This included working with pure JavaScript, SMIL, CSS, and two libraries for animation:
    GSAP and Vivus.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了关于SVG的可视化和动画。这包括使用纯JavaScript、SMIL、CSS以及两个用于动画的库：GSAP和Vivus。
- en: 'In this chapter, we looked at:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了：
- en: Creating a custom data visualization with JavaScript, SVG, and CSS. You took
    a data set, manipulated it with JavaScript, and used the results to create a nice
    looking visualization that illustrates a set of data in an easy-to-read way.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript、SVG和CSS创建自定义数据可视化。您使用JavaScript处理了一组数据，并使用结果创建了一个漂亮的可视化，以便以易于阅读的方式说明一组数据。
- en: Creating a custom SVG animation with JavaScript. This included calculating increments
    to animate over 60 frames-per-second and using `requestAnimationFrame` as a method
    to ensure that you're providing the smoothest possible experience.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript创建自定义SVG动画。这包括计算增量以在每秒60帧的速度下进行动画，并使用`requestAnimationFrame`作为一种方法，以确保您提供最流畅的体验。
- en: Animating SVG with CSS. You learned that the powerful options for animating
    SVG come with uncertain browser support.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS对SVG进行动画。您了解到，用于对SVG进行动画的强大选项具有不确定的浏览器支持。
- en: Animating SVG with SMIL, which also comes with uncertain browser support.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SMIL对SVG进行动画，这也带来了不确定的浏览器支持。
- en: Animating SVG with the Vivus library, which makes implementing a "drawing" animation
    in SVG as easy as including the library and adding a single line of JavaScript.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vivus库对SVG进行动画，这使得在SVG中实现“绘图”动画就像包含库并添加一行JavaScript代码一样简单。
- en: Finally, you got a glimpse at the powerful GSAP library, which offers incredibly
    powerful options for the animation of SVG and other elements.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您对强大的GSAP库有了一瞥，它为SVG和其他元素的动画提供了非常强大的选项。
- en: Now that we've introduced a couple of libraries into the mix, it will be a smooth
    transition into a whole chapter on helper libraries for SVG, Snap.svg, and SVG.js.
    These are important tools and will be invaluable if you're looking to do advanced,
    custom work with SVG.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将一些库引入到混合中，将顺利过渡到一个关于SVG、Snap.svg和SVG.js的辅助库的整个章节。这些是重要的工具，如果您想要在SVG上进行高级的自定义工作，它们将是非常宝贵的。
