- en: Chapter 1. Getting Started with Multiplayer Game Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。开始多人游戏编程
- en: If you're reading this book, chances are pretty good that you are already a
    game developer. That being the case, then you already know just how exciting it
    is to program your own games, either professionally or as a highly gratifying
    hobby that is very time-consuming. Now you're ready to take your game programming
    skills to the next level—that is, you're ready to implement multiplayer functionality
    into your JavaScript-based games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，很有可能你已经是一名游戏开发者。如果是这样，那么你已经知道编写自己的游戏是多么令人兴奋，无论是专业地还是作为一种非常耗时但非常令人满足的爱好。现在你已经准备将你的游戏编程技能提升到下一个水平——也就是说，你已经准备在基于JavaScript的游戏中实现多人功能。
- en: In case you have already set out to create multiplayer games for the **Open
    Web Platform** using HTML5 and JavaScript, then you may have already come to realize
    that a personal desktop computer, laptop, or a mobile device is not particularly
    the most appropriate device to share with another human player for games in which
    two or more players share the same game world at the same time. Therefore, what
    is needed in order to create exciting multiplayer games with JavaScript is some
    form of networking technology.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经开始使用HTML5和JavaScript为**Open Web Platform**创建多人游戏，那么你可能已经意识到个人台式电脑、笔记本电脑或移动设备并不是与另一个玩家分享游戏世界的最合适的设备，因此，为了使用JavaScript创建令人兴奋的多人游戏，需要一些形式的网络技术。
- en: 'In this chapter, we will discuss the following principles and concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下原则和概念：
- en: The basics of networking and network programming paradigms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络和网络编程范式的基础知识
- en: Socket programming with HTML5
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5进行套接字编程
- en: Programming a game server and game clients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写游戏服务器和游戏客户端
- en: Turn-based multiplayer games
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回合制多人游戏
- en: Understanding the basics of networking
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解网络的基础知识
- en: It is said that one cannot program games that make use of networking without
    first understanding all about the discipline of computer networking and network
    programming. Although having a deep understanding of any topic can be only beneficial
    to the person working on that topic, I don't believe that you must know everything
    there is to know about game networking in order to program some pretty fun and
    engaging multiplayer games. Saying that is the case is like saying that one needs
    to be a scholar of the Spanish language in order to cook a simple burrito. Thus,
    let us take a look at the most basic and fundamental concepts of networking. At
    the end of this section, you will know enough about computer networking to get
    started, and you will feel comfortable adding multiplayer aspects to your games.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 据说，如果没有先了解计算机网络和网络编程的学科，就无法编写利用网络的游戏。虽然对任何主题有深入的了解对于从事该主题的人来说都是有益的，但我不认为你必须了解关于游戏网络的所有知识才能编写一些非常有趣和引人入胜的多人游戏。说这种情况就像说一个人需要成为西班牙语的学者才能做一个简单的墨西哥卷饼。因此，让我们来看看网络的最基本和基本概念。在本节结束时，你将了解足够的计算机网络知识，可以开始，并且可以轻松地为你的游戏添加多人游戏方面。
- en: 'One thing to keep in mind is that, even though networked games are not nearly
    as old as single-player games, computer networking is actually a very old and
    well-studied subject. Some of the earliest computer network systems date back
    to the 1950s. Though some of the techniques have improved over the years, the
    basic idea remains the same: two or more computers are connected together to establish
    communication between the machines. By communication, I mean data exchange, such
    as sending messages back and forth between the machines, or one of the machines
    only sends the data and the other only receives it.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，尽管网络游戏并不像单人游戏那样古老，但计算机网络实际上是一个非常古老且经过深入研究的主题。一些最早的计算机网络系统可以追溯到20世纪50年代。尽管一些技术随着时间的推移有所改进，但基本思想仍然是一样的：两台或更多台计算机连接在一起，以建立机器之间的通信。通过通信，我指的是数据交换，比如在机器之间来回发送消息，或者一台机器只发送数据，另一台只接收数据。
- en: With this brief introduction to the concept of networking, you are now grounded
    in the subject of networking, enough to know what is required to network your
    games—two or more computers that talk to each other as close to real time as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个对网络概念的简要介绍，你现在已经对网络主题有了一定的了解，足以知道网络游戏所需的是什么——尽可能接近实时地交流的两台或更多台计算机。
- en: By now, it should be clear how this simple concept makes it possible for us
    to connect multiple players into the same game world. In essence, we need a way
    to share the global game data among all the players who are connected to the game
    session, then continue to update each player about every other player. There are
    several different techniques that are commonly used to achieve this, but the two
    most common approaches are peer-to-peer and client-server. Both techniques present
    different opportunities, including advantages and disadvantages. In general, neither
    is particularly better than the other, but different situations and use cases
    may be better suited for one or the other technique.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应该很清楚这个简单的概念是如何让我们能够将多个玩家连接到同一个游戏世界中的。实质上，我们需要一种方法来在连接到游戏会话的所有玩家之间共享全局游戏数据，然后继续更新每个玩家关于其他每个玩家的信息。通常有几种不同的技术用于实现这一点，但最常见的两种方法是点对点和客户端-服务器。这两种技术都提供了不同的机会，包括优势和劣势。一般来说，两者都没有特别优于另一种，但不同的情况和用例可能更适合其中一种技术。
- en: Peer-to-peer networking
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点对点网络
- en: A simple way to connect players into the same virtual game world is through
    the peer-to-peer architecture. Although the name might suggest that only two peers
    ("nodes") are involved, by definition a peer-to-peer network system is one in
    which two or more nodes are connected directly to each other without a centralized
    system orchestrating the connection or information exchange.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点对点架构将玩家连接到同一个虚拟游戏世界是一种简单的方法。尽管名称可能暗示只涉及两个对等体（“节点”），但根据定义，点对点网络系统是指两个或更多个节点直接连接在一起，没有中央系统编排连接或信息交换。
- en: On a typical peer-to-peer setup, each peer serves the same function as every
    other one—that is, they all consume the same data and share whatever data they
    produce so that others can stay synchronized. In the case of a peer-to-peer game,
    we can illustrate this architecture with a simple game of *Tic-tac-toe*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的点对点设置中，每个对等体都扮演着与其他对等体相同的功能，即它们都消耗相同的数据并共享它们产生的数据，以便其他人保持同步。在点对点游戏的情况下，我们可以用一个简单的*井字棋*游戏来说明这种架构。
- en: '![Peer-to-peer networking](img/B04669_01_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![点对点网络](img/B04669_01_01.jpg)'
- en: Once both the players have established a connection between themselves, whoever
    is starting the game makes a move by marking a cell on the game board. This information
    is relayed across the wire to the other peer, who is now aware of the decision
    made by his or her opponent, and can thus update their own game world. Once the
    second player receives the game's latest state that results from the first player's
    latest move, the second player is able to make a move of their own by checking
    some available space on the board. This information is then copied over to the
    first player who can update their own world and continue the process by making
    the next desired move.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两名玩家之间建立了连接，谁开始游戏就在游戏板上标记一个单元格。这些信息通过电线传递给另一个对等体，后者现在知道了对手所做的决定，并因此可以更新自己的游戏世界。一旦第二名玩家收到了由第一名玩家最新移动所导致的游戏最新状态，第二名玩家就能够通过检查游戏板上的一些可用空间来进行自己的移动。然后这些信息被复制到第一名玩家那里，他可以更新自己的世界，并通过进行下一个期望的移动来继续这个过程。
- en: The process goes on until one of the peers disconnects or the game ends as some
    condition that is based on the game's own business logic is met. In the case of
    the game of *Tic-tac-toe*, the game would end once one of the players has marked
    three spaces on the board forming a straight line or if all nine cells are filled,
    but neither player managed to connect three cells in a straight path.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会一直持续，直到其中一个对等体断开连接或者游戏以基于游戏自身业务逻辑的某个条件结束。在*井字棋*游戏的情况下，游戏将在其中一名玩家在棋盘上标记了三个空格形成一条直线，或者所有九个单元格都被填满，但没有一名玩家成功连接三个单元格的情况下结束。
- en: 'Some of the benefits of peer-to-peer networked games are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点网络游戏的一些好处如下：
- en: '**Fast data transmission**: Here, the data goes directly to its intended target.
    In other architectures, the data could go to some centralized node first, then
    the central node (or the "server", as we''ll see in the next section) contacts
    the other peer, sending the necessary updates.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速数据传输**：在这里，数据直接传输到其预定目标。在其他架构中，数据可能首先传输到一些集中节点，然后中央节点（或者在下一节中我们将看到的“服务器”）联系其他对等体，发送必要的更新。'
- en: '**Simpler setup**: You would only need to think about one instance of your
    game that, generally speaking, handles its own input, sends its input to other
    connected peers, and handles their output as input for its own system. This can
    be especially handy in turn-based games, for example, most board games such as
    *Tic-tac-toe*.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简单的设置**：你只需要考虑游戏的一个实例，一般来说，它处理自己的输入，将其输入发送给其他连接的对等体，并处理它们的输出作为自己系统的输入。这在回合制游戏中特别方便，例如，大多数棋盘游戏，比如*井字棋*。'
- en: '**More reliability**: Here one peer that goes offline typically won''t affect
    any of the other peers. However, in the simple case of a two-player game, if one
    of the players is unable to continue, the game will likely cease to be playable.
    Imagine, though, that the game in question has dozens or hundreds of connected
    peers. If a handful of them suddenly lose their Internet connection, the others
    can continue to play. However, if there is a server that is connecting all the
    nodes and the server goes down, then none of the other players will know how to
    talk to each other, and nobody will know what is going on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更可靠**：这里一个离线的对等体通常不会影响其他对等体。然而，在一个两人游戏的简单情况下，如果其中一名玩家无法继续，游戏很可能会无法继续进行。不过，想象一下，如果所涉及的游戏有数十甚至数百个连接的对等体。如果其中一些突然失去了互联网连接，其他人可以继续玩。但是，如果有一个连接所有节点的服务器并且服务器宕机，那么其他玩家将不知道如何与彼此交流，也不会知道发生了什么。'
- en: 'On the other hand, some of the more obvious drawbacks of peer-to-peer architecture
    are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，点对点架构的一些明显缺点如下：
- en: '**Incoming data cannot be trusted**: Here, you don''t know for sure whether
    or not the sender modified the data. The data that is input into a game server
    will also suffer from the same challenge, but once the data is validated and broadcasted
    to all the other peers, you can be more confident that the data received by each
    peer from the server will have at least been sanitized and verified, and will
    be more credible.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法信任传入数据**：在这里，你无法确定发送者是否修改了数据。输入到游戏服务器的数据也会受到同样的挑战，但一旦数据经过验证并广播到所有其他对等体，你就可以更有信心地认为每个对等体从服务器接收到的数据至少已经经过了清理和验证，并且更可信。'
- en: '**Fault tolerance can be very low**: The opposite argument was made in the
    benefits'' section of *Peer-to-peer networking* that we discussed previously;
    if enough players share the game world, one or more crashes won''t make the game
    unplayable to the rest of the peers. Now, if we consider the many cases where
    any of the players that suddenly crash out of the game negatively affect the rest
    of the players, we can see how a server could easily recover from the crash.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错率可能非常低**：在我们之前讨论的*点对点网络*的好处部分中提出了相反的观点；如果足够多的玩家共享游戏世界，一个或多个崩溃不会使游戏对其他对等体不可玩。现在，如果我们考虑到任何突然崩溃的玩家对其他玩家产生负面影响的许多情况，我们就可以看到服务器如何可以轻松从崩溃中恢复。'
- en: '**Data duplication when broadcasting to other peers**: Imagine that your game
    is a simple 2D side scroller, and many other players are sharing that game world
    with you. Every time one of the players moves to the right, you receive the new
    (x, y) coordinates from that player, and you''re able to update your own game
    world. Now, imagine that you move your player to the right by a very few pixels;
    you would have to send that data out to all of the other nodes in the system.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向其他对等体广播时的数据重复**：想象一下，你的游戏是一个简单的2D横向卷轴游戏，许多其他玩家与你共享这个游戏世界。每当其中一个玩家向右移动时，你会收到该玩家的新的（x，y）坐标，并且能够更新自己的游戏世界。现在，想象一下，你将你的玩家向右移动了几个像素；你将不得不将这些数据发送给系统中的所有其他节点。'
- en: Overall, peer-to-peer is a very powerful networking architecture and is still
    widely used by many games in the industry. Since current peer-to-peer web technologies
    are still in their infancy, most JavaScript-powered games today do not make use
    of peer-to-peer networking. For this and other reasons that should become apparent
    soon, we will focus the rest of the book almost exclusively on the other popular
    networking paradigm, namely, the client-server architecture.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，点对点是一种非常强大的网络架构，仍然被许多游戏行业广泛使用。由于当前的点对点网络技术仍处于起步阶段，今天大多数基于JavaScript的游戏不使用点对点网络。出于这个原因和其他很快就会变得明显的原因，我们将几乎专注于另一种流行的网络范式，即客户端-服务器架构。
- en: Client-server networking
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器网络
- en: The idea behind the **client-server networking** architecture is very simple.
    If you squint your eyes hard enough, you can almost see a peer-to-peer graph.
    The most obvious difference between them, is that, instead of every node being
    an equal peer, one of the nodes is special. That is, instead of every node connecting
    to every other node, every node (*client*) connects to a main centralized node
    called the *server*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端-服务器网络**架构的理念非常简单。如果你闭上眼睛，你几乎可以看到一个点对点图。它们之间最明显的区别是，每个节点都是平等的对等体，而其中一个节点是特殊的。也就是说，每个节点（客户端）不是连接到每个其他节点，而是连接到一个名为*服务器*的主要集中节点。'
- en: While the concept of a client-server network seems clear enough, perhaps a simple
    metaphor might make it easier for you to understand the role of each type of node
    in this network format as well as differentiate it from peer-to-peer (*McConnell*,
    *Steve*, *(2004)* *Code Complete*., *Microsoft Press*). In a peer-to-peer network,
    you can think of it as a group of friends (*peers*) having a conversation at a
    party. They all have access to all the other peers involved in the conversation
    and can talk to them directly. On the other hand, a client-server network can
    be viewed as a group of friends having dinner at a restaurant. If a client of
    the restaurant wishes to order a certain item from the menu, he or she must talk
    to the waiter, who is the only person in that group of people with access to the
    desired products and the ability to serve the products to the clients.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然客户端-服务器网络的概念似乎足够清晰，也许一个简单的比喻可能会让你更容易理解这种网络格式中每种类型节点的角色，并将其与点对点区分开（*McConnell*，*Steve*，*(2004)*
    *Code Complete*，*Microsoft Press*）。在点对点网络中，你可以将其视为一群朋友（对等体）在派对上进行对话。他们都可以直接与参与对话的其他对等体交谈。另一方面，客户端-服务器网络可以被视为一群朋友在餐馆吃饭。如果餐馆的客户想要点菜单上的某样东西，他或她必须与服务员交谈，服务员是那群人中唯一能够访问所需产品并为客户提供服务的人。
- en: In short, the server is in charge of providing data and services to one or more
    clients. In the context of game development, the most common scenario is when
    two or more clients connect to the same server; the server will keep track of
    the game as well as the distributed players. Thus, if two players are to exchange
    information that is only pertinent to the two of them, the communication will
    go from the first player to and through the server and will end up at the other
    end with the second player.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，服务器负责向一个或多个客户端提供数据和服务。在游戏开发的背景下，最常见的情况是两个或多个客户端连接到同一个服务器；服务器将跟踪游戏以及分布的玩家。因此，如果两个玩家要交换只与他们两个有关的信息，通信将从第一个玩家经过服务器传递并最终到达第二个玩家那里。
- en: '![Client-server networking](img/B04669_01_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![客户端服务器网络](img/B04669_01_02.jpg)'
- en: Following the example of the two players involved in a game of *Tic-tac-toe*
    that we looked at in the section about peer-to-peer, we can see how similar the
    flow of events is on a client-server model. Again, the main difference is that
    players are unaware of each other and only know what the server tells them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前关于点对点的部分中看到的*井字棋*游戏中涉及的两名玩家的例子中，我们可以看到客户端-服务器模型中事件流是多么相似。再次强调，主要区别在于玩家彼此不知道对方，只知道服务器告诉他们的内容。
- en: While you can very easily mimic a peer-to-peer model by using a server to merely
    connect the two players, most often the server is used much more actively than
    that. There are two ways to engage the server in a networked game, namely in an
    authoritative and a non-authoritative way. That is to say, you can have the enforcement
    of the game's logic strictly in the server, or you can have the clients handle
    the game logic, input validation, and so on. Today, most games using the client-server
    architecture actually use a hybrid of the two (authoritative and non-authoritative
    servers, which we'll discuss later in the book). For all intents and purposes,
    however, the server's purpose in life is to receive input from each of the clients
    and distribute that input throughout the pool of connected clients.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以很容易地通过使用服务器仅仅连接两个玩家来模拟点对点模型，但通常服务器的使用要比这更加活跃。在网络游戏中，有两种方式可以让服务器参与，即授权方式和非授权方式。也就是说，你可以将游戏逻辑的执行严格放在服务器端，或者你可以让客户端处理游戏逻辑、输入验证等。如今，大多数使用客户端-服务器架构的游戏实际上使用这两种方式的混合（授权和非授权服务器，我们将在本书的后面讨论）。但无论如何，服务器的生命周期的目的是接收来自每个客户端的输入，并将该输入分发到连接的客户端池中。
- en: Now, regardless of whether you decide to go with an authoritative server instead
    of a non-authoritative one, you will notice that one of challenges with a client-server
    game is that you will need to program both ends of the stack. You will have to
    do this even if your clients do nothing more than take input from the user, forward
    it to the server, and render whatever data they receive from the server; if your
    game server does nothing more than forward the input that it receives from each
    client to every other client, you will still need to write a game client and a
    game server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你决定使用授权服务器还是非授权服务器，你会注意到客户端-服务器游戏的一个挑战是你需要编写整个堆栈的两端。即使你的客户端只是从用户那里获取输入，将其转发到服务器，并渲染从服务器接收到的任何数据；如果你的游戏服务器只是将它从每个客户端接收到的输入转发给其他每个客户端，你仍然需要编写游戏客户端和游戏服务器。
- en: We will discuss game clients and servers later in the chapter. For now, all
    we really need to know is that these two components are what set this networking
    model apart from peer-to-peer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面我们将讨论游戏客户端和服务器。目前，我们真正需要知道的是，这两个组件是将这种网络模型与点对点网络区分开来的关键。
- en: 'Some of the benefits of client-server networked games are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器网络游戏的一些好处如下：
- en: '**Separation of concerns**: If you know anything about software development,
    you know that this is something you should always aim for. That is, good, maintainable
    software is written as discrete components where each does one "thing", and it
    is done well. Writing individual specialized components lets you focus on performing
    one individual task at a time, making your game easier to design, code, test,
    reason, and maintain.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：如果你了解软件开发，你就会知道这是你应该始终追求的。也就是说，良好的、可维护的软件是由离散的组件编写的，每个组件都只做一件“事”，而且做得很好。编写单独的专门组件让你可以专注于一次执行一个任务，使得你的游戏更容易设计、编码、测试、推理和维护。'
- en: '**Centralization**: While this can be argued against as well as in favor of,
    having one central place through which all communication must flow makes it easier
    to manage such communication, enforce any required rules, control access, and
    so forth.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中化**：尽管这一点可以被反对也可以被支持，但通过一个中心位置进行所有通信使得更容易管理这样的通信，强制执行任何必要的规则，控制访问等等。'
- en: '**Less work for the client**: Instead of having a client (peer) in charge of
    taking input from the user as well as other peers, validating all the input, sharing
    data among other peers, rendering the game, and so on, the client can focus on
    only doing a few of these things, allowing the server to offload some of this
    work. This is particularly handy when we talk about mobile gaming, and how much
    subtle divisions of labor can impact the overall player experience. For example,
    imagine a game where 10 players are engaged in the same game world. In a peer-to-peer
    setup, every time one player takes an action, he or she would need to send that
    action to nine other players (in other words, there would need to be nine network
    calls, boiling down to more mobile data usage). On the other hand, on a client-server
    configuration, one player would only need to send his or her action to one of
    the peers, that is, the server, who would then be responsible for sending that
    data to the remaining nine players.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减轻客户端的工作量**：客户端不再需要负责从用户和其他对等体获取输入，验证所有输入，与其他对等体共享数据，渲染游戏等等，客户端只需要专注于做其中的一部分，让服务器来分担一部分工作。当我们谈论移动游戏以及微妙的劳动分工如何影响整体玩家体验时，这一点尤为重要。例如，想象一个游戏中有10名玩家参与同一个游戏世界。在点对点设置中，每当一个玩家采取行动时，他或她需要将该行动发送给其他九名玩家（换句话说，需要进行九次网络调用，导致更多的移动数据使用）。另一方面，在客户端-服务器配置中，一个玩家只需要将他或她的行动发送给一个对等体，也就是服务器，然后服务器负责将该数据发送给其余的九名玩家。'
- en: 'Common drawbacks of client-server architectures, whether or not the server
    is authoritative, are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论服务器是否具有授权性，客户端-服务器架构的一些常见缺点如下：
- en: '**Communication takes longer to propagate**: In the very best possible scenario
    imaginable, every message sent from the first player to the second player would
    take twice as long to be delivered as compared to a peer-to-peer connection. That
    is, the message would be first sent from the first player to the server and then
    from the server to the second player. There are many techniques that are used
    today to solve the latency problem faced in this scenario, some of which we will
    discuss in much more depth later in [Chapter 4](ch04.html "Chapter 4. Reducing
    Network Latency"), *Reducing Network Latency*. However, the underlying dilemma
    will always be there.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信需要更长时间传播**：在最理想的情况下，从第一个玩家发送到第二个玩家的每条消息传递时间都会比点对点连接长一倍。也就是说，消息首先从第一个玩家发送到服务器，然后从服务器发送到第二个玩家。今天有许多技术用于解决这种情况下面临的延迟问题，其中一些我们将在[第4章](ch04.html
    "第4章。减少网络延迟")中更深入地讨论，*减少网络延迟*。然而，根本的困境将始终存在。'
- en: '**More complexity due to more moving parts**: It doesn''t really matter how
    you slice the pizza; the more code you need to write (and trust me, when you build
    two separate modules for a game, you will write more code), the greater your mental
    model will have to be. While much of your code can be reused between the client
    and the server (especially if you use well-established programming techniques,
    such as object-oriented programming), at the end of the day, you need to manage
    a greater level of complexity.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由于移动部件更复杂**：无论你如何切割披萨，你需要编写的代码越多（相信我，当你为游戏构建两个独立的模块时，你会写更多的代码），你的心智模型就需要越大。虽然你的大部分代码可以在客户端和服务器之间重复使用（特别是如果你使用了成熟的编程技术，比如面向对象编程），但归根结底，你需要管理更高级别的复杂性。'
- en: '**Single point of failure and network congestion**: Up until now, we have mostly
    discussed the case where only a handful of players participate in the same game.
    However, the more common case is that a handful of groups of players play different
    games at the same time.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点故障和网络拥塞**：到目前为止，我们大多讨论的是只有少数玩家参与同一游戏的情况。然而，更常见的情况是少数玩家组在同一时间玩不同的游戏。'
- en: Using the same example of the two-player game of *Tic-tac-toe*, imagine that
    there are thousands of players facing each other in single games. In a peer-to-peer
    setup, once a couple of players have directly paired off, it is as though there
    are no other players enjoying that game. The only thing to keep these two players
    from continuing their game is their own connection with each other.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以两人玩*Tic-tac-toe*的游戏为例，想象一下有成千上万的玩家在单人游戏中面对面。在点对点设置中，一旦一对玩家直接配对，就好像没有其他玩家在享受那个游戏。唯一能阻止这两个玩家继续游戏的是他们彼此之间的连接。
- en: On the other hand, if the same thousands of players are connected to each other
    through a server sitting between the two, then two singled out players might notice
    severe delays between messages because the server is so busy handling all of the
    messages from and to all of the other people playing isolated games. Worse yet,
    these two players now need to worry about maintaining their own connection with
    each other through the server, but they also hope that the server's connection
    between them and their opponent will remain active.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果同样成千上万的玩家通过一个位于两者之间的服务器相互连接，那么两个被孤立的玩家可能会注意到消息之间出现严重的延迟，因为服务器忙于处理所有来自其他玩家的消息。更糟糕的是，这两个玩家现在不仅需要担心彼此之间通过服务器维持连接，还希望服务器与他们和对手之间的连接保持活动状态。
- en: All in all, many of the challenges involved in client-server networking are
    well studied and understood, and many of the problems you're likely to face during
    your multiplayer game development will already have been solved by someone else.
    Client-server is a very popular and powerful game networking model, and the required
    technology for it, which is available to us through HTML5 and JavaScript, is well
    developed and widely supported.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，客户端-服务器网络中涉及的许多挑战都经过深入研究和理解，你在多人游戏开发过程中可能会遇到的许多问题已经被其他人解决了。客户端-服务器是一种非常流行和强大的游戏网络模型，而通过HTML5和JavaScript可用的所需技术已经得到了很好的发展和广泛的支持。
- en: Networking protocols – UDP and TCP
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络协议 - UDP和TCP
- en: By discussing some of the ways in which your players can talk to each other
    across some form of network, we have yet only skimmed over how that communication
    is actually done. Let us then describe what protocols are and how they apply to
    networking and, more importantly, multiplayer game development.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过讨论玩家如何在某种形式的网络上进行交流，我们只是浅尝辄止，实际上并没有涉及到通信是如何实际完成的。让我们来描述一下协议是什么，以及它们如何应用于网络和更重要的是多人游戏开发。
- en: The word protocol can be defined as *a set of conventions* or a *detailed plan
    of a procedure* [Citation [Def. 3,4]. (n.d.). In Merriam Webster Online, Retrieved
    February 12, 2015, from [http://www.merriam-webster.com/dictionary/protocol](http://www.merriam-webster.com/dictionary/protocol)].
    In computer networking, a protocol describes to the receiver of a message how
    the data is organized so that it can be decoded. For example, imagine that you
    have a multiplayer beat 'em up game, and you want to tell the game server that
    your player just issued a kick command and moved 3 units to the left. What exactly
    do you send to the server? Do you send a string with a value of "kick", followed
    by the number 3? Otherwise, do you send the number first, followed by a capitalized
    letter "K", indicating that the action taken was a kick? The point I'm trying
    to make is that, without a well-understood and agreed-upon protocol, it is impossible
    to successfully and predictably communicate with another computer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 协议一词可以被定义为*一组约定*或*详细的程序计划* [引用[Def. 3,4]。(n.d.)。在Merriam Webster Online中检索到2015年2月12日，从[http://www.merriam-webster.com/dictionary/protocol](http://www.merriam-webster.com/dictionary/protocol)]。在计算机网络中，协议向消息的接收方描述数据的组织方式，以便对其进行解码。例如，想象一下，您有一个多人对打游戏，并且您想告诉游戏服务器，您的玩家刚刚发出了一个踢的命令，并向左移动了3个单位。您应该向服务器发送什么？您发送一个值为“kick”的字符串，然后是数字3吗？否则，您首先发送数字，然后是一个大写字母“K”，表示所采取的行动是踢？我试图表达的观点是，如果没有一个被充分理解和达成一致的协议，就不可能成功和可预测地与另一台计算机进行通信。
- en: The two networking protocols that we'll discuss in the section, and that are
    also the two most widely used protocols in multiplayer networked games, are the
    **Transmission Control Protocol** (**TCP**) and the **User Datagram Protocol**
    (**UDP**). Both protocols provide communication services between clients in a
    network system. In simple terms, they are protocols that allow us to send and
    receive packets of data in such a way that the data can be identified and interpreted
    in a predictable way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中讨论的两种网络协议，也是多人联机游戏中最广泛使用的两种协议，分别是**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。这两种协议都提供了网络系统中客户端之间的通信服务。简单来说，它们是允许我们以可预测的方式发送和接收数据包的协议。
- en: When data is sent through TCP, the application running in the source machine
    first establishes a connection with the destination machine. Once a connection
    has been established, data is transmitted in packets in such a way that the receiving
    application can then put the data back together in the appropriate order. TCP
    also provides built-in error checking mechanisms so that, if a packet is lost,
    the target application can notify the sender application, and any missing packets
    are sent again until the entire message is received.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据通过TCP发送时，源机器中运行的应用程序首先与目标机器建立连接。一旦建立了连接，数据以数据包的形式传输，以便接收方的应用程序可以将数据按适当的顺序重新组合。TCP还提供了内置的错误检查机制，因此，如果数据包丢失，目标应用程序可以通知发送方应用程序，并且任何丢失的数据包都会被重新发送，直到整个消息被接收。
- en: In short, TCP is a connection-based protocol that guarantees the delivery of
    the full data in the correct order. Use cases where this behavior is desirable
    are all around us. When you download a game from a web server, for example, you
    want to make sure that the data comes in correctly. You want to be sure that your
    game assets will be properly and completely downloaded before your users start
    playing your game. While this guarantee of delivery may sound very reassuring,
    it can also be thought of as a slow process, which, as we'll see briefly, may
    sometimes be more important than knowing that the data will arrive in full.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，TCP是一种基于连接的协议，可以保证完整数据的按正确顺序传递。我们周围有许多需要这种行为的用例。例如，当您从Web服务器下载游戏时，您希望确保数据正确传输。您希望在用户开始玩游戏之前，游戏资产能够被正确完整地下载。虽然这种交付保证听起来非常令人放心，但也可以被认为是一个缓慢的过程，有时可能比知道数据将完整到达更重要，我们稍后会简要看到。
- en: In contrast, UDP transmits packets of data (called *datagrams*) without the
    use of a pre-established connection. The main goal of the protocol is to be a
    very fast and frictionless way of sending data towards some target application.
    In essence, you can think of UDP as the brave employees who dress up as their
    company's mascot and stand outside their store waving a large banner in the hope
    that at least some of the people driving by will see them and give them their
    business.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，UDP在不使用预先建立的连接的情况下传输数据包（称为*数据报*）。该协议的主要目标是以非常快速和无摩擦的方式向某个目标应用程序发送数据。实质上，您可以将UDP视为勇敢的员工，他们打扮成公司的吉祥物站在店外挥舞着大型横幅，希望至少有一些经过的人会看到他们并给他们业务。
- en: While at first, UDP may seem like a reckless protocol, the use cases that make
    UDP so desirable and effective includes the many situations when you care more
    about speed than missing packets a few times, getting duplicate packets, or getting
    them out of order. You may also want to choose UDP over TCP when you don't care
    about the reply from the receiver. With TCP, whether or not you need some form
    of confirmation or reply from the receiver of your message, it will still take
    the time to reply back to you, at least acknowledging that the message was received.
    Sometimes, you may not care whether or not the server received the data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，UDP可能看起来像是一种鲁莽的协议，但使UDP如此令人渴望和有效的用例包括许多情况，当您更关心速度而不是偶尔丢失数据包，获取重复数据包或以无序方式获取它们时。您可能还希望在您不关心接收方的回复时选择UDP而不是TCP。使用TCP时，无论您是否需要接收方的某种确认或回复，它仍然需要时间来回复您，至少确认消息已收到。有时，您可能不在乎服务器是否收到了数据。
- en: '![Networking protocols – UDP and TCP](img/B04669_01_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![网络协议 - UDP和TCP](img/B04669_01_03.jpg)'
- en: A more concrete example of a scenario where UDP is a far better choice over
    TCP is when you need a heartbeat from the client letting the server know if the
    player is still there. If you need to let your server know that the session is
    still active every so often, and you don't care if one of the heartbeats get lost
    every now and again, then it would be wise to use UDP. In short, for any data
    that is not mission-critical and you can afford to lose, UDP might be the best
    option.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: UDP比TCP更好的选择的一个更具体的例子是，当你需要从客户端获取心跳信号，让服务器知道玩家是否还在游戏中时。如果你需要让服务器知道会话仍然活跃，并且偶尔丢失一个心跳信号并不重要，那么使用UDP是明智的选择。简而言之，对于任何不是关键任务且可以承受丢失的数据，UDP可能是最佳选择。
- en: In closing, keep in mind that, just as peer-to-peer and client-server models
    can be built side by side, and in the same way your game server can be a hybrid
    of authoritative and non-authoritative, there is absolutely no reason why your
    multiplayer games should only use TCP or UDP. Use whichever protocol a particular
    situation calls for.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要记住，就像点对点和客户端-服务器模型可以并行构建一样，同样你的游戏服务器可以是授权和非授权的混合体，绝对没有理由为什么你的多人游戏只能使用TCP或UDP。使用特定情况需要的任何协议。
- en: Network sockets
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络套接字
- en: There is one other protocol that we'll cover very briefly, but only so that
    you can see the need for network sockets in game development. As a JavaScript
    programmer, you are doubtlessly familiar with **Hypertext Transfer Protocol**
    (**HTTP**). This is the protocol in the application layer that web browsers use
    to fetch your games from a Web server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个我们将非常简要地介绍的协议，只是为了让你看到在游戏开发中需要网络套接字。作为JavaScript程序员，你无疑熟悉**超文本传输协议**（**HTTP**）。这是Web浏览器用来从Web服务器获取你的游戏的应用层协议。
- en: 'While HTTP is a great protocol to reliably retrieve documents from web servers,
    it was not designed to be used in real-time games; therefore, it is not ideal
    for this purpose. The way HTTP works is very simple: a client sends a request
    to a server, which then returns a response back to the client. The response includes
    a completion status code, indicating to the client that the request is either
    in process, needs to be forwarded to another address, or is finished successfully
    or erroneously (*Hypertext Transfer Protocol (HTTP/1.1): Authentication*, *(June
    1999)*. [https://tools.ietf.org/html/rfc7235](https://tools.ietf.org/html/rfc7235))'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP是一个可靠地从Web服务器检索文档的协议，但它并不是为实时游戏而设计的；因此，它并不是这个目的的理想选择。HTTP的工作方式非常简单：客户端向服务器发送请求，然后服务器返回响应给客户端。响应包括一个完成状态码，向客户端指示请求是正在处理中，需要转发到另一个地址，或者已成功或错误地完成（*超文本传输协议（HTTP/1.1）：身份验证*，*（1999年6月）*。[https://tools.ietf.org/html/rfc7235](https://tools.ietf.org/html/rfc7235)）
- en: There are a handful of things to note about HTTP that will make it clear that
    a better protocol is needed for real-time communication between the client and
    server. Firstly, after each response is received by the requester, the connection
    is closed. Thus, before making each and every request, a new connection must be
    established with the server. Most of the time, an HTTP request will be sent through
    TCP, which, as we've seen, can be slow, relatively speaking.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情需要注意关于HTTP，这将清楚地表明在客户端和服务器之间的实时通信需要更好的协议。首先，每次接收到响应后，连接就会关闭。因此，在发出每个请求之前，必须与服务器建立新的连接。大多数情况下，HTTP请求将通过TCP发送，相对而言，这可能会比较慢。
- en: Secondly, HTTP is by design a stateless protocol. This means that, every time
    you request a resource from a server, the server has no idea who you are and what
    is the context of the request. (It doesn't know whether this is your first request
    ever or if you're a frequent requester.) A common solution to this problem is
    to include a unique string with every HTTP request that the server keeps track
    of, and can thus provide information about each individual client on an ongoing
    basis. You may recognize this as a standard *session*. The major downside with
    this solution, at least with regard to real-time gaming, is that mapping a session
    cookie to the user's session takes additional time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，HTTP在设计上是一个无状态协议。这意味着，每次你从服务器请求资源时，服务器都不知道你是谁以及请求的上下文是什么。（它不知道这是你的第一个请求，还是你经常请求。）这个问题的一个常见解决方案是在每个HTTP请求中包含一个唯一的字符串，服务器会跟踪这个字符串，并因此可以持续提供有关每个个体客户端的信息。你可能会认识到这是一个标准的*会话*。这种解决方案的主要缺点，至少在实时游戏方面，是将会话cookie映射到用户会话需要额外的时间。
- en: Finally, the major factor that makes HTTP unsuitable for multiplayer game programming
    is that the communication is one way—only the client can connect to the server,
    and the server replies back through the same connection. In other words, the game
    client can tell the game server that a punch command has been entered by the user,
    but the game server cannot pass that information along to other clients. Think
    of it like a vending machine. As a client of the machine, we can request specific
    items that we wish to buy. We formalize this request by inserting money into the
    vending machine, and then we press the appropriate button.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使HTTP不适合多人游戏编程的主要因素是通信是单向的——只有客户端可以连接到服务器，服务器通过同一连接回复。换句话说，游戏客户端可以告诉游戏服务器用户输入了一个出拳命令，但游戏服务器无法将这些信息传递给其他客户端。想象一下自动售货机。作为机器的客户，我们可以请求我们想要购买的特定物品。我们通过向自动售货机投入货币来正式化这个请求，然后按下适当的按钮。
- en: Under no circumstance will a vending machine issue commands to a person standing
    nearby. That would be like waiting for a vending machine to dispense food, expecting
    people to deposit the money inside it afterwards.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，自动售货机都不会向附近站立的人发出命令。这就像等待自动售货机发放食物，期望人们之后再往里面投钱。
- en: The answer to this lack of functionality in HTTP is pretty straightforward.
    A network socket is an endpoint in a connection that allows for two-way communication
    between the client and the server. Think of it more like a telephone call, rather
    than a vending machine. During a telephone call, either party can say whatever
    they want at any given time. Most importantly, the connection between both parties
    remains open throughout the duration of the conversation, making the communication
    process highly efficient.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTTP功能的缺乏，答案非常简单。网络套接字是连接中允许客户端和服务器进行双向通信的端点。把它想象成电话通话，而不是自动售货机。在电话通话期间，任何一方都可以在任何时候说任何他们想说的话。最重要的是，双方之间的连接在整个对话期间保持打开状态，使通信过程非常高效。
- en: '![Network sockets](img/B04669_01_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![网络套接字](img/B04669_01_04.jpg)'
- en: '**WebSocket** is a protocol built on top of TCP, allowing web-based applications
    to have two-way communication with a server (*The WebSocket Protocol*, *(December
    2011)*. [http://tools.ietf.org/html/rfc6455 RFC 6455](http://tools.ietf.org/html/rfc6455
    RFC 6455)). The way a WebSocket is created consists of several steps, including
    a protocol upgrade from HTTP to WebSocket. Thankfully, all of the heavy lifting
    is done behind the scenes by the browser and JavaScript, as we''ll see in the
    next section. For now, the key takeaway here is that with a TCP socket (yes, there
    are other types of socket including UDP sockets), we can reliably communicate
    with a server, and the server can talk back to us as per the need.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket**是建立在TCP之上的协议，允许基于Web的应用程序与服务器进行双向通信（*WebSocket Protocol*，*（2011年12月）*。[http://tools.ietf.org/html/rfc6455
    RFC 6455](http://tools.ietf.org/html/rfc6455 RFC 6455)）。创建WebSocket的方式包括多个步骤，包括从HTTP升级到WebSocket的协议升级。幸运的是，所有繁重的工作都是由浏览器和JavaScript在幕后完成的，我们将在下一节中看到。现在，这里的关键要点是，通过TCP套接字（是的，还有其他类型的套接字，包括UDP套接字），我们可以可靠地与服务器通信，服务器也可以根据需要回应我们。'
- en: Socket programming in JavaScript
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的套接字编程
- en: Let's now bring the conversation about network connections, protocols, and sockets
    to a close by talking about the tools—JavaScript and WebSockets—that bring everything
    together, allowing us to program awesome multiplayer games in the language of
    the open Web.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过讨论将一切联系在一起的工具——JavaScript和WebSocket——来结束关于网络连接、协议和套接字的对话，从而使我们能够使用开放Web的语言编写出色的多人游戏。
- en: The WebSocket protocol
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket协议
- en: Modern browsers and other JavaScript runtime environments have implemented the
    WebSocket protocol in JavaScript. Don't make the mistake of thinking that just
    because we can create WebSocket objects in JavaScript, WebSockets are part of
    JavaScript. The standard that defines the WebSocket protocol is language-agnostic
    and can be implemented in any programming language. Thus, before you start to
    deploy your JavaScript games that make use of WebSockets, ensure that the environment
    that will run your game uses an implementation of the **ECMA** standard that also
    implements WebSockets. In other words, not all browsers will know what to do when
    you ask for a WebSocket connection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器和其他JavaScript运行时环境已经在JavaScript中实现了WebSocket协议。不要误以为只因为我们可以在JavaScript中创建WebSocket对象，WebSocket就是JavaScript的一部分。定义WebSocket协议的标准是与语言无关的，可以在任何编程语言中实现。因此，在开始部署使用WebSocket的JavaScript游戏之前，请确保将运行游戏的环境使用了实现了WebSockets的**ECMA**标准。换句话说，并非所有浏览器在您请求WebSocket连接时都知道该怎么做。
- en: For the most part, though, the latest versions, as of this writing, of the most
    popular browsers today (namely, Google Chrome, Safari, Mozilla Firefox, Opera,
    and Internet Explorer) implement the current latest revision of RFC 6455\. Previous
    versions of WebSockets (such as protocol version - 76, 7, or 10) are slowly being
    deprecated and have been removed by some of the previously mentioned browsers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，今天最流行的浏览器（即Google Chrome，Safari，Mozilla Firefox，Opera和Internet Explorer）的最新版本（即本文撰写时）实施了RFC
    6455的最新修订版。 WebSockets的旧版本（如协议版本-76、7或10）正在逐渐被弃用，并已被一些先前提到的浏览器移除。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Probably the most confusing thing about the WebSocket protocol is the way each
    version of the protocol is named. The very first draft (which dates back to 2010),
    was named *draft-hixie-thewebsocketprotocol-75*. The next version was named *draft-hixie-thewebsocketprotocol-76*.
    Some people refer to these versions as 75 and 76, which can be quite confusing,
    especially since the fourth version of the protocol is named *draft-ietf-hybi-thewebsocketprotocol-07*,
    which is named in the draft as WebSocket Version 7\. The current version of the
    protocol (*RFC 6455*) is 13.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于WebSocket协议最令人困惑的事情可能是每个协议版本的命名方式。最初的草案（可以追溯到2010年）被命名为*draft-hixie-thewebsocketprotocol-75*。下一个版本被命名为*draft-hixie-thewebsocketprotocol-76*。有些人将这些版本称为75和76，这可能会相当令人困惑，特别是因为协议的第四个版本被命名为*draft-ietf-hybi-thewebsocketprotocol-07*，在草案中被命名为WebSocket
    Version 7。协议的当前版本（*RFC 6455*）是13。
- en: Let us take a quick look at the programming interface (API) that we'll use within
    our JavaScript code to interact with a WebSocket server. Keep in mind that we'll
    need to write both the JavaScript clients that use WebSockets to consume data
    as well as the WebSocket server, which uses WebSockets but plays the role of the
    server. The difference between the two will become apparent as we go over some
    examples.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们将在JavaScript代码中使用的编程接口（API），以与WebSocket服务器进行交互。请记住，我们需要编写使用WebSockets消耗数据的JavaScript客户端，以及使用WebSockets但扮演服务器角色的WebSocket服务器。随着我们讨论一些示例，两者之间的区别将变得明显。
- en: Creating a client-side WebSocket
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建客户端WebSocket
- en: The following code snippet creates a new object of type WebSocket that connects
    the client to some backend server. The constructor takes two parameters; the first
    is required and represents the URL where the WebSocket server is running and expecting
    connections. The second URL, which we won't make use of in this book, is an optional
    list of sub-protocols that the server may implement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建了一个新的WebSocket类型对象，将客户端连接到某个后端服务器。构造函数需要两个参数；第一个是必需的，表示WebSocket服务器正在运行并期望连接的URL。第二个URL在本书中不会使用，它是服务器可能实现的可选子协议列表。
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although this one line of code may seem simple and harmless enough, here are
    a few things to keep in mind:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一行代码可能看起来很简单且无害，但请记住以下几点：
- en: We are no longer in HTTP territory. The address to your WebSocket server now
    starts with `ws://` instead of `http://`. Similarly, when we work with secure
    (encrypted) sockets, we would specify the server's URL as `wss://`, just like
    in `https://`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再处于HTTP领域。现在，WebSocket服务器的地址以`ws://`开头，而不是`http://`。同样，当我们使用安全（加密）套接字时，我们将指定服务器的URL为`wss://`，就像在`https://`中一样。
- en: It may seem obvious to you, but a common pitfall that those getting started
    with WebSockets fall into is that, before you can establish a connection with
    the previous code, you need a WebSocket server running at that domain.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对您可能显而易见，但WebSockets入门者常犯的一个常见错误是，在您可以使用上述代码建立连接之前，您需要在该域上运行一个WebSocket服务器。
- en: WebSockets implement the same-origin security model. As you may have already
    seen with other HTML5 features, the same-origin policy states that you can only
    access a resource through JavaScript if both the client and the server are in
    the same domain.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSockets实现了同源安全模型。正如您可能已经在其他HTML5功能中看到的那样，同源策略规定，只有在客户端和服务器位于同一域中时，才能通过JavaScript访问资源。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For those who are not familiar with the same-domain (also known as the **same-origin**)
    policy, the three things that constitute a domain, in this context, are the protocol,
    host, and port of the resource being accessed. In the previous example, the protocol,
    host, and port number were, respectively `ws` (and not `wss`, `http`, or `ssh`),
    `www.game-domain.com` (any sub-domain, such as `game-domain.com` or `beta.game-domain.com`
    would violate the same-origin policy), and 80 (by default, WebSocket connects
    to port 80, and port 443 when it uses `wss`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉同源（也称为**同源**）策略的人来说，在这种情况下，构成域的三个要素是正在访问的资源的协议、主机和端口。在上一个示例中，协议、主机和端口号分别是`ws`（而不是`wss`、`http`或`ssh`）、`www.game-domain.com`（任何子域，如`game-domain.com`或`beta.game-domain.com`都将违反同源策略），以及80（默认情况下，WebSocket连接到端口80，使用`wss`时连接到端口443）。
- en: Since the server in the previous example binds to port 80, we don't need to
    explicitly specify the port number. However, had the server been configured to
    run on a different port, say 2667, then the URL string would need to include a
    colon followed by the port number that would need to be placed at the end of the
    host name, such as `ws://www.game-domain.com:2667`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上一个示例中的服务器绑定到端口80，我们不需要显式指定端口号。但是，如果服务器配置为在不同的端口上运行，比如2667，那么URL字符串需要包括一个冒号，后面跟着需要放在主机名末尾的端口号，如`ws://www.game-domain.com:2667`。
- en: 'As with everything else in JavaScript, WebSocket instances attempt to connect
    to the backend server asynchronously. Thus, you should not attempt to issue commands
    on your newly created socket until you''re sure that the server has connected;
    otherwise, JavaScript will throw an error that may crash your entire game. This
    can be done by registering a callback function on the socket''s `onopen` event
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与JavaScript中的其他所有内容一样，WebSocket实例尝试异步连接到后端服务器。因此，在确保服务器已连接之前，您不应尝试在新创建的套接字上发出命令；否则，JavaScript将抛出一个可能会使整个游戏崩溃的错误。可以通过在套接字的`onopen`事件上注册回调函数来实现这一点：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the socket is ready to send and receive data, you can send messages to
    the server by calling the socket object's `send` method, which takes a string
    as the message to be sent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦套接字准备好发送和接收数据，您可以通过调用套接字对象的`send`方法向服务器发送消息，该方法接受一个字符串作为要发送的消息。
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most often, however, you will want to send more meaningful data to the server,
    such as objects, arrays, and other data structures that have more meaning on their
    own. In these cases, we can simply serialize our data as JSON strings.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，您会希望向服务器发送更有意义的数据，例如对象、数组和其他具有自己含义的数据结构。在这些情况下，我们可以简单地将我们的数据序列化为JSON字符串。
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, the server can receive that message and work with it as the same object
    structure that the client sent it, by running it through the parse method of the
    JSON object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务器可以接收该消息，并将其作为客户端发送的相同对象结构进行处理，方法是通过JSON对象的解析方法运行它。
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you look at the previous example closely, you will notice that we extract
    the message that is sent through the socket from the `data` attribute of some
    event object. Where did that event object come from, you ask? Good question! The
    way we receive messages from the socket is the same on both the client and server
    sides of the socket. We must simply register a callback function on the socket's
    `onmessage` event, and the callback will be invoked whenever a new message is
    received. The argument passed into the callback function will contain an attribute
    named data, which will contain the raw string object with the message that was
    sent.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看上一个示例，您会注意到我们从某个事件对象的`data`属性中提取通过套接字发送的消息。您会问，那个事件对象是从哪里来的？好问题！我们从套接字的`onmessage`事件上注册回调函数的方式在套接字的客户端和服务器端上接收消息是相同的。我们只需在套接字的`onmessage`事件上注册回调函数，每当接收到新消息时，就会调用该回调。传递给回调函数的参数将包含一个名为data的属性，其中包含发送的原始字符串对象的消息。
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt Publishing图书的示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: Other events on the socket object on which you can register callbacks include
    `onerror`, which is triggered whenever an error related to the socket occurs,
    and `onclose`, which is triggered whenever the state of the socket changes to
    *CLOSED*; in other words, whenever the server closes the connection with the client
    for any reason or the connected client closes its connection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在socket对象上注册回调的其他事件包括`onerror`，每当与socket相关的错误发生时触发，以及`onclose`，每当socket的状态更改为*CLOSED*时触发；换句话说，每当服务器以任何原因关闭与客户端的连接或连接的客户端关闭其连接时。
- en: 'As mentioned previously, the socket object will also have a property called
    `readyState`, which behaves in a similar manner to the equally-named attribute
    in AJAX objects (or more appropriately, `XMLHttpRequest` objects). This attribute
    represents the current state of the connection and can have one of four values
    at any point in time. This value is an unsigned integer between 0 and 3, inclusive
    of both the numbers. For clarity, there are four accompanying constants on the
    WebSocket class that map to the four numerical values of the instance''s `readyState`
    attribute. The constants are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，socket对象还将具有一个名为`readyState`的属性，其行为类似于AJAX对象（或更恰当地说是`XMLHttpRequest`对象）中同名属性。该属性表示连接的当前状态，并且在任何时间点都可以具有四个值之一。该值是一个无符号整数，介于0和3之间，包括这两个数字。为了清晰起见，在WebSocket类上有四个与实例的`readyState`属性的四个数值相对应的常量。这些常量如下：
- en: '`WebSocket.CONNECTING`: This has a value of 0 and means that the connection
    between the client and the server has not yet been established.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebSocket.CONNECTING`：其值为0，表示客户端和服务器之间的连接尚未建立。'
- en: '`WebSocket.OPEN`: This has a value of 1 and means that the connection between
    the client and the server is open and ready for use. Whenever the object''s `readyState`
    attribute changes from CONNECTING to OPEN, which will only happen once in the
    object''s life cycle, the `onopen` callback will be invoked.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebSocket.OPEN`：其值为1，表示客户端和服务器之间的连接已经打开并准备就绪。每当对象的`readyState`属性从CONNECTING更改为OPEN时（这只会在对象的生命周期中发生一次），将调用`onopen`回调。'
- en: '`WebSocket.CLOSING`: This has a value of 2 and means that the connection is
    being closed.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebSocket.CLOSING`：其值为2，表示连接正在关闭。'
- en: '`WebSocket.CLOSED`: This has a value of 3 and means that the connection is
    now closed (or could not be opened to begin with).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebSocket.CLOSED`：其值为3，表示连接现在已关闭（或者根本无法打开）。'
- en: Once the `readyState` has changed to a new value, it will never return to a
    previous state in the same instance of the socket object. Thus, if a socket object
    is CLOSING or has already become *CLOSED*, it will never *OPEN* again. In this
    case, you would need a new instance of WebSocket if you would like to continue
    to communicate with the server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`readyState`已经更改为新值，它将永远不会在同一socket对象实例中返回到先前的状态。因此，如果一个socket对象正在CLOSING或已经变为*CLOSED*，它将永远不会再次*OPEN*。在这种情况下，如果您希望继续与服务器通信，您将需要一个新的WebSocket实例。
- en: 'To summarize, let us bring together the simple WebSocket API features that
    we discussed previously and create a convenient function that simplifies data
    serialization, error checking, and error handling when communicating with the
    game server:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，让我们总结一下之前讨论过的简单WebSocket API功能，并创建一个方便的函数，简化与游戏服务器通信时的数据序列化、错误检查和错误处理：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Game clients
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏客户端
- en: Earlier in the chapter, we talked about the architecture of a multiplayer game
    that was based on the client-server pattern. Since this is the approach we will
    take for the games that we'll be developing throughout the book, let us define
    some of the main roles that the game client will fulfill.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们讨论了基于客户端-服务器模式的多人游戏的架构。由于这是我们将在整本书中开发的游戏所采用的方法，让我们定义一些游戏客户端将要履行的主要角色。
- en: From a higher level, a game client will be the interface between the human player
    and the rest of the game universe (which includes the game server and other human
    players who are connected to it). Thus, the game client will be in charge of taking
    input from the player, communicating this to the server, receive any further instructions
    and information from the server, and then render the final output to the human
    player again. Depending on the type of game server used (we'll discuss this in
    the next section and in future chapters), the client can be more sophisticated
    than just an input application that renders static data received from the server.
    For example, the client could very well simulate what the game server will do
    and present the result of this simulation to the user while the server performs
    the real calculations and tells the results to the client. The biggest selling
    point of this technique is that the game would seem a lot more dynamic and real-time
    to the user since the client responds to input almost instantly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从更高的层次来看，游戏客户端将是人类玩家与游戏宇宙的其余部分（包括游戏服务器和连接到它的其他人类玩家）之间的接口。因此，游戏客户端将负责接收玩家的输入，将其传达给服务器，接收服务器的任何进一步指令和信息，然后再次将最终输出呈现给人类玩家。根据所使用的游戏服务器类型（我们将在下一节和未来章节中讨论此问题），客户端可以比仅仅是从服务器接收静态数据的输入应用程序更复杂。例如，客户端很可能会模拟游戏服务器的操作，并将此模拟的结果呈现给用户，而服务器则执行真正的计算并将结果告知客户端。这种技术的最大卖点在于，由于客户端几乎立即响应输入，游戏对用户来说会显得更加动态和实时。
- en: Game servers
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏服务器
- en: The game server is primarily responsible for connecting all the players to the
    same game world and keeping the communication going between them. However as you
    will soon realize, there may be cases where you will want the server to be more
    sophisticated than a routing application. For example, just because one of the
    players is telling the server to inform the other participants that the game is
    over, and the player sending the message is the winner, we may still want to confirm
    the information before deciding that the game is in fact over.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏服务器主要负责将所有玩家连接到同一个游戏世界，并保持它们之间的通信。然而，你很快就会意识到，有些情况下，你可能希望服务器比一个路由应用程序更复杂。例如，即使其中一名玩家告诉服务器通知其他参与者游戏结束了，并且发送消息的玩家是赢家，我们可能仍然希望在决定游戏是否真的结束之前确认信息。
- en: 'With this idea in mind, we can label the game server as being of one of the
    two kinds: authoritative or non-authoritative. In an authoritative game server,
    the game''s logic is actually running in memory (although it normally doesn''t
    render any graphical output like the game clients certainly will) all the time.
    As each client reports the information to the server by sending messages through
    its corresponding socket, the server updates the current game state and sends
    the updates back to all of the players, including the original sender. This way
    we can be more certain that any data coming from the server has been verified
    and is accurate.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我们可以将游戏服务器标记为两种类型之一：权威或非权威。在权威游戏服务器中，游戏逻辑实际上一直在内存中运行（尽管通常不像游戏客户端一样渲染任何图形输出），每个客户端通过其对应的套接字发送消息将信息报告给服务器，服务器更新当前游戏状态并将更新发送回所有玩家，包括原始发送者。这样我们就可以更加确定从服务器传来的任何数据都经过了验证并且是准确的。
- en: In a non-authoritative server, the clients take on a much more involved part
    in the game logic enforcement, which gives the client a lot more trust. As suggested
    previously, what we can do is take the best of both worlds and create a mix of
    both the techniques. What we will do in this book is have a strictly authoritative
    server, but clients that are smart and can do some of the work on their own. Since
    the server has the ultimate say in the game, however, any messages received by
    clients from the server are considered as the ultimate truth and supersede any
    conclusions it came to on its own.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个非权威的服务器中，客户端在游戏逻辑执行中扮演了更加重要的角色，这给了客户端更多的信任。正如之前建议的，我们可以取长补短，创造两种技术的混合。在这本书中，我们将拥有一个严格的权威服务器，但客户端是智能的，可以自行完成一些工作。然而，由于服务器对游戏有最终决定权，因此客户端从服务器接收的任何消息都被视为最终真相，并且超越了客户端自己的任何结论。
- en: Putting it all together – Tic-tac-toe
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起 - 井字棋
- en: Before we go crazy with our new knowledge about networking, WebSockets, and
    multiplayer game architecture, let us apply these principles in the simplest way
    possible by creating a very exciting networked game of *Tic-tac-toe*. We will
    use plain WebSockets to communicate with the server, which we'll write in pure
    JavaScript. Since this JavaScript is going to be run in a server environment,
    we will use **Node.js** (refer to [https://nodejs.org/](https://nodejs.org/)),
    which you may or may not be familiar with at this point. Do not worry too much
    about the details specific to Node.js just yet. We have dedicated a whole chapter
    just to getting started with Node.js and its associated ecosystem. For now, try
    to focus on the networking aspects of this game.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对网络、WebSockets和多人游戏架构的新知识疯狂之前，让我们通过创建一个非常激动人心的*井字棋*网络游戏，以最简单的方式应用这些原则。我们将使用纯WebSockets与服务器通信，服务器将使用纯JavaScript编写。由于这个JavaScript将在服务器环境中运行，我们将使用**Node.js**（参考[https://nodejs.org/](https://nodejs.org/)），你可能在这一点上对它很熟悉，也可能不熟悉。现在不要太担心Node.js的具体细节。我们已经专门为Node.js和其相关生态系统的入门编写了一整章。现在，尽量专注于这个游戏的网络方面。
- en: '![Putting it all together – Tic-tac-toe](img/B04669_01_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容整合在一起 - 井字棋](img/B04669_01_05.jpg)'
- en: Surely, you are familiar with *Tic-tac-toe*. Two players take turns marking
    a single square on a 9x9 grid, and whoever marks three spaces on the board with
    the same mark such that a straight line is formed either horizontally, vertically,
    or diagonally wins. If all nine squares are marked and the previously mentioned
    rule is not fulfilled, then the game ends in a draw.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你对*井字棋*很熟悉。两名玩家轮流在一个9x9的网格上标记一个方格，谁能标记三个相同的标记，形成水平、垂直或对角线的直线，谁就赢了。如果所有九个方格都被标记，并且之前提到的规则没有被满足，那么游戏就以平局结束。
- en: Node.js – the center of the universe
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js - 宇宙的中心
- en: As promised, we will discuss Node.js in great depth in the next chapter. For
    now, just know that Node.js is a fundamental part of our development strategy
    since the entire server will be written in Node, and all other supporting tools
    will take advantage of Node's environment. The setup that we'll use for this first
    demo game contains three main parts, namely, the **web server**, the **game server**,
    and the **client files** (where the game client resides).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的，我们将在下一章深入讨论Node.js。现在，只需知道Node.js是我们开发策略的基本部分，因为整个服务器将使用Node编写，所有其他支持工具都将利用Node的环境。我们将在这个第一个演示游戏中使用的设置包含三个主要部分，即**web服务器**、**游戏服务器**和**客户端文件**（游戏客户端所在的地方）。
- en: '![Node.js – the center of the universe](img/B04669_01_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js - 宇宙的中心](img/B04669_01_06.jpg)'
- en: There are six main files that we need to worry about for now. The rest of them
    are automatically generated by Node.js and related tooling. As for our six scripts,
    this is what each of them does.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要担心的主要是六个文件。其余的文件都是由Node.js和相关工具自动生成的。至于我们的六个脚本，每个脚本的作用如下。
- en: The /Player.js class
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /Player.js类
- en: This is a very simple class that is intended mostly to describe what is expected
    by both the game client and the server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的类，主要用于描述游戏客户端和服务器的期望。
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last line will be explained in more detail when we talk about the basics
    of Node.js. For now, what you need to know it is that it makes the `Player` class
    available to the server code as well as the client code that is sent to the browser.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Node.js的基础知识时，最后一行将会有更详细的解释。现在，你需要知道的是它使`Player`类在服务器代码以及发送到浏览器的客户端代码中都可用。
- en: In addition, we could very well just use an object literal throughout the game
    in order to represent what we're abstracting away as a `player` object. We could
    even use an array with those three values, where the order of each element would
    represent what the element is. While we're at it, we could even use a comma-separated
    string to represent all the three values.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们很可能只需在整个游戏中使用对象字面量来表示我们所抽象出的`player`对象。我们甚至可以使用一个包含这三个值的数组，其中每个元素的顺序代表元素的含义。顺便说一句，我们甚至可以使用逗号分隔的字符串来表示这三个值。
- en: As you can see, the slight verbosity incurred here by creating a whole new class
    just to store three simple values makes it easier to read the code, as we now
    know the contract that is established by the game when it asks for a `Player`.
    It will expect attributes named `id`, `label`, and `name` to be present there.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，通过创建一个全新的类来存储三个简单的值，这里产生了一些冗余，但这使得代码更易于阅读，因为现在我们知道了游戏在请求`Player`时建立的契约。它将期望在那里存在名为`id`、`label`和`name`的属性。
- en: In this case, `id` can be considered a bit superfluous because its only purpose
    is to identify and distinguish between the players. The important thing is that
    the two players have a unique ID. The label attribute is what each player will
    print on the board, which just happens to be a unique value as well between both
    the players. Finally, the name attribute is used to print the name of each player
    in a human-readable way.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`id`可以被认为有点多余，因为它的唯一目的是识别和区分玩家。重要的是两个玩家有一个唯一的ID。标签属性是每个玩家将在棋盘上打印的内容，这也恰好是两个玩家之间的一个唯一值。最后，名称属性用于以人类可读的方式打印每个玩家的名称。
- en: The /BoardServer.js class
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /BoardServer.js类
- en: This class abstracts a representation of the game of *Tic-tac-toe*, defining
    an interface where we can create and manage a game world with two players and
    a board.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类抽象了*井字棋*游戏的表示，定义了一个接口，我们可以在其中创建和管理一个有两个玩家和一个棋盘的游戏世界。
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As this code is intended to run in the server only, it takes full advantage
    of Node.js. The first part of the script imports two core Node.js modules that
    we'll leverage instead of reinventing the wheel. The first, `EventEmitter`, will
    allow us to broadcast events about our game as they take place. Second, we import
    a utility class that lets us easily leverage object-oriented programming. Finally,
    we define some static variables related to the `Board` class in order to simplify
    event registration and propagation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码只打算在服务器上运行，它充分利用了Node.js。脚本的第一部分导入了两个核心Node.js模块，我们将利用它们而不是重新发明轮子。第一个是`EventEmitter`，它允许我们广播关于游戏发生的事件。其次，我们导入一个实用类，让我们轻松地利用面向对象编程。最后，我们定义了一些与`Board`类相关的静态变量，以简化事件注册和传播。
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Board` class exposes several methods that a driver application can call
    in order to input data into it, and it emits events when certain situations occur.
    As illustrated in the method mentioned previously, whenever a player successfully
    marks an available square on the board, the game broadcasts that event so that
    the driver program knows what has happened in the game; it can then contact each
    client through their corresponding sockets, and let them know what happened.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board`类公开了几种方法，驱动程序可以调用这些方法来向其中输入数据，并在发生某些情况时触发事件。正如前面提到的方法所示，每当玩家成功在棋盘上标记一个可用的方块时，游戏就会广播该事件，以便驱动程序知道游戏中发生了什么；然后它可以通过相应的套接字联系每个客户端，并让他们知道发生了什么。'
- en: The /server.js class
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /server.js类
- en: Here, we have the driver program that uses the `Board` class that we described
    previously in order to enforce the game's rules. It also uses WebSockets to maintain
    connected clients and handle their individual interaction with the game.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个驱动程序，它使用我们之前描述的`Board`类来强制执行游戏规则。它还使用WebSockets来维护连接的客户端，并处理他们与游戏的个体交互。
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first part of this Node.js server script imports both our custom classes
    (`Board` and `Player`) as well as a handy third-party library called `ws` that
    helps us implement the WebSocket server. This library handles things such as the
    setup of the initial connection, the protocol upgrade, and so on, since these
    steps are not included in the JavaScript WebSocket object, which is only intended
    to be used as a client. After a couple of convenience objects, we have a working
    server that waits for connections on `ws://localhost:2667`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Node.js服务器脚本的第一部分导入了我们自定义的类（`Board`和`Player`）以及一个方便的第三方库`ws`，它帮助我们实现WebSocket服务器。这个库处理诸如初始连接设置、协议升级等事情，因为这些步骤不包括在JavaScript
    WebSocket对象中，该对象只是用作客户端。在一些方便的对象之后，我们有一个等待在`ws://localhost:2667`上连接的工作服务器。
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The rest of the important stuff with this server happens in the middle. For
    brevity, we've only included one example of each situation, which includes an
    event handler registration for events emitted by the `Board` class as well as
    registration of a `callback` function for events received by the socket. (Did
    you recognize the `ws.on('message', function(msg){})` function call? This is Node's
    equivalent of the client-side JavaScript `socket.onmessage = function(event){}`
    that we discussed earlier.)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器的其余重要部分发生在中间。为了简洁起见，我们只包括了`Board`类发出的事件的事件处理程序注册的一个示例，以及对套接字接收到的事件注册的`callback`函数。（你是否认出了`ws.on('message',
    function(msg){})`函数调用？这是Node中等价于我们之前讨论的客户端JavaScript`socket.onmessage = function(event){}`的函数调用。）
- en: Of major importance here is the way we handle incoming messages from the game
    clients. Since the client can only send us a single string as the message, how
    are we to know what the message is? Since there are many types of messages that
    the client can send to the server, what we do here is create our own little protocol.
    That is, each message will be a serialized `JSON` object (also known as an object
    literal) with two attributes. The first will be keyed with the value of `action`
    and the second will have a key of `data`, which can have a different value depending
    on the specified action. From here, we can look at the value of `msg.action` and
    respond to it accordingly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要之处在于我们如何处理来自游戏客户端的消息。由于客户端只能向我们发送单个字符串作为消息，我们如何知道消息是什么？由于客户端可以向服务器发送许多类型的消息，我们在这里创建了自己的小协议。也就是说，每条消息都将是一个序列化的`JSON`对象（也称为对象文字），具有两个属性。第一个属性将以`action`的值为键，第二个属性将以`data`的值为键，具体取决于指定的操作。从这里，我们可以查看`msg.action`的值，并相应地做出响应。
- en: 'For example, whenever a client connects to the game server, it sends a message
    with the following value:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每当客户端连接到游戏服务器时，它会发送一个带有以下值的消息。
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once the server receives that object as the payload of the `onmessage` event,
    it can know what the message means and the expected value for the player's nickname.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器将该对象作为`onmessage`事件的有效载荷接收，它就可以知道消息的含义以及玩家昵称的预期值。
- en: The /public/js/Board.js class
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /public/js/Board.js类
- en: This class is very similar to `BoardServer.js`, with the main difference being
    that it also handles the DOM (meaning the HTML elements rendered and managed by
    the browser), since the game needs to be rendered to human players.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与`BoardServer.js`非常相似，主要区别在于它还处理DOM（即浏览器渲染和管理的HTML元素），因为游戏需要呈现给人类玩家。
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, for brevity, we have chosen not to display much of the game's logic.
    The important things to note here are that this version of the Board class is
    very much DOM-aware, and it behaves very passively to game decisions and the enforcement
    of the game's rules. Since we're using an authoritative server, this class does
    whatever the server tells it to, such as marking itself in a way that indicates
    that a certain participant has won the game.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简洁起见，我们选择不显示游戏逻辑的大部分内容。这里需要注意的重点是，这个版本的Board类非常了解DOM，并且对游戏决策和游戏规则的执行非常被动。由于我们使用的是权威服务器，这个类会按照服务器的指示进行操作，比如标记自己以指示某个参与者赢得了游戏。
- en: The /public/js/app.js class
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /public/js/app.js类
- en: 'Similar to `server.js`, this script is the driver program for our game. It
    does two things: it takes input from the user with which it drives the server,
    and it uses input that it receives from the server in order to drive the board.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与`server.js`类似，这个脚本是我们游戏的驱动程序。它有两个功能：接收用户输入并驱动服务器，以及使用从服务器接收的输入来驱动棋盘。
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, it is noteworthy how DOM-centric the client server is. Observe also how
    obedient the client is to the messages received from the server. If the action
    specified by the server in the message that it sends to the clients is `GAME_OVER`,
    the client cleans things up, tells the player that the game is over either because
    someone won the game or the game ended in a draw, then it tells the server that
    it is ready to disconnect. Again, the client waits for the server to tell it what
    to do next. In this case, it waits for the server to clean up, then tells the
    client to disconnect itself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次需要注意的是客户端服务器是多么以DOM为中心。还要注意客户端对从服务器接收的消息是多么顺从。如果服务器在发送给客户端的消息中指定的操作是`GAME_OVER`，客户端会清理一切，告诉玩家游戏结束了，要么是因为有人赢得了游戏，要么是因为游戏以平局结束，然后告诉服务器它准备断开连接。再次，客户端等待服务器告诉它下一步该做什么。在这种情况下，它等待服务器清理，然后告诉客户端断开连接。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the basics of networking and network programming
    paradigms. We saw how WebSockets makes it possible to develop real-time, multiplayer
    games in HTML5\. Finally, we implemented a simple game client and game server
    using widely supported web technologies and built a fun game of *Tic-tac-toe*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了网络和网络编程范式的基础知识。我们看到了WebSockets如何使得在HTML5中开发实时多人游戏成为可能。最后，我们使用广泛支持的Web技术实现了一个简单的游戏客户端和游戏服务器，并构建了一个有趣的*井字棋*游戏。
- en: In the next chapter, we will take a look at the current state of the art in
    the JavaScript development world, including JavaScript in the server through Node.js.
    The chapter will teach you current techniques to manage the development cycle
    in JavaScript with workflow and resource management tools such as NPM, Bower,
    Grunt, and so on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍JavaScript开发领域的最新技术，包括通过Node.js在服务器端使用JavaScript。本章将教授您使用工作流和资源管理工具（如NPM、Bower、Grunt等）来管理JavaScript开发周期的当前技术。
