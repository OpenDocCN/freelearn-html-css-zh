- en: Chapter 2. Setting Up the Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。设置环境
- en: The goal of the last chapter was to introduce you to multiplayer game programming
    in JavaScript using current HTML5 technologies. Although we went over the implementation
    of a real multiplayer game, there was no mention made of how you might manage
    a more complex project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章的目标是介绍使用当前HTML5技术进行JavaScript多人游戏编程。虽然我们讨论了一个真正的多人游戏的实现，但并没有提到如何管理更复杂的项目。
- en: Along with new technologies such as WebSockets, we can also attribute the great
    advance that has taken place within the web platform to the supporting tools that
    have been created to support project management and workflow of HTML5 and JavaScript
    development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了诸如WebSockets之类的新技术之外，我们还可以将发生在Web平台内的巨大进步归功于已经创建的支持项目管理和HTML5和JavaScript开发工作流的支持工具。
- en: 'In this chapter, we will discuss the following principles and concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下原则和概念：
- en: Developing JavaScript applications in **Node.js**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Node.js**中开发JavaScript应用程序
- en: Writing modular JavaScript applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写模块化的JavaScript应用程序
- en: Managing Node.js packages with **npm**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**npm**管理Node.js包
- en: Managing client-side packages with **Bower**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Bower**管理客户端包
- en: Automating JavaScript development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化JavaScript开发
- en: JavaScript outside the browser with Node.js
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js中的JavaScript在浏览器之外
- en: It wasn't too many years ago when a so-called web developer used JavaScript
    on the rare occasion when a web form needed client-side validation. Since CSS
    wasn't as advanced as it is today, or at least it wasn't widely supported, JavaScript
    was also used in order to create image rollover effects. Not many years ago, the
    words JavaScript and programmer would not have gone well together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，所谓的Web开发人员很少使用JavaScript，只有在Web表单需要客户端验证时才会用到。由于CSS不像今天这样先进，或者至少没有得到广泛支持，JavaScript也被用来创建图像滚动效果。不久前，JavaScript和程序员这两个词是不太搭配的。
- en: However, times change and technologies evolve. Today, qualified JavaScript programmers
    are sought after and compensated very competitively relative to programmers of
    other programming languages. This is a reflection of how popular and powerful
    the JavaScript language has become.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，时代在变化，技术在进化。如今，合格的JavaScript程序员受到追捧，并且相对于其他编程语言的程序员来说，薪酬竞争力非常强。这反映了JavaScript语言变得多么受欢迎和强大。
- en: As a result, JavaScript is steadily going from being *The World's Most Misunderstood
    Programming Language* (*Crockford*, *Douglas (2001)*. [http://javascript.crockford.com/javascript.html](http://javascript.crockford.com/javascript.html))
    to becoming an enterprise-level language, which is used in applications both inside
    the browser as well as in standalone programs, including server applications.
    As explained and illustrated in the last chapter, JavaScript is used in different
    ways when it is employed for the client-side build of your game as well as the
    game server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript正在稳步从*世界上最被误解的编程语言*（*Crockford*，*Douglas（2001）*。[http://javascript.crockford.com/javascript.html](http://javascript.crockford.com/javascript.html)）变成一个企业级语言，它被用于浏览器内部以及独立程序，包括服务器应用程序。正如上一章所解释和说明的，当它被用于游戏的客户端构建以及游戏服务器时，JavaScript以不同的方式被使用。
- en: You may remember that a game server doesn't have to be written in JavaScript.
    In fact, the game client has absolutely no idea what language the server is written
    in since all of its communication with the server takes place through the WebSocket
    protocol. However, since we want to maximize the amount of code that we can share
    between client and server, while reducing the overall amount of code that we write
    at the same time, we will write our games in a way where this sharing of code
    is possible. That is where Node.js comes into play.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得游戏服务器不一定要用JavaScript编写。事实上，游戏客户端根本不知道服务器是用什么语言编写的，因为它与服务器的所有通信都是通过WebSocket协议进行的。然而，由于我们希望最大化我们可以在客户端和服务器之间共享的代码量，同时减少我们编写的总代码量，我们将以一种可以实现代码共享的方式编写我们的游戏。这就是Node.js发挥作用的地方。
- en: Node.js
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js
- en: Without doubt, you've heard of Node.js by now. For those who are not exactly
    sure what Node actually is, it is simply a runtime environment built on Google
    Chrome's JavaScript engine (also known as **V8**). In other words, Node is neither
    a special version of JavaScript nor is it a standalone JavaScript engine, but
    rather, it is an entire ecosystem that happens to leverage Google's open source
    JavaScript engine, which happens to be, arguably, one of the seven wonders of
    the world today.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，你现在应该已经听说过Node.js了。对于那些不太确定Node实际是什么的人来说，它只是建立在谷歌Chrome的JavaScript引擎（也称为**V8**）之上的运行时环境。换句话说，Node既不是JavaScript的特殊版本，也不是独立的JavaScript引擎，而是一个整个的生态系统，碰巧利用了谷歌的开源JavaScript引擎，这可能是当今世界上的七大奇迹之一。
- en: '![Node.js](img/B04669_02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js](img/B04669_02_01.jpg)'
- en: Two characteristics of Node.js that are worth mentioning are that Node.js is
    not tied to the browser, and every I/O operation is asynchronous.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是Node.js的两个特点是它不依赖于浏览器，以及每个I/O操作都是异步的。
- en: As for it not being a browser environment, you will not find a window object
    like you do in a browser. In addition, since none of the restrictions that are
    imposed by a browser exist in the Node.js environment, you can take full advantage
    of the underlying operating system. First, think of whatever server-side language
    you have been using so far, or whatever programming language you were considering
    using to write your game servers that we discussed in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Multiplayer Game Programming"), *Getting Started with Multiplayer
    Game Programming*. Then, replace that language in your mind with JavaScript. This
    is the big offer that Node.js makes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 至于它不是浏览器环境，您不会像在浏览器中那样找到window对象。此外，由于Node.js环境中不存在浏览器施加的任何限制，您可以充分利用底层操作系统。首先，想象一下到目前为止您一直在使用的服务器端语言，或者您考虑使用来编写我们在[第1章](ch01.html
    "第1章。开始多人游戏编程")中讨论的游戏服务器的任何编程语言，*开始多人游戏编程*。然后，在您的脑海中用JavaScript替换该语言。这就是Node.js提供的重要优势。
- en: 'Some of the benefits that you will find in using JavaScript on both ends of
    the stack (server side and client side) include the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈的两端（服务器端和客户端）使用JavaScript的一些好处包括以下内容：
- en: You can share a lot of the code that you write for the server and client
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以共享为服务器和客户端编写的大量代码
- en: You only need to master one language
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只需要掌握一种语言
- en: JavaScript is a powerful language that solves many of the problems that exist
    in other languages
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript是一种强大的语言，解决了其他语言中存在的许多问题
- en: Since JavaScript is single threaded, you will never have deadlocks or many of
    the issues associated with multi-threaded programming
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于JavaScript是单线程的，您永远不会遇到死锁或许多与多线程编程相关的问题
- en: By now, I hope that you are able to see how fundamental Node.js can be in HTML5
    multiplayer game development, or at least how crucial it will be in this book.
    Before we dive too deeply into some of the fundamental concepts, let us ensure
    that you can install and run it on your system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我希望您能够看到Node.js在HTML5多人游戏开发中有多么基础，或者至少在本书中有多么关键。在我们深入探讨一些基本概念之前，让我们确保您可以在系统上安装和运行它。
- en: Installing Node.js
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: The two recommended ways to install Node.js on your system are to download an
    executable file from the official website at [http://www.nodejs.org](http://www.nodejs.org)
    or to install it manually by compiling the source code. Depending on your operating
    system of choice, you may also be able to install it via some package management
    system or a similar tool. Whatever method you decide to pursue, be sure to install
    the latest stable version, which, as of this writing, is Version 0.12.0.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上安装Node.js的两种推荐方法是从官方网站[http://www.nodejs.org](http://www.nodejs.org)下载可执行文件，或者通过编译源代码手动安装。根据您选择的操作系统，您还可以通过某些软件包管理系统或类似工具安装它。无论您决定采取哪种方法，请确保安装最新的稳定版本，截至撰写本文时，最新版本是0.12.0。
- en: 'Once you have installed Node.js on your system, you can take it for a test
    run by opening a terminal window and typing in the following commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在系统上安装了Node.js，您可以通过打开终端窗口并输入以下命令来进行测试：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If all goes well during the installation process, you should see an output
    similar to the one displayed in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在安装过程中一切顺利，您应该会看到类似于以下截图中显示的输出：
- en: '![Installing Node.js](img/B04669_02_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![安装Node.js](img/B04669_02_02.jpg)'
- en: 'You can check the version of Node.js that you have installed by running the
    following command on your terminal:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端上运行以下命令来检查已安装的Node.js版本：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though the latest version available today (as of this writing, in early
    2015) is 0.12.0, all scripts described in this book are written in and tested
    against Version 0.10.25\. For backward-and forward-compatibility issues and questions,
    be sure to reference Node.js's official backlogs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管今天（撰写本文时，即2015年初）可用的最新版本是0.12.0，但本书中描述的所有脚本都是在版本0.10.25中编写和测试的。对于向后和向前兼容性问题和疑问，请务必参考Node.js的官方待办事项。
- en: Writing modular JavaScript
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模块化JavaScript
- en: Before the advent of Node.js, given all of JavaScript's infamous restrictions,
    probably the biggest complaint that it received from developers was the lack of
    built-in support for a modular development process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js出现之前，鉴于JavaScript的臭名昭著的限制，开发人员可能对其最大的抱怨是缺乏对模块化开发过程的内置支持。
- en: The best practice for modular JavaScript development was creating your components
    inside a literal object, which, in its own way, behaved somewhat like a namespace.
    The idea was to create an object in the global scope, then use the named properties
    inside that object to represent specific namespaces where you would declare your
    classes, functions, constants, and so on (or at least the JavaScript equivalent).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化JavaScript开发的最佳实践是在字面对象内创建组件，以某种方式行为类似于命名空间。这个想法是在全局范围内创建一个对象，然后使用该对象内的命名属性来表示您将声明类、函数、常量等的特定命名空间（或至少JavaScript等效项）。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code snippet, we create an empty object in case the `packt`
    variable doesn't exist. In case it does, we don't replace it with an empty object,
    but we assign a reference to it to the `packt` variable. We do the same with the
    math property, inside which we add a constructor function named `Vec2d`. Now,
    we can confidently create instances of that specific vector class, knowing that,
    if there is some other vector library in our global scope, even if it's also named
    `Vec2`, it won't clash with our version since our constructor function resides
    inside the `packt.math` object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码片段中，我们在`packt`变量不存在的情况下创建一个空对象。如果存在，我们不会用空对象替换它，而是将一个引用分配给`packt`变量。我们在math属性中也是一样，其中我们添加了一个名为`Vec2d`的构造函数。现在，我们可以自信地创建特定向量类的实例，知道如果我们的全局范围内还有其他向量库，即使它也被命名为`Vec2`，它也不会与我们的版本冲突，因为我们的构造函数位于`packt.math`对象内。
- en: 'While this method worked relatively well for a long time, it does come with
    three drawbacks:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法在很长一段时间内运行得相对良好，但它确实有三个缺点：
- en: Typing the entire namespace every time needs a lot of work
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次键入整个命名空间都需要很多工作
- en: Constantly referencing deeply nested functions and properties hurts performance
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不断引用深层嵌套的函数和属性会影响性能
- en: Your code can easily be replaced by a careless assignment to a top-level `namespace`
    property
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的代码很容易被粗心的赋值替换为顶级 `namespace` 属性
- en: The good news is that today there is a better way to write modules in JavaScript.
    By recognizing the shortcomings of the old way of doing things, a few proposed
    standards have emerged to solve this very problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，今天有一种更好的方法来编写 JavaScript 模块。通过认识到旧方式的缺点，一些提出的标准出现了，以解决这个问题。
- en: CommonJS
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommonJS
- en: In 2009, the folks at Mozilla created a project that was aimed at defining a
    way to develop JavaScript applications that were freed from the browser. (refer
    to [http://en.wikipedia.org/wiki/CommonJS](http://en.wikipedia.org/wiki/CommonJS).)
    Two distinct features of this approach are the `require` statement, which is similar
    to what other languages offer, and the `exports` variable, from where all the
    code to be included on a subsequent call to the require function comes. Each exported
    module resides inside a separate file, making it possible to identify the file
    referenced by the `require` statement as well as isolate the code that makes up
    the module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 2009 年，Mozilla 的开发人员创建了一个旨在定义一种从浏览器中解放出来的 JavaScript 应用程序的方式的项目。 (参见 [http://en.wikipedia.org/wiki/CommonJS](http://en.wikipedia.org/wiki/CommonJS).)
    这种方法的两个显著特点是 `require` 语句，它类似于其他语言提供的功能，以及 `exports` 变量，从这里来的所有代码将被包含在对 require
    函数的后续调用中。每个导出的模块都驻留在单独的文件中，这样就可以识别 `require` 语句引用的文件，并隔离组成模块的代码。
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code creates a module inside a file named `player.js`. The takeaways here
    are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在名为 `player.js` 的文件中创建了一个模块。这里的要点如下：
- en: The contents of your actual module are the same old, plain JavaScript that you're
    used to and are in love with
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您实际模块的内容是您所熟悉和热爱的相同的旧式 JavaScript
- en: Whatever code you wish to export is assigned to the `module.exports` variable
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望导出的任何代码都分配给 `module.exports` 变量
- en: Before we look at how to make use of this module, let us expound on the last
    point mentioned previously. As a result of how JavaScript closures work, we can
    reference values in a file (within the file) that are not directly exported through
    `module.exports`, and the values cannot be accessed (or modified) outside the
    module.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何使用这个模块之前，让我们详细说明之前提到的最后一点。由于 JavaScript 闭包的工作原理，我们可以引用文件中（在文件内部）未直接通过
    `module.exports` 导出的值，这些值无法在模块外部访问（或修改）。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `Player` constructor function accepts a width and height value,
    which will be assigned to a local and corresponding width and height attribute
    on instances of that class. However, if we omit these values, instead of assigning
    undefined or null to the instance's attributes, we fallback to the values specified
    in the `defaults` object. The benefit is that the object cannot be accessed anywhere
    outside the module since we don't export the variable. Of course, if we make use
    of EcmaScript 6's `const` declaration, we could achieve read-only named constants,
    as well as through EcmaScript 5's `Object.defineProperty`, with the writable bit
    set to false. However, the point here still holds, which is that nothing outside
    an exported module has direct access to values within a module that were not exported
    through `module.exports`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Player` 构造函数接受宽度和高度值，这些值将分配给该类实例的本地和对应的宽度和高度属性。但是，如果我们省略这些值，那么我们将回退到 `defaults`
    对象中指定的值，而不是将未定义或空值分配给实例的属性。好处是该对象无法在模块外部任何地方访问，因为我们没有导出该变量。当然，如果我们使用 EcmaScript
    6 的 `const` 声明，我们可以实现只读的命名常量，以及通过 EcmaScript 5 的 `Object.defineProperty`，将可写位设置为
    false。然而，这里的要点仍然是，未导出的模块外部的任何东西都无法直接访问模块中未通过 `module.exports` 导出的值。
- en: Now, to make use of CommonJs modules, we need to be sure that we can reach the
    code locally within the filesystem. In its simplest form, a require statement
    will look for a file (relative to the one provided) to include, where the name
    of the file matches the require statement.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用 CommonJs 模块，我们需要确保可以在文件系统中本地访问代码。在其最简单的形式中，一个 require 语句将寻找一个文件（相对于所提供的文件）来包含，其中文件的名称与
    require 语句匹配。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run the script in the app.js file, we can use the following command within
    the same directory where `app.js` is stored:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 app.js 文件中运行脚本，我们可以在与存储 `app.js` 相同的目录中使用以下命令：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Assuming that the `app.js` and `player.js` files are stored in the same directory,
    Node should be able to find the file named `player.js`. If `player.js` was located
    in the parent directory from `app.js`, then the `require` statement would need
    to look like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `app.js` 和 `player.js` 文件存储在同一个目录中，Node 应该能够找到名为 `player.js` 的文件。如果 `player.js`
    存储在 `app.js` 的父目录中，那么 `require` 语句需要如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you'll see later, we can use Node's package management system to import modules
    or entire libraries very easily. Doing so causes the imported packages to be stored
    in a methodical manner, which, as a result, makes requiring them into your code
    much easier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在后面看到的，我们可以使用 Node 的包管理系统非常容易地导入模块或整个库。这样做会使导入的包以一种有条理的方式存储，从而使将它们引入您的代码变得更容易。
- en: 'The next way of requiring a module is by simply including the exported module''s
    name in the require statement, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种导入模块的方式是简单地在 require 语句中包含导出模块的名称，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run the previous file, you will see a fatal runtime error that looks
    something like the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行先前的文件，您将看到一个致命的运行时错误，看起来像以下的屏幕截图：
- en: '![CommonJS](img/B04669_02_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![CommonJS](img/B04669_02_03.jpg)'
- en: The reason Node can't find the `player.js` file is because, when we don't specify
    the name of the file with a leading period (this means that the file included
    is relative to the current script), it will look for the file inside a directory
    named `node_modules` within the same directory as the current script.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Node无法找到`player.js`文件的原因是，当我们不使用前导句号指定文件名（这意味着包含的文件是相对于当前脚本的），它会在与当前脚本相同的目录中寻找名为`node_modules`的目录中的文件。
- en: If Node is unable to find a matching file inside `node_modules`, or if the current
    directory does not have a directory that is so named, it will look for a directory
    named `node_modules` along with a file with the same name, similar to the require
    statement in the parent directory of the current script. If the search there fails,
    it will go up one more directory level and look for the file inside a `node_modules`
    directory there. The search continues as far as the root of the filesystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Node无法在`node_modules`中找到匹配的文件，或者当前目录没有这样命名的目录，它将在与当前脚本的父目录中的`require`语句类似的目录中寻找名为`node_modules`的目录以及同名的文件。如果在那里搜索失败，它将再向上查找一个目录级别，并在那里的`node_modules`目录中寻找文件。搜索将一直持续到文件系统的根目录。
- en: Another way to organize your files into a reusable, self-contained module is
    to bundle your files in a directory within `node_modules` and make use of an `index.js`
    file that represents the entry point to the module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件组织成可重用的、自包含模块的另一种方法是将文件捆绑在`node_modules`中的一个目录中，并利用一个代表模块入口点的`index.js`文件。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the name of the module, as specified in the `require` statement, now
    matches the name of a directory within `node_modules`. You can tell that Node
    will look for a directory instead of a filename that matches the one supplied
    in the `require` function when the name doesn't start with characters that indicate
    either a relative or absolute path ("`/`", "`./`", or "`../`") and the file extension
    is left out.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模块的名称，在`require`语句中指定的，现在与`node_modules`中的一个目录的名称匹配。当名称不以指示相对或绝对路径的字符（"`/`"，"`./`"或"`../`"）开头，并且文件扩展名被省略时，可以确定Node将寻找一个目录而不是与`require`函数中提供的名称匹配的文件。
- en: When Node looks for a directory name, as shown in the preceding example, it
    will first look for an `index.js` file within the matched directory and return
    its contents. If Node doesn't find an `index.js` file, it will look for a file
    named `package.json`, which is a manifest file that describes the module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当Node查找目录名称时，如前面的示例所示，它将首先在匹配的目录中查找`index.js`文件并返回其内容。如果Node找不到`index.js`文件，它将查找一个名为`package.json`的文件，这是描述模块的清单文件。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Assuming that we have renamed the `node_modules/MyPlayer/index.js` file as `node_modules/MyPlayer/player.js`,
    all will work as before.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已将`node_modules/MyPlayer/index.js`文件重命名为`node_modules/MyPlayer/player.js`，一切将与以前一样工作。
- en: Later in this chapter, when we talk about npm, we will dive deeper into `package.json`
    since it plays an important role in the Node.js ecosystem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，当我们谈论npm时，我们将更深入地了解`package.json`，因为它在Node.js生态系统中扮演着重要的角色。
- en: RequireJS
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RequireJS
- en: An alternative project that attempts to solve JavaScript's lack of native script
    importing and a standard module specification is RequireJS. (refer to [http://requirejs.org/](http://requirejs.org/).)
    Actually, RequireJS is a specific implementation of the **Asynchronous Module**
    **Definition** (**AMD**) specification. AMD is a specification that defines an
    API for *defining modules such that the module and its dependencies can be asynchronously
    loaded* [Burke, James (2011). [https://github.com/amdjs/amdjs-api/wiki/AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)].
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 试图解决JavaScript缺乏本地脚本导入和标准模块规范的另一个项目是RequireJS。 （参见[http://requirejs.org/](http://requirejs.org/)。）实际上，RequireJS是**异步模块定义**（**AMD**）规范的一个特定实现。
    AMD是一个定义模块及其依赖项可以异步加载的API的规范[Burke，James（2011）。[https://github.com/amdjs/amdjs-api/wiki/AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)]。
- en: A distinctive difference between CommonJS and RequireJS is that RequireJS is
    designed for use inside a browser, whereas CommonJS doesn't have a browser in
    mind. However, both methods can be adapted for the browser (in the case of CommonJS)
    as well as for other environments (in the case of RequireJS).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS和RequireJS之间的一个显著区别是，RequireJS设计用于在浏览器内部使用，而CommonJS并没有考虑浏览器。然而，这两种方法都可以适应浏览器（在CommonJS的情况下）以及其他环境（在RequireJS的情况下）。
- en: 'Similar to CommonJS, RequireJS can be thought of as having two parts: a module
    definition script and a second script that consumes (or requires) the modules.
    In addition, similar to CommonJS but more obvious in RequireJS, is the fact that
    every app has a single entry point. This is where the requiring begins.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与CommonJS类似，RequireJS可以被认为有两部分：一个模块定义脚本和一个消费（或需要）模块的第二个脚本。此外，与CommonJS类似但在RequireJS中更明显的是，每个应用程序都有一个单一的入口点。这是需要开始的地方。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we include the `require.js` library in an HTML file, specifying the entry
    point, which is indicated by the `data-main` attribute. Once the library loads,
    it will attempt to load a script named `app.js` that is located in a directory
    named `scripts`, which is stored on the same path as the host `index.html` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在HTML文件中包含`require.js`库，指定入口点，这由`data-main`属性表示。一旦库加载，它将尝试加载名为`app.js`的脚本，该脚本位于名为`scripts`的目录中，该目录存储在与主机`index.html`文件相同的路径上。
- en: Two things to note here are that the `scripts/app.js` script is loaded asynchronously,
    as opposed to the default way all scripts are loaded by the browser when using
    a `script` tag. Furthermore, `scripts/app.js` can itself require other scripts,
    which will in turn be loaded asynchronously.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的两件事是，`scripts/app.js`脚本是异步加载的，而不是使用`script`标签时浏览器默认加载所有脚本的方式。此外，`scripts/app.js`本身可以要求其他脚本，这些脚本将依次异步加载。
- en: By convention, the entry point script (`scripts/app.js` in the previous example)
    will load a configuration object so that RequireJS can be adapted to your own
    environment and then the real application entry point is loaded.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，入口脚本（在上一个示例中为`scripts/app.js`）将加载一个配置对象，以便RequireJS可以适应您自己的环境，然后加载真正的应用程序入口点。
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous example, we first configure the script loader, then we require
    two modules—first the `jQuery` library and then a module named `player`. The `baseUrl`
    option in the configuration block tells RequireJS to load all the scripts from
    the `scripts/lib` directory, which is relative to the file that loaded `scripts/app.js`
    (in this case, `index.html`). The path's attribute allows you to create exceptions
    to that `baseUrl`, rewriting the path to scripts whose require name (known as
    the **module ID**) starts with, in this case, the `app` string . When we require
    `app/player`, RequireJS will load a script, which is relative to `index.html`,
    `scripts/app/player.js`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们首先配置了脚本加载器，然后我们需要两个模块——首先是`jQuery`库，然后是一个名为`player`的模块。配置块中的`baseUrl`选项告诉RequireJS从`scripts/lib`目录加载所有脚本，这是相对于加载`scripts/app.js`的文件（在本例中为`index.html`）。路径属性允许您对`baseUrl`创建异常，重写以`app`字符串开头的脚本的路径，这被称为**模块ID**。当我们需要`app/player`时，RequireJS将加载一个相对于`index.html`的脚本`scripts/app/player.js`。
- en: Once those two modules are loaded, RequireJS will invoke the callback function
    that you passed to the `requirejs` function, adding the modules that were requested
    as parameters in the same order as specified.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了这两个模块，RequireJS将调用传递给`requirejs`函数的回调函数，按照指定的顺序将请求的模块作为参数添加进去。
- en: You may be wondering why we talked about both CommonJS and RequireJS since the
    goal is to share as much code as possible between the server and the client. The
    reason for covering both methods and tools is for completeness and information
    purposes only. Since Node.js already uses CommonJS for its module-loading strategy,
    there is little reason to use RequireJS in the server. Instead of mixing RequireJS
    for use in the browser, what is commonly done (this will be the approach of choice
    for the rest of the book) is to use CommonJS for everything (including **client-side**
    code) and then run a tool called **Browserify** over the client code, making it
    possible to load scripts in the browser that make use of CommonJS. We'll cover
    Browserify shortly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么我们谈论了CommonJS和RequireJS，因为目标是在服务器和客户端之间尽可能共享尽可能多的代码。覆盖两种方法和工具的原因仅是为了完整性和信息目的。由于Node.js已经使用CommonJS作为其模块加载策略，几乎没有理由在服务器上使用RequireJS。而不是混合使用RequireJS在浏览器中使用，通常做法（这将是本书其余部分的选择）是在所有地方使用CommonJS（包括**客户端**代码），然后在客户端代码上运行一个名为**Browserify**的工具，使得可以在浏览器中加载使用CommonJS的脚本。我们将很快介绍Browserify。
- en: Managing Node.js packages with Npm
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Npm管理Node.js包
- en: Npm is a package manager for JavaScript and is similar to **Composer** for PHP
    or **Pip** for Python. (go to [https://www.npmjs.com/](https://www.npmjs.com/).)
    Some people may assure you that npm stands for Node Package Manager, but although
    it has been Node.js's default package manager since version 0.6.3, npm is not
    an acronym. Thus, you will often see npm spelled in lowercase.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Npm是JavaScript的包管理器，类似于PHP的**Composer**或Python的**Pip**。（转到[https://www.npmjs.com/](https://www.npmjs.com/)。）有些人可能会告诉您npm代表Node
    Package Manager，但尽管自0.6.3版本以来一直是Node.js的默认包管理器，npm并不是一个首字母缩写词。因此，您经常会看到npm以小写形式拼写。
- en: To quickly check if you have npm installed, you can use a terminal window to
    query the version of npm that you have installed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速检查是否已安装npm，可以使用终端窗口查询已安装的npm版本。
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For instructions on how to install npm on your particular operating system,
    ensure that you follow the guidelines on npm's official website. The version used
    in the sample codes and demo applications in this book is version 1.3.10.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在特定操作系统上安装npm的说明，请确保您遵循npm官方网站上的指南。本书中示例代码和演示应用程序使用的版本是1.3.10。
- en: When using npm to install third-party packages, you can choose to install them
    either locally for your project, or globally so that the package will be visible
    anywhere in your system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用npm安装第三方包时，可以选择将其安装在项目的本地位置，也可以全局安装，以便在系统的任何位置都可见该包。
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, when you install a package (in the previous example, we install
    a package named `watch` that watches directories and files for changes) with no
    flags, the package is installed locally (assuming a `package.json` file also exists)
    and saved to a `node_modules` directory relative to where the command was executed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当您安装一个包（在上一个示例中，我们安装了一个名为`watch`的包，用于监视目录和文件的更改）时，如果没有标志，该包将被安装在本地（假设`package.json`文件也存在），并保存到执行命令的相对位置的`node_modules`目录中。
- en: 'To install a package globally or system-wide, just append the `-g` flag to
    the install command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局或系统范围安装一个包，只需在安装命令后附加`-g`标志：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By convention, if you need a package that is used within your code through `require`
    statements, you will want to save the package locally. If the intent is to use
    the package as an executable code from your command line, then you will normally
    want to install it globally.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，如果您需要一个通过`require`语句在代码中使用的包，您将希望将该包保存在本地。如果意图是从命令行中使用包作为可执行代码，那么通常会希望全局安装它。
- en: 'If you want to build on your `package.json` manifest so that the local packages
    your project depends on can be shared and easily installed, you can either edit
    the manifest file manually, adding the dependency to the `json` object under the
    "`dependencies`" key, or you can let npm do that for you, but without forgetting
    to specify the `--save` flag:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在`package.json`清单上构建，以便项目依赖的本地包可以共享并轻松安装，可以手动编辑清单文件，在“`dependencies`”键下的`json`对象中添加依赖项，或者让npm为您执行此操作，但不要忘记指定`--save`标志：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that running the previous command will download the code that makes up
    the requested package into your working directory as well as update your `package.json`
    manifest so that you can later update the packages or install them anew, as needed.
    In other words, you can always use your existing `package.json` file to rebuild
    your development environment as far as your third-party dependencies are concerned.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行上一个命令将下载组成所请求包的代码到你的工作目录，并更新你的`package.json`清单，以便以后更新包或根据需要重新安装它们。换句话说，你可以随时使用你现有的`package.json`文件来重建你的开发环境，就第三方依赖而言。
- en: 'Once you have one or more dependencies specified in your `package.json` file,
    you can install them by running npm, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在`package.json`文件中指定了一个或多个依赖项，你可以通过运行npm来安装它们，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will download all the dependencies in your manifest file and save them
    into `node_modules`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载清单文件中的所有依赖项并保存到`node_modules`中。
- en: 'Similarly, you can update packages through npm by using the update command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以通过使用update命令通过npm更新包：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you don't know how to get started to create a `package.json` manifest file,
    you can let npm help you to fill in the blanks for the most common attributes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道如何开始创建一个`package.json`清单文件，你可以让npm帮助你填写最常见属性的空白部分。
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will load an interactive utility that asks you to enter values for the
    various attributes for the manifest, such as the package name, version, author
    name, and so on. It also offers some same default values so that you can either
    ignore attributes you don't know what they do, or you can trust npm with whatever
    fallback option it offers you, making it easy for you to quickly get a manifest
    file going.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载一个交互式实用程序，要求你为清单的各种属性输入值，比如包名称、版本、作者名称等。它还提供了一些默认值，这样你可以忽略你不知道它们的属性，或者你可以信任npm提供的任何后备选项，让你很容易快速获得一个清单文件。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once you have a generic `package.json` manifest, you can add your dependencies
    to it with npm install commands.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个通用的`package.json`清单，你可以用npm install命令将你的依赖项添加到其中。
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course, you can always edit the file manually to change values or remove
    attributes that you feel are unnecessary, such as license, description, or version.
    Some attributes are only meaningful if you plan to share your package privately
    or with the global npm registry. Other values, such as scripts, are used for convenience
    during development. For example, we can register a script to be executed when
    we run `npm <script value>`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以随时手动编辑文件来更改值或删除你认为不必要的属性，比如许可证、描述或版本。有些属性只有在你计划私下或与全局npm注册表共享你的包时才有意义。其他值，比如脚本，用于方便开发。例如，我们可以注册一个脚本，当我们运行`npm
    <script value>`时执行。
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Thus, we can have Node run a script named `test.js` through npm with the following
    command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以让Node通过npm运行一个名为`test.js`的脚本，命令如下：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While you may not be saving a lot of typing by using npm in this case, you do
    make it more standard for others to know, for example, how to run your tests,
    even if your test runner scripts are not named or executed in any particular standard
    form.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这种情况下使用npm可能不会节省很多输入，但它确实使其他人更容易知道，例如，如何运行你的测试，即使你的测试运行器脚本没有以任何特定的标准形式命名或执行。
- en: Managing frontend packages with Bower
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bower管理前端包
- en: If you're not impressed enough with npm as a backend JavaScript package manager,
    perhaps Bower will take you to the next level of joy. (Refer to [http://bower.io/](http://bower.io/).)
    Bower works very similarly to npm. In fact, most commands and conventions that
    we've just discussed for npm work verbatim in Bower.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对npm作为后端JavaScript包管理器并不满意，也许Bower会让你更加快乐。 （参见[http://bower.io/](http://bower.io/)。）Bower的工作方式与npm非常相似。事实上，我们刚刚讨论的大多数npm命令和约定在Bower中都可以直接使用。
- en: 'In fact, Bower itself is a Node.js module that is installed through npm:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Bower本身是一个通过npm安装的Node.js模块：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can interact with Bower the same way we've interacted with npm so far.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与npm相同的方式与Bower交互。
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Bower makes use of a `bower.json` manifest file, which by now should look somewhat
    familiar to you. To install dependencies, either edit the manifest by hand or
    leverage Bower.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Bower使用`bower.json`清单文件，到目前为止，这应该对你来说看起来有些熟悉。要安装依赖项，要么手动编辑清单，要么利用Bower。
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The main difference between Bower and npm, as should be apparent by now, is
    that Bower deals with frontend dependencies, which can be JavaScript, CSS, HTML,
    font files, and so on. Bower will save dependencies inside a `bower_components`
    directory, similar to npm's `node_dependencies`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Bower和npm之间的主要区别是，Bower处理前端依赖项，可以是JavaScript、CSS、HTML、字体文件等。Bower将依赖项保存在`bower_components`目录中，类似于npm的`node_dependencies`。
- en: Browserify
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Browserify
- en: 'Finally, let us use this very handy npm package to leverage our CommonJS modules
    (as well as Node''s native modules) for use in the browser. This is exactly what
    Browserify does: it takes an entry point script, follows all require statements
    recursively from that file down, then inlines all files in the dependency tree
    that it builds, and returns a single file. (Refer to [http://browserify.org/](http://browserify.org/).)
    This way, when a browser runs across a require statement in one of your scripts,
    it doesn''t have to fetch the file from the filesystem; it fetches the file from
    within the same file.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用这个非常方便的npm包来利用我们的CommonJS模块（以及Node的原生模块）在浏览器中使用。这正是Browserify的作用：它接受一个入口点脚本，从该文件递归地跟随所有require语句，然后内联构建的依赖树中的所有文件，并返回一个单一文件。（参见[http://browserify.org/](http://browserify.org/)。）这样，当浏览器在你的脚本中遇到一个require语句时，它不必从文件系统中获取文件；它从同一个文件中获取文件。
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once we have installed Browserify (again, since this is intended to be used
    as a command line tool, we install it globally), we can `bundle` all of our CommonJS
    files in one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Browserify（再次强调，因为这是用作命令行工具，我们要全局安装它），我们可以将所有的CommonJS文件“捆绑”在一起。
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Browserify will take care of requiring all of the dependencies as needed so
    that the output file will have all of its dependencies ready to be used, as shown
    in the preceding code sample.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify将负责根据需要引入所有的依赖项，以便输出文件具有所有准备好供使用的依赖项，就像上面的代码示例中所示的那样。
- en: Browserify takes the name of the entry point as the first argument and prints
    the output to standard output by default. Alternately, we can specify a filename
    where the bundle will be saved.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify将入口点的名称作为第一个参数，并默认将输出打印到标准输出。或者，我们可以指定一个文件名，将捆绑保存在那里。
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Browserify will now create a file named `bundle.js`, which we can include in
    an HTML file and use in the browser. Additionally, we can compress the output
    file with any of the many available tools that are found in npm's registry.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify现在将创建一个名为`bundle.js`的文件，我们可以在HTML文件中包含它，并在浏览器中使用。此外，我们可以使用npm注册表中的许多可用工具之一来压缩输出文件。
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Running the preceding code will install a node package named **UglifyJS**, which
    parses, mangles, compresses, and shrink-wraps our `bundle.js` file very smartly.
    (Refer to [https://github.com/mishoo/UglifyJS](https://github.com/mishoo/UglifyJS).)
    The output will be both very small in size and not at all readable by humans.
    As a bonus, it creates a `source map` file, which allows us to debug the minified
    file by mapping it back to the original `bundle.js` file in its original form.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码将安装一个名为**UglifyJS**的node包，它可以非常智能地解析、混淆、压缩和收缩我们的`bundle.js`文件。（参考[https://github.com/mishoo/UglifyJS](https://github.com/mishoo/UglifyJS)。）输出文件将非常小，并且对人类来说完全不可读。作为奖励，它还创建了一个`source
    map`文件，这样我们就可以通过将其映射回原始的`bundle.js`文件来调试被最小化的文件。
- en: Automating your workflow
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化您的工作流程
- en: 'So far, we have learned how to perform the following tasks:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了执行以下任务：
- en: Writing modular JavaScript code that can be imported into other modules
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可导入其他模块的模块化JavaScript代码
- en: Reusing modules in client and server code through CommonJS and Browserify
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过CommonJS和Browserify在客户端和服务器端代码中重用模块
- en: Managing node packages with npm
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm管理node包
- en: Managing client packages with Bower
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bower管理客户端包
- en: Now we're ready to bring this all together in a way that takes the burden of
    running all these commands away from us. Picture for a moment what it would be
    like if you had to write a few lines of code, save your work, skip over to the
    command line, run Browserify, then run Uglify-js, then run your unit tests, followed
    by a handful of other npm tools, and then finally hop over to a browser, refresh
    the browser, and see the updated app working. Oh, wait! You forgot to restart
    the game server, which is a Node.js app, and needs to be restarted after you change
    those files. So, you go back to the terminal, run a few more commands, and eventually,
    you see the new code in the browser.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备以一种方式将所有这些内容整合起来，以便摆脱我们运行所有这些命令的负担。试想一下，如果您必须编写几行代码，保存您的工作，跳到命令行，运行Browserify，然后运行Uglify-js，然后运行您的单元测试，然后运行其他几个npm工具，最后跳到浏览器，刷新浏览器，看到更新后的应用程序正在运行。哦，等等！您忘记重新启动游戏服务器，它是一个Node.js应用程序，在更改这些文件后需要重新启动。所以，您回到终端，运行几个命令，最终，您会在浏览器中看到新的代码。
- en: If that mental exercise just made all those wonderful tools that we covered
    earlier in the chapter look like a lot of work, remain calm. There is yet another
    set of tools that we can count on to make our lives easier, and JavaScript development
    is a thing of beauty (as opposed to what it is commonly called, particularly by
    those who do not use the tools that we'll now discuss).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刚才的思维练习让我们所涵盖的这些精彩工具看起来像是很多工作，保持冷静。我们还有另一套工具可以让我们的生活变得更轻松，JavaScript开发是一种美妙的事情（与通常所说的相反，特别是那些不使用我们将要讨论的工具的人）。
- en: Grunt
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grunt
- en: '**Grunt** is a popular task runner tool that automates repetitive tasks you
    may need to do, such as running unit tests, bundling components, minifying bundles,
    creating API documentation from your source file comments, and so on. (Refer to
    [http://gruntjs.com/](http://gruntjs.com/).)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grunt**是一个流行的任务运行工具，可以自动化您可能需要执行的重复任务，例如运行单元测试、捆绑组件、缩小捆绑包、从源文件注释创建API文档等。（参考[http://gruntjs.com/](http://gruntjs.com/)。）'
- en: Grunt uses the concept of plugins, which are specific task configurations that
    can be shared and reused. For example, it is likely that you will want a plugin
    that watches a directory for changes, then runs Browserify when a change is triggered.
    (In other words, every time you save a file, a task will be run.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt使用插件的概念，这些插件是特定的任务配置，可以共享和重复使用。例如，您可能希望有一个插件来监视目录的更改，然后在触发更改时运行Browserify。（换句话说，每次保存文件时，都会运行一个任务。）
- en: You can write your own plugins by hand; although this is a straightforward process,
    it is verbose enough, so we will not get into it in this book. Thankfully, Grunt
    has a vast plugin listing with a plugin for just about everything that you will
    ever need, or at least everything that we will need for the purpose of this book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动编写自己的插件；尽管这是一个简单的过程，但它足够冗长，所以我们不会在本书中详细介绍。幸运的是，Grunt有一个庞大的插件列表，几乎包含了您所需的所有插件，或者至少是我们在本书中需要的所有插件。
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: No surprise here! We install Grunt through npm. Next, we need to install Grunt
    plugins using npm and `package.json`; the only thing is that we list them under
    `devDependencies` and not dependencies.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪！我们通过npm安装Grunt。接下来，我们需要使用npm和`package.json`安装Grunt插件；唯一的区别是我们将它们列在`devDependencies`下，而不是dependencies下。
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we create a `Gruntfile.js` to configure our tasks. This file specifies
    *targets* and defines the behavior of each target. Most of the time, you will
    simply look at sample configuration files for whatever plugin you use and then
    tweak it to fit your needs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`Gruntfile.js`来配置我们的任务。这个文件指定了*目标*，并定义了每个目标的行为。大多数情况下，您只需查看您使用的插件的示例配置文件，然后调整它以满足您的需求。
- en: 'In the specific case of using watch and Browserify, we need to simply tell
    the watch plugin to run the Browserify task when a change is observed, and in
    the Browserify task, we need to specify the most basic settings: an entry point
    file and an output bundle file.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用watch和Browserify的特定情况下，我们只需要告诉watch插件在观察到变化时运行Browserify任务，并且在Browserify任务中，我们需要指定最基本的设置：一个入口文件和一个输出捆绑文件。
- en: 'The four parts that make up the `Gruntfile` are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 构成`Gruntfile`的四个部分如下：
- en: A boilerplate wrapper function
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个样板包装函数
- en: The configuration for each task
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个任务的配置
- en: Manual loading of each plugin that is used by the task
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动加载每个任务使用的插件
- en: Registration of each task so that Grunt can execute them
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个任务的注册，以便Grunt可以执行它们
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inside `grunt.initConfig`, you configure each task, with the attribute name
    matching the name of the task. You then load each plugin calling the `loadNpmTasks`
    function and loading the corresponding dependency. Finally, you specify default
    tasks as well as any custom tasks and map them to their dependencies. Using the
    name used in the task registration will run that particular task.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`grunt.initConfig`内，您配置每个任务，属性名称与任务名称匹配。然后，您调用`loadNpmTasks`函数加载每个插件并加载相应的依赖项。最后，您指定默认任务以及任何自定义任务，并将它们映射到它们的依赖项。使用任务注册中使用的名称将运行特定的任务。
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding command will run the browserify task, which has been configured
    and loaded as shown previously. If you run the grunt command with no task specified
    will run the `default` task, which, in this case, will run the watch task.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将运行browserify任务，该任务已经配置和加载如前所示。如果您运行grunt命令而没有指定任务，将运行`default`任务，这种情况下将运行watch任务。
- en: Gulp
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gulp
- en: '**Gulp** is a popular alternative to Grunt, which claims to improve on Grunt
    by offering simpler configuration. (Refer to [http://gulpjs.com/](http://gulpjs.com/).)
    Whichever tool you use is up to you. Much like the kind of car you drive or the
    fast food restaurant you visit, using Gulp or Grunt is all about taste and personal
    preference.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gulp**是Grunt的一个流行的替代品，它声称通过提供更简单的配置来改进Grunt。（参考[http://gulpjs.com/](http://gulpjs.com/)。）你使用哪种工具取决于你。就像你开什么样的车或者去哪家快餐店一样，使用Gulp或Grunt完全取决于口味和个人偏好。'
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Gulp uses `gulpfile.js` as its configuration file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp使用`gulpfile.js`作为其配置文件。
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding configuration should look much more straightforward as compared
    to Grunt. If looking at it you guess that a task named minify is registered, taking
    a source file called `app.js` that is first uglified, then saved to a build directory,
    you guessed right.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与Grunt相比，前面的配置看起来更加简单。如果你看到一个名为minify的任务被注册，它会取一个名为`app.js`的源文件，首先进行uglify，然后保存到一个构建目录，那么你猜对了。
- en: 'To run the task, you can specify a default task or explicitly run the previously
    mentioned one with the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行任务，您可以指定一个默认任务，或者使用以下命令显式运行先前提到的任务：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of ground, explaining the opportunity we have
    with Node.js bringing JavaScript to the server. We saw ways to build manageable
    modules in JavaScript, share and reuse these modules on both ends of the stack,
    and use management and workflow tools, such as npm, Bower, Grunt, and Gulp, to
    automate the development process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，解释了Node.js为我们带来的机会，将JavaScript带到服务器上。我们看到了在JavaScript中构建可管理的模块的方法，在堆栈的两端共享和重用这些模块，并使用npm、Bower、Grunt和Gulp等管理和工作流工具来自动化开发过程。
- en: Now, we are ready to take full advantage of the Node.js ecosystem along with
    the powerful supporting workflow tools that are available. From here, we will
    get back to writing games by building a fun multiplayer snake game. We will discuss
    concepts that will allow us to match players together in the same game world,
    which is a fundamental part of bringing players into your game.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备充分利用Node.js生态系统以及可用的强大的支持工作流工具。从这里开始，我们将回到编写游戏，通过构建一个有趣的多人蛇游戏。我们将讨论一些概念，这些概念将允许我们将玩家匹配到同一个游戏世界中，这是将玩家带入游戏的基本部分。
