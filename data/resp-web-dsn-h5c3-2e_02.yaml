- en: Chapter 2. Media Queries – Supporting Differing Viewports
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 媒体查询-支持不同的视口
- en: 'In the previous chapter, we had a brief look at the essential components for
    a responsive web page: a fluid layout, fluid images, and media queries.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了响应式网页的基本组件：流体布局、流体图像和媒体查询。
- en: This chapter will look in detail at media queries, hopefully providing all that's
    needed to fully understand their capability, syntax, and future development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍媒体查询，希望能够提供充分理解它们的能力、语法和未来发展所需的一切。
- en: 'In this chapter, we shall:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn why media queries are needed for a responsive web design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解为什么响应式网页设计需要媒体查询
- en: Understand the media query syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解媒体查询语法
- en: Learn how to use media queries in `link` tags, with CSS `@import` statements
    and within CSS files themselves
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在`link`标签中使用媒体查询，以及在CSS文件中使用CSS `@import`语句和媒体查询本身
- en: Understand what device features we can test for
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解我们可以测试的设备功能
- en: Use media queries to facilitate visual changes dependent upon available screen
    space
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用媒体查询来促进视觉变化，取决于可用的屏幕空间
- en: Consider whether media queries should be grouped together or written as and
    where needed
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑媒体查询是否应该被分组在一起或根据需要编写
- en: Understand the `meta` viewport tag, to allow media queries to work as intended
    on iOS and Android devices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`meta`视口标签，以便在iOS和Android设备上使媒体查询按预期工作
- en: Consider the capabilities being proposed for future media queries specifications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑未来媒体查询规范提出的功能
- en: The CSS3 specification is made up of a number of modules. Media Queries (Level
    3) are just one of these modules. Media queries allow us to target specific CSS
    styles depending upon the capabilities of a device. For example, with just a few
    lines of CSS we can change the way content is displayed, dependent upon things
    such as viewport width, screen aspect ratio, orientation (landscape or portrait),
    and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3规范由许多模块组成。媒体查询（Level 3）只是其中之一。媒体查询允许我们根据设备的功能来定位特定的CSS样式。例如，只需几行CSS，我们就可以根据视口宽度、屏幕宽高比、方向（横向或纵向）等来改变内容的显示方式。
- en: Media queries are widely implemented. Pretty much everything other than ancient
    versions of Internet Explorer (8 and below) support them. In short, there's absolutely
    no good reason not to be using them!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询被广泛实现。除了古老版本的Internet Explorer（8及以下）之外，几乎所有浏览器都支持它们。简而言之，没有任何理由不使用它们！
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Specifications at the W3C go through a ratification process. If you have a spare
    day, knock yourself out with the official explanation of the process at [http://www.w3.org/2005/10/Process-20051014/tr](http://www.w3.org/2005/10/Process-20051014/tr).
    The simpler version is that specifications go from **Working Draft** (**WD**),
    to **Candidate Recommendation** (**CR**), to **Proposed Recommendation** (**PR**)
    before finally arriving, many years later, at W3C Recommendation (REC). Modules
    at a greater maturity level than others are generally safer to use. For example,
    CSS Transforms Module Level 3 ([http://www.w3.org/TR/css3-3d-transforms/](http://www.w3.org/TR/css3-3d-transforms/))
    has been at WD status since March 2009 and browser support for it is far poorer
    than CR modules such as media queries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: W3C的规范经过一系列的批准过程。如果你有一天空闲，可以去看看它们在[http://www.w3.org/2005/10/Process-20051014/tr](http://www.w3.org/2005/10/Process-20051014/tr)上的官方解释。简化版本是，规范从**工作草案**（**WD**）到**候选推荐**（**CR**），再到**建议推荐**（**PR**），最后在许多年后到达W3C推荐（REC）。比其他模块更成熟的模块通常更安全使用。例如，CSS变换模块Level
    3（[http://www.w3.org/TR/css3-3d-transforms/](http://www.w3.org/TR/css3-3d-transforms/)）自2009年3月以来一直处于WD状态，而它的浏览器支持要比CR模块如媒体查询差得多。
- en: Why media queries are needed for a responsive web design
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么响应式网页设计需要媒体查询
- en: 'CSS3 media queries enable us to target particular CSS styles to particular
    device capabilities or situations. If you head over to the W3C specification of
    the CSS3 media query module ([http://www.w3.org/TR/css3-mediaqueries/](http://www.w3.org/TR/css3-mediaqueries/)),
    you''ll see that this is their official introduction to what media queries are
    all about:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3媒体查询使我们能够将特定的CSS样式定位到特定的设备功能或情况上。如果你前往W3C的CSS3媒体查询模块规范（[http://www.w3.org/TR/css3-mediaqueries/](http://www.w3.org/TR/css3-mediaqueries/)），你会看到这是他们对媒体查询的官方介绍：
- en: '*"A media query consists of a media type and zero or more expressions that
    check for the conditions of particular media features. Among the media features
    that can be used in media queries are ''width'', ''height'', and ''color''. By
    using media queries, presentations can be tailored to a specific range of output
    devices without changing the content itself."*'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “媒体查询由媒体类型和零个或多个表达式组成，用于检查特定媒体特征的条件。可以在媒体查询中使用的媒体特征包括'宽度'、'高度'和'颜色'。通过使用媒体查询，演示可以根据特定范围的输出设备进行定制，而不改变内容本身。”
- en: Without media queries we would be unable to substantially alter the visuals
    of a website using CSS alone. They facilitate us writing defensive CSS rules that
    pre-empt such eventualities as portrait screen orientation, small or large viewport
    dimensions, and more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 没有媒体查询，我们将无法仅使用CSS大幅改变网站的视觉效果。它们使我们能够编写防御性的CSS规则，以预防诸如纵向屏幕方向、小或大视口尺寸等情况。
- en: Whilst a fluid layout can carry a design a substantial distance, given the gamut
    of screen sizes we hope to cover, there are times when we need to revise the layout
    more fully. Media queries make this possible. Think of them as basic conditional
    logic for CSS.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管流体布局可以在很大程度上实现设计，但考虑到我们希望覆盖的屏幕尺寸范围，有时我们需要更全面地修改布局。媒体查询使这成为可能。把它们看作是CSS的基本条件逻辑。
- en: Basic conditional logic in CSS
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS中的基本条件逻辑
- en: True programming languages all have some facility in which one of two or more
    possible situations are catered for. This usually takes the form of conditional
    logic, typified by an `if/else` statement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的编程语言都有一些设施，可以处理两种或更多可能的情况。这通常采用条件逻辑的形式，以`if/else`语句为典型。
- en: If programming vernacular makes your eyes itch, fear not; it's a very simple
    concept. You probably dictate conditional logic every time you ask a friend to
    order for you when visiting a cafe, "If they've got triple chocolate muffins I'll
    have one of those, if not, I'll have a slice of carrot cake". It's a simple conditional
    statement with two possible (and equally fine, in this case) results.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编程术语让你的眼睛发痒，不要害怕；这是一个非常简单的概念。每当你去咖啡馆时让朋友帮你点餐时，你可能都在规定条件逻辑，“如果他们有三重巧克力松饼，我就要一个，如果没有，我就要一块胡萝卜蛋糕”。这是一个简单的条件语句，有两种可能的结果（在这种情况下同样好）。
- en: At the time of writing, CSS does not facilitate true conditional logic or programmatic
    features. Loops, functions, iteration, and complex math are still firmly in the
    domain of CSS processors (did I mention a fine book on the subject of the Sass
    pre-processor, called *Sass and Compass for Designers*?). However, media queries
    are one mechanism in CSS that allows us to author basic conditional logic. By
    using a media query the styles within are scoped depending upon whether certain
    conditions are met.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，CSS不支持真正的条件逻辑或编程特性。循环、函数、迭代和复杂的数学仍然完全属于CSS处理器的领域（我是否提到了一本关于Sass预处理器的精彩书籍，名为*Sass
    and Compass for Designers*？）。然而，媒体查询是CSS中允许我们编写基本条件逻辑的一种机制。通过使用媒体查询，其中的样式根据是否满足某些条件而作用域。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Programming features on their way**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程特性即将到来**'
- en: 'The popularity of CSS pre-processors has made the people working on CSS specifications
    take note. Right now there is a WD specification for CSS variables: [http://www.w3.org/TR/css-variables/](http://www.w3.org/TR/css-variables/)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CSS预处理器的流行使得负责CSS规范的人们开始注意到这一点。现在有一个CSS变量的WD规范：[http://www.w3.org/TR/css-variables/](http://www.w3.org/TR/css-variables/)
- en: However, browser support is currently limited to Firefox so it's really not
    something to consider using in the wild at present.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前浏览器支持仅限于Firefox，因此目前真的不值得考虑在实际中使用。
- en: Media query syntax
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体查询语法
- en: So what does a CSS media query look like and more importantly, how does it work?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CSS媒体查询是什么样的，更重要的是，它是如何工作的？
- en: 'Enter the following code at the bottom of any CSS file and preview the related
    web page. Alternatively, you can open `example_02-01`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何CSS文件的底部输入以下代码，并预览相关的网页。或者，你可以打开`example_02-01`：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, preview the file in a browser and resize the window. The background color
    of the page will vary depending upon the current viewport size. We'll cover how
    the syntax works in more detail shortly. First, it's important to know how and
    where you can use media queries.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中预览文件并调整窗口大小。页面的背景颜色将根据当前的视口大小而变化。我们将很快介绍语法的工作原理。首先，重要的是要知道如何以及在哪里可以使用媒体查询。
- en: Media queries in link tags
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接标签中的媒体查询
- en: 'Those that have been working with CSS since version 2 will know it''s possible
    to specify the type of device (for example, `screen` or `print`) applicable to
    a style sheet with the media attribute of the `<link>` tag. Consider this example
    (which you''d place in the `<head>` tags of your markup):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自CSS2以来一直在使用CSS的人会知道，可以使用`<link>`标签的媒体属性来指定样式表适用的设备类型（例如，`screen`或`print`）。考虑以下示例（你会将其放在你的标记的`<head>`标签中）：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Media queries add the ability to target styles based upon the capability or
    features of a device, rather than merely the type of device. Think of it as a
    question to the browser. If the browser''s answer is "true", the enclosed styles
    are applied. If the answer is "false", they are not. Rather than just asking the
    browser "Are you a screen?"—as much as we could effectively ask with just CSS2—media
    queries ask a little more. Instead, a media query might ask, "Are you a screen
    and are you in portrait orientation?" Let''s look at that as an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询增加了根据设备的能力或特性来定位样式的能力，而不仅仅是设备类型。把它看作是对浏览器的一个问题。如果浏览器的答案是“true”，那么封闭的样式将被应用。如果答案是“false”，它们就不会。媒体查询不仅仅询问浏览器“你是屏幕吗？”——就像我们只能用CSS2来问的那样——媒体查询问得更多。相反，媒体查询可能会问，“你是屏幕，你是纵向的吗？”让我们以此为例：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, the media query expression asks the type (are you a screen?), and then
    the feature (is your screen in portrait orientation?). The `portrait-screen.css`
    style sheet will be applied for any screen device with a portrait screen orientation
    and ignored for any others. It''s possible to reverse the logic of any media query
    expression by adding not to the beginning of the media query. For example, the
    following code would negate the result in our prior example, applying the file
    for anything that wasn''t a screen with a portrait orientation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，媒体查询表达式询问类型（你是屏幕吗？），然后是特性（你的屏幕是纵向的吗？）。`portrait-screen.css`样式表将应用于任何具有纵向屏幕方向的屏幕设备，并对其他设备忽略。通过在媒体查询的开头添加not，可以颠倒任何媒体查询表达式的逻辑。例如，以下代码将否定我们之前例子中的结果，将文件应用于任何不是纵向屏幕的屏幕：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Combining media queries
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合媒体查询
- en: It's also possible to string multiple expressions together. For example, let's
    extend one of our prior examples and also limit the file to devices that have
    a viewport greater than 800 pixels.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将多个表达式串联在一起。例如，让我们扩展我们之前的一个例子，并将文件限制为视口大于800像素的设备。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Further still, we could have a list of media queries. If any of the listed
    queries are true, the file will be applied. If none are true, it won''t. Here
    is an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以有一个媒体查询列表。如果列出的任何查询为true，则将应用该文件。如果没有一个为true，则不会应用。以下是一个例子：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are two points to note here. Firstly, a comma separates each media query.
    Secondly, you'll notice that after projection, there is no trailing and/or feature/value
    combination in parentheses. That's because in the absence of these values, the
    media query is applied to all media types. In our example, the styles will apply
    to all projectors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点需要注意。首先，逗号分隔每个媒体查询。其次，在投影后，你会注意到括号中没有尾随的特性/值组合。这是因为在没有这些值的情况下，媒体查询将应用于所有媒体类型。在我们的例子中，样式将应用于所有投影仪。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You should be aware that you can use any CSS length unit to specify media queries
    with. **Pixels** (**px**) are the most commonly used but **ems** (**em**) and
    **rems** (**rem**) are equally appropriate. For some further info on the merits
    of each, I wrote a little more on the subject here: [http://benfrain.com/just-use-pixels](http://benfrain.com/just-use-pixels)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，可以使用任何CSS长度单位来指定媒体查询。**像素**（**px**）是最常用的，但**ems**（**em**）和**rems**（**rem**）同样适用。关于每种单位的优点，我在这里写了更多内容：[http://benfrain.com/just-use-pixels](http://benfrain.com/just-use-pixels)
- en: Therefore, if you want a break point at 800px (but specified in em units) simply
    divide the number of pixels by 16\. For example, 800px could also be specified
    as 50em (800 / 16 = 50).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想在800px（但以em单位指定）处设置断点，只需将像素数除以16。例如，800px也可以指定为50em（800 / 16 = 50）。
- en: Media queries with @import
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@import的媒体查询
- en: 'We can also use the `@import` feature of CSS to conditionally load style sheets
    into our existing style sheet. For example, the following code would import the
    style sheet called `phone.css`, providing the device was screen based and had
    a maximum viewport of 360 pixels:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用CSS的`@import`功能将样式表有条件地加载到现有样式表中。例如，以下代码将导入名为`phone.css`的样式表，前提是设备基于屏幕，并且视口最大为360像素：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember that using the `@import` feature of CSS, adds to HTTP requests (which
    impacts load speed) so use this method sparingly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用CSS的`@import`功能会增加HTTP请求（影响加载速度），因此请谨慎使用此方法。
- en: Media queries in CSS
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS中的媒体查询
- en: 'So far, we have included them as links to CSS files that we would place within
    the `<head></head>` section of our HTML and as `@import` statements. However,
    it''s more likely we will want to use media queries within CSS style sheets themselves.
    For example, if we add the following code into a style sheet, it will make all
    `h1` elements green, providing the device has a screen width of 400 pixels or
    less:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将它们作为链接到我们将放置在HTML的`<head></head>`部分中的CSS文件，并作为`@import`语句。但是，更有可能的是，我们将希望在CSS样式表中使用媒体查询。例如，如果我们将以下代码添加到样式表中，它将使所有`h1`元素变为绿色，前提是设备的屏幕宽度为400像素或更小：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First we specify we want a media query with the `@media` at-rule, then we specify
    the type we want to match. In the preceding example, we want to apply the rules
    enclosed only to screens (and not, for example, `print`). Then, inside parenthesis
    we enter the specifics of the query. Then like any CSS rule, we open the braces
    and write the required styles.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定要使用`@media`规则的媒体查询，然后指定要匹配的类型。在前面的示例中，我们只想将封闭的规则应用于屏幕（例如不适用于`print`）。然后，在括号内输入查询的具体内容。然后像任何CSS规则一样，我们打开大括号并编写所需的样式。
- en: 'At this point it''s probably prudent of me to point out that in most situations,
    you don''t actually need to specify `screen`. Here''s the key point in the specification:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我可能需要指出的是，在大多数情况下，实际上不需要指定`screen`。这是规范中的关键点：
- en: '*"A shorthand syntax is offered for media queries that apply to all media types;
    the keyword ''all'' can be left out (along with the trailing ''and''). I.e. if
    the media type is not explicitly given it is ''all''."*'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“媒体查询提供了适用于所有媒体类型的简写语法；关键字''all''可以省略（以及末尾的''and''）。也就是说，如果媒体类型没有明确给出，它就是''all''。”*'
- en: Therefore, unless you want to target styles to particular media types, just
    leave the `screen and` part out. That's the way we will be writing media queries
    in the example files from this point on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非你想要针对特定媒体类型的样式，否则可以省略`screen and`部分。这是我们从现在开始在示例文件中编写媒体查询的方式。
- en: What can media queries test for?
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体查询可以测试什么？
- en: 'When building responsive designs, the media queries that get used most, usually
    relate to a device''s viewport width (`width`). In my own experience, I have found
    little need (with the occasional exception of resolution and viewport height)
    to employ the other capabilities. However, just in case the need arises, here
    is a list of all capabilities that Media Queries Level 3 can test for. Hopefully
    some will pique your interest:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建响应式设计时，最常使用的媒体查询通常与设备的视口宽度（`width`）有关。根据我的经验，我发现除了分辨率和视口高度偶尔需要使用外，几乎没有必要使用其他功能。但是，以防万一需要，这里是媒体查询级别3可以测试的所有功能列表。希望其中一些能引起你的兴趣：
- en: '`width`: The viewport width.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：视口宽度。'
- en: '`height`: The viewport height.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`：视口高度。'
- en: '`device-width`: The rendering surface''s width (for our purposes, this is typically
    the screen width of a device).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device-width`：渲染表面的宽度（对于我们的目的，这通常是设备的屏幕宽度）。'
- en: '`device-height`: The rendering surface''s height (for our purposes, this is
    typically the screen height of a device).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device-height`：渲染表面的高度（对于我们的目的，这通常是设备的屏幕高度）。'
- en: '`orientation`: This capability checks whether a device is portrait or landscape
    in orientation.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orientation`：此功能检查设备是纵向还是横向。'
- en: '`aspect-ratio`: The ratio of width to height based upon the viewport width
    and height. A 16:9 widescreen display can be written as `aspect-ratio: 16/9`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aspect-ratio`：基于视口宽度和高度的宽高比。16:9的宽屏显示可以写为`aspect-ratio: 16/9`。'
- en: '`device-aspect-ratio`: This capability is similar to `aspect-ratio` but is
    based upon the width and height of the device rendering surface, rather than viewport.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device-aspect-ratio`：此功能类似于`aspect-ratio`，但是基于设备渲染表面的宽度和高度，而不是视口。'
- en: '`color`: The number of bits per color component. For example, `min-color: 16`
    will check that the device has 16-bit color.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：每个颜色分量的位数。例如，`min-color: 16`将检查设备是否具有16位颜色。'
- en: '`color-index`: The number of entries in the color lookup table of the device.
    Values must be numbers and cannot be negative.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color-index`：设备颜色查找表中的条目数。值必须是数字，不能为负数。'
- en: '`monochrome`: This capability tests how many bits per pixel are in a monochrome
    frame buffer. The value would be a number (integer), for example, `monochrome:
    2`, and cannot be negative.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monochrome`：此功能测试单色帧缓冲区中每像素的位数。值将是一个数字（整数），例如，`monochrome: 2`，不能为负数。'
- en: '`resolution`: This capability can be used to test screen or print resolution;
    for example, `min-resolution: 300dpi`. It can also accept measurements in dots
    per centimeter; for example, `min-resolution: 118dpcm`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolution`：此功能可用于测试屏幕或打印分辨率；例如，`min-resolution: 300dpi`。它还可以接受每厘米的点数；例如，`min-resolution:
    118dpcm`。'
- en: '`scan`: This can be either progressive or interlace features largely particular
    to TVs. For example, a 720p HD TV (the p part of 720p indicates "progressive")
    could be targeted with `scan: progressive` while a 1080i HD TV (the i part of
    1080i indicates "interlaced") could be targeted with `scan: interlace`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan`：这可以是渐进式或隔行扫描功能，主要适用于电视。例如，720p高清电视（720p中的p表示“渐进式”）可以使用`scan: progressive`进行定位，而1080i高清电视（1080i中的i表示“隔行扫描”）可以使用`scan:
    interlace`进行定位。'
- en: '`grid`: This capability indicates whether or not the device is grid or bitmap
    based.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid`：此功能指示设备是基于网格还是位图。'
- en: 'All the preceding features, with the exception of `scan` and `grid`, can be
    prefixed with `min` or `max` to create ranges. For example, consider the following
    code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述功能，除了`scan`和`grid`，都可以用`min`或`max`进行前缀处理以创建范围。例如，考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, a minimum (`min`) and maximum (`max`) have been applied to width to set
    a range. The tiny.css file will only be imported for screen devices with a minimum
    viewport width of 200 pixels and a maximum viewport width of 360 pixels.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，宽度应用了最小（`min`）和最大（`max`）来设置一个范围。tiny.css文件只会被导入到视口宽度最小为200像素，最大为360像素的屏幕设备中。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Features deprecated in CSS Media Queries Level 4**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSS媒体查询级别4中弃用的功能**'
- en: It's worth being aware that the draft specification for Media Queries Level
    4 deprecates the use of a few features ([http://dev.w3.org/csswg/mediaqueries-4/#mf-deprecated](http://dev.w3.org/csswg/mediaqueries-4/#mf-deprecated));
    most notably `device-height`, `device-width`, and `device-aspect-ratio`. Support
    for those queries will remain in browsers but it's recommended you refrain from
    writing any new style sheets that use them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，媒体查询级别4的草案规范弃用了一些功能（[http://dev.w3.org/csswg/mediaqueries-4/#mf-deprecated](http://dev.w3.org/csswg/mediaqueries-4/#mf-deprecated)）；其中最明显的是`device-height`、`device-width`和`device-aspect-ratio`。浏览器将继续支持这些查询，但建议您不要编写使用它们的新样式表。
- en: Using media queries to alter a design
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用媒体查询来改变设计
- en: By their very nature, styles further down a **cascading style sheet** (**CSS**
    file to you and me) override equivalent styles higher up (unless styles higher
    up are more specific). We can therefore set base styles at the beginning of a
    style sheet, applicable to all versions of our design (or at least providing our
    'base' experience), and then override relevant sections with media queries further
    on in the document. For example, we might choose to set navigation links as text
    alone in limited viewports (or perhaps just smaller text) and then overwrite those
    styles with a media query to give us both text and icons at larger viewports where
    more space is available.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的本质，样式表中更下面的样式（对我们来说是CSS文件）会覆盖更上面的等效样式（除非更上面的样式更具体）。因此，我们可以在样式表的开头设置基本样式，适用于我们设计的所有版本（或者至少提供我们的“基本”体验），然后在文档中进一步使用媒体查询来覆盖相关部分。例如，我们可能选择在有限的视口中将导航链接设置为纯文本（或者只是较小的文本），然后使用媒体查询来在更大的视口中覆盖这些样式，以便在更大的空间可用时为我们提供文本和图标。
- en: 'Let''s have a look at how this might look in practice (`example_02-02`). First
    the markup:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实践中是什么样子（`example_02-02`）。首先是标记：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now the CSS:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在CSS：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'Here''s a screen grab of the links in a small viewport:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小视口中链接的屏幕截图：
- en: '![Using media queries to alter a design](img/B03777_02_01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![使用媒体查询来改变设计](img/B03777_02_01.jpg)'
- en: 'And here''s a grab of them at a larger viewport:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它在较大的视口中的截图：
- en: '![Using media queries to alter a design](img/B03777_02_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用媒体查询来改变设计](img/B03777_02_02.jpg)'
- en: Any CSS can be wrapped in a media query
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何CSS都可以包含在媒体查询中
- en: It's important to remember that anything you would normally write in CSS can
    also be enclosed inside a media query. As such, it's possible to entirely change
    the layout and look of a site in different situations (usually for differing viewport
    sizes) with media queries.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，您通常在CSS中编写的任何内容也可以包含在媒体查询中。因此，可以使用媒体查询在不同情况下（通常是不同的视口大小）完全改变站点的布局和外观。
- en: Media queries for HiDPI devices
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HiDPI设备的媒体查询
- en: 'Another common use case for media queries is to change styles when the site
    is viewed on a high-resolution device. Consider this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询的另一个常见用例是在高分辨率设备上查看站点时更改样式。考虑这个：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here our media query is specifying that we only want the enclosed styles to
    apply where the screen resolution is 2 dots per pixel unit (2dppx). This would
    apply to devices like the iPhone 4 (Apple's HiDPI devices are given the 'Retina'
    moniker) and a whole raft of Android devices. You could change that media query
    to apply to a wider range of devices by reducing the dppx value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的媒体查询指定，我们只希望封闭的样式应用于屏幕分辨率为2像素每像素单位（2dppx）的情况。这将适用于iPhone 4等设备（苹果的HiDPI设备被称为“Retina”）以及大量的Android设备。您可以通过减少dppx值来将该媒体查询应用于更广泛的设备范围。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the broadest possible support, when writing min-resolution media queries,
    ensure you have a prefixing tool running to provide relevant vendor prefixes.
    Don't worry if the term vendor prefixes doesn't make much sense right now as we
    deal with the subject in more detail in the next chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写最小分辨率媒体查询时，确保运行有一个添加前缀的工具，以提供相关的供应商前缀，以获得尽可能广泛的支持。如果现在对供应商前缀这个术语不太理解，也不用担心，因为我们将在下一章更详细地讨论这个主题。
- en: Considerations for organizing and authoring media queries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织和编写媒体查询的考虑
- en: We will take a brief tangent at this point to consider some of the different
    approaches that authors can take when writing and organizing their media queries.
    Each approach offers some benefits and some tradeoffs so it's worth at least knowing
    about these factors, even if you decide they are largely irrelevant for your needs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将进行一个简短的偏离，考虑作者在编写和组织他们的媒体查询时可以采取的一些不同方法。每种方法都有一些好处和一些权衡，因此至少了解这些因素是值得的，即使您认为它们对您的需求基本上无关紧要。
- en: Linking to different CSS files with media queries
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接到不同的CSS文件，带有媒体查询
- en: From a browser perspective, CSS is considered to be a 'render blocking' asset.
    The browser needs to fetch and parse a linked CSS file before rendering of the
    page can complete.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从浏览器的角度来看，CSS被认为是“渲染阻塞”的资源。浏览器需要在渲染页面之前获取和解析链接的CSS文件。
- en: However, modern browsers are smart enough to discern which style sheets (linked
    with media queries in the head) need to be analyzed immediately and which can
    be deferred until after the initial page rendering.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现代浏览器足够聪明，可以区分哪些样式表（在头部链接的带有媒体查询的样式表）需要立即分析，哪些可以推迟到初始页面渲染之后再进行。
- en: For these browsers, CSS files linked to with non-applicable media queries (for
    example if the screen is too small for the media query to apply) can be 'deferred'
    until after the initial page load, providing some performance advantage.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些浏览器，链接到不适用媒体查询的CSS文件（例如，如果屏幕太小，媒体查询不适用）可以在初始页面加载后“推迟”，从而提供一些性能优势。
- en: 'There''s more on this topic over on Google''s developer pages: [https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题，Google的开发者页面上有更多内容：[https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css)
- en: 'However, I would like to draw your attention to this part in particular:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我想特别提醒您注意这一部分：
- en: '*"...note that "render blocking" only refers to whether the browser will have
    to hold the initial rendering of the page on that resource. In either case, the
    CSS asset is still downloaded by the browser, albeit with a lower priority for
    non-blocking resources."*'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “...请注意，“渲染阻塞”只是指浏览器是否必须在该资源上保持页面的初始渲染。无论哪种情况，浏览器都会下载CSS资源，尽管对于非阻塞资源，它的优先级较低。”
- en: To reiterate, all the linked files will still be downloaded, the browser just
    won't hold up rendering of the page if they don't immediately apply.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有链接的文件仍然会被下载，只是如果它们不立即应用，浏览器不会延迟页面的渲染。
- en: Therefore, a modern browser loading a responsive web page (take a look at `example_02-03`)
    with four different style sheets linked with different media queries (to apply
    different styles for different viewport ranges) will download all four CSS files
    but probably only parse the applicable one initially before rendering the page.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代浏览器加载一个响应式网页（查看`example_02-03`）时，会下载链接了不同媒体查询的四个不同样式表（以适应不同的视口范围），但可能只会在渲染页面之前解析适用的样式表。
- en: The practicalities of separating media queries
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离媒体查询的实际性
- en: Although we have just learned that the process of splitting media queries potentially
    offers some benefit, there is not always a large tangible advantage (apart from
    personal preference and/or compartmentalization of code) in separating different
    media query styles into separate files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚了解到分割媒体查询的过程可能会带来一些好处，但将不同的媒体查询样式分开到不同的文件中并不总是有很大的实际优势（除了个人偏好和/或代码的分隔）。
- en: After all, using separate files increases the number of HTTP requests needed
    to render a page, which in turn can make the pages slower in certain other situations.
    Nothing is ever easy on the Web! It's therefore really a question of evaluating
    the entire performance of your site and testing each scenario on different devices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，使用单独的文件会增加呈现页面所需的HTTP请求的数量，这反过来可能会使页面在某些其他情况下变慢。在网络上没有什么是容易的！因此，这实际上是一个问题，评估您的网站的整体性能，并在不同设备上测试每种情况。
- en: 'My default stance on this is that, unless the project has considerable time
    available for performance optimizations, this is one of the last places I would
    look to make performance gains. Only once I am certain that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我对此的默认立场是，除非项目有足够的时间进行性能优化，否则这是我寻求性能提升的最后一个地方。只有当我确定：
- en: All images are compressed
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有图像都已经压缩
- en: All scripts are concatenated and minified
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有脚本都被连接并进行了最小化
- en: All assets are being served gzipped
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有资产都以gzip方式提供
- en: All static content is being cached via CDNs
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有静态内容都通过CDN进行缓存
- en: All surplus CSS rules have been removed
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有多余的CSS规则已被删除
- en: Perhaps then I would start looking to split up media queries into separate files
    for performance gains.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 也许那时我会开始考虑将媒体查询拆分成单独的文件以获得性能提升。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'gzip is a compression and decompression file format. Any good server should
    allow gzip for files such as CSS and this greatly decreases the size of the file
    as it travels from server to device (at which point it is decompressed to its
    native format). You can find a good summary of gzip on Wikipedia: [http://en.wikipedia.org/wiki/Gzip](http://en.wikipedia.org/wiki/Gzip)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: gzip是一种压缩和解压缩文件格式。任何好的服务器都应该允许对CSS等文件进行gzip压缩，这将大大减小文件在从服务器到设备的传输过程中的大小（在这一点上，它被解压缩为其原生格式）。您可以在维基百科上找到gzip的一个很好的摘要：[http://en.wikipedia.org/wiki/Gzip](http://en.wikipedia.org/wiki/Gzip)
- en: Nesting media queries 'inline'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套媒体查询“内联”
- en: In all but extreme circumstances, I recommend adding media queries within an
    existing style sheet alongside the 'normal' rules.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了极端情况外，我建议在现有样式表中添加媒体查询，与“正常”的规则一起。
- en: 'If you are happy to do the same, it leads to one further consideration: should
    media queries be declared underneath the associated selector? Or split off into
    a separate block of code at the end for all identical media queries? I''m glad
    you asked.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意这样做，还有一个考虑因素：媒体查询应该在相关选择器下声明吗？还是分离出一个单独的代码块，包含所有相同的媒体查询？我很高兴你问了。
- en: Combine media queries or write them where it suits?
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并媒体查询还是根据需要编写媒体查询？
- en: 'I''m a fan of writing media queries underneath the original ''normal'' definition.
    For example, let''s say I want to change the width of a couple of elements, at
    different places in the style sheet, depending upon the viewport width I would
    do this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在原始的“正常”定义下编写媒体查询。例如，假设我想要根据视口宽度在样式表的不同位置更改一些元素的宽度，我会这样做：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This seems like lunacy at first. We have two media queries that both relate
    to when the screen has a minimum width of 30rem. Surely repeating the same `@media`
    declaration is overly verbose and wasteful? Shouldn''t I be advocating grouping
    all the identical media queries into a single block like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这乍一看似乎是疯狂的。我们有两个媒体查询都与屏幕最小宽度为30rem有关。重复相同的`@media`声明肯定是冗长和浪费的吧？我应该主张将所有相同的媒体查询分组到一个单独的代码块中，就像这样：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is certainly one way to do it. However, from a maintenance point of view
    I find this more difficult. There is no 'right' way to do this but my preference
    is to define a rule for an individual selector once and have any variations of
    that rule (such as changes within media queries) defined immediately after. That
    way I don't have to search for separate blocks of code to find the declaration
    that is relevant to a particular selector.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一种方法。然而，从维护的角度来看，我觉得这更加困难。没有“正确”的方法，但我更喜欢为单个选择器定义一条规则，并在其后立即定义该规则的任何变体（例如在媒体查询中的更改）。这样我就不必搜索单独的代码块，找到与特定选择器相关的声明。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With CSS pre and post processors, this can be even more convenient as the media
    query 'variant' of a rule can be nested directly within the rule set. There's
    a whole section on that in my other book *Sass and Compass for Designers*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CSS预处理器和后处理器，这甚至可以更加方便，因为媒体查询的“变体”可以直接嵌套在规则集中。我的另一本书*Sass and Compass for
    Designers*中有一个完整的章节介绍这个。
- en: 'It would seem fair to argue against the former technique on the grounds of
    verbosity. Surely file size alone should be enough reason not to write media queries
    in this manner? After all, no one wants a big bloated CSS file to serve their
    users. However, the simple fact is that gzip compression (which should be compressing
    all the possible assets on your server) reduces the difference to a completely
    inconsequential amount. I''ve done various tests on this in the past so if it''s
    something you would like to read more about, head over to: [http://benfrain.com/inline-or-combined-media-queries-in-sass-fight/](http://benfrain.com/inline-or-combined-media-queries-in-sass-fight/).
    The bottom line is, I don''t believe you should concern yourself with file size
    if you would rather write media queries directly after the standard styles.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从冗长的角度来看，对前一种技术提出异议似乎是公平的。单单文件大小就足以成为不以这种方式编写媒体查询的理由了吧？毕竟，没有人希望为用户提供一个臃肿的CSS文件。然而，简单的事实是，gzip压缩（应该压缩服务器上的所有可能的资源）将这种差异减少到完全可以忽略的程度。我过去做过各种测试，所以如果您想了解更多信息，请访问：[http://benfrain.com/inline-or-combined-media-queries-in-sass-fight/](http://benfrain.com/inline-or-combined-media-queries-in-sass-fight/)。最重要的是，如果您宁愿直接在标准样式之后编写媒体查询，我认为您不应该担心文件大小。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to author your media queries directly after the original rule but
    have all identical media queries definitions merged into one, there are a number
    of build tools (at the time of writing, Grunt and Gulp both have relevant plugins)
    that facilitate this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想直接在原始规则之后编写媒体查询，但希望所有相同的媒体查询定义合并为一个，那么有许多构建工具（在撰写本文时，Grunt和Gulp都有相关插件）可以实现这一点。
- en: The viewport meta tag
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: viewport meta标签
- en: To get the most out of media queries, you will want smaller screen devices to
    display web pages at their native size (and not render them in a 980px window
    that you then have to zoom in and out of).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用媒体查询，您希望较小的屏幕设备以其原生尺寸显示网页（而不是在980px窗口中渲染，然后您必须放大和缩小）。
- en: When Apple released the iPhone in 2007, they introduced a proprietary `meta`
    tag called the viewport `meta` tag which Android and a growing number of other
    platforms now also support. The purpose of the viewport `meta` tag is to provide
    a way for web pages to communicate to mobile browsers how they would like the
    web browser to render the page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 2007年苹果发布iPhone时，他们引入了一个名为viewport `meta`的专有`meta`标签，Android和越来越多的其他平台现在也支持这个标签。viewport
    `meta`标签的目的是为了让网页与移动浏览器通信，告诉它们希望如何渲染页面。
- en: For the foreseeable future, any web page you want to be responsive, and render
    well across small screen devices, will need to make use of this `meta` tag.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在可预见的未来，任何您希望响应式的网页，并在小屏设备上良好呈现的网页，都需要使用这个`meta`标签。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Testing responsive designs on emulators and simulators**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**在模拟器和仿真器上测试响应式设计**'
- en: Although there is no substitute for testing your development work on real devices,
    there are emulators for Android and a simulator for iOS.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在真实设备上测试开发工作是无法替代的，但Android有模拟器，iOS有仿真器。
- en: For the pedantic, a simulator merely simulates the relevant device whereas an
    emulator actually attempts to interpret the original device code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一丝不苟的人来说，模拟器只是模拟相关设备，而仿真器实际上试图解释原始设备代码。
- en: The Android emulator for Windows, Linux, and Mac is available for free by downloading
    and installing the Android **Software Development Kit** (**SDK**) at [http://developer.android.com/sdk/](http://developer.android.com/sdk/).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Windows、Linux和Mac的Android模拟器可通过下载和安装Android**软件开发工具包**（**SDK**）免费获取，网址为[http://developer.android.com/sdk/](http://developer.android.com/sdk/)。
- en: The iOS simulator is only available to Mac OS X users and comes as part of the
    Xcode package (free from the Mac App Store).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: iOS模拟器仅适用于Mac OS X用户，并作为Xcode软件包的一部分（可从Mac App Store免费获取）。
- en: Browsers themselves are also including ever improving tools for emulating mobile
    devices in their development tools. Both Firefox and Chrome currently have specific
    settings to emulate different mobile devices/viewports.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器本身也在其开发工具中包含了不断改进的模拟移动设备的工具。Firefox和Chrome目前都有特定的设置来模拟不同的移动设备/视口。
- en: 'The viewport `<meta>` tag is added within the `<head>` tags of the HTML. It
    can be set to a specific width (which we could specify in pixels, for example)
    or as a scale, for example `2.0` (twice the actual size). Here''s an example of
    the viewport `meta` tag set to show the browser at twice (200 percent) the actual
    size:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: viewport `<meta>`标签添加在HTML的`<head>`标签中。它可以设置为特定宽度（例如，我们可以指定为像素）或作为比例，例如`2.0`（实际大小的两倍）。以下是viewport
    `meta`标签的示例，设置为显示浏览器为实际大小的两倍（200％）：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's break down the preceding `<meta>` tag so we can understand what's going
    on. The `name="viewport"` attribute is obvious enough. The `content="initial-scale=2.0`
    section is then saying, "scale the content to twice the size" (where 0.5 would
    be half the size, 3.0 would be three times the size, and so on) while the `width=device-width`
    part tells the browser that the width of the page should be equal to device-width.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的`<meta>`标签，以便我们了解发生了什么。`name="viewport"`属性是显而易见的。然后，`content="initial-scale=2.0`部分表示“将内容缩放到原始大小的两倍”（其中0.5表示原始大小的一半，3.0表示原始大小的三倍，依此类推），而`width=device-width`部分告诉浏览器页面的宽度应等于设备宽度。
- en: 'The `<meta>` tag can also be used to control the amount a user can zoom in
    and out of the page. This example allows users to go as large as three times the
    device width and as small as half the device width:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`<meta>`标签还可以用于控制用户在页面上放大和缩小的程度。此示例允许用户放大到设备宽度的三倍，缩小到设备宽度的一半：'
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You could also disable users from zooming at all, although as zooming is an
    important accessibility tool, it''s rare that it would be appropriate in practice:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以完全禁用用户缩放，尽管缩放是一个重要的辅助工具，但在实践中很少会适用：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `user-scalable=no` being the relevant part.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`user-scalable=no` 是相关部分。'
- en: 'Right, we''ll change the scale to `1.0`, which means that the mobile browser
    will render the page at 100 percent of its viewport. Setting it to the device''s
    width means that our page should render at 100 percent of the width of all supported
    mobile browsers. For the majority of cases, this `<meta>` tag would be appropriate:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们将缩放比例更改为`1.0`，这意味着移动浏览器将以其视口的100％呈现页面。将其设置为设备的宽度意味着我们的页面应该在所有支持的移动浏览器的宽度的100％呈现。对于大多数情况，这个`<meta>`标签是合适的：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Noticing that the viewport `meta` element is seeing increasing use, the W3C
    is making attempts to bring the same capability into CSS. Head over to [http://dev.w3.org/csswg/css-device-adapt/](http://dev.w3.org/csswg/css-device-adapt/)
    and read all about the new `@viewport` declaration. The idea is that rather than
    writing a `<meta>` tag in the `<head>` section of your markup, you could write
    `@viewport { width: 320px; }` in the CSS instead. This would set the browser width
    to 320 pixels. However, browser support is scant, although to cover all bases
    and be as future proof as possible you could use a combination of `meta` tag and
    the `@viewport` declaration.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到viewport `meta`元素的使用越来越多，W3C正在努力将相同的功能引入CSS。前往[http://dev.w3.org/csswg/css-device-adapt/](http://dev.w3.org/csswg/css-device-adapt/)，了解有关新的`@viewport`声明的所有信息。这个想法是，您可以在CSS中写`@viewport
    { width: 320px; }`，而不是在标记的`<head>`部分中写`<meta>`标签。这将把浏览器宽度设置为320像素。然而，浏览器支持有限，尽管为了尽可能覆盖所有基础并尽可能具有未来的性能，您可以使用`meta`标签和`@viewport`声明的组合。'
- en: At this point, you should have a solid grasp of media queries and how they work.
    However, before we move on to a different topic entirely, I think it's nice to
    consider what may be possible in the near future with the next version of media
    queries. Let's take a sneak peak!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经对媒体查询及其工作原理有了扎实的掌握。然而，在我们完全转移到另一个话题之前，我认为考虑一下媒体查询的下一个版本可能会有什么可能性是很好的。让我们来偷偷看一眼！
- en: Media Queries Level 4
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体查询4级
- en: At the time of writing, while CSS Media Queries Level 4 enjoy a draft specification
    ([http://dev.w3.org/csswg/mediaqueries-4/](http://dev.w3.org/csswg/mediaqueries-4/)),
    the features in the draft don't enjoy many browser implementations. This means
    that while we will take a brief look at the highlights of this specification,
    it's highly volatile. Ensure you check browser support and double-check for syntax
    changes before using any of these features.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，虽然CSS媒体查询4级有一个草案规范（[http://dev.w3.org/csswg/mediaqueries-4/](http://dev.w3.org/csswg/mediaqueries-4/)），但草案中的功能并没有得到很多浏览器的实现。这意味着虽然我们将简要介绍此规范的亮点，但它非常不稳定。在使用这些功能之前，请确保检查浏览器支持并仔细检查语法更改。
- en: For now, while there are other features in the level 4 specification, we will
    concern ourselves only with scripting, pointer and hover, and luminosity.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，虽然4级规范中还有其他功能，但我们只关注脚本、指针和悬停以及亮度。
- en: Scripting media feature
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本媒体特性
- en: It's a common practice to set a class on the HTML tag to indicate that no JavaScript
    is present by default and then replace that class with a different class when
    JavaScript runs. This provides a simple ability to fork code (including CSS) based
    upon that new HTML class. Specifically, using this practice you can then write
    rules specific to users that have JavaScript enabled.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML标签上设置一个类来指示默认情况下没有JavaScript，然后在JavaScript运行时用不同的类替换该类是一种常见做法。这提供了一个简单的能力来根据新的HTML类分叉代码（包括CSS）。具体来说，使用这种做法，你可以编写特定于启用JavaScript的用户的规则。
- en: 'That''s potentially confusing so let''s consider some example code. By default,
    this would be the tag as authored in the HTML:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让人困惑，所以让我们考虑一些示例代码。默认情况下，这将是在HTML中编写的标签：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When JavaScript was run on the page, one of its first tasks would be to replace
    that `no-js` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript在页面上运行时，它的第一个任务之一将是替换`no-js`类：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once this is done, we can then write specific CSS rules that will only apply
    when JavaScript is present. For example, `.js .header { display: block; }`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '完成后，我们可以编写特定的CSS规则，这些规则只在JavaScript存在时才适用。例如，`.js .header { display: block;
    }`。'
- en: 'However, the scripting media feature of CSS Media Queries Level 4 aims to provide
    a more standardized manner to do this directly in the CSS:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CSS Media Queries Level 4的脚本媒体特性旨在提供一种更标准的方式直接在CSS中执行此操作：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And when JavaScript is present:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript存在时：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, it also aims to provide the ability to ascertain when JavaScript is
    present but only initially. One example given in the W3C specification is that
    of a printed page that could be laid out initially but does not have JavaScript
    available after that. In such an eventuality, you should be able to do this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它还旨在提供确定JavaScript是否存在但仅在最初时。W3C规范中给出的一个例子是，可以最初布置打印页面，但之后没有JavaScript可用。在这种情况下，你应该能够这样做：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The current Editor''s draft of this feature can be read here: [http://dev.w3.org/csswg/mediaqueries-4/#mf-scripting](http://dev.w3.org/csswg/mediaqueries-4/#mf-scripting)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的当前编辑草案可以在这里阅读：[http://dev.w3.org/csswg/mediaqueries-4/#mf-scripting](http://dev.w3.org/csswg/mediaqueries-4/#mf-scripting)
- en: Interaction media features
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互媒体特性
- en: 'Here is the W3C introduction to the pointer media feature:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是W3C对指针媒体特性的介绍：
- en: '*"The pointer media feature is used to query about the presence and accuracy
    of a pointing device such as a mouse. If a device has multiple input mechanisms,
    the pointer media feature must reflect the characteristics of the "primary" input
    mechanism, as determined by the user agent."*'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“指针媒体特性用于查询指针设备（如鼠标）的存在和准确性。如果设备有多个输入机制，则指针媒体特性必须反映“主要”输入机制的特性，由用户代理确定。”*'
- en: 'There are three possible states for the pointer features: `none`, `coarse`,
    and `fine`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 指针特性有三种可能的状态：`none`，`coarse`和`fine`。
- en: A `coarse` pointer device would be a finger on a touch screen device. However,
    it could equally be a cursor from a games console that doesn't have the fine grained
    control of something like a mouse.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`粗糙`指针设备可能是触摸屏设备上的手指。然而，它也可以是游戏控制台上没有鼠标那样精细控制的光标。'
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A `fine` pointer device would be a mouse but could also be a stylus pen or any
    future fine grained pointer mechanism.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`fine`指针设备可能是鼠标，但也可能是触控笔或任何未来的精细指针机制。'
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As far as I'm concerned, the sooner browsers implement these pointer features,
    the better. At present it's notoriously difficult to know whether or not a user
    has mouse, touch input, or both. And which one they are using at any one time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就我而言，浏览器越早实现这些指针特性越好。目前，要知道用户是否有鼠标、触摸输入或两者都有是非常困难的。以及他们在任何时候使用的是哪一个。
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The safest bet is always to assume users are using touch-based input and size
    user interface elements accordingly. That way, even if they are using a mouse
    they will have no difficulty using the interface with ease. If however you assume
    mouse input, and can't reliably detect touch to amend the interface, it might
    make for a difficult experience.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的做法总是假设用户使用基于触摸的输入，并相应地调整用户界面元素的大小。这样，即使他们使用鼠标，也不会难以轻松使用界面。然而，如果你假设鼠标输入，并且无法可靠地检测触摸以修改界面，可能会导致困难的体验。
- en: 'For a great overview of the challenges of developing for both touch and pointer,
    I recommend this set of slides called *Getting touchy* from Patrick H. Lauke:
    [https://patrickhlauke.github.io/getting-touchy-presentation/](https://patrickhlauke.github.io/getting-touchy-presentation/)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同时开发触摸和指针的挑战的很好概述，我推荐Patrick H. Lauke的这组幻灯片*Getting touchy*：[https://patrickhlauke.github.io/getting-touchy-presentation/](https://patrickhlauke.github.io/getting-touchy-presentation/)
- en: 'Read the Editor''s draft of this feature here: [http://dev.w3.org/csswg/mediaqueries-4/#mf-interaction](http://dev.w3.org/csswg/mediaqueries-4/#mf-interaction)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里阅读这个功能的编辑草案：[http://dev.w3.org/csswg/mediaqueries-4/#mf-interaction](http://dev.w3.org/csswg/mediaqueries-4/#mf-interaction)
- en: The hover media feature
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 悬停媒体特性
- en: 'As you might imagine, the hover media feature tests the users'' ability to
    hover over elements on the screen. If the user has multiple inputs at their disposal
    (touch and mouse for example), characteristics of the primary input are used.
    Here are the possible values and example code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，悬停媒体特性测试用户在屏幕上悬停元素的能力。如果用户有多个输入设备（例如触摸和鼠标），则使用主要输入的特性。以下是可能的值和示例代码：
- en: For users that have no ability to hover, we can target styles for them with
    a value of `none`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有悬停能力的用户，我们可以以`none`的值为他们定制样式。
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For users that can hover but have to perform a significant action to initiate
    it, `on-demand` can be used.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以悬停但必须执行重要操作来启动它的用户，可以使用`on-demand`。
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For users that can hover, `hover` alone can be used.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以悬停的用户，可以单独使用`hover`。
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Be aware that there are also `any-pointer` or `any-hover` media features. They
    are like the preceding hover and pointer but test the capabilities of any of the
    possible input devices.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还有`any-pointer`或`any-hover`媒体特性。它们类似于前面的hover和pointer，但测试任何可能的输入设备的功能。
- en: Environment media features
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境媒体特性
- en: 'Wouldn''t it be nice if we had the ability to alter our designs based upon
    environmental features such as ambient light level? That way if a user was in
    a darker room, we could dim the lightness of the colors used. Or conversely, increase
    contrast in brighter sunlight. The environment media features aim to solve these
    very problems. Consider these examples:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够根据环境特征（如环境光水平）来改变我们的设计，那不是挺好的吗？这样，如果用户在较暗的房间里，我们可以降低所使用颜色的亮度。或者相反，在更明亮的阳光下增加对比度。环境媒体特性旨在解决这些问题。请考虑以下示例：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember there are few implementations of these Level 4 Media Queries in the
    wild. It's also probable that the specifications will change before we can safely
    use them. It is however useful to have some feel for what new capabilities are
    on the way for us in the next few years.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，目前很少有这些Level 4媒体查询的实现。在我们能够安全使用它们之前，规范很可能会发生变化。然而，了解未来几年我们将拥有哪些新功能是有用的。
- en: 'Read the Editor''s draft of this feature here: [http://dev.w3.org/csswg/mediaqueries-4/#mf-environment](http://dev.w3.org/csswg/mediaqueries-4/#mf-environment)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读此功能的编辑草案：[http://dev.w3.org/csswg/mediaqueries-4/#mf-environment](http://dev.w3.org/csswg/mediaqueries-4/#mf-environment)
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned what CSS3 media queries are, how to include them
    in our CSS files, and how they can help our quest to create a responsive web design.
    We've also learned how to use the `meta` tag to make modern mobile browsers render
    pages as we'd like.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是CSS3媒体查询，如何在CSS文件中包含它们，以及它们如何帮助我们创建响应式网页设计。我们还学习了如何使用`meta`标签使现代移动浏览器呈现页面，就像我们想要的那样。
- en: However, we've also learned that media queries alone can only provide an adaptable
    web design, one that snaps from one layout to another. Not a truly responsive
    one that smoothly transitions from one layout to another. To achieve our ultimate
    goal we will also need to utilize fluid layouts. They will allow our designs to
    flex between the break points that the media queries handle. Creating fluid layouts
    to smooth the transition between our media query break points is what we'll be
    covering in the next chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也了解到，单独使用媒体查询只能提供一个适应性的网页设计，从一个布局切换到另一个布局。而不能实现一个真正响应式的设计，能够平稳地从一个布局过渡到另一个布局。为了实现我们的最终目标，我们还需要利用流动布局。它们将允许我们的设计在媒体查询处理的断点之间灵活变化。在下一章中，我们将介绍如何创建流动布局，以平滑过渡我们的媒体查询断点之间的变化。
