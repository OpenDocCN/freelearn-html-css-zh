- en: Chapter 3. Fluid Layouts and Responsive Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 流式布局和响应式图片
- en: Eons ago, in the mists of time (well the late 1990s), websites were typically
    built with their widths defined as percentages. These percentage-based widths
    fluidly adjusted to the screen viewing them and became known as fluid layouts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 亿万年前，在时间的迷雾中（嗯，是在20世纪90年代晚期），网站通常以百分比定义宽度。这些基于百分比的宽度可以流畅地调整到屏幕上，并被称为流式布局。
- en: In the years shortly after, in the mid to late 2000s, there was an intervening
    fixation on fixed width designs (I blame those pesky print designers and their
    obsession with pixel perfect precision). Nowadays, as we build responsive web
    designs we need to look back to fluid layouts and remember all the benefits they
    offer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之后的几年里，即在2000年代中期到晚期，人们对固定宽度设计产生了干扰（我责怪那些固执的印刷设计师和他们对像素完美精度的痴迷）。如今，当我们构建响应式网页设计时，我们需要回顾流式布局，并记住它们提供的所有好处。
- en: In [Chapter 2](ch02.html "Chapter 2. Media Queries – Supporting Differing Viewports"),
    *Media Queries – Supporting Differing Viewports*, we ultimately conceded that
    while media queries allowed our design to adapt to changing viewport sizes, by
    snapping from one set of styles to another, we needed some ability to flex our
    design between the 'break points' that media queries provided. By coding a 'fluid'
    layout, we can facilitate this need perfectly; it will effortlessly stretch to
    fill the gaps between our media query break points.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章 媒体查询-支持不同的视口"), *媒体查询-支持不同的视口*中，我们最终承认，虽然媒体查询允许我们的设计适应不同的视口大小，但通过从一组样式切换到另一组样式，我们需要一些能力在媒体查询提供的“断点”之间灵活调整我们的设计。通过编写“流式”布局，我们可以完美地满足这种需求；它将轻松地拉伸以填补媒体查询断点之间的空白。
- en: In 2015, we have better means to build responsive web sites than ever. There
    is a new CSS layout module called **Flexible Box** (or **Flexbox** as it is more
    commonly known) that now has enough browser support to make it viable for everyday
    use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，我们有比以往任何时候都更好的方法来构建响应式网站。现在有一个名为**Flexible Box**（或者更常见的称为**Flexbox**）的新CSS布局模块，它现在有足够的浏览器支持，可以在日常使用中使用。
- en: It can do more than merely provide a fluid layout mechanism. Want to be able
    to easily center content, change the source order of markup, and generally create
    amazing layouts with relevant ease? Flexbox is the layout mechanism for you. The
    majority of this chapter deals with Flexbox, covering all the incredible capabilities
    it has to offer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅可以提供流式布局机制。想要轻松地居中内容，更改标记的源顺序，并以相关的轻松方式创建令人惊叹的布局？Flexbox是适合您的布局机制。本章的大部分内容涉及Flexbox，涵盖了它所提供的所有令人难以置信的功能。
- en: There is another key area to responsive web design we can address better now
    than ever before and that's responsive images. There are now specified methods
    and syntax for sending devices the most relevant version of an image for their
    viewport. We will spend the last section of this chapter understanding how responsive
    images work and how we can make them work for us.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了指定的方法和语法，可以向设备发送最相关版本的图像以适应其视口。我们将在本章的最后一节中了解响应式图片的工作原理以及如何使其为我们工作。
- en: 'In this chapter we will cover:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: How to convert fixed pixel sizes to proportional sizes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将固定像素尺寸转换为比例尺寸
- en: Consider existing CSS layout mechanisms and their shortfalls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑现有的CSS布局机制及其不足之处
- en: Understand the Flexible Box Layout Module and the benefits it offers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Flexbox布局模块及其提供的好处
- en: Learn the correct syntax for resolution switching and art direction with responsive
    images
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习响应式图片的分辨率切换和艺术方向的正确语法
- en: Converting a fixed pixel design to a fluid proportional layout
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将固定像素设计转换为流式比例布局
- en: Graphic composites made in a program like Photoshop, Illustrator, Fireworks
    (RIP), or Sketch all have fixed pixel dimensions. At some point, the designs need
    to be converted to proportional dimensions by a developer when recreating the
    design as a fluid layout in a browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Photoshop、Illustrator、Fireworks（已故）或Sketch这样的程序中制作的图形合成都有固定的像素尺寸。在将设计重新创建为浏览器中的流式布局时，开发人员需要将设计转换为比例尺寸。
- en: 'There is a beautifully simple formula for making this conversion that the father
    of responsive web design, Ethan Marcotte, set down in his 2009 article, *Fluid
    Grids* ([http://alistapart.com/article/FLUIDGRIDS](http://alistapart.com/article/FLUIDGRIDS)):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常简单的公式可以将固定尺寸布局转换为响应式/流式等价物，这是响应式网页设计之父Ethan Marcotte在他2009年的文章*Fluid Grids*（[http://alistapart.com/article/FLUIDGRIDS](http://alistapart.com/article/FLUIDGRIDS)）中提出的：
- en: '*target / context = result*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标/上下文=结果*'
- en: 'If anything resembling math makes you quiver, think of it this way: divide
    the units of the thing you want, by the thing it lives in. Let''s put that into
    practice as understanding it will enable you to convert any fixed dimension layouts
    into responsive/fluid equivalents.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何类似数学的东西让您感到不安，可以这样想：将您想要的东西的单位除以它所在的单位。理解这一点将使您能够将任何固定尺寸布局转换为响应式/流式等价物。
- en: Consider a very basic page layout intended for desktop. In an ideal world we
    would always be moving to a desktop layout from a smaller screen layout, but for
    the sake of illustrating the proportions we will look at the two situations back
    to front.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个专为桌面设计的非常基本的页面布局。在理想的情况下，我们总是会从较小的屏幕布局转移到桌面布局，但为了说明比例，我们将从后往前看这两种情况。
- en: 'Here''s an image of the layout:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是布局的图像：
- en: '![Converting a fixed pixel design to a fluid proportional layout](img/B03777_03_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![将固定像素设计转换为流式比例布局](img/B03777_03_01.jpg)'
- en: The layout is 960px wide. Both header and footer are the full width of layout.
    The left hand side area is 200px wide, the right hand area is 100px wide. Even
    with my mathematically challenged brain I can tell you the middle section will
    be 660px wide. We need to convert the middle and side sections to proportional
    dimensions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 布局宽度为960像素。页眉和页脚都是布局的全宽。左侧区域宽度为200像素，右侧区域宽度为100像素。即使我的数学能力有限，我也可以告诉您中间部分将宽660像素。我们需要将中间和侧面区域转换为比例尺寸。
- en: 'First up, the left hand side. It''s 200 units wide (target). Divide that size
    by 960 units (the context) and we have a result: .208333333\. Now, whenever we
    get our result with that formula we need to shift the decimal point two to the
    right. That would give us 20.8333333%. That''s 200px described as a percentage
    of 960px.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，左侧。它的宽度是200个单位（目标）。将该尺寸除以960个单位（上下文），我们得到一个结果：.208333333\. 现在，每当我们用这个公式得到结果时，我们需要将小数点向右移动两位。这将给我们20.8333333%。这是将200px描述为960px的百分比。
- en: 'OK, what about the middle section? 660 (target) divided by 960 (context) gives
    us .6875\. Move the decimal two points to the right and we have 68.75%. Finally,
    the right hand section. 100 (target) divided by 960 (context) gives us .104166667\.
    Move the decimal point and we have 10.4166667%. That''s as difficult as it gets.
    Say it with me: target, divided by context, equals result.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，中间部分呢？660（目标）除以960（上下文）给我们.6875\. 将小数点向右移动两位，我们得到68.75%。最后，右侧部分。100（目标）除以960（上下文）给我们.104166667\.
    移动小数点，我们得到10.4166667%。就是这么困难。跟我说：目标，除以上下文，等于结果。
- en: 'To prove the point, let''s quickly build that basic layout as blocks in the
    browser. You can view the layout as `example_03-01`. Here is the HTML:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们在浏览器中快速构建基本布局块。您可以在`example_03-01`中查看布局。这是HTML：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here is the CSS:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CSS：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you open the example code in a browser and resize the page you will see the
    dimensions of the middle sections remain proportional to one another. You can
    also play around with the max-width of the .Wrap values to make the bounding dimensions
    for the layout bigger or smaller (it's set in the example to `1400px`).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开示例代码并调整页面大小，您会发现中间部分的尺寸保持相互成比例。您还可以通过调整`.Wrap`值的最大宽度来使布局的边界尺寸变大或变小（在示例中设置为`1400px`）。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you're looking at the markup and wondering why I haven't used semantic elements
    like `header`, `footer`, and `aside`, then worry not. [Chapter 4](ch04.html "Chapter 4. HTML5
    for Responsive Web Designs"), *HTML5 for Responsive Web Designs*, deals with those
    semantic HTML5 elements in detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看标记并想知道为什么我没有使用`header`，`footer`和`aside`等语义元素，那就不用担心。[第4章](ch04.html "第4章.响应式Web设计的HTML5")，*响应式Web设计的HTML5*，详细介绍了这些语义HTML5元素。
- en: Now, let's consider how we would have the same content on a smaller screen that
    flexes to a point and then changes to the layout we have already seen. You can
    view the final code of this layout in `example_03-02`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一下如何在较小的屏幕上具有相同的内容，然后转换为我们已经看到的布局。您可以在`example_03-02`中查看此布局的最终代码。
- en: The idea is that for smaller screens we will have a single 'tube' of content.
    The left hand side area will only be viewable as an 'off canvas' area; typically
    an area for a menu area or similar, that sits off the viewable screen area and
    slides in when a menu button is pressed. The main content sits below the header,
    then the right hand section below that, and finally the footer area. In our example,
    we can expose the left hand menu area by clicking anywhere on the header. Typically,
    when making this kind of design pattern for real, a menu button would be used
    to activate the side menu.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是，对于较小的屏幕，我们将有一个单独的内容'管道'。左侧区域将只能作为'离屏'区域查看；通常是菜单区域或类似的区域，位于可视屏幕区域之外，当按下菜单按钮时滑入。主要内容位于页眉下方，然后右侧部分位于其下方，最后是页脚区域。在我们的示例中，我们可以通过单击页眉的任何位置来显示左侧菜单区域。通常，在真正制作这种设计模式时，会使用菜单按钮来激活侧边菜单。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To switch the class on the body of the document, I've employed a little JavaScript.
    This isn't 'production ready' though as we are using 'click' as the event handler
    in JavaScript, when ideally we would have some provision for touch (to remove
    the 300ms delay still present on iOS devices).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在文档的body上切换类，我使用了一点JavaScript。不过这并不是'production ready'，因为我们在JavaScript中使用了'click'作为事件处理程序，理想情况下，我们应该有一些触摸的准备（以消除iOS设备上仍然存在的300毫秒延迟）。
- en: As you would expect, when combining this with our newly mastered media query
    skills we can adjust the viewport and the design just 'responds'—effortlessly
    moving from one layout to another and stretching between the two.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，当将这与我们新掌握的媒体查询技能相结合时，我们可以调整视口和设计，布局就会自动地从一个布局移动到另一个布局，并在两者之间拉伸。
- en: 'I''m not going to list out all the CSS here, it''s all in `example_03-02`.
    However, here''s an example—the left hand section:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算在这里列出所有的CSS，它都在`example_03-02`中。不过，这里有一个例子——左侧部分：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that up first, without a media query, is the small screen layout.
    Then, at larger screen sizes, the width becomes proportional, the positioning
    relative and the left value is set to zero. We don't need to re-write properties
    such as the `height`, `display`, or `background-color` as we aren't changing them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，首先是在没有媒体查询的情况下，小屏幕布局。然后，在较大的屏幕尺寸上，宽度变得成比例，定位相对，左值设置为零。我们不需要重新编写诸如`height`，`display`或`background-color`之类的属性，因为我们不会改变它们。
- en: This is progress. We have combined two of the core responsive web design techniques
    we have covered; converting fixed dimensions to proportions and using media queries
    to target CSS rules relevant to the viewport size.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进步。我们已经结合了我们所学的两种核心响应式Web设计技术；将固定尺寸转换为比例，并使用媒体查询来针对视口大小调整CSS规则。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are two important things to note in our prior example. Firstly, you may
    be wondering if it's strictly necessary to include all the digits after the decimal
    point. While the widths themselves will ultimately be converted to pixels by the
    browser, their values are retained for future calculations (for example, more
    accurately computing the width of nested elements). Subsequently, I always recommend
    leaving the numbers after the decimals in.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中有两件重要的事情需要注意。首先，您可能想知道是否严格需要包括小数点后的所有数字。虽然这些宽度最终将被浏览器转换为像素，但它们的值将被保留用于未来的计算（例如，更准确地计算嵌套元素的宽度）。因此，我总是建议保留小数点后的数字。
- en: Secondly, in a real project we should be making some provision for if JavaScript
    isn't available and we need to view the content of the menu. We deal with this
    scenario in detail in [Chapter 8](ch08.html "Chapter 8. Transitions, Transformations,
    and Animations"), *Transitions, Transformations, and Animations*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在一个真实的项目中，如果JavaScript不可用并且我们需要查看菜单的内容，我们应该做一些准备。我们在[第8章](ch08.html "第8章。过渡，变换和动画")中详细处理这种情况，*过渡，变换和动画*。
- en: Why do we need Flexbox?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么需要Flexbox？
- en: We are now going to get into the detail of using CSS Flexible Box Layouts, or
    Flexbox as it is more commonly known.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将详细介绍使用CSS弹性盒布局，或者更常见的Flexbox。
- en: However, before we do that, I think it will be prudent to first consider the
    shortfalls of existing layout techniques such as inline-block, floats and tables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，我认为首先考虑现有布局技术的不足是明智的，比如内联块，浮动和表格。
- en: Inline block and whitespace
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联块和空格
- en: 'The biggest issue with using inline-block as a layout mechanism is that it
    renders space in-between HTML elements. This is not a bug (although most developers
    would welcome a sane way to remove the space) but it does mean a few hacks to
    remove the space when it''s unwanted, which for me is about 95% of the time. There
    are a bunch of ways to do this, in the previous example we used the ''font-size
    zero'' approach; an approach not without its own problems and limitations. However,
    rather than list each possible workaround for removing the whitespace when using
    inline-block, check out this article by the irrepressible Chris Coyier: [http://css-tricks.com/fighting-the-space-between-inline-block-elements/](http://css-tricks.com/fighting-the-space-between-inline-block-elements/).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联块作为布局机制的最大问题是它在HTML元素之间渲染空格。这不是一个错误（尽管大多数开发人员都希望有一种理智的方法来删除空格），但这意味着一些方法来删除不需要的空格，对我来说，这大约是95%的时间。有很多方法可以做到这一点，在前面的例子中，我们使用了“字体大小为零”的方法；这种方法并非没有问题和局限性。但是，与其列出使用内联块时去除空格的每种可能的解决方法，不如查看这篇由无法抑制的Chris
    Coyier撰写的文章：[http://css-tricks.com/fighting-the-space-between-inline-block-elements/](http://css-tricks.com/fighting-the-space-between-inline-block-elements/)。
- en: It's also worth pointing out that there no simple way to vertically center content
    within an inline-block. Using inline-blocks, there is also no way of having two
    sibling elements where one has a fixed width and another fluidly fills the remaining
    space.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得指出的是，没有简单的方法在内联块内垂直居中内容。使用内联块，也没有办法让两个兄弟元素中一个具有固定宽度，另一个自动填充剩余空间。
- en: Floats
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮动
- en: I hate floats. There I said it. In their favor they work everywhere fairly consistently.
    However, there are two major irritations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我讨厌浮动。我说了。它们的好处是它们在各处的工作相当一致。然而，有两个主要的烦恼。
- en: Firstly, when specifying the width of floated elements in percentages, their
    computed widths don't get rounded consistently across browsers (some browsers
    round up, some down). This means that sometimes sections will drop down below
    others when it isn't intended and other times they can leave an irritating gap
    at one side.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当以百分比指定浮动元素的宽度时，它们的计算宽度在各个浏览器中并不一致（有些浏览器向上舍入，有些向下舍入）。这意味着有时部分内容会意外地下降到其他部分下面，而其他时候它们可能会在一侧留下令人恼火的间隙。
- en: Secondly you usually have to 'clear' the floats so that parent boxes/elements
    don't collapse. It's easy enough to do this but it's a constant reminder that
    floats were never intended to be used as a robust layout mechanism.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，通常需要“清除”浮动，以防止父框/元素坍塌。这很容易做到，但它不断提醒我们，浮动从来不是用作强大的布局机制。
- en: Table and table-cell
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格和表格单元格
- en: 'Don''t confuse `display: table` and `display: table-cell` with the equivalent
    HTML elements. These CSS properties merely mimic the layout of their HTML based
    brethren. They in no way affect the structure of the HTML.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '不要混淆`display: table`和`display: table-cell`与等效的HTML元素。这些CSS属性仅模仿其基于HTML的兄弟的布局。它们绝对不会影响HTML的结构。'
- en: 'I''ve found enormous utility in using CSS table layouts. For one, they enable
    consistent and robust vertical centring of elements within one another. Also,
    elements set to be `display: table-cell` inside an element set as `display: table`
    space themselves perfectly; they don''t suffer rounding issues like floated elements.
    You also get support all the way back to Internet Explorer 7!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '我发现使用CSS表格布局非常有用。首先，它们可以在元素之间实现一致和强大的垂直居中。此外，设置为`display: table`的元素内部设置为`display:
    table-cell`的元素可以完美地空出空间；它们不像浮动元素那样遇到四舍五入的问题。您还可以获得对Internet Explorer 7的全面支持！'
- en: 'However, there are limitations. Generally, it''s necessary to wrap an extra
    element around items (to get the joys of perfect vertical centring, a table-cell
    must live inside an element set as a table). It''s also not possible to wrap items
    set as `display: table-cell` onto multiple lines.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，也有局限性。通常需要在项目周围包装额外的元素（为了获得完美的垂直居中的乐趣，表格单元格必须存在于设置为表格的元素内）。还不可能将设置为`display:
    table-cell`的项目包装到多行中。'
- en: In conclusion, all of the existing layout methods have severe limitations. Thankfully,
    there is a new CSS layout method that addresses these issues and much more. Cue
    the trumpets, roll out the red carpet. Here comes Flexbox.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，所有现有的布局方法都有严重的局限性。幸运的是，有一种新的CSS布局方法可以解决这些问题，还有更多。吹号声响起，铺开红地毯。Flexbox来了。
- en: Introducing Flexbox
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Flexbox
- en: 'Flexbox addresses the shortfalls in each of the aforementioned display mechanisms.
    Here''s a brief overview of its super powers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox解决了上述每种显示机制的不足。以下是它的超级功能的简要概述：
- en: It can easily vertically center contents
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以轻松地垂直居中内容
- en: It can change the visual order of elements
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以改变元素的视觉顺序
- en: It can automatically space and align elements within a box, automatically assigning
    available space between them
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以自动在框内对齐和排列元素，自动分配它们之间的可用空间。
- en: It can make you look 10 years younger (probably not, but in low numbers of empirical
    tests (me) it has been proven to reduce stress)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以让你看起来年轻10岁（可能不是，但在少量经验测试中（我）已经证明可以减轻压力）
- en: The bumpy path to Flexbox
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通往Flexbox的崎岖之路
- en: Flexbox has been through a few major iterations before arriving at the relatively
    stable version we have today. For example, consider the changes from the 2009
    version ([http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/](http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/)),
    the 2011 version ([http://www.w3.org/TR/2011/WD-css3-flexbox-20111129/](http://www.w3.org/TR/2011/WD-css3-flexbox-20111129/)),
    and the 2014 version we are basing our examples on ([http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)).
    The syntax differences are marked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在达到我们今天拥有的相对稳定版本之前，Flexbox经历了几次重大迭代。例如，考虑从2009年版本（[http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/](http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/)）到2011年版本（[http://www.w3.org/TR/2011/WD-css3-flexbox-20111129/](http://www.w3.org/TR/2011/WD-css3-flexbox-20111129/)），再到我们基于的2014年版本（[http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)）。语法差异很大。
- en: These differing specifications mean there are three major implementation versions.
    How many of these you need to concern yourself with depends on the level of browser
    support you need.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的规范意味着有三个主要的实现版本。您需要关注多少取决于您需要的浏览器支持级别。
- en: Browser support for Flexbox
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flexbox的浏览器支持
- en: 'Let''s get this out of the way up front: there is no Flexbox support in Internet
    Explorer 9, 8, or below.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先说清楚：Internet Explorer 9、8或更低版本都不支持Flexbox。
- en: For everything else you'd likely want to support (and virtually all mobile browsers),
    there is a way to enjoy most (if not all) of Flexbox's features. You can check
    the support information at [http://caniuse.com/](http://caniuse.com/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您可能想要支持的其他所有内容（几乎所有移动浏览器），都有一种方法可以享受Flexbox的大多数（如果不是全部）功能。您可以在[http://caniuse.com/](http://caniuse.com/)上查看支持信息。
- en: Before we get stuck into Flexbox, we need to take a brief but essential tangent.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入Flexbox之前，我们需要进行一个简短但必要的偏离。
- en: Leave prefixing to someone else
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 把前缀留给别人
- en: 'It''s my hope that once you have seen a few examples of Flexbox, you will appreciate
    its utility and feel empowered to use it. However, manually writing all the necessary
    code to support each of the different Flexbox specifications is a tough task.
    Here''s an example. I''m going to set three Flexbox related properties and values.
    Consider this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望一旦您看到了Flexbox的一些示例，您会欣赏到它的实用性，并感到有能力使用它。然而，手动编写支持每个不同Flexbox规范所需的所有必要代码是一项艰巨的任务。这里有一个例子。我将设置三个与Flexbox相关的属性和值。考虑一下：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s how the properties and values would look in the most recent syntax.
    However, if we want support for Android browsers (v4 and below) and IE 10, here
    is what would actually be needed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最新语法中属性和值的样子。然而，如果我们想要支持Android浏览器（v4及以下）和IE 10，实际上需要的是：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's necessary to write all that because in the last few years, as browsers
    made experimental versions of new functionality available, they did so with a
    'vendor prefix'. Each vendor had their own prefix. For example `-ms-` for Microsoft,
    `-webkit-` for WebKit, `-moz-` for Mozilla, and so on. For every new feature this
    meant it was necessary to write multiple versions of the same property; the vendor
    prefixed versions first, and the official W3C version at the bottom.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要写出所有这些，因为在过去几年里，随着浏览器发布了新功能的实验版本，它们都带有“供应商前缀”。每个供应商都有自己的前缀。例如，微软的是`-ms-`，WebKit的是`-webkit-`，Mozilla的是`-moz-`，等等。对于每个新功能，这意味着需要编写同一属性的多个版本；首先是供应商前缀版本，然后是官方的W3C版本。
- en: The result of this spell in web history is CSS that looks like the previous
    example. It's the only way to get the feature working across the widest number
    of devices. Nowadays, vendors rarely add prefixes but for the foreseeable future
    we must live with the reality of many existing browsers still requiring prefixes
    to enable certain features. This brings us back to Flexbox, an extreme example
    of vendor prefixing thanks to not just multiple vendor versions but also different
    specifications of the feature. And understanding and remembering everything you
    need to write in the current format and each previous format is not a whole lot
    of fun.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个咒语在Web历史上的结果是CSS看起来像前面的例子。这是在尽可能多的设备上使功能正常工作的唯一方法。如今，供应商很少添加前缀，但在可预见的未来，我们必须接受许多现有浏览器仍然需要前缀来启用某些功能的现实。这让我们回到了Flexbox，这是供应商前缀的一个极端例子，不仅有多个供应商版本，还有不同的功能规范。记住并理解您需要以当前格式和每个以前的格式编写的所有内容并不是一件有趣的事情。
- en: I don't know about you, but I'd rather spend my time doing something more productive
    than writing out that little lot each time! In short, if you intend to use Flexbox
    in anger, take the time to setup an auto-prefixing solution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你怎么想，但我宁愿把时间花在做一些更有意义的事情上，而不是每次都写出那么多东西！简而言之，如果您打算愤怒地使用Flexbox，请花时间设置自动前缀解决方案。
- en: Choosing your auto-prefixing solution
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择您的自动前缀解决方案
- en: For the sake of your sanity, to accurately and easily add vendor-prefixes to
    CSS, use some form of automatic prefixing solution. Right now, I favor Autoprefixer
    ([https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)).
    It's fast, easy to setup and very accurate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持理智，准确且轻松地向CSS添加供应商前缀，使用某种形式的自动前缀解决方案。目前，我更喜欢Autoprefixer（[https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)）。它快速、易于设置且非常准确。
- en: 'There are versions of Autoprefixer for most setups; you don''t necessarily
    need a command line based build tool (for example, Gulp or Grunt). For example,
    if you use Sublime Text, there is a version that will work straight from the command
    palette: [https://github.com/sindresorhus/sublime-autoprefixer](https://github.com/sindresorhus/sublime-autoprefixer).
    There are also versions of Autoprefixer for Atom, Brackets, and Visual Studio.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数设置都有Autoprefixer的版本；您不一定需要基于命令行的构建工具（例如Gulp或Grunt）。例如，如果您使用Sublime Text，有一个版本可以直接从命令面板中使用：[https://github.com/sindresorhus/sublime-autoprefixer](https://github.com/sindresorhus/sublime-autoprefixer)。Atom、Brackets和Visual
    Studio也有Autoprefixer的版本。
- en: From this point on, unless essential to illustrate a point, there will be no
    more vendor prefixes in the code samples.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，除非必须说明一个观点，否则在代码示例中将不再有供应商前缀。
- en: Getting Flexy
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活起来
- en: 'Flexbox has four key characteristics: **direction**, **alignment**, **ordering**,
    and **flexibility**. We''ll cover all these characteristics and how they relate
    by way of a few examples.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox有四个关键特性：**方向**，**对齐**，**排序**和**灵活性**。我们将通过一些示例来介绍所有这些特性以及它们之间的关系。
- en: The examples are deliberately simplistic; just moving some boxes and their content
    around so we can understand the principals of how Flexbox works.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例故意简单化；只是移动一些框和它们的内容，以便我们可以理解Flexbox的工作原理。
- en: Perfect vertically centered text
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完美垂直居中的文本
- en: 'Note that this first Flexbox example is `example_03-03`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个第一个Flexbox示例是`example_03-03`：
- en: '![Perfect vertically centered text](img/B03777_03_15.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![完美垂直居中的文本](img/B03777_03_15.jpg)'
- en: 'Here''s the markup:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标记：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the entire CSS rule that''s styling that markup:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是样式整个CSS规则：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The majority of the property/value pairs in that rule are merely setting colors
    and font sizing. The three properties we are interested in are:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则中的大多数属性/值对仅仅是设置颜色和字体大小。我们感兴趣的三个属性是：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you have not used Flexbox or any of the properties in the related Box Alignment
    specification ([http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/))
    these properties probably seem a little alien. Let''s consider what each one does:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用Flexbox或相关的Box Alignment规范中的任何属性（[http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/)），这些属性可能看起来有点陌生。让我们考虑每个属性的作用：
- en: '`display: flex`: This is the bread and butter of Flexbox. This merely sets
    the item to be a Flexbox (as opposed to a block, inline-block, and so on).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display: flex`：这是Flexbox的基础。这仅仅是将项目设置为Flexbox（而不是块、内联块等）。'
- en: '`align-items`: This aligns the items within a Flexbox in the cross axis (vertically
    centering the text in our example).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`align-items`：这在Flexbox中沿交叉轴对齐项目（在我们的示例中垂直居中文本）。'
- en: '`justify-content`: This sets the main axis centring of the content. With a
    Flexbox row, you can think of it like the button in a word processor that sets
    the text to the left, right, or center (although there are additional `justify-content`
    values we will look at shortly).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`justify-content`：这设置了内容的主轴居中。对于Flexbox行，您可以将其视为文字处理器中设置文本左对齐、右对齐或居中的按钮（尽管我们很快将看到更多`justify-content`的值）。'
- en: OK, before we get further into the properties of Flexbox, we will consider a
    few more examples.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在我们深入了解Flexbox的属性之前，我们将考虑一些更多的示例。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In some of these examples I'm making use of the Google hosted font 'Oswald'
    (with a fallback to a sans-serif font). In [Chapter 5](ch05.html "Chapter 5. CSS3
    – Selectors, Typography, Color Modes, and New Features"), *CSS3 – Selectors, Typography,
    Color Modes, and New Features*, we will look at how we can use the `@font-face`
    rule to link to custom font files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中一些示例中，我使用了谷歌托管的字体'Oswald'（并回退到无衬线字体）。在[第5章](ch05.html "第5章。CSS3 – 选择器、排版、颜色模式和新功能")中，*CSS3
    – 选择器、排版、颜色模式和新功能*，我们将看看如何使用`@font-face`规则链接到自定义字体文件。
- en: Offset items
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏移项目
- en: How about a simple list of navigation items, but with one offset to one side?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想要一个简单的导航项目列表，但其中一个偏移了一边？
- en: 'Here''s what it looks like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的样子：
- en: '![Offset items](img/B03777_03_02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![偏移项目](img/B03777_03_02.jpg)'
- en: 'Here''s the markup:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标记：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And here is the CSS:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CSS：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'How about that—not a single float, inline-block, or table-cell needed! When
    you set `display: flex;` on a wrapping element, the children of that element become
    flex-items which then get laid out using the flex layout model. The magic property
    here is `margin-left: auto` which makes that item use all available margin on
    that side.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '怎么样，没有一个浮动、内联块或表格单元格！当您在包裹元素上设置`display: flex;`时，该元素的子元素就成为了flex项目，然后使用flex布局模型进行布局。这里的神奇属性是`margin-left:
    auto`，它使该项目在该侧使用所有可用的边距。'
- en: Reverse the order of items
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颠倒项目的顺序
- en: Want to reverse the order of the items?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 想要颠倒项目的顺序吗？
- en: '![Reverse the order of items](img/B03777_03_03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![颠倒项目的顺序](img/B03777_03_03.jpg)'
- en: 'It''s as easy as adding `flex-direction: row-reverse;` to the wrapping element
    and changing `margin-left: auto` to `margin-right: auto` on the offset item:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '只需在包裹元素上添加`flex-direction: row-reverse;`并将偏移项上的`margin-left: auto`更改为`margin-right:
    auto`：'
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How about if we want them laid out vertically instead?
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果我们想要它们垂直布局呢？
- en: 'Simple. Change to `flex-direction: column;` on the wrapping element and remove
    the auto margin:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '简单。在包裹元素上更改为`flex-direction: column;`并删除自动边距：'
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Column reverse
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列反转
- en: 'Want them stacked in the opposite direction? Just change to `flex-direction:
    column-reverse;` and you''re done.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '想要它们以相反的方向堆叠吗？只需更改为`flex-direction: column-reverse;`就可以了。'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You should be aware that there is a `flex-flow` property that is shorthand
    for setting `flex-direction` and `flex-wrap` in one. For example, `flex-flow:
    row wrap;` would set the direction to a row and set wrapping on. However, at least
    initially, I find it easier to specify the two settings separately. The `flex-wrap`
    property is also absent from the oldest Flexbox implementations so can render
    the whole declaration void in certain browsers.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '您应该知道有一个`flex-flow`属性，它是设置`flex-direction`和`flex-wrap`的快捷方式。例如，`flex-flow:
    row wrap;`会将方向设置为行，并设置换行。然而，至少在最初，我发现更容易分别指定这两个设置。`flex-wrap`属性在最旧的Flexbox实现中也不存在，因此可能会在某些浏览器中使整个声明无效。'
- en: Different Flexbox layouts inside different media queries
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的媒体查询内的不同Flexbox布局
- en: 'As the name suggests, Flexbox is inherently flexible so how about we go for
    a column list of items at smaller viewports and a row style layout when space
    allows. It''s a piece of cake with Flexbox:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，Flexbox本质上是灵活的，所以在较小的视口上，我们选择列出项目，并在空间允许时选择行样式布局。这对Flexbox来说非常简单：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can view that as `example_03-05`. Be sure to resize the browser window to
    see the different layouts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其视为`example_03-05`。确保调整浏览器窗口大小以查看不同的布局。
- en: Inline-flex
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联弹性
- en: 'Flexbox has an inline variant to complement inline-block and inline-table.
    As you might have guessed it is `display: inline-flex;`. Thanks to its beautiful
    centering abilities you can do some wacky things with very little effort.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'Flexbox有一个内联变体，以补充内联块和内联表格。你可能已经猜到了，它是`display: inline-flex;`。由于它美丽的居中能力，你可以用很少的努力做一些古怪的事情。'
- en: '![Inline-flex](img/B03777_03_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![内联弹性](img/B03777_03_04.jpg)'
- en: 'Here''s the markup:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标记：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And here is the CSS for that:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是那个的CSS：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When items are set as `inline-flex` anonymously (for example, their parent
    element is not set to `display: flex;`) then they retain whitespace between elements,
    just like inline-block or inline-table do. However, if they are within a flex
    container, then whitespace is removed, much as it is with table-cell items within
    a table.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '当项目被匿名设置为`inline-flex`（例如，它们的父元素没有设置为`display: flex;`）时，它们保留元素之间的空白，就像inline-block或inline-table一样。然而，如果它们在一个flex容器中，那么空白将被移除，就像在表格中的table-cell项目一样。'
- en: Of course, you don't always have to center items within a Flexbox. There are
    a number of different options. Let's look at those now.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你并不总是需要在Flexbox中居中项目。有许多不同的选项。让我们现在来看看这些。
- en: Flexbox alignment properties
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flexbox对齐属性
- en: If you want to play with this example, you can find it at `example_03-07`. Remember
    the example code you download will be at the point where we finish this section
    so if you want to 'work along' you may prefer to delete the CSS in the example
    file and start again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想玩玩这个例子，你可以在`example_03-07`找到它。记住你下载的例子代码将会在我们完成这一部分时的位置，所以如果你想“跟着做”，你可能更喜欢删除示例文件中的CSS，然后重新开始。
- en: The important thing to understand with Flexbox alignment is the concept of axis.
    There are two axis to consider, the 'main axis' and the 'cross axis'. What each
    of these represents depends upon the direction the Flexbox is heading. For example,
    if the direction of your Flexbox is set to `row`, the main axis will be the horizontal
    axis and the cross axis will be the vertical axis.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Flexbox对齐的重要事情是轴的概念。有两个轴要考虑，'主轴'和'交叉轴'。每个代表什么取决于Flexbox的方向。例如，如果你的Flexbox的方向设置为`row`，主轴将是水平轴，交叉轴将是垂直轴。
- en: Conversely, if your Flexbox direction is set to `column`, the main axis will
    be the vertical axis and the cross axis will be the horizontal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你的Flexbox方向设置为`column`，主轴将是垂直轴，交叉轴将是水平轴。
- en: 'The specification ([http://www.w3.org/TR/css-flexbox-1/#justify-content-property](http://www.w3.org/TR/css-flexbox-1/#justify-content-property))
    provides the following illustration to aid authors:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 规范([http://www.w3.org/TR/css-flexbox-1/#justify-content-property](http://www.w3.org/TR/css-flexbox-1/#justify-content-property))提供了以下插图来帮助作者：
- en: '![Flexbox alignment properties](img/B03777_03_11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Flexbox对齐属性](img/B03777_03_11.jpg)'
- en: 'Here''s the basic markup of our example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例的基本标记：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s set basic Flexbox related styles:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置基本的Flexbox相关样式：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the browser, that produces this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，这产生了这个效果：
- en: '![Flexbox alignment properties](img/B03777_03_06.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Flexbox对齐属性](img/B03777_03_06.jpg)'
- en: Right, let's test drive the effects of some of these properties.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们来测试一下这些属性的效果。
- en: The align-items property
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: align-items属性
- en: 'The `align-items` property positions items in the cross axis. If we apply this
    property to our wrapping element like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`align-items`属性将项目在交叉轴上定位。如果我们将这个属性应用到我们的包裹元素上，就像这样：'
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you would imagine, the item within that box gets centered vertically:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，盒子中的项目垂直居中：
- en: '![The align-items property](img/B03777_03_05.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![align-items属性](img/B03777_03_05.jpg)'
- en: The same effect would be applied to any number of children within.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的效果将应用于任何数量的子元素。
- en: The align-self property
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: align-self属性
- en: 'Sometimes, you may want to pull just one item into a different alignment. Individual
    flex items can use the `align-self` property to align themselves. At this point,
    I''ll remove the previous alignment properties, add another two items into the
    markup (they have been given the `.FlexInner` HTML class), and on the middle one
    I''ll add another HTML class (`.AlignSelf`) and use it to add the `align-self`
    property. Viewing the CSS at this point may be more illustrative:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只想将一个项目拉到不同的对齐方式。单独的flex项目可以使用`align-self`属性来对齐自己。在这一点上，我将删除之前的对齐属性，将另外两个项目添加到标记中（它们已经被赋予了`.FlexInner`
    HTML类），并在中间的项目上添加另一个HTML类（`.AlignSelf`），并使用它来添加`align-self`属性。此时查看CSS可能更具说明性：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the effect in the browser:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在浏览器中的效果：
- en: '![The align-self property](img/B03777_03_07.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![align-self属性](img/B03777_03_07.jpg)'
- en: Wow! Flexbox really makes these kinds of changes trivial. In that example the
    value of `align-self` was set to `flex-end`. Let's consider the possible values
    we could use on the cross axis before looking at alignment in the main axis.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！Flexbox真的让这些变化变得微不足道。在这个例子中，`align-self`的值被设置为`flex-end`。在看主轴上的对齐之前，让我们考虑一下我们可以在交叉轴上使用的可能值。
- en: Possible alignment values
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可能的对齐值
- en: 'For cross axis alignment, Flexbox has the following possible values:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交叉轴对齐，Flexbox有以下可能的值：
- en: '`flex-start`: Setting an element to `flex-start` would make it begin at the
    ''starting'' edge of its flex container'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-start`：将元素设置为`flex-start`会使其从其flex容器的“起始”边开始'
- en: '`flex-end`: Setting to `flex-end` would align the element at the end of the
    flex container'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-end`：设置为`flex-end`会将元素对齐到flex容器的末尾'
- en: '`center`: Puts it in the middle of the flex container'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`：将其放在flex容器的中间'
- en: '`baseline`: Sets all flex items in the container so that their baselines align'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseline`：设置容器中所有flex项目，使它们的基线对齐'
- en: '`stretch`: Makes the items stretch to the size of their flex container (in
    the cross axis)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch`：使项目拉伸到其flex容器的大小（在交叉轴上）'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are some particulars inherent to using these properties, so if something
    isn''t playing happily, always refer to the specification for any edge case scenarios:
    [http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些属性有一些特殊之处，所以如果有什么不顺利的地方，总是参考规范中的任何边缘情况场景：[http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)。
- en: The justify-content property
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: justify-content属性
- en: 'Alignment in the main axis is controlled with `justify-content` (for non Flexbox/block-level
    items, the `justify-self` property has also been proposed ([http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/)).
    Possible values for `justify-content` are:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 主轴上的对齐由`justify-content`控制（对于非Flexbox/block-level项目，还提出了`justify-self`属性（[http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/)）。`justify-content`的可能值包括：
- en: '`flex-start`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-start`'
- en: '`flex-end`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-end`'
- en: '`center`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`'
- en: '`space-between`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space-between`'
- en: '`space-around`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space-around`'
- en: 'The first three do exactly what you would now expect. However, let''s take
    a look what `space-between` and `space-around` do. Consider this markup:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个正是你现在所期望的。然而，让我们看看`space-between`和`space-around`的作用。考虑这个标记：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And then consider this CSS. We are setting the three flex-items (`FlexInner`)
    to each be 25% width, wrapped by a flex container (`FlexWrapper`) set to be 100%
    width.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后考虑这个CSS。我们将三个flex项（`FlexInner`）的宽度分别设置为25%，并由一个设置为100%宽度的flex容器（`FlexWrapper`）包裹。
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As the three items will only take up 75% of the available space, `justify-content`
    explains what we would like the browser to do with the remaining space. A value
    of `space-between` puts equal amount of space between the items and `space-around`
    puts it around. Perhaps a screenshot here will help: This is `space-between`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个项目只占用了可用空间的75%，`justify-content`解释了我们希望浏览器如何处理剩余空间。`space-between`的值在项目之间放置相等的空间，而`space-around`则将其放置在周围。也许这里的屏幕截图会有所帮助：这是`space-between`。
- en: '![The justify-content property](img/B03777_03_08.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![justify-content属性](img/B03777_03_08.jpg)'
- en: And here is what happens if we switch to `space-around`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到`space-around`，会发生什么呢？
- en: '![The justify-content property](img/B03777_03_09.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![justify-content属性](img/B03777_03_09.jpg)'
- en: Those two values are pretty handy I think you will agree.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这两个值非常方便。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The various alignment properties of Flexbox are currently being specified into
    the CSS Box Alignment Module Level 3\. This should give the same fundamental alignment
    powers to other display properties, such as `display: block;` and `display: table;`.
    The specification is still being worked upon so check the status at [http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'Flexbox的各种对齐属性目前正在被规范为CSS Box Alignment Module Level 3。这应该为其他显示属性（如`display:
    block;`和`display: table;`）提供相同的基本对齐功能。规范仍在进行中，因此请查看[http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/)的状态。'
- en: The flex property
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: flex属性
- en: 'We''ve used the `width` property on those flex-items but it''s also possible
    to define the width, or ''flexiness'' if you will, with the `flex` property. To
    illustrate, consider another example; same markup, but amended CSS for the items:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在这些flex项上使用了`width`属性，但也可以使用`flex`属性定义宽度或'灵活性'。为了说明这一点，考虑另一个例子；相同的标记，但是为项目修改了CSS：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `flex` property is actually a shorthand way of specifying three separate
    properties: `flex-grow`, `flex-shrink`, and `flex-basis`. The specification covers
    these individual properties in more detail at [http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/).
    However, the specification recommends that authors use the `flex` shorthand property,
    so that''s what we''re rolling with here, capiche?'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex`属性实际上是指定三个单独属性的一种简写方式：`flex-grow`、`flex-shrink`和`flex-basis`。规范在[http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)中更详细地涵盖了这些单独的属性。然而，规范建议作者使用`flex`简写属性，这就是我们在这里使用的，明白了吗？'
- en: '![The flex property](img/B03777_03_13.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![flex属性](img/B03777_03_13.jpg)'
- en: For flex-items, if a `flex` property is present (and the browser supports it),
    it is used to size the item rather than a width or height value (if present).
    Even if the width or height value is specified after the `flex` property, it will
    still have no effect. Let's look at what each of these values do.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于flex项，如果存在`flex`属性（并且浏览器支持），则使用该属性来调整项目的大小，而不是宽度或高度值（如果存在）。即使在`flex`属性之后指定了宽度或高度值，它仍然没有效果。让我们看看每个值的作用。
- en: '`flex-grow` (the first value you can pass to flex) is the amount, relevant
    to the other flex items, the flex-item can grow when free space is available'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-grow`（传递给flex的第一个值）是与其他flex项相关的，当有空闲空间时，flex项可以增长的量'
- en: '`flex-shrink` is the amount the flex-item can shrink relevant to the other
    flex-items when there is not enough space available'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-shrink`是与其他flex项相关的，当没有足够的空间时，flex项可以缩小的量'
- en: '`flex-basis` (the final value you can pass to Flex) is the basis size the flex-item
    is sized to'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-basis`（传递给Flex的最后一个值）是flex项的基础大小'
- en: 'Although it''s possible to just write `flex: 1`, I recommend writing all the
    values into a `flex` property. I think it''s clearer what you intend to happen.
    For example: `flex: 1 1 auto` means that the item will grow into 1 part of the
    available space, it will also shrink 1 part when space is lacking and the basis
    size for the flexing is the intrinsic width of the content (the size the content
    would be if flex wasn''t involved).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然可能只写`flex: 1`，但我建议将所有值写入`flex`属性。我认为这样更清楚你的意图。例如：`flex: 1 1 auto`表示项目将占用可用空间的1部分，当空间不足时它也会缩小1部分，而弹性的基础大小是内容的固有宽度（如果没有弹性，内容的大小将是多少）。'
- en: 'Let''s try another: `flex: 0 0 50px` means this item will neither grow nor
    shrink and it''s basis is 50px (so it will be 50px regardless of any free space).
    How about flex: 2 0 50%—that''s going to take two ''lots'' of available space,
    it won''t shrink and its basis size is 50%. Hopefully, these brief examples have
    demystified the flex property a little.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们再试一下：`flex: 0 0 50px`表示此项目既不会增长也不会缩小，其基础大小为50px（因此无论有多少空闲空间，它都将是50px）。`flex:
    2 0 50%`呢？这将占用两个''部分''的可用空间，它不会缩小，其基础大小为50%。希望这些简短的例子能让flex属性变得更加清晰。'
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you set the `flex-shrink` value to zero, then the flex basis effectively
    behaves like a minimum width.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`flex-shrink`值设置为零，则flex基础实际上就像最小宽度一样。
- en: 'You can think of the `flex` property as a way to set ratios. With each flex-item
    set to 1, they each take an equal amount of space:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`flex`属性视为设置比例的一种方式。每个flex项设置为1，它们各自占据相等的空间：
- en: '![The flex property](img/B03777_03_10.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![flex属性](img/B03777_03_10.jpg)'
- en: 'Right, so to test the theory, let''s amend the HTML classes in the markup:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，为了测试这个理论，让我们修改标记中的HTML类：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And then here is the amended CSS:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这是修改后的CSS：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this instance, `FlexOne` takes up 1.5 the amount of space that `FlexTwo`
    and `FlexThree` take up.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`FlexOne`占据了`FlexTwo`和`FlexThree`占据的1.5倍空间。
- en: This shorthand syntax really becomes useful for quickly bashing out relationships
    between items. For example, if the request comes in, "that needs to be 1.8 times
    wider than the others", you could easily facilitate that request with the flex
    property.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写语法确实非常有用，可以快速建立项目之间的关系。例如，如果有请求说，“这需要比其他项目宽1.8倍”，您可以很容易地使用flex属性满足该请求。
- en: Hopefully, the incredibly powerful flex property is starting to make a little
    sense now?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 希望非常强大的flex属性现在开始有点意义了？
- en: I could write chapters and chapters on Flexbox! There are so many examples we
    could look at. However, before we move on to the other main topic of this chapter
    (responsive images) there are just two more things I would like to share with
    you.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以写上关于Flexbox的章节！我们可以看很多例子。然而，在我们继续本章的另一个主题（响应式图片）之前，我还有两件事想与您分享。
- en: Simple sticky footer
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的粘性页脚
- en: 'Suppose you want a footer to sit at the bottom of the viewport when there is
    not enough content to push it there. This has always been a pain to achieve but
    with Flexbox it''s simple. Consider this markup (which can be viewed in `example_03-08`):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望在内容不足以将其推到底部时，页脚位于视口底部。以前实现这一点总是很麻烦，但使用Flexbox很简单。考虑以下标记（可以在`example_03-08`中查看）：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And here''s the CSS:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CSS：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Take a look at that in the browser and test adding more content into `.MainContentdiv`.
    You'll see that when there is not enough content, the footer is stuck to the bottom
    of the viewport. When there is, it sits below the content.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看并测试向`.MainContentdiv`添加更多内容。您会发现当内容不足时，页脚会固定在视口底部。当有足够内容时，它会显示在内容下方。
- en: This works because our `flex` property is set to grow where space is available.
    As our body is a flex container of 100% minimum height, the main content can grow
    into all that available space. Beautiful.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的`flex`属性设置为在有空间时增长。由于我们的body是一个100%最小高度的flex容器，主内容可以扩展到所有可用空间。很美。
- en: Changing source order
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改源顺序
- en: 'Since the dawn of CSS, there has only been one way to switch the visual ordering
    of HTML elements in a web page. That was achieved by wrapping elements in something
    set to `display: table` and then switching the `display` property on the items
    within, between `display: table-caption` (puts it on top), `display: table-footer-group`
    (sends it to the bottom), and `display: table-header-group` (sends it to just
    below the item set to `display: table-caption`). However, as robust as this technique
    is, it was a happy accident, rather than the true intention of these settings.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '自CSS诞生以来，在网页中切换HTML元素的视觉顺序只有一种方法。通过将元素包装在设置为`display: table`的东西中，然后在元素之间切换`display`属性，即在`display:
    table-caption`（将其放在顶部），`display: table-footer-group`（将其发送到底部）和`display: table-header-group`（将其发送到`display:
    table-caption`下方的项目）。然而，尽管这种技术很强大，但这是一个幸运的意外，而不是这些设置的真正意图。'
- en: However, Flexbox has visual source re-ordering built in. Let's have a look at
    how it works.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Flexbox内置了视觉源重新排序。让我们看看它是如何工作的。
- en: 'Consider this markup:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个标记：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see here that the third item within the wrapper has a HTML class of
    `FlexContent`—imagine that this `div` is going to hold the main content for the
    page.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到包装器中的第三个项目具有`FlexContent`的HTML类-想象一下这个`div`将保存页面的主要内容。
- en: OK, let's keep things simple. We will add some simple colors to more easily
    differentiate the sections and just get these items one under another in the same
    order they appear in the markup.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们保持简单。我们将为更容易区分各个部分添加一些简单的颜色，并使这些项目按照它们在标记中出现的顺序一个接一个地排列。
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That renders in the browser like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现如下：
- en: '![Changing source order](img/B03777_03_16.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![更改源顺序](img/B03777_03_16.jpg)'
- en: 'Now, suppose we want to switch the order of `.FlexContent` to be the first
    item, without touching the markup. With Flexbox it''s as simple as adding a single
    property/value pair:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要交换`.FlexContent`的顺序成为第一项，而不改变标记。使用Flexbox很简单，只需添加一个属性/值对：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `order` property lets us revise the order of items within a Flexbox simply
    and sanely. In this example, a value of `-1` means that we want it to be before
    all the others.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`order`属性让我们简单而明智地修改Flexbox中项目的顺序。在这个例子中，值为`-1`表示我们希望它在所有其他项目之前。'
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to switch items around quite a bit, I'd recommend being a little
    more declarative and add an order number for each. This makes things a little
    easier to understand when you combine them with media queries.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想频繁切换项目的顺序，我建议更加声明性地为每个添加一个顺序号。当您将它们与媒体查询结合使用时，这样做会使事情变得更容易理解。
- en: Let's combine our new source order changing powers with some media queries to
    produce not just a different layout at different sizes but different ordering.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的新源顺序更改功能与一些媒体查询结合起来，以在不同尺寸下产生不同的布局和不同的顺序。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: you can view this finished example at `example_03-09`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在`example_03-09`中查看此完成的示例。
- en: 'As it''s generally considered wise to have your main content at the beginning
    of a document, let''s revise our markup to this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通常认为将主要内容放在文档开头是明智的，让我们将标记修改为这样：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First the page content, then our two sidebar areas, then the header and finally
    the footer. As I'll be using Flexbox, we can structure the HTML in the order that
    makes sense for the document, regardless of how things need to be laid out visually.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是页面内容，然后是我们的两个侧边栏区域，然后是页眉，最后是页脚。由于我将使用Flexbox，我们可以按照对文档有意义的顺序来构造HTML，而不管需要如何在视觉上布局。
- en: 'For the smallest screens (outside of any media query), I''ll go with this ordering:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最小的屏幕（在任何媒体查询之外），我将按照这个顺序进行：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Which gives us this in the browser:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这在浏览器中给我们的是这样的：
- en: '![Changing source order](img/B03777_03_12.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![更改源顺序](img/B03777_03_12.jpg)'
- en: 'And then, at a breakpoint, I''m switching to this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在断点处，我切换到这个：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Which gives us this in the browser:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这在浏览器中给我们的是这样的：
- en: '![Changing source order](img/B03777_03_14.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![更改源顺序](img/B03777_03_14.jpg)'
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In that example, the shortcut `flex-flow: row wrap` has been used. That allows
    the flex items to wrap onto multiple lines. It''s one of the poorer supported
    properties, so depending upon how far back support is needed, it might be necessary
    to wrap the content and two side bars in another element.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，使用了快捷方式`flex-flow: row wrap`。这允许flex项目换行到多行。这是支持较差的属性之一，因此，取决于需要多远的支持，可能需要将内容和两个侧边栏包装在另一个元素中。'
- en: Wrapping up Flexbox
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结Flexbox
- en: There are near endless possibilities when using the Flexbox layout system and
    due to its inherent 'flexiness', it's a perfect match for responsive design. If
    you've never built anything with Flexbox before, all the new properties and values
    can seem a little odd and it's sometimes disconcertingly easy to achieve layouts
    that have previously taken far more work. To double-check implementation details
    against the latest version of the specification, make sure you check out [http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flexbox布局系统时有无限的可能性，由于其固有的“灵活性”，它非常适合响应式设计。如果你以前从未使用过Flexbox构建任何东西，所有新的属性和值可能看起来有点奇怪，有时很容易实现以前需要更多工作的布局。要根据最新版本的规范检查实施细节，请确保查看[http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)。
- en: I think you'll love building things with Flexbox.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你会喜欢使用Flexbox构建东西。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Hot on the heels of the Flexible Box Layout Module is the Grid Layout Module
    Level 1: [http://www.w3.org/TR/css3-grid-layout/](http://www.w3.org/TR/css3-grid-layout/).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随灵活盒子布局模块之后的是网格布局模块1级：[http://www.w3.org/TR/css3-grid-layout/](http://www.w3.org/TR/css3-grid-layout/)。
- en: It's relatively immature compared to Flexbox (much like the early history of
    Flexbox, grid layout has already been through some major changes) and as such
    we aren't looking at it in detail here. However, it's definitely one to keep an
    eye on as it promises us even more layout powers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与Flexbox相比，它相对不成熟（就像Flexbox的早期历史一样，网格布局已经经历了一些重大变化），因此我们在这里不会详细讨论它。然而，这绝对是一个值得关注的属性，因为它向我们承诺了更多的布局能力。
- en: Responsive images
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式图片
- en: Serving the appropriate image to users based upon the particulars of their device
    and environment has always been a tricky problem. This problem was highlighted
    with the advent of responsive web design, the very nature of which is to serve
    a single code base to each and every device.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户设备和环境的特点为用户提供适当的图像一直是一个棘手的问题。这个问题在响应式网页设计的出现时就被突显出来，其本质是为每个设备提供单一的代码库。
- en: The intrinsic problem of responsive images
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式图片的固有问题
- en: As an author, you cannot know or plan for every possible device that may visit
    your site now or in the future. Only a browser knows the particulars of the device
    using it (screen size and device capabilities for example) at the moment it serves
    up and renders the content.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 作为作者，你无法知道或计划每个可能访问你网站的设备。只有浏览器知道在它提供和渲染内容时使用它的设备的特点（例如屏幕尺寸和设备功能）。
- en: 'Conversely only the author (you and I) know what versions of an image we have
    at our disposal. For example, we may have three versions of the same image. A
    small, medium, and large: each with increasing dimensions to cover off a host
    of screen size and density eventualities. The browser does not know this. We have
    to tell it.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，只有作者（你和我）知道我们拥有哪些图像的版本。例如，我们可能有同一图像的三个版本。小，中，大：每个版本都有不同的尺寸，以涵盖各种屏幕尺寸和密度的情况。浏览器不知道这一点。我们必须告诉它。
- en: To summarize the conundrum, we have halve of the solution in that we know what
    images we have, and the browser has the other halve of the solution in that the
    browser knows what device is visiting the site and what the most appropriate image
    dimensions and resolution would be.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这个难题，我们知道我们拥有的图像是一半的解决方案，浏览器知道访问网站的设备的特点以及最合适的图像尺寸和分辨率是另一半的解决方案。
- en: How can we tell the browser what images we have at our disposal so that it may
    chose the most appropriate one for the user?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何告诉浏览器我们拥有哪些图像，以便它可以为用户选择最合适的图像？
- en: 'In the first few years of responsive web design, there was no specified way.
    Thankfully, now we have the Embedded Content specification: [https://html.spec.whatwg.org/multipage/embedded-content.html](https://html.spec.whatwg.org/multipage/embedded-content.html).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式网页设计的最初几年，没有指定的方法。幸运的是，现在我们有了嵌入内容规范：[https://html.spec.whatwg.org/multipage/embedded-content.html](https://html.spec.whatwg.org/multipage/embedded-content.html)。
- en: The Embedded Content specification describes ways to deal with the simple resolution
    switching of images (to facilitate a user on a higher resolution screen receiving
    a higher resolution version of images) and 'art direction' situations, for when
    authors want users to see a totally different image, depending upon a number of
    device characteristics (think media queries).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入内容规范描述了处理图像的简单分辨率切换（以便在更高分辨率屏幕上接收图像的更高分辨率版本）和“艺术方向”情况的方法，即作者希望用户根据一些设备特性（比如媒体查询）看到完全不同的图像。
- en: Demonstrating responsive image examples is tricky. It's not possible to appreciate
    on a single screen the different images that could be loaded with a particular
    syntax or technique. Therefore, the examples that follow will be mainly code and
    you'll just have to trust me that's it's going to produce the result you need
    in supporting browsers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 演示响应式图像示例是棘手的。在单个屏幕上无法欣赏到特定语法或技术加载的不同图像。因此，接下来的示例将主要是代码，你只能相信我，它将在支持的浏览器中产生你需要的结果。
- en: Let's look at the two most common scenarios you likely need responsive images
    for. These are switching an image when a different resolution is needed, and changing
    an image entirely depending upon the available viewport space.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可能需要响应式图片的两种最常见情况。这些是在需要不同分辨率时切换图像，以及根据可用的视口空间改变图像。
- en: Simple resolution switching with srcset
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用srcset进行简单的分辨率切换
- en: Let's suppose you have three versions of an image. They all look the same except
    one is a smaller size or resolution intended for smaller viewports, another caters
    for medium size viewports, and finally a larger version covers off every other
    viewport. Here is how we can let the browser know we have these three versions
    available.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有图像的三个版本。它们看起来都一样，只是一个是为较小的视口而设计的较小尺寸或分辨率，另一个是为中等尺寸视口而设计的，最后一个更大的版本适用于其他任何视口。以下是我们如何让浏览器知道我们有这三个版本可用。
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is about as simple as things get with responsive images, so let's ensure
    that syntax makes perfect sense.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是响应式图片中最简单的情况，所以让我们确保语法完全合理。
- en: First of all, the `src` attribute, which you will already be familiar with,
    has a dual role here; it's specifying the small 1x version of the image and it
    also acts as a fallback image if the browser doesn't support the `srcset` attribute.
    That's why we are using it for the small image. This way, older browsers that
    will ignore the `srcset` information will get the smallest and best performing
    image possible.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`src`属性，你可能已经熟悉了，这里有一个双重作用；它指定了图像的小尺寸1x版本，如果浏览器不支持`srcset`属性，它也充当备用图像。这就是为什么我们在小图像上使用它。这样，忽略`srcset`信息的旧浏览器将得到最小且性能最佳的图像。
- en: For browsers that understand `srcset`, with that attribute, we provide a comma-separated
    list of images that the browser can choose from. After the image name (such as
    `scones_medium.jpg`) we issue a simple resolution hint. In this example 1.5x and
    2x have been used but any integer would be valid. For example, 3x or 4x would
    work too (providing you can find a suitably high resolution screen).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于理解`srcset`的浏览器，我们在该属性后提供了一个逗号分隔的图像列表，供浏览器选择。在图像名称（如`scones_medium.jpg`）之后，我们发出了一个简单的分辨率提示。在这个例子中，使用了1.5x和2x，但任何整数都是有效的。例如，3x或4x也可以（只要你能找到适当分辨率的屏幕）。
- en: However, there is an issue here; a device with a 1440px wide, 1x screen will
    get the same image as a 480px wide, 3x screen. That may or may not be the desired
    effect.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里存在一个问题；一个1440像素宽，1x屏幕的设备将得到与480像素宽，3x屏幕相同的图像。这可能是期望的效果，也可能不是。
- en: Advanced switching with srcset and sizes
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用srcset和sizes进行高级切换
- en: 'Let''s consider another situation. In a responsive web design, it wouldn''t
    be uncommon for an image to be the full viewport width on smaller viewports, but
    only half the width of the viewport at larger sizes. The main example in [Chapter
    1](ch01.html "Chapter 1. The Essentials of Responsive Web Design"), *The Essentials
    of Responsive Web Design*, was a typical example of this. Here''s how we can communicate
    these intentions to the browser:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种情况。在响应式网页设计中，图像在较小的视口上可能是整个视口宽度，但在较大的尺寸上可能只有视口宽度的一半。[第1章](ch01.html
    "第1章。响应式网页设计的基本要素")中的主要示例，“响应式网页设计的基本要素”，就是一个典型的例子。以下是我们如何向浏览器传达这些意图的方式：
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inside the image tag we are utilizing `srcset` again. However, this time, after
    specifying the images we are adding a value with a w suffix. This tells the browser
    how wide the image is. In our example we have a 450px wide image (called `scones-small.jpg`)
    and a 900px wide image (called `scones-medium.jpg`). It's important to note this
    `w` suffixed value isn't a 'real' size. It's merely an indication to the browser,
    roughly equivalent to the width in 'CSS pixels'.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像标签内部，我们再次使用`srcset`。然而，这一次，在指定图像之后，我们添加了一个带有w后缀的值。这告诉浏览器图像有多宽。在我们的例子中，我们有一个宽度为450像素的图像（名为`scones-small.jpg`）和一个宽度为900像素的图像（名为`scones-medium.jpg`）。重要的是要注意，这个带有`w`后缀的值并不是一个“真实”的尺寸。它只是对浏览器的一种指示，大致相当于“CSS像素”的宽度。
- en: Tip
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What exactly defines a pixel in CSS? I wondered that myself. Then I found the
    explanation at [http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/)
    and wished I hadn't wondered.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: CSS中究竟是什么定义了像素？我自己也想知道。然后我在[http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/)找到了解释，但后悔了。
- en: This `w` suffixed value makes more sense when we factor in the `sizes` attribute.
    The `sizes` attribute allows us to communicate the intentions for our images to
    the browser. In our preceding example, the first value is equivalent to, "for
    devices that are at least 17em wide, I intend the image to be shown around 100vw
    wide".
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑`sizes`属性时，这个带有`w`后缀的值更有意义。`sizes`属性允许我们向浏览器传达我们图像的意图。在我们之前的例子中，第一个值相当于“对于至少宽度为17em的设备，我打算显示大约100vw宽的图像”。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If some of the units used, such as vh (where 1vh is equal to 1% of the viewport
    height) and vw (where 1vw is equal to 1% of the viewport width) don't make sense,
    be sure to read [Chapter 5](ch05.html "Chapter 5. CSS3 – Selectors, Typography,
    Color Modes, and New Features"), *CSS3 – Selectors, Typography, Color Modes, and
    New Features*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一些使用的单位，比如vh（其中1vh等于视口高度的1%）和vw（其中1vw等于视口宽度的1%）不合理，请务必阅读[第5章](ch05.html "第5章。CSS3
    – 选择器，排版，颜色模式和新特性")，“CSS3 – 选择器，排版，颜色模式和新特性”。
- en: The second part is effectively, "Hi browser, for devices that are at least 40em
    wide, I only intend the image to be shown at 50vw". That may seem a little redundant
    until you factor in DPI (or DPR for Device Pixel Ratio). For example, on a 320px
    wide device with a 2x resolution (effectively requiring a 640px wide image if
    shown at full width) the browser might decide the 900px wide image is actually
    a better match as it's the first option it has for an image that would be big
    enough to fulfill the required size.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分有效地是，“嗨，浏览器，对于至少40em宽的设备，我只打算以50vw的宽度显示图像”。这可能看起来有点多余，直到你考虑DPI（或DPR，设备像素比）。例如，在一个320px宽的设备上，分辨率为2倍（如果以全宽度显示需要640px宽的图像），浏览器可能会决定900px宽的图像实际上更合适，因为它是满足所需尺寸的第一个选项。
- en: Did you say the browser 'might' pick one image over another?
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你说浏览器可能会选择一张图像而不是另一张？
- en: An important thing to remember is that the `sizes` attributes are merely hints
    to the browser. That doesn't necessarily ensure that the browser will always obey.
    This is a good thing. Trust me, it really is. It means that in future, if there
    is a reliable way for browsers to ascertain network conditions, it may choose
    to serve one image over another because it knows things at that point that we
    can't possibly know at this point as the author. Perhaps a user has a setting
    on their device to 'only download 1x images' or 'only download 2x images'; in
    these scenarios the browser can make the best call.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，`sizes`属性只是对浏览器的提示。这并不一定意味着浏览器总是会遵守。这是一件好事。相信我，真的是。这意味着将来，如果浏览器有一种可靠的方式来确定网络条件，它可能会选择提供一张图像而不是另一张，因为在那时它知道的事情我们在这个时候作为作者可能无法知道。也许用户在他们的设备上设置了“只下载1x图像”或“只下载2x图像”的选项；在这些情况下，浏览器可以做出最佳选择。
- en: The alternative to the browser deciding is to use the `picture` element. Using
    this element ensures that the browser serves up the exact image you asked for.
    Let's take a look at how it works.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器决定相反的是使用`picture`元素。使用这个元素可以确保浏览器提供你要求的确切图像。让我们看看它是如何工作的。
- en: Art direction with the picture element
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用picture元素进行艺术指导
- en: 'The final scenario you may find yourself in is one in which you have different
    images that are applicable at different viewport sizes. For example, consider
    our cake based example again from [Chapter 1](ch01.html "Chapter 1. The Essentials
    of Responsive Web Design"), *The Essentials of Responsive Web Design*. Maybe on
    the smallest screens we would like a close up of the scone with a generous helping
    of jam and cream on top. For larger screens, perhaps we have a wider image we
    would like to use. Perhaps it''s a wide shot of a table loaded up with all manner
    of cakes. Finally, for larger viewports still, perhaps we want to see the exterior
    of a cake shop on a village street with people sat outside eating cakes and drinking
    tea (I know, sounds like nirvana, right?). We need three different images that
    are most appropriate at different viewport ranges. Here is how we could solve
    this with `picture`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现自己处于的最后一种情况是，你有不同的图像适用于不同的视口尺寸。例如，再次考虑我们基于蛋糕的例子，来自[第1章](ch01.html "第1章.响应式网页设计的基本原理")，“响应式网页设计的基本原理”。也许在最小的屏幕上，我们想要一个特写的司康饼，上面有大量果酱和奶油。对于更大的屏幕，也许我们有一个更宽的图像想要使用。也许是一张装满各种蛋糕的桌子的全景照。最后，对于更大的视口，也许我们想要看到一个村庄街道上的蛋糕店的外部，人们坐在外面吃蛋糕和喝茶（我知道，听起来像天堂，对吧？）。我们需要三种在不同视口范围内最合适的图像。以下是我们如何使用`picture`解决这个问题的方法：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First of all, be aware that when you use the `picture` element, it is merely
    a wrapper to facilitate other images making their way to the `img` tag within.
    If you want to style the images in any way, it's the `img` that should get your
    attention.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要注意的是，当你使用`picture`元素时，它只是一个包装器，用于方便其他图像进入`img`标签。如果你想以任何方式样式化图像，应该关注的是`img`。
- en: Secondly, the `srcset` attribute here works exactly the same as the previous
    example.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在这里，`srcset`属性的工作方式与前面的示例完全相同。
- en: Thirdly, the `img` tag provides your fallback image and also the image that
    will be displayed if a browser understands picture but none of the media definitions
    match. Just to be crystal clear; do not omit the `img` tag from within a `picture`
    element or things won't end well.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`img`标签提供了你的备用图像，也是如果浏览器理解`picture`但没有匹配的媒体定义时将显示的图像。只是为了非常清楚；不要在`picture`元素内省略`img`标签，否则事情就会变得不好。
- en: The key difference with picture is that we have a `source` tag. Here we can
    use media query style expressions to explicitly tell the browser which asset to
    use in a matching situation. For example, our first one in the preceding example
    is telling the browser, "Hey you, if the screen is at least 30em wide, load in
    the `cake-table.jpg` image instead". As long as conditions match, the browser
    will dutifully obey.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`picture`的关键区别在于我们有一个`source`标签。在这里，我们可以使用媒体查询样式表达式明确告诉浏览器在匹配情况下使用哪个资源。例如，前面示例中的第一个告诉浏览器，“嘿，如果屏幕宽度至少为30em，就加载`cake-table.jpg`图像”。只要条件匹配，浏览器就会忠实地遵守。'
- en: Facilitate new-fangled image formats
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方便新潮的图像格式
- en: 'As a bonus, `picture` also facilitates us providing alternate formats of an
    image. ''WebP'' (more info at [https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/))
    is a newer format that plenty of browsers lack support for ([http://caniuse.com/](http://caniuse.com/)).
    For those that do, we can offer a file in that format and a more common format
    for those that don''t:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个额外的好处，`picture`还可以帮助我们提供图像的其他格式。'WebP'（更多信息请参阅[https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/)）是一种新的格式，许多浏览器不支持（[http://caniuse.com/](http://caniuse.com/)）。对于那些支持的浏览器，我们可以提供该格式的文件，对于不支持的浏览器，我们可以提供更常见的格式：
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Hopefully this is now a little more straightforward. Instead of the `media`
    attribute, we are using `type` (we will do more with the type attribute in [Chapter
    4](ch04.html "Chapter 4. HTML5 for Responsive Web Designs"), *HTML5 for Responsive
    Web Designs*), which, although more typically used to specify video sources (possible
    video source types can be found at [https://html.spec.whatwg.org/multipage/embedded-content.html](https://html.spec.whatwg.org/multipage/embedded-content.html)),
    allows us here to define WebP as the preferred image format. If the browser can
    display it, it will, otherwise it will grab the default one in the `img` tag.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在这已经变得更加简单明了。我们不再使用`media`属性，而是使用`type`（我们将在[第4章](ch04.html "第4章. 响应式Web设计的HTML5")中更多地使用type属性，*响应式Web设计的HTML5*），尽管它更常用于指定视频来源（可能的视频来源类型可以在[https://html.spec.whatwg.org/multipage/embedded-content.html](https://html.spec.whatwg.org/multipage/embedded-content.html)找到），但在这里允许我们定义WebP作为首选图像格式。如果浏览器可以显示它，它将显示，否则它将获取`img`标签中的默认图像。
- en: Tip
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are plenty of older browsers that will never be able to make use of the
    official W3C responsive images. Unless there is a specific reason not to, my advice
    would be to allow the built-in fallback capabilities do their thing. Use a sensibly
    sized fallback image to provide them with a good experience and allow more capable
    devices to enjoy an enhanced experience.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多旧版浏览器永远无法使用官方的W3C响应式图像。除非有特定原因不这样做，我的建议是允许内置的回退功能发挥作用。使用一个合理大小的回退图像为他们提供良好的体验，并允许更有能力的设备享受增强的体验。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've covered a lot of ground in this chapter. We have spent considerable time
    getting acquainted with Flexbox, the most recent, powerful, and now well-supported
    layout technique. We have also covered how we can serve up any number of alternative
    images to our users depending upon the problems we need to solve. By making use
    of `srcset`, `sizes`, and `picture`, our users should always get the most appropriate
    image for their needs, both now and in the future.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。我们花了相当多的时间来熟悉Flexbox，这是最新、最强大、现在也得到了很好支持的布局技术。我们还介绍了如何根据我们需要解决的问题，为我们的用户提供任意数量的替代图像。通过使用`srcset`、`sizes`和`picture`，我们的用户应该始终能够获得最适合他们需求的图像，无论是现在还是将来。
- en: So far we've looked at lots of CSS and some of its emerging possibilities and
    capabilities, but only with responsive images have we looked at more modern markup.
    Let's address that issue next.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看了很多CSS及其一些新兴的可能性和能力，但只有在响应式图像中，我们才看到了更现代的标记。让我们下一步来解决这个问题。
- en: The next chapter is going to be all about HTML5\. What it offers, what's changed
    from the previous version, and for the most part, how we can make best use of
    its new semantic elements to create cleaner, more meaningful HTML documents.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全面介绍HTML5。它提供了什么，与上一个版本相比有什么变化，以及在很大程度上，我们如何最好地利用其新的语义元素来创建更清晰、更有意义的HTML文档。
