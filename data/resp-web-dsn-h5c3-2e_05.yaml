- en: Chapter 5. CSS3 – Selectors, Typography, Color Modes, and New Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。CSS3-选择器、排版、颜色模式和新功能
- en: In the last few years, CSS has enjoyed a raft of new features. Some enable us
    to animate and transform elements, others allow us to create background images,
    gradients, mask and filter effects, and others still allow us to bring SVG elements
    to life.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，CSS已经拥有了许多新功能。一些功能使我们能够对元素进行动画和变换，其他功能允许我们创建背景图像、渐变、蒙版和滤镜效果，还有一些功能允许我们使SVG元素栩栩如生。
- en: 'We will get to all those capabilities in the next few chapters. Firstly I think
    it will be useful to look at some of the fundamentals that have changed in CSS
    in the last few years: how we select elements on the page, the units we can use
    to style and size our elements, and how existing (and future) pseudo-classes and
    pseudo-elements make CSS ever more powerful. We will also look at how we can create
    forks in our CSS code to facilitate the features supported in different browsers.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几章中了解所有这些功能。首先，我认为看一下过去几年中CSS中发生的一些基本变化会很有用：我们如何在页面上选择元素，我们可以使用哪些单位来样式和调整我们的元素，以及现有（和未来）伪类和伪元素如何使CSS变得更加强大。我们还将看看如何在我们的CSS代码中创建分支，以便在不同浏览器中支持不同的功能。
- en: 'In this chapter, we will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The anatomy of a CSS rule (what defines a rule, declaration and property, and
    value pairs)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS规则的解剖（定义规则、声明和属性、值对）
- en: Quick and handy CSS tricks for responsive designs (multiple columns, word wraps,
    truncation/text ellipsis, scrolling areas)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式设计的快速和方便的CSS技巧（多列、换行、截断/文本省略、滚动区域）
- en: Facilitating feature forks in CSS (how to have some rules apply to some browsers
    and other rules apply to others)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CSS中实现功能分支（如何使一些规则适用于一些浏览器，而另一些规则适用于其他浏览器）
- en: How to use sub-string attribute selectors to select HTML elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用子字符串属性选择器选择HTML元素
- en: What nth-based selectors are and how we can use them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于nth的选择器是什么以及我们如何使用它们
- en: What pseudo classes and pseudo elements are (`:empty`, `::before`, `::after`,
    `:target`, `:scope`)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪类和伪元素是什么（`:empty`, `::before`, `::after`, `:target`, `:scope`）
- en: The new selectors in CSS Level 4 Selectors module (`:has`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS Level 4选择器模块中的新选择器（`:has`）
- en: What CSS variables and custom properties are and how to write them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS变量和自定义属性是什么，以及如何编写它们
- en: What the CSS `calc` function is and how to use it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS `calc`函数是什么以及如何使用它
- en: Making use of viewport related units (`vh`, `vw`, `vmin`, and `vmax`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用与视口相关的单位（`vh`、`vw`、`vmin`和`vmax`）
- en: How to make use of web typography with `@font-face`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`@font-face`进行网络排版
- en: RGB and HSL color modes with Alpha transparency
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB和HSL颜色模式与Alpha透明度
- en: No one knows it all
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有人知道所有的东西
- en: No one can know everything. I've been working with CSS for over a decade and
    on a weekly basis I still discover something new in CSS (or rediscover something
    I'd forgotten). As such, I don't feel that trying to know every possible CSS property
    and value permutation is actually a worthy pursuit. Instead, I think it's more
    sensible to develop a good grasp of what's possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人能知道所有的东西。我已经使用CSS工作了十多年，每周我仍然会在CSS中发现一些新东西（或重新发现我已经忘记的东西）。因此，我认为试图了解每种可能的CSS属性和值的排列组合实际上并不值得追求。相反，我认为更明智的做法是掌握可能性。
- en: As such, we are going to concentrate in this chapter on some of the techniques,
    units, and selectors I have found most useful when building responsive web designs.
    I'm hoping you'll then have the requisite knowledge to solve most problems that
    come your way when developing a responsive web design.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将集中讨论一些在构建响应式网页设计时我发现最有用的技术、单位和选择器。我希望你能够掌握解决开发响应式网页设计时遇到的大多数问题所需的知识。
- en: Anatomy of a CSS rule
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS规则的解剖
- en: 'Before exploring some of what CSS3 has to offer, to prevent confusion, let''s
    establish the terminology we use to describe a CSS rule. Consider the following
    example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索CSS3所提供的一些功能之前，为了避免混淆，让我们先确定一下我们用来描述CSS规则的术语。考虑以下示例：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This rule is made up of the selector (`.round`) and then the declaration (`border-radius:
    10px;`). The declaration is further defined by the property (`border-radius:`)
    and the value (`10px;`). Happy we''re on the same page? Great, let''s press on.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '这个规则由选择器（`.round`）和声明（`border-radius: 10px;`）组成。声明进一步由属性（`border-radius:`）和值（`10px;`）定义。我们对此有了共识吗？太好了，让我们继续前进。'
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Remember to check support for your users**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**记得检查用户的支持情况**'
- en: As we delve into CSS3 more and more, don't forget to visit [http://caniuse.com/](http://caniuse.com/),
    if you ever want to know what the current level of browser support is available
    for a particular CSS3 or HTML5 feature. Alongside showing browser version support
    (searchable by feature), it also provides the most recent set of global usage
    statistics from [http://gs.statcounter.com/](http://gs.statcounter.com/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们越来越深入了解CSS3，请不要忘记访问[http://caniuse.com/](http://caniuse.com/)，如果您想了解特定CSS3或HTML5功能的当前浏览器支持水平。除了显示浏览器版本支持（可按功能搜索），它还提供了来自[http://gs.statcounter.com/](http://gs.statcounter.com/)的最新全局使用统计数据。
- en: Quick and useful CSS tricks
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速实用的CSS技巧
- en: In my day-to-day work, I've found I use some CSS3 features constantly and others
    hardly ever. I thought it might be useful to share those I've used most often.
    These are CSS3 goodies that can make life easier, especially in responsive designs.
    They solve problems that used to be minor headaches with relative ease.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的日常工作中，我发现我经常使用一些CSS3功能，而其他一些几乎从不使用。我认为分享我经常使用的那些可能会很有用。这些是CSS3的好东西，可以让生活变得更轻松，特别是在响应式设计中。它们可以相对轻松地解决以前可能是小头疼的问题。
- en: CSS multi-column layouts for responsive designs
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式设计的CSS多列布局
- en: 'Ever needed to make a single piece of text appear in multiple columns? You
    could solve the problem by splitting the content into different markup elements
    and then styling accordingly. However, altering markup for purely stylistic purposes
    is never ideal. The CSS multi-column layout specification describes how we can
    span one or more pieces of content across multiple columns with ease. Consider
    the following markup:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 是否曾经需要使单个文本出现在多个列中？您可以通过将内容拆分为不同的标记元素，然后进行相应的样式设置来解决问题。但是，仅出于样式目的而更改标记永远不是理想的。CSS多列布局规范描述了我们如何轻松地跨越一个或多个内容片段跨越多个列。考虑以下标记：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With CSS multi-columns you can make all that content flow across multiple columns
    in a number of ways. You could make the columns a certain column width (for example,
    12em) or instead you could specify that the content needs to span a certain number
    of columns (for example, 3).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS多列，您可以以多种方式使所有内容跨越多列流动。您可以使列具有特定的列宽（例如12em），或者您可以指定内容需要跨越一定数量的列（例如3列）。
- en: 'Let''s look at the code needed to achieve each of those scenarios. For columns
    of a set width, use the following syntax:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现这些情景所需的代码。对于固定宽度的列，请使用以下语法：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will mean, no matter the viewport size, the content will span across columns
    that are 12em in width. Altering the viewport will adjust the number of columns
    displayed dynamically. You can view this in the browser by looking at `example_05-01`
    (or at the GitHub repository: [https://github.com/benfrain/rwd](https://github.com/benfrain/rwd)).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论视口大小如何，内容都将跨越宽度为12em的列。更改视口将动态调整显示的列数。您可以通过查看`example_05-01`（或GitHub存储库：[https://github.com/benfrain/rwd](https://github.com/benfrain/rwd)）在浏览器中查看此内容。
- en: 'Consider how the page renders on an iPad in portrait orientation (768px wide
    viewport):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下页面在iPad纵向方向（768px宽视口）上的呈现方式：
- en: '![CSS multi-column layouts for responsive designs](img/3777_05_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![CSS多列布局用于响应式设计](img/3777_05_01.jpg)'
- en: 'And then on Chrome in the desktop (approximately 1100px wide viewport):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在Chrome桌面上（大约1100px宽的视口）：
- en: '![CSS multi-column layouts for responsive designs](img/3777_05_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![CSS多列布局用于响应式设计](img/3777_05_02.jpg)'
- en: Simple responsive text columns with minimum work; I like it!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的响应式文本列，工作量最小；我喜欢它！
- en: Fixed columns, variable width
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定列，可变宽度
- en: 'If you''d rather keep a fixed number of columns and vary the width, you can
    write a rule like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢保持固定数量的列并改变宽度，可以编写以下规则：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding a gap and column divider
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加间隙和列分隔符
- en: 'We can take things even further by adding a specified gap for the columns and
    a divider:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以进一步添加指定的列间隙和分隔符：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This gives us a result like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下结果：
- en: '![Adding a gap and column divider](img/3777_05_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![添加间隙和列分隔符](img/3777_05_03.jpg)'
- en: To read the specification on the CSS3 Multi-column Layout Module, visit [http://www.w3.org/TR/css3-multicol/](http://www.w3.org/TR/css3-multicol/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读CSS3多列布局模块的规范，请访问[http://www.w3.org/TR/css3-multicol/](http://www.w3.org/TR/css3-multicol/)。
- en: For the time being, despite being at CR status at the W3C, you'll likely still
    need vendor prefixes on the column declarations for maximum compatibility.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，尽管在W3C的CR状态，但您可能仍需要供应商前缀以获得最大的兼容性。
- en: The only caveat I would place on using CSS multi-column is that for longer spans
    of text it can lead to a flawed user experience. In these instances the user will
    have to scroll up and down the page to read the columns of text, which can become
    a little laborious.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我对使用CSS多列的唯一警告是，对于较长的文本跨度，它可能导致用户体验不佳。在这些情况下，用户将不得不在页面上上下滚动以阅读文本的列，这可能有点繁琐。
- en: Word wrapping
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动换行
- en: How many times have you had to add a big URL into a tiny space and, well, despaired?
    Take a look at [http://rwd.education/code/example_05-04](http://rwd.education/code/example_05-04).
    The problem can also be seen in the following screenshot; notice that the URL
    is breaking out of its allocated space.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您有多少次不得不将一个大URL添加到一个小空间中，然后感到绝望？看一下[http://rwd.education/code/example_05-04](http://rwd.education/code/example_05-04)。问题也可以在以下屏幕截图中看到；请注意，URL正在超出其分配的空间。
- en: '![Word wrapping](img/3777_05_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Word wrapping](img/3777_05_04.jpg)'
- en: 'It''s easy to fix this issue with a simple CSS3 declaration, which as chance
    would have it, also works in older versions of Internet Explorer as far back as
    5.5! Just add:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的CSS3声明很容易解决这个问题，碰巧的是，这也适用于Internet Explorer 5.5以前的旧版本！只需添加：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: to the containing element, which gives an effect as shown in the following screenshot.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到包含元素，效果如下截图所示。
- en: '![Word wrapping](img/3777_05_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Word wrapping](img/3777_05_05.jpg)'
- en: Hey presto, the long URL now wraps perfectly!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，长长的URL现在完美地换行了！
- en: Text ellipsis
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本省略
- en: Text truncation used to be the sole domain of server side technology. Nowadays
    we can do text ellipsis/truncation with CSS alone. Let's consider how.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 文本截断过去是服务器端技术的专属领域。现在我们可以仅使用CSS进行文本省略/截断。让我们来考虑一下。
- en: 'Consider this markup (you can view this example online at `rwd.education/code/ch5/example_05-03/`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个标记（您可以在`rwd.education/code/ch5/example_05-03/`上在线查看此示例）：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But we actually want to truncate the text at 520px wide. So it looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上我们希望将文本截断为520px宽。所以看起来像这样：
- en: '![Text ellipsis](img/3777_05_14.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Text ellipsis](img/3777_05_14.jpg)'
- en: 'Here is the CSS to make that happen:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使其发生的CSS：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can read the specification for the `text-overflow` property at [http://dev.w3.org/csswg/css-ui-3/](http://dev.w3.org/csswg/css-ui-3/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://dev.w3.org/csswg/css-ui-3/](http://dev.w3.org/csswg/css-ui-3/)上阅读有关`text-overflow`属性的规范。
- en: 'Whenever the width of the content exceeds the width defined (the width can
    just as happily be set as a percentage such as 100% if it''s inside a flexible
    container) it will be truncated. The `white-space: no-wrap` property/value pair
    is used to ensure that the content doesn''t wrap inside the surrounding element.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '每当内容的宽度超过定义的宽度时（如果它在一个灵活的容器内，宽度也可以设置为百分比，比如100%），它将被截断。`white-space: no-wrap`属性/值对用于确保内容不会在周围的元素内换行。'
- en: Creating horizontal scrolling panels
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建水平滚动面板
- en: Hopefully you know the kind of thing I mean? Horizontal scrolling panels are
    common on the iTunes store and Apple TV for showing panels of related content
    (movies, albums, and so on). Where there is enough horizontal space, all the items
    are viewable. When space is limited (think mobile devices) the panel is scrollable
    from side to side.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您知道我是什么意思？水平滚动面板在iTunes商店和Apple TV上很常见，用于显示相关内容的面板（电影、专辑等）。当水平空间足够时，所有项目都是可见的。当空间有限时（考虑移动设备），面板可以从一侧滚动到另一侧。
- en: 'The scrolling panels work particularly well on modern Android and iOS devices.
    If you have a modern iOS or Android device to hand, take a look at this next example
    on that, alongside a desktop browser like Safari or Chrome: [http://rwd.education/code/ch5/example_05-02/](http://rwd.education/code/ch5/example_05-02/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动面板在现代Android和iOS设备上特别有效。如果您手头有一部现代iOS或Android设备，请在那上面看看下一个示例，同时在Safari或Chrome等桌面浏览器上查看：[http://rwd.education/code/ch5/example_05-02/](http://rwd.education/code/ch5/example_05-02/)。
- en: 'I''ve created a scrolling panel of the top-grossing films of 2014\. It looks
    something like this on an iPhone:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个2014年票房最高的电影的滚动面板。在iPhone上看起来是这样的：
- en: '![Creating horizontal scrolling panels](img/3777_05_11.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![创建水平滚动面板](img/3777_05_11.jpg)'
- en: I'm actually cheating a little. The key to this technique is the `white-space`
    property, which has actually been around since CSS 2.1 ([http://www.w3.org/TR/CSS2/text.html](http://www.w3.org/TR/CSS2/text.html)).
    However, I'm going to use it alongside the new Flexbox layout mechanism, so hopefully
    you'll indulge me regardless?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我其实有点作弊。这种技术的关键是`white-space`属性，它实际上自CSS 2.1以来就存在了（[http://www.w3.org/TR/CSS2/text.html](http://www.w3.org/TR/CSS2/text.html)）。然而，我打算将它与新的Flexbox布局机制一起使用，所以希望你不介意？
- en: To get the basics of this technique working we just need a wrapper narrower
    than the sum of its contents and to set it's width to auto in the *x* axis. This
    way, it won't scroll if there is enough space but it will if there isn't.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种技术起作用，我们只需要一个比其内容总和更窄的包装器，并在*x*轴上将其宽度设置为自动。这样，如果有足够的空间，它就不会滚动，但如果没有，它就会滚动。
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By using `white-space: nowrap` we are saying ''do not wrap these elements when
    you find white space''. Then to keep everything in a single line, we set all the
    first children of that container to display inline. We''re using `inline-flex`
    here but it could just as easily be inline, `inline-block`, or `inline-table`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '通过使用`white-space: nowrap`，我们在说''当找到空白字符时，不要换行这些元素''。然后为了保持所有内容在一行中，我们将该容器的所有第一个子元素设置为内联显示。我们在这里使用`inline-flex`，但它也可以很容易地是内联、`inline-block`或`inline-table`。'
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**::before and ::after pseudo-elements**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**::before和::after伪元素**'
- en: If viewing the sample code you will notice that the `::before` pseudo element
    is used to display the number of the item. If using pseudo-elements, remember
    that for `::before` or `::after` to display, they must have a content value, even
    if just whitespace. When these pseudo-elements are displayed, they then behave
    like the first and last child of that element respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看示例代码，您会注意到`::before`伪元素用于显示项目的编号。如果使用伪元素，请记住`::before`或`::after`要显示，它们必须有内容值，即使只是空格。当这些伪元素被显示时，它们就会分别像该元素的第一个和最后一个子元素一样行为。
- en: 'To make things a little more aesthetically pleasing I''m going to hide the
    scroll bar where I can. Unfortunately these are browser specific so you will need
    to add these by hand (an Autoprefixer tool won''t add them as they are proprietary
    properties). I''m also going to add touch style inertia scrolling for WebKit browsers
    (typically iOS devices). Now the updated `.Scroll_Wrapper` rule looks like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情看起来更美观，我将尽可能隐藏滚动条。不幸的是，这些是特定于浏览器的，所以您需要手动添加它们（自动添加器工具不会添加它们，因为它们是专有属性）。我还将为WebKit浏览器（通常是iOS设备）添加触摸样式惯性滚动。现在更新的`.Scroll_Wrapper`规则看起来像这样：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Where space is limited, we get a nice scrollable horizontal panel. Otherwise,
    the content just fits.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当空间有限时，我们得到一个漂亮的可滚动水平面板。否则，内容就合适。
- en: There are, however, a couple of caveats to this pattern. Firstly, at the time
    of writing, Firefox has no property that allows you to hide the scroll bars. Secondly,
    older Android devices can't perform horizontal scrolling (no, really). I therefore
    tend to qualify this pattern with the help of feature detection. We'll look at
    how that works next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模式有一些注意事项。首先，在撰写本文时，Firefox没有允许隐藏滚动条的属性。其次，较旧的Android设备无法执行水平滚动（是的，真的）。因此，我倾向于通过特性检测来限定这种模式。我们将看看下面的工作原理。
- en: Facilitating feature forks in CSS
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CSS中实现特性分支
- en: When you're building out a responsive web design, attempting to provide a single
    design that works everywhere, on every device, it's a simple fact that you'll
    frequently encounter situations when features or techniques are not supported
    on certain devices. In these instances you'll likely want to create a fork in
    your CSS; if the browser supports a feature, provide one chunk of code, if they
    don't, they get different code. It's the kind of situation that gets handled by
    `if/else` or `switch` statements in JavaScript.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建响应式网页设计时，试图提供一个在每个设备上都能正常工作的单一设计，一个简单的事实是，您经常会遇到某些设备不支持的功能或技术。在这些情况下，您可能希望在您的CSS中创建一个分支；如果浏览器支持某个功能，则提供一段代码，如果不支持，则提供不同的代码。这是JavaScript中`if/else`或`switch`语句处理的情况。
- en: We currently have two possible approaches. One is entirely CSS based but with
    fewer browser implementations, and the other is only made possible with the help
    of a JavaScript library but enjoys far broader support. Let's consider each in
    turn.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有两种可能的方法。一种完全基于CSS，但浏览器实现较少，另一种只能在JavaScript库的帮助下实现，但支持范围更广。让我们依次考虑每种方法。
- en: Feature queries
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性查询
- en: The native solution to forking code in CSS is to use 'Feature Queries', part
    of the CSS Conditional Rules Module Level 3 ([http://www.w3.org/TR/css3-conditional/](http://www.w3.org/TR/css3-conditional/)).
    However, right now, CSS Conditional Rules lack support in Internet Explorer (as
    of version 11) and Safari (including iOS devices up to iOS 8.1) so support is
    hardly ubiquitous.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中分叉代码的本机解决方案是使用'Feature Queries'，这是CSS条件规则模块3级的一部分（[http://www.w3.org/TR/css3-conditional/](http://www.w3.org/TR/css3-conditional/)）。然而，目前，CSS条件规则在Internet
    Explorer（截至版本11）和Safari（包括iOS设备直到iOS 8.1）中缺乏支持，因此支持几乎不普遍。
- en: 'Feature queries follow a similar syntax to media queries. Consider this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 特性查询遵循与媒体查询类似的语法。考虑这个：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here the styles will only get applied if the browser supports the `flashing-sausages`
    property. I'm quite confident that no browser is ever going to support a `flashing-sausages`
    feature (and if they do, I want full credit) so none of the styles inside the
    `@supports` block will be applied.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的样式只有在浏览器支持`flashing-sausages`属性时才会应用。我非常确信没有浏览器会支持`flashing-sausages`功能（如果他们支持，我希望得到充分的认可），因此`@supports`块内的样式将不会应用。
- en: 'Let''s consider a more practical example. How about we use Flexbox for when
    browsers support it, and fallback to another layout technique when they don''t.
    Consider this example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更实际的例子。如果浏览器支持Flexbox，则使用Flexbox，否则使用其他布局技术。考虑这个例子：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we are defining one block of code for when the browser supports a feature,
    and another lot for when it doesn't. This pattern is fine if the browser supports
    `@supports` (yes, I realise that is confusing) but if it doesn't, it won't apply
    any of those styles.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为浏览器支持某个功能定义了一个代码块，为不支持该功能的情况定义了另一个代码块。如果浏览器支持`@supports`（是的，我意识到这很令人困惑），这种模式是可以的，但如果不支持，将不会应用任何这些样式。
- en: 'If you want to cover off devices that don''t support `@supports`, you''re better
    off writing your default declarations first and then your `@supports` specific
    one after, so that the prior rule will be overruled if support for `@support`
    exists, and the `@support` block will be ignored if the browser doesn''t support
    it. Our prior example could therefore be reworked to:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想覆盖不支持`@supports`的设备，最好先编写默认声明，然后在支持`@support`的声明之后编写特定的声明，这样如果支持`@support`存在，先前的规则将被覆盖，如果浏览器不支持`@support`，则将忽略`@support`块。因此，我们之前的示例可以重新设计为：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Combining conditionals
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合条件
- en: 'You can also combine conditionals. Let''s suppose we only wanted to apply some
    rules if both Flexbox and `pointer: coarse` were supported (in case you missed
    it, we covered the ''pointer'' interaction media feature back in [Chapter 2](ch02.html
    "Chapter 2. Media Queries – Supporting Differing Viewports"), *Media Queries –
    Supporting Differing Viewports*). Here is what that might look like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '您还可以结合条件。假设我们只想在支持Flexbox和`pointer: coarse`的情况下应用一些规则（如果您错过了，我们在[第2章](ch02.html
    "第2章。媒体查询-支持不同的视口")中介绍了''pointer''交互媒体特性，*媒体查询-支持不同的视口*）。可能会是这样：'
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here we have used the `and` keyword but we could use `or` as well as, or instead
    of it. For example, if we were happy to apply styles if those two prior property/value
    combinations were supported, or 3D transforms were supported:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了`and`关键字，但我们也可以使用`or`，或者用它来代替。例如，如果我们愿意在支持前两个属性/值组合或支持3D变换时应用样式：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note in that prior example, the extra set of parenthesis that separates the
    flex and pointer conditional from the transform conditional.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上一个示例中，额外的括号将灵活和指针条件与变换条件分开。
- en: Sadly, as I already mentioned, support for `@support` is far from universal.
    Boohoo! What's a responsive web designer to do? Fear not, there's a great JavaScript
    tool that is more than capable of rising to this challenge.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如我之前提到的，对`@support`的支持远非普遍。哎呀！一个响应式网页设计师该怎么办？不要担心，有一个很棒的JavaScript工具完全能够应对这一挑战。
- en: Modernizr
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Modernizr
- en: Until `@supports` is more widely implemented in browsers, we can use a JavaScript
    tool called Modernizr. At present, it's simply the most robust manner in which
    to facilitate forks in your code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@supports`在浏览器中得到更广泛实现之前，我们可以使用一个名为Modernizr的JavaScript工具。目前，这是促进代码分叉的最健壮的方式。
- en: When forks are needed in CSS, I try and adopt a progressive enhancement approach.
    Progressive enhancement means starting with simple accessible code; code that
    will provide, at the very least, a functional design for less capable devices.
    Then that code is progressively enhanced for more capable devices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当在CSS中需要分叉时，我尝试采用渐进增强方法。渐进增强意味着从简单的可访问代码开始；至少为功能较弱的设备提供功能设计的代码。然后逐渐增强更强大的设备的代码。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We'll talk a lot more about progressive enhancement in [Chapter 10](ch10.html
    "Chapter 10. Approaching a Responsive Web Design"), *Approaching a Responsive
    Web Design*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](ch10.html "第10章。接近响应式网页设计")中更详细地讨论渐进增强，*接近响应式网页设计*。
- en: Let's look how we can facilitate progressive enhancement and forking our CSS
    code with Modernizr.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Modernizr来促进渐进增强和分叉我们的CSS代码。
- en: Feature detection with Modernizr
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Modernizr进行特性检测
- en: 'If you''re a web developer, it''s likely you have heard of Modernizr, even
    if you have perhaps not used it. It''s a JavaScript library that you include in
    your page that feature tests the browser. To start using Modernizr, it''s as simple
    as including a link to the downloaded file in the `head` section of your pages:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Web开发人员，很可能已经听说过Modernizr，即使您可能尚未使用它。这是一个JavaScript库，您可以在页面中包含它来对浏览器进行特性测试。要开始使用Modernizr，只需在页面的`head`部分包含指向下载文件的链接即可：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With that in place, when the browser loads the page, any of the included tests
    are run. If the browser passes the test, Modernizr handily (for our purposes)
    adds a relevant class to the root HTML tag.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，当浏览器加载页面时，任何包含的测试都会运行。如果浏览器通过了测试，Modernizr会方便地（对我们的目的）向根HTML标签添加相关的类。
- en: 'For example, after Mondernizr has done its thing, the classes on the HTML tag
    for a page might look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Mondernizr完成其任务后，页面的HTML标签上的类可能如下所示：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In that instance just a few features have been tested: animations, transforms,
    SVG, inline SVG, and support for touch. With those classes in place, the code
    can be forked like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只测试了一些功能：动画，变换，SVG，内联SVG和对触摸的支持。有了这些类，代码可以被分叉，就像这样：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, the widget item is just 1rem high ordinarily, but
    if the touch class is present on the HTML (thanks to Modernizr), then the widget
    would be 2rem high.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，小部件项目通常只有1rem高，但如果HTML上存在触摸类（感谢Modernizr），那么小部件将有2rem高。
- en: 'We could flip the logic too:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以改变逻辑：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This way we would default to the item being 2rem high, and adjust down if the
    `no-touch` class was present.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将默认为项目高度为2rem，并在出现`no-touch`类时调整高度。
- en: Whichever way you want to structure things, Modernizr provides a widely supported
    way to fork features. You'll find it especially useful when you want to use features
    like `transform3d` but still provide a working substitute for browsers that can't
    make use of it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您想如何构造结构，Modernizr都提供了一种广泛支持的方式来分叉功能。当您想要使用`transform3d`等功能但仍为无法使用它的浏览器提供一个可用的替代品时，您会发现它特别有用。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Modernizr can provide accurate tests for most things you'll likely need to fork
    code on, but not all. For example, overflow-scrolling is notoriously difficult
    to accurately test for. In situations where a class of devices isn't playing happily,
    it may make more sense to fork your code on a different feature. For example,
    as older Android versions have difficulty with horizontal scrolling you might
    fork with `no-svg` (as Android 2-2.3 doesn't support SVG either).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Modernizr可以为您可能需要在其上分叉代码的大多数事物提供准确的测试，但并非所有事物都是如此。例如，溢出滚动通常很难进行准确测试。在设备类别不愉快的情况下，可能更有意义的是在不同的功能上分叉您的代码。例如，由于旧版Android版本难以进行水平滚动，您可能会使用`no-svg`进行分叉（因为Android
    2-2.3也不支持SVG）。
- en: Finally, you may wish to combine tests to make your own custom test. That's
    a little outside the scope here but if that's something that interests you, take
    a look at [http://benfrain.com/combining-modernizr-tests-create-custom-convenience-forks/](http://benfrain.com/combining-modernizr-tests-create-custom-convenience-forks/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能希望结合测试来创建自己的自定义测试。这有点超出了这里的范围，但如果这是您感兴趣的事情，请查看[http://benfrain.com/combining-modernizr-tests-create-custom-convenience-forks/](http://benfrain.com/combining-modernizr-tests-create-custom-convenience-forks/)。
- en: New CSS3 selectors and how to use them
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的CSS3选择器及其使用方法
- en: CSS3 gives incredible power for selecting elements within a page. You may not
    think this sounds very glitzy but trust me, it will make your life easier and
    you'll love CSS3 for it! I'd better qualify that bold claim.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3为在页面内选择元素提供了令人难以置信的能力。您可能认为这听起来并不那么花哨，但相信我，它会让您的生活变得更轻松，您会喜欢CSS3的！我最好对这个大胆的说法进行限定。
- en: CSS3 attribute selectors
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS3属性选择器
- en: 'You''ve probably used CSS attribute selectors to create rules. For example,
    consider the following rule:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经使用CSS属性选择器创建规则。例如，考虑以下规则：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This would target any image tags in the markup which have an `alt` attribute.
    Or, let''s say we wanted to select all elements with a `data-sausage` attribute:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将针对标记中具有`alt`属性的任何图像标记。或者，假设我们想选择所有具有`data-sausage`属性的元素：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All you need is to specify the attribute in squared brackets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要在方括号中指定属性。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `data-*` type attribute was introduced in HTML5 to provide a place for custom
    data that can't be stored sensibly by any other existing mechanism. The specification
    description for these can be found at [http://www.w3.org/TR/2010/WD-html5-20101019/elements.html](http://www.w3.org/TR/2010/WD-html5-20101019/elements.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-*`类型的属性是在HTML5中引入的，用于提供一个无法通过任何其他现有机制合理存储的自定义数据的位置。这些的规范描述可以在[http://www.w3.org/TR/2010/WD-html5-20101019/elements.html](http://www.w3.org/TR/2010/WD-html5-20101019/elements.html)找到。'
- en: 'You can also narrow things down by specifying what the attribute value is.
    For example, consider the following rule:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过指定属性值来缩小范围。例如，考虑以下规则：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This would only target images which have an `alt` attribute of `sausages`.
    For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅针对具有`alt`属性为`sausages`的图像。例如：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So far, so 'big deal we could do that in CSS2'. What does CSS3 bring to the
    party?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这听起来像是“我们在CSS2中也可以做到这一点”。CSS3给派对带来了什么？
- en: CSS3 substring matching attribute selectors
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS3子字符串匹配属性选择器
- en: 'CSS3 lets us select elements based upon the substring of their attribute selector.
    That sounds complicated. It isn''t! The three options are whether the attribute
    is:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3让我们根据其属性选择器的子字符串选择元素。听起来很复杂。其实不是！这三个选项是属性是否：
- en: Beginning with the prefix
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前缀开始
- en: Contains an instance of
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个实例
- en: Ends with the suffix
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以后缀结束
- en: Let's see what they look like.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们是什么样子的。
- en: The 'beginning with' substring matching attribute selector
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “以...开始”的子字符串匹配属性选择器
- en: 'Consider the following markup:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下标记：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can use the ''beginning with'' substring matching attribute selector to
    select both of those images like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“以...开始”的子字符串匹配属性选择器来选择这两个图像，就像这样：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The key character in all this is the `^` symbol (the symbol is called the **caret**,
    although it is often referred to as the 'hat' symbol too) which means "begins
    with". Because both `alt` tags begin with `film` our selector selects them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些中的关键字符都是`^`符号（该符号称为**caret**，尽管它也经常被称为“帽子”符号），意思是“以...开始”。因为两个`alt`标签都以`film`开头，我们的选择器选择了它们。
- en: The 'contains an instance of' substring matching attribute selector
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “包含一个实例”的子字符串匹配属性选择器
- en: 'The ''contains an instance of'' substring matching attribute selector has the
    following syntax:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '''包含一个实例''子字符串匹配属性选择器的语法如下：'
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Like all attribute selectors, you can combine them with a type selector (one
    that references the actual HTML element used) if needed, although personally I
    would only do that if I had to (in case you want to change the type of element
    used).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有属性选择器一样，如果需要，您可以将它们与类型选择器（引用实际使用的HTML元素）结合使用，尽管个人认为只有在必要时才这样做（以防您想要更改所使用的元素类型）。
- en: 'Let''s try an example. Consider this markup:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试一个例子。考虑这个标记：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The key character in all this is the `*` symbol that in this context means "contains".
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些中的关键字符是`*`符号，在这种情况下表示“包含”。
- en: The 'begins with' selector would not have worked in with this markup as the
    string inside the attribute didn't *begin with* 'cream'. It did however *contain*
    'cream' so the 'contains an instance of' substring attribute selector finds it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '''以...开头''选择器在这个标记中不起作用，因为属性中的字符串并没有以''cream''开头。但它确实*包含* ''cream''，因此''包含一个实例''子字符串属性选择器找到了它。'
- en: The 'ends with' substring matching attribute selector
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '''以...结尾''子字符串匹配属性选择器'
- en: 'The "ends with" substring matching attribute selector has the following syntax:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: “以...结尾”子字符串匹配属性选择器的语法如下：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'An example should help. Consider this markup:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子应该有所帮助。考虑这个标记：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Suppose we only want to select the element with scones, cream, and jam in the
    `data-ingredients` attribute (the first element). We can't use the 'contains an
    instance of' (it will select all three) or 'begins with' (it will only select
    the last one) substring attribute selector. However, we can use the 'ends with'
    substring attribute selector.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想选择`data-ingredients`属性中包含scones、cream和jam的元素（第一个元素）。我们不能使用'包含一个实例'（它会选择所有三个）或'以...开头'（它只会选择最后一个）子字符串属性选择器。但是，我们可以使用'以...结尾'子字符串属性选择器。
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The key character in all this is the `$` (dollar) symbol which means "ends with".
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些中的关键字符是`$`（美元）符号，表示“以...结尾”。
- en: Gotchas with attribute selection
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性选择的陷阱
- en: 'There is a ''gotcha'' with attribute selection that''s it''s important to grasp:
    attributes are seen as a single string. Consider this CSS rule:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 属性选择中有一个需要理解的“陷阱”：属性被视为单个字符串。考虑这个CSS规则：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It might surprise you to know that it would not select this, even though one
    of the words inside the attribute begins with `film`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 也许让你惊讶的是，它不会选择这个，即使属性中的一个单词以`film`开头：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That's because the `data-film` attribute here doesn't begin with `film`, in
    this case it begins with awful (and if you've seen *Moulin Rouge* you'll know
    that it begins awfully too—and never improves).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这里的`data-film`属性不是以`film`开头的，在这种情况下它是以awful开头的（如果你看过《红磨坊》，你会知道它一开始就很糟糕，而且永远不会好转）。
- en: 'There are a couple of ways around this, in addition to the substring matching
    selectors we looked at a moment ago. You could use the whitespace separated selector
    (note the tilde symbol), which has support all the way back to Internet Explorer
    7:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才看到的子字符串匹配选择器，还有几种解决方法。您可以使用空格分隔选择器（注意波浪线符号），它一直支持到Internet Explorer 7：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You could select the entire attribute:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择整个属性：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or, if you only wanted to select based upon the presence of a couple of strings
    inside an attribute, you could join a couple (or as many as were needed) of ''contains
    an instance of'' substring attribute selectors:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您只想根据属性中的一些字符串的存在来进行选择，您可以连接一对（或者需要的数量）'包含一个实例'子字符串属性选择器：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's no 'right' thing to do, it really just depends on the complexity of
    the string you are trying to select.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面没有“正确”的做法，这实际上取决于您尝试选择的字符串的复杂性。
- en: Attribute selectors allow you to select IDs and classes that start with numbers
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性选择器允许您选择以数字开头的ID和类
- en: Before HTML5, it wasn't valid markup to start IDs or class names with a number.
    HTML5 removes that restriction. When it comes to IDs, there are still some things
    to remember. There should be no spaces in the ID name and it must be unique on
    the page. For more information visit [http://www.w3.org/html/wg/drafts/html/master/dom.html](http://www.w3.org/html/wg/drafts/html/master/dom.html).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5之前，以数字开头的ID或类名是无效的标记。HTML5取消了这一限制。在涉及ID时，仍然有一些事情需要记住。ID名称中不应该有空格，并且在页面上必须是唯一的。有关更多信息，请访问[http://www.w3.org/html/wg/drafts/html/master/dom.html](http://www.w3.org/html/wg/drafts/html/master/dom.html)。
- en: Now, although you can start ID and class values with numbers in HTML5, CSS still
    restricts you from using ID and class selectors that start with a number ([http://www.w3.org/TR/CSS21/syndata.html](http://www.w3.org/TR/CSS21/syndata.html)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在HTML5中可以以数字开头命名ID和类值，但CSS仍限制您不能使用以数字开头的ID和类选择器（[http://www.w3.org/TR/CSS21/syndata.html](http://www.w3.org/TR/CSS21/syndata.html)）。
- en: Lucky for us, we can easily workaround this by using an attribute selector.
    For example, `[id="10"]`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过使用属性选择器轻松解决这个问题。例如，`[id="10"]`。
- en: CSS3 structural pseudo-classes
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS3结构伪类
- en: CSS3 gives us more power to select elements based upon where they sit in the
    structure of the DOM.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3使我们能够更有力地选择基于DOM结构的元素。
- en: Let's consider a common design treatment; we're working on the navigation bar
    for a larger viewport and we want to have all but the last link over on the left.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个常见的设计处理；我们正在为较大的视口设计导航栏，并且希望除了最后一个链接之外的所有链接都在左侧。
- en: 'Historically, we would have needed to solve this problem by adding a class
    name to the last link so that we could select it, like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，我们需要通过向最后一个链接添加类名来解决这个问题，以便我们可以选择它，就像这样：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This in itself can be problematic. For example, sometimes, just getting a content
    management system to add a class to a final list item can be frustratingly difficult.
    Thankfully, in those eventualities, it's no longer a concern. We can solve this
    problem and many more with CSS3 structural pseudo-classes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身可能会有问题。例如，有时，让内容管理系统向最后一个列表项添加类可能会非常困难。幸运的是，在这种情况下，这不再是一个问题。我们可以使用CSS3结构伪类来解决这个问题以及许多其他问题。
- en: The :last-child selector
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: :last-child选择器
- en: 'CSS 2.1 already had a selector applicable for the first item in a list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 2.1已经有了一个适用于列表中第一项的选择器：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, CSS3 adds a selector that can also match the last:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CSS3添加了一个选择器，也可以匹配最后一个：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s look how that selector could fix our prior problem:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那个选择器如何解决我们之前的问题：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are also useful selectors for when something is the only item: `:only-child`
    and the only item of a type: `:only-of-type`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些有用的选择器，用于当某物是唯一的项目时：`:only-child`和唯一的类型：`:only-of-type`。
- en: The nth-child selectors
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nth-child选择器
- en: The `nth-child` selectors let us solve even more difficult problems. With the
    same markup as before, let's consider how nth-child selectors allow us to select
    any link(s) within the list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`nth-child`选择器让我们解决更困难的问题。使用与之前相同的标记，让我们考虑一下nth-child选择器如何允许我们选择列表中的任何链接。'
- en: 'Firstly, what about selecting every other list item? We could select the odd
    ones like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择每隔一个列表项怎么样？我们可以这样选择奇数项：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or, if you wanted to select the even ones:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想选择偶数：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Understanding what nth rules do
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解nth规则的作用
- en: For the uninitiated, nth-based selectors can look pretty intimidating. However,
    once you've mastered the logic and syntax you'll be amazed what you can do with
    them. Let's take a look.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，基于nth的选择器可能看起来很吓人。然而，一旦你掌握了逻辑和语法，你会惊讶于你可以用它们做什么。让我们来看看。
- en: 'CSS3 gives us incredible flexibility with a few nth-based rules:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3用几个基于nth的规则给了我们令人难以置信的灵活性：
- en: '`nth-child(n)`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nth-child(n)`'
- en: '`nth-last-child(n)`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nth-last-child(n)`'
- en: '`nth-of-type(n)`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nth-of-type(n)`'
- en: '`nth-last-of-type(n)`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nth-last-of-type(n)`'
- en: 'We''ve seen that we can use (odd) or (even) values already in an nth-based
    expression but the (n) parameter can be used in another couple of ways:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到在基于nth的表达式中可以使用（奇数）或（偶数）值，但（n）参数还可以以另外两种方式使用：
- en: As an integer; for example, `:nth-child(2)` would select the second item
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为整数；例如，`:nth-child(2)`将选择第二个项目
- en: As a numeric expression; for example, `:nth-child(3n+1)` would start at 1 and
    then select every third element
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数字表达式；例如，`:nth-child(3n+1)`将从1开始，然后选择每三个元素
- en: The integer based property is easy enough to understand, just enter the element
    number you want to select.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 整数属性很容易理解，只需输入您想要选择的元素编号。
- en: The numeric expression version of the selector is the part that can be a little
    baffling for mere mortals. If math is easy for you, I apologize for this next
    section. For everyone else, let's break it down.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器的数字表达式版本对于普通人来说可能有点令人困惑。如果数学对你来说很容易，我为这一部分道歉。对于其他人，让我们来分解一下。
- en: Breaking down the math
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解数学
- en: 'Let''s consider 10 spans on a page (you can play about with these by looking
    at `example_05-05`):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑页面上的10个span（您可以通过查看`example_05-05`来玩弄这些）：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'By default they will be styled like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它们的样式将是这样的：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you might imagine, this gives us 10 squares in a line:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，这给了我们一行中的10个方块：
- en: '![Breaking down the math](img/3777_05_06.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![分解数学](img/3777_05_06.jpg)'
- en: OK, let's look at how we can select different ones with nth-based selections.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看如何使用基于nth的选择来选择不同的项目。
- en: 'For practicality, when considering the expression within the parenthesis, I
    start from the right. So, for example, if I want to figure out what (2n+3) will
    select, I start with the right-most number (the three here indicates the third
    item from the left) and know it will select every second element from that point
    on. So adding this rule:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实用性，当考虑括号内的表达式时，我从右边开始。所以，例如，如果我想弄清楚(2n+3)会选择什么，我从最右边的数字开始（这里的三表示从左边数第三个项目），并且知道它将从那一点开始选择每第二个元素。因此添加这个规则：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Results in this in the browser:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中的结果：
- en: '![Breaking down the math](img/3777_05_07.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![分解数学](img/3777_05_07.jpg)'
- en: As you can see, our nth selector targets the third list item and then every
    subsequent second one after that too (if there were 100 list items, it would continue
    selecting every second one).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的nth选择器目标是第三个列表项，然后是之后的每第二个列表项（如果有100个列表项，它将继续选择每第二个列表项）。
- en: How about selecting everything from the second item onwards? Well, although
    you could write `:nth-child(1n+2)`, you don't actually need the first number 1
    as unless otherwise stated, n is equal to 1\. We can therefore just write `:nth-child(n+2)`.
    Likewise, if we wanted to select every third element, rather than write `:nth-child(3n+3)`,
    we can just write `:nth-child(3n)` as every third item would begin at the third
    item anyway, without needing to explicitly state it. The expression can also use
    negative numbers, for example, `:nth-child(3n-2)` starts at -2 and then selects
    every third item.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从第二个项目开始选择所有内容？虽然你可以写成`:nth-child(1n+2)`，但实际上你不需要第一个数字1，因为除非另有说明，n等于1。因此，我们可以只写`:nth-child(n+2)`。同样，如果我们想选择每三个元素，而不是写成`:nth-child(3n+3)`，我们可以只写`:nth-child(3n)`，因为每三个项目都会从第三个项目开始，而不需要明确说明。表达式也可以使用负数，例如，`:nth-child(3n-2)`从-2开始，然后选择每三个项目。
- en: 'You can also change the direction. By default, once the first part of the selection
    is found, the subsequent ones go down the elements in the DOM (and therefore from
    left to right in our example). However, you can reverse that with a minus. For
    example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以更改方向。默认情况下，一旦找到选择的第一部分，随后的选择将沿着DOM中的元素向下（因此在我们的示例中从左到右）。但是，您可以用减号来颠倒这一点。例如：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This example finds the third item again, but then goes in the opposite direction
    to select every two elements (up the DOM tree and therefore from right to left
    in our example):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子再次找到第三个项目，然后沿着相反的方向选择每两个元素（在DOM树中向上，因此在我们的示例中从右到左）：
- en: '![Breaking down the math](img/3777_05_08.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![分解数学](img/3777_05_08.jpg)'
- en: Hopefully, the nth-based expressions are making perfect sense now?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 希望基于nth的表达式现在完全合乎逻辑了？
- en: 'The `nth-child` and `nth-last-child` differ in that the `nth-last-child` variant
    works from the opposite end of the document tree. For example, `:nth-last-child(-n+3)`
    starts at 3 from the end and then selects all the items after it. Here''s what
    that rule gives us in the browser:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`nth-child`和`nth-last-child`的区别在于`nth-last-child`变体是从文档树的相反端起作用的。例如，`:nth-last-child(-n+3)`从末尾开始的3开始，然后选择其后的所有项目。这是浏览器中该规则给我们的内容：'
- en: '![Breaking down the math](img/3777_05_09.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![分解数学](img/3777_05_09.jpg)'
- en: 'Finally, let''s consider `:nth-of-type` and `:nth-last-of-type`. While the
    previous examples count any children regardless of type (always remember the `nth-child`
    selector targets all children at the same DOM level, regardless of classes), `:nth-of-type`
    and `:nth-last-of-type` let you be specific about the type of item you want to
    select. Consider the following markup (`example_05-06`):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑`：nth-of-type`和`：nth-last-of-type`。虽然前面的例子计算任何类型的子元素（始终记住`nth-child`选择器会选择同一DOM级别的所有子元素，而不管类），`：nth-of-type`和`：nth-last-of-type`让您可以具体指定要选择的项目类型。考虑以下标记（`example_05-06`）：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we used the selector:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了选择器：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Even though all the elements have the same `span-class`, we will only actually
    be targeting the `span` elements (as they are the first type selected). Here is
    what gets selected:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有元素都具有相同的`span-class`，但实际上我们只会针对`span`元素（因为它们是首选类型）。这是被选中的内容：
- en: '![Breaking down the math](img/3777_05_10.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![分解数学](img/3777_05_10.jpg)'
- en: We will see how CSS4 selectors can solve this issue shortly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到CSS4选择器如何解决这个问题。
- en: Tip
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**CSS3 doesn''t count like JavaScript and jQuery!**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSS3不像JavaScript和jQuery那样计数！**'
- en: If you're used to using JavaScript and jQuery you'll know that it counts from
    0 upwards (zero index based). For example, if selecting an element in JavaScript
    or jQuery, an integer value of 1 would actually be the second element. CSS3 however,
    starts at 1 so that a value of 1 is the first item it matches.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯使用JavaScript和jQuery，您会知道它从0开始计数（基于零索引）。例如，如果在JavaScript或jQuery中选择元素，整数值1实际上是第二个元素。然而，CSS3从1开始，因此值为1的是它匹配的第一个项目。
- en: nth-based selection in responsive web designs
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式网页设计中的基于nth的选择
- en: Just to close out this little section I want to illustrate a real life responsive
    web design problem and how we can use nth-based selection to solve it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一个真实的响应式网页设计问题，以及我们如何使用基于nth的选择来解决它。
- en: Remember the horizontal scrolling panel from `example_05-02`? Let's consider
    how that might look in a situation where horizontal scrolling isn't possible.
    So, using the same markup, let's turn the top 10 grossing films of 2014 into a
    grid. For some viewports the grid will only be two items wide, as the viewport
    increases we show three items and at larger sizes still we show four. Here is
    the problem though. Regardless of the viewport size, we want to prevent any items
    on the bottom row having a border on the bottom. You can view this code at `example_05-09`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得`example_05-02`中的水平滚动面板吗？让我们考虑一下在水平滚动不可能的情况下它可能会是什么样子。因此，使用相同的标记，让我们将2014年票房前十的电影变成网格。对于某些视口，网格将只有两个项目宽，随着视口的增加，我们显示三个项目，并且在更大的尺寸上，我们仍然显示四个。然而，这里有一个问题。无论视口大小如何，我们都希望防止底部的任何项目具有底部边框。您可以在`example_05-09`中查看此代码。
- en: 'Here is how it looks with four items wide:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是四个宽项目的外观：
- en: '![nth-based selection in responsive web designs](img/3777_05_12.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![响应式网页设计中的基于nth的选择](img/3777_05_12.jpg)'
- en: See that pesky border below the bottom two items? That's what we need to remove.
    However, I want a robust solution so that if there were another item on the bottom
    row, the border would also be removed on that too. Now, because there are a different
    number of items on each row at different viewports, we will also need to change
    the nth-based selection at different viewports. For the sake of brevity, I'll
    show you the selection that matches four items per row (the larger of the viewports).
    You can view the code sample to see the amended selection at the different viewports.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 看到下面两个项目底部的烦人边框了吗？这就是我们需要移除的。但是，我希望有一个强大的解决方案，这样如果底部行还有另一个项目，边框也会被移除。现在，因为在不同的视口上每行的项目数量不同，我们还需要在不同的视口上更改基于nth的选择。为了简洁起见，我将向您展示匹配每行四个项目的选择（较大的视口）。您可以查看代码示例，以查看在不同视口上修改后的选择。
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll notice here that we are chaining the nth-based pseudo-class selectors.
    It's important to understand that the first doesn't filter the selection for the
    next, rather the element has to match each of the selections. For our preceding
    example, the first element has to be the first item of four and also be one of
    the last four.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们在链接基于nth的伪类选择器。重要的是要理解，第一个不会过滤下一个的选择，而是元素必须匹配每个选择。对于我们之前的例子，第一个元素必须是四个中的第一个项目，并且也必须是最后四个中的一个。
- en: Nice! Thanks to nth-based selections we have a defensive set of rules to remove
    the bottom border regardless of the viewport size or number of items we are showing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！由于基于nth的选择，我们有一套防御性规则，可以删除底部边框，而不管视口大小或我们显示的项目数量如何。
- en: '![nth-based selection in responsive web designs](img/3777_05_13.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![响应式网页设计中的基于nth的选择](img/3777_05_13.jpg)'
- en: The negation (:not) selector
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 否定（:not）选择器
- en: 'Another handy selector is the negation pseudo-class selector. This is used
    to select everything that isn''t something else. Consider this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方便的选择器是否定伪类选择器。这用于选择除其他东西之外的所有内容。考虑这个：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And then these styles:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这些样式：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our final rule will make every element with a class of `.a-div` orange and round,
    with the exception the `div` that also has the `.not-me` class. You can find that
    code in the `example_05-07` folder of the code samples (remember, you can grab
    them all at [http://rwd.education/](http://rwd.education/)).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终规则将使具有`.a-div`类的每个元素变为橙色和圆形，但`div`也具有`.not-me`类除外。您可以在代码示例的`example_05-07`文件夹中找到该代码（请记住，您可以在[http://rwd.education/](http://rwd.education/)上找到所有代码示例）。
- en: Tip
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: So far we have looked primarily at what's known as structural pseudo-classes
    (full information on this is available at [http://www.w3.org/TR/selectors/](http://www.w3.org/TR/selectors/)).
    However, CSS3 has many more selectors. If you're working on a web application,
    it's worth looking at the full list of UI element states pseudo-classes ([http://www.w3.org/TR/selectors/](http://www.w3.org/TR/selectors/)),
    as they can, for example, help you target rules based on whether something is
    selected or not.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要看了所谓的结构伪类（关于这方面的完整信息可在[http://www.w3.org/TR/selectors/](http://www.w3.org/TR/selectors/)找到）。然而，CSS3还有许多其他选择器。如果你正在开发一个Web应用程序，值得查看完整的UI元素状态伪类列表（[http://www.w3.org/TR/selectors/](http://www.w3.org/TR/selectors/)），因为它们可以帮助你根据某些东西是否被选中来定位规则。
- en: The empty (:empty) selector
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空的(:empty)选择器
- en: 'I''ve encountered situations where I have an element that includes some padding
    on the inside and gets content dynamically inserted. Sometimes it gets content,
    sometimes it doesn''t. The trouble is, when it doesn''t include content, I still
    see the padding. Consider the HTML and CSS in `example_05-08`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到过这样的情况，我有一个元素，在里面包含一些填充，并且动态插入内容。有时它会有内容，有时没有。问题是，当它不包含内容时，我仍然看到填充。考虑一下`example_05-08`中的HTML和CSS：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Without anything content in that `div` I still see the `background-color`.
    Thankfully, we can easily hide it like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个`div`中没有任何内容，我仍然看到`background-color`。幸运的是，我们可以很容易地隐藏它，就像这样：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, just be careful with the `:empty` selector. For example, you might
    think this is empty:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要小心`:empty`选择器。例如，你可能认为这是空的：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It isn't! Look at the whitespace in there. Whitespace is not no space!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 不是！看看里面的空白。空白不是没有空间！
- en: 'However, just to confuse matters, be aware that a comment doesn''t affect whether
    an element has whitespace or not. For example, this is still considered empty:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要让事情更加混乱，要知道评论不会影响元素是否有空白或不。例如，这仍然被认为是空的：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Amendments to pseudo-elements**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪元素的修正**'
- en: Pseudo-elements have been around since CSS2 but the CSS3 specification revises
    the syntax of their use very slightly. To refresh your memory, until now, `p:first-line`
    would target the first line in a `<p>` tag. Or `p:first-letter` would target the
    first letter. Well, CSS3 asks us to separate these pseudo-elements with a double
    colon to differentiate them from pseudo-classes (such as `nth-child()`). Therefore,
    we should write `p::first-letter` instead. Note, however, that Internet Explorer
    8 and lower versions don't understand the double colon syntax, they only understand
    the single colon syntax.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 伪元素自CSS2以来就存在，但CSS3规范对它们的使用语法进行了非常轻微的修订。为了提醒你，直到现在，`p:first-line`会定位`<p>`标签中的第一行。或者`p:first-letter`会定位第一个字母。然而，CSS3要求我们用双冒号来区分这些伪元素和伪类（比如`nth-child()`）。因此，我们应该写成`p::first-letter`。然而，需要注意的是，Internet
    Explorer 8及更低版本不理解双冒号语法，它们只理解单冒号语法。
- en: Do something with the :first-line regardless of viewport
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无论视口如何，都对`:first-line`做一些事情
- en: 'One thing that you may find particularly handy about the `:first-line` pseudo-element
    is that it is specific to the viewport. For example, if we write the following
    rule:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`:first-line`伪元素，你可能会发现一个特别方便的地方是它是特定于视口的。例如，如果我们写下以下规则：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you might expect, the first line is rendered in an awful shade of pink. However,
    on a different viewport, it renders a different selection of text.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，第一行呈现为一种可怕的粉色。然而，在不同的视口上，它呈现为不同的文本选择。
- en: So, without needing to alter the markup, with a responsive design, there's a
    handy way of having the first visual line of text (as the browser renders it,
    not as it appears in the markup) appear differently than the others.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不需要改变标记，使用响应式设计，有一种方便的方法可以使文本的第一行（如浏览器呈现的，而不是在标记中显示的）与其他行不同。
- en: CSS custom properties and variables
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS自定义属性和变量
- en: Thanks to the popularity of CSS pre-processors, CSS is starting to gain some
    more 'programmatic' features. The first of which is custom properties. They are
    more often referred to as variables although that is not necessarily their only
    use case. You can find the full specification at [http://dev.w3.org/csswg/css-variables/](http://dev.w3.org/csswg/css-variables/).
    Be warned, as of early 2015, browser implementations are few and far between (only
    Firefox).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSS预处理器的流行，CSS开始获得一些更多的“编程”特性。其中之一是自定义属性。它们更常被称为变量，尽管这不一定是它们唯一的用例。你可以在[http://dev.w3.org/csswg/css-variables/](http://dev.w3.org/csswg/css-variables/)找到完整的规范。需要警告的是，截至2015年初，浏览器实现还很少（只有Firefox）。
- en: 'CSS custom properties allow us to store information in our style sheets that
    can then be utilized in that style sheet or perhaps acted upon with JavaScript.
    An obvious use case would be to store a font-family name and then reference it.
    Here is how we create a custom property:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: CSS自定义属性允许我们在样式表中存储信息，然后可以在该样式表中利用或者通过JavaScript进行操作。一个明显的用例是存储字体系列名称，然后引用它。以下是我们创建自定义属性的方法：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we are using the `:root` pseudo-class to store the custom property in
    the document root (although you can store them inside any rule you like).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`:root`伪类将自定义属性存储在文档根中（尽管你可以将它们存储在任何你喜欢的规则中）。
- en: Tip
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `:root` pseudo-class always references the top-most parent element in a
    document structure. In an HTML document this would always be the HTML tag but
    for an SVG document (we look at SVG in [Chapter 7](ch07.html "Chapter 7. Using
    SVGs for Resolution Independence"), *Using SVGs for Resolution Independence*),
    it would reference a different element.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`:root`伪类总是引用文档结构中最顶层的父元素。在HTML文档中，这总是HTML标签，但对于SVG文档（我们在[第7章](ch07.html "第7章。使用SVG实现分辨率独立性")中看到SVG，*使用SVG实现分辨率独立性*），它将引用不同的元素。'
- en: A custom property always begins with two dashes, then the custom name, and then
    its end, signified like every other property in CSS; with a colon.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义属性总是以两个破折号开始，然后是自定义名称，然后是它的结束，就像CSS中的其他属性一样；用一个冒号表示。
- en: 'We can reference that value with the `var()` notation. Like so:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`var()`符号引用该值。就像这样：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You could obviously store as many custom properties as you need in this manner.
    The main benefit of this approach is that you can change the value inside the
    variable and every rule that makes use of the variable gets the new value without
    having to amend them directly.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你显然可以以这种方式存储尽可能多的自定义属性。这种方法的主要好处是，你可以更改变量内的值，而每个使用该变量的规则都会得到新的值，而无需直接修改它们。
- en: 'It''s envisaged that in future these properties might be parsed and utilized
    by JavaScript. For more on that kind of craziness, you might be interested in
    the new CSS Extensions module:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 预计将来这些属性可能会被JavaScript解析和利用。关于这种疯狂的东西，你可能会对新的CSS扩展模块感兴趣：
- en: '[http://dev.w3.org/csswg/css-extensions/](http://dev.w3.org/csswg/css-extensions/)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://dev.w3.org/csswg/css-extensions/](http://dev.w3.org/csswg/css-extensions/)'
- en: CSS calc
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS calc
- en: 'How many times have you been trying to code out a layout and thought something
    like, "it needs to half the width of the parent element minus exactly 10px"? This
    is particularly useful with responsive web design, as we never know the size of
    the screen that will be viewing our web pages. Thankfully CSS now has a way to
    do this. It''s called the `calc()` function. Here''s that example in CSS:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次试图编写布局并想到类似“它需要是父元素宽度的一半减去10像素”这样的东西？这在响应式网页设计中特别有用，因为我们永远不知道将查看我们网页的屏幕大小。幸运的是，CSS现在有了一种方法来做到这一点。它被称为`calc()`函数。以下是CSS中的示例：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Addition, subtraction, division, and multiplication are supported so it's possible
    to solve a bunch of problems that have been impossible without JavaScript in the
    past.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 加法、减法、除法和乘法都受支持，因此可以解决以前无法使用JavaScript解决的一系列问题。
- en: Browser support is quite good, but a notable exception is Android 4.3 and below.
    Read the specification at [http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器支持相当不错，但一个值得注意的例外是Android 4.3及以下版本。请阅读规范：[http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/)。
- en: CSS Level 4 selectors
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS 4级选择器
- en: There are a number of new selector types being specified for CSS Selectors Level
    4 (the latest version available was the Editor's Draft dated December 14, 2014,
    ([http://dev.w3.org/csswg/selectors-4/](http://dev.w3.org/csswg/selectors-4/)).
    However, as I write this, there are no implementations of them in browsers. As
    such we will just look at one example as they are liable/probable to change.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: CSS选择器4级（最新版本是2014年12月14日的编辑草案，[http://dev.w3.org/csswg/selectors-4/](http://dev.w3.org/csswg/selectors-4/)）中规定了许多新的选择器类型。然而，就在我写这篇文章的时候，浏览器中还没有它们的实现。因此，我们只看一个例子，因为它们可能会发生变化。
- en: The Relational Pseudo-class selector is from the 'Logical Combinations' ([http://dev.w3.org/csswg/selectors-4/](http://dev.w3.org/csswg/selectors-4/))
    section of the latest draft.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 关系伪类选择器来自“逻辑组合”（[http://dev.w3.org/csswg/selectors-4/](http://dev.w3.org/csswg/selectors-4/)）部分的最新草案。
- en: The :has pseudo class
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: :has伪类
- en: 'This selector takes this format:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择器采用这种格式：
- en: '[PRE58]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This would add padding to any item `a` tag that contains a `figcaption`. You
    could invert the selection in combination with the negation pseudo class too:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a`标签包含`figcaption`，这将为任何`a`标签添加填充。你也可以与否定伪类结合来反转选择：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This would add the padding if the `a` tag did not contain a `figcaption` element.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a`标签不包含`figcaption`元素，这将添加填充。
- en: I'll be honest and say that right now, there aren't many new selectors in that
    draft that get me excited. But who knows what they'll come up with by the time
    they start being available to use in browsers?
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我要诚实地说，现在在这份草案中，并没有太多新的选择器让我感到兴奋。但谁知道他们在开始在浏览器中使用之前会想出什么呢？
- en: Responsive viewport-percentage lengths (vmax, vmin, vh, vw)
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式视口百分比长度（vmax、vmin、vh、vw）
- en: 'Let''s change tack now. We''ve looked at how we can select items in our responsive
    world. But how about how we size them? The CSS Values and Units Module Level 3
    ([http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/)), ushered
    in viewport relative units. These are great for responsive web design as each
    unit is a percentage length of the viewport:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们改变一下方向。我们已经看过如何在响应式世界中选择项目。但是如何调整它们的大小呢？CSS值和单位模块3级（[http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/)）引入了视口相关单位。这对于响应式网页设计非常有用，因为每个单位都是视口的百分比长度：
- en: The vw unit (for viewport width)
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vw单位（视口宽度）
- en: vh unit (for viewport height)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vh单位（视口高度）
- en: vmin unit (for viewport minimum; equal to the smaller of either vw or vh)
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vmin单位（视口最小值；等于vw或vh中较小的一个）
- en: vmax (viewport maximum; equal to the larger of either vw or vh)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vmax（视口最大值；等于vw或vh中较大的一个）
- en: Browser support isn't bad either ([http://caniuse.com/](http://caniuse.com/)).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器支持也不错（[http://caniuse.com/](http://caniuse.com/)）。
- en: 'Want a modal window that''s 90% of the browser height? It''s as easy as:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 想要一个模态窗口，它的高度是浏览器高度的90%？这很容易：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Tip
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As useful as viewport relative units are, some browsers have curious implementations.
    Safari in iOS 8, for example, changes the viewable screen area as you scroll from
    the top of a page (it shrinks the address bar) but doesn't make any changes to
    the reported viewport height.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 视口相关单位虽然很有用，但一些浏览器的实现方式很奇怪。例如，iOS 8中的Safari在你从页面顶部滚动时会改变可视屏幕区域（它会缩小地址栏），但不会对报告的视口高度进行任何更改。
- en: However, you can perhaps find more utility for these units when coupled with
    fonts. For example, it's now trivially easy to create text that scales in size
    depending upon the viewport.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当与字体结合时，也许可以找到更多这些单位的实用性。例如，现在可以轻松创建根据视口大小而调整大小的文本。
- en: Now, I could show you that right now. However, I'd like to use a distinct font,
    so that regardless of whether you are viewing the example on a Windows, Mac, or
    Linux box we will all see the same thing.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以立即向你展示。但是，我想使用一个不同的字体，这样无论你是在Windows、Mac还是Linux上查看示例，我们都能看到相同的东西。
- en: OK, I'll be honest, this is a cheap ploy to allow me to document how we can
    use web fonts with CSS3.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我要诚实地说，这是一个廉价的手段，让我记录一下我们如何在CSS3中使用Web字体。
- en: Web typography
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络排版
- en: For years the web has had to make do with a boring selection of 'web safe' fonts.
    When some fancy typography was essential for a design, it was necessary to substitute
    a graphical element for it and used a text-indent rule to shift the actual text
    from the viewport. Oh, the joy!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，网络一直不得不使用一些无聊的“网络安全”字体。当设计中必不可少的一些花哨的排版时，有必要用图形元素替代它，并使用文本缩进规则将实际文本从视口中移开。哦，快乐！
- en: There were also a few inventive methods for adding fancy typography to a page
    along the way. sIFR ([http://www.mikeindustries.com/blog/sifr/](http://www.mikeindustries.com/blog/sifr/))
    and Cufón ([http://cufon.shoqolate.com/generate/](http://cufon.shoqolate.com/generate/))
    used Flash and JavaScript respectively to re-make text elements appear as the
    fonts they were intended to be. Thankfully, CSS3 provides a means of custom web
    typography that is now ready for the big time.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一过程中，还有一些创新的方法可以在页面上添加花哨的排版。sIFR（[http://www.mikeindustries.com/blog/sifr/](http://www.mikeindustries.com/blog/sifr/)）和Cufón（[http://cufon.shoqolate.com/generate/](http://cufon.shoqolate.com/generate/)）分别使用Flash和JavaScript重新制作文本元素，使其显示为它们原本打算的字体。幸运的是，CSS3提供了一种现在已经准备好大放异彩的自定义网络排版的方法。
- en: The @font-face CSS rule
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@font-face CSS规则'
- en: The `@font-face` CSS rule has been around since CSS2 (but subsequently absent
    in CSS 2.1). It was even supported partially by Internet Explorer 4 (no, really)!
    So what's it doing here, when we're supposed to be talking about CSS3?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`@font-face` CSS规则自CSS2以来就存在（但随后在CSS 2.1中消失了）。甚至Internet Explorer 4部分支持它（不是吗）！那么，当我们应该谈论CSS3时，它在这里做什么呢？'
- en: Well, as it turns out, `@font-face` was re-introduced for the CSS3 Fonts module
    ([http://www.w3.org/TR/css3-fonts](http://www.w3.org/TR/css3-fonts)). Due to the
    historic legal quagmire of using fonts on the web, it's only in recent years that
    it has started to gain serious traction as the de facto solution for web typography.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`@font-face`被重新引入到了CSS3字体模块中（[http://www.w3.org/TR/css3-fonts](http://www.w3.org/TR/css3-fonts)）。由于在网络上使用字体的历史法律泥潭，直到最近几年，它才开始作为网络排版的事实解决方案而受到严重关注。
- en: Like anything on the web that involves assets, there is no single file format.
    Just as images can come in JPG, PNG, GIF, and other formats, fonts have their
    own set of formats to choose from. The Embedded OpenType (files with an `.eot`
    extension) font was Internet Explorer's (and not anyone else's) preferred choice.
    Others favor the more common TrueType (`.ttf` file extension), whilst there is
    also SVGs and Web Open Font Format (`.woff` / `.woff2` extension).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 与网页上涉及资产的任何内容一样，没有单一的文件格式。就像图像可以是JPG、PNG、GIF和其他格式一样，字体也有自己的一套可供选择的格式。嵌入式开放类型（扩展名为`.eot`的文件）字体是Internet
    Explorer（而不是其他任何人）的首选。其他人更喜欢更常见的TrueType（`.ttf`文件扩展名），同时还有SVG和Web开放字体格式（`.woff`
    / `.woff2`扩展名）。
- en: Right now, it's necessary to serve multiple file versions of the same font to
    cover the different browser implementations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要为不同的浏览器实现提供相同字体的多个文件版本。
- en: However, the good news is that adding each custom font format for every browser
    is easy. Let's see how!
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，好消息是为每个浏览器添加每种自定义字体格式很容易。让我们看看如何！
- en: Implementing web fonts with @font-face
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@font-face实现网络字体
- en: CSS provides a `@font-face` 'at-rule' to reference online fonts that can then
    be used to display text.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: CSS提供了一个`@font-face`“at-rule”来引用在线字体，然后可以用于显示文本。
- en: There are now a number of great sources for viewing and acquiring web fonts;
    both free and paid. My personal favorite for free fonts is Font Squirrel ([http://www.fontsquirrel.com/](http://www.fontsquirrel.com/))
    although Google also offers free web fonts, ultimately served with the `@font-face`
    rule ([http://www.google.com/webfonts](http://www.google.com/webfonts)). There
    are also great, paid services from Typekit ([http://www.typekit.com/](http://www.typekit.com/))
    and Font Deck ([http://www.fontdeck.com/](http://www.fontdeck.com/)).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有许多查看和获取网络字体的好资源，包括免费和付费的。我个人最喜欢免费字体的是Font Squirrel（[http://www.fontsquirrel.com/](http://www.fontsquirrel.com/)），尽管谷歌也提供免费网络字体，最终使用`@font-face`规则提供（[http://www.google.com/webfonts](http://www.google.com/webfonts)）。还有来自Typekit（[http://www.typekit.com/](http://www.typekit.com/)）和Font
    Deck（[http://www.fontdeck.com/](http://www.fontdeck.com/)）的优秀付费服务。
- en: For this exercise, I'm going to download Roboto. It's the Font used for later
    Android handsets so if you have one of those it will be familiar. Otherwise, all
    you need to know is that it's a lovely interface font designed to be highly legible
    on small screens. You can grab it yourself at [http://www.fontsquirrel.com/fonts/roboto](http://www.fontsquirrel.com/fonts/roboto).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我将下载Roboto。它是后来Android手机使用的字体，所以如果你有其中之一，它会很熟悉。否则，你只需要知道它是一种可爱的界面字体，设计用于在小屏幕上非常易读。你可以在[http://www.fontsquirrel.com/fonts/roboto](http://www.fontsquirrel.com/fonts/roboto)上自己获取它。
- en: Note
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you can download a 'subset' of your font, specific to the language you intend
    to use, do so. It means, the resultant file size will be much smaller as it won't
    contain glyphs for languages you have no intention of using.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以下载特定于您打算使用的语言的字体的“子集”，请这样做。这意味着由于不包含您不打算使用的语言的字形，结果文件大小将小得多。
- en: 'Having downloaded the `@font-face` kit, a look inside the ZIP file reveals
    folders of the different Roboto fonts. I''m choosing the Roboto Regular version
    and inside that folder the font exists in various file formats (WOFF, TTF, EOT,
    and SVG), plus a `stylesheet.css` file containing a font stack. For example, the
    rule for Roboto Regular looks like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 下载了`@font-face`套件后，打开ZIP文件，里面有不同Roboto字体的文件夹。我选择了Roboto Regular版本，在该文件夹中，字体以各种文件格式（WOFF、TTF、EOT和SVG）存在，还有一个包含字体堆栈的`stylesheet.css`文件。例如，Roboto
    Regular的规则如下：
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Much like the way vendor prefixes work, the browser will apply styles from that
    list of properties (with the lower properties, if applicable, taking precedence)
    and ignore ones it doesn't understand. That way, no matter what the browser, there
    should be a font that it can use.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 就像供应商前缀的工作方式一样，浏览器将应用来自该属性列表的样式（如果适用，较低的属性优先），并忽略它不理解的样式。这样，无论使用什么浏览器，都应该有一个可以使用的字体。
- en: 'Now, although this block of code is great for fans of copy and paste, it''s
    important to pay attention to the paths the fonts are stored in. For example,
    I tend to copy the fonts from the ZIP file and store them in a folder inventively
    called `fonts` on the same level as my `css` folder. Therefore, as I''m usually
    copying this font stack rule into my main style sheet, I need to amend the paths.
    So, my rule becomes:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管这段代码对于复制和粘贴的粉丝来说非常棒，但重要的是要注意字体存储的路径。例如，我倾向于从ZIP文件中复制字体并将其存储在一个名为`fonts`的文件夹中，该文件夹与我的`css`文件夹处于同一级别。因此，由于我通常将这个字体堆栈规则复制到我的主样式表中，我需要修改路径。因此，我的规则变成了：
- en: '[PRE62]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It''s then just a case of setting the correct font and weight (if needed) for
    the relevant style rule. Look at `example_05-10`, it''s the same markup as `example_05-09`,
    we are merely declaring this `font-family` as the default:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需设置正确的字体和重量（如果需要）即可为相关的样式规则设置正确的字体。看看`example_05-10`，它与`example_05-09`的标记相同，我们只是将这个`font-family`声明为默认值：
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: An added bonus with web fonts is that, if the composite uses the same fonts
    you are using in the code, you can plug the sizes in direct from the composite
    file. For example, if the font is 24px in Photoshop, we either plug that value
    straight in or convert it to a more flexible unit such as REM (assuming a root
    font-size of 16px, 24 / 16 = 1.5rem).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 网络字体的一个额外好处是，如果合成文件使用与代码中使用的相同字体，您可以直接从合成文件中插入大小。例如，如果Photoshop中的字体大小为24px，我们可以直接插入该值，或者将其转换为更灵活的单位，如REM（假设根字体大小为16px，24/16=1.5rem）。
- en: However, as I mentioned before, we now have viewport relative sizes at our disposal.
    We can use them here to scale the text relative to the amount of viewport space.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我之前提到的，现在我们可以使用视口相对大小。我们可以在这里使用它们，以便根据视口空间的大小来调整文本的大小。
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you open that example in the browser and resize the viewport you will see
    that with just a few lines of CSS we have text that scales to the available space.
    Beautiful!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开该示例并调整视口大小，您会看到只需几行CSS，我们就可以使文本按照可用空间进行缩放。美妙！
- en: A note about custom @font-face typography and responsive designs
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于自定义@font-face排版和响应式设计的说明
- en: The `@font-face` method of web typography is, on the whole, great. The only
    caveats to be aware of when using the technique with responsive designs are in
    relation to the font file size. By way of an example, if the device rendering
    our example required the SVG font format of Roboto Regular, it would need to fetch
    an extra 34 KB, compared with using the standard web-safe fonts such as Arial.
    We have used an English subset in our example which reduces the file size but
    that isn't always an option. Be sure to check the size of custom fonts and be
    judicious with their use if you want the best possible site performance.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 网络排版的`@font-face`方法总体上非常好。在使用响应式设计技术时需要注意的唯一注意事项是字体文件的大小。例如，如果设备需要渲染我们示例的Roboto
    Regular的SVG字体格式，它需要额外获取34 KB，而使用标准的网络安全字体（如Arial）则不需要。我们在示例中使用了英文子集来减小文件大小，但这并不总是一个选项。如果您希望获得最佳的网站性能，请务必检查自定义字体的大小，并谨慎使用。
- en: New CSS3 color formats and alpha transparency
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的CSS3颜色格式和alpha透明度
- en: So far in this chapter, we have looked at how CSS3 has given us new powers of
    selection and the ability to add custom typography to our designs. Now, we'll
    look at ways that CSS3 allows us to work with color that were simply not possible
    before.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到CSS3如何赋予我们新的选择能力，并使我们能够向设计中添加自定义排版。现在，我们将看看CSS3允许我们以前根本不可能的方式处理颜色的方法。
- en: 'Firstly, CSS3 provides two new ways to declare color: RGB and HSL. In addition,
    these two formats enable us to use an alpha channel alongside them (RGBA and HSLA
    respectively).'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，CSS3提供了两种声明颜色的新方法：RGB和HSL。此外，这两种格式使我们能够在它们旁边使用alpha通道（分别为RGBA和HSLA）。
- en: RGB color
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RGB颜色
- en: '**Red, Green, and Blue** (**RGB**) is a coloring system that''s been around
    for decades. It works by defining different values for the red, green, and blue
    components of a color. For example, a red color might be defined in CSS as a HEX
    (hexadecimal) value, `#fe0208`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**红色、绿色和蓝色**（**RGB**）是一个存在几十年的着色系统。它通过为颜色的红色、绿色和蓝色分量定义不同的值来工作。例如，红色可以在CSS中定义为十六进制值`#fe0208`：'
- en: '[PRE65]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Tip
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'For a great post describing how to understand HEX values more intuitively,
    I can recommend this blog post at Smashing Magazine: [http://www.smashingmagazine.com/2012/10/04/the-code-side-of-color/](http://www.smashingmagazine.com/2012/10/04/the-code-side-of-color/)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何更直观地理解十六进制值的出色文章，我可以推荐Smashing Magazine上的这篇博文：[http://www.smashingmagazine.com/2012/10/04/the-code-side-of-color/](http://www.smashingmagazine.com/2012/10/04/the-code-side-of-color/)
- en: 'However, with CSS3, that color can equally be described by an RGB value:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用CSS3，该颜色同样可以用RGB值来描述：
- en: '[PRE66]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Most image editing applications show colors as both HEX and RGB values in their
    color picker. The Photoshop color picker, has R, G, and B boxes showing the values
    for each channel. For example, the R value might be 254, the G value 2, and the
    B value 8\. This is easily transferable to the CSS `color` property value. In
    the CSS, after defining the color mode (for example, RGB) the values for red,
    green, and blue colors are comma separated in that order within parenthesis (as
    we have in the previous code).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图像编辑应用程序在其颜色选择器中以HEX和RGB值显示颜色。例如，Photoshop的颜色选择器显示了R、G和B框，显示了每个通道的值。例如，R值可能是254，G值为2，B值为8。这很容易转换为CSS的`color`属性值。在CSS中，定义颜色模式（例如RGB）后，红色、绿色和蓝色的值以逗号分隔的顺序放在括号内（就像我们在之前的代码中所做的那样）。
- en: HSL color
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HSL颜色
- en: Besides RGB, CSS3 also allows us to declare color values as **Hue, Saturation,
    and Lightness** (**HSL**).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 除了RGB，CSS3还允许我们将颜色值声明为**色调、饱和度和亮度**（**HSL**）。
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**HSL isn''t the same as HSB!**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**HSL不同于HSB！**'
- en: Don't make the mistake of thinking that the **Hue, Saturation, and Brightness**
    (**HSB**) value shown in the color picker of image editing applications such as
    Photoshop is the same as HSL—it isn't!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 不要犯错误认为图像编辑应用程序（如Photoshop）中的颜色选择器中显示的**色调、饱和度和亮度**（**HSB**）值与HSL相同-它并不相同！
- en: What makes HSL such a joy to use is that it's relatively simple to understand
    the color that will be represented based on the values given. For example, unless
    you're some sort of color picking ninja, I'd wager you couldn't instantly tell
    me what color rgb(255, 51, 204) is? Any takers? No, me neither. However, show
    me the HSL value of hsl(315, 100%, 60%) and I could take a guess that it is somewhere
    between Magenta and Red color (it's actually a festive pink color). How do I know
    this? Simple.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: HSL如此令人愉快的原因在于，根据给定的值，很容易理解将表示的颜色。例如，除非你是某种颜色选择忍者，否则我敢打赌你无法立即告诉我rgb(255, 51,
    204)是什么颜色？没有人？我也不知道。然而，告诉我hsl(315, 100％, 60％)的值，我可以猜测它在品红色和红色之间（实际上是一种节日粉色）。我怎么知道的？很简单。
- en: 'HSL works on a 360° degree color wheel. It looks like this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: HSL基于360°的色轮。它看起来像这样：
- en: '![HSL color](img/3777_05_15.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![HSL颜色](img/3777_05_15.jpg)'
- en: The first figure in a HSL color definition represents Hue. Looking at our wheel
    we can see that Yellow is at 60°, Green at 120°, Cyan at 180°, Blue at 240°, Magenta
    at 300°, and finally Red at 360°. So as the aforementioned HSL color had a hue
    of 315, it's easy to know that it will be between Magenta (at 300°) and Red (at
    360°).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: HSL颜色定义中的第一个数字代表色调。从我们的色轮上可以看到，黄色在60°，绿色在120°，青色在180°，蓝色在240°，品红色在300°，最后红色在360°。因此，如上述HSL颜色的色调为315，很容易知道它将在品红色（在300°）和红色（在360°）之间。
- en: The following two values in an HSL definition are for saturation and lightness,
    specified as percentages. These merely alter the base hue. For a more saturated
    or 'colorful' appearance, use a higher percentage in the second value. The final
    value, controlling the Lightness, can vary between 0 percent for black and 100
    percent for white.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: HSL定义中的后两个值是饱和度和亮度，以百分比表示。这些只是改变基本色调。要获得更饱和或“色彩丰富”的外观，请在第二个值中使用更高的百分比。控制亮度的最终值可以在0％至100％之间变化，0％表示黑色，100％表示白色。
- en: 'So, once you''ve defined a color as an HSL value, it''s also easy to create
    variations on it, merely by altering the saturation and lightness percentages.
    For example, our red color can be defined in HSL values as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦您将颜色定义为HSL值，仅通过改变饱和度和亮度百分比就可以轻松创建变化。例如，我们的红色可以用以下HSL值来定义：
- en: '[PRE67]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we wanted to make a slightly darker color, we could use the same HSL value
    and merely alter the lightness (the final value) percentage value only:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要制作稍暗一些的颜色，我们可以使用相同的HSL值，仅改变亮度（最终值）百分比值：
- en: '[PRE68]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In conclusion, if you can remember the mnemonic 'Young Guys Can Be Messy Rascals'
    (or any other mnemonic you care to memorize) for the HSL color wheel, you'll be
    able to approximately write HSL color values without resorting to a color picker,
    and also create variations upon it. Show that trick to the savant Ruby, Node,
    and .NET guys and gals at the office party and earn some quick kudos!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果你能记住“年轻人可以是混乱的顽童”（或者你想记住的任何其他助记符）的话，你就能大致写出HSL颜色值，而不需要使用取色器，并且还可以创建变化。在办公室派对上向Ruby、Node和.NET的聪明人展示这个技巧，赢得一些快速的赞赏吧！
- en: Alpha channels
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Alpha通道
- en: So far you'd be forgiven for wondering why on earth we'd bother using HSL or
    RGB instead of our trusty HEX values we've been using for years. Where HSL and
    RGB differ from HEX is that they allow the use of an alpha transparency channel
    so something beneath an element can 'show through'.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能会想为什么我们要使用HSL或RGB而不是多年来一直在使用的可靠的HEX值。HSL和RGB与HEX的不同之处在于它们允许使用alpha透明通道，因此元素下面的东西可以透过来。
- en: 'An HSLA color declaration is similar in syntax to a standard HSL rule. However,
    in addition, you must declare the value as `hsla` (rather than merely `hsl`) and
    add an additional opacity value, given as a decimal value between 0 (completely
    transparent) and 1 (completely opaque). For example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: HSLA颜色声明在语法上类似于标准的HSL规则。但是，除此之外，您必须将值声明为`hsla`（而不仅仅是`hsl`），并添加一个额外的不透明度值，以十进制值表示，介于0（完全透明）和1（完全不透明）之间。例如：
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The RGBA syntax follows the same convention as the HSLA equivalent:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: RGBA语法遵循与HSLA等效项相同的约定：
- en: '[PRE70]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Tip
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why not just use opacity?**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么不直接使用不透明度？**'
- en: CSS3 also allows elements to have opacity set with the opacity declaration.
    A value is set between 0 and 1 in decimal increments (for example, opacity set
    to .1 is 10 percent). However, this differs from RGBA and HSLA in that setting
    an opacity value on an element effects the entire element. Whereas, setting a
    value with HSLA or RGBA meanwhile allows particular parts of an element to have
    an alpha layer. For example, an element could have an HSLA value for the background
    but a solid color for the text within it.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3还允许使用opacity声明设置元素的不透明度。值在0和1之间以十进制增量设置（例如，设置为0.1的不透明度为10％）。然而，这与RGBA和HSLA不同之处在于，在元素上设置不透明度值会影响整个元素。而使用HSLA或RGBA设置值与此同时允许元素的特定部分具有alpha层。例如，一个元素可以具有背景的HSLA值，但其中的文本为纯色。
- en: Color manipulation with CSS Color Module Level 4
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CSS颜色模块4进行颜色操作
- en: Although in the very early specification stages, it should be possible in the
    not too distant future to enjoy color manipulations in CSS using the `color()`
    function.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在非常早期的规范阶段，但在不久的将来，通过使用`color()`函数在CSS中进行颜色操作应该是可能的。
- en: Until there is wide browser support, this kind of thing is best handled by CSS
    pre/post processors (do yourself a favor and buy yourself a book on the subject
    right now; I recommend *Sass and Compass for Designers* by that wonderful chap,
    Ben Frain).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在有广泛的浏览器支持之前，最好由CSS预处理器/后处理器来处理这种情况（给自己一个忠告，立即买一本关于这个主题的书；我推荐那位了不起的人Ben Frain的《面向设计师的Sass和Compass》）。
- en: You can follow the progress of the CSS Color Module Level 4 at [http://dev.w3.org/csswg/css-color-4/](http://dev.w3.org/csswg/css-color-4/).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://dev.w3.org/csswg/css-color-4/](http://dev.w3.org/csswg/css-color-4/)上关注CSS颜色模块4的进展。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've learned how to easily select almost anything we need
    on the page with CSS3's new selectors. We've also looked at how we can make responsive
    columns and scrolling panels for content in record time and solve common and annoying
    problems such as long URL wrapping. We now also have an understanding of CSS3's
    new color module and how we can apply colors with RGB and HSL complete with transparent
    alpha layers for great aesthetic effects.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学会了如何使用CSS3的新选择器轻松地选择几乎我们在页面上需要的任何东西。我们还看到了如何可以快速制作响应式的列和滚动面板，以解决常见且令人讨厌的问题，比如长URL换行。我们现在也了解了CSS3的新颜色模块，以及如何使用RGB和HSL应用颜色，包括透明的alpha层，以产生出色的美学效果。
- en: In this chapter, we've also learned how to add web typography to a design with
    the `@font-face` rule, finally freeing us from the shackles of the humdrum selection
    of web-safe fonts. Despite all these great new features and techniques, we've
    only picked at the surface of what we can do with CSS3\. Let's move on now and
    look at even more ways CSS3 can make a responsive design as fast, efficient, and
    maintainable as possible with CSS3 text shadows, box shadows, gradients, and multiple
    backgrounds.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还学会了如何使用`@font-face`规则将网络排版添加到设计中，最终摆脱了单调的网络安全字体的束缚。尽管有了所有这些新特性和技术，我们只是触及了CSS3的潜力表面。让我们继续前进，看看CSS3如何通过文本阴影、盒子阴影、渐变和多重背景等方式，使响应式设计尽可能快速、高效和易于维护。
