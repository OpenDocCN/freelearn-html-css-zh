- en: Chapter 2. Creating Fluid Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。创建流体布局
- en: A key part of our journey through the essentials of responsive design is laying
    out content on the page—in the early days of the Internet, this was a simple process!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在响应式设计的基本知识中的关键部分是在页面上布置内容——在互联网的早期，这是一个简单的过程！
- en: With the advent of mobile devices (and those non-PC devices) that can access
    the Internet, content layout has become ever more critical; for example, how many
    images do we have, or do we include content X, or show a summary instead? These
    are just some of the questions we might ask ourselves. It goes to show that it
    can open a real can of worms!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动设备（以及那些非PC设备）能够访问互联网，内容布局变得更加关键；例如，我们有多少图片，或者我们是否包含内容X，或者只显示摘要？这些只是我们可能问自己的一些问题。这表明它可能会引发一系列问题！
- en: To simplify the process, we can use grid or fluid-based layouts. Throughout
    the course of this chapter, we'll take a look at using them in more detail; we'll
    start with setting the available viewport, and take it right through to future
    grid-based layouts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个过程，我们可以使用网格或基于流体的布局。在本章的课程中，我们将更详细地研究它们的使用；我们将从设置可用的视口开始，一直到未来的基于网格的布局。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing grid layouts and understanding different types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍网格布局并了解不同类型
- en: Setting the available viewport for use
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置可用的视口以供使用
- en: Exploring the benefits and mechanics of using grid layouts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用网格布局的好处和机制
- en: Implementing a prebuilt grid layout
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施预先构建的网格布局
- en: Exploring the future of grid-based template layouts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索基于网格模板布局的未来
- en: Curious? Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇吗？让我们开始吧！
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the exercises have been designed for the Windows platform, as this
    is the authors' platform of choice; alter as appropriate if you use a different
    platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些练习是为Windows平台设计的，因为这是作者首选的平台；如果您使用不同的平台，请适当修改。
- en: Introducing flexible grid layouts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍灵活的网格布局
- en: For many years, designers have built layouts of different types; they may be
    as simple as a calling card site, right through to a theme for a content management
    system, such as WordPress or Joomla. The meteoric rise of accessing the Internet
    through different devices means that we can no longer create layouts that are
    tied to specific devices or sizes—we must be flexible!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，设计师们建立了不同类型的布局；它们可能只是一个名片网站，也可能是一个用于内容管理系统（如WordPress或Joomla）的主题。通过不同设备访问互联网的迅猛增长意味着我们不能再创建与特定设备或尺寸绑定的布局——我们必须要灵活！
- en: To achieve this flexibility requires us to embrace a number of changes in our
    design process—the first being the type of layout we should create. A key part
    of this is the use of percentage values to define our layouts; rather than create
    something from the ground up, we can make use of a predefined grid system that
    has been tried and tested, as a basis for future designs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种灵活性，我们需要在设计过程中接受一些变化——首先是我们应该创建的布局类型。其中一个关键部分是使用百分比值来定义我们的布局；我们可以利用经过试验和测试的预定义网格系统作为未来设计的基础，而不是从头开始创建某些东西。
- en: The irony is that there are lots of grid systems vying for our attention, so
    without further ado, let's make a start by exploring the different types of layouts,
    and how they compare to responsive designs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 讽刺的是，有很多网格系统争相吸引我们的注意，因此，让我们毫不犹豫地开始探索不同类型的布局以及它们与响应式设计的比较。
- en: Understanding the different layout types
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解不同的布局类型
- en: A problem that has faced web designers for some years is the type of layout
    their site should use—should it be fluid, fixed width, have the benefits of being
    elastic, or a hybrid version that draws on the benefits of a mix of these layouts?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，困扰网页设计师的一个问题是他们的网站应该使用哪种布局——应该是流体的、固定宽度的、具有弹性的，还是混合这些布局优势的混合版本？
- en: The type of layout we choose to use will of course depend on client requirements—making
    it a fluid layout means we are effectively one step closer to making it responsive;
    the difference being that the latter uses media queries to allow resizing of content
    for different devices, not just normal desktops!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用的布局类型当然取决于客户的要求——将其设置为流体布局意味着我们实际上更接近于使其响应式；不同之处在于后者使用媒体查询来允许不同设备上的内容调整大小，而不仅仅是普通的桌面！
- en: 'To understand the differences, and how responsive layouts compare, let''s take
    a quick look at each in turn:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解差异以及响应式布局的比较，让我们依次快速看一下每种布局：
- en: '**Fixed width layouts**: These are constrained to a fixed width; a good size
    is around 960px, as this can be split equally into columns, with no remainder.
    The downside is fixed width makes assumptions about the available viewport area,
    and if the screen is too small or large, it results in lots of scrolling which
    affects the user experience.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定宽度布局**：这些布局受限于固定宽度；一个好的尺寸大约是960像素，因为这可以平均分成列，没有余数。缺点是固定宽度对可用视口区域做出了假设，如果屏幕太小或太大，就会导致大量滚动，影响用户体验。'
- en: '**Fluid layouts**: Instead of using static values, we use percentage-based
    units; it means that no matter what the size of the browser window, our site will
    adjust accordingly. This removes the problems that surround fixed layouts at a
    stroke.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流体布局**：我们使用基于百分比的单位，而不是使用静态值；这意味着无论浏览器窗口的大小如何，我们的网站都会相应调整。这一举措一下子解决了围绕固定布局的问题。'
- en: '**Elastic layouts**: They are similar to fluid layouts, but the constraints
    are measured by type or font size, using em or rem units; these are based on the
    defined font size, so 16px is 1 rem, 32px is 2 rem, and so on. These layouts allow
    for decent readability, with lines of 45-70 characters; font sizes are resized
    automatically. We may still see scrollbars appear in some instances, or experience
    some odd effects if we zoom our page content.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性布局**：它们类似于流体布局，但约束是通过类型或字体大小来衡量的，使用em或rem单位；这些是基于定义的字体大小，因此16px是1 rem，32px是2
    rem，依此类推。这些布局允许良好的可读性，每行45-70个字符；字体大小会自动调整大小。在某些情况下，我们可能仍会看到滚动条出现，或者在缩放页面内容时体验一些奇怪的效果。'
- en: '**Hybrid layouts**: They combine a mix of two or more of these different layout
    types; this allows us to choose static widths for some elements while others remain
    elastic or fluid.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合布局**：它们结合了两种或更多种不同的布局类型；这使我们可以为某些元素选择静态宽度，而其他元素保持弹性或流体。'
- en: In comparison, responsive layouts take fluid layouts a step further, using media
    queries to not only make our designs resize automatically, but also present different
    views of our content on multiple devices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，响应式布局进一步使用媒体查询，不仅使我们的设计自动调整大小，还在多个设备上呈现我们内容的不同视图。
- en: How do we set the available space though, and be sure that our content will
    zoom in or out as appropriate? Easy—we can do this by adding the viewport directive
    to our markup; let's go and explore what is required to allow our viewport to
    resize as needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何设置可用空间，并确保我们的内容会根据需要放大或缩小呢？很简单——我们可以通过在标记中添加视口指令来实现这一点；让我们去探索允许我们的视口根据需要调整大小所需的内容。
- en: Setting the available viewport for use
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置可用视口以供使用
- en: When viewing a website on different devices, we of course expect it to resize
    to the available device width automatically with no loss of *experience*; unfortunately,
    not every site does this quite the right way or successfully!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当在不同设备上查看网站时，我们当然希望它能自动调整到可用的设备宽度，而不会丢失*体验*；不幸的是，并非每个网站都能以正确的方式或成功地实现这一点！
- en: 'To understand why this is important, let''s assume we operate a desktop version
    of our site (one in the 1280+ group in this screenshot), and a mobile equivalent
    from the 418-768 group:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这很重要，让我们假设我们在桌面版本的网站上操作（在此屏幕截图中的1280+组中），以及移动等效版本从418-768组中：
- en: '![Setting the available viewport for use](img/image_02_001.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![设置可用视口以供使用](img/image_02_001.jpg)'
- en: 'The first stage in making our site responsive is to add the viewport directive;
    without it, we are likely to end up with a similar effect to this when resizing
    our sites:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的网站响应的第一步是添加视口指令；没有它，我们很可能会在调整我们的网站大小时出现类似的效果：
- en: '![Setting the available viewport for use](img/image_02_002.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![设置可用视口以供使用](img/image_02_002.jpg)'
- en: 'See what I mean? It looks awful—text is cut off, we would have to swipe to
    the right...ugh! In stark contrast, adding one line of code can have a dramatic
    effect:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 明白我的意思了吗？看起来很糟糕——文本被截断，我们必须向右滑动...噫！相比之下，添加一行代码可以产生戏剧性的效果：
- en: '![Setting the available viewport for use](img/image_02_003.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![设置可用视口以供使用](img/image_02_003.jpg)'
- en: 'Our example uses the Google Chrome set to emulate an iPhone 6 Plus. The code
    needed to restore sanity to our example can be added to the `<head>` of our code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用了设置为模拟iPhone 6 Plus的Google Chrome。恢复我们示例的理智所需的代码可以添加到我们代码的`<head>`中：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once set, we can immediately see the difference. Granted, our demo isn’t going
    to win any style awards, but then it wasn't the aim! It does, however, show that
    the text has been reduced in size to fit the screen, we have a proper border around
    the text—it all looks more pleasing as a display.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 设置后，我们可以立即看到区别。诚然，我们的演示不会赢得任何风格奖，但这也不是目的！然而，它确实显示文本已经缩小以适应屏幕，我们在文本周围有一个适当的边框——作为显示，这一切看起来更令人愉悦。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see what happens in action, try running the `viewport.html` demo from the
    code download that accompanies this book; you will need to run it in device/responsive
    mode for your browser; remove line 5, and re-add it back in to see the difference.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实际效果，请尝试运行附带本书的代码下载中的`viewport.html`演示；您需要在浏览器的设备/响应模式下运行它；删除第5行，然后重新添加它以查看区别。
- en: 'The content property in this directive supports using any one of a number of
    different values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令中的内容属性支持使用多种不同的值之一：
- en: '| **Property** | **Description** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `width` | The width of the virtual viewport of the device. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '`width` | 设备虚拟视口的宽度。'
- en: '| `device-width` | The physical width of the device''s screen. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '`device-width` | 设备屏幕的物理宽度。'
- en: '| `height` | The height of the virtual viewport of the device. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '`height` | 设备虚拟视口的高度。'
- en: '| `device-height` | The physical height of the device''s screen. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '`device-height` | 设备屏幕的物理高度。'
- en: '| `initial-scale` | The initial zoom when visiting the page; setting 1.0 does
    not zoom. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '`initial-scale` | 访问页面时的初始缩放；设置为1.0不会缩放。'
- en: '| `minimum-scale` | The minimum amount the visitor can zoom on the page; setting
    1.0 does not zoom. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '`minimum-scale` | 访问者可以在页面上缩小的最小量；设置为1.0不会缩小。'
- en: '| `maximum-scale` | The maximum amount the visitor can zoom on the page; setting
    1.0 does not zoom. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '`maximum-scale` | 访问者可以在页面上放大的最大量；设置为1.0不会放大。'
- en: '| `user-scalable` | Allows the device to zoom in and out (yes) or remain fixed
    (no). |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '`user-scalable` | 允许设备放大和缩小（是）或保持固定（否）。'
- en: Current versions of MS Edge don't play so well with viewport tags; it is worth
    noting that `@-ms-viewport` needs to be specified in code to ensure our viewport
    widths behave in the same way as other browsers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的MS Edge与视口标签不太兼容；值得注意的是，需要在代码中指定`@-ms-viewport`，以确保我们的视口宽度与其他浏览器的行为方式相同。
- en: Balancing viewport against experience
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视口和体验之间取得平衡
- en: You will notice that I italicized the word experience at the start of this section—the
    key point here is that in responsive design, the experience does not have to be
    identical across all devices; it must be useful though, and allow our visitors
    to interact with us as an organization. In other words, if we worked for a theater,
    we might limit our mobile offer to simply booking tickets, and let the main desktop
    site manage everything else.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我在本节开头使用了斜体的“体验”一词——这里的关键是，在响应式设计中，体验不必在所有设备上完全相同；但它必须是有用的，并允许我们的访问者作为一个组织与我们互动。换句话说，如果我们为一个剧院工作，我们可能会将我们的移动提供限制在简单的订票，而让主要的桌面站点管理其他一切。
- en: This is perfectly valid; while limiting a site, mobile ticketing might be considered
    by some as very restrictive. The concept is still technically sound, as long as
    the user experience is acceptable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全有效的；虽然限制了站点，移动订票可能被一些人认为非常受限制。这个概念在技术上仍然是合理的，只要用户体验是可以接受的。
- en: It's worth noting that we could have set a specific width using `width=<value>`.
    This is great if we need a certain width to display our content; if the orientation
    changes from portrait (320px) to landscape (360px) for example, then the viewport's
    content will be automatically scaled up and down to reflect these changes. If,
    however, we had set a device-width as a maximum, this implies that no scaling
    is need and that the browser should adjust the content within it to fit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们可以使用`width=<value>`来设置特定的宽度。如果我们需要特定的宽度来显示我们的内容，这是很好的；如果方向从纵向（320像素）变为横向（360像素），那么视口的内容将自动按比例缩放以反映这些变化。然而，如果我们将设备宽度设置为最大值，这意味着不需要缩放，浏览器应该调整其中的内容以适应。
- en: Considering viewport units
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑视口单位
- en: 'A key part of responsive design is to make the move away from using pixel values
    to working with em or rem units. In our examples (and the viewport demo from earlier
    in this chapter), we used both pixel and rem units. Although this works well,
    we still have a dependency on parent elements. Instead, we should consider using
    an alternative for working with viewports. They are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式设计的一个关键部分是摆脱使用像素值，而是使用em或rem单位。在我们的示例中（以及本章前面的视口演示中），我们使用了像素和rem单位。虽然这很有效，但我们仍然依赖于父元素。相反，我们应该考虑使用另一种处理视口的方法。它们是：
- en: '**vw**: viewport width'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vw**：视口宽度'
- en: '**vh**: viewport height'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vh**：视口高度'
- en: '**vmax**: maximum of the viewport''s height and width'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vmax**：视口高度和宽度的最大值'
- en: '**vmin**: minimum of the viewport''s height and width'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vmin**：视口高度和宽度的最小值'
- en: 'As a unit of measure, these equate to 1% of the viewport area that has been
    set; the beauty though is that they remove any dependency elements, and are calculated
    based on the current viewport size. Browser support for them is currently very
    good:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种度量单位，它们相当于已设置的视口区域的1%；但美妙之处在于它们消除了任何依赖元素，并且基于当前视口大小进行计算。目前，浏览器对它们的支持非常好：
- en: '![Considering viewport units](img/image_02_004.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![考虑视口单位](img/image_02_004.jpg)'
- en: 'Source: [http://caniuse.com/#search=vh](http://caniuse.com/#search=vh)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://caniuse.com/#search=vh](http://caniuse.com/#search=vh)
- en: Leaving aside the slight quirks with more recent versions of Internet Explorer,
    this is a useful option that combines the ease of units, with the flexibility
    of using percentages, in our designs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 撇开最近版本的Internet Explorer存在的一些小问题，这是一个有用的选项，它结合了单位的简便性和在设计中使用百分比的灵活性。
- en: Let’s move on—we’ve introduced flexible grids and explored how setting a viewport
    is critical to displaying content correctly. It’s time we moved on and explore
    some of the benefits of incorporating a grid system into our layout, and dive
    into the internals of how they work as a principle in responsive design.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续——我们已经介绍了灵活的网格，并探讨了设置视口对于正确显示内容的重要性。现在是时候继续探索将网格系统纳入我们的布局的一些好处，并深入了解它们作为响应式设计原则的内部工作。
- en: Exploring the benefits of flexible grid layouts
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索灵活网格布局的好处
- en: 'Now that we''ve been introduced to grid layouts as a tenet of responsive design,
    it''s a good opportunity to explore why we should use them. Creating a layout
    from scratch can be time consuming and needs lots of testing; there are some real
    benefits from using a grid layout:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了网格布局作为响应式设计的一个原则，现在是一个很好的机会来探讨为什么我们应该使用它们。从头开始创建布局可能会耗费时间并需要大量测试；使用网格布局有一些真正的好处：
- en: '**Grids make for a simpler design**: Instead of trying to develop the proverbial
    wheel, we can focus on providing the content instead; the infrastructure will
    have already been tested by the developer and other users.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格使设计更简单**：我们可以专注于提供内容，而不是试图开发传统的轮子；基础设施已经经过开发人员和其他用户的测试。'
- en: '**They provide for a visually appealing design**: Many people prefer content
    to be displayed in columns, so grid layouts make good use of this concept to help
    organize content on the page.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们提供了视觉上吸引人的设计**：许多人喜欢以列的形式显示内容，因此网格布局很好地利用了这个概念来帮助组织页面上的内容。'
- en: '**Grids can of course adapt to different size viewports**: The system they
    use makes it easier to display a single codebase on multiple devices, which reduces
    the effort required for developers to maintain and webmasters to manage.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格当然可以适应不同大小的视口**：它们使用的系统使得在多个设备上显示单一的代码库更容易，这减少了开发人员维护和网站管理员管理所需的工作量。'
- en: '**Grids help with the display of adverts**: Google has been known to favor
    sites which display genuine content and not those where it believes the sole purpose
    of the site is for ad generation; we can use the grid to define specific areas
    for adverts, without getting in the way of natural content.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格有助于显示广告**：谷歌已经知道偏爱显示真实内容的网站，而不是那些它认为网站的唯一目的是产生广告的网站；我们可以使用网格来定义特定的广告区域，而不会妨碍自然内容。'
- en: All in all, it makes sense to familiarize ourselves with grid layouts; the temptation
    is of course to use an existing library. There is nothing wrong with this, but
    to really get the benefit out of using them, it's good to understand some of the
    basics around the mechanics of grid layouts and how this can help with the construction
    of our site.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，熟悉网格布局是有意义的；诱惑当然是使用现有的库。这没有错，但要真正从中获益，了解一些围绕网格布局机制的基础知识以及如何帮助构建我们的网站是很有好处的。
- en: Let's take a quick look first at how we would calculate the widths of each element,
    an important part of creating any grid layout.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们快速看一下如何计算每个元素的宽度，这是创建任何网格布局的重要部分。
- en: Understanding the mechanics of grid layouts
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解网格布局的机制
- en: So far, we explored one of the key critical elements of responsive design, in
    the form of how we would set our available screen estate (or viewport)—as someone
    once said, *it's time...*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们探讨了响应式设计的一个关键要素，即我们将如何设置我们的可用屏幕空间（或视口）——正如有人曾经说过的那样，“是时候了…”
- en: 'Absolutely—it''s time we cracked on and explored how grids operate! The trick
    behind grids is nothing special; it boils down to the use of a single formula
    to help define the proportions of each element used in our layouts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对没错——是时候开始探索网格是如何运作的了！网格背后的技巧并不特别；它归结为使用一个公式来帮助定义我们布局中使用的每个元素的比例：
- en: '*target ÷ context = result*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标 ÷ 上下文 = 结果*'
- en: Let's imagine that we have a layout with two columns, and that the container
    (or context) is 960px wide (I will use pixel values purely to illustrate the maths
    involved).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含两列的布局，容器（或上下文）宽度为960px（我将使用像素值纯粹是为了说明所涉及的数学）。
- en: To create our layout, we will make use of the Golden Ratio that we touched on
    in [Chapter 1](ch01.html "Chapter 1. Introducing Responsive Web Design"), *Introducing
    Responsive Web Design*; to recap, we use the ratio of 1.618 to every 1 pixel.
    So, if our layout is 960px wide, we multiply 960 x 0.618 (the difference)—this
    gives 593px (rounded down to the nearest integer). We then simply subtract 593
    from 960, to arrive at 367px for our side column. Easy, when you know how...!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的布局，我们将使用我们在[第1章](ch01.html "第1章.介绍响应式网页设计")中提到的黄金比例，*介绍响应式网页设计*；回顾一下，我们使用1.618的比例对每个像素。因此，如果我们的布局宽度为960px，我们将960乘以0.618（差值）—这给出593px（四舍五入到最接近的整数）。然后我们简单地从960中减去593，得到367px作为我们的侧边栏。当你知道如何做的时候，这就很简单了…！
- en: 'At this stage, we can convert these to percentages; `593px` becomes `61.77%`,
    and the side bar will be `38.23%`. Let''s translate this into some sample CSS,
    with values rounded to 2 decimal places:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以将这些转换为百分比；`593px`变为`61.77%`，侧边栏将是`38.23%`。让我们将这些转化为一些样本CSS，值四舍五入到小数点后两位：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, our target is the `aside` (or sub-element), with context as the container;
    in this case, we've set it to 960px. The section forms a second target; in both
    cases, we've divided the target by the context to arrive at our result. As our
    result figures need to be expressed as percentages, we can simply multiply each
    by 100 to get the figures we need.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的目标是`aside`（或子元素），上下文是容器；在这种情况下，我们将其设置为960px。该部分形成了第二个目标；在这两种情况下，我们将目标除以上下文得出结果。由于我们的结果需要以百分比表示，我们只需将每个结果乘以100即可获得所需的数字。
- en: 'The observant among you will note the presence of `margin: 1.00%`. We must
    allow sufficient space for our margin, so the resulting figures will need to change.
    We''ll keep the section width at `61.77%`, so our margin will need to drop down
    to `34.23%`, to retain a full width of 100% (this allows for the two margins each
    side of the two sub-elements).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '你们中敏锐的人可能会注意到`margin: 1.00%`的存在。我们必须为我们的边距留出足够的空间，因此结果数字将需要更改。我们将保持部分宽度为`61.77%`，因此我们的边距将需要降至`34.23%`，以保持100%的全宽（这允许两个子元素两侧的两个边距）。'
- en: 'If we carried this through to its conclusion, we could end up with something
    akin to this screenshot, as an example layout:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一直坚持下去，最终可能会得到类似于这个屏幕截图的布局：
- en: '![Understanding the mechanics of grid layouts](img/image_02_005.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![理解网格布局的机制](img/image_02_005.jpg)'
- en: 'Okay, let''s move on. I feel it''s time for a demo! Before we get stuck into
    writing code, there are a few pointers we should take a quick look at:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续。我觉得是时候进行演示了！在我们开始编写代码之前，有一些要点我们应该快速看一下：
- en: Although we've only scraped the surface of how grid layouts work, there is a
    lot more we can do; it will all depend on how many columns your site needs, whether
    the columns should be equal in width, or be merged with others, how big the container
    will be, and so on.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们只是浅尝辄止地探索了网格布局的工作原理，但我们还有很多事情要做；这将取决于你的网站需要多少列，列是否应该等宽，或者与其他列合并，容器有多大，等等。
- en: There are dozens of grid layout frameworks available online. Before getting
    into designing and creating your own from scratch, take a look at what is available;
    it will save you a lot of time!
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有数十种网格布局框架可以在线使用。在开始从头设计和创建自己的网格之前，看看有什么可用的；这将节省你很多时间！
- en: Keep it simple; don't try to overcomplicate your layout. You may read stories
    of developers extolling the virtues of flexbox, or that you must use JavaScript
    or jQuery in some form or other; for a simple layout, it isn't necessary. Yes,
    we might use properties such as box sizing, but flexbox-based grid systems can
    become overinflated with CSS.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持简单；不要试图过分复杂化你的布局。你可能会读到开发人员赞扬flexbox的优点，或者说你必须以某种形式使用JavaScript或jQuery；对于简单的布局，这是不必要的。是的，我们可能会使用box
    sizing等属性，但基于flexbox的网格系统可能会在CSS中变得过于臃肿。
- en: 'With this in mind, it''s time we got stuck into a demo. Before we do though,
    there is something we need to cover, as it will become a recurring theme throughout
    this book:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，现在是时候进行演示了。不过，在我们开始之前，有一些东西需要讲解，因为这将成为本书中的一个主题：
- en: We will avoid the use of JavaScript or downloading libraries in order to create
    our demos. Yes, you heard right. We're going to attempt to use nothing more than
    plain HTML5 or CSS3 to construct our responsive elements!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将避免使用JavaScript或下载库来创建我们的演示。是的，你没听错。我们将尝试仅使用纯HTML5或CSS3来构建我们的响应式元素！
- en: The reason for this is simple—I maintain that we've become lazy as developers,
    and that sometimes it is good to go back to basics and really appreciate that
    sometimes simple is better. You may hear of singers who want to get back to their
    roots or where they started from; we're simply applying the same principle to
    our responsive development. It does mean that we can't always use the most feature-rich,
    or latest version, but that isn't always a bad thing, right?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单——我坚持认为我们作为开发人员变得懒惰了，有时候回归基础并真正欣赏简单更好。你可能会听说歌手想回到他们的根源或起点；我们只是将同样的原则应用到我们的响应式开发中。这意味着我们不能总是使用最丰富功能的或最新版本的，但这并不总是坏事，对吧？
- en: Implementing a prebuilt grid layout
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施预构建的网格布局
- en: We've touched on the basics of creating grids; these can be really time consuming
    to create from scratch, so with so many already available online, it makes better
    sense to use a prebuilt version unless your requirements are such that you can't
    find one that works for you! It is worth spending time researching what is available,
    as no two grids are the same.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了创建网格的基础知识；从头开始创建这些可能非常耗时，因此有这么多已经可用在线的网格，除非您的要求是找不到适合您的网格，否则最好使用预构建版本！值得花时间研究可用的内容，因为没有两个网格是相同的。
- en: 'As an example of what is available and to prove that we don''t need all the
    bells and whistles that grids can offer, let''s take a look at an example grid,
    in the form of Gridism. We can see an example of how our next demo looks like
    when completed, in this screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可用内容的示例，并证明我们不需要网格提供的所有花哨功能，让我们看一个Gridism形式的示例网格。我们可以在这个屏幕截图中看到我们的下一个演示完成后的样子：
- en: '![Implementing a prebuilt grid layout](img/image_02_006.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![实施预构建的网格布局](img/image_02_006.jpg)'
- en: Although this library has been around for two to three years, its simplicity
    proves that we don't need to implement a complex solution in order to create the
    basis for a simple layout. The flexbox attribute in CSS is perfect for creating
    grids, but its flexibility adds a layer of complexity that isn't needed; instead,
    we'll make use of the `box-sizing` attribute, which will work just as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个库已经存在了两三年，但它的简单性证明了我们不需要实施复杂的解决方案来创建简单布局的基础。CSS中的flexbox属性非常适合创建网格，但它的灵活性增加了不必要的复杂性；相反，我们将使用`box-sizing`属性，它同样有效。
- en: Created by Cody Chapple, it doesn't make use of flexbox (of which more, anon),
    but does make use of box-sizing as an attribute in the grid. The library can be
    downloaded from [https://github.com/cobyism/gridism/blob/master/gridism.css](https://github.com/cobyism/gridism/blob/master/gridism.css)
    (or installed using Bower), but as it consists of one file only, we can simply
    copy the contents to a text file and save it that way (and still keep to our earlier
    aim of not downloading content).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由Cody Chapple创建，它不使用flexbox（稍后会详细介绍），但在网格中使用box-sizing作为属性。该库可以从[https://github.com/cobyism/gridism/blob/master/gridism.css](https://github.com/cobyism/gridism/blob/master/gridism.css)下载（或使用Bower安装），但由于它只包含一个文件，我们可以简单地将内容复制到文本文件中并保存（仍然保持我们早期的目标，即不下载内容）。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The demo will use the original example from the Gridism site, but the CSS has
    been reworked to bring it up to date and remove some unnecessary code. For ease
    of convenience, we will assume use of Google Chrome throughout this demo.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 演示将使用Gridism网站的原始示例，但CSS已经重新设计以使其保持最新状态并删除一些不必要的代码。为了方便起见，我们将假设在整个演示过程中都使用Google
    Chrome。
- en: 'Let''s make a start:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: From the code download that accompanies this book, go ahead and download a copy
    of `gridism.html`, along with `normalize.css`, `gridism.css`, and `style.css`.
    Save the HTML markup at the root of our project area, and the two CSS files within
    the CSS subfolder.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从随书附带的代码下载中，下载`gridism.html`的副本，以及`normalize.css`，`gridism.css`和`style.css`。将HTML标记保存在项目区域的根目录中，将两个CSS文件保存在CSS子文件夹中。
- en: Try running `gridism.html` in a browser, then enable its device or responsive
    mode (by pressing *Ctrl* + *Shift* + *I* then *Ctrl* + *Shift* + *M*). We should
    see something akin to the screenshot shown at the beginning of this exercise.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在浏览器中运行`gridism.html`，然后启用其设备或响应模式（按下*Ctrl* + *Shift* + *I*，然后按下*Ctrl* + *Shift*
    + *M*）。我们应该看到类似于本练习开始时显示的屏幕截图。
- en: The screenshot at the start of this section was taken in Google Chrome, set
    to emulate an iPhone 6 Plus in landscape mode. Now use the orientation tool in
    Chrome:![Implementing a prebuilt grid layout](img/image_02_007.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本节开头的屏幕截图是在设置为模拟iPhone 6 Plus横向模式的Google Chrome中拍摄的。现在在Chrome中使用方向工具：![实施预构建的网格布局](img/image_02_007.jpg)
- en: 'To change the orientation to portrait:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将方向更改为纵向：
- en: '![Implementing a prebuilt grid layout](img/image_02_008.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![实施预构建的网格布局](img/image_02_008.jpg)'
- en: 'Notice how the grid has automatically realigned itself? The trick here is not
    in the `style.css` file, but within `gridism.css`; if we open it in a text editor
    and look for this block of code, on or around lines 50-61, it will look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意网格如何自动重新排列？这里的技巧不在于`style.css`文件，而在于`gridism.css`；如果我们在文本编辑器中打开它并查找代码块，大约在第50-61行左右，它会像这样：
- en: '![Implementing a prebuilt grid layout](img/image_02_009.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![实施预构建的网格布局](img/image_02_009.jpg)'
- en: We can see that the library makes good use of percentage values to assign a
    width to each block. The real crux of this is not in the widths set, but the size
    of our container; for gridism, this is set to `978px` by default. So, for example,
    if we were to set a cell width of `.one-third`, we would want `33.3332%` of `736px`,
    or `245.33px`. We then ensure all grid cells have the right dimensions by applying
    the box-sizing attribute to each of our grid cells.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该库充分利用百分比值来为每个块分配宽度。这里的关键不在于设置的宽度，而在于我们的容器的大小；对于gridism，默认设置为`978px`。因此，例如，如果我们设置一个单元格宽度为`.one-third`，我们希望占据`736px`的`33.3332%`，即`245.33px`。然后，我们通过将box-sizing属性应用于我们的每个网格单元格来确保所有网格单元格具有正确的尺寸。
- en: 'See how easy that was? In place of having to work out percentages, we simply
    specify the name of the column type we need, depending on how wide we need it
    to be:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 看，这多简单？我们只需指定我们需要的列类型的名称，具体取决于我们需要它有多宽：
- en: '![Implementing a prebuilt grid layout](img/image_02_010.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![实现预构建的网格布局](img/image_02_010.jpg)'
- en: Hold on a moment. How come the screenshot shows `215.33`, and not `245.33`,
    as the calculation indicated it should be?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。为什么屏幕截图显示的是`215.33`，而不是计算所指示的`245.33`？
- en: Aha, this is just something we need to be mindful of; when working with a grid
    system like Gridism, the calculations are based on the full width of our viewport.
    Any padding required will be included within the width calculations of our column,
    so we may need a slightly larger column then we anticipate! It goes to show that
    even though our grid system doesn't have all of the mod-cons of current systems,
    we can still produce a useable grid, as long as we plan it carefully.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈，这只是我们需要注意的一点；当使用像Gridism这样的网格系统时，计算是基于我们视口的全宽度的。任何所需的填充将包含在我们列的宽度计算中，因此我们可能需要比预期的稍大的列！这表明，即使我们的网格系统没有当前系统的所有功能，只要我们仔细规划，我们仍然可以制作出一个可用的网格。
- en: Okay, let's move on. We talked in passing about the fact that many grids use
    flexbox to help control their appearance; this is a great option to use, but can
    require setting a lot of additional properties that would otherwise be unnecessary
    for simple layouts. With careful planning, there is every possibility that we
    can avoid using it, but if we're working on a complex layout with lots of different
    elements, then there will be occasions when using it will avoid a lot of heartache!
    With this in mind, let's take a quick look at the basics of how it works in more
    detail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续。我们曾经提到过，许多网格使用flexbox来帮助控制它们的外观；这是一个很好的选择，但可能需要设置许多额外的属性，否则对于简单的布局来说是不必要的。通过仔细规划，有可能避免使用它，但如果我们正在处理具有许多不同元素的复杂布局，那么在某些情况下使用它将避免很多麻烦！考虑到这一点，让我们快速看一下它的基本工作原理。
- en: Exploring the use of flexbox
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索flexbox的使用
- en: So, what is flexbox?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是flexbox？
- en: It's a module that has been designed to provide a more efficient way to layout
    and distribute space around items in a container, particularly if their sizes
    are not yet known. We can set a number of properties to ensure that each item
    best uses the available space around it, even if its size changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个被设计为以更有效的方式在容器中布局和分配空间的模块，特别是如果它们的大小尚不清楚。我们可以设置一些属性来确保每个项目最好地利用其周围的可用空间，即使其大小发生变化。
- en: 'At the time of writing, this is a W3C Candidate Recommendation; this means
    that it is effectively on the last call before becoming a browser standard in
    late 2016\. This should be something of a formality though, as most browsers already
    support it as a standard:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，这是W3C的候选推荐；这意味着它实际上是在2016年底成为浏览器标准之前的最后一次呼吁。尽管如此，大多数浏览器已经支持它作为标准：
- en: '![Exploring the use of flexbox](img/image_02_011.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![探索flexbox的使用](img/image_02_011.jpg)'
- en: 'Source: [http://caniuse.com/#search=flexbox](http://caniuse.com/#search=flexbox)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://caniuse.com/#search=flexbox](http://caniuse.com/#search=flexbox)
- en: 'To fully understand how it all works is outside the scope of this book, but
    to help get started, we can run a quick demo, and explore some of the main features:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解它的工作原理超出了本书的范围，但为了帮助入门，我们可以运行一个快速演示，并探索一些主要特性：
- en: From the code download that accompanies this book, go ahead and extract copies
    of `flexbox.html` and `flexbox.css`; store the HTML markup at the root of our
    project area, and the CSS style sheet in the `css` subfolder of our project area.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从附带本书的代码下载中，提取`flexbox.html`和`flexbox.css`的副本；将HTML标记存储在我们项目区域的根目录下，将CSS样式表存储在我们项目区域的`css`子文件夹中。
- en: 'Try previewing `flexbox.html` in a browser. For this, we will need to enable
    the browser''s responsive mode (or device mode, depending on browser); if all
    is well, we should see something akin to this screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中尝试预览`flexbox.html`。为此，我们需要启用浏览器的响应模式（或设备模式，取决于浏览器）；如果一切正常，我们应该看到类似于这个屏幕截图的东西：
- en: '![Exploring the use of flexbox](img/image_02_012.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![探索flexbox的使用](img/image_02_012.jpg)'
- en: The demo is based on a pen created by Irina Kramer, which is available at [https://codepen.io/irinakramer/pen/jcLlp](https://codepen.io/irinakramer/pen/jcLlp);
    for the purposes of our demo, we focus on the example layout taken from that pen.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该演示基于Irina Kramer创建的一个笔记本，可以在[https://codepen.io/irinakramer/pen/jcLlp](https://codepen.io/irinakramer/pen/jcLlp)上找到；为了我们的演示目的，我们专注于从该笔记本中提取的示例布局。
- en: At first glance, this demo looks very straightforward. It could certainly use
    some help in the color department, but that's not what is of interest to us at
    the moment. If we dig deeper into the code, we can see that flexbox has been incorporated
    in various places; let's explore its use in more detail.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个演示看起来非常简单。它肯定可以在颜色方面提供一些帮助，但这并不是我们目前感兴趣的。如果我们深入挖掘代码，我们会发现flexbox已经被应用在各个地方；让我们更详细地探索它的使用。
- en: Taking a closer look
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细观察
- en: 'Taking a closer look at our code, we will find that a large part of it uses
    standard attributes, which we might find on any site. The code that is of interest
    to us starts on line 50; to understand its role, we first need to get our heads
    around the basic concept of flex layouts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下我们的代码，我们会发现其中有很大一部分使用了标准属性，这些属性可能在任何网站上都能找到。对我们感兴趣的代码从第50行开始；为了理解它的作用，我们首先需要理解flex布局的基本概念：
- en: '![Taking a closer look](img/image_02_013.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![仔细看一下](img/image_02_013.jpg)'
- en: 'Source: W3C'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：W3C
- en: 'In a nutshell, items are laid out following either the main axis (from main-start
    to main-end) or the cross axis (from cross-start to cross-end):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，项目按照主轴（从主开始到主结束）或交叉轴（从交叉开始到交叉结束）进行布局：
- en: '| **Property** | **Purpose** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **目的** |'
- en: '| `main axis` | The primary axis along which flex items are laid out; this
    is dependent on the flex-direction property. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `main axis` | 伸缩项目布局的主轴；这取决于flex-direction属性。 |'
- en: '| `main-start &#124;  main-end` | The start and end points of flex items that
    are placed within the container (horizontally). |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `main-start &#124;  main-end` | 容器内放置的伸缩项目的起点和终点（水平）。 |'
- en: '| `main size` | A flex item''s width or height, whichever is in the main dimension,
    is the item''s main size. The main size property can be the item''s height or
    width size. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `main size` | 伸缩项目的宽度或高度，取决于主尺寸，是项目的主尺寸。主尺寸属性可以是项目的高度或宽度尺寸。 |'
- en: '| `cross axis` | The axis perpendicular to the main axis. Its direction depends
    on the main axis direction. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `cross axis` | 与主轴垂直的轴。其方向取决于主轴的方向。 |'
- en: '| `cross-start &#124; cross-end` | Start and end points for flex lines that
    are filled with items and placed into the container (vertically). |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `cross-start &#124; cross-end` | 用于填充项目并放置到容器中的伸缩行的起点和终点（垂直）。 |'
- en: '| `cross size` | This is the width or height of a flex item, whichever is in
    the cross dimension. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `cross size` | 这是伸缩项目的宽度或高度，取决于交叉尺寸。 |'
- en: With this in mind, let's explore some of the flexbox terms that have been used
    in our code; the initial few styles are standard rules that could apply to any
    site. The code of interest to us starts on line `29`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们来探索一些在我们的代码中使用的flexbox术语；最初的几个样式是适用于任何网站的标准规则。我们感兴趣的代码从第`29`行开始。
- en: 'If we scroll down to that line, we are met with this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们滚动到那一行，我们会看到这个：
- en: '![Taking a closer look](img/image_02_014.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![仔细看一下](img/image_02_014.jpg)'
- en: 'Our first attribute, `display: flex`, defines the container which contains
    the flex items; here, we''re setting it to show items in rows, and to wrap from
    left to right. If we had a number of columns in our layout, and by this I mean
    more than just two or three, then we might use `align-items` and `justify-content`
    to ensure that each column was evenly spread throughout the row, irrespective
    of the width of each column.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的第一个属性`display: flex`定义了包含伸缩项目的容器；在这里，我们设置它以行的形式显示项目，并从左到右换行。如果我们的布局中有多列，我的意思不仅仅是两三列，那么我们可能会使用`align-items`和`justify-content`来确保每一列均匀地分布在行中，而不管每一列的宽度如何。'
- en: With the `.grid` defined, we need to style our grid-cells, or the containers
    where we host our content. There are several properties we can apply; the one
    we've used is `flex`, which is shorthand for `flex-grow`, `flex-shrink`, and `flex-basis`.
    In our case, it is recommended that the shorthand version be used, as this will
    set the other values automatically; we've set `flex-grow` to `1`, which indicates
    how much it should grow, in relation to other flexible items in the same container.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`.grid`的定义，我们需要为我们的网格单元格或容器进行样式设置。我们可以应用几个属性；我们使用的是`flex`，这是`flex-grow`，`flex-shrink`和`flex-basis`的简写。在我们的情况下，建议使用简写版本，因为这将自动设置其他值；我们将`flex-grow`设置为`1`，这表示它应该在同一容器中的其他伸缩项目中增长多少。
- en: 'The next property of interest is in the `.nav` rule. Here, we''ve used flex-flow
    again, but this time we also justify-content; the latter controls how items are
    packed on each row (in this case, toward the end of the line):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的下一个属性是在`.nav`规则中。在这里，我们再次使用了flex-flow，但这次我们还使用了justify-content；后者控制了每一行上的项目是如何排列的（在这种情况下，朝着行的末尾）：
- en: '![Taking a closer look](img/image_02_015.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![仔细看一下](img/image_02_015.jpg)'
- en: 'Our last block of code of particular interest is this section, within the large
    screen media query:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别感兴趣的最后一段代码是在大屏幕媒体查询中的这一部分：
- en: '![Taking a closer look](img/image_02_016.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![仔细看一下](img/image_02_016.jpg)'
- en: The order property simply specifies the order of each item in our flex container;
    in this case, we have `.aside-1` and `.aside-2` in position 1 and 2 respectively
    (not in shot), with the `.main` in the middle at position 2.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: order属性只是指定了我们的伸缩容器中每个项目的顺序；在这种情况下，我们有`.aside-1`和`.aside-2`分别在位置1和2（不在镜头中），而`.main`在中间位置2。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot more properties we can set, depending on our requirements. Take
    a look at the source code on the original pen. There are plenty of reference sources
    about flexbox available online—as a start, have a look at Chris Coyier's guide,
    available at [http://bit.ly/1xEYMhF](http://bit.ly/1xEYMhF).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的需求，我们可以设置更多属性。查看原始笔的源代码。在线上有很多关于flexbox的参考资料，首先可以看看Chris Coyier的指南，网址为[http://bit.ly/1xEYMhF](http://bit.ly/1xEYMhF)。
- en: Let's move on. We've explored some examples of what is possible now, but there
    is at least one downside with using flexbox. The technology works very well, but
    can add a fair amount of code and complexity when implementing in a site.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续。我们已经探索了现在可能的一些例子，但是使用flexbox至少有一个缺点。这项技术非常有效，但在网站实施时可能会增加大量代码和复杂性。
- en: It's time to look for something simpler to use, which doesn't require quite
    the same effort to implement; enter CSS grid templates! This is still an early
    technology, with minimal browser support, but is already easier to implement.
    Let's dive in and take a look in more detail.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候寻找一些更简单的东西来使用了，这不需要同样的努力来实现；进入CSS网格模板！这仍然是一项早期技术，浏览器支持有限，但已经更容易实现。让我们深入了解一下。
- en: Visiting the future
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问未来
- en: Imagine that we have flexbox as a technique for creating grid layouts, but its
    design is meant for simpler, one-dimensional layouts; it doesn't work so well
    if the layout is complicated! Is there an answer, something better, that is designed
    for the job?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有flexbox作为一种创建网格布局的技术，但它的设计是用于更简单的一维布局；如果布局复杂，它就不太适用！有没有一个答案，更好的东西，专门为这项工作设计的？
- en: Fortunately there is; I am of course referring to a relatively new technology,
    named CSS Grid Layout. Support for this is minimal for now, but this is likely
    to change. In a nutshell, it provides a simpler way to create grids in a browser,
    without the plethora of options we saw with flexbox.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是；我当然是在指一种相对较新的技术，名为CSS Grid Layout。目前对它的支持还很有限，但这可能会改变。简而言之，它提供了一种更简单的方式在浏览器中创建网格，而不像flexbox那样拥有大量的选项。
- en: 'The downside of using CSS Grid Layout as a technology is that support for it
    has yet to hit mainstream; it is supported in IE11/Edge, but only under the `-ms-`
    prefix. Opera, Firefox, and Chrome offer support, but all require a flag to be
    enabled to view the results:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS Grid Layout作为一种技术的缺点是，对它的支持尚未普及；它在IE11/Edge中得到支持，但只在`-ms-`前缀下支持。Opera、Firefox和Chrome提供支持，但都需要启用标志才能查看结果：
- en: '![Visiting the future](img/image_02_017.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![访问未来](img/image_02_017.jpg)'
- en: 'Source: [CanIUse.com](http://caniuse.com/)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[CanIUse.com](http://caniuse.com/)
- en: Leaving aside the concerns about support for a moment, it is easy to see why
    CSS Grid Layout will take off as a technique. The whole concept has been designed
    to simplify how we reference cells, rows, and columns; if we compare with flexbox,
    it is more straightforward to apply styles using CSS Grid Layout than with flexbox.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 暂且不谈对支持的担忧，很容易看出为什么CSS Grid Layout将作为一种技术蓬勃发展。整个概念旨在简化我们如何引用单元格、行和列；与flexbox相比，使用CSS
    Grid Layout更容易应用样式。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you would like to learn more about CSS Grid Layout, then have a look online.
    This article by Chris House explains it well: [http://bit.ly/2bMGlDp](http://bit.ly/2bMGlDp).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于CSS Grid Layout的信息，请在网上查看。Chris House的这篇文章解释得很好：[http://bit.ly/2bMGlDp](http://bit.ly/2bMGlDp)。
- en: To see how it compares, let's dive in and build a simple demo to illustrate
    some images in a grid layout.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看它的效果，让我们深入研究并构建一个简单的演示，以说明网格布局中的一些图片。
- en: Implementing a basic gallery grid
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基本画廊网格
- en: 'For our next demo, we''re going to make use of an example created by the developer
    Rachel Andrew, at [http://codepen.io/rachelandrew/full/LGpONE/](http://codepen.io/rachelandrew/full/LGpONE/);
    we''ll be replacing the images with ones from Flickr, depicting pictures of my
    favorite European town, Bruges. No, it''s not to do with the lace, before you
    ask: good food, fine wine, great atmosphere, stunning chocolates for sale...what
    more could you ask for, I wonder?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个演示，我们将利用开发人员Rachel Andrew在[http://codepen.io/rachelandrew/full/LGpONE/](http://codepen.io/rachelandrew/full/LGpONE/)创建的一个示例；我们将用来自Flickr的图片替换它们，展示我最喜欢的欧洲小镇布鲁日的图片。不，这与蕾丝无关，你问之前：美食、美酒、绝佳的氛围、出售的令人惊叹的巧克力……我想你还能要求什么呢？
- en: 'But I digress. Before we get into creating our code, there are a couple of
    points we must bear in mind:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但我岔开了话题。在我们开始创建我们的代码之前，有几点我们必须牢记：
- en: 'This demo is cutting edge, it won''t work in all browsers, and for some, it
    requires enabling support within the browser. Take care, it is perfectly okay
    to enable the flag, but make sure you get the right one:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个演示是尖端的，不会在所有浏览器中运行，对于一些浏览器，需要在其中启用支持。请注意，启用标志是完全可以的，但请确保您选择正确的标志：
- en: '![Implementing a basic gallery grid](img/image_02_018.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![实现基本画廊网格](img/image_02_018.jpg)'
- en: We have to restart Google Chrome in step 1, so make sure you only have the flags
    page displayed at the start of the demo.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在第1步重新启动Google Chrome，所以确保在演示开始时只显示标志页面。
- en: 'Without further ado, let''s make a start on our demo:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们开始我们的演示吧：
- en: We'll begin by enabling support in Google Chrome for CSS Grid Layout. To do
    so, browse to `chrome://flags` and search for **Experimental Web Platform features**.
    Click on the enable button to activate it, then hit the blue **Relaunch Now**
    button at the bottom of the page to relaunch Google Chrome.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在Google Chrome中启用对CSS Grid Layout的支持。要这样做，浏览到`chrome://flags`，并搜索**实验性网络平台功能**。单击启用按钮以激活它，然后点击页面底部的蓝色**立即重新启动**按钮以重新启动Google
    Chrome。
- en: With support enabled, go ahead and extract a copy of `gridtemplate.html` from
    the code download that accompanies this book; save it to the root of our project
    area.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启用支持后，继续从本书附带的代码下载中提取`gridtemplate.html`的副本；将其保存到我们项目区域的根目录。
- en: 'In a new text file, add the following styles. We''ll go through them in blocks,
    beginning with some initial styling for our images and labels:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的文本文件中，添加以下样式。我们将按块进行解释，首先是一些用于我们的图片和标签的初始样式：
- en: '[PRE2]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next up comes the rules needed to set our container; note that the only style
    used that relates to our grid is `box-sizing`, which we set to `border-box`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是设置我们的容器所需的规则；请注意，与我们的网格相关的唯一样式是`box-sizing`，我们将其设置为`border-box`：
- en: '[PRE3]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The real magic starts to happen in a set of media queries; we begin with assigning
    wrapper as our grid container, then set the column and row layout of our grid:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真正的魔法开始在一组媒体查询中发生；我们首先将wrapper分配为我们的网格容器，然后设置网格的列和行布局：
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our second query, we set individual styles for our grid wrapper and list
    items, this time for 640px or greater:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的第二个查询中，我们为我们的网格包装器和列表项设置了单独的样式，这次是针对640像素或更大的情况：
- en: '[PRE5]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the file as `gridtemplate.css`, within the `css` subfolder of our project
    area.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为`gridtemplate.css`，保存在我们项目区域的`css`子文件夹中。
- en: 'Try previewing the results in a browser; if all is well, we should see results
    similar to this screenshot:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在浏览器中预览结果；如果一切正常，我们应该看到类似于这个截图的结果：
- en: '![Implementing a basic gallery grid](img/image_02_019.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![实现基本画廊网格](img/image_02_019.jpg)'
- en: Okay, granted. It's probably not what you might expect in terms of styling,
    but this demo isn't about making it look pretty, but the basic grid effect. There
    are nonetheless some important concepts that are good to understand, so let's
    dive in and explore what took place in our demo in more detail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，承认吧。这可能不是你所期望的样式，但这个演示不是为了让它看起来漂亮，而是基本的网格效果。然而，有一些重要的概念是值得理解的，所以让我们深入探讨一下我们演示中发生的事情。
- en: Exploring what happened
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索发生了什么
- en: Earlier in this chapter, we explored how flexbox can be used to create a grid
    layout; if we were to compare CSS styling, it is easy to see that on balance,
    we need to provide more styling when using flexbox than using CSS Grid Layout.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们探讨了flexbox如何用于创建网格布局；如果我们比较CSS样式，很容易看出，使用flexbox需要提供更多的样式，而使用CSS
    Grid布局则需要更少的样式。
- en: The only styling attribute that we've used in our core styles is `box-sizing`,
    which we set to `border-box`. Nothing else has been used at this point—all of
    our CSS Grid Layout styles have been set within two media queries.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在核心样式中唯一使用的样式属性是`box-sizing`，我们将其设置为`border-box`。在这一点上没有使用其他任何东西——我们所有的CSS
    Grid布局样式都在两个媒体查询中设置。
- en: Our first media query sets the `.wrapper` class as our grid container. Note
    that we've only need to set it once, as it will cascade through to larger viewports
    that are `500px` or greater in size.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个媒体查询将`.wrapper`类设置为我们的网格容器。请注意，我们只需要设置一次，因为它将在大于`500px`的更大视口中级联。
- en: Once the grid container is assigned, we then specify the grid columns for our
    template - the `1fr` value assigned represents the fraction of free white space
    in the grid around each cell's content (hence the `fr` unit). We then finish up
    by specifying `grid-row` or `grid-column` in both media queries - these values
    define a grid item's location within the grid; these two terms are shorthand for
    `grid-row-start`, `grid-row-end`, `grid-column-start` and `grid-column-end` respectively.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网格容器被分配，我们就可以为我们的模板指定网格列——分配的`1fr`值代表了网格中每个单元格内容周围的自由空白空间的分数（因此是`fr`单位）。然后我们在两个媒体查询中通过指定`grid-row`或`grid-column`来完成——这些值定义了网格项在网格中的位置；这两个术语是`grid-row-start`、`grid-row-end`、`grid-column-start`和`grid-column-end`的简写。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more detailed explanation of how these terms are used in creating grids,
    refer to the Mozilla Developer Network articles available at [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些术语在创建网格中的使用方式的更详细解释，请参阅Mozilla开发者网络上的文章，网址为[https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout)。
- en: Taking it further
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: Learning a new technology is like putting on new clothes; at some point, we
    will outgrow those clothes, or they no longer present the appeal that attracted
    us to them at the time of purchase.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 学习新技术就像穿上新衣服；在某个时候，我们会长大，或者它们不再具有吸引我们购买时的吸引力。
- en: It's at times like this we need to progress onto something more advanced or
    with additional functionality, otherwise our development will come to a standstill!
    Thankfully, there are literally dozens of options available online that we can
    explore—one might be forgiven for thinking that there are too many and where does
    one start?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的时候，我们需要进步到更高级或具有额外功能的东西，否则我们的开发将停滞不前！幸运的是，在线上有数十种我们可以探索的选项——人们可能会原谅我们认为有太多选择，不知道从哪里开始？
- en: A great starting point is a responsive framework such as Bootstrap or Unsemantic;
    these have been made to improve the usability and help speed up the process of
    development. These frameworks were introduced with the aim of providing a grid
    or foundation for rapid prototyping of the various mobile functionalities, layouts
    which allow the designers and developers to better make use of their development
    time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的起点是一个响应式框架，比如Bootstrap或Unsemantic；这些框架旨在提高可用性，并帮助加快开发过程。这些框架的推出旨在为各种移动功能、布局的快速原型设计提供网格或基础，使设计师和开发人员能更好地利用他们的开发时间。
- en: 'This is just one part of what is available to help you along, let''s briefly
    cover a few ideas that might serve as somewhere to start:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是可用于帮助您的一部分，让我们简要地介绍一些可能作为起点的想法：
- en: '**Bootstrap** is downloadable from [http://getbootstrap.com/](http://getbootstrap.com/),
    this veteran grid system was first created by Facebook, before becoming a standalone
    product in its own right.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bootstrap**可以从[http://getbootstrap.com/](http://getbootstrap.com/)下载，这个老牌网格系统最初是由Facebook创建的，后来成为了一个独立的产品。'
- en: If you want to explore something that is more than just a framework, then **Responsive
    Grid System** might be an option; it's available from [http://www.responsivegridsystem.com/](http://www.responsivegridsystem.com/),
    with a SASS version available for those who use that CSS preprocessor.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想探索更多不仅仅是一个框架的东西，那么**Responsive Grid System**可能是一个选择；它可以从[http://www.responsivegridsystem.com/](http://www.responsivegridsystem.com/)获得，对于那些使用CSS预处理器的人来说，还有一个SASS版本可用。
- en: Instead of simply downloading a framework, how about generating one online?
    For this, try **Responsify.it** ([http://responsify.it](http://responsify.it/))
    and Gridpak.com ([http://gridpak.com](http://gridpak.com/)) as possible contenders.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其简单地下载一个框架，不如在线生成一个？为此，可以尝试**Responsify.it** ([http://responsify.it](http://responsify.it/))
    和Gridpak.com ([http://gridpak.com](http://gridpak.com/))。
- en: We used a minimal Grid system earlier in the form of Gridfy, there are others
    available, if this one is not to your liking. As an example, try Gridly, which
    can be downloaded from [http://ionicabizau.github.io/gridly/example/](http://ionicabizau.github.io/gridly/example/).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前在Gridfy中使用了一个最小的网格系统，还有其他可用的选项，如果这个选项不合你的口味。例如，尝试一下Gridly，可以从[http://ionicabizau.github.io/gridly/example/](http://ionicabizau.github.io/gridly/example/)下载。
- en: It's worth noting that not every Grid system is available as a standalone—some
    form part of a component library. A good example is **Formstone**; its grid system
    is available from [https://formstone.it/components/grid/](https://formstone.it/components/grid/).
    For those of you who use the Less CSS preprocessor, this grid comes with a version
    that can be used with this tool.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，并非每个网格系统都可以作为独立的存在——有些是组件库的一部分。一个很好的例子是**Formstone**；它的网格系统可以从[https://formstone.it/components/grid/](https://formstone.it/components/grid/)获取。对于那些使用Less
    CSS预处理器的人来说，这个网格系统有一个可以与这个工具一起使用的版本。
- en: Staying with the theme of component libraries, why not have a look at **Metro
    UI**? This library, available from [http://metroui.org.ua/grid.html](http://metroui.org.ua/grid.html),
    even has backing from Microsoft; it does require jQuery though!
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续讨论组件库的主题，为什么不看看**Metro UI**？这个库可以从[http://metroui.org.ua/grid.html](http://metroui.org.ua/grid.html)获取，甚至得到了微软的支持；不过它需要jQuery！
- en: Some of you might have heard of the 960.gs grid system, which was available
    a few years ago - it has been replaced by **Unsemantic**, which is available from
    [http://unsemantic.com/](http://unsemantic.com/).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你们中的一些人可能听说过960.gs网格系统，它在几年前是可用的——现在已经被**Unsemantic**取代，可以从[http://unsemantic.com/](http://unsemantic.com/)获取。
- en: We covered the use of flexbox as a technology for creating grid-based layouts;
    as a start point, why not have a look at the PureCSS library? This is available
    at [http://purecss.io](http://purecss.io/); it's a good example of using flexbox
    to produce clean layouts without too much fuss.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了使用flexbox作为创建基于网格的布局的技术；作为一个起点，为什么不看看PureCSS库？这可以在[http://purecss.io](http://purecss.io/)找到；这是使用flexbox来产生清晰布局的一个很好的例子，而不需要太多麻烦。
- en: 'As developers, this is one area of responsive design where we are spoilt for
    choice; the great thing about open source software is that if a framework we choose
    isn''t right, then we can always try another! To help us make the decision, there
    are a few questions we can ask ourselves:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，这是响应式设计的一个领域，我们有很多选择；开源软件的好处在于，如果我们选择的框架不合适，我们总是可以尝试另一个！为了帮助我们做出决定，我们可以问自己几个问题：
- en: Do you need a version that works with a CSS preprocessor? Although preprocessed
    CSS is a superset of standard CSS, there are grid systems available that are specifically
    built from a preprocessing technology such as SASS or PostCSS. This is easier
    than trying to convert finished CSS into something that can be compiled by our
    processor.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否需要一个与CSS预处理器兼容的版本？尽管预处理的CSS是标准CSS的超集，但有一些网格系统是专门从SASS或PostCSS等预处理技术构建的。这比尝试将成品CSS转换为可以被我们的处理器编译的东西要容易得多。
- en: How complex is your site? Is it a single page *calling card* affair, or something
    substantially more complex? There is clearly no point in burdening a simple site
    with a complex grid arrangement; equally if we're building a complex site, then
    our chosen grid system must be up to par.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的网站有多复杂？它是一个单页的“名片”式网站，还是更复杂的东西？显然，给一个简单的网站加上复杂的网格布局是没有意义的；同样，如果我们正在构建一个复杂的网站，那么我们选择的网格系统必须达到要求。
- en: Is browser support an issue? If we can forgo support for some of the older browsers
    (and particularly below IE8), then choosing a CSS-only option is preferable to
    one dependent on using jQuery. The same principle applies if we already have to
    use more than just the occasional external resource. There is no need to add in
    a plugin if using CSS is sufficient.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器支持是否是一个问题？如果我们可以放弃对一些旧版本浏览器的支持（特别是IE8以下），那么选择仅依赖CSS的选项比依赖jQuery的选项更可取。如果我们已经不得不使用不止偶尔的外部资源，同样的原则也适用。如果使用CSS就足够了，就没有必要添加插件。
- en: Does your site need to make use of UI components which need to be styled using
    a themed library? If so, check the library; it may already have a grid system
    built in that we can use.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的网站是否需要使用需要使用主题库进行样式化的UI组件？如果是这样，检查一下库；它可能已经内置了一个我们可以使用的网格系统。
- en: The key here is that we shouldn't simply choose the first available option to
    us, but carefully consider what is available and pick something that satisfies
    our requirements where possible. Any styling can of course be overridden—the trick
    here is to choose the right one, so that overriding is minimal or not required
    for our site.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们不应该简单地选择第一个可用的选项，而是仔细考虑可用的内容，并选择尽可能满足我们要求的东西。当然，任何样式都可以被覆盖——关键在于选择合适的样式，以便最小化或不需要覆盖我们的网站。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Constructing the layout grid for any site is key critical to its success; traditionally,
    we may have done this first, but in the world of responsive design, content comes
    first! Throughout the course of this chapter, we've covered a few topics to help
    get you started, so let's take a moment to recap what we have learned.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为任何网站构建布局网格对其成功至关重要；传统上，我们可能首先做这个，但在响应式设计的世界中，内容是第一位的！在本章的过程中，我们已经涵盖了一些主题，帮助你入门，所以让我们花点时间回顾一下我们学到了什么。
- en: We kicked off with an introduction to flexible grid layouts, with a mention
    that we may have to change our design process to facilitate creating responsive
    grids. We then moved onto to explore the different types of layout we can use,
    and how responsive layouts compare to these different types.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从灵活的网格布局入手，提到我们可能需要改变我们的设计流程来促进创建响应式网格。然后我们继续探讨了我们可以使用的不同类型的布局，以及响应式布局与这些不同类型的比较。
- en: Next up, we began on the most important part of our layout—setting the available
    viewport; this controls how much is visible at any one point. We covered the need
    to set a viewport directive in our code, so that content is correctly displayed;
    we examined how not providing the directive can have a negative impact on the
    appearance of our content! In addition, we covered some of the additional properties
    and units of value we can use, along with balancing the viewport size against
    user experience.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始布局中最重要的部分——设置可用的视口；这控制着任何时候可见的内容量。我们讨论了在我们的代码中设置视口指令的必要性，以便内容能够正确显示；我们还研究了不提供指令可能对内容外观产生负面影响！此外，我们还介绍了一些额外的属性和值单位，以及如何平衡视口大小和用户体验。
- en: We then moved onto exploring the benefits of flexible grid layouts, before taking
    a look at how they work in more detail; we then created a simple demo using a
    prebuilt grid system available from the Internet.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始探讨灵活的网格布局的好处，然后更详细地了解它们的工作原理；然后我们使用从互联网上获得的预构建网格系统创建了一个简单的演示。
- en: Moving on, we then took a look at using flexbox as a technology; we explored
    it through a simple demo, before dissecting some of the issues with using flexbox.
    We then saw how a replacement is in the works. We rounded out the chapter with
    a demo to explore how it can be activated today, and that it is simpler to develop
    solutions for it once it becomes a mainstream standard.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们开始研究flexbox作为一种技术；我们通过一个简单的演示来探索它，然后剖析了使用flexbox时的一些问题。然后我们看到正在研发一种替代方案。我们以一个演示来结束本章，探讨了如何在今天激活它，以及一旦它成为主流标准，为其开发解决方案会更加简单。
- en: Now that we have our layout in place, it's time to move on. We need to start
    adding content! It's assumed that text would be added by default, but what about
    media? How do we make it responsive? We'll answer these questions, and more, in
    the next chapter, when we take a look at adding responsive media to our pages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的布局已经就位，是时候继续了。我们需要开始添加内容！默认情况下会添加文本，但是媒体呢？我们如何使其响应式？我们将在下一章中回答这些问题，以及更多内容，当我们看看如何向我们的页面添加响应式媒体时。
