- en: Chapter 3. Adding Responsive Media
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。添加响应式媒体
- en: '*A picture paints a thousand words...*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*一图胜千言……*'
- en: A key element of any website is a visual content; after all, text will become
    very repetitive and dull, without adding some form of color!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网站的关键元素是视觉内容；毕竟，没有添加一些形式的颜色，文本会变得非常重复和乏味！
- en: Adding media not only gives color to a site, but can serve as a vital tool to
    show potential customers what a product looks like or how we should use it. In
    fact, sales can go up based purely on being able to see a product being demonstrated.
    With the advent of mobile devices, it is more important that we not only add media,
    but also ensure it works well on a range of different devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 添加媒体不仅为网站增添色彩，而且可以作为展示潜在客户产品外观或如何使用产品的重要工具。事实上，销售额可能仅基于能够看到产品演示而上升。随着移动设备的出现，更重要的是我们不仅要添加媒体，还要确保它在各种不同设备上运行良好。
- en: 'Throughout the course of this chapter, we will explore different ways of adding
    media to our pages, and see how easy it is to make it respond to any changes in
    available screen size. In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们将探讨不同的方法来向我们的页面添加媒体，并看看如何轻松地使其响应可用屏幕大小的任何更改。在本章中，我们将涵盖以下主题：
- en: Understanding the basics of adding images using `<picture>`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解使用`<picture>`添加图像的基础知识
- en: Exploring alternatives to adding images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索添加图像的替代方法
- en: Making video and audio content responsive
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使视频和音频内容响应
- en: Adjusting text to fit automatically on the screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动调整文本以适应屏幕
- en: Curious? Let's get cracking!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇吗？让我们开始吧！
- en: Making media responsive
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使媒体具有响应性
- en: Our journey through the basics of adding responsive capabilities to a site has
    so far touched on how we make our layouts respond automatically to changes; it's
    time for us to do the same to media!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在基本的响应能力上的旅程已经涉及到了如何使我们的布局自动响应变化；现在是时候对媒体做同样的事情了！
- en: If your first thought is that we need lots of additional functionality to make
    media responsive, then I am sorry to disappoint; it's much easier, and requires
    zero additional software to do it! Yes, all we need is just a text editor and
    a browser; I'll be using my favorite editor, Sublime Text, but you can use whatever
    works for you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的第一个想法是我们需要大量的额外功能来使媒体响应，那么我很抱歉让您失望；这要容易得多，而且不需要额外的软件来完成！是的，我们只需要一个文本编辑器和一个浏览器；我将使用我最喜欢的编辑器Sublime
    Text，但您可以使用任何适合您的工具。
- en: Over the course of this chapter, we will take a look in turn at images, videos,
    audio, and text, and we'll see how with some simple changes, we can make each
    of them responsive. Let's kick off our journey, first with a look at making image
    content responsive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们将依次查看图像、视频、音频和文本，并看看通过一些简单的更改，我们可以使每个内容都具有响应性。让我们开始我们的旅程，首先看看如何使图像内容具有响应性。
- en: Creating fluid images
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建流体图像
- en: It is often said that *images speak a thousand words*. We can express a lot
    more with media than we can using words. This is particularly true for websites
    selling products; a clear, crisp image clearly paints a better picture than a
    poor quality one!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 常常说*图像胜过千言万语*。我们可以用媒体表达的东西比用文字表达的要多得多。对于销售产品的网站来说，这一点尤为真实；清晰、鲜明的图像比质量差的图像更能清晰地展现产品的形象！
- en: 'When constructing responsive sites, we need our images to adjust in size automatically.
    To see why this is important, go ahead and extract `coffee.html` from a copy of
    the code download that accompanies this book and run it in a browser. Try resizing
    the window. We should see something akin to this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建响应式网站时，我们需要我们的图像自动调整大小。要了解为什么这很重要，请从随附本书的代码下载中提取`coffee.html`并在浏览器中运行它。尝试调整窗口大小。我们应该看到类似于这样的东西：
- en: '![Creating fluid images](img/image_03_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: ！[创建流体图像]（img / image_03_001.jpg）
- en: 'It doesn''t look great, does it? Leaving aside my predilection for nature''s
    finest bean drink, we can''t have images that don''t resize properly, so let''s
    take a look at what is involved to make this happen:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不太好，是吗？撇开我对大自然最好的豆类饮料的偏爱，我们不能有不能正确调整大小的图像，所以让我们看看需要做些什么：
- en: Go ahead and extract a copy of `coffee.html` and save it to our project area.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续提取`coffee.html`的副本，并将其保存到我们的项目区域。
- en: We also need our image—this is in the `img` folder; save a copy to the `img`
    folder in our project area.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要我们的图像-这是在`img`文件夹中；将副本保存到我们项目区域中的`img`文件夹中。
- en: 'In a new text file, add the following code, saving it as `coffee.css`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的文本文件中，添加以下代码，并将其保存为`coffee.css`：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Revert to `coffee.html`. You will see line 6 is currently commented out; remove
    the comment tags.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复到`coffee.html`。您会看到第6行目前已被注释掉；删除注释标记。
- en: Save the file, then preview it in a browser. If all is well, we will still see
    the same image as before, but this time try resizing it.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后在浏览器中预览。如果一切顺利，我们仍然会看到与以前相同的图像，但这次尝试调整大小。
- en: 'This time around, our image grows or shrinks automatically, depending on the
    size of our browser window:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们的图像会根据浏览器窗口的大小自动增长或缩小：
- en: '![Creating fluid images](img/image_03_002.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: ！[创建流体图像]（img / image_03_002.jpg）
- en: 'Although our image does indeed fit better, there are a couple of points we
    should be aware of when using this method:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的图像确实更合适，但在使用此方法时，我们应该注意以下几点：
- en: Sometimes you might see `!important` set as a property against the `height`
    attribute when working with responsive images; this isn't necessary, unless you're
    setting sizes in a site where image sizes may be overridden at a later date
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时在使用响应式图像时，您可能会看到`!important`设置为`height`属性的属性；这并不是必要的，除非您在以后可能会覆盖图像大小的站点中设置大小
- en: We've set `max-width` to `100%` as a minimum; you may need to set a `width`
    value too, to be sure that your images do not become too big and break your layout
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`max-width`设置为`100％`作为最小值；您可能还需要设置`width`值，以确保您的图像不会变得太大并破坏布局
- en: This is an easy technique to use, although there is a downside that can trip
    us up—spot what it is? If we use a high-quality image, its file size will be hefty—we
    can't expect users of mobile devices to download it, can we?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种易于使用的技术，尽管有一个可能会让我们出错的缺点——你能发现是什么吗？如果我们使用高质量的图像，它的文件大小将非常大——我们不能指望移动设备的用户下载它，对吧？
- en: Don't worry though - there is a great alternative that has quickly gained popularity
    among browsers; we can use the `<picture>` element to control what is displayed,
    depending on the size of the available window. Let's dive in and take a look.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不过不用担心——有一个备受浏览器欢迎的很好的替代方案；我们可以使用`<picture>`元素来控制根据可用窗口大小显示什么。让我们深入了解一下。
- en: Implementing the <picture> element
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`<picture>`元素
- en: 'In a nutshell, responsive images are images that are displayed their optimal
    form on a page, depending on the device your website is being viewed from. This
    can mean several things:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，响应式图像是根据您的网站被查看的设备在页面上显示其最佳形式的图像。这可能意味着几件事情：
- en: You want to show a separate image asset based on the user's physical screen
    size. This might be a 13.5-inch laptop or a 5-inch mobile phone screen.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望根据用户的物理屏幕尺寸显示不同的图像资源。这可能是13.5英寸的笔记本电脑或5英寸的手机屏幕。
- en: You want to show a separate image based on the resolution of the device or using
    the device-pixel ratio (which is the ratio of device pixels to CSS pixels).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望根据设备的分辨率或使用设备像素比（即设备像素与CSS像素的比率）显示不同的图像。
- en: You want to show an image in a specified image format (WebP, for example) if
    the browser supports it.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望在浏览器支持的情况下以指定的图像格式（例如WebP）显示图像。
- en: Traditionally, we might have used simple scripting to achieve this, but it is
    at the risk of potentially downloading multiple images or none at all, if the
    script loads after images have loaded, or if we don't specify any image in our
    HTML and want the script to take care of loading images.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们可能会使用简单的脚本来实现这一点，但这样做可能会有潜在的风险，可能会下载多个图像，或者如果脚本在图像加载后加载，或者如果我们在HTML中没有指定任何图像并且希望脚本负责加载图像，那么可能根本不会下载任何图像。
- en: 'We clearly need a better way to manage responsive images! A relatively new
    tag for HTML5 is perfect for this job: `<picture>`. We can use this in one of
    three different ways, depending on whether we want to resize an existing image,
    display a larger one, or show a high-resolution version of the image. The recommended
    way to approach this is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然需要一种更好的方式来管理响应式图像！HTML5中一个相对较新的标签非常适合这项工作：`<picture>`。我们可以以三种不同的方式之一使用它，取决于我们是想要调整现有图像的大小，显示一个更大的图像，还是显示图像的高分辨率版本。建议的方法是：
- en: '`srcset` attribute'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`srcset`属性'
- en: '`sizes` attribute'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sizes`属性'
- en: '`picture` element'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`picture`元素'
- en: We'll explore all three in detail; let's start with implementing the `srcset`
    attribute in a standard `<img>` tag, before moving on to using the `<picture>`
    element.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨这三种方法；让我们先从在标准的`<img>`标签中实现`srcset`属性开始，然后再使用`<picture>`元素。
- en: Using the srcset attribute
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`srcset`属性
- en: A key benefit of using the `<picture>` element is using the srcset attribute
    to select any one of several images, based on whether we want to display higher
    resolution versions or different sizes of the same image in different viewports.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<picture>`元素的一个关键好处是使用`srcset`属性来选择多个图像中的任何一个，取决于我们是想在不同视口中显示更高分辨率的版本还是不同尺寸的相同图像。
- en: 'Support for this in browsers is very good, with only Opera Mini and up to IE11
    not wanting to join the party:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器对此的支持非常好，只有Opera Mini和IE11不愿加入这个行列：
- en: '![Using the srcset attribute](img/image_03_003.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用`srcset`属性](img/image_03_003.jpg)'
- en: 'Source: [http://caniuse.com/#search=srcset](http://caniuse.com/#search=srcset)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://caniuse.com/#search=srcset](http://caniuse.com/#search=srcset)
- en: 'To make use of this `srcset` attribute, we need to avail ourselves of sufficient
    different images, then specify what should be displayed at the appropriate trigger
    point, as shown in this example, based on defining the `device-pixel` ratio:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`srcset`属性，我们需要提供足够多的不同图像，然后根据定义的`设备像素`比例在适当的触发点指定应该显示什么，就像这个例子中所示：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the `src` attribute acts as fallback image for those browsers that do
    not support `srcset` (although support is now very good!). The `srcset` attribute
    allows us to specify different images to use, either based on the device-pixel
    ratio or the available viewport:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`src`属性充当了那些不支持`srcset`的浏览器的备用图像（尽管现在支持得非常好！）。`srcset`属性允许我们根据设备像素比或可用视口指定不同的图像使用：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, our fallback is `default.png`; however, if the browser being used
    supports `srcset`, then it will display `small.png` at `256w` or `med.png` at
    `511w`. If, however, we wanted to change the size and use different images based
    on the available viewport, then we would have to add an extra attribute—`sizes`.
    It's easy enough to configure, so let's pause for a moment to see what this means
    in practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的备用图像是`default.png`；然而，如果使用的浏览器支持`srcset`，那么它将在`256w`处显示`small.png`或在`511w`处显示`med.png`。然而，如果我们想要改变大小并根据可用视口使用不同的图像，那么我们就需要添加一个额外的属性——`sizes`。配置起来很容易，让我们暂停一下看看这在实践中意味着什么。
- en: Exploring the sizes attribute
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索`sizes`属性
- en: When adding pictures as part of the content on a responsive site, the images
    may each take up 100% of the element width, but the content itself doesn't always
    take 100% of the width of the window! For example, we might set each image element
    to 100% width (so they fill their parent containers), but that the overall content
    on screen only fills 50% of the available screen width.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式网站的内容中添加图片时，每个图像可能会占据元素宽度的100％，但内容本身并不总是占据窗口宽度的100％！例如，我们可能将每个图像元素设置为100％宽度（以便填充其父容器），但屏幕上的整体内容只占可用屏幕宽度的50％。
- en: To overcome this, we need to know the URLs for the various images to use, along
    with the width of each image resource; we can't get this from standard markup
    in the page layout, as images start downloading before CSS is applied.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，我们需要知道各种图像的URL以及每个图像资源的宽度；我们无法从页面布局中的标准标记中获取这些信息，因为图像在应用CSS之前开始下载。
- en: 'Instead, we can simply set suitable widths within our HTML code using the `srcset`
    attribute and suitable width descriptors. This is a little controversial for some,
    as it starts to blur the divide between HTML markup and the CSS presentation layer.
    This aside, let''s take a look at an example of how we can set up the code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以在HTML代码中使用`srcset`属性和适当的宽度描述符来简单设置适当的宽度。对于一些人来说，这有点具有争议，因为它开始模糊HTML标记和CSS呈现层之间的界限。不过，让我们来看一个如何设置代码的例子：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this excerpt, we set a default of 50% or half of the viewport width; the
    browser can then select the appropriate image to display, depending on the available
    width.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个摘录中，我们将默认设置为视口宽度的50%或一半；然后浏览器可以根据可用宽度选择适当的图像来显示。
- en: Manipulating the HTML5 <picture> element
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作HTML5的<picture>元素
- en: 'We''ve covered two key parts of making images responsive, but to bring it all
    together, we can use the HTML5 `<picture>` element, which has garnered good support
    in most browsers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了使图像响应的两个关键部分，但为了将所有内容整合在一起，我们可以使用HTML5的`<picture>`元素，在大多数浏览器中得到了良好的支持：
- en: '![Manipulating the HTML5 <picture> element](img/image_03_004.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![操作HTML5的<picture>元素](img/image_03_004.jpg)'
- en: 'Source: [http://caniuse.com/#search=picture](http://caniuse.com/#search=picture)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://caniuse.com/#search=picture](http://caniuse.com/#search=picture)
- en: 'The `<picture>` element uses this syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`<picture>`元素使用以下语法：'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this extract, we've tied together all of the various attributes we can use
    with the `<picture>` element; in this case, we've specified media queries (one
    of `60rem` and another of `35rem`), and that if our viewport is only 50% or less
    (indicated by the `50vw` value in the code), we display the normal images; if
    it is higher, then we display the high-definition images (as specified by using
    the `100vw` value).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个摘录中，我们将所有可以与`<picture>`元素一起使用的各种属性联系在一起；在这种情况下，我们指定了媒体查询（一个是`60rem`，另一个是`35rem`），如果我们的视口只有50%或更少（代码中的`50vw`值表示），我们显示普通图像；如果更高，那么我们显示高清晰度图像（使用`100vw`值指定）。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will explore how this works in more detail, in *Exploring what happened*,
    later in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更详细地探讨这是如何工作的，*探索发生了什么*。
- en: Putting it all together
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: Now that we've seen all three elements in use, let's pull them together and
    create a simple demo that automatically adjusts which image to use, based on the
    available viewport. For simplicity, we will concentrate just on the image, but
    there is nothing stopping us from developing this further into a full-sized page!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了这三个元素的使用，让我们把它们整合起来，创建一个简单的演示，根据可用视口自动调整要使用的图像。为简单起见，我们将只集中在图像上，但这并不妨碍我们将其进一步发展成一个全尺寸的页面！
- en: Let's make a start. For this demo, I would strongly recommend using Google Chrome
    if you have it installed; its device mode is perfect for this task!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。对于这个演示，我强烈建议使用已安装的Google Chrome；它的设备模式非常适合这个任务！
- en: From a copy of the code download that accompanies this book, go ahead and extract
    copies of the four landscape images, and save them to the `img` folder at the
    root of our project area.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码下载中提取四个横向图片的副本，并将它们保存到项目区域根目录下的`img`文件夹中。
- en: 'Next, fire up your text editor, and add the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开文本编辑器，添加以下代码：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save this as `pictureelement.html` at the root of our project folder.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为`pictureelement.html`，放在我们项目文件夹的根目录下。
- en: Go ahead and preview the results of the file in Google Chrome (or another browser
    if preferred). Make sure you switch on that browser's device/responsive mode.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome（或其他首选浏览器）中预览文件的结果。确保打开浏览器的设备/响应模式。
- en: 'If all is well, we should see the image flip between two similar versions;
    to identify which is which, I''ve added the words **High Resolution Image** on
    one, and **Medium Resolution Image** on the other image used:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们应该看到图像在两个相似版本之间切换；为了识别哪个是哪个，我在一个图像上添加了**高分辨率图像**，在另一个图像上添加了**中分辨率图像**：
- en: '![Putting it all together](img/image_03_005.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容放在一起](img/image_03_005.jpg)'
- en: 'This is the same image, but this time using the medium resolution version:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的图像，但这次使用的是中等分辨率版本：
- en: '![Putting it all together](img/image_03_006.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容放在一起](img/image_03_006.jpg)'
- en: Although this demo may look simple at face value, it is deceptive. We have the
    power to construct some complex statements, which can automatically select an
    image based on a number of criteria! It's important to understand how this demo
    works, as a basis for using it for complex examples. Let's take a moment to explore
    it in more detail.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个演示看起来很简单，但实际上并不简单。我们有能力构建一些复杂的语句，可以根据多个标准自动选择图像！了解这个演示如何工作是很重要的，因为这是使用它进行复杂示例的基础。让我们花点时间更详细地探讨一下。
- en: Exploring what happened
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索发生了什么
- en: 'If we take a look through our picture element demo, the code used may initially
    look complex, but is simpler than it looks! The key to it is understanding each
    part the `<source>` statements and how they interact with each other. Let''s tackle
    the first one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们浏览一下我们的图片元素演示，所使用的代码可能一开始看起来很复杂，但实际上比看起来简单！关键在于理解每个部分`<source>`语句以及它们如何相互作用。让我们先来解决第一个：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this one, we're specifying `high-res-image.png` as our source image; this
    will only be displayed when our browser window is showing a minimum width of `800px`.
    The size of the image will either go to a maximum of `1000px` or `100vw`—the latter
    equivalent to 100% width of the available viewport space. The `738w` against the
    image is just the width of the image specified in the code (1w unit is equal to
    1px, so our image is 738px wide).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们指定`high-res-image.png`作为我们的源图像；这将只在我们的浏览器窗口显示的最小宽度为`800px`时显示。图像的大小将要么达到最大宽度为`1000px`，要么达到`100vw`——后者相当于可用视口空间的100%宽度。图像旁边的`738w`只是代码中指定的图像宽度（1w单位等于1px，因此我们的图像宽度为738px）。
- en: 'Moving onto the second source statement, we find it shows a similar set up,
    but this time the media query is limited to a maximum width of `799px`, and that
    the size of the image will go to `600px` or the full width of the viewport, depending
    on its current size:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 转到第二个来源声明，我们发现它显示了一个类似的设置，但这次媒体查询的最大宽度限制为`799px`，并且图像的大小将变为`600px`或视口的全宽，具体取决于其当前大小：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To finish off the `<picture>` element, we specify `fallback-image.png` as our
    fallback for those browsers that have yet to support this element in HTML5.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成`<picture>`元素，我们指定`fallback-image.png`作为那些尚未支持HTML5中的这个元素的浏览器的备用图像。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We've only scratched the surface of what is possible with the `<picture>` element;
    for more details, take a look at the site maintained by the Responsive Images
    Community Group, hosted at [https://responsiveimages.org/](https://responsiveimages.org/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是挖掘了`<picture>`元素的一部分可能性；有关更多详细信息，请查看响应式图像社区组维护的网站，托管在[https://responsiveimages.org/](https://responsiveimages.org/)。
- en: Creating a real-world example
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个真实的例子
- en: We've explored the theory behind making images responsive with a couple of useful
    techniques; it's time we got practical! The basis for our next demo is going to
    look at making a responsive map using Google Maps.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了使用一些有用的技术使图像具有响应性的理论；现在是时候实践了！我们下一个演示的基础是使用谷歌地图制作一个响应式地图。
- en: 'Responsive maps, I hear you ask? Surely this should come automatically, right?
    Well no, it doesn''t, which makes its use a little awkward on mobile devices.
    Fortunately, we can easily fix this; the great thing about it is that it only
    requires a little additional CSS:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式地图，你会问？这应该是自动的，对吧？好吧，不，它不是，这使得它在移动设备上有点尴尬。幸运的是，我们可以很容易地解决这个问题；它的好处在于它只需要一点额外的CSS：
- en: Let's make a start by browsing to [http://maps.google.com](http://maps.google.com/),
    then entering the zip code of our chosen location; in this instance, I will use
    Packt's UK office, which is B3 2PB.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始浏览[http://maps.google.com](http://maps.google.com/)，然后输入我们选择位置的邮政编码；在这种情况下，我将使用Packt的英国办公室，即B3
    2PB。
- en: Click on the cog, then select **Share and embed** map, as shown in this screenshot:![Creating
    a real-world example](img/image_03_007.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击齿轮图标，然后选择**分享和嵌入**地图，如此屏幕截图所示：![创建一个真实的例子](img/image_03_007.jpg)
- en: In the dialog box that appears, switch to the Embed map tab, then copy the contents
    of the text field starting with `<iframe src=...`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的对话框中，切换到嵌入地图选项卡，然后复制以`<iframe src=...`开头的文本字段的内容。
- en: In a copy of the code download that accompanies this book, extract a copy of
    `googlemaps.html` in your favorite text editor, and add the `<iframe>` code in
    between the google-maps div tags.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书附带的代码下载副本中，从中提取`googlemaps.html`的副本，然后在您喜欢的文本编辑器中添加`<iframe>`代码，放在google-maps
    div标签之间。
- en: 'Next, add the following CSS styling to a new file, saving it as `googlemaps.css`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下CSS样式添加到一个新文件中，并将其保存为`googlemaps.css`：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If all is well, we will see a Google Maps image of Birmingham, with Packt''s
    office marked accordingly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将看到伯明翰的谷歌地图图像，并标出Packt的办公室：
- en: '![Creating a real-world example](img/image_03_008.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个真实的例子](img/image_03_008.jpg)'
- en: At this point, try resizing the browser window. You will see that the map resizes
    automatically; the CSS styling that we've added has overridden the standard styles
    used within Google Maps to make our map responsive and accessible from any device
    we care to use.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，尝试调整浏览器窗口的大小。您会看到地图会自动调整大小；我们添加的CSS样式已经覆盖了Google地图中使用的标准样式，使我们的地图能够在任何设备上进行响应和访问。
- en: Taking things further
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步进行
- en: Throughout the course of this chapter, we've followed the principle of using
    just a browser and text editor to construct our code. This, of course, included
    not downloading anything that was core to creating our examples (save for media
    and content).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们遵循了只使用浏览器和文本编辑器构建我们的代码的原则。当然，这包括不下载任何对创建我们的示例核心的东西（保存媒体和内容）。
- en: 'There will be times though when this approach is not sufficient, we may find
    we need to avail ourselves of additional support to get a job done. Our overriding
    question should always be to check that we really need it, and that we''re not
    just being lazy! If when answering that question, we do find that need additional
    help is needed, then there are a number of sources you can try out, to help take
    things further:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时这种方法并不足够，我们可能会发现需要额外的支持来完成工作。我们的首要问题应该始终是检查我们是否真的需要它，而不仅仅是懒惰！如果在回答这个问题时，我们确实发现需要额外的帮助，那么有许多来源可以尝试，以帮助进一步解决问题：
- en: It goes without saying, but there will come a time when we need to resort to
    using jQuery ([http://www.jquery.com](http://www.jquery.com/)) to help within
    our development. The state of responsive design is such that we should only need
    jQuery to make it easier to reference elements in the DOM, and not to make images
    or content responsive!
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不用说，但是总有一天我们需要使用jQuery（[http://www.jquery.com](http://www.jquery.com/)）来帮助我们的开发。响应式设计的状态是，我们应该只需要jQuery来更容易地引用DOM中的元素，而不是使图像或内容具有响应性！
- en: The Responsive Images site hosted at [https://responsiveimages.org/](https://responsiveimages.org/).
    We covered it briefly at the end of the `<picture>` demo, but it's worth pointing
    it out again. It's a useful compendium of material to help understand and use
    the `<picture>` element.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管在[https://responsiveimages.org/](https://responsiveimages.org/)的响应式图片网站。我们在`<picture>`演示的最后简要介绍了它，但再次指出它是值得的。这是一个有用的资料汇编，可以帮助理解和使用`<picture>`元素。
- en: The developer Scott Jehl created a polyfill for `<picture>`, to extend support
    to those browsers that do not support it natively; you can download it from [https://scottjehl.github.io/picturefill/](https://scottjehl.github.io/picturefill/).
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员Scott Jehl为`<picture>`创建了一个polyfill，以扩展对那些不本地支持它的浏览器的支持；您可以从[https://scottjehl.github.io/picturefill/](https://scottjehl.github.io/picturefill/)下载它。
- en: Are you in need of a responsive carousel? There are plenty available online,
    but one which I've found to work well, is ResponsiveSlides, available from [http://responsiveslides.com/](http://responsiveslides.com/).
    Granted, the project is a few years old, but this particular plugin keeps things
    nice and simple, which is very much in keeping with the theme for this book!
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要一个响应式的轮播图吗？网上有很多可用的，但我发现工作得很好的一个是ResponsiveSlides，可以从[http://responsiveslides.com/](http://responsiveslides.com/)获取。诚然，该项目已经存在几年了，但这个特定的插件保持了简单明了，非常符合本书的主题！
- en: A good example of where responsive capabilities are already present is in using
    the SVG image format. These are effectively vector-based images that we can manipulate
    using CSS; the key benefit though is that SVG images can automatically grow or
    shrink, with no loss of quality. Browser support for the format is excellent,
    although IE (and Edge) both have a couple of quirks that require attention when
    using these browsers (for more details, see [http://caniuse.com/#feat=svg](http://caniuse.com/#feat=svg)).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应能力已经存在的一个很好的例子是使用SVG图像格式。这些实际上是基于矢量的图像，我们可以使用CSS进行操作；然而，SVG图像的关键优势是可以自动增长或缩小，而不会失去质量。浏览器对该格式的支持非常好，尽管IE（和Edge）在使用这些浏览器时有一些需要注意的怪癖（有关更多详细信息，请参见[http://caniuse.com/#feat=svg](http://caniuse.com/#feat=svg)）。
- en: Another idea to try is with responsive icons. A good example that is worth a
    look is the FontAwesome library, available from [http://fontawesome.io/](http://fontawesome.io/).
    These will resize equally as well. In this instance, they would be perfect for
    smaller images, such as credit card icons or shopping baskets on e-commerce sites.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个尝试的想法是使用响应式图标。一个值得一看的好例子是FontAwesome库，可以从[http://fontawesome.io/](http://fontawesome.io/)获取。这些图标也可以等比例调整大小。在这种情况下，它们非常适合较小的图像，比如信用卡图标或电子商务网站上的购物篮。
- en: 'Taking things even further afield, how about support for the WebP image format?
    Yes, this is one that hasn''t gained huge support yet, with it being limited to
    Chrome and Opera at the time of writing. However, when used with the `<picture>`
    element, it shows off a nice trick:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更进一步，如何支持WebP图像格式？是的，这是一个尚未得到广泛支持的格式，在撰写本文时仅限于Chrome和Opera。然而，当与`<picture>`元素一起使用时，它展示了一个不错的技巧：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our example, the browser will check for WebP support, if it can support it,
    it will display the appropriate image in WebP format, depending on what device-pixel-ratio
    is supported on the device being used. If WebP isn't supported, then it will fall
    back to using JPEG (although this could equally have been a different format such
    as PNG).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的例子中，浏览器将检查对WebP的支持，如果支持它，它将根据设备使用的设备像素比显示适当的WebP格式的图像。如果不支持WebP，那么它将退回到使用JPEG（尽管这也可以是不同的格式，比如PNG）。
- en: There are certainly things we can do, once we've become accustomed to working
    with responsive images, and want to graduate away from just using HTML5 and CSS3\.
    It is important to note though, that there are a number of projects operating
    online that aren't listed here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们习惯于使用响应式图片，并希望摆脱仅使用HTML5和CSS3时，我们当然可以做一些事情。但重要的是要注意，有许多在线运行的项目没有在这里列出。
- en: The main reason for this is age—support for responsive images was patchy for
    a while, which meant a number of projects appeared to help provide support for
    responsive images. Support for the `<picture>` and associated elements is getting
    better all of the time, which reduces some of the attraction of these older projects;
    it is worth considering whether it is sensible to use them, or if the impact of
    not using them can be mitigated by changes to the user experience.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要原因是年龄——一段时间内对响应式图片的支持不够完善，这意味着出现了许多项目来帮助提供对响应式图片的支持。对`<picture>`和相关元素的支持正在不断改善，这减少了一些旧项目的吸引力；值得考虑是否明智地使用它们，或者如果不使用它们的影响可以通过改变用户体验来减轻。
- en: Okay, let's move on; time to get a little animated, I think! Alright, that was
    a terrible lead in to our next topic, given that we're going to explore making
    videos responsive. Over the next few pages, we'll see that although some of the
    same principles apply here, there are some bumps along the way, which might impact
    our journey.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续吧；我想是时候稍微动画一下了！好吧，这是一个糟糕的引子，因为我们接下来要探讨如何使视频具有响应性。在接下来的几页中，我们将看到虽然这里也适用一些相同的原则，但途中会有一些颠簸，这可能会影响我们的旅程。
- en: Making video responsive
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使视频具有响应性
- en: 'Flexible videos are somewhat more complex than images. The HTML5 `<video>`
    maintains its aspect ratio just like images and therefore we can apply the same
    CSS principle to make it responsive:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活的视频比图像稍微复杂一些。HTML5的`<video>`保持其纵横比，就像图像一样，因此我们可以应用相同的CSS原则使其具有响应性：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Until relatively recently, there have been issues with HTML5 video—this is
    mainly due to split support for the codecs required to run HTML video. The CSS
    required to make a HTML5 video is very straightforward, but using it directly
    presents a few challenges:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 直到相对最近，HTML5视频一直存在问题——这主要是由于对运行HTML视频所需的编解码器的支持分裂。制作HTML5视频所需的CSS非常简单，但直接使用它会带来一些挑战：
- en: Hosting video is bandwidth intensive and expensive
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管视频需要大量带宽和昂贵
- en: Streaming requires complex hardware support in addition to video
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流媒体需要复杂的硬件支持以及视频
- en: It is not easy to maintain a consistent look and feel across different formats
    and platforms
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同格式和平台上保持一致的外观和感觉并不容易
- en: For many, a better alternative is to host the video through a third-party service
    such as YouTube. There is a caveat that they would be in control of your video
    content; if this isn't an issue, we can let them worry about bandwidth issues
    and providing a consistent look and feel; we just have to make it fit on the page!
    This requires a little more CSS styling to make it work, so let's explore what
    is involved.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多人来说，一个更好的选择是通过YouTube等第三方服务托管视频。有一个警告，他们将控制您的视频内容；如果这不是问题，我们可以让他们担心带宽问题和提供一致的外观和感觉；我们只需要让它适应页面！这需要一些额外的CSS样式来使其工作，所以让我们探讨一下涉及的内容。
- en: Embedding externally hosted videos
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入外部托管的视频
- en: To embed those videos, we need to use iframes, which unfortunately do not maintain
    aspect ratio by default; we can work around this with a CSS solution by Thierry
    Koblentz.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要嵌入这些视频，我们需要使用iframe，不幸的是，默认情况下它们不保持纵横比；我们可以通过Thierry Koblentz的CSS解决方案来解决这个问题。
- en: 'Let''s for argument''s sake say that we have a YouTube video, such as this
    one, titled *The Big Buck Bunny*, by the Blender Foundation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个YouTube视频，比如这个，名为*大野兔*，由Blender Foundation制作：
- en: '![Embedding externally hosted videos](img/image_03_009.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入外部托管的视频](img/image_03_009.jpg)'
- en: (c) Blender Foundation | [www.bigbuckbunny.org](http://www.bigbuckbunny.org)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: (c) Blender Foundation | [www.bigbuckbunny.org](http://www.bigbuckbunny.org)
- en: 'Looks okay, doesn''t it? Granted, we can''t immediately tell it is a video
    from YouTube, but this next screenshot clearly shows it is:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来还不错，是吧？当然，我们不能立即看出这是来自YouTube的视频，但下一个屏幕截图清楚地显示了它是：
- en: '![Embedding externally hosted videos](img/image_03_010.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入外部托管的视频](img/image_03_010.jpg)'
- en: Hold on; that doesn't look right, does it? The screenshot was taken in Google,
    but set to emulate the screen estate of a Galaxy S5 mobile phone, but it clearly
    shows that the video is not responsive.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 等等；那看起来不对，是吧？这个屏幕截图是在Google中拍摄的，但设置为模拟Galaxy S5手机的屏幕空间，但它清楚地显示视频不是响应式的。
- en: To see this in action, extract a copy of `youtube.html` from the code download
    that accompanies this book to our project area, then run it in a browser. Activate
    your browser's responsive mode (or device mode, depending on browser) and resize
    the screen to 360px by 640px. You will soon see how it doesn't resize well!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这一点，从本书附带的代码下载中提取`youtube.html`的副本到我们的项目区域，然后在浏览器中运行它。激活浏览器的响应式模式（或设备模式，取决于浏览器），并将屏幕调整为360px
    x 640px。您很快就会看到它的调整效果不好！
- en: How do we fix this?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？
- en: 'The trick is to create a box with a proper aspect ratio, say 4:3 or 16:9 (through
    zero height and bottom padding in %), and then fit the video and stretch it inside
    the box up to the box dimensions by positioning it absolutely with respect to
    the box. The bottom padding acts as the width that helps to maintain the aspect
    ratio. Let''s alter our code to fix this issue:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是创建一个具有适当纵横比的框，比如4:3或16:9（通过零高度和底部填充百分比），然后将视频放入框内，并通过绝对定位使其在框内拉伸到框的尺寸。底部填充作为帮助保持纵横比的宽度。让我们修改我们的代码来解决这个问题：
- en: 'In `youtube.html`, add this link within the `<head>` section:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`youtube.html`中，在`<head>`部分中添加此链接：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Further down, alter the code as shown:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面，按照所示修改代码：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Save the file. Switch to a new file, then add the following code and save it
    as `youtube.css` within the `css` subfolder of our project area:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。切换到一个新文件，然后添加以下代码，并将其保存为`youtube.css`，放在我们项目区域的`css`子文件夹中：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A word of note—setting `height: 0` ensures the element is present within the
    DOM so that older browsers can format the inner box properly.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '一句话注意——设置`height: 0`确保元素存在于DOM中，以便旧版浏览器可以正确格式化内部框。'
- en: Save the file, revert back to your browser, and re-enable its responsive (or
    device) mode if it is not already switched on.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，返回到浏览器，并重新启用其响应式（或设备）模式，如果尚未打开。
- en: Try previewing the results now; if all is well, we should see something akin
    to this. It uses the same Galaxy S5 size settings, but this time zoomed in to
    150% for clarity:![Embedding externally hosted videos](img/image_03_011.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试预览结果；如果一切正常，我们应该看到类似于这样的东西。它使用相同的Galaxy S5大小设置，但这次放大到150%以获得清晰度：![嵌入外部托管的视频](img/image_03_011.jpg)
- en: This looks much better! With some simple styling, we have the best of both worlds;
    we can let YouTube do all the heavy lifting while we concentrate on making our
    video available from our site on multiple devices. The CSS we used forces all
    of the video content to the full width of the `.video-box-wrapper` container,
    which in turn is positioned relative to its normal position. We then add `56.25%`
    to the bottom to maintain the classic 16:9 aspect ratio and provide a little extra
    padding at the top so it doesn't appear to go off screen!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来好多了！通过一些简单的样式，我们可以兼顾两全；我们可以让YouTube来处理所有繁重的工作，而我们专注于让我们的视频在多个设备上从我们的网站上可用。我们使用的CSS强制所有视频内容适应`.video-box-wrapper`容器的全宽度，然后相对于其正常位置进行定位。然后我们在底部添加了`56.25%`以保持经典的16:9纵横比，并在顶部提供了一些额外的填充，以便它不会出现在屏幕外！
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Question**: How did we arrive at 56.25%? This is simply 9 divided by 16 (the
    aspect ratio), which is 0.5625 or 56.25%.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：我们是如何得到56.25%的？这只是9除以16（纵横比），即0.5625或56.25%。'
- en: There will be occasions, though, when we have to host our own videos; this might
    be for controlling visibility or preventing adverts from being played, if we were
    to host it externally. To achieve this, we can use the now current HTML5 `<video>`
    element to render content on a page; let's take a look and see how this works
    in action.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们必须托管自己的视频；这可能是为了控制可见性或防止在外部托管时播放广告。为了实现这一点，我们可以使用当前的HTML5`<video>`元素在页面上呈现内容；让我们看看这在实际中是如何工作的。
- en: Introducing the new HTML5 video element
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍新的HTML5视频元素
- en: 'If hosting videos on an external source is not possible, then we must host
    locally; for this, we can use the native HTML5 video tag, which looks something
    like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在外部来源托管视频不可能，那么我们必须本地托管；为此，我们可以使用原生的HTML5视频标签，看起来像这样：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the past, codec support for the HTML5 element has been split across each
    platform; in 2015, Firefox added support for H.264 to its browsers across all
    platforms, which goes a long way to rationalize support for HTML5 video. At present,
    support for the two formats (MP4 and WebM) is good, but not 100% across all browsers
    – this screenshot indicates the current state of play for desktop and mobile browsers
    for the MP4 format:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，HTML5元素的编解码器支持在每个平台上都有所不同；2015年，Firefox在所有平台的浏览器中添加了对H.264的支持，这在很大程度上推动了对HTML5视频的支持。目前，对于这两种格式（MP4和WebM）的支持情况良好，但并非所有浏览器都支持100%
    - 此截图显示了桌面和移动浏览器对MP4格式的当前状态：
- en: '![Introducing the new HTML5 video element](img/image_03_012.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![介绍新的HTML5视频元素](img/image_03_012.jpg)'
- en: 'Source: CanIuse.com'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：CanIuse.com
- en: 'In contrast, support for the WebM format is not quite so complete:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，对于WebM格式的支持并不是那么完整：
- en: '![Introducing the new HTML5 video element](img/image_03_013.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![介绍新的HTML5视频元素](img/image_03_013.jpg)'
- en: 'Source: CanIuse.com'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：CanIuse.com
- en: In reality, the only format we need to worry about using is MP4; we can use
    WebM format if desired. If we do so, then it must come first in the `<source>`
    list; otherwise, the browser will pick the first available supported format (in
    this case, MP4) and not use WebM!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们唯一需要担心使用的格式是MP4；如果需要，我们可以使用WebM格式。如果这样做，那么它必须在`<source>`列表中排在第一位；否则，浏览器将选择第一个可支持的格式（在这种情况下是MP4），而不使用WebM！
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Before continuing, I would strongly recommend making sure you have Google Chrome
    or Firefox installed - WebM video will work in IE9 or above, but not without adding
    codec support for the format!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我强烈建议确保你已经安装了Google Chrome或Firefox - WebM视频将在IE9或更高版本中工作，但如果没有为该格式添加编解码器支持，就无法使用！
- en: Now that we've been introduced, let's move on and put it into practice, with
    a simple demo to illustrate how the `<video>` element works in action.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了，让我们继续并将其付诸实践，用一个简单的演示来说明`<video>`元素是如何运作的。
- en: Embedding HTML5 video content
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入HTML5视频内容
- en: 'If our requirements are such that we have to host a video ourselves, then implementing
    it using the HTML5 standard tags is very easy; it consists of setting any number
    of different sources within the `<video>` tags so that we can play the same video
    using the supported format for that browser. Let''s dive in and take a look at
    how we do it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的要求是必须自己托管视频，那么使用HTML5标准标签实现它非常容易；它包括在`<video>`标签中设置任意数量的不同来源，以便我们可以使用该浏览器支持的格式播放相同的视频。让我们深入了解一下我们是如何做到的：
- en: We'll start by extracting copies of the following, from the code download that
    accompanies this book - the `video` folder and `html5video.html`. Save them to
    the root of our project folder.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从随本书附带的代码下载中提取以下内容的副本 - `video`文件夹和`html5video.html`。将它们保存到我们项目文件夹的根目录。
- en: 'In a new file, go ahead and add these styles; save the file as `html5video.css`
    in the `css` subfolder of our project area:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，继续添加这些样式；将文件保存为`html5video.css`，放在我们项目区域的`css`子文件夹中：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Try previewing the results in a browser. If all is well, we should see something
    akin to this (screenshot taken from Chrome):'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在浏览器中预览结果。如果一切正常，我们应该会看到类似于这样的东西（来自Chrome的截图）：
- en: '![Embedding HTML5 video content](img/image_03_014.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入HTML5视频内容](img/image_03_014.jpg)'
- en: The result looks perfect—the question is, which version of our video is being
    used? One way to find out is to right-click on the video, while it is still playing,
    then click on **Save video as...**. If all is well, we should see a **Save As**
    dialog box open, ready to save the WebM format if we're using FireFox, Chrome,
    or Opera; otherwise it will be MP4 (if using IE).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来完美 - 问题是，我们使用的是哪个版本的视频？找出的一种方法是右键单击视频，当它仍在播放时，然后单击**另存为...**。如果一切正常，我们应该会看到一个**另存为**对话框打开，准备保存WebM格式（如果使用FireFox，Chrome或Opera）；否则将是MP4（如果使用IE）。
- en: Exploring what happened
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索发生了什么
- en: The real question, though, is not so much how does it all work, but if it is
    responsive?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，真正的问题不是它是如何工作的，而是它是否是响应式的？
- en: 'The answer is yes; our use of the HTML5`<video>` tags mean that we can select
    any number of different video formats to use; the browser will simply choose the
    first available that it is able to play. The order is critical though:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的；我们使用HTML5`<video>`标签意味着我们可以选择任意数量的不同视频格式来使用；浏览器将简单地选择它能够播放的第一个可用格式。但顺序很重要：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we were to swap it around so that MP4 is first, then WebM will be ignored
    for almost all browsers, as MP4 can be played in almost all of the browsers!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们交换顺序，让MP4排在第一位，那么WebM将被几乎所有浏览器忽略，因为几乎所有浏览器都可以播放MP4！
- en: 'The real magic lies not in the use of a specific video format, but in the CSS
    rule we''ve created:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的魔力不在于使用特定的视频格式，而在于我们创建的CSS规则：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our use of percentage values means that it will automatically scale up or down
    when our window is resized; the maximum size of the video is constrained by the
    video's dimensions, not other elements on screen. Of course, we may decide to
    host the video within a parent container; the video will fill that container,
    but the parent may only stretch over part of the site.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用百分比值意味着当我们的窗口调整大小时，它会自动缩放；视频的最大尺寸受到视频尺寸的限制，而不是屏幕上的其他元素。当然，我们可以决定将视频托管在父容器中；视频将填充该容器，但父容器可能只会延伸到站点的一部分。
- en: Building a practical example
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个实际的例子
- en: If you spend any time on the Internet, it's possible you've come across sites
    where the developer hasn't used images as a background, but *video*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在互联网上花费了一些时间，可能会遇到一些开发者没有使用图像作为背景，而是*视频*的网站。
- en: This isn't entirely new as a concept; it's been around for a couple of years
    now. If done with care, it can work very well. It's a perfect candidate for making
    full-size video as a responsive background. The great thing about it is that we
    can make it responsive using pure CSS. That's right, no need for any JavaScript.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个全新的概念；它已经存在了几年。如果小心处理，它可以运行得非常好。它是制作全尺寸视频作为响应式背景的完美候选者。它的好处是我们可以使用纯CSS使其响应。没错，不需要任何JavaScript。
- en: For our next demo, we'll take a break from creating content. This time around,
    we'll run the demo from the code download that accompanies this book, and take
    a look at the code in more detail later in the demo. We'll be using videos from
    the Big Buck Bunny project, created by the Blender Foundation as our background;
    over this, we'll overlay a simple block of sample text, generated using the Lorem
    Ipsum generator.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个演示，我们将暂停创建内容。这一次，我们将从附带本书的代码下载中运行演示，并稍后更详细地查看代码。我们将使用Blender基金会的Big
    Buck Bunny项目的视频作为我们的背景；在此之上，我们将叠加一个使用Lorem Ipsum生成器生成的简单文本块。
- en: 'To see this in action, go ahead and run the `fullscreen .html` demo from a
    copy of the code download that accompanies this book. If all is well, you will
    see the video play behind a simple `<div>` with text:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此示例，请继续运行附带本书的代码下载中的`fullscreen .html`演示。如果一切正常，您将看到视频在一个简单的`<div>`后面播放，上面有文本：
- en: '![Building a practical example](img/image_03_015.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个实际的例子](img/image_03_015.jpg)'
- en: If we take a look at our code in more detail, we can see the video element in
    use; it's been set to autoplay, with sound muted and a poster (or placeholder)
    image set. The real magic, though, lies in the CSS styling, so let's explore this
    in more detail.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更详细地查看我们的代码，我们可以看到视频元素的使用；它被设置为自动播放，声音被静音，还设置了一个海报（或占位符）图像。然而，真正的魔力在于CSS样式，所以让我们更详细地探讨一下这一点。
- en: Exploring what happened
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索发生了什么
- en: 'The trick that makes our video work is in this code. We need to set two media
    queries with 16:9 aspect ratio (one as a min-aspect-ratio, another as the max)
    so that our video displays correctly on the screen:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的视频工作的技巧在于这段代码。我们需要设置两个16:9宽高比的媒体查询（一个作为最小宽高比，另一个作为最大宽高比），以便我们的视频在屏幕上正确显示：
- en: '![Exploring what happened](img/image_03_016.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![探索发生了什么](img/image_03_016.jpg)'
- en: 'When resizing it though, it will show white space. We fix that by setting negative
    margins, which makes the viewport much wider, and allows us to center the content
    on screen:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但在调整大小时，它会显示白色空间。我们通过设置负边距来解决这个问题，这样视口就会变得更宽，从而使我们能够将内容居中在屏幕上：
- en: '![Exploring what happened](img/image_03_017.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![探索发生了什么](img/image_03_017.jpg)'
- en: A key point to note is the values used for `height`, `top`, `left`, and `width`;
    although these seem extreme, they are required to help center the video on screen
    when viewing the content with a `16/9` aspect ratio set.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的关键点是`height`、`top`、`left`和`width`的值；尽管这些值看起来很极端，但在查看设置了`16/9`宽高比的内容时，它们是必需的，以帮助将视频居中在屏幕上。
- en: Perfect! Our video plays well. We can see the content without too much difficulty.
    Everything should be good, surely? Well, yes and no; concepts such as background
    video are not without their risks; it's important to understand where things might
    fall over if we're not careful. Let's pause for a moment and consider some of
    the potential traps that might upset the proverbial apple cart, if we're not careful
    with our video.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们的视频播放得很好。我们可以轻松看到内容。一切应该都很好，对吧？嗯，是的和不是；诸如背景视频之类的概念并非没有风险；如果我们不小心，重要的是要了解事情可能出错的地方。让我们暂停一下，考虑一下我们的视频如果不小心可能会引起的一些潜在陷阱。
- en: Exploring the risks
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索风险
- en: In our previous example, we explored the concept of adding video as background
    content. It's a fashion that has taken off within the last couple of years, and
    provides an interesting effect, that is different to seeing the standard images
    we might otherwise see!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们探讨了将视频作为背景内容的概念。这是近几年流行起来的一种时尚，提供了一种有趣的效果，与我们可能会看到的标准图像不同！
- en: 'It''s not without a certain element of risk though; there are a few pointers
    we must consider, when adding video as the background content:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非没有一定的风险；在添加视频作为背景内容时，有一些要考虑的要点：
- en: It's possible to add video, but we shouldn't just add it because we can—any
    video we add using this method must amplify the site's overall message.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以添加视频，但我们不应该只是因为我们可以而添加它——我们使用这种方法添加的任何视频都必须增强网站的整体信息。
- en: Any video added will likely be set to autoplay, but the sound must be muted
    by default—if possible, it shouldn't have any sound at all.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何添加的视频可能会被设置为自动播放，但默认情况下必须将声音静音——如果可能的话，最好根本没有声音。
- en: Does our video fit with the site brand, tone, color palette, and so on? There
    is no point building a killer site, only to ruin it with a rubbish video.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的视频是否符合网站品牌、语气、色彩搭配等？建立一个精彩的网站，然后用一个垃圾视频毁掉它是没有意义的。
- en: Costs are something we must consider; it can be expensive to host video content,
    so it must be compressed as much as possible to keep file sizes down, and in a
    suitable format that works on multiple devices, including mobile.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本是我们必须考虑的问题；托管视频内容可能很昂贵，因此必须尽可能压缩文件大小，并以适合多个设备（包括移动设备）的格式进行处理。
- en: Our video should not be too long; we must strike a balance between making it
    too long and not long enough so that it does not feel too repetitive.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的视频不应该太长；我们必须在使它太长和不够长之间取得平衡，以使它不会感到太重复。
- en: Accessibility is a key pointer; it must be of sufficiently high contrast so
    as to make the text overlay legible.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可访问性是一个关键要点；它必须具有足够高的对比度，以使文本叠加可读。
- en: Our video may look good, but what about performance? Your customers will not
    thank you if you produce a lightning fast site, but slow it down with a large,
    poorly optimized video as a background; they will very likely vote with their
    feet!
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的视频可能看起来不错，但性能如何？如果您在背景中使用了一个大型、未经优化的视频，您的客户可能不会感谢您，因为这可能会减慢网站的速度；他们很可能会选择离开！
- en: The compatibility technique we've used doesn't work on IE8, so a static placeholder
    must be included as a fallback; in the event the browser we use doesn't support
    HTML5 video or its attributes (such as autoplay, for mobiles).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的兼容性技术在IE8上不起作用，因此必须包含一个静态占位符作为后备；以防我们使用的浏览器不支持HTML5视频或其属性（例如移动设备的自动播放）。
- en: Even though we have some clear pointers that should be considered, it should
    not stop us from using this effect; I'm one for pushing out the boundaries of
    what is possible, provided we do it well!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有一些明显的指针需要考虑，但这不应该阻止我们使用这种效果；只要我们做得好，我就会不断推动可能性的边界！
- en: Making audio responsive
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使音频响应式
- en: Question—we've worked on making videos responsive, but what about audio content?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 问题——我们已经致力于使视频响应式，但音频内容呢？
- en: Well, we can apply similar principles to the HTML5 `<audio>` element; instead
    of setting a specific width, we can use max-width and set a percentage figure
    to control how wide it displays on the screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将类似的原则应用到HTML5的`<audio>`元素上；我们可以使用max-width而不是设置特定的宽度，并设置一个百分比来控制它在屏幕上的显示宽度。
- en: 'The code to achieve this is very simple, and should by now be familiar—let''s
    take a look at what is involved:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的代码非常简单，现在应该很熟悉——让我们看看涉及了什么：
- en: For this demo, we need to avail ourselves of suitable files; for licensing reasons,
    you won't find any in the code download that accompanies this book, unfortunately!
    One way to achieve this is to take a copy of an iTunes file (normally in `.m4a`
    format), then use an online service such as Media.io ([http://media.io/](http://media.io/))
    to convert it to the right formats. You will need to convert to both MP3 and OGG
    formats, before continuing with this demo.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个演示，我们需要使用合适的文件；出于许可原因，不幸的是，你在本书附带的代码下载中找不到任何文件！实现这一点的一种方法是复制iTunes文件（通常是`.m4a`格式），然后使用Media.io（[http://media.io/](http://media.io/)）等在线服务将其转换为正确的格式。在继续进行此演示之前，您需要将其转换为MP3和OGG格式。
- en: Assuming we now have the right files, go ahead and extract a copy of `audioelement.html`
    from the code download that accompanies this book, and save it to the root of
    our project area.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们现在有了正确的文件，继续从本书附带的代码下载中提取`audioelement.html`的副本，并将其保存到我们项目区域的根目录。
- en: Next, at the root of our project area, go ahead and create a new folder called
    `audio`; into it, save copies of the audio files you either have or created from
    step 1.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们项目区域的根目录中，创建一个名为`audio`的新文件夹；将音频文件的副本保存到其中，这些文件要么已经存在，要么是从第一步创建的。
- en: 'In a new file go ahead and add the following code, saving it as `audioelement.css`
    in the `css` subfolder at the root of our project area:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码，并将其保存为`audioelement.css`，保存在我们项目区域根目录的`css`子文件夹中：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Try previewing the results of our work in a browser—if all is well, we should
    see something akin to this screenshot:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在浏览器中预览我们的工作结果——如果一切顺利，我们应该看到类似于这个屏幕截图的东西：
- en: '![Making audio responsive](img/image_03_018.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![使音频响应式](img/image_03_018.jpg)'
- en: At first glance, it may not look special, but then the `<audio>` element isn't
    meant to look anything out of the ordinary! The key here though is when we resize
    the browser window; we've set a max width value of `100%`, but have constrained
    this by setting an upper limit of `50rem` in the width attribute. No matter how
    many times we resize our window, the audio player will fill the full width, but
    not go any wider than `50rem`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，它可能看起来并不特别，但`<audio>`元素本来就不打算看起来与众不同！关键在于当我们调整浏览器窗口大小时；我们设置了`100%`的最大宽度值，但通过在宽度属性中设置`50rem`的上限来限制了这一点。无论我们调整窗口多少次，音频播放器都会填满整个宽度，但不会超过`50rem`。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike the `<video>` element, we can't resize the height using just CSS; to
    do this requires overriding the `<audio>` element with jQuery, which is out of
    the scope of this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与`<video>`元素不同，我们不能仅使用CSS调整高度；这需要使用jQuery覆盖`<audio>`元素，这超出了本书的范围。
- en: Let's move on and put our new-found knowledge to the test to create a practical
    example—how about making a video fullscreen, and responding to changes in the
    browser viewport automatically? Setting up video using this technique is always
    fraught with controversy, but I'm not one to shy away from a challenge, so without
    further ado, let's dive in and see why we must step carefully when using video
    at fullscreen.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，将我们新学到的知识付诸实践，创建一个实际的例子——比如将视频全屏，并自动响应浏览器视口的变化？使用这种技术设置视频始终充满争议，但我不会逃避挑战，所以让我们毫不犹豫地深入研究，看看为什么在全屏使用视频时我们必须小心谨慎。
- en: Taking things further
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步进行
- en: Throughout the course of this book, we've concentrated on using the core technologies
    of HTML5 and CSS3; in many cases, this is all we need, but there will come a time
    when we have to use other technologies to help fulfill a task, as we've outgrown
    the art of possible with plain CSS and HTML code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们一直致力于使用HTML5和CSS3的核心技术；在许多情况下，这已经足够了，但总会有一天我们需要使用其他技术来帮助完成任务，因为我们已经超越了普通CSS和HTML代码的可能性。
- en: Thankfully, there are lots of options available online to help with making videos
    responsive, and to take our skills. It goes without saying though that we should
    always ask ourselves if our need for another library is because the realities
    of life mean that we can't achieve our task without using it or if we've simply
    become too lazy!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在线上有很多选项可帮助我们使视频响应式，并提高我们的技能。不过，我们应该始终问自己，我们是否需要另一个库是因为生活的现实意味着我们无法在不使用它的情况下完成任务，还是因为我们变得太懒了！
- en: 'If indeed we do need to download and use an additional library, there are a
    few good options to try out, which include:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实需要下载和使用额外的库，有几个不错的选择可以尝试，包括：
- en: '**FluidVids**: It is available from [http://toddmotto.com/labs/fluidvids](http://toddmotto.com/labs/fluidvids);
    the library is a couple of years old, but may be worth a look.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FluidVids**：可以从[http://toddmotto.com/labs/fluidvids](http://toddmotto.com/labs/fluidvids)获取；这个库已经有几年了，但可能值得一看。'
- en: '**responsiveVideo**: It is downloadable from [http://cbavota.bitbucket.org/responsive-video/](http://cbavota.bitbucket.org/responsive-video/).
    This has been around for a couple of years, so may not work so well.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**responsiveVideo**：可以从[http://cbavota.bitbucket.org/responsive-video/](http://cbavota.bitbucket.org/responsive-video/)下载。这个已经存在了几年，所以可能效果不太好。'
- en: '**Embed Responsively**: It is hosted at [http://embedresponsively.com/](http://embedresponsively.com/),
    and will return appropriate embed code for any of the major video hosting companies,
    such as YouTube; it''s also responsive to boot!'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Embed Responsively**：它托管在[http://embedresponsively.com/](http://embedresponsively.com/)，并且会返回任何主要视频托管公司（如YouTube）的适当嵌入代码；它也是响应式的！'
- en: '**FitVids.js**: This plugin, available from [http://fitvidsjs.com](http://fitvidsjs.com/)
    and built by Chris Coyier of CSS Tricks'' fame, may be worth a look, although
    it hasn''t been updated for at least 2-3 years.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FitVids.js**：这个插件可以从[http://fitvidsjs.com](http://fitvidsjs.com)获得，由CSS Tricks的Chris
    Coyier创建，可能值得一看，尽管它至少有2-3年没有更新了。'
- en: '**MediaElement.js**: It is available from [http://mediaelementjs.com](http://mediaelementjs.com/),
    and is a great library that works with both the `<video>` and `<audio>` elements;
    it allows us to override the standard element and customize it to our requirements
    using jQuery and CSS. There are plenty of examples of doing this online, along
    with suitable tutorials on how to achieve a custom look and feel to any player
    we skin using jQuery.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MediaElement.js**：它可以从[http://mediaelementjs.com](http://mediaelementjs.com)获得，并且是一个很棒的库，可以与`<video>`和`<audio>`元素一起使用；它允许我们覆盖标准元素，并使用jQuery和CSS来自定义它以满足我们的需求。有很多在线示例，以及如何使用jQuery实现自定义外观和感觉的适当教程。'
- en: A small word of caution—a number of the video plugin libraries for jQuery haven't
    been updated for some time; you may well find that they no longer work properly
    with more recent versions of jQuery. This isn't necessarily a bad thing, as support
    for the HTML5 `<video>` and `<audio>` elements is now excellent; this renders
    many of these libraries surplus to requirements!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 小心提醒一下 - 一些用于jQuery的视频插件库已经有一段时间没有更新了；你可能会发现它们在最新版本的jQuery中无法正常工作。这并不一定是件坏事，因为对HTML5的`<video>`和`<audio>`元素的支持现在非常出色；这使得许多这些库变得多余！
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of you may ask why we need to use jQuery to skin either HTML5 audio or
    video players; many of the individual elements are not accessible using plain
    CSS, and need JavaScript to expose those elements before styling them with CSS.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会问为什么我们需要使用jQuery来美化HTML5音频或视频播放器；许多单独的元素无法使用纯CSS访问，并且需要JavaScript在用CSS样式之前暴露这些元素。
- en: Phew! We're almost through this part of the journey, but before we move onto
    taking a look at using media queries in the next chapter, there is one more part
    of making responsive content; how about the text we have on our sites? It might
    not immediately strike you as being one we would associate with videos and text
    (at least in the context of making content responsive), but all will shortly become
    clear.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，我们几乎完成了这一部分的旅程，但在我们进入下一章节讨论如何使用媒体查询之前，还有一个制作响应式内容的部分；我们的网站上的文本怎么样？它可能不会立即让你联想到与视频和文本相关的内容（至少在使内容响应式的情况下），但一切很快就会变得清晰起来。
- en: Making text fit on screen
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使文本适应屏幕
- en: When building sites, it goes without saying but our designs clearly must start
    somewhere—this is usually with adding text. It's therefore essential that we allow
    for this in our responsive designs at the same time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建网站时，毋庸置疑，我们的设计显然必须从某个地方开始 - 通常是添加文本。因此，在我们的响应式设计中，我们必须同时考虑到这一点。
- en: Now is a perfect opportunity to explore how to make our text fluid and fill
    the available space. Although text is not media in the same way as images or video,
    it is still content that has to be added at some point to our pages! With this
    in mind, let's dive in and explore how we can make our text responsive.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个完美的机会来探索如何使我们的文本流动并填充可用空间。尽管文本不像图片或视频那样是媒体，但它仍然是必须在某个时候添加到我们的页面上的内容！考虑到这一点，让我们深入探讨如何使我们的文本响应式。
- en: Sizing with em units
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用em单位进行大小调整
- en: When working on non-responsive sites, it's likely that sizes will be quoted
    in pixel values; it's a perfectly acceptable way of working. However, if we begin
    to make our sites responsive, then content won't resize well using pixel values;
    we have to use something else.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理非响应式网站时，尺寸可能会以像素值引用；这是一个完全可以接受的工作方式。然而，如果我们开始使我们的网站响应式，那么使用像素值调整内容大小就不太好了；我们必须使用其他方法。
- en: 'There are two alternatives: em or rem units. The former is based on setting
    a base font size that in most browsers defaults to 16px; in this example, the
    equivalent pixel sizes are given in the comments that follow each rule:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种选择：em或rem单位。前者是基于设置一个基本字体大小，大多数浏览器默认为16px；在这个例子中，相应的像素大小在每条规则后面的注释中给出。
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unfortunately, there is an inherent problem with using em units; if we nest
    elements, then font sizes will be compounded, as em units are calculated relative
    to its parent. For example, if the font size of a list element is set at 1.4em
    (22px), then the font size of a list item within a list becomes 30.8em (1.4 x
    22px).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用em单位存在一个固有的问题；如果我们嵌套元素，那么字体大小将会叠加，因为em单位是相对于其父元素计算的。例如，如果列表元素的字体大小设置为1.4em（22px），那么列表中的列表项的字体大小就变成了30.8em（1.4
    x 22px）。
- en: To work around these issues, we can use rem values as a replacement, these are
    calculated from the root element, in place of the parent element. If you look
    carefully throughout many of the demos created for this book, you will see rem
    units being used to define the sizes of elements in the demos.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们可以使用rem值作为替代，这些值是从根元素计算出来的，而不是从父元素计算出来的。如果你仔细观察本书中创建的许多演示，你会看到rem单位被用来定义演示中元素的大小。
- en: Using rem units as a replacement
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用rem单位作为替代
- en: The rem (or root em) unit is set to be relative to the root, instead of the
    parent; it means that we eliminate any issues with compounding at a stroke, as
    our reference point remains constant, and is not affected by other elements on
    the page.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: rem（或根em）单位被设置为相对于根的单位，而不是父级的单位；这意味着我们消除了任何复合问题，因为我们的参考点保持恒定，并且不受页面上其他元素的影响。
- en: 'The downside of this is support—rem units are not supported in IE7 or 8, so
    if we still have to support these browsers, then we must fall back to using pixel
    or em values instead. This of course raises the question: should we still support
    these browsers, or is their usage of our site so small as to not be worth the
    effort required to update our code?'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的缺点是支持——IE7或8不支持rem单位，因此如果我们仍然需要支持这些浏览器，那么我们必须回退到使用像素或em值。当然，这引发了一个问题：我们是否仍然应该支持这些浏览器，或者他们对我们网站的使用量太小，不值得更新我们的代码？
- en: 'If the answer is that we must support IE8 or below, then we can take a hybrid
    approach; we can set both pixel/em and rem values at the same time in our code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案是我们必须支持IE8或更低版本，那么我们可以采取混合方法；我们可以在我们的代码中同时设置像素/em和rem值：
- en: '[PRE20]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how we set rem values first? Browsers that support rem units will use
    these first; the ones that don't can automatically fall back to using pixel or
    em values instead. The values in each comment are the pixel equivalents; if, for
    example, we divide `18px` by `16px` (as the base value for all sizes), we would
    arrive at `1.125`, as indicated in the text.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们首先设置rem值？支持rem单位的浏览器将首先使用这些值；不支持的浏览器可以自动回退到使用像素或em值。每个注释中的值都是像素等价值；例如，如果我们将`18px`除以`16px`（作为所有大小的基本值），我们将得到`1.125`，如文本中所示。
- en: Exploring use of viewport units
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索视口单位的使用
- en: If we want to take it further, then there is another alternative we can explore;
    how about using viewport units?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想进一步，那么还有另一种选择我们可以探索；如何使用视口单位？
- en: 'These effectively combine the best of both worlds; a viewport unit (or `1vw`)
    is 1% of the viewport axis. So, if we had a viewport of 50 cm wide, a single `vw`
    unit would be 0.5 cm. We can specify sizes in the same way as we would do for
    pixel, em, or rem units. Take a look at this little extract, which gives a flavor
    of what it would look like:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有效地结合了两者的优点；视口单位（或`1vw`）是视口轴的1%。因此，如果我们有一个宽度为50厘米的视口，一个`vw`单位将是0.5厘米。我们可以以与像素、em或rem单位相同的方式指定大小。看看这个小节，它给出了它会是什么样子的味道：
- en: '[PRE21]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The beauty though is no matter what size the viewport, the font size will always
    appear correctly, as it will automatically resize if the view port is changed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，美妙之处在于无论视口大小如何，字体大小都会始终正确显示，因为如果视口改变，它会自动调整大小。
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To see a simple example of this in action, browse to [http://codepen.io/alibby251/pen/xOGrqN](http://codepen.io/alibby251/pen/xOGrqN)
    and try resizing the browser window. See how the text automatically changes size,
    with no loss of quality?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个在实际中的简单例子，浏览到[http://codepen.io/alibby251/pen/xOGrqN](http://codepen.io/alibby251/pen/xOGrqN)并尝试调整浏览器窗口大小。看看文本如何自动更改大小，而不会失去质量？
- en: Taking things further
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步探讨
- en: Okay, at this point, we've added responsive capabilities to our text; our sites
    are looking pretty good....I can see a *but* coming....
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在这一点上，我们已经为我们的文本添加了响应能力；我们的网站看起来相当不错....我可以看到一个*但*的出现....
- en: At present, support for responsive text (and in particular vw or rem units)
    is excellent; browsers that will choke on these two units are few and far between.
    However, there *may* come a time when we need additional help; unlike images or
    video content, there are not many options available to choose from! The two best
    examples are FlowType.js, available from [http://simplefocus.com/flowtype/](http://simplefocus.com/flowtype/),
    and FitText.js, from [http://fittextjs.com/](http://fittextjs.com/).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，对于响应式文本（特别是vw或rem单位）的支持非常好；对这两个单位会出现问题的浏览器是少之又少。然而，可能会有一天我们需要额外的帮助；与图像或视频内容不同，可供选择的选项并不多！最好的两个例子是FlowType.js，可从[http://simplefocus.com/flowtype/](http://simplefocus.com/flowtype/)获取，以及FitText.js，可从[http://fittextjs.com/](http://fittextjs.com/)获取。
- en: The catch though is that these libraries haven't been updated for 2-3 years,
    so are not likely to work with recent versions of jQuery. It's a good indicator
    of how well responsive text has come along over the years, and that we really
    should be using it natively, rather than relying on JavaScript!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是这些库已经有2-3年没有更新了，因此不太可能与最近版本的jQuery一起使用。这很好地说明了多年来响应式文本的发展情况，我们真的应该原生地使用它，而不是依赖JavaScript！
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: A key part of any website must be the media used; after all, it would become
    boring without some form of color! This is no different for responsive sites;
    throughout the course of this chapter, we've covered some useful techniques for
    adding responsive media, so let's reflect on what we've covered in this chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网站的关键部分必须是使用的媒体；毕竟，没有某种形式的颜色，它会变得无聊！对于响应式网站来说也是如此；在本章的过程中，我们已经涵盖了一些有用的技术来添加响应式媒体，所以让我们回顾一下本章涵盖的内容。
- en: We kicked off with a look at making images fluid, which is the basic concept
    behind responsive media; we then swiftly moved on to look at using the HTML5 `<picture>`
    element, to see how it can be used to specify different sized images based on
    hardware capabilities. We explored a few pointers on what is available to use,
    should we decide to that existing native support is insufficient, and we need
    to progress from using just plain HTML and CSS.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从研究使图像流畅开始，这是响应式媒体背后的基本概念；然后我们迅速转向使用HTML5的`<picture>`元素，看看它如何用于根据硬件能力指定不同大小的图像。我们探讨了一些可用的指针，如果我们决定现有的原生支持不够，我们需要从仅使用纯HTML和CSS进展。
- en: Next up came a look at responsive video; we examined how to make externally
    hosted videos responsive, with just plain CSS. We also covered the techniques
    required to make the HTML5 `<video>` element responsive, if hosting externally
    is not an option. We also explored the HTML5 `<audio>` element, and saw how we
    can use similar techniques to make it responsive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看一下响应式视频；我们将探讨如何使用纯CSS使外部托管的视频具有响应性。我们还介绍了使HTML5 `<video>` 元素具有响应性所需的技术，如果外部托管不是一个选择。我们还探讨了HTML5
    `<audio>` 元素，并看到我们可以使用类似的技术使其具有响应性。
- en: We then rounded off the chapter with a look at making standard text responsive;
    we covered how this has already been used in many demos throughout the book, before
    exploring the different techniques, such as using em or rem values, which are
    often better than standard pixel units. We then finished with a quick demo on
    using viewport units for font sizes, so we could see how to get the best of everything
    when creating responsive text.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们以探讨如何使标准文本具有响应性结束了本章；我们介绍了这在本书的许多演示中已经被使用过，然后探讨了不同的技术，比如使用em或rem值，这些通常比标准像素单位更好。最后，我们进行了一个关于使用视口单位来设置字体大小的快速演示，这样我们就可以看到如何在创建响应式文本时获得最佳效果。
- en: Phew—a lot covered! Let's move on. Now that we have our layout and content in
    place, we need to consider how to resize them correctly. Enter media queries—this
    will be the subject of our next chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，涵盖了很多内容！让我们继续。既然我们已经有了布局和内容，我们需要考虑如何正确调整它们的大小。媒体查询就是解决这个问题的方法，这将是我们下一章的主题。
