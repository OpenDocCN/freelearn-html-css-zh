- en: Chapter 3. Omni Menu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 Omni菜单
- en: 'With media queries, we can activate or deactivate CSS instructions when some
    device or viewport requirements are met. This is especially useful when we have
    to deal with elements that need to have different representations depending on
    the user''s device. The menu is usually such an element. In this chapter we will
    develop a main menu system that displays perfectly on desktop browsers and mobile
    devices; we can call it Omni Menu. We''re going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用媒体查询，我们可以在满足某些设备或视口要求时激活或停用CSS指令。当我们需要处理需要根据用户设备具有不同表示的元素时，这是非常有用的。菜单通常就是这样的一个元素。在本章中，我们将开发一个主菜单系统，可以在桌面浏览器和移动设备上完美显示；我们可以称之为Omni菜单。我们将涵盖以下主题：
- en: Setup operations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置操作
- en: First level
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一级
- en: Second level
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二级
- en: Moving parts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动部件
- en: Basic transitions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本过渡
- en: Introducing animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍动画
- en: Adding some colors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些颜色
- en: Media queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体查询
- en: Mobile version
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动版本
- en: Improving speed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高速度
- en: 'In the next section we''ll start creating a basic HTML menu structure. As usual,
    we can store all of the project''s files in a folder named as the name of the
    project (`omni_menu` in this case). Before we begin, let''s look at a screenshot
    of the final result:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始创建一个基本的HTML菜单结构。通常情况下，我们可以将项目的所有文件存储在一个以项目名称（在本例中为`omni_menu`）命名的文件夹中。在开始之前，让我们先看一下最终结果的截图：
- en: '![Omni Menu](img/3264OT_03_00.01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Omni菜单](img/3264OT_03_00.01.jpg)'
- en: Setup operations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置操作
- en: To style the menu, we need to define the markup first. Let's write a small HTML
    file, `index.html`, where we will define a classic two-level menu structure using
    `li` and `ul` items. Next, we'll add some basic CSS before moving to the central
    part of the chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要为菜单设置样式，我们需要先定义标记。让我们编写一个小的HTML文件`index.html`，在其中我们将使用`li`和`ul`项目定义一个经典的两级菜单结构。接下来，我们将在转到本章的核心部分之前添加一些基本的CSS。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We take advantage of the new `data-*` attributes to enhance semantically the
    items in the first level of our menu. We'll also see in a moment how these attributes
    can help us better style this structure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用新的`data-*`属性来语义化地增强菜单第一级中的项目。我们稍后还将看到这些属性如何帮助我们更好地样式化这个结构。
- en: 'Now let''s open `application.css` and define a basic CSS structure to center
    this menu and add a nice background. For this part of the project we don''t focus
    on a mobile layout, so we can use a classic 960 px approach:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开`application.css`，定义一个基本的CSS结构来居中这个菜单并添加一个漂亮的背景。对于项目的这一部分，我们不关注移动布局，所以我们可以使用经典的960像素方法：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The highlighted part in the previous code defines a collapsed gradient in order
    to obtain a striped background. Next we define the size of the `nav` element to
    `960px` and put some nice gradient, shadows, and a border radius on it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的高亮部分定义了一个折叠的渐变，以获得条纹背景。接下来我们将`nav`元素的大小定义为`960px`，并在其上添加一些漂亮的渐变、阴影和边框半径。
- en: 'If we load the project in a CSS3 compatible browser, we can view the effects
    of our first styling:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在支持CSS3的浏览器中加载项目，我们可以查看我们的第一个样式效果：
- en: '![Setup operations](img/3264OT_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![设置操作](img/3264OT_03_01.jpg)'
- en: Styling the first-level items
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化第一级项目
- en: 'The typical format in many two-level menus is to display the first-level items
    horizontally on the same line and then hide the second-level ones. We will add
    some CSS code to `application.css` to accomplish this, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多两级菜单的典型格式是在同一行上水平显示第一级项目，然后隐藏第二级项目。我们将添加一些CSS代码到`application.css`中来实现这一点，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the inline-block display
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用inline-block显示
- en: 'In the previous code, we used `display: inline-block` instead of floating the
    elements as is commonly done. Both these properties are commonly used to align
    elements inline, but the difference is that `display: inline-block` doesn''t break
    the page flow and saves us from using `clearfix`. However, there''s a drawback
    to using the `display: inline-block` property. Let''s see it in a small demo:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码中，我们使用了`display: inline-block`而不是通常使用的浮动元素。这两个属性通常用于将元素内联对齐，但不同之处在于`display:
    inline-block`不会破坏页面流，并且可以节省我们使用`clearfix`。然而，使用`display: inline-block`属性也有一个缺点。让我们在一个小的演示中看看：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we load our demo page in a browser, the result is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中加载我们的演示页面，结果如下：
- en: '![Using the inline-block display](img/3264OT_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用inline-block显示](img/3264OT_03_02.jpg)'
- en: 'You will notice that there is no space between **THREE** and **FOUR** but there
    are spaces between **ONE**, **TWO**, and **THREE**. Why is that so? This is because
    `display: inline-block` takes into account the spaces between the elements in
    the HTML markup. To avoid this issue, we will take care to ensure that we have
    consistent space or line breaks between each element.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '您会注意到**THREE**和**FOUR**之间没有空格，但**ONE**、**TWO**和**THREE**之间有空格。为什么会这样？这是因为`display:
    inline-block`考虑了HTML标记中元素之间的空格。为了避免这个问题，我们将确保在每个元素之间有一致的空格或换行。'
- en: Using new pseudo-selectors
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用新的伪选择器
- en: 'Now, let''s move to the next interesting instruction: `nth-last-child(2)`.
    This is one of the many new pseudo-selectors introduced by CSS3\. With `nth-last-child(n)`
    we can target the `nth` element counting from the last, and with `nth-child(n)`
    we can do the same but starting from the top. These two pseudo-selectors can also
    be used to select elements through some kind of pattern. For example, suppose
    we want to highlight only the even elements of the following list:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到下一个有趣的指令：`nth-last-child(2)`。这是CSS3引入的许多新伪选择器之一。使用`nth-last-child(n)`，我们可以定位从最后开始计数的第`n`个元素，而使用`nth-child(n)`，我们可以从顶部开始做同样的事情。这两个伪选择器也可以用来通过某种模式选择元素。例如，假设我们只想突出显示以下列表的偶数元素：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can achieve this with the following simple CSS code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下简单的CSS代码实现这一点：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If instead we want to target only the elements with index greater than three,
    we can use the following CSS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要只针对索引大于三的元素进行目标定位，我们可以使用以下CSS：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the result of the previous example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上一个示例的结果：
- en: '![Using new pseudo-selectors](img/3264OT_03_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![使用新的伪选择器](img/3264OT_03_03.jpg)'
- en: Completing the first level
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成第一级
- en: 'We still have to add a few CSS properties to complete the styling of our first-level
    elements:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要添加一些CSS属性来完成我们第一级元素的样式：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Well done! Now let''s run the project in a CSS3-compatible browser to appreciate
    the results:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在让我们在支持CSS3的浏览器中运行项目，以欣赏结果：
- en: '![Completing the first level](img/3264OT_03_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![完成第一级](img/3264OT_03_04.jpg)'
- en: Styling submenus
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化子菜单
- en: Now we have to style the second-level items. Well, to be honest, we have already
    hidden them in the previous section in order to obtain a nice first-level styling,
    but now we can enrich the second-level elements with plenty of more properties
    and make sure they show up when users hover the mouse on their first-level parent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须为第二级项目设置样式。好吧，说实话，我们在上一节中已经隐藏了它们，以获得漂亮的一级样式，但现在我们可以用更多的属性丰富第二级元素，并确保当用户将鼠标悬停在它们的一级父级上时它们会显示出来。
- en: 'Let''s start with the last part we just discussed. In order to display the
    second-level elements, we have to use the `:hover` pseudo-selector:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从刚讨论的最后一部分开始。为了显示第二级元素，我们必须使用`:hover`伪选择器：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have intercepted both the hover on the parent and on all of the children
    in order to keep the second-level menu displayed even when the mouse moves on
    them. Once done, we can start with some basic styling:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拦截了父级和所有子级的悬停，以便即使鼠标移动到它们上面，第二级菜单仍然显示。完成后，我们可以开始一些基本的样式：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is just one small thing to underline here. Within the highlighted part
    of the previous code, there is an easy and simple fallback mechanism for browsers
    that do not support CSS3\. If we first declare an `rgb background-color` value
    and then an `rgba` one, we ensure that browsers that do not support CSS3 apply
    the `rgb` instruction and skip the `rgba` one, whereas browsers that do support
    CSS3 overwrite the `rgb` instruction with the `rgba` one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一件小事要强调。在上一段代码的突出部分中，有一个简单的回退机制，用于不支持CSS3的浏览器。如果我们首先声明一个`rgb背景颜色`值，然后是一个`rgba`值，我们可以确保不支持CSS3的浏览器应用`rgb`指令并跳过`rgba`指令，而支持CSS3的浏览器则用`rgba`指令覆盖`rgb`指令。
- en: 'Ok, time to reload the project in our preferred CSS3 browser and test the results:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，是时候在我们首选的CSS3浏览器中重新加载项目并测试结果了：
- en: '![Styling submenus](img/3264OT_03_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![样式化子菜单](img/3264OT_03_05.jpg)'
- en: In the next section, we're going to add some basic CSS in order to respond to
    mouse movements. For example, activating a particular submenu when the mouse is
    placed over its parent first-level menu.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将添加一些基本的CSS以响应鼠标移动。例如，当鼠标放在其父级一级菜单上时激活特定的子菜单。
- en: Moving parts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动部分
- en: 'We have added a (yet unused) `<li class="cursor">` element at the end of the
    first and second levels. What we want to create is a block that is able to move
    under the element when the mouse hovers over it. It''s a nice effect, and to achieve
    it we are going to use CSS3 transitions. But first let''s create the same effect
    without animation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一级和第二级末尾添加了一个（尚未使用的）`<li class="cursor">`元素。我们想要创建的是一个能够在鼠标悬停在其上时移动到元素下方的块。这是一个很好的效果，为了实现它，我们将使用CSS3过渡。但首先让我们创建相同的效果，但没有动画：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The highlighted code shows the special selector we use to toggle the visibility
    of our `.cursor` element. Basically, we display it if one of the previous `li`
    elements are hovered by the mouse.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的代码显示了我们用来切换`.cursor`元素可见性的特殊选择器。基本上，如果鼠标悬停在前面的`li`元素之一上，我们就显示它。
- en: Next, we have to define the absolute position of the `.cursor` element, which
    obviously depends on the `li` element we're hovering. To achieve this behavior,
    we chain the `+` selector in order to precisely move the cursor under the element.
    The same is done for the second-level elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义`.cursor`元素的绝对位置，这显然取决于我们正在悬停的`li`元素。为了实现这种行为，我们使用`+`选择器来精确地将光标移动到元素下方。对于第二级元素也是如此。
- en: If we run the project in our browser, we may experience some disappointment.
    The effect is exactly the same as simply changing the `li` background using the
    `:hover` pseudo-selector.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行项目，可能会感到失望。效果与仅使用`:hover`伪选择器改变`li`背景的效果完全相同。
- en: '![Moving parts](img/3264OT_03_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![移动部分](img/3264OT_03_06.jpg)'
- en: 'Ok, time to add our hidden ingredient: transitions.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，是时候添加我们隐藏的成分：过渡效果了。
- en: Adding transitions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加过渡效果
- en: 'The logic behind transitions is simple yet powerful. We can instruct the browser
    to create an animation between two different property values. That''s it! We can
    use the `transition` property to specify that when a change occurs in another
    CSS property (for example, `width`), the element should not switch from one value
    to the other instantaneously but take a desired amount of time, thus creating
    an animation between the two values. The following example illustrates this effect:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡背后的逻辑简单而强大。我们可以指示浏览器在两个不同的属性值之间创建动画。就是这样！我们可以使用`transition`属性来指定当另一个CSS属性发生变化时（例如`width`），元素不应立即从一个值切换到另一个值，而是花费一定的时间，从而在两个值之间创建动画。以下示例说明了这种效果：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `all` keyword tells the browser to take exactly one second to change from
    one property to the other for all the properties that support transition. In this
    case, when we hover the `a` element, the `color` property changes from `black`
    to `red`, but not instantaneously; instead, it covers all the colors between black
    and red in one second with a really cool effect.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`关键字告诉浏览器在所有支持过渡的属性上从一个属性变化到另一个属性时花费一秒钟。在这种情况下，当我们悬停在`a`元素上时，`color`属性从`black`变为`red`，但不是立即变化；相反，它在一秒钟内覆盖了从黑色到红色的所有颜色，产生了一个非常酷的效果。'
- en: '![Adding transitions](img/3264OT_03_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![添加过渡效果](img/3264OT_03_07.jpg)'
- en: 'We can do this trick with a lot of other properties and in many other ways,
    as we''ll see in the later chapters of this book. For the moment, we can use what
    we have learned to enhance our project. Let''s add a `transition` statement to
    `application.css`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用很多其他属性和很多其他方式来做这个技巧，正如我们将在本书的后面章节中看到的那样。目前，我们可以利用我们所学到的知识来增强我们的项目。让我们在`application.css`中添加一个`transition`语句：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this simple property, we have obtained a whole new result. Now every time
    we hover an element, the cursor moves under that element in a really smooth animation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的属性，我们获得了一个全新的结果。现在每当我们悬停在一个元素上时，光标都会以非常平滑的动画移动到该元素下方。
- en: '![Adding transitions](img/3264OT_03_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![添加转换](img/3264OT_03_08.jpg)'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, `prefixfree.js` did not support transitions
    and animations in Internet Explorer 10\. So we have to remember to add a copy
    of the transition property with the `-ms-` experimental prefix. This is likely
    to change in the future, both because Microsoft will remove the need of experimental
    vendor prefixes, and because of a new version of this JavaScript library.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，`prefixfree.js`不支持Internet Explorer 10中的转换和动画。因此，我们必须记住添加带有`-ms-`实验性前缀的转换属性的副本。这很可能会在将来发生变化，这既是因为微软将删除实验性供应商前缀的需要，也是因为这个JavaScript库的新版本。
- en: Now we have to handle another problem. The second-level menu appears too soon,
    with an unpleasant effect. How can we delay its appearance until the `.cursor`
    element has reached the right position under the `li` element? We will see this
    in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须处理另一个问题。二级菜单出现得太早，效果不佳。我们如何延迟其出现，直到`.cursor`元素在`li`元素下方达到正确位置？我们将在下一节中看到这一点。
- en: Introducing animations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入动画
- en: 'Animations are one-step-forward transitions. With them, we can control the
    transition between one or more properties in detail. An animation is composed
    of a set of keyframes where each keyframe is basically a way to declare which
    values our chosen properties must have at a specific progress percentage of the
    animation. Let''s explore this feature with the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是一步向前的转换。通过它们，我们可以详细控制一个或多个属性之间的过渡。动画由一组关键帧组成，其中每个关键帧基本上是声明我们选择的属性在动画的特定进度百分比时必须具有哪些值的一种方式。让我们通过以下示例来探索这个特性：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the `@keyframes` statement, we define the value of some properties of
    our choice during a progression from `0%` to `100%`. Once this is done, we can
    use the `animation` property with a few parameters, defined as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@keyframes`语句，我们定义了在从`0%`到`100%`的过程中我们选择的一些属性的值。一旦这样做了，我们就可以使用`animation`属性以一些参数来定义，如下所示：
- en: 'First parameter: It specifies the name of the animation we want to execute
    on the element (for example, `fouredges` in the previous code).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数：它指定我们要在元素上执行的动画的名称（例如，在上面的代码中是`fouredges`）。
- en: 'Second parameter: It specifies the total amount of time we want a single loop
    through the animation to take place in.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数：它指定我们希望动画在单个循环中进行的总时间。
- en: 'Third parameter: It specifies the accelerating function. Basically, we can
    decide whether the element should move at a constant velocity (with the keyword
    `linear`) or accelerate during the beginning or ending phase of each step of the
    animation (using `ease-in`, `ease-out`, or `ease`).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数：它指定加速函数。基本上，我们可以决定元素是否应该以恒定的速度移动（使用关键字`linear`）或者在动画的开始或结束阶段加速（使用`ease-in`、`ease-out`或`ease`）。
- en: 'Fourth parameter: It specifies the delay we want to apply to the beginning
    of the animation.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数：它指定我们希望应用于动画开始的延迟。
- en: 'Fifth parameter: It specifies the number of times we want the animation to
    be repeated. `infinite` is a valid value for this parameter as well as positive
    numbers.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数：它指定我们希望动画重复的次数。`infinite`是这个参数的有效值，以及正数。
- en: 'Sixth parameter: With the keyword `alternate`, we can ask the browser to toggle
    the direction of the animation. In other words, the animation will go first from
    `0%` to `100%`, and then from `100%` to `0%`, and over again.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六个参数：使用关键字`alternate`，我们可以要求浏览器切换动画的方向。换句话说，动画将首先从`0%`到`100%`，然后从`100%`到`0%`，再次循环。
- en: 'If we try the example we just wrote in a browser, we''ll see a square moving
    along a four-vertex path:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中尝试刚刚写的例子，我们会看到一个正方形沿着四个顶点路径移动：
- en: '![Introducing animations](img/3264OT_03_09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![引入动画](img/3264OT_03_09.jpg)'
- en: 'Well, that sounds interesting, but how can this help us with our project? Simple!
    We can use a delayed animation (an animation with some delay) to create a fade-in
    effect in the second-level menus. So let''s remove the `opacity: 1` temporary
    property we added earlier and add some CSS to `application.css`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '嗯，听起来很有趣，但这如何帮助我们的项目呢？简单！我们可以使用延迟动画（带有一些延迟的动画）来创建二级菜单的淡入效果。所以让我们移除之前添加的`opacity:
    1`临时属性，并在`application.css`中添加一些CSS：'
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `animation-fill-mode: forwards` property tells the browser not to revert
    to `0%` at the end of the animation, but to keep the `100%` position.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-fill-mode: forwards`属性告诉浏览器在动画结束时不要恢复到`0%`，而是保持`100%`位置。'
- en: With these new add-ons in our project, we can now try an almost complete desktop
    version in our browser. Enjoy the cursor animation and the second-level menu's
    fade-in effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新的附加功能，我们现在可以在浏览器中尝试一个几乎完整的桌面版本。享受光标动画和二级菜单的淡入效果。
- en: 'With the previous lines of code we have, however, removed the support to browsers
    that don''t handle CSS3 animations, in particular for IE9 and below. To handle
    this problem there are a lot of techniques, most of which will be unveiled during
    the course of this book. The first technique that we''ll implement works by substituting
    the `<html>` tag with something slightly more complex, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过上面的代码，我们已经移除了不支持CSS3动画的浏览器的支持，特别是IE9及以下版本。为了解决这个问题，有很多技术，其中大部分将在本书的过程中揭示。我们将实现的第一种技术是通过用稍微复杂一些的东西替换`<html>`标签，如下所示：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By using conditional comments, we can now identify when the user is browsing
    our website using IE9 or less because a new `.lteie9` class gets added to the
    `html` element.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用条件注释，我们现在可以确定用户是否使用IE9或更低版本浏览我们的网站，因为新的`.lteie9`类被添加到`html`元素中。
- en: 'So we can add a small chunk of code to our CSS file that gets triggered only
    when `.lteie9` is present:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以向我们的CSS文件添加一小段代码，只有在`.lteie9`存在时才会触发：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding colors
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加颜色
- en: 'We can easily change the color of the `.cursor` element depending on which
    element the mouse is hovering. We''ll also observe how the colors will change
    gradually, thanks to our `transition: all 1s` property, thus creating a really
    nice effect.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以根据鼠标悬停在哪个元素上轻松更改`.cursor`元素的颜色。由于我们的`transition: all 1s`属性，我们还将观察颜色如何逐渐变化，从而创建一个非常好的效果。'
- en: 'Let''s add some properties to `application.css` to change the color of the
    `.cursor` element, and to add some colors to the second-level menus:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向`application.css`添加一些属性，以更改`.cursor`元素的颜色，并向二级菜单添加一些颜色：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code, we target three different elements. First the `.cursor`
    element when the `li` element with attribute `data-section-portfolio` is in state
    `:hover`, next the second-level menu corresponding to the `li` element with attribute
    `data-section-portfolio`, and finally the `.cursor` element for this second-level
    menu. In this case, it is particularly useful to take advantage of a `data-*`
    attribute to mark semantically each item of the menu.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们针对三个不同的元素。首先是`.cursor`元素，当具有属性`data-section-portfolio`的`li`元素处于状态`:hover`时，接下来是对应于具有属性`data-section-portfolio`的`li`元素的二级菜单，最后是此二级菜单的`.cursor`元素。在这种情况下，利用`data-*`属性来语义化地标记菜单的每个项目特别有用。
- en: 'Let''s reload the project in the browser to view and experience the effect:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中重新加载项目以查看和体验效果：
- en: '![Adding colors](img/3264OT_03_10.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![添加颜色](img/3264OT_03_10.jpg)'
- en: Media queries
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体查询
- en: 'Media queries is a simple yet incredibly powerful tool to activate some CSS
    properties, depending on certain browser and device characteristics, such as the
    browser''s viewport size, the device''s width and height, and orientation. Before
    diving into the details, let''s write a small script to experiment with this feature:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询是一种简单但非常强大的工具，可以根据某些浏览器和设备特性（如浏览器的视口大小、设备的宽度和高度以及方向）激活一些CSS属性。在深入细节之前，让我们编写一个小脚本来尝试这个功能：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, we instruct the browser to apply the properties enclosed between
    the `@media` curly brackets *only* when the conditions expressed are satisfied.
    Let''s have a look at them:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们指示浏览器仅在满足所表达的条件时应用`@media`大括号之间的属性。让我们来看看它们：
- en: '`screen`: This keyword is one of the available media types, and is used to
    indicate which kind of media must implement the enclosed statements. There are
    plenty of media types described in the dedicated W3C specification ([http://www.w3.org/TR/CSS2/media.html#media-types](http://www.w3.org/TR/CSS2/media.html#media-types)),
    but only a few of them (`screen`, `print`, `projection`) are actually supported
    by today''s browsers.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`screen`：此关键字是可用媒体类型之一，用于指示必须实现封闭语句的媒体类型。在专门的W3C规范中描述了许多媒体类型（[http://www.w3.org/TR/CSS2/media.html#media-types](http://www.w3.org/TR/CSS2/media.html#media-types)），但只有少数几种（`screen`、`print`、`projection`）实际上受到今天浏览器的支持。'
- en: '`max-width`: This is one of the many conditional keywords we can chain to list
    the characteristics that must be present in a device in order to activate the
    enclosing statements. The `max-width` keyword can be read as "up to", so this
    condition is verified until the browser''s viewport size exceeds the given value.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max-width`：这是我们可以链接的许多条件关键字之一，以列出必须存在于设备中才能激活封闭语句的特征。`max-width`关键字可以解读为“最大为”，因此此条件在浏览器的视口大小超过给定值之前得到验证。'
- en: 'If we run the previous code in a CSS3-compatible browser, we can see something
    like the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在兼容CSS3的浏览器中运行上面的代码，我们可以看到类似以下截图的内容：
- en: '![Media queries](img/3264OT_03_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![媒体查询](img/3264OT_03_11.jpg)'
- en: 'But if we adjust the size of the window below `400px`, the statements within
    the media query get activated and the result will be something like the following
    screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们调整窗口大小到`400px`以下，媒体查询中的语句将被激活，结果将类似于以下截图：
- en: '![Media queries](img/3264OT_03_12.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![媒体查询](img/3264OT_03_12.jpg)'
- en: 'Cool, isn''t it? Of course, there are other conditional keywords besides `max-width`.
    Let''s have a look at them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，不是吗？当然，除了`max-width`之外，还有其他条件关键字。让我们来看看它们：
- en: '`min-width`: This keyword can be read as "the viewport width is minimum x",
    where x is the value assigned to the `min-width` property.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min-width`：此关键字可以解读为“视口宽度最小为x”，其中x是分配给`min-width`属性的值。'
- en: '`max-height` and `min-height`: These keywords work in the same way as the `*-width`
    ones, but they are applied to the browser''s viewport height.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max-height`和`min-height`：这些关键词的工作方式与`*-width`相同，但它们适用于浏览器的视口高度。'
- en: '`min-device-width`, `max-device-width`, `min-device-height`, and `max-device-height`:
    These keywords identify the real dimensions of the device; so if we want to target
    only screens bigger than 1900 x 1200, we have to write a rule such as `(min-device-width:
    1900px)` and `(min-device-height: 1200px)`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min-device-width`、`max-device-width`、`min-device-height`和`max-device-height`：这些关键字标识设备的实际尺寸；因此，如果我们只想针对大于1900
    x 1200的屏幕进行定位，我们必须编写诸如`(min-device-width: 1900px)`和`(min-device-height: 1200px)`的规则。'
- en: '`orientation`: The value for this property can be either `portrait` or `landscape`.
    It identifies the current orientation of the device.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orientation`：此属性的值可以是`portrait`或`landscape`。它标识设备的当前方向。'
- en: There are even more of such conditional keywords, but those not present in the
    previous list aren't so useful, and furthermore are not yet supported by any browser.
    Anyway, the full list can be viewed at [http://www.w3.org/TR/css3-mediaqueries/#media1](http://www.w3.org/TR/css3-mediaqueries/#media1).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有更多这样的条件关键字，但是在上一个列表中不存在的关键字并不那么有用，而且目前还没有任何浏览器支持。无论如何，完整列表可以在[http://www.w3.org/TR/css3-mediaqueries/#media1](http://www.w3.org/TR/css3-mediaqueries/#media1)上查看。
- en: 'We can also define a media query in a `<link>` declaration using the `media`
    attribute, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`<link>`声明中使用`media`属性来定义媒体查询，如下所示：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, we have to take into account browsers that don''t understand
    media query statements because they will always load the linked CSS regardless
    of the conditions. To prevent this behavior, at least on older versions of Internet
    Explorer, we can wrap the `<link>` element with a conditional comment:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须考虑不理解媒体查询语句的浏览器，因为它们将始终加载链接的CSS，而不考虑条件。为了防止这种行为，至少在较旧版本的Internet
    Explorer中，我们可以使用条件注释将`<link>`元素包装起来：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ok, now we know how media queries work, but how can we use this feature to target
    mobile devices? We can do it in two ways, using `max-device-width` or `max-width`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道媒体查询是如何工作的，但是我们如何使用此功能来针对移动设备呢？我们可以使用`max-device-width`或`max-width`来做到这一点。
- en: The `max-device-width` property checks the size of the device, which makes it
    difficult to emulate on a desktop web browser or laptop. The other drawback of
    using this property is that we don't want to change our layout based on the size
    of the screen; we want to change it in response to the size of the browser window.
    Therefore, the preferred property is `max-width`, which is the behavior that will
    give us the most flexibility for our menu system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`max-device-width`属性检查设备的大小，这在桌面Web浏览器或笔记本电脑上模拟是困难的。使用此属性的另一个缺点是，我们不希望根据屏幕大小来更改布局；我们希望根据浏览器窗口的大小来更改布局。因此，首选属性是`max-width`，这是将为我们的菜单系统提供最大灵活性的行为。'
- en: 'Now that we have chosen the behavior to target mobile devices, we have another
    complication to resolve. In order to represent a desktop version of the page and
    then let the user zoom in and out, mobile devices fake their actual resolution.
    To force mobile browsers to expose their true dimensions and disable zoom, we
    can use a `<meta>` tag. This tag basically says that the maximum and minimum zoom
    factor must be equal to 1\. Add the following line to `index.html`, just after
    the `<head>` tag:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了针对移动设备的行为，我们有另一个问题要解决。为了表示页面的桌面版本，然后让用户放大和缩小，移动设备会伪造它们的实际分辨率。为了强制移动浏览器暴露其真实尺寸并禁用缩放，我们可以使用`<meta>`标签。该标签基本上表示最大和最小缩放因子必须等于1。在`index.html`文件中的`<head>`标签后面添加以下行：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Well done! Now all we have to do is find the size we want to use as a trigger
    to enable our "mobile" CSS. We''ll use `320px`, which is the size of an iPhone
    handled in portrait mode. So let''s create a new `application_mobile.css` file
    under the `css` folder, and add the following `link` element just below the previous
    one in our `index.html` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在我们只需要找到要用作触发器以启用我们的“移动”CSS的大小。我们将使用`320px`，这是iPhone在纵向模式下的大小。因此，让我们在`css`文件夹下创建一个新的`application_mobile.css`文件，并在`index.html`文件中的上一个`link`元素下面添加以下`link`元素：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Styling the mobile version
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动版本设置样式
- en: Now we are ready to start styling the mobile version of this project. To accomplish
    this, we're going to transform the menu from a horizontal shape to a vertical
    one. Instead of having a second-level menu, we will instead create some cards
    and make them slide in when the corresponding first-level menu item is clicked.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始为该项目的移动版本设置样式。为了实现这一点，我们将把菜单从水平形状转换为垂直形状。我们将不再使用二级菜单，而是创建一些卡片，并在单击相应的一级菜单项时使它们滑入。
- en: 'So, first of all, let''s write the necessary CSS to change the shape of our
    menu (within `application_mobile.css`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先让我们编写必要的CSS来改变我们菜单的形状（在`application_mobile.css`中）：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first highlighted instruction shows how we can take advantage of a really
    useful property called `box-sizing`, which basically says which parts of an element
    are influenced when setting its width. The options are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个突出显示的指令显示了我们如何利用一个非常有用的属性，称为`box-sizing`，它基本上表示在设置元素宽度时受影响的部分。选项如下：
- en: '`content-box`: In this option, width refers only to the box that surrounds
    the element''s content. Padding, margin, and border widths are excluded.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content-box`：在此选项中，宽度仅指围绕元素内容的框。填充、边距和边框宽度被排除。'
- en: '`padding-box`: This option is the same as the previous one, but this time width
    includes padding. Border and margin widths are still excluded.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding-box`：此选项与前一个选项相同，但这次宽度包括填充。边框和边距宽度仍然被排除。'
- en: '`border-box`: This option is the same as the previous two, but this time only
    the margin width is excluded.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`border-box`：此选项与前两个选项相同，但这次只有边距宽度被排除。'
- en: 'So when we write the following, we ask the browser to take care of 30 px of
    padding within the `100%` width:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们编写以下内容时，我们要求浏览器在`100%`宽度内处理30px的填充：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we now try to load the project in a mobile browser (for example, from the
    iPhone simulator), or if we resize our desktop browser window below 320 px, we
    can experiment with this layout:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试在移动浏览器中加载项目（例如，从iPhone模拟器中），或者如果我们将桌面浏览器窗口调整到320px以下，我们可以尝试这种布局：
- en: '![Styling the mobile version](img/3264OT_03_13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![为移动版本设置样式](img/3264OT_03_13.jpg)'
- en: 'We''ve already added the property `transition: left 1s` in the mobile version
    of the CSS code (`application_mobile.css`), so all we need to do is move the second-level
    menu to `left: 0px` when the corresponding first-level menu is clicked, in order
    to make it overlap the first-level menu. To achieve this, we can take advantage
    of the `:hover` pseudo-selector, which, in a mobile environment, is triggered
    when the user touches an element. So we can write the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经在CSS代码的移动版本（`application_mobile.css`）中添加了属性`transition: left 1s`，所以我们需要做的就是在相应的一级菜单被点击时将二级菜单移动到`left:
    0px`，以使其重叠在一级菜单上。为了实现这一点，我们可以利用`:hover`伪选择器，在移动环境中，当用户触摸元素时会触发。因此我们可以写如下：'
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The most important statement is the one highlighted; the others are there only
    to adjust some minor visual details. Now we can reload the project to appreciate
    the effects of the code we just wrote:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的语句是突出显示的那个；其他的只是为了调整一些细微的视觉细节。现在我们可以重新加载项目，欣赏我们刚刚编写的代码的效果：
- en: '![Styling the mobile version](img/3264OT_03_14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![为移动版本添加样式](img/3264OT_03_14.jpg)'
- en: Handling the new layout on desktop browsers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在桌面浏览器上处理新布局
- en: 'What we did in the last chunk of code works on mobile devices, but fails on
    desktop browsers because of the difference in the behavior of the `:hover` pseudo-selector.
    Even though it is really unlikely that someone would ever explore this project
    from a desktop computer with a browser whose width is less than 320 px, we can
    use a bit of JavaScript to address this problem. The following is the code to
    add to `index.html` before the `</head>` tag:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最后一部分代码中所做的对移动设备有效，但在桌面浏览器上失败，因为`：hover`伪选择器的行为不同。尽管几乎不太可能有人会从宽度小于320像素的桌面计算机浏览器中探索这个项目，但我们可以使用一点JavaScript来解决这个问题。以下是要添加到`index.html`中的代码，放在`</head>`标签之前：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this code we check if the browser doesn't support touch events (and therefore
    doesn't support the `:hover` behavior we need) and then, if true, we add a `data-status='selected'`
    attribute to the element of the first-level menu that has been clicked by the
    user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们检查浏览器是否不支持触摸事件（因此不支持我们需要的`:hover`行为），然后，如果为真，我们为用户点击的一级菜单元素添加`data-status='selected'`属性。
- en: 'To achieve this result, we used a very interesting library that we''ll cover
    in detail in the next chapter: Modernizr ([http://modernizr.com/](http://modernizr.com/)).
    This library contains some methods that check the presence of most of the HTML5
    and CSS3 features (for example, `Modernizr.touch`) returning `true` or `false`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个结果，我们使用了一个非常有趣的库，我们将在下一章中详细介绍：Modernizr ([http://modernizr.com/](http://modernizr.com/))。这个库包含一些方法，用于检查大多数HTML5和CSS3特性的存在（例如，`Modernizr.touch`），返回`true`或`false`。
- en: Additionally, each feature is also expressed in the form of a class attached
    to the `html` element. For example, if there is a support for touch events, the
    `html` element receives the class `touch`; otherwise it receives the class `no-touch`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个特性也以附加到`html`元素的类的形式表示。例如，如果支持触摸事件，`html`元素会接收`touch`类；否则，它会接收`no-touch`类。
- en: 'To complete this step, all we need to do is restrict the selector that uses
    `:hover` to touch-enabled devices only and take care of the new `data-status="selected"`
    attribute. To do so, we need to change a little the `nav > ul > li > .item:hover
    + ul` selector within `application_mobile.css`, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步，我们需要做的就是将使用`:hover`的选择器限制为仅触摸设备，并处理新的`data-status="selected"`属性。为此，我们需要在`application_mobile.css`中稍微更改`nav
    > ul > li > .item:hover + ul`选择器，如下所示：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Final adjustments
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终调整
- en: 'We can now conclude this project by adding some more enhancements with the
    `:after` and `:before` pseudo-selectors. So let''s add this final touch to `application_mobile.css`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过`:after`和`:before`伪选择器为这个项目添加一些更多的增强。所以让我们在`application_mobile.css`中添加这个最后的修饰：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Every time we use CSS-generated content, we have to remember that the content
    we inject is not handled by a screen reader; so we have to take care of that either
    by injecting only non-essential content, such as in this case, or by providing
    a fallback mechanism.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用CSS生成的内容时，我们必须记住，我们注入的内容不会被屏幕阅读器处理；因此，我们必须通过注入仅非必要内容（例如在这种情况下）或提供备用机制来处理。
- en: 'Ok, let''s reload the project in our mobile browser simulator for the last
    time to see the final result:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们最后一次在移动浏览器模拟器中重新加载项目，看最终结果：
- en: '![Final adjustments](img/3264OT_03_15.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![最终调整](img/3264OT_03_15.jpg)'
- en: Improving speed
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高速度
- en: 'If we want to improve the speed of the "slide in" animation, one of the most
    effective change we can implement is removing transparency from the background.
    To do this, we have to add some more CSS to `application_mobile.css` in order
    to overwrite the settings inherited from the desktop version:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要改进“滑入”动画的速度，我们可以实施的最有效的变化之一是从背景中去除透明度。为此，我们必须在`application_mobile.css`中添加一些CSS，以覆盖从桌面版本继承的设置：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementing in older browsers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在旧版浏览器中实现
- en: 'We have been careful while developing this project, so even if the animations
    and the gradients are not supported by older browsers, the basic structure works
    perfectly. The following is a screenshot taken from Internet Explorer 8:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开发这个项目时非常小心，所以即使旧版浏览器不支持动画和渐变，基本结构仍然完美运行。以下是从Internet Explorer 8中截取的屏幕截图：
- en: '![Implementing in older browsers](img/3264OT_03_16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![在旧版浏览器中实现](img/3264OT_03_16.jpg)'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we experimented with the power of media queries and we started
    discovering animations and transitions. We also discovered the differences between
    `display:inline-block` and floating elements, and we started collecting a few
    tips on mobile performances. Of course we will have time to dig deeper into these
    new features in the following chapters, to discover many other interesting CSS3
    properties.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们尝试了媒体查询的强大功能，并开始探索动画和过渡效果。我们还发现了`display:inline-block`和浮动元素之间的区别，并开始收集一些关于移动性能的小贴士。当然，在接下来的章节中，我们会有时间深入了解这些新特性，发现许多其他有趣的CSS3属性。
- en: However, now it's time to turn the page and start working on a new interesting
    project involving handling infographics!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在是时候翻开新的一页，开始着手处理一个涉及信息图表的新项目了！
