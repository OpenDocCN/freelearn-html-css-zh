# 第二章：CSS 在规模上的问题

在上一章中，我们谈到了导致 ECSS 方法论产生的场景。开发人员发现很难理解、难以处理并且充斥着缺乏注释和冗余代码的大型 CSS 代码库。然而，没有 CSS 代码库是这样开始的。

在大多数项目中，CSS 始于一些简单的规则。在开始时，您必须做一些相当愚蠢的事情才能使 CSS 的维护成为问题。

然而，随着项目的发展，CSS 也在增长。要求变得更加复杂。更多的作者参与编写样式。边缘情况和浏览器的解决方法需要被编写和考虑进去。事情很容易变得混乱。

让我们考虑一下一个不起眼的小部件所面临的不断增长的需求：

+   当小部件在侧边栏中时，我们可以减小字体大小吗？

+   当我们在主页时，小部件可以有不同的背景颜色吗？

+   在更大的视口中，我们可以让小部件内部的东西垂直堆叠吗？

+   当小部件在产品页面的侧边栏中时，字体颜色需要改变

不久之后，我们需要对一个关键选择器写一系列覆盖。让我们考虑一下我们可能需要的选择器：

```css
.widget{
    /* Base Styles */
}

aside#sidebar .widget {
    /* Sidebar specific */
}

body.home-page aside#sidebar .widget {
    /* Home page sidebar specific */
}

@media (min-width: 600px) {
    .widget {
        /* Base Styles 600px and above */
    }

    aside#sidebar .widget {
        /* Sidebar specific 600px and above */
    }

    body.home-page aside#sidebar .widget {
        /* Home page sidebar specific 600px and above */
   }    
}

body.product-page .widget {
    /* Product page specific */
}

body.product-page aside#sidebar .widget {
    /* Product page sidebar specific */
}
```

如果这是我们想要扩展的 CSS，那么在这里存在一些基本的编写问题。现在让我们考虑一下这些规则中更明显的问题。

### 注

术语*关键选择器*用于描述任何 CSS 规则中最右边的选择器。这是您试图对其进行更改的选择器。

# 特异性

在尝试扩展 CSS 时，首要问题是特异性的问题。通常，特异性是一件有用的事情。它允许我们在 CSS 中引入一些逻辑。比其他样式更具体的样式将被应用在浏览器中。我们上面的例子证明了这一点：不同的规则将在不同的情况下应用（例如，在侧边栏中，我们希望覆盖默认样式）。

现在，CSS 选择器可以由 ID、类、属性和类型选择器组成，以及这些的任意组合。在响应式设计中，您还可以将媒体查询加入其中。

然而，并非所有选择器都是平等的。W3C 在这里描述了特异性的计算方式：[`www.w3.org/TR/css3-selectors/#specificity`](http://www.w3.org/TR/css3-selectors/#specificity)。以下是最相关的部分：

> *选择器的特异性计算如下：计算选择器中 ID 选择器的数量（= a）计算选择器中类选择器、属性选择器和伪类的数量（= b）计算选择器中类型选择器和伪元素的数量（= c）忽略通用选择器否定伪类内的选择器与其他选择器一样计数，但否定本身不算作伪类。将这三个数字 a-b-c 连接起来（在一个大基数的数字系统中）得到特异性。*

那里缺少的一个重要事情是样式属性。关于此的信息*在其他地方*（[`www.w3.org/TR/css-style-attr/`](https://www.w3.org/TR/css-style-attr/)）告诉我们：

> *样式属性中的声明适用于该属性所属的元素。在级联中，这些声明被认为具有作者来源和比任何选择器更高的特异性。*

因此，在元素的样式属性中应用的样式将比 CSS 文件中的等效规则更具体。

无论如何，这里最重要的一点是 ID 选择器比基于类的选择器更具体。这使得覆盖包含基于 ID 的选择器的任何选择器变得更加困难。例如，在侧边栏中的小部件中，这不起作用：

```css
.widget {
   /* Widget in the sidebar */
}

aside#sidebar .widget {
    /* Widget in an aside element with the ID of sidebar */
}

.class-on-sidebar .widget {
    /* Why doesn't this work */
}
```

在这种情况下，我们将在侧边栏元素（具有 ID 为侧边栏的 aside 元素）上应用 HTML 类（`class-on-sidebar`），然后在 CSS 中选择比基于 ID 的选择器更低的位置。然而，规则仍然不会被应用。

根据 W3C 规范，我们知道了特异性，我们可以计算这些规则的特异性。

让我们来算一下。从左到右，下面选择器后面的数字与：内联样式的数量、ID 选择器的数量、类选择器的数量以及最后类型选择器的数量有关。

| **选择器** | **内联** | **ID** | **类** | **类型** |
| --- | --- | --- | --- | --- |
| `.widget` | 0 | 0 | 1 | 0 |
| `aside#sidebar .widget` | 0 | 1 | 1 | 1 |
| `.class-on-sidebar .widget` | 0 | 0 | 2 | 0 |

所以你可以看到这里，中间的选择器比最后一个选择器的特异性更高。遗憾。

在单个或较小的文件中，这并不是什么大问题。我们只需创建一个更具体的规则。然而，如果你的代码库的 CSS 分布在许多较小的部分 CSS 文件中，找到阻止你的覆盖工作的规则可能会成为一个不必要的负担。现在，问题不再是特异性选择器的问题。这更像是样式表中不平衡加权选择器的问题。可以把它想象成一个重量级拳击手对阵一个蝇量级拳击手。这不是一个公平的比赛。在使用的选择器之间创造一个公平的竞争环境比实际使用的选择器更重要。

这种不匹配的选择器混合是特异性问题的关键。一旦你有了一个包含数百条规则的 CSS 代码库，任何不需要的特异性都开始成为快速开发的主要障碍。

因此，总之，特异性是我们需要解决的问题，它存在于不断增长的 CSS 代码库中。

# 与选择器相关的标记结构

在编写大规模 CSS 时要避免的另一种做法是使用类型选择器；与特定标记相关的选择器。例如：

```css
aside#sidebar ul > li a {
    /* Styles */
}
```

在这种情况下，我们需要在`sidebar`元素的内部有一个`ul`元素内部有一个`li`元素内部有一个`a`标记 - 哎呀！

如果我们想将这些样式应用到其他地方的`div`上会发生什么？或者任何其他标记结构？

我们刚刚不必要地将我们的规则与特定的标记结构联系在一起。这样做通常是很诱人的，因为给某些看似微不足道的标记（如`a`或`span`标记）添加类似的东西似乎很荒谬。然而，我希望一旦你读完这本书，你会被说服避免这种做法。

我们希望 CSS 尽可能地与结构松散耦合。这样，如果我们需要引入一个覆盖（特定实例的更具体选择器），我们可以尽可能地保持模糊以完成工作。再次，要习惯于只引入所需的特异性。

# 级联

通常，层叠样式表的级联部分是有用的。即使在使用的选择器中特异性非常相等，级联也允许在 CSS 中更深的位置应用等效规则。

然而，在一个庞大的代码库中，级联呈现了一种不良的诱惑；开发人员可以通过简单地在现有 CSS 底部编写更多新代码来修改现有 CSS 的能力。

这种诱惑既真实又容易被认同。出于许多原因，这可能是诱人的。例如，熟悉其他语言的作者可能缺乏对 CSS 代码库的信心或深入了解，无法自信地删除或修改现有代码。因此，他们选择最安全的选项，并使用更具体的规则覆盖现有规则。当时，这似乎是负责任的做法——只在需要时添加一两条规则。

然而，以这种方式依赖级联的问题在于，随着时间和迭代的进行，CSS 代码变得臃肿，充斥着许多多余的规则。这些 CSS 的使用者（用户）下载的是浏览器根本不需要的垃圾代码，而这些代码的维护者在每次需要理清代码库时都需要筛选更多的代码。

# 总结

到目前为止，我们已经从高层次上看到了一些问题，这些问题表明了一个在规模上难以应对的 CSS 代码库所面临的困境。问题包括过于具体的选择器、与特定标记结构相关联的选择器以及依赖级联和导致 CSS 膨胀的诱惑。

在下一章中，我们将探讨尝试驯服大型 CSS 代码库的公认智慧和方法，并考虑它们可能存在的不足之处。
