# 第四章。介绍 ECSS 方法论

在上一章中，我们考虑了现有的 CSS 方法论，以及对于我们谦逊的作者来说，它们存在的不足之处。

我不打算说服您持久 CSS 方法是*阿尔法和欧米茄*。然而，它确实具有与现有方法不同的优势和目标。因此，即使整体采用它并不吸引人，我希望您可以借鉴一些东西来解决自己的问题。

ECSS 的亮点：

+   通过隔离每个视觉模式来获得可维护性

+   文件大小随着时间的推移保持最小，因为您可以毫不留情地剪切部分/功能/组件

+   规则是*自我隔离的*

+   类名/选择器可以传达上下文、起源逻辑和变化

+   所有规则、它们的效果和范围都是完全可预测的

当我第一次写关于持久 CSS 时，我预料到会有一些反对声音。那时（2014 年 8 月），没有人真正提倡我所建议的东西。对于扩展 CSS 的普遍看法是抽象视觉模式，尽可能规范设计，并使代码更干燥。*持久 CSS*在某种程度上与这些信念相反。

在本章中，我们不会涉及 ECSS 的具体技术细节，比如命名约定、工具、编写和组织。我们将在以后的章节中详细讨论这些主题。相反，我们将着眼于这种方法的广泛目标和好处，以及与其他方法相比的优势。

### 注

如果您不知道这个缩写，DRY 代表不要重复自己，这是编码时的一个流行目标，以便逻辑只在代码库中写一次，提供一个真实的单一来源。

在我们深入讨论之前，我认为澄清将要使用的术语可能会有所帮助。在不同的方法中，用于定义页面视觉部分的术语有不同的名称。我所提出的建议或我所使用的术语并没有什么新意，重要的是在我们深入讨论之前，我们都在同一页面上。

# 定义术语

我使用术语*模块*来指代功能区域和/或创建它的代码。举例来说，网站的页眉可以被视为一个模块。页眉模块将由其他更小的功能部分组成。例如，下拉菜单或搜索框。这些嵌套的功能部分将被定义为组件。最后，我们最小的*项*将是组件或模块的组成部分的子节点。

因此，重申一下：

+   **模块**是最宽的、在视觉上可识别的、独立的功能部分

+   **组件**是包含在模块中的嵌套功能部分

+   **子节点**是组件的组成部分（通常是 DOM 中的节点）

为了简洁起见，接下来，当我提到模块时，它可能是一个模块或组件。从 ECSS 编写的角度来看，这种区别并不重要。

# ECSS 解决的问题

我的 ECSS 的主要目标是将样式隔离开来，而不是将其抽象化。

通常情况下，创建 CSS 类的抽象常见功能是有意义的。好处在于它们可以在许多不同的元素上被重复使用和重新应用。原则上这是合理的。问题是，在更大更复杂的用户界面上，即使对这些抽象进行微小的调整和修改也变得不可能，因为这样做会无意中影响到您不打算影响的东西。

因此，ECSS 的一个指导原则是将样式隔离到预期的目标上。

根据您的目标，即使重复，孤立性也可以为您带来更大的优势；允许可预测的样式和简单的样式解耦。

隔离样式的另一个优势是，设计师可以被鼓励带来他们需要的任何东西，而不一定感到受到现有视觉模式的限制。需要编写的每个新模块都可以是一个*绿地*。我发现，当从头开始编写设计时，我可以比尝试从任意数量的模糊抽象中构建它们更快地编写出设计。

# 处理特异性

我还想消除与特异性相关的问题。因此，我采用了广泛使用的方法，坚持所有选择器都使用单个（或尽可能接近理想的）基于类的选择器。

| | *如果你遇到 CSS 问题，我为你感到难过，我有 99 个问题，但特异性不是其中之一* | |
| --- | --- | --- |
| | --*[`twitter.com/benfrain/status/537339394706141184`](https://twitter.com/benfrain/status/537339394706141184)* |

此外，结构化的 HTML 元素（除了伪元素）在样式表中永远不会被引用为类型选择器。此外，ECSS 完全避免使用 ID 选择器。不是因为 ID 选择器本身不好，而是因为我们需要选择器强度的公平竞争环境。

通过简单的覆盖来处理组件的*更改*。然而，从作者的角度来看，它们的处理方式使它们易于管理和理解。

假设您有一个元素，如果它在特定容器内，需要具有不同的宽度-非常简单，我们不需要以严厉的方式进行覆盖。我们不需要将修改器应用于该特定元素。我们可以处理典型和非常宽松的覆盖场景，但可以自信地管理它们。您可以在作者样式表中这样编写：

```css
.my-Module_Component {
    width: 100%;
    /* If in the sidebar */
    .sw-Sidebar & {
        width: 50%;
    }
}

```

它将产生以下 CSS：

```css
.my-Module_Component {
  width: 100%;
}

.sw-Sidebar .my-Module_Component {
  width: 50%;
}

```

这可能看起来是一个微小的好处。毕竟，我们可能会以稍微不同的方式编写代码，通过嵌套覆盖，但最终结果是典型的 CSS；一个元素根据不同和更具体的选择器获得不同的样式。

### 提示

在嵌套上下文中使用和符号来表示父选择器的约定是从*Sass*（[`sass-lang.com/`](http://sass-lang.com/)）语言借鉴的。

然而，通过采用这种方法，从作者的角度来看，我们为每个关键选择器创建了一个*真理的单一来源*。将对该关键选择器进行任何更改的所有内容都嵌套在那组花括号的开头内。此外，该关键选择器永远不会在整个代码库中的任何其他地方被定义为根规则。

### 注意

**DRY 的不同解释**

我并不认为其他 CSS 开发者追求和赞美的 DRY 代码目标，是我想要的那种 DRY 代码。更具体地说，我并不太在意规则中重复的值和对，这是大多数人关注的 DRY 化的内容。我关心的是关键选择器在代码库中不重复。关键选择器是我的*真理的单一来源*，这是我想要 DRY 化的领域。因此，在 ECSS 中，我们强制执行了一种作者约定，防止在整个项目中多次定义关键选择器。我们将在第八章中更详细地讨论这个问题，*理智样式表的十诫*。

## 这是！重要

偶尔，一个覆盖的存在不够，我们可以使用`!important`。

您可能已经意识到，在 CSS 中使用`!important`通常是不受欢迎的。以下是 MDN 对`!important`的看法：

| | *当在样式声明中使用!important 规则时，此声明将覆盖 CSS 中的任何其他声明，无论它在声明列表中的位置如何。尽管!important 与特异性无关，但使用!important 是一种不好的做法，因为它使调试变得困难，因为它破坏了样式表中的自然级联* | |
| --- | --- | --- |
|   | --*[`developer.mozilla.org/en-US/docs/Web/CSS/Specificity`](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity)* |

然而，当我们无法控制的事件影响我们的样式（例如，在页面上加载了第三方 CSS 文件），我们需要一些权威，我会接受`!important`。以下是一个状态变化的例子，它从`!important`获得了额外的支持：

```css
[aria-expanded="true"] & {
    transform: translate3d(0, -$super-height,
    0)!important;
}

```

我会诚实地说，当需要时，我真的不会因为使用`!important`而失眠。由于所有的覆盖都局限于它们在编写样式表中的父选择器，偶尔使用`!important`在 ECSS 中并不会出现问题。

# 接受重复

在我们进一步深入之前，我认为有必要处理一个可能存在的*悬而未决的问题*。我需要试图说服你，消除文件之间属性和值的重复可能并不像从维护的角度来看那么有价值，而是一个坚实且包含的模块集，可以根据需要轻松从代码库中删除。

ECSS 方法接受 CSS 中属性和值的重复。

使用 ECSS，每个视觉模块或组件都是用微命名空间编写的，以便与其他模块和组件隔离。以下是一个经过编写的 ECSS 规则的典型示例（编写语法与 Sass 非常相似，但通常由 PostCSS 进行辅助）：

```css
.ip-SubHeader_Wrapper {
    @mixin Headline;
    align-items: center;
    /* We want the subheader hidden by default at the
    smallest sizes */
    display: none;
    font-size: $text12;
    background-color: $color-grey-54;
    border-bottom: 1px solid color($color-grey-54 a(.5));
    min-height: $size-fine-quadruple;
    @media (min-width: $SM) {
        display: inline-block;
    }
    @media (min-width: $M) {
        display: flex;
        background-color: $color-grey-a7;
        color: $color-grey-54;
        font-size: $text13;
        min-height: 1.5rem;
        border-bottom: 1px solid $color-grey-54;
        border-top: 1px solid $color-grey-33;
    }
    /* However, even on mobile, if the SubHeader Wrapper
    is in section 1, we want to see it */
    .ip-Classification_Header-1 & {
        display: flex;
    }
}

```

倾向于 OOCSS 和 Atomic CSS 方法的人可能会看到这一点而感到恐惧。像`color`和`font-size`这样的东西在大多数组件中都有声明。`@mixin Headline` mixin 也会生成大量的 CSS 来指定特定的字体堆栈。所以，是的，有属性和值的重复。

然而，积极的一面：

+   它冗长，但不依赖于样式的继承。

+   它通常是与上下文无关的（除了它所放置的大小上下文），影响这个组件的任何媒体查询都在这一组花括号内定义。

+   这样的关键选择器只需编写一次。当这个关键选择器需要更改时，你只需要在这一个地方查找。

+   编写的规则中所有的覆盖都嵌套在其中，形成了一种微型级联。通常情况下，覆盖可以出现在 CSS 的任何地方，遵循这种方法将它们限制在一个非常特定的区域。这样就更容易理解特定性与规则的关系。

# 零组件抽象

使用 ECSS，如果需要创建一个与现有组件类似但略有不同的组件，我们不会从现有组件中抽象或扩展。而是会编写一个新的组件。

是的，我是认真的。

即使有 95%是相同的。

这样做的好处是，每个组件都是独立的和隔离的。一个可以存在而另一个不需要。一个可以根据需要进行变化，而与其他组件独立。尽管它们在外观上看起来很相似，但它们可以根据需要进行变异，而不用担心感染或污染其他看起来相似的组件。延伸生物学的隐喻，我们获得了*自我隔离*的组件，通过它们独特的命名空间。

### 注意

进一步的类比：BMW 3 系与 BMW 5 系有很多共同之处。但它们并不相同。它们可能共享一些/许多零件（相当于 CSS 属性和值的组合），但这并不意味着它们是相同的。它们的差异定义了它们。它们不能由完全相同的零件制成，因为它们之间有根本的不同。我认为这也适用于使用 ECSS 定义的模块和组件。CSS 语言是抽象的。CSS 的属性/值对已经意味着我们可以从单个部分构建我们想要的东西。

# 重复的成本？

要充分利用 ECSS 的好处，你需要对它所创建的属性和值的重复感到舒适。此时，你可能会认为我是疯了。有了这么多重复，这种 ECSS 方法怎么可能是一个可行的选择？我会用一个词来解决这个问题：gzip。

好吧，我撒了谎。我想进一步说明。

## gzip 在压缩重复字符串方面非常高效

我很好奇像 ECSS 这样的方法中重复属性/值对的冗长实际上产生了什么*真实世界*的差异？一个实验：

我正在进行的一个基于 ECSS 的项目的结果 CSS 文件，在经过 gzip 压缩后（因为它将通过网络传输），大小为 42.9 KB。这是一个相当大的 CSS 文件。

这个样式表中可以从中抽象出来的最常见和冗长的模式是一对基于 Flex 的规则，它们在整个样式表中被大量使用，用于垂直居中其容器中的内容。由于*Autoprefixer*（[`github.com/postcss/autoprefixer`](https://github.com/postcss/autoprefixer)）添加了大量代码以支持旧设备，它们甚至更冗长。例如，定义 flex 布局的结果 CSS 是：

```css
.flex {
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex;
}

```

在测试样式表中，这四行 CSS 被重复了**193**次。

这只是其中一半。许多这些项目也需要对齐。这在 CSS 中也是必需的：

```css
.flex-center {
    -webkit-box-align: center;
    -webkit-align-items: center;
    -ms-flex-align: center;
    align-items: center;
}

```

这个代码块被重复了**117**次。看起来没有更好的理由来抽象成一个 OOCSS 类，对吧？那一定会导致严重的膨胀？

不要那么着急，蝙蝠侠！

如果这些代码块被移除并重新压缩文件，CSS 文件大小将减少到 41.9 KB。

将最常见和冗长的视觉模式提取到一个 OOCSS 类中，仅在传输过程中节省了 1 KB 的 CSS。尽管 CSS 仅节省了 1 KB，但要考虑到，如果将这些样式抽象为单一职责类（例如`.flex`和`.flex-center`），还需要在 HTML 中添加相关的 OOCSS 类来恢复视觉效果。

这是否使得单一职责类值得？

考虑到没有其他属性组合有类似的冗长和重复，从文件大小的角度来看，当然不是在我的书中。这将会大大降低开发的灵活性（记住，抽象会使作者和迭代变慢，因为需要同时更改模板和 CSS）和响应灵活性（如果我想在不同的视口中做一些不同的事情）以换取 CSS 文件大小的微小节省。这就是 CSS 版的*拿来主义*。

让我非常清楚。尽管 gzip 的效果很好，如果你的优先级是拥有尽可能小的 CSS 文件大小，ECSS 并不是你最好的选择。

相反，去看看*Atomic CSS*（[`acss.io/`](http://acss.io/)）。它的创作者是聪明人，确实，*Thierry Koblentz*（[`www.cssmojo.com/`](http://www.cssmojo.com/)）是我所知道的最聪明的 CSS 人之一。我相信 ACSS 会满足你的需求。

另一方面，ECSS 的优先级是开发人员的人体工程学（可理解的类命名约定）、易维护性（按组件组织的样式，易于删除）和样式封装（命名空间防止泄漏的抽象）。

不同的问题，不同的解决方案。

# 总结

希望我已经给了你足够的理由来考虑，如果你试图创建可维护的样式表，那么过度关注重复的属性值和对可能不是最好的时间利用。在下一章中，除了看看 ECSS 命名约定的好处之外，我还会争辩说，对项目维护采取合理的组织方法将比类抽象和重用在长期内生成更精简的样式表。
