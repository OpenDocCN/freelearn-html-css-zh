# 第五章：文件组织和命名约定

在上一章中，我们对 ECSS 的设计考虑进行了高层次的概述。在本章中，我们将深入探讨如何实际开始使用 ECSS。

使 ECSS 适合您的两个基石是遵守文件组织和类命名约定原则。让我们接下来看看这些方面。

# 项目组织

如果我们想要方便地从我们的网站/应用程序中删除代码，我们需要考虑我们组成项目的文件的方式。通常，在构建网站，特别是 Web 应用程序时，考虑模块或组件的方式是有用的；可定义的用户界面部分。这些模块可能主要由视觉区域定义，或者可能由生成它们的文件定义。无论哪种方式，花时间考虑这些模块的组织都是值得的。

通常，按技术类型将项目中的文件拆分是一种常见做法。

考虑这个基本的文件夹结构：

```css
my-project/
- html/
- js/
- css/
```

在这些文件夹中，您可能会命名相关文件。例如：

```css
my-project/
- html/
    - v2ShoppingCart.html
- js/
    - v2ShoppingCart.js
- css/
    - v2ShoppingCart.css
```

然而，问题在于，超过一定程度后，即使给文件命名，也很难理清项目中每个样式表、逻辑文件和模板之间的关系。在`css`文件夹中可能有 80 多个 CSS 部分，在`html`文件夹中可能有 50 多个模板存根。

### 注意

我意识到现实情况是，网站或应用程序的*view*部分通常是由多种不同的技术生成的，如 Ruby、PHP、.NET 甚至 JavaScript - 而不是纯粹的 HTML。

随后，越来越需要依赖*find*在文本编辑器/IDE 中查找某个类别正在使用的任何模板。反之亦然；需要*find*来定位包含某个模块模板所需样式的部分。

这种结构并不会使事情变得不可行，只是效率低下，通常需要一点心理定位来记住什么与什么相关。

虽然对于 ECSS 来说并非必需，但通常更倾向于按视觉或逻辑组件组织文件，而不是按技术类型组织。因此，不是这样：

```css
html/
- shopping-cart-template.html
- callouts-template.html
- products-template.html

js/
- shopping-cart-template.js
- callouts-template.js
- products-template.js

css/
- shopping-cart-template.css
- callouts-template.css
- products-template.css
```

我们的目标是这样的：

```css
shopping-cart-template/
    - shopping-cart.html
    - shopping-cart.css
    - shopping-cart.js

callouts-template/
    - callouts.html
    - callouts.js
    - callouts.css

products-template/
    - products.html
    - products.js
    - products.css
```

乍一看，这似乎是一个看似不重要的区别，但它带来了重要的好处。

每个组件的代码都是物理上自包含的。然后，在我们持久的项目中，当需要更改或废弃功能时，可以轻松更新/删除与该模块相关的所有代码（样式、视图逻辑（HTML）和 JS）。

### 注意

**应有的赞誉**

*Nicolas Gallagher* ([`nicolasgallagher.com/`](http://nicolasgallagher.com/)) 在考虑规模化的 CSS 实现时总是领先一步，我从他的工作中借鉴并调整了大部分元素（特别是按组件组织代码）。我已经为组件命名空间化了一段时间（因此我宣称伪多重发现），但按组件组织代码的方法完全是从*听他谈论* ([`www.youtube.com/watch?v=m0oMHG6ZXvo`](https://www.youtube.com/watch?v=m0oMHG6ZXvo)) 中得来的。

除了有意的*全局*CSS 之外，与组件或模块的呈现相关的所有代码都应包含在与该组件的 HTML/JS 并列的部分中。

### 注意

尽管你可能不喜欢，但总是需要一定程度的全局 CSS；至少需要一组简单的重置或规范化样式。

当一个模块被废弃时，可以轻松地一次性从代码库中删除与之相关的所有文件；只需删除包含该模块的文件夹。

为了明确，考虑我们想象中的`ShoppingCart`组件的文件夹结构：

```css
ShoppingCart/
    - ShoppingCart.js
    - ShoppingCart.css
```

现在假设我们创建一个新的购物车：

```css
v2ShoppingCart/
    - v2ShoppingCart.js
    - v2ShoppingCart.css
```

一旦我们的`v2`购物车完成，就可以轻松地从我们的代码库中删除先前版本的代码；我们只需删除包含旧代码的`ShoppingCart`文件夹。

## 当无法使用相同的文件夹组织时

可能无法或不希望将样式表、资源和应用程序逻辑包含在同一个文件夹中。

在这种情况下，下一个最佳选择是模仿逻辑的结构。举例来说。假设一个组件的逻辑存储在这样的文件夹结构中：

```css
src/app/v2ShoppingCart/v2ShoppingCart.js
```

我们应尽可能模仿这种结构。在任何规模的应用程序中，这将使查找相关文件变得更容易。因此，我们可以这样做-尽可能地匹配逻辑文件的文件夹层次结构：

```css
src/app/css/v2ShoppingCart/v2ShoppingCart.css
```

在使用 ECSS 时，相同的父文件夹应该被认为是*黄金*标准，但在没有这种情况下，模仿逻辑文件的结构应该能够提供一些好处。

有了如何组织项目中的文件的具体想法，让我们转向我们可以向我们的选择器/类传达附加含义和开发人员便利的主要方式。

# 使用 ECSS 命名类和选择器

回到第三章，*实施接收到的智慧*，我意识到 BEM 方法在命名 CSS 选择器方面给我们带来的好处。首先命名一个块，然后根据该块命名任何子元素，为子元素创建了一个命名空间。

模块的 CSS 命名空间创建了一种隔离形式。通过防止与其他元素发生名称冲突，CSS 块可以更轻松地从一个环境移动到另一个环境（例如从原型到生产）。这也大大减少了一个选择器的样式更改无意中影响其他选择器的可能性。

### 注意

有许多其他方法来解决名称冲突的问题。例如，如果您正在使用流行的*React* ([`facebook.github.io/react/`](https://facebook.github.io/react/)) 框架构建应用程序，请考虑使用*Radium* ([`github.com/FormidableLabs/radium`](https://github.com/FormidableLabs/radium))，它将为每个节点内联样式，因此您可以有效地不提供任何 CSS。当然，这也存在一些权衡，比如缺乏缓存和无法添加重置样式，但它确实解决了手头的问题。此外，当不使用 React 构建时，请考虑*CSS 模块* ([`github.com/css-modules/css-modules`](https://github.com/css-modules/css-modules))。虽然需要比 ECSS 更多的工具支持，但它意味着您可以完全不考虑命名事物，因为它会为您创建 CSS 作用域。在这里*了解更多* ([`medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284`](https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284))。

ECSS 采用选择器命名空间的概念，并将其*提升到 11* ([`en.wikipedia.org/wiki/Up_to_eleven`](https://en.wikipedia.org/wiki/Up_to_eleven))。选择器实际上以两种方式进行命名空间：

+   微型命名空间：通常用于指定上下文，但也可以指示父模块

+   模块自己的命名空间：通常是创建所讨论元素的逻辑文件的名称

让我们更详细地看看这些。*微型*命名空间是每个模块的简单 2-3 个字母的命名空间。构建购物车？尝试使用`.` `sc-` 作为您的微型命名空间。构建同一购物车的下一个版本？那就是`.` `sc2-`。这足以隔离您的组件样式，并允许样式更具自我说明性。让我们考虑一个更复杂的例子。

### 提示

在命名事物时，不同的项目会有不同的合理性。虽然 ECSS 可以适应不同的方法，但我建议在每个项目中采用一致的方法。

例如，假设微命名空间用于传达创建它的逻辑的父级或起源。回到我们的购物车示例。我们可能有一个名为`ShoppingCart.php`的文件，其中包含了与我们想象中的购物车相关的所有逻辑。因此，我们可以使用`sc-`作为该文件名的缩写，以便我们知道以该命名空间开头的任何元素都与购物车相关，并由相关文件渲染。

在这种情况下，我们将有类似以下的选择器：

+   `sc-Title`：购物车的标题

+   `sc-RemoveBtn`：从购物车中移除物品的按钮

这里的选择器非常紧凑-如果一个选择器甚至可以用这种方式描述的话，那么它在美学上是令人愉悦的。然而，假设我们有一个可以存在于多个上下文中的购物车。迷你购物车视图和完整页面视图。在这种情况下，我们可能决定使用微命名空间来传达上下文。例如：

+   `mc-ShoppingCart_Title`：购物车的标题，在*迷你购物车*视图/上下文中由文件`ShoppingCart`生成。

+   `mc-ShoppingCart_RemoveBtn`：购物车的删除按钮，在*迷你购物车*视图/上下文中由文件`ShoppingCart`生成。

这两者都不是唯一的方法。ECSS 哲学的一部分是，虽然一些核心原则是必不可少的，但它可以适应不同的需求。一般来说，对于较小规模的用例，前一种方法是可以的。然而，尽管第二种方法中选择器的相对冗长，但它是最具弹性和自我记录的。通过第二种方法，您可以了解上下文，生成选择器的文件（因此它所属的模块）和它所关联的元素。

### 注意

在第七章中，有关将 ECSS 约定应用于 Web 应用程序和视觉模块的更具体信息，*将 ECSS 应用于您的网站或应用程序*。

## 重申好处

由于命名空间模块和组件几乎肯定不会相互泄漏，因此非常容易构建和迭代新设计。这提供了一个迄今为止难以想象的免责保护。只需为正在构建的事物创建一个新的部分文件，分配一个合适的微命名空间和模块名称，并编写您的样式，确信您不会对任何不想要的东西产生不利影响。如果您正在构建的新事物不起作用，您可以删除部分文件，也可以确信您不会删除其他东西的样式。CSS 编写和维护的信心-终于！

### 源顺序变得不重要

由于我们的规则现在是隔离的，因此样式表中规则的顺序变得不重要。在处理大型项目时，这一好处变得至关重要。在这些情况下，通常希望可以以任何顺序组装部分文件。由于规则彼此隔离，这很简单。有了我们的*自我隔离*规则，部分样式表的文件全局匹配变得简单且无风险。通过一些基本的工具，您可以像这样一次性编译模块中的所有 CSS 部分：

```css
@import "**/*.css";

```

不再为项目中的每个部分编写`@import`语句，并担心它们的顺序。

### 提示

我们将在第九章中更多地讨论文件全局匹配，*ECSS 方法的工具*。

## ECSS 命名约定的解剖

由于项目名称对于实现我们的目标非常有用和必要，下一节将更详细地记录 ECSS 的命名约定。把它想象成你的 CSS 选择器的*Haynes 手册*([`haynes.co.uk/catalog/manuals-online`](https://haynes.co.uk/catalog/manuals-online))。

以下是 ECSS 选择器的分解：

```css
.namespace-ModuleOrComponent_ChildNode-variant {}

```

为了说明各个部分，这是该选择器的解剖，用方括号划分各个部分：

```css
.[namespace][-ModuleOrComponent][_ChildNode][-variant]
```

### 提示

在一个项目中有多个开发人员的情况下，我建议对不遵循 ECSS 命名模式的代码提交进行自动拒绝。关于必要的工具支持的一些信息在第九章中有所涉及，*工具支持 ECSS 方法*。

### 选择器部分的解释

让我们回顾一下 ECSS 选择器的各个部分和允许的字符类型：

+   `Namespace`：这是每个选择器的**必需**部分。微命名空间应该全部小写/短横线命名法。通常是一个缩写，用于表示上下文或起始逻辑。

+   `模块或组件`：这是大驼峰命名法。它应该始终前面有一个连字符（`-`）。

+   `ChildNode`：这是选择器的一个可选部分。它应该是大驼峰命名法，并且前面有一个下划线（`_`）。

+   `Variant`：这是选择器的另一个可选部分。它应该全部小写/短横线命名法。

使用这种语法，类名的每个部分都可以从另一个逻辑上区分出来。更多关于这些部分是什么以及它们应该如何使用的信息如下：

### 命名空间

如上所述，HTML 类/CSS 选择器的第一部分是微命名空间（全部小写/短横线命名法）。命名空间用于防止冲突，并为规则的更轻松维护提供一些软隔离。

### 模块或组件

这是创建选择器的视觉模块或逻辑片段。它应该用大驼峰命名法。我看到 ECSS 被成功应用时，模块或组件直接引用了创建它的文件的名称。例如，一个名为`CallOuts.js`的文件可以有一个选择器，如`sw-CallOuts`（这里的`sw-`微命名空间用于表示它将被*站点范围*使用）。这样可以消除未来开发人员对该元素起点的歧义。

## 子节点

如果某个大驼峰命名法前面有一个下划线（`_`），那么它是模块或组件的子节点。

例如：

```css
.sc-Item_Header {}

```

在这里，`_Header`表示这个节点是属于`sc`命名空间的`Item`模块或组件的`Header`子节点（如果它是一个组件，那么该命名空间可以表示父模块）。

### 变体

如果某个东西全部小写/短横线命名法，并且不是类名的第一部分，那么它是一个变体标志。变体标志保留用于需要引用许多选择器变体的情况。假设我们有一个模块，需要根据分配给它的类别编号显示不同的背景图像。我们可以像这样使用变体指示器：

```css
.sc-Item_Header-bg1 {} /* Image for category 1 */.
sc-Item_Header-bg2 {} /* Image for category 2 */.
sc-Item_Header-bg3 {} /* Image for category 3 */

```

这里选择器的`-bg3`部分表示这个`sc-Item_Header`是类别 3 版本（因此可以分配适当的样式）。

### 在 ECSS 选择器上加倍

我们之前的例子表明了一个完美的情况，适合在元素上使用两个类。一个用于分配默认样式，另一个用于设置变体的具体内容。

考虑这个标记：

```css
<div class="sc-Item_Header sc-Item_Header-bg1">
    <!-- Stuff -->
</div>

```

在这里，我们将使用`sc-Item_Header`为元素设置通用样式，然后使用`sc-Item_Header-bg1`为变体设置特定样式。这种方法并不具有革命性，我只是在这里记录它，以明确指出 ECSS 方法中没有任何阻止这种做法的地方。

# 总结

本章我们涵盖了很多细节。我们主要关注了两个方面：如何组织项目的语言文件，以便更容易维护；以及如何命名 HTML 类/CSS 选择器，使得 DOM 中元素的类可以告诉我们关于其来源、目的和预期上下文的一切。我们还详细研究了 ECSS 选择器的接受语法：在哪里以及如何应用大小写区别来划分选择器的不同部分。到目前为止，我们只关注静态元素。在下一章中，我们将看看 ECSS 如何处理网站或应用程序的变化状态。
