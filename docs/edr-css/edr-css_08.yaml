- en: Chapter 8. The Ten Commandments of Sane Style Sheets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章。理智样式表的十诫
- en: Thou shalt have a single source of truth for all key selectors
  id: totrans-1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该有一个所有关键选择器的单一真相来源
- en: Thou shalt not nest, unless thou art nesting media queries or overrides
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非你正在嵌套媒体查询或覆盖，否则不应该嵌套
- en: Thou shalt not use ID selectors, even if thou thinkest thou hast to
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使你认为你必须使用 ID 选择器，也不应该使用 ID 选择器
- en: Thou shalt not write vendor prefixes in the authoring style sheets
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写样式表中不应该写厂商前缀
- en: Thou shalt use variables for sizing, colours and z-index
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用变量来设置大小、颜色和 z-index
- en: Thou shalt always write rules mobile first (avoid max-width)
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该总是首先编写移动规则（避免使用 max-width）
- en: Use mixins sparingly, and avoid @extend
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节制使用混合，并避免 @extend
- en: Thou shalt comment all magic numbers and browser hacks
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该注释所有魔术数字和浏览器黑客
- en: Thou shalt not inline images
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不应该内联图片
- en: Thou shalt not write complicated CSS when simple CSS will work just as well
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当简单的 CSS 能够正常工作时，你不应该编写复杂的 CSS
- en: Blessed are those that follow these rules for they shall inherit sane style
    sheets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些规则的人是有福的，因为他们将继承理智的样式表。
- en: Amen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 阿门。
- en: Why the ten commandments?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么是十诫？
- en: The following, highly opinionated, set of rules came about as a way to author
    predictable style sheets across teams of developers. Each rule can be enforced
    with tooling. When there is just one CSS developer on a project, spending time
    developing or integrating tooling may seem superfluous. However, beyond a couple
    of active developers the tooling will earn its time investment time and again.
    We will deal with the tooling to *police* the rules in the next chapter. For now,
    let's consider the syntax and the rules themselves.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一套高度主观的规则，是为了在开发团队中编写可预测的样式表而产生的。每个规则都可以通过工具强制执行。当一个项目中只有一个 CSS 开发人员时，花时间开发或集成工具可能看起来是多余的。然而，在超过两个活跃的开发人员之后，工具将一次又一次地赚取它的时间投资。我们将在下一章中处理工具来“监督”规则。现在，让我们考虑语法和规则本身。
- en: Tooling
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具
- en: 'To achieve more maintainable style sheets we can lean upon PostCSS, a piece
    of CSS tooling that allows the manipulation of CSS with JavaScript. The curious
    can look here for more information: [https://github.com/postcss/postcss](https://github.com/postcss/postcss)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更易维护的样式表，我们可以依赖于 PostCSS，这是一个允许使用 JavaScript 操作 CSS 的 CSS 工具。有兴趣的人可以在这里查看更多信息：[https://github.com/postcss/postcss](https://github.com/postcss/postcss)
- en: PostCSS facilitates the use of an extended CSS syntax. For the purpose of authoring,
    the syntax used borrows heavily from *Sass* ([http://sass-lang.com/](http://sass-lang.com/)).
    This provides functionality to make our authoring style sheets easier to maintain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS 促进了扩展 CSS 语法的使用。为了编写，所使用的语法大量借鉴了 Sass ([http://sass-lang.com/](http://sass-lang.com/))。这提供了使我们的编写样式表更易于维护的功能。
- en: 'Using PostCSS we are able to make use of:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PostCSS，我们能够利用：
- en: Variables
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Mixins (like macros for certain settings such as font-families)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合（如宏，用于某些设置，如字体系列）
- en: Referencing a **key-selector** with an ampersand symbol (`&`)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和符号（`&`）引用**关键选择器**
- en: Practically, PostCSS can enable similar functionality to a CSS pre-processor
    such as Sass, LESS or Stylus.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，PostCSS 可以实现类似于 CSS 预处理器（如 Sass、LESS 或 Stylus）的功能。
- en: Where it differs is in its modularity and extensibility. Rather than *swallow
    the whole pill* as is needed with the aforementioned pre-processors, using PostCSS
    allows us to be more selective about the feature set we employ. It also allows
    us to easily extend our feature set at will, either with any number of *off the
    peg* plugins, or, by writing our own plugins with JavaScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它的不同之处在于它的模块化和可扩展性。与前面提到的预处理器需要“吞下整颗药丸”不同，使用 PostCSS 允许我们更加选择我们使用的功能集。它还允许我们轻松地根据需要扩展我们的功能集，可以使用任意数量的“现成的”插件，或者使用
    JavaScript 编写我们自己的插件。
- en: For example, where Sass allows loops to be written, we choose to prevent that
    capability. For instance where looping is needed to solve a specific problem (for
    example, 100 variants of different coloured headers) we can still achieve that
    buy as a PostCSS plugin written in JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Sass 允许编写循环，我们选择阻止该功能。例如，如果需要循环来解决特定问题（例如，100 种不同颜色的标题变体），我们仍然可以通过使用 JavaScript
    编写的 PostCSS 插件来实现。
- en: In addition, thanks to the PostCSS ecosystem, we can perform static analysis
    of the authoring styles with linting; failing builds and code commits when undesirable
    code is authored.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 PostCSS 生态系统，我们可以对编写的样式进行静态分析和 linting；当编写不良代码时，会导致构建失败和代码提交。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case the term *linting* is alien to you, it''s another term for static analysis.
    It looks at the authored code and makes suggestions based on any number of pre-defined
    rules. For example, it might issue a warning if you use floats, or don''t put
    white-space or a semi-colon where required. Generally speaking, you can use linters
    to enforce any kind of coding conventions you like and while more than useful
    when working alone, they can be priceless when working in teams: where many (careless)
    hands might touch the code.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果术语“linting”对你来说是陌生的，那么它是静态分析的另一个术语。它查看编写的代码，并根据任意数量的预定义规则提出建议。例如，如果你使用浮动，或者没有在需要的地方放置空格或分号，它可能会发出警告。一般来说，你可以使用
    linters 来强制执行任何你喜欢的编码约定，而且在独自工作时非常有用，但在团队中工作时可能是无价的：在那里，许多（粗心的）人可能会触及代码。
- en: Rationale
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原理
- en: When we are authoring ECSS, we want to avoid producing CSS that suffers from
    being overly specific, littered with unneeded prefixes, poorly commented and full
    of *magic* numbers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 ECSS 时，我们希望避免产生 CSS，这些 CSS 遭受过于具体、充斥着不需要的前缀、缺乏注释和充满“魔法”数字的问题。
- en: The following 10 rules set-out what are considered to be the most important
    rules to achieve this goal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 10 条规则阐明了被认为是实现此目标最重要的规则。
- en: 'Definitions used throughout:'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Throughout 使用的定义：
- en: '**Override**: A situation where the values of a key selector are purposely
    amended based upon inheritance'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖**：根据继承有意修改关键选择器的值的情况'
- en: '**Key selector**: The right most selector in any CSS rule'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键选择器**：任何 CSS 规则中最右边的选择器'
- en: '**Prefixes**: Vendor specific prefixes e.g. `-webkit-transform:`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前缀**：供应商特定前缀，例如`-webkit-transform:`'
- en: '**Authoring style sheets**: The files we author the styling rules in'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写样式表**：我们在其中编写样式规则的文件'
- en: '**CSS**: The resultant CSS file generated by the tooling and ultimately consumed
    by the browser'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSS**：工具生成的结果CSS文件，最终由浏览器消耗'
- en: Let's now consider each rule and the problem it aims to solve.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑每个规则及其旨在解决的问题。
- en: 1\. Thou shalt have a single source of truth for all key selectors
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 所有关键选择器都应该有一个单一的真相来源
- en: In the authoring style sheets, a key selector should only be written once.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写样式表中，关键选择器应该只写一次。
- en: This allows us to search for a key-selector in the code base and find a *single
    source of truth* for our selector. Thanks to the use of an extended CSS syntax,
    everything that happens to that key selector can be encapsulated in a single rule
    block.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在代码库中搜索关键选择器并找到我们选择器的*单一真相来源*。由于使用了扩展的CSS语法，发生在关键选择器上的一切都可以封装在一个规则块中。
- en: Overrides to the key selector are handled by nesting and referencing the key
    selector with the *parent* selector. More of which shortly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过嵌套和使用*父*选择器引用关键选择器来处理对关键选择器的覆盖。稍后会详细讨论。
- en: 'Consider this example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That would yield the following in the CSS:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在CSS中产生以下结果：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the authoring style sheets, the key selector (`.key-Selector`) is never repeated
    at a root level. Therefore, from a maintenance point of view, we only have to
    search for `.key-Selector` in the code base and we will find everything that could
    happen to that key selector described in a single location; a single source of
    truth.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写样式表中，关键选择器（`.key-Selector`）在根级别永远不会重复。因此，从维护的角度来看，我们只需要在代码库中搜索`.key-Selector`，就能找到关于该关键选择器的一切内容，这是一个单一的真相来源。
- en: What happens if we need it to display differently in a different viewport size?
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要在不同的视口大小下以不同的方式显示，会发生什么？
- en: What happens when it lives within containerX?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它存在于containerX中时会发生什么？
- en: What happens when this or that class gets added to it via JavaScript?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过JavaScript向其添加这个或那个类时会发生什么？
- en: In all these instances the eventualities for that key selector are nested within
    that single rule block. This means that any possible specificity issues are entirely
    isolated within a single set of curly braces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，关键选择器的可能性都嵌套在同一个规则块中。这意味着任何可能的特异性问题都完全隔离在一个大括号集合内。
- en: Let's look at overrides in further detail next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来更详细地看一下覆盖。
- en: Dealing with overrides
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理覆盖
- en: In the prior example, there was a demonstration of how to deal with an override
    to a key selector. We nest the overriding selector inside the rule block of the
    key selector and reference the parent with the `&` symbol. The `&` symbol, as
    in the Sass language, is a parent selector. It might help you to think of it as
    being roughly equivalent to `this` in JavaScript.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，演示了如何处理对关键选择器的覆盖。我们将覆盖选择器嵌套在关键选择器的规则块内，并使用`&`符号引用父级。`&`符号在Sass语言中是父选择器。你可以把它想象成JavaScript中的`this`。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To test rules using the parent selector I recommend [http://sassmeister.com](http://sassmeister.com)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用父选择器测试规则，我建议使用[http://sassmeister.com](http://sassmeister.com)
- en: Standard override
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准覆盖
- en: 'Consider this example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This would yield the following CSS:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下CSS：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This results in a `font-size` increase for the `ip-Carousel` when it is inside
    an element with a class of `ip-HomeCallouts`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致`ip-Carousel`在具有`ip-HomeCallouts`类的元素内部时`font-size`增加。
- en: Override with additional class on same element
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在同一元素上使用额外的类进行覆盖
- en: 'Let''s consider another example, what if we need to provide an override when
    this element gets an additional class? We should do that like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，如果我们需要在此元素获得额外类时提供覆盖？我们应该这样做：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That would yield this CSS:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下CSS：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, the override is contained within the rule block for the key selector.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，覆盖包含在关键选择器的规则块内。
- en: Override when inside another class and also has an additional class
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在另一个类中覆盖并且还有额外的类
- en: 'Finally let''s consider the eventuality where we need to provide an override
    for a key selector inside another element that also has an additional class present:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后让我们考虑一种情况，我们需要为另一个元素内部的关键选择器提供覆盖，该元素还有额外的类：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That would yield the following CSS:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下CSS：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have used the parent selector here to reference our key selector between
    an override above (`.home-Container`) and alongside another class (`.ip-ClassificationHeader`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用父选择器来引用我们的关键选择器，介于上面的覆盖（`.home-Container`）和另一个类（`.ip-ClassificationHeader`）之间。
- en: Override with media queries
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用媒体查询进行覆盖
- en: 'Finally, let''s consider overrides with media queries. Consider this example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑使用媒体查询进行覆盖。考虑这个例子：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That would yield this CSS:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下CSS：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, all eventualities contained within the same rule. Note the use of a variable
    for the media query width? We will come to that shortly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，所有可能性都包含在同一个规则内。注意媒体查询宽度的变量使用？我们很快会讨论到这一点。
- en: 'Any and all media queries should be contained in the same manner. Here''s a
    more complex example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何和所有媒体查询都应以相同的方式包含。以下是一个更复杂的例子：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That would yield this CSS:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下CSS：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With all the nesting of overrides we have just looked at, you may think it makes
    sense to nest child elements too? You are wrong. Very wrong. This would be a very,
    very bad thing to do. We'll look at why next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过刚刚查看的所有覆盖的嵌套，你可能会认为嵌套子元素也是有道理的？你错了。非常错误。这将是一件非常非常糟糕的事情。接下来我们将看看为什么。
- en: 2\. Thou shalt not nest, unless thou art nesting media queries or overrides
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 除非你是嵌套媒体查询或覆盖，否则不得嵌套
- en: The key selector in CSS is the rightmost selector in any rule. It is the selector
    upon which the enclosed property/values are applied.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CSS中的关键选择器是任何规则中最右边的选择器。它是应用封闭属性/值的选择器。
- en: We want our CSS rules to be as *flat* as possible. We **DO NOT** want other
    selectors before a key selector (or any DOM element) unless we absolutely need
    them to override the default key selector styles.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的CSS规则尽可能*扁平*。我们**不希望**在关键选择器（或任何DOM元素）之前有其他选择器，除非我们绝对需要它们来覆盖默认的关键选择器样式。
- en: 'The reason being that adding additional selectors and using element types (for
    example `h1.yes-This_Selector`):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是添加额外的选择器并使用元素类型（例如`h1.yes-This_Selector`）：
- en: Creates additional unneeded specificity
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建额外不需要的特异性
- en: Makes it harder to maintain, as subsequent overrides need to be ever more specific
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使维护变得更加困难，因为随后的覆盖需要更加具体
- en: Adds unneeded bloat to the resultant CSS file
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向结果CSS文件添加不必要的膨胀
- en: In the case of element types, ties the rule to a specific element and/or markup
    structure
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在元素类型的情况下，将规则绑定到特定元素和/或标记结构
- en: 'For example, suppose we have a CSS rule like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有这样的CSS规则：
- en: '![2\. Thou shalt not nest, unless thou art nesting media queries or overrides](img/Warning-image-1.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![2. 除非你在嵌套媒体查询或覆盖，否则不要嵌套](img/Warning-image-1.jpg)'
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In that above example, `yes-This_Selector` is the key selector. If those property/values
    should be added to the key selector in all eventualities, we should make a simpler
    rule.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`yes-This_Selector`是关键选择器。如果这些属性/值应该在所有情况下添加到关键选择器中，我们应该制定一个更简单的规则。
- en: 'To simplify that prior example, if all we want to target is the key-selector
    we would want a rule like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简化前面的例子，如果我们只想针对关键选择器进行目标定位，我们会希望有这样的规则：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Don't nest children within a rule
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要在规则中嵌套子元素
- en: 'Suppose we have a situation where we have a video play button inside a wrapping
    element. Consider this markup:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有这样的情况，我们在包装元素内部有一个视频播放按钮。考虑这个标记：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s set some basic styling for the wrapper:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为包装器设置一些基本样式：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we want to position the play element within that wrapping element. You
    might be tempted to do this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要在包装元素内部定位播放元素。你可能会想这样做：
- en: '![Don''t nest children within a rule](img/Warning-image-1.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![不要在规则中嵌套子元素](img/Warning-image-1.jpg)'
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That would yield this CSS (vendor prefixes removed for brevity):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下CSS（为简洁起见删除了供应商前缀）：
- en: '![Don''t nest children within a rule](img/Warning-image-1.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![不要在规则中嵌套子元素](img/Warning-image-1.jpg)'
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Do you see the problem here? We have introduced additional specificity for our
    `.med-Video_Play` element when it is completely unneeded.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到问题了吗？当完全不需要时，我们为`.med-Video_Play`元素引入了额外的特异性。
- en: 'This is a subtle illustration. However, it is important to be aware of this,
    and avoid doing it, lest we end up with rules like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的例子。然而，重要的是要意识到这一点，并避免这样做，以免最终得到这样的规则：
- en: '![Don''t nest children within a rule](img/Warning-image-1.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![不要在规则中嵌套子元素](img/Warning-image-1.jpg)'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Instead, remember that *each key selector gets its own rule block*. Overrides
    are nested, child elements are not. Here is that example rewritten correctly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，记住*每个关键选择器都有自己的规则块*。覆盖是嵌套的，子元素不是。这是正确重写的示例：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That would yield this CSS:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下CSS：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each key selector is only as specific as it needs to be and no more.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关键选择器只有在需要时才会具体化，而不会更多。
- en: 3\. Thou shalt not use ID selectors, even if thou thinkest thou hast to
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 即使你认为你必须使用ID选择器，也不要使用
- en: The limitations of IDs in a complex UI are well documented. In summary, they
    are far more specific than a class selector - therefore making overrides more
    difficult. Plus they can only be used once in the page anyway so their efficacy
    is limited.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂UI中ID的限制已经有了详细的记录。简而言之，它们比类选择器更具体 - 因此使覆盖更加困难。此外，它们在页面中只能使用一次，因此它们的有效性有限。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember we dealt with specificity in detail back in [Chapter 2](ch02.html "Chapter 2. The
    Problems of CSS at Scale"), *The Problems of CSS at Scale*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们在[第2章](ch02.html "第2章。CSS在规模上的问题")中详细讨论了特异性，*CSS在规模上的问题*。
- en: With ECSS we do not use ID selectors in the CSS. They present no advantages
    over class based selectors and introduce unwanted problems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ECSS时，我们不在CSS中使用ID选择器。它们与基于类的选择器相比没有任何优势，并引入了不需要的问题。
- en: 'In the almost unbelievable situation where you HAVE to use an ID to select
    an element, use it within an attribute selector instead to keep specificity lower:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎难以置信的情况下，如果您必须使用ID来选择元素，请在属性选择器中使用它以保持特异性较低：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 4\. Thou shalt not write vendor prefixes in the authoring style sheets
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 不要在编写样式表中写供应商前缀
- en: Thanks to PostCSS, we now have tooling that means it is unnecessary to write
    vendor prefixes for any W3C specified property/values in the authoring style sheets.
    The prefixes are handled auto-magically by the *Autoprefixer* ([https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer))
    tool that can be configured to provide vendor prefixes for the required level
    of platforms/browser support.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了PostCSS，我们现在有了工具，这意味着在编写样式表中不需要为W3C指定的属性/值编写供应商前缀。这些前缀由*Autoprefixer*（[https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)）工具自动处理，可以配置为为所需的平台/浏览器支持级别提供供应商前缀。
- en: 'For example, don''t do this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，不要这样做：
- en: '![4\. Thou shalt not write vendor prefixes in the authoring style sheets](img/Warning-image-1.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![4. 不要在编写样式表中写供应商前缀](img/Warning-image-1.jpg)'
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead you should just write this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该只写这个：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Not only does this make the authoring style sheets easier to read and work with,
    it also means that when we want to change our level of support we can make a single
    change to the build tool and the vendor prefixes that get added will update automatically.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅使编写样式表更易于阅读和处理，而且意味着当我们想要改变我们的支持级别时，我们可以对构建工具进行单一更改，添加的供应商前缀将自动更新。
- en: 'The only exception to this scenario is non-W3C property/values that might still
    be desirable. For example, for touch inertia scrolling panels in WebKit devices,
    it will still be necessary to add certain vendor prefixed properties in the authoring
    styles as they are non-W3C. For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是可能仍然需要非W3C属性/值的情况。例如，在WebKit设备中的触摸惯性滚动面板，仍然需要在作者样式中添加某些供应商前缀的属性，因为它们不是W3C。例如：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or in the case of removing the scrollbar for WebKit:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在移除WebKit的滚动条时：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 5\. Thou shalt use variables for sizing, colours and z-index
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 使用变量进行尺寸、颜色和z-index设置
- en: For any project of size, setting variables for sizing, colours, and z-index
    is essential.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何规模的项目，设置尺寸、颜色和z-index的变量是必不可少的。
- en: 'UIs are typically based upon some form of grid or sizing ratio. Therefore sizing
    should be based upon set sizes, and sensible delineations of those sizes. For
    example here is `11px` based sizing and variants as variables:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: UI通常基于某种网格或尺寸比例。因此，尺寸应该基于固定尺寸，并对这些尺寸进行合理的划分。例如，这里是基于`11px`的尺寸和变量的变体：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For a developer, the use of variables offers additional economies. For example,
    it saves colour picking values from composites. It also helps to normalise designs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，使用变量还提供了额外的经济效益。例如，它可以节省从复合中选择颜色值。它还有助于规范化设计。
- en: For example, if a project uses only 13px, 15px and 22px font sizes and a change
    comes through requesting 14px font-sizing, the variables provide some normalisation
    reference. In this case, should the fonts be 13px or 15px as 14px is not used
    anywhere else? This allows developers to feedback possible design inconsistencies
    to the designers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个项目只使用13px、15px和22px的字体大小，并且有一个变化要求14px的字体大小，那么变量提供了一些标准化的参考。在这种情况下，如果字体是13px或15px，因为14px在其他地方都没有使用？这使开发人员可以向设计人员反馈可能存在的设计不一致之处。
- en: 'The same is true of colour values. For example, suppose we have a variable
    for the hex `#333`. We can write that as a variable like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色值也是如此。例如，假设我们有一个十六进制`#333`的变量。我们可以这样写一个变量：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On the surface it seems ridiculous to write the variable name when the hex value
    is shorter. However, again, using variables prevents unwanted variants creeping
    in to the code base (e.g. `#323232`) and helps identify *red flags* in the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，当十六进制值更短时，写变量名似乎是荒谬的。然而，再次强调，使用变量可以防止不需要的变体渗入代码库（例如`#323232`），并有助于识别代码中的*红旗*。
- en: It's also important to still use the variables when making amendments to colours.
    Use colour functions on the variables to achieve your goal. For example, suppose
    we want a semi-opaque `#333` colour.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在对颜色进行修改时，仍然使用变量是很重要的。使用颜色函数对变量进行操作以实现你的目标。例如，假设我们想要一个半透明的`#333`颜色。
- en: 'That should be achieved in the authoring style sheets like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在作者样式表中实现这样：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'PostCSS can provide a polyfill for the W3C colour functions: [https://drafts.csswg.org/css-color/#modifying-colors](https://drafts.csswg.org/css-color/#modifying-colors) 
    and the example above yields this CSS:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS可以为W3C颜色函数提供一个polyfill：[https://drafts.csswg.org/css-color/#modifying-colors](https://drafts.csswg.org/css-color/#modifying-colors)，上面的示例产生了以下CSS：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example we have used the alpha CSS colour function. We use the `color()`
    function, pass in the colour we want to manipulate and then the manipulation (alpha
    in this instance).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了alpha CSS颜色函数。我们使用`color()`函数，传入我们想要操作的颜色，然后进行操作（在这种情况下是alpha）。
- en: Using the variables can initially seem more complex but makes it easier for
    future authors to reason about what colour is being manipulated.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最初使用变量可能看起来更复杂，但这样可以让未来的作者更容易理解正在操作的颜色是什么。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I'd also encourage you to look at *CSS Color Guard* ([https://github.com/SlexAxton/css-colorguard](https://github.com/SlexAxton/css-colorguard))
    which is a tool to warn of colours in your codebase that are visually indistinguishable
    from other colours in your codebase.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我还鼓励你看看*CSS Color Guard*（[https://github.com/SlexAxton/css-colorguard](https://github.com/SlexAxton/css-colorguard)），这是一个用于警告代码库中颜色在视觉上难以区分的工具。
- en: 'The use of variables for z-index is equally important. This enforces some sanity
    when it comes to stacking contexts. There should be no need for `z-index: 999`
    or similar. Instead, use one of only a few defaults (set as variables). Here are
    some relevant variables for z-index:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '同样重要的是使用变量来设置z-index。这在堆叠上下文方面是很重要的。不应该需要`z-index: 999`或类似的东西。而是使用几个默认值（设置为变量）中的一个。这里有一些与z-index相关的变量：'
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 6\. Thou shalt always write rules mobile first (avoid max-width)
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 总是首先编写移动端规则（避免使用max-width）
- en: For any responsive work, we want to embrace a mobile-first mentality in our
    styles. Therefore, the properties and values within the root of a rule should
    be the properties that apply to the smallest viewports (e.g. mobile). We then
    use media queries to override or add to these styles as and when needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何响应式工作，我们希望在样式中采用移动优先的思维方式。因此，规则的根部应该是适用于最小视口（例如移动设备）的属性和值。然后我们使用媒体查询来覆盖或添加这些样式，根据需要。
- en: 'Consider this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That would yield this CSS:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下CSS：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We only need to change the `font-size` and `line-height` at different viewports
    so that is all we are amending. By using `min-width` (and not `max-width`) in
    our media query, should the `font-size` and `line-height` need to stay the same
    at a larger size viewport we wouldn't need any extra media queries. We only need
    a media query when things change going up the viewport size range. To this ends,
    the use of `max-width` as the single argument of a media query is discouraged.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在不同的视口更改`font-size`和`line-height`，所以这就是我们要修改的全部内容。通过在媒体查询中使用`min-width`（而不是`max-width`），如果在更大的视口尺寸上`font-size`和`line-height`需要保持不变，我们就不需要额外的媒体查询。只有当视口尺寸变化时，我们才需要媒体查询。因此，不建议将`max-width`作为媒体查询的单个参数。
- en: 'Bottom line: write media queries with `min-width` not `max-width`. The only
    exception here is if you want to isolate some style to a middle range. For example
    between medium and large viewports. Example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 底线：使用`min-width`而不是`max-width`编写媒体查询。这里唯一的例外是如果您想将一些样式隔离到中等范围。例如：在中等和大型视口之间。
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 7\. Use mixins sparingly (and avoid @extend)
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 谨慎使用mixins（避免@extend）
- en: Avoid the temptation of abstracting code into mixins. There are a few areas
    where mixins are perfect. The code for CSS text truncation (e.g. `@mixin Truncate`)
    or iOS style inertia scrolling panels, where there are number of pseudo selectors
    to get right for different browsers. Another good use case can be complex font
    stacks.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 避免将代码抽象为mixins的诱惑。有一些领域是mixins非常适合的。CSS文本截断的代码（例如`@mixin Truncate`）或iOS风格的惯性滚动面板，其中有许多伪选择器需要针对不同的浏览器进行正确设置。另一个很好的用例可能是复杂的字体堆栈。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Font stacks are difficult to get right and tedious to author. The sanest way
    I've found to deal with fonts is to have the `body` use the most common font stack
    and then only override this with a different font-stack as and when needed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 字体堆栈很难设置，而且很烦人。我发现处理字体的最理智的方法是让`body`使用最常见的字体堆栈，然后只在需要时用不同的字体堆栈覆盖它。
- en: 'For example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For simpler font-stacks, a variable can handle this need easily so may be preferable.
    However, mixins are great for more complex font stacks, where it's preferable
    to have certain font stacks apply in certain situations. For example, perhaps
    one font is required for LoDPI, and another for HiDPI. These situations can't
    be dealt with by using a variable alone so a mixin is used as needed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更简单的字体堆栈，变量可以轻松处理这个需求，因此可能更可取。然而，对于更复杂的字体堆栈，混合很适合，其中在某些情况下最好使用某些字体堆栈。例如，也许LoDPI需要一个字体，而HiDPI需要另一个字体。这些情况不能仅通过使用变量来处理，因此需要根据需要使用混合。
- en: Ultimately, aim for ten or less mixins in a project. Any more than that and
    it's probable mixins are being abused to needlessly abstract code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，一个项目中应该有十个或更少的mixins。如果超过这个数量，那么可能是滥用mixins来无谓地抽象代码。
- en: Avoid @extends
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免@extend
- en: I first came across `@extend` when using Sass ([http://sass-lang.com/documentation/file.SASS_REFERENCE.html#extend](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#extend)).
    The `@extend` directive makes one selector inherit the styles of another selector.
    While this can offer some file size benefits it can make debugging more difficult
    as rules are combined together in a manner that is not always possible to predict
    at the point of authoring.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次接触`@extend`是在使用Sass时（[http://sass-lang.com/documentation/file.SASS_REFERENCE.html#extend](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#extend)）。`@extend`指令使一个选择器继承另一个选择器的样式。虽然这可能会带来一些文件大小的好处，但它可能会使调试变得更加困难，因为规则以一种在编写时不一定能够预测的方式组合在一起。
- en: To determine whether using `@extend` was worthwhile I did a short experiment
    on a Sass codebase I was working with at the time. There were 73 instances that
    would require a Headline font stack and 37 instances that would require a headline
    condensed font stack (so if going the mixin route, that's 73 `@include Headline`
    and 37 instances of `@include HeadlineCondensed`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定使用`@extend`是否值得，我在当时正在使用的Sass代码库上进行了一个简短的实验。有73个实例需要一个Headline字体堆栈，37个实例需要一个headline
    condensed字体堆栈（因此，如果选择mixins路线，那就是73个`@include Headline`和37个`@include HeadlineCondensed`）。
- en: Let's look at what the file size was with no font references at all, the font
    references defined as mixins/@includes and then the font references as @extends
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看没有任何字体引用的文件大小，字体引用定义为mixins/@includes，然后字体引用为@extend
- en: With no font references
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有字体引用
- en: 'With no font declarations at all:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何字体声明：
- en: 105.5 KB (minified), 14.2 KB (Gzipped)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 105.5 KB（最小化），14.2 KB（Gzipped）
- en: This is our *base* or control if you will. Let's look at the difference adding
    all our fonts in via mixins/@includes creates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的*base*或者说控制。让我们看看通过mixins/@includes添加所有字体的区别。
- en: Using @includes
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用@includes
- en: 'Using mixins (@includes in Sass) for the *Headline* and *Headline Condensed* the
    file size of the resultant CSS was:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mixins（Sass中的@include）*Headline*和*Headline Condensed*的结果CSS文件大小为：
- en: 146.9 KB (minified), 15.4 KB (Gzipped)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 146.9 KB（最小化），15.4 KB（Gzipped）
- en: So, 1.2 KB added. How does `@extend` fare?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，增加了1.2 KB。`@extend`的表现如何？
- en: Using @extend
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用@extend
- en: 'By using an `@extend` rather than an `@include`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@extend`而不是`@include`：
- en: 106.9 KB (minified), 14.5 (Gzipped); only a .3 KB file size increase.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 106.9 KB（最小化），14.5（Gzipped）；只增加了0.3 KB的文件大小。
- en: What to conclude from this anecdotal data? For me, all other things being equal,
    if you absolutely want the smallest file size, perhaps `@extend` is the way to
    go. There is some saving, albeit minor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些轶事数据中得出什么结论？对我来说，其他一切都相等的话，如果你绝对想要最小的文件大小，也许`@extend`是一个好选择。虽然节省不多，但确实有一些。
- en: However, being pragmatic, if there is any maintainability gain for you using
    `@include` instead of `@extend` I certainly wouldn't worry about the file size.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，务实地说，如果使用`@include`而不是`@extend`可以获得任何可维护性的收益，我肯定不会担心文件大小。
- en: Personally, I don't allow `@extend` functionality in projects. It adds an additional
    layer of complexity to debugging for very little benefit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我不允许在项目中使用`@extend`功能。它增加了调试的复杂性，而好处很少。
- en: 8\. Thou shalt comment all magic numbers and browser hacks
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 一切魔数和浏览器hack都应该有注释
- en: A variables file should exist in each project that contains all variables relevant
    to the project.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都应该有一个包含与项目相关的所有变量的变量文件。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: PostCSS facilitates variables and mixins defined in either CSS files or as JavaScript
    objects. You can read *more about the latter here* ([https://benfrain.com/creating-and-referencing-javascript-mixins-and-variables-with-postcss/](https://benfrain.com/creating-and-referencing-javascript-mixins-and-variables-with-postcss/)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS可以在CSS文件或JavaScript对象中定义变量和mixins。您可以在[https://benfrain.com/creating-and-referencing-javascript-mixins-and-variables-with-postcss/](https://benfrain.com/creating-and-referencing-javascript-mixins-and-variables-with-postcss/)了解更多关于后者的信息。
- en: If a situation arises where a pixel based value needs entering into the authoring
    style sheets, that isn't already defined in the variables this should serve as
    a red flag to you. This scenario is also covered above. In the case where a *magic* number
    needs entering in the authoring style sheets, ensure a comment is added on the
    line above to explain its relevance. This may seem superfluous at the time but
    think of others and yourself in 3 months time. Why did you add a negative margin
    of 17 pixels to that element?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现需要在编写样式表中输入基于像素的值，而这些值在变量中尚未定义，那么这应该对你构成一个警示。这种情况也在上面有所涉及。在需要在编写样式表中输入*魔术*数字的情况下，请确保在上一行添加注释以解释其相关性。这可能在当时看起来多余，但请考虑其他人和自己在3个月后。为什么你要给那个元素添加一个负边距17像素？
- en: 'Example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The same goes for any device/browser hacks. You may have your own syntax but
    I use a comment above the start of the hack code with the prefix `/*HHHack:*/`
    when I have to add code purely to satisfy a particular situation. Consider this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何设备/浏览器的hack也是一样。你可能有自己的语法，但我在hack代码的开始上方使用`/*HHHack:*/`前缀添加注释，当我不得不添加代码来满足特定情况时。考虑一下：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These kinds of overrides should be bottom-most in the rule if at all possible.
    However, make sure you add a comment. Otherwise, future authors may look at your
    code and presume the line(s) are superfluous and remove them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种覆盖应该尽可能放在规则的最下面。但是，请确保添加注释。否则，未来的作者可能会查看你的代码并认为这行（行）是多余的，然后将其删除。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you find you have a lot of code, purely to service a particular browser,
    you might consider extracting those rules (manually or with tooling) into a separate
    file that only gets served as needed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你有很多代码，纯粹是为了服务特定的浏览器，你可以考虑将这些规则（手动或使用工具）提取到一个只在需要时提供的单独文件中。
- en: 9\. Thou shalt not place inline images in the authoring style sheets
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 不要在编写样式表中放置内联图像
- en: While we continue to support HTTP based users (as opposed to HTTP2) the practice
    of inlining assets provides some advantages; primarily it reduces the number of
    HTTP requests required to serve the page to the user. However, placing inline
    assets in the authoring style sheets is discouraged.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们继续支持基于HTTP的用户（而不是HTTP2），但内联资源的做法提供了一些优势；主要是减少了为向用户提供页面所需的HTTP请求的数量。然而，不鼓励将内联资源放在编写样式表中。
- en: 'Consider this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How is a future author supposed to reason about what that asset is?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的作者应该如何理解那个资产是什么？
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you encounter an existing inline image in style sheets, to determine what
    the image is you can copy and paste the data into the browser address bar.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在样式表中遇到现有的内联图像，可以复制并粘贴数据到浏览器地址栏中来确定图像是什么。
- en: 'Instead, let the tooling inline the image for you. This means the authoring
    style sheets can provide a clue as to what the image might be but also enables
    that image to be more easily swapped out. If employing the *postcss-assets* ([https://github.com/assetsjs/postcss-assets](https://github.com/assetsjs/postcss-assets))
    plugin, you can inline images with the inline command. Here''s that prior example
    re-written:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让工具内联图像。这意味着编写样式表可以提供图像可能是什么的线索，但也使得该图像更容易被替换。如果使用 *postcss-assets* ([https://github.com/assetsjs/postcss-assets](https://github.com/assetsjs/postcss-assets))
    插件，你可以使用内联命令内联图像。下面是之前的例子重写：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Not only is that easier to read, it also specifies the location of the existing
    asset. A better approach in every way.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅更容易阅读，还指定了现有资产的位置。这是一种更好的方法。
- en: 10\. Thou shalt not write complicated CSS when simple CSS will work just as
    well
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 当简单的CSS能够正常工作时，不要写复杂的CSS
- en: Try and write CSS code that is as simple as possible for others to reason about
    in future. Loops, mixins and functions should seldom be written. As a general
    rule, if there are less than 10 variations of a rule, write it *by-hand*. If on
    the other hand you need to create background positions for a sprite sheet of 30
    images, this is something that tooling should be used for.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量编写尽可能简单的CSS代码，以便其他人在未来能够理解。循环、混合和函数很少需要编写。一般规则是，如果一个规则少于10个变体，就手动编写。另一方面，如果你需要为一个包含30个图像的精灵表创建背景位置，这就是工具应该使用的东西。
- en: This pursuit of simplicity should be extended in the manner layouts are achieved.
    If a better supported layout mechanism achieves the same goal with the same amount
    of DOM nodes as a less well supported one, use the former. However, if a different
    layout mechanism reduces the number of DOM nodes needed or presents additional
    benefits yet is simply unfamiliar (for example Flexbox), take the time to understand
    the benefits it might offer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种追求简单性应该延伸到布局的实现方式。如果一个更好支持的布局机制以与较少支持的机制相同的DOM节点数量实现了相同的目标，那就使用前者。然而，如果不同的布局机制减少了所需的DOM节点数量或提供了额外的好处，但只是不熟悉（例如Flexbox），花时间了解它可能提供的好处。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Rules are nothing without enforcement. When many hands are touching the CSS
    codebase, no amount of education, strong words or documentation can prevent the
    quality of your codebase getting diluted. Offering *carrots* will only get you
    so far, it's usually necessary to use a little *stick* too!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 规则没有执行力就什么都不是。当许多人触及CSS代码库时，无论教育、强硬的话语还是文档都无法阻止你的代码库质量被稀释。提供*胡萝卜*只能走得那么远，通常也需要使用一点*棍子*！
- en: In this case, the *stick* will take the form of static analysis *linting* tools
    that can check and enforce code as authors write. This approach can prevent non-con-formant
    code ever making it further than the offending developers local machine. In the
    next chapter we will look at how to approach that, alongside tooling in general.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*棍子*将采取静态分析*linting*工具的形式，这些工具可以在作者编写代码时检查和强制执行代码。这种方法可以防止不符合规范的代码进一步传播到有问题的开发者的本地机器之外。在下一章中，我们将讨论如何处理这个问题，以及工具的一般情况。
- en: Here come the *Fun Police*!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*乐警*来了！'
