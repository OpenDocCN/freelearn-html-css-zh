- en: Chapter 2. Shape Drawing and Composites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。形状绘制和复合
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Drawing a rectangle
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制矩形
- en: Drawing a circle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制圆形
- en: Working with custom shapes and fill styles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义形状和填充样式
- en: 'Fun with Bezier curves: drawing a cloud'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贝塞尔曲线的乐趣：绘制云
- en: Drawing transparent shapes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制透明形状
- en: Working with the context state stack to save and restore styles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文状态堆栈保存和恢复样式
- en: Working with composite operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复合操作
- en: 'Creating patterns with loops: drawing a gear'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环创建图案：绘制齿轮
- en: 'Randomizing shape properties: drawing a field of flowers'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机化形状属性：绘制一片花田
- en: 'Creating custom shape functions: playing card suits'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义形状函数：纸牌花色
- en: 'Putting it all together: drawing a jet'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起：绘制喷气机
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started withPaths and Text"), *Getting
    Started with Paths and Text*, we learned how to draw sub paths such as lines,
    arcs, Quadratic curves, and Bezier curves, and then we learned how to connect
    them together to form paths. In this chapter, we'll focus on basic and advanced
    shape drawing techniques such as drawing rectangles and circles, drawing custom
    shapes, filling shapes, working with composites, and drawing pictures. Let's get
    started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。路径和文本入门")*路径和文本入门*中，我们学习了如何绘制子路径，如线条、弧线、二次曲线和贝塞尔曲线，然后学习了如何将它们连接在一起形成路径。在本章中，我们将专注于基本和高级形状绘制技术，如绘制矩形和圆形、绘制自定义形状、填充形状、使用复合操作和绘制图片。让我们开始吧！
- en: Drawing a rectangle
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制矩形
- en: In this recipe, we'll learn how to draw the only built-in shape provided by
    the HTML5 canvas API, a rectangle. As unexciting as a rectangle might seem, many
    applications use them in one way or another, so you might as well get acquainted.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何绘制HTML5画布API提供的唯一内置形状，即矩形。尽管矩形可能看起来不那么令人兴奋，但许多应用程序以某种方式使用它们，因此您最好熟悉一下。
- en: '![Drawing a rectangle](img/1369_02_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![绘制矩形](img/1369_02_01.jpg)'
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a simple rectangle centered on the canvas:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在画布上绘制一个简单的居中矩形：
- en: 'Define a 2D canvas context:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义2D画布上下文：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Draw a rectangle using the `rect()` method, set the color fill with the `fillStyle`
    property, and then fill the shape with the `fill()` method:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rect()`方法绘制一个矩形，使用`fillStyle`属性设置填充颜色，然后使用`fill()`方法填充形状：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you can see from the preceding code, we can draw a simple rectangle by using
    the `rect()` method:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，我们可以使用`rect()`方法来绘制一个简单的矩形：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `rect()` method draws a rectangle at the position `x,y`, and defines its
    size with `width` and `height`. Another key thing to pay attention to in this
    recipe is the usage of `fillStyle` and `fill()`. Similar to `strokeStyle` and
    `stroke()`, we can assign a fill color using the `fillStyle` method and fill the
    shape using `fill()`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`rect()`方法在位置`x，y`处绘制一个矩形，并使用`width`和`height`定义其大小。在本示例中需要注意的另一件重要的事情是使用`fillStyle`和`fill()`。与`strokeStyle`和`stroke()`类似，我们可以使用`fillStyle`方法分配填充颜色，并使用`fill()`填充形状。'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that we used `fill()` before `stroke()`. If we were to stroke a shape
    before filling it, the fill style would actually overlay half of the stroke style,
    effectively halving the line width style set with `lineWidth`. As a result, it's
    good practice to use `fill()` before using `stroke()`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`stroke()`之前使用了`fill()`。如果我们在填充形状之前描边形状，填充样式实际上会覆盖描边样式的一半，有效地减半了使用`lineWidth`设置的线宽样式。因此，最好在使用`stroke()`之前使用`fill()`。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition to the `rect()` method, there are two additional methods that we
    can use to draw a rectangle and also apply styling with one line of code, the
    `fillRect()` method and the `strokeRect()` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`rect()`方法，还有两种额外的方法可以用一行代码绘制矩形并应用样式，即`fillRect()`方法和`strokeRect()`方法。
- en: The fillRect() method
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`fillRect()`方法'
- en: 'If we intend to fill a rectangle after drawing it with `rect()`, we might consider
    both drawing the rectangle and filling it with a single method using `fillRect()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算在使用`rect()`绘制矩形后填充它，我们可以考虑使用`fillRect()`方法同时绘制和填充矩形：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `fillRect()` method is equivalent to using the `rect()` method followed
    by `fill()`. When using this method, you'll need to define the fill style prior
    to calling it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillRect()`方法相当于使用`rect()`方法后跟`fill()`。在使用此方法时，您需要在调用它之前定义填充样式。'
- en: The strokeRect() method
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`strokeRect()`方法'
- en: 'In addition to the `fillRect()` method, we can draw a rectangle and stroke
    it with a single method using the `strokeRect()` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`fillRect()`方法，我们还可以使用`strokeRect()`方法一次绘制矩形并描边：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `strokeRect()` method is equivalent to using the `rect()` method followed
    by `stroke()`. Similar to `fillRect()`, you'll need to define the stroke style
    prior to calling this method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`strokeRect()`方法相当于使用`rect()`方法后跟`stroke()`。与`fillRect()`类似，您需要在调用此方法之前定义描边样式。'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unfortunately, the HTML5 canvas API does not support a method that both fills
    and strokes a rectangle. Personally, I like to use the `rect()` method and apply
    stroke styles and fills as needed using `stroke()` and `fill()` because it's more
    consistent with custom shape drawing. However, if you're wanting to apply both
    a stroke and fill to a rectangle while using one of these short-hand methods,
    it's good practice to use `fillRect()` followed by `stroke()`. If you were to
    use `strokeRect()` followed by `fill()`, you would overlay the stroke style by
    the fill, halving the stroke line width.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，HTML5画布API不支持同时填充和描边矩形的方法。个人而言，我喜欢使用`rect()`方法，并根据需要使用`stroke()`和`fill()`应用描边样式和填充，因为这更符合自定义形状绘制的一致性。但是，如果您想要在使用这些简写方法之一时同时应用描边和填充矩形，最好使用`fillRect()`后跟`stroke()`。如果您使用`strokeRect()`后跟`fill()`，您会通过填充覆盖描边样式，使描边线宽减半。
- en: See also...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见...
- en: '*Creating a linear motion* in [Chapter 5](ch05.html "Chapter 5. Bringing the
    Canvas to Life with Animation")'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。通过动画使画布栩栩如生")中创建线性运动
- en: '*Detecting region events* in [Chapter 6](ch06.html "Chapter 6. Interacting
    with the Canvas: Attaching Event Listeners to Shapes and Regions")'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。与画布交互：将事件侦听器附加到形状和区域")中检测区域事件
- en: '*Creating a bar chart* in [Chapter 7](ch07.html "Chapter 7. Creating Graphs
    and Charts")'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。创建图表和图表")中创建条形图
- en: Drawing a circle
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个圆
- en: Although the HTML5 canvas API doesn't support a circle method, we can certainly
    create one by drawing a fully enclosed arc.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HTML5画布API不支持圆形方法，但我们可以通过绘制完全封闭的弧线来创建一个圆。
- en: '![Drawing a circle](img/1369_02_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![绘制一个圆](img/1369_02_02.jpg)'
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a circle centered on the canvas:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个居中在画布上的圆：
- en: 'Define a 2D canvas context:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a circle using the `arc()` method, set the color fill using the `fillStyle`
    property, and then fill the shape with the `fill()` method:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`arc()`方法创建一个圆，使用`fillStyle`属性设置颜色填充，然后使用`fill()`方法填充形状：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入到HTML文档的主体中：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As you might recall from [Chapter 1](ch01.html "Chapter 1. Getting Started
    withPaths and Text"), we can create an arc using the `arc()` method which draws
    a section of a circle defined by a starting angle and an ending angle. If, however,
    we define the difference between the starting angle and ending angle as 360 degrees
    (2π), we will have effectively drawn a complete circle:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的那样，我们可以使用`arc()`方法创建一个弧线，该方法绘制由起始角和结束角定义的圆的一部分。然而，如果我们将起始角和结束角之间的差定义为360度（2π），我们将有效地绘制了一个完整的圆：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating patterns with loops: drawing a gear*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环创建图案：绘制齿轮
- en: '*Transforming a circle into an oval* in [Chapter 4](ch04.html "Chapter 4. Mastering
    Transformations")'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将圆形变换为椭圆在[第4章](ch04.html "第4章。掌握变换")中
- en: '*Swinging a pendulum* in [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas
    to Life with Animation")'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。通过动画使画布栩栩如生")中摆动钟摆
- en: '*Simulating particle physics* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。通过动画使画布栩栩如生")中模拟粒子物理
- en: '*Animating a clock* in [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas
    to Life with Animation")'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。通过动画使画布栩栩如生")中制作动画时钟
- en: '*Detecting region events* in [Chapter 6](ch06.html "Chapter 6. Interacting
    with the Canvas: Attaching Event Listeners to Shapes and Regions")'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。与画布交互：将事件侦听器附加到形状和区域")中检测区域事件
- en: '*Creating a pie chart* in [Chapter 7](ch07.html "Chapter 7. Creating Graphs
    and Charts")'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。创建图表和图表")中创建饼图
- en: Working with custom shapes and fill styles
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义形状和填充样式
- en: In this recipe, we'll draw four triangles and then fill each one with a different
    fill style. The fill styles available with the HTML5 canvas API are color fills,
    linear gradients, radial gradients, and patterns.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将绘制四个三角形，然后用不同的填充样式填充每一个。HTML5画布API提供的填充样式包括颜色填充、线性渐变、径向渐变和图案。
- en: '![Working with custom shapes and fill styles](img/1369_02_10.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义形状和填充样式](img/1369_02_10.jpg)'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw four triangles, one with a color fill, one with
    a linear gradient fill, one with a radial gradient fill, and one with a pattern
    fill:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制四个三角形，一个用颜色填充，一个用线性渐变填充，一个用径向渐变填充，一个用图案填充：
- en: 'Create a simple function that draws a triangle:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个绘制三角形的简单函数：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define a 2D canvas context and set the height, width, and y position of our
    triangles:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文，并设置三角形的高度、宽度和y位置：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Draw a triangle using a color fill:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用颜色填充绘制三角形：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Draw a triangle using a linear gradient fill:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用线性渐变填充绘制三角形：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Draw a triangle using a radial gradient fill:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用径向渐变填充绘制三角形：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Draw a triangle using a pattern fill:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图案填充绘制三角形：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入到HTML文档的主体中：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As you might recall from [Chapter 1](ch01.html "Chapter 1. Getting Started
    withPaths and Text"), we can start a new path with the `beginPath()` method, place
    our drawing cursor using `moveTo()`, and then draw consecutive sub paths to form
    a path. We can add one more step to this procedure by closing our path with the
    `closePath()` method of the canvas context to create a shape:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的那样，我们可以使用`beginPath()`方法开始一个新路径，使用`moveTo()`放置我们的绘图光标，然后绘制连续的子路径以形成路径。我们可以通过使用画布上下文的`closePath()`方法来关闭路径，从而创建一个形状：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method essentially tells the canvas context to complete the current path
    by connecting the last point in the path with the start point of the path.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法基本上告诉画布上下文通过连接路径中的最后一个点和路径的起点来完成当前路径。
- en: In the `drawTriangle()` method, we can begin a new path using `beginPath()`,
    position the drawing cursor using `moveTo()`, draw two sides of the triangle using
    `lineTo()`, and then complete the third side of the triangle with `closePath()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawTriangle()`方法中，我们可以使用`beginPath()`开始一个新路径，使用`moveTo()`定位绘图光标，使用`lineTo()`绘制三角形的两条边，然后使用`closePath()`完成三角形的第三条边。
- en: 'As you can see from the preceding screenshot, the second triangle from the
    left is filled with a linear gradient. Linear gradients can be created with the
    `createLinearGradient()` method of the canvas context, which is defined by a start
    point and an end point:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中可以看出，从左边数第二个三角形是用线性渐变填充的。线性渐变可以使用画布上下文的`createLinearGradient()`方法创建，该方法由起点和终点定义：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we can set the colors of the gradient using the `addColorStop()` method
    which assigns a color value at an offset position along the gradient line from
    0 to 1:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`addColorStop()`方法设置渐变的颜色，该方法在0到1的渐变线偏移位置处分配颜色值：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Colors assigned with an offset value of 0 will be positioned at the starting
    point of the linear gradient, and colors assigned with an offset value of 1 will
    be positioned at the end point of the linear gradient. In this example, we've
    positioned a light blue color at the top of the triangle and a dark blue color
    at the bottom of the triangle.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移值为0的颜色将位于线性渐变的起点，偏移值为1的颜色将位于线性渐变的终点。在这个例子中，我们将浅蓝色放在三角形的顶部，深蓝色放在三角形的底部。
- en: 'Next up, let''s cover radial gradients. The second triangle from the right
    is filled with a radial gradient composed of six different colors. Radial gradients
    can be created using the `createRadialGradient()` method of the canvas context,
    which requires a starting point, a start radius, an end point, and an end radius:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来介绍径向渐变。右侧的第二个三角形填充有一个由六种不同颜色组成的径向渐变。可以使用画布上下文的`createRadialGradient()`方法创建径向渐变，该方法需要一个起点、起始半径、终点和终点半径：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Radial gradients are defined by two imaginary circles. The first imaginary circle
    is defined by `startX`, `startY`, and `startRadius`. The second imaginary circle
    is defined by `endX`, `endY`, and `endRadius`. Similarly to linear gradients,
    we can position colors along the radial gradient line using the `addColorStop()`
    method of the canvas context.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 径向渐变由两个虚拟圆定义。第一个虚拟圆由`startX`，`startY`和`startRadius`定义。第二个虚拟圆由`endX`，`endY`和`endRadius`定义。与线性渐变类似，我们可以使用画布上下文的`addColorStop()`方法沿径向渐变线位置颜色。
- en: 'Finally, the fourth type of fill style available with the HTML5 canvas API
    is patterns. We can create a `pattern` object using the `createPattern()` method
    of the canvas context, which requires an `image` object and a repeat option:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，HTML5画布API提供的第四种填充样式是图案。我们可以使用画布上下文的`createPattern()`方法创建一个`pattern`对象，该方法需要一个`image`对象和一个重复选项：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `repeatOption` can take one of the four options, `repeat`, `repeat-x`, `repeat-y`,
    and `no-repeat`. Unless otherwise specified, the `repeatOption` is defaulted to
    `repeat`. We'll cover images more in depth in [Chapter 3](ch03.html "Chapter 3. Working
    with Images and Videos"), *Working with Images and Videos*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeatOption`可以选择四个选项之一，`repeat`，`repeat-x`，`repeat-y`和`no-repeat`。除非另有说明，否则`repeatOption`默认为`repeat`。我们将在[第3章](ch03.html
    "第3章。使用图像和视频")中更深入地介绍图像，*使用图像和视频*。'
- en: See also...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Putting it all together: drawing a jet*'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将所有内容放在一起：绘制一架喷气机*'
- en: 'Fun with Bezier curves: drawing a cloud'
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贝塞尔曲线的乐趣：绘制一朵云
- en: In this recipe, we will learn how to draw a custom shape by connecting a series
    of Bezier curve sub paths to create a fluffy cloud.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何通过连接一系列贝塞尔曲线子路径来绘制自定义形状，从而创建一朵蓬松的云。
- en: '![Fun with Bezier curves: drawing a cloud](img/1369_02_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![贝塞尔曲线的乐趣：绘制一朵云](img/1369_02_05.jpg)'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a fluffy cloud in the center of the canvas:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在画布中心绘制一朵蓬松的云：
- en: 'Define a 2D canvas context:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Draw a cloud by connecting six Bezier curves:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过连接六个贝塞尔曲线来绘制一朵云：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define a radial gradient with the `createRadialGradient()` method and fill
    the shape with the gradient:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createRadialGradient()`方法定义一个径向渐变并填充形状：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Set the line width and stroke the cloud:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置线宽并描绘云：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw a fluffy cloud using the HTML5 canvas API, we can connect several Bezier
    curves to form the perimeter of the cloud shape. To create the illusion of a bulbous
    surface, we can create a radial gradient using the `createRadialGradient()` method,
    set the gradient colors and offsets using the `addColorStop()` method, set the
    radial gradient as the fill style using `fillStyle`, and then apply the gradient
    using `fill()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML5画布API绘制一朵蓬松的云，可以连接多个贝塞尔曲线以形成云形的周边。为了营造一个球形表面的幻觉，我们可以使用`createRadialGradient()`方法创建径向渐变，使用`addColorStop()`方法设置渐变颜色和偏移，使用`fillStyle`设置径向渐变为填充样式，然后使用`fill()`应用渐变。
- en: Drawing transparent shapes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制透明形状
- en: For applications that require shape layering, it's often desirable to work with
    transparencies. In this recipe, we will learn how to set shape transparencies
    using the global alpha composite.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要形状分层的应用程序，通常希望使用透明度。在这个示例中，我们将学习如何使用全局alpha合成来设置形状的透明度。
- en: '![Drawing transparent shapes](img/1369_02_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![绘制透明形状](img/1369_02_03.jpg)'
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a transparent circle on top of an opaque square:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在不透明正方形上方绘制一个透明圆：
- en: 'Define a 2D canvas context:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Draw a rectangle:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个矩形：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Set the global alpha of the canvas using the `globalAlpha` property and draw
    a circle:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`globalAlpha`属性设置画布的全局alpha，并绘制一个圆：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To set the opacity of a shape using the HTML5 canvas API, we can use the `globalAlpha`
    property:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML5画布API设置形状的不透明度，可以使用`globalAlpha`属性：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `globalAlpha` property accepts any real number between 0 and 1\. We can
    set the `globalAlpha` property to `1` to make shapes fully opaque, and we can
    set the `globalAlpha` property to `0` to make shapes fully transparent.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`globalAlpha`属性接受0到1之间的任何实数。我们可以将`globalAlpha`属性设置为`1`，使形状完全不透明，也可以将`globalAlpha`属性设置为`0`，使形状完全透明。'
- en: Working with the context state stack to save and restore styles
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文状态堆栈来保存和恢复样式
- en: When creating more complex HTML5 canvas applications, you'll find yourself needing
    a way to revert back to previous style combinations so that you don't have to
    set and reset dozens of style properties at different points in the drawing process.
    Fortunately, the HTML5 canvas API provides us with access to the context state
    stack which allows us to save and restore context states. In this recipe, we'll
    demonstrate how the state stack works by saving the context state, setting the
    global alpha, drawing a transparent circle, restoring the state stack to the state
    before we set the global alpha, and then drawing an opaque square. Let's take
    a look!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建更复杂的HTML5画布应用程序时，您会发现自己需要一种方法来恢复到以前的样式组合，这样您就不必在绘图过程的不同点设置和重置几十种样式属性。幸运的是，HTML5画布API为我们提供了访问上下文状态堆栈的方式，允许我们保存和恢复上下文状态。在这个示例中，我们将演示状态堆栈是如何工作的，通过保存上下文状态，设置全局alpha，绘制一个透明圆，将状态堆栈恢复到设置全局alpha之前的状态，然后绘制一个不透明的正方形。让我们来看看！
- en: '![Working with the context state stack to save and restore styles](img/1369_02_11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用上下文状态堆栈保存和恢复样式](img/1369_02_11.jpg)'
- en: Getting ready...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了...
- en: Before we cover the canvas state stack, it's imperative that you understand
    how a stack data structure works (if you already do, you can skip to the *How
    it works* section).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论画布状态堆栈之前，您必须了解堆栈数据结构的工作原理（如果您已经了解，可以跳到*它是如何工作*部分）。
- en: A stack data structure is a last in, first out (LIFO) structure. Stacks have
    three major operations – **push**, **pop**, and **stack top**. When an element
    is pushed onto the stack, it gets added to the top of the stack. When the stack
    is popped, the top element is removed from the stack. The *stack top* operation
    simply returns the element at the top of the stack.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈数据结构是一种后进先出（LIFO）结构。堆栈有三个主要操作-**push**，**pop**和**stack top**。当一个元素被推送到堆栈上时，它被添加到堆栈的顶部。当堆栈被弹出时，顶部元素被从堆栈中移除。*stack
    top*操作简单地返回堆栈顶部的元素。
- en: '![Getting ready...](img/1369_02_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![准备好了...](img/1369_02_12.jpg)'
- en: Take a look at the preceding diagram, which represents the state of a stack
    throughout multiple actions. In step 1, we start out with a stack containing one
    element, element "a". In step 2, the "b" element is pushed onto the stack. In
    step 3, the "c" element is pushed onto the stack. In step 4, we pop the stack,
    which removes the last element pushed onto the stack. Since element "c" was at
    the top of the stack, it's the element that's removed. In step 5, we again pop
    the stack, which removes the last element pushed onto the stack. Since element
    "b" was at the top of the stack, it's the element that's removed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的图表，它代表了在多个操作中堆栈的状态。在步骤1中，我们开始时有一个包含一个元素“a”的堆栈。在步骤2中，“b”元素被推送到堆栈上。在步骤3中，“c”元素被推送到堆栈上。在步骤4中，我们弹出堆栈，这将移除最后推送到堆栈上的元素。由于元素“c”位于堆栈顶部，因此它被移除。在步骤5中，我们再次弹出堆栈，这将移除最后推送到堆栈上的元素。由于元素“b”位于堆栈顶部，因此它被移除。
- en: As we will see in the next section, stacks are a wonderful data structure for
    saving states as they change over time, and then restoring them by popping the
    stack.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中看到的，堆栈是一个很好的数据结构，用于保存随时间变化的状态，然后通过弹出堆栈来恢复它们。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw an opaque square on top of a transparent circle:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在透明圆上绘制一个不透明的正方形：
- en: 'Define a 2D canvas context:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Draw a rectangle:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一个矩形：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save the context state with `save()`, set the global alpha of the canvas using
    the `globalAlpha` property, draw a circle, and then restore the canvas state with
    `restore()`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`save()`保存上下文状态，使用`globalAlpha`属性设置画布的全局alpha，绘制一个圆，然后使用`restore()`恢复画布状态：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Draw another rectangle (which will be opaque) to show that the context state
    has been restored to the state before the global alpha property was set:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制另一个矩形（将是不透明的），以显示上下文状态已恢复到设置全局alpha属性之前的状态：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将canvas标签嵌入到HTML文档的body中：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作...
- en: As you can see in the preceding code, by wrapping the circle drawing code with
    a save-restore combination, we are essentially encapsulating any styles that we
    use between the `save()` method and the `restore()` method such that they don't
    affect the shapes drawn afterwards. Save-restore combinations can be thought of
    as a way to induce style scoping, similar to the way that a function induces variable
    scope in JavaScript. Although you might be saying "Well that sounds like a complicated
    way to set the globalAlpha back to 1!" Hold on partner. In the real world, you'll
    typically be dealing with lots of different combinations of styles for different
    sections of code. In this type of scenario, save-restore combinations are a life-saver.
    Writing complex HTML5 canvas applications without save-restore combinations is
    a lot like building a complex web application with one big block of JavaScript
    code using nothing but global variables. Yikes!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所见，通过将圆形绘制代码包装在save-restore组合中，我们实质上是在`save()`方法和`restore()`方法之间封装了我们使用的任何样式，以便它们不会影响之后绘制的形状。可以将save-restore组合视为一种引入样式作用域的方式，类似于函数在JavaScript中引入变量作用域的方式。尽管您可能会说“嗯，这听起来像是一个复杂的方法来将globalAlpha设置回1！”
    等一下伙计。在现实世界中，您通常会处理大量不同的样式组合，用于代码的不同部分。在这种情况下，save-restore组合是救命稻草。在没有save-restore组合的情况下编写复杂的HTML5画布应用程序，就像使用全局变量在一个大的JavaScript代码块中构建复杂的Web应用程序一样。天啊！
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we'll see in [Chapter 4](ch04.html "Chapter 4. Mastering Transformations"),
    *Mastering Transformations*, another common usage of the state stack is to save
    and restore transformation states.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。掌握变换")中，我们将看到*掌握变换*，状态堆栈的另一个常见用法是保存和恢复变换状态。
- en: See also...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Handling multiple transforms with the state stack* in [Chapter 4](ch04.html
    "Chapter 4. Mastering Transformations")'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用状态堆栈处理多个变换*在[第4章](ch04.html "第4章。掌握变换")中'
- en: Working with composite operations
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用复合操作进行工作
- en: In this recipe, we'll explore composite operations by creating a table of each
    variation. Composite operations are particularly useful for creating complex shapes,
    drawing shapes underneath other shapes instead of on top of them, and creating
    other interesting effects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过创建每种变化的表格来探索复合操作。复合操作对于创建复杂形状、在其他形状下面绘制形状而不是在其上面以及创建其他有趣的效果非常有用。
- en: '![Working with composite operations](img/1369_02_04.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![使用复合操作](img/1369_02_04.jpg)'
- en: Getting ready...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了...
- en: 'The following is a description for each possible composite operation available
    with the HTML5 canvas API, where the red circle represents the source (S) and
    the blue square represents the destination (D). To further develop your understanding
    of composite operations, it helps to look at the corresponding operation while
    reading each description:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTML5画布API中可用的每种可能的复合操作的描述，其中红色圆表示源（S），蓝色正方形表示目标（D）。为了进一步加深对复合操作的理解，在阅读每个描述时，有助于查看相应的操作：
- en: '| Operation | Description |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 |'
- en: '| --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `source-atop` (S atop D) | Display the source image wherever both images
    are opaque. Display the destination image wherever the destination image is opaque
    but the source image is transparent. Display transparency elsewhere. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `source-atop` (S atop D) | 在两个图像都不透明的地方显示源图像。在目标图像不透明但源图像透明的地方显示目标图像。在其他地方显示透明度。
    |'
- en: '| `source-in` (S in D) | Display the source image wherever both the source
    image and destination image are opaque. Display transparency elsewhere. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `source-in` (S in D) | 在源图像和目标图像都不透明的地方显示源图像。在其他地方显示透明度。 |'
- en: '| `source-out` (S out D) | Display the source image wherever the source image
    is opaque and the destination image is transparent. Display transparency elsewhere.
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `source-out` (S out D) | 在源图像不透明且目标图像透明的地方显示源图像。在其他地方显示透明度。 |'
- en: '| `source-over` (S over D, default) | Display the source image wherever the
    source image is opaque. Display the destination image elsewhere. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `source-over` (S over D, default) | 在源图像不透明的地方显示源图像。在其他地方显示目标图像。 |'
- en: '| `destination-atop` (S atop D) | Display the destination image wherever both
    images are opaque. Display the source image wherever the source image is opaque
    but the destination image is transparent. Display transparency elsewhere. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `destination-atop` (S atop D) | 在两个图像都不透明的地方显示目标图像。在源图像不透明但目标图像透明的地方显示源图像。在其他地方显示透明度。
    |'
- en: '| `destination-in` (S in D) | Display the destination image wherever both the
    destination image and source image are opaque. Display transparency elsewhere.
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `destination-in` (S in D) | 在目标图像和源图像都不透明的地方显示目标图像。在其他地方显示透明度。 |'
- en: '| `destination -out` (S out D) | Display the destination image wherever the
    destination image is opaque and the source image is transparent. Display transparency
    elsewhere. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `destination -out` (S out D) | 在目标图像不透明且源图像透明的地方显示目标图像。在其他地方显示透明度。 |'
- en: '| `destination -over` (S over D) | Display the destination image wherever the
    destination image is opaque. Display the destination image elsewhere. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `destination -over` (S over D) | 在目标图像不透明的地方显示目标图像。在其他地方显示目标图像。 |'
- en: '| `lighter` (S plus D) | Display the sum of the source image and destination
    image. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `lighter` (S plus D) | 显示源图像和目标图像的总和。 |'
- en: '| `xor` (S xor D) | Exclusive OR of the source image and destination image.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `xor` (S xor D) | 源图像和目标图像的异或。 |'
- en: '| `copy` (D is ignored) | Display the source image instead of the destination
    image. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `copy` (D is ignored) | 显示源图像而不是目标图像。 |'
- en: At the time of writing, dealing with composite operations is quite tricky because
    each of the five major browsers—Chrome, Firefox, Safari, Opera, and IE9—handle
    composite operations differently. Rather than showing you a chart of currently
    supported composite operations by browser at the time of writing, you should instead
    go online and search for something like "canvas composite operation support by
    browser" to see the current support for each browser if you intend on using them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，处理复合操作相当棘手，因为五个主要浏览器——Chrome、Firefox、Safari、Opera和IE9——对复合操作的处理方式不同。与其向您展示当前支持的复合操作的图表，您应该上网搜索类似"canvas
    composite operation support by browser"的内容，以查看每个浏览器当前的支持情况，如果您打算使用它们。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a live table of composite operations:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建复合操作的实时表格：
- en: 'Define styles for the canvases and text displays:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为画布和文本显示定义样式：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define the sizes and relative distances of each square and circle:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义每个正方形和圆的大小和相对距离：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Build an array of composite operations:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个复合操作的数组：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Perform each operation and draw the result on the corresponding canvas:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行每个操作并在相应的画布上绘制结果：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Embed a canvas tag for each operation inside the body of the HTML document:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的主体中嵌入每个操作的画布标签：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can set a composite operation by using the `globalCompositeOperation` property
    of the canvas context:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用画布上下文的`globalCompositeOperation`属性来设置复合操作：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `globalCompositeOperaton` property accepts one of the eleven values, including
    `source-atop`, `source-in`, `source-out`, `source-over`, `destination-atop`, `destination-in`,
    `destination-out`, `destination-over`, `lighter`, `xor`, and `copy`. `Source`
    refers to everything drawn on the canvas after the operation, and `destination`
    refers to everything drawn on the canvas before the operation. Unless otherwise
    specified, the default composite operation is set to `source-over`, which basically
    means that each time something is drawn on the canvas, it's drawn on top of the
    stuff already there.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`globalCompositeOperaton`属性接受十一个值之一，包括`source-atop`，`source-in`，`source-out`，`source-over`，`destination-atop`，`destination-in`，`destination-out`，`destination-over`，`lighter`，`xor`和`copy`。`Source`指的是操作后在画布上绘制的所有内容，`destination`指的是操作前在画布上绘制的所有内容。除非另有规定，默认的复合操作设置为`source-over`，这基本上意味着每次在画布上绘制东西时，它都会绘制在已经存在的东西的顶部。'
- en: We can create an array for each composite operation and then loop through each
    one to draw the result onto the corresponding canvas. For each iteration, we can
    draw a square, set the composite operation, and then draw a circle.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个复合操作创建一个数组，然后循环遍历每个数组，将结果绘制到相应的画布上。对于每次迭代，我们可以绘制一个正方形，设置复合操作，然后绘制一个圆。
- en: 'Creating patterns with loops: drawing a gear'
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环创建图案：绘制齿轮
- en: In this recipe, we'll create a mechanical gear by iteratively drawing a radial
    zigzag to form teeth and then drawing circles to form the body of the gear.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过迭代绘制径向锯齿来创建一个机械齿轮，然后绘制圆来形成齿轮的主体。
- en: '![Creating patterns with loops: drawing a gear](img/1369_02_06.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![使用循环创建图案：绘制齿轮](img/1369_02_06.jpg)'
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a gear centered on the canvas:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在画布中心绘制齿轮：
- en: 'Define a 2D canvas context and set the gear properties:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义2D画布上下文并设置齿轮属性：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Draw the gear teeth:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制齿轮齿：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Draw the gear body:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制齿轮主体：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Draw the gear hole:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制齿轮孔：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw a gear with the HTML5 canvas, we can start by drawing the teeth around
    the gear. One way to draw teeth around a gear is to draw a radial zigzag pattern
    with beveled line joins. One great example of a radial zigzag is a star, which
    has five points along an imaginary inner circle, and five more points along an
    imaginary outer circle. To create a star, we can set up a loop with 10 iterations,
    one iteration for each point. For even iterations, we can draw a point along the
    outer circle, and for odd iterations we can draw a point along the inner circle.
    Since our star would have 10 points, each point would be separated by (2π / 10)
    radians.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要在HTML5画布上绘制齿轮，我们可以从齿轮周围绘制齿。绘制齿轮的一种方法是使用倒角线连接绘制径向锯齿图案。径向锯齿的一个很好的例子是星星，它沿着想象的内圆有五个点，沿着想象的外圆有五个点。要创建一个星星，我们可以设置一个循环，进行10次迭代，每个点进行一次迭代。对于偶数次迭代，我们可以沿着外圆绘制一个点，对于奇数次迭代，我们可以沿着内圆绘制一个点。由于我们的星星有10个点，每个点之间的间隔为（2π
    / 10）弧度。
- en: You might be asking yourself "What does a star have to do with gear teeth?".
    If we extend this logic to draw a zigzag shape of say 50 points instead of 10,
    we'll have effectively created a gear with 25 wedged teeth.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问自己“星星与齿轮齿有什么关系？”如果我们将这种逻辑扩展到绘制50个点的锯齿形状而不是10个点，我们将有效地创建了一个具有25个楔形齿的齿轮。
- en: Once the gear teeth are taken care of, we can draw a circle and apply a linear
    gradient using the `createLinearGradient()` method, and then draw a smaller circle
    for the hole of the gear.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理了齿轮齿，我们可以绘制一个圆，并使用“createLinearGradient（）”方法应用线性渐变，然后为齿轮的孔绘制一个较小的圆。
- en: See also...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Animating mechanical gears* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布栩栩如生")中制作机械齿轮*'
- en: 'Randomizing shape properties: drawing a field of flowers'
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机化形状属性：绘制一片花海
- en: In this recipe, we'll embrace our inner hippie by creating a field of colorful
    flowers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过创建一片色彩缤纷的花海来拥抱我们内心的嬉皮士。
- en: '![Randomizing shape properties: drawing a field of flowers](img/1369_02_07.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![随机化形状属性：绘制一片花海](img/1369_02_07.jpg)'
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw randomized flowers all over the canvas:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在整个画布上绘制随机花朵：
- en: 'Define the constructor of a `Flower` object:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义“Flower”对象的构造函数：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define a `draw` method of the `Flower` object that creates flower petals with
    a `for` loop and then draws a yellow center:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个“Flower”对象的“draw”方法，该方法使用“for”循环创建花瓣，然后绘制一个黄色中心：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Set the 2D canvas context:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置2D画布上下文：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a green gradation for the background:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为背景创建绿色渐变：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create an array of flower colors:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个花色数组：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a loop that generates flowers with a random position, size, and color:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个生成具有随机位置、大小和颜色的花朵的循环：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is all about randomizing object properties and drawing the results
    on the screen using HTML5 canvas. The idea is to create a bunch of flowers with
    varying positions, sizes, and colors.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱主要是关于随机化对象属性并使用HTML5画布在屏幕上绘制结果。其想法是创建一堆具有不同位置、大小和颜色的花朵。
- en: To help aid us in creating a field of flowers, it's useful to create a `Flower`
    class that defines the properties of a flower and a method for drawing the flower.
    For this recipe, I've kept the number of petals constant, although you can certainly
    experiment with a varying number of petals for each flower on your own.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们创建一片花海，创建一个“Flower”类非常有用，该类定义了花的属性和绘制花的方法。对于这个食谱，我保持了花瓣数量恒定，尽管您可以自行尝试每朵花的花瓣数量不同。
- en: 'Drawing a flower is actually quite similar to our previous recipe, *Creating
    patterns with loops: drawing a gear*, only this time, we''ll be drawing petals
    around a circle instead of zigzags. I''ve found that the easiest way to draw a
    petal with HTML5 canvas is to draw a Bezier curve whose starting point is connected
    to its ending point. The starting and ending points of the Bezier curve are at
    the center of the flower, and the control points are defined with each iteration
    in the `draw()` method of the `Flower` class.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一朵花实际上与我们以前的食谱“使用循环创建图案：绘制齿轮”非常相似，只是这一次，我们将在圆周围绘制花瓣，而不是锯齿。我发现使用HTML5画布绘制花瓣的最简单方法是绘制贝塞尔曲线，其起点连接到终点。贝塞尔曲线的起点和终点在花的中心，控制点在“Flower”类的“draw（）”方法中的每次迭代中定义。
- en: Once our `Flower` class is set up and ready to go, we can create a loop that
    instantiates random `Flower` objects with each iteration and then render them
    with the `draw()` method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的“Flower”类设置好并准备就绪，我们可以创建一个循环，每次迭代都实例化随机的“Flower”对象，然后用“draw（）”方法渲染它们。
- en: If you try out this recipe for yourself, you'll see that the flowers are completely
    randomized each time you refresh the screen.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己尝试这个教程，你会发现每次刷新屏幕时花朵完全是随机的。
- en: 'Creating custom shape functions: playing card suits'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义形状函数：纸牌花色
- en: If a royal flush gets your adrenaline going, then this one's for you. In this
    recipe, we'll create drawing functions for the spade, heart, club, and diamond
    suits.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果皇家同花顺让你的肾上腺素飙升，那么这个教程适合你。在这个教程中，我们将为黑桃、红心、梅花和方块花色创建绘图函数。
- en: '![Creating custom shape functions: playing card suits](img/1369_02_08.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义形状函数：纸牌花色](img/1369_02_08.jpg)'
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to draw a spade, heart, club, and diamond suit:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制黑桃、红心、梅花和方块花色：
- en: 'Define the drawSpade() function which draws a spade with four Bezier curves,
    two quadratic curves, and one straight line:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义drawSpade()函数，使用四条贝塞尔曲线、两条二次曲线和一条直线绘制黑桃：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define the drawHeart() function which draws a heart with four Bezier curves:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义drawHeart()函数，使用四条贝塞尔曲线绘制心形：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define the drawClub() function which draws a club with four circles, two quadratic
    curves, and one straight line:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义drawClub()函数，使用四个圆形、两条二次曲线和一条直线绘制梅花：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define the drawDiamond() function which draws a diamond with four straight
    lines:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义drawDiamond()函数，使用四条直线绘制菱形：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When the page loads, define the canvas context and then use the four drawing
    functions to render a spade, a heart, a club, and a diamond:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载时，定义画布上下文，然后使用四个绘图函数来渲染黑桃、红心、梅花和方块：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body内嵌入canvas标签：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This recipe demonstrates how any shape can be drawn by combining the four major
    types of sub paths provided by the HTML5 canvas: straight lines, arcs, Quadratic
    curves, and Bezier curves.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程演示了如何通过组合HTML5画布提供的四种主要子路径类型：直线、圆弧、二次曲线和贝塞尔曲线来绘制任何形状。
- en: To draw a spade, we can connect four Bezier curves to form the top portion,
    and we can use two Quadratic curves and a straight line to form the bottom portion.
    To draw a heart, we can connect four Bezier curves in much the same way that we
    created the spade, except that the point of the shape is on the bottom instead
    of the top. To create a club, we can draw three circles using arcs for the top
    portion, and similar to the spade, we can use two Quadratic curves and a straight
    line to form the bottom portion. Finally, to draw a diamond, we can simply connect
    four straight lines.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制黑桃，我们可以连接四条贝塞尔曲线形成顶部部分，然后使用两条二次曲线和一条直线形成底部部分。要绘制红心，我们可以以与黑桃相同的方式连接四条贝塞尔曲线，只是形状的顶点在底部而不是顶部。要创建梅花，我们可以使用圆弧绘制三个圆形作为顶部部分，与黑桃类似，我们可以使用两条二次曲线和一条直线来形成底部部分。最后，要绘制方块，我们可以简单地连接四条直线。
- en: 'Putting it all together: drawing a jet'
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起：绘制飞机
- en: In this recipe, we'll push the limits of the HTML5 canvas drawing API by drawing
    a vector-style jet using lines, curves, shapes, colors, linear gradients, and
    radial gradients.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将通过使用线条、曲线、形状、颜色、线性渐变和径向渐变来推动HTML5画布绘图API的极限，绘制出矢量飞机。
- en: '![Putting it all together: drawing a jet](img/1369_02_09.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容放在一起：绘制飞机](img/1369_02_09.jpg)'
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to draw a vector-style jet:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制矢量飞机：
- en: 'Define a 2D canvas context and set the line join style:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个2D画布上下文，并设置线连接样式：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Draw the right tail wing:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制右尾翼：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Draw the right wing:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制右翼：
- en: '[PRE63]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Draw the body and top of the tail:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制机身和尾部顶部：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Draw the left tail wing:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制左尾翼：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Draw the left wing:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制左翼：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Draw the side detail:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制侧面细节：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Draw the nose detail:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制机头细节：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Draw the cockpit:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制座舱：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Draw the intake:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制进气口：
- en: '[PRE70]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body内嵌入canvas标签：
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This recipe combines the use of lines, Quadratic curves, Bezier curves, paths,
    shapes, solid fills, linear gradients, and radial gradients. Although it's true
    that the HTML5 canvas is quite rudimentary, it does provide everything that we
    need to make great drawings, including a vector-style jet.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程结合了线条、二次曲线、贝塞尔曲线、路径、形状、实心填充、线性渐变和径向渐变的使用。尽管HTML5画布相当基础，但它提供了我们绘制出优秀图形所需的一切，包括矢量飞机。
- en: To draw a jet with the HTML5 canvas, we can start by drawing a jet in Adobe
    Photoshop or some other image editor with a drawing area size equal to the size
    of our canvas, which in this case is 650 x 350 pixels. Next, we can use our cursor
    to find the major points that form the jet shape by hovering over the end points
    of each line in our drawing and recording the x, y coordinates. With these coordinates
    in hand, we can draw the major outline of the jet with a line width of 4, and
    we can go back and fill in the finer details of the jet using a line width of
    2.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTML5画布绘制飞机，我们可以先在Adobe Photoshop或其他带有绘图区域大小等于画布大小的图像编辑器中绘制一架飞机，本例中为650 x
    350像素。接下来，我们可以使用鼠标在绘图中找到形成飞机形状的主要点，通过悬停在绘图的每条线的端点上记录x、y坐标。有了这些坐标，我们可以用4像素的线宽绘制飞机的主要轮廓，然后我们可以回去用2像素的线宽填充飞机的细节。
- en: Tip
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's good practice to draw the portions of the drawing farthest away from the
    viewer first because each shape that you draw on the canvas will overlap the previous
    shapes. If you take a look at the preceding code, you'll notice that the right
    wing was drawn first, followed by the body of the jet, followed by the left wing.
    This is because the right wing is farthest from the viewer while the left wing
    is closest to the viewer.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是首先绘制远离观众的图形部分，因为你在画布上绘制的每个形状都会重叠在前面的形状上。如果你看一下前面的代码，你会注意到右翼先被绘制，然后是飞机的机身，最后是左翼。这是因为右翼离观众最远，而左翼离观众最近。
- en: Once the line drawing is complete, we can fill in the jet with solid colors,
    add a linear gradient to the body, and add a radial gradient to the cockpit to
    give the drawing some depth. Finally, we can add a bold red gradation to the nose
    of the plane, preparing it for take-off and inspiring our imagination.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦线条绘制完成，我们可以用纯色填充喷气机，给机身添加线性渐变，给座舱添加径向渐变，使绘画具有一定的深度。最后，我们可以在飞机的机头上添加醒目的红色渐变，为起飞做准备，激发我们的想象力。
