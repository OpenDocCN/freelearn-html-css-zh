- en: Chapter 4. Mastering Transformations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。掌握变换
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Translating the canvas context
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换画布上下文
- en: Rotating the canvas context
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转画布上下文
- en: Scaling the canvas context
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放画布上下文
- en: Creating a mirror transform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建镜像变换
- en: Creating custom transforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义变换
- en: Shearing the canvas context
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪切画布上下文
- en: Handling multiple transforms with the state stack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态堆栈处理多个变换
- en: Transforming a circle into an oval
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将圆形变换为椭圆
- en: Rotating an image
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转图像
- en: Drawing a simple logo and randomizing its position, rotation, and scale
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个简单的标志并随机化其位置、旋转和缩放
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter will reveal the power of canvas transformations, which can drastically
    simplify complex drawings and provide new functionality that we wouldn't have
    had otherwise. Until now, we've been positioning elements on the screen directly
    with x and y coordinates. This can quickly become a problem if you've worked out
    the coordinates for each point of a complex drawing, and then later decide that
    the entire drawing needs to be repositioned, rotated, or scaled. Canvas transforms
    solve this problem by enabling the developer to translate, rotate, and scale entire
    sections of the canvas without having to rework the coordinates of each point
    that make up a drawing. In addition, canvas transforms also enable the developer
    to rotate and scale images and text, which isn't possible without transforms.
    Let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将揭示画布变换的威力，它可以极大地简化复杂的绘图，并提供新的功能，否则我们将无法拥有。到目前为止，我们一直在屏幕上直接定位元素的x和y坐标。如果您已经计算出复杂绘图的每个点的坐标，然后后来决定整个绘图需要重新定位、旋转或缩放，这可能很快成为一个问题。画布变换通过使开发人员能够在不必重新计算构成绘图的每个点的坐标的情况下，转换、旋转和缩放画布的整个部分来解决这个问题。此外，画布变换还使开发人员能够旋转和缩放图像和文本，这是没有变换不可能的。让我们开始吧！
- en: Translating the canvas context
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换画布上下文
- en: In this recipe, we'll learn how to perform the most basic and commonly used
    transformation available with the HTML5 canvas API—translation. If you're unfamiliar
    with transformation terminologies, "translation" is just a fancy way of saying
    "move". In this case, we'll be moving the context to a new location on the canvas.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何执行HTML5画布API提供的最基本和最常用的变换——平移。如果您对变换术语不熟悉，“平移”只是一种花哨的说法，意思是“移动”。在这种情况下，我们将把上下文移动到画布上的新位置。
- en: '![Translating the canvas context](img/1369_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![转换画布上下文](img/1369_04_01.jpg)'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a translated rectangle moved to the center of the
    canvas:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个移动到画布中心的平移矩形：
- en: 'Define the canvas context and the dimensions for the rectangle:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文和矩形的尺寸：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Translate the context to the center of the canvas:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上下文转换为画布的中心：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Draw a rectangle whose center lies on the top-left corner of the translated
    canvas context:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个中心位于平移画布上下文左上角的矩形：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body内嵌入canvas标签：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here's how it works!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的！
- en: '![canvas contexttranslating, stepsHow it works...](img/1369_04_10.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![画布上下文转换，步骤是如何工作的...](img/1369_04_10.jpg)'
- en: 'The idea behind HTML5 canvas transformations is to transform the canvas context
    in some way and then draw onto the canvas. In this recipe, we''ve translated the
    canvas context such that the top-left corner of the context has moved to the center
    of the canvas:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5画布变换的思想是以某种方式变换画布上下文，然后在画布上绘制。在这个示例中，我们已经将画布上下文平移，使得上下文的左上角移动到画布的中心：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*The* `tx` parameter corresponds to the horizontal translation, and the `ty`
    parameter corresponds to the vertical translation. Once the context has been transformed,
    we can draw a rectangle centered on the top-left corner of the canvas context.
    The end result is a translated rectangle that''s been moved to the center of the
    canvas.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*tx*参数对应于水平平移，*ty*参数对应于垂直平移。一旦上下文被变换，我们就可以在画布上下文的左上角上绘制一个居中的矩形。最终结果是一个被平移的矩形，它被移动到画布的中心。'
- en: Rotating the canvas context
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转画布上下文
- en: The next type of transformation available with the HTML5 canvas API, and quite
    arguably the handiest, is the rotation transform. In this recipe, we'll first
    position the canvas context with a translation transform, and then we'll rotate
    the context with `rotate()` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5画布API提供的下一种类型的变换，也可以说是最方便的变换，是旋转变换。在这个示例中，我们将首先使用平移变换来定位画布上下文，然后使用`rotate()`方法来旋转上下文。
- en: '![Rotating the canvas context](img/1369_04_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![旋转画布上下文](img/1369_04_03.jpg)'
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a rotated rectangle:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个旋转的矩形：
- en: 'Define the canvas context and the dimensions for the rectangle:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文和矩形的尺寸：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Translate the canvas context and then rotate it by 45 degrees:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布上下文平移，然后将其旋转45度：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Draw the rectangle:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制矩形：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body内嵌入canvas标签：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here's how it works!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的！
- en: '![How it works...](img/1369_04_11.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1369_04_11.jpg)'
- en: 'To position and rotate the rectangle, we can translate the canvas context to
    the center of the canvas as we did in the previous recipe, and then we can rotate
    the canvas context using the rotation transform, which rotates the context about
    the top-left corner of the context:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定位和旋转矩形，我们可以将画布上下文转换为画布的中心，就像我们在上一个示例中所做的那样，然后我们可以使用旋转变换来旋转画布上下文，这将使上下文围绕上下文的左上角旋转：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The parameter `theta` is in radians, and the transform rotates the context clockwise.
    Once the context has been translated and rotated, we can then draw the rectangle
    centered on the top-left corner of the context. The end result is a rotated rectangle
    centered on the canvas.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 参数*theta*以弧度表示，变换将上下文顺时针旋转。一旦上下文被平移和旋转，我们就可以在画布上下文的左上角上绘制一个居中的矩形。最终结果是一个以画布为中心的旋转矩形。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that we've achieved this result by chaining two different transforms,
    a translation and a rotation. Each of the three transformations provided by the
    HTML5 canvas API apply a transformation matrix to the current state. For example,
    if we applied three translations one after another that moved the canvas context
    10 pixels to the right, the net result would be a translation 30 pixels to the
    right.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过链接两种不同的变换（平移和旋转）来实现了这个结果。HTML5画布API提供的三种变换都会将一个变换矩阵应用于当前状态。例如，如果我们连续应用三次将画布上下文向右移动10像素的平移，最终结果将是向右移动30像素的平移。
- en: If we had wanted to rotate the rectangle about a different point, say the bottom-right
    corner of the rectangle, we could simply draw the bottom-right corner of the rectangle
    at the origin of the canvas context.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要围绕不同的点旋转矩形，比如说矩形的右下角，我们可以简单地在画布上下文的原点处绘制矩形的右下角。
- en: Translations and rotations are the most common transformation chains used when
    creating complex HTML5 canvas drawings. As we'll see in the next chapter, rotations
    are exceptionally useful when animating shapes that spin about an axis.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建复杂的HTML5画布绘图时，平移和旋转是最常用的变换链。正如我们将在下一章中看到的那样，旋转在动画形状围绕轴旋转时非常有用。
- en: See also...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见...
- en: '*Swinging a pendulum* in [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas
    to Life with Animation")'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布生动起来")中摆动钟摆*'
- en: '*Animating mechanical gears* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布生动起来")中制作机械齿轮的动画*'
- en: '*Animating a clock* in [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas
    to Life with Animation")'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布生动起来")中制作时钟的动画*'
- en: Scaling the canvas context
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放画布上下文
- en: In addition to translations and rotations, the HTML5 canvas API also provides
    us with a means for scaling the canvas context. In this recipe, we'll scale down
    the height of the canvas context using the `scale()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了平移和旋转之外，HTML5画布API还为我们提供了一种缩放画布上下文的方法。在这个示例中，我们将使用`scale()`方法缩小画布上下文的高度。
- en: '![Scaling the canvas context](img/1369_04_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![缩放画布上下文](img/1369_04_02.jpg)'
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a scaled rectangle:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个缩放的矩形：
- en: 'Define the canvas context and the dimensions for the rectangle:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文和矩形的尺寸：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Translate the canvas context and then scale the canvas context height by 50%:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移画布上下文，然后将画布上下文的高度缩小50%：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Draw a rectangle whose center lies on the top-left corner of the canvas context:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个中心位于画布上下文左上角的矩形：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To scale the canvas context, we can simply use the scale transform:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放画布上下文，我们可以简单地使用缩放变换：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the context's default state, the `sx` and `sy` parameters are normalized
    to `1` and `1`. As you might expect, the `sx` parameter corresponds to the horizontal
    scale, and the `sy` parameter corresponds to the vertical scale.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文的默认状态下，`sx`和`sy`参数被标准化为`1`和`1`。正如您所期望的那样，`sx`参数对应于水平比例，`sy`参数对应于垂直比例。
- en: In this recipe, we've shrunk the vertical context by 50% by setting the `sy`
    parameter to a value of `0.5`. If we assign `sy` to a value greater than `1`,
    on the other hand, the context will stretch vertically. As we will see in the
    next recipe, if we assign negative values to either the `sx` or `sy` values, we
    will end up inverting the canvas context either horizontally or vertically, creating
    a mirror transform.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过将`sy`参数设置为`0.5`来将垂直上下文缩小了50%。另一方面，如果我们将`sy`分配给大于`1`的值，上下文将垂直拉伸。正如我们将在下一个示例中看到的，如果我们将`sx`或`sy`值分配为负值，我们将水平或垂直地翻转画布上下文，从而创建一个镜像变换。
- en: See also...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见...
- en: '*Oscillating a bubble* in [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas
    to Life with Animation")'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布生动起来")中振荡气泡*'
- en: Creating a mirror transform
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建镜像变换
- en: Another interesting use of the scale transformation is its ability to mirror
    the canvas context vertically or horizontally. In this recipe, we'll mirror the
    canvas context horizontally, and then write out some backwards text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放变换的另一个有趣用途是它能够垂直或水平地镜像画布上下文。在这个示例中，我们将水平镜像画布上下文，然后写出一些倒序的文本。
- en: '![Creating a mirror transform](img/1369_04_05.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![创建镜像变换](img/1369_04_05.jpg)'
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to write text backwards:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将文本写成倒序：
- en: 'Define the canvas context:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Translate the canvas context and then flip the context horizontally using a
    negative `x` value:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移画布上下文，然后使用负的`x`值水平翻转上下文：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Write "Hello World!":'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出“Hello World!”：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Embed the canvas tag into the body of the HTML document:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To create a mirror transform using the HTML5 canvas API, we can assign a negative
    value to `sx` or `sy` when using the `scale` method of the canvas context:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTML5画布API创建镜像变换，我们可以在使用画布上下文的`scale`方法时将`sx`或`sy`赋予负值：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this recipe, we've translated the canvas context to the center of the canvas,
    and then inverted the context horizontally by applying a `–sx` value with the
    `scale()` transform.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将画布上下文平移到画布的中心，然后通过应用`scale()`变换的`-sx`值来水平翻转上下文。
- en: Creating a custom transform
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义变换
- en: If you're looking to perform a custom transformation other than a translation,
    scale, or rotation, the HTML5 canvas API also provides a method which allows us
    to define a custom transformation matrix that can be applied to the current context.
    In this recipe, we'll manually create a translational transform to demonstrate
    how the `transform()` method works.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想执行除平移、缩放或旋转之外的自定义变换，HTML5画布API还提供了一种方法，允许我们定义一个自定义变换矩阵，该矩阵可以应用于当前上下文。在这个示例中，我们将手动创建一个平移变换，以演示`transform()`方法的工作原理。
- en: '![Creating a custom transform](img/1369_04_06.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义变换](img/1369_04_06.jpg)'
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to perform a custom transform:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行自定义变换：
- en: 'Define the canvas context and the dimensions for our rectangle:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义矩形的画布上下文和尺寸：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Apply a custom transform by manually translating the canvas context:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手动平移画布上下文应用自定义变换：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Draw the rectangle:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制矩形：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Embed the canvas element into the body of the HTML document:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布元素嵌入到HTML文档的主体中：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we''ve created a custom translation transform by applying a
    custom translation transformation matrix to the context state. A transformation
    matrix is simply a 2-dimensional matrix that can be used to transform the current
    matrix into a new one. Custom transformations can be applied to the context state
    using the `transform()` method of the canvas context:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们通过将自定义平移变换矩阵应用于上下文状态来创建了自定义平移变换。变换矩阵只是一个二维矩阵，可以用来将当前矩阵转换为新矩阵。可以使用画布上下文的`transform()`方法将自定义变换应用于上下文状态：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Where the parameters `a`, `b`, `c`, `d`, `e`, and `f` correspond to the following
    components of a transformation matrix:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其中参数`a`、`b`、`c`、`d`、`e`和`f`对应于变换矩阵的以下组成部分：
- en: '![How itcustom transformperforming, steps works...](img/1369_04_15.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![自定义变换执行步骤的工作原理...](img/1369_04_15.jpg)'
- en: 'Here, *x''* and *y''* are the new matrix *x* and *y* components after applying
    the transformation. The transformation matrix for a translation transform looks
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*x'*和*y'*是应用变换后的新矩阵*x*和*y*分量。平移变换的变换矩阵如下所示：
- en: '![How itcustom transformperforming, steps works...](img/1369_04_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![自定义变换执行步骤的工作原理...](img/1369_04_13.jpg)'
- en: Where *tx* is the horizontal translation, and *ty* is the vertical translation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*tx*是水平平移，*ty*是垂直平移。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In addition to the `transform()` method, which *applies* a transformation matrix
    to the current context state, we can also *set* the transformation matrix using
    the `setTransform()` method of the canvas context:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`transform()`方法之外，还可以使用画布上下文的`setTransform()`方法*设置*变换矩阵，该方法将变换矩阵应用于当前上下文状态：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method can be useful if you want to directly set the transformation matrix
    of the context with a formulated transformation matrix, instead of obtaining the
    same result through a series of transformations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想直接使用经过公式化的变换矩阵设置上下文的变换矩阵，而不是通过一系列变换获得相同的结果，那么这种方法可能会很有用。
- en: Shearing the canvas context
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倾斜画布上下文
- en: In this recipe, we'll use what we've learned from the `transform()` method of
    the canvas context to create a custom shear transformation to skew the canvas
    context horizontally.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使用画布上下文的`transform()`方法从水平方向对画布上下文进行自定义剪切变换，利用了我们从画布上下文的`transform()`方法中学到的知识。
- en: '![Shearing the canvas context](img/1369_04_07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![倾斜画布上下文](img/1369_04_07.jpg)'
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a sheared rectangle:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个倾斜的矩形：
- en: 'Define the canvas context and the dimensions for the rectangle:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义矩形的画布上下文和尺寸：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Translate the canvas context and then apply a custom shear transform to the
    context:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移画布上下文，然后对上下文应用自定义剪切变换：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Draw the rectangle:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制矩形：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Embed the canvas element inside the body of the HTML document:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布元素嵌入到HTML文档的主体中：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To shear the canvas context, we can apply the following transformation matrix:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使画布上下文倾斜，可以应用以下变换矩阵：
- en: '![How it works...](img/1369_04_14.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1369_04_14.jpg)'
- en: 'We can use the `transform()` method with the following parameters:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`transform()`方法和以下参数：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The more we increase the value of `sx`, the greater the context is sheared horizontally.
    The more we increase the value of `sy`, the greater the context is sheared vertically.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加`sx`的值，上下文水平倾斜就越大。我们增加`sy`的值，上下文垂直倾斜就越大。
- en: Handling multiple transforms with the state stack
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态堆栈处理多个变换
- en: Now that we have a good handle on transformations with the HTML5 canvas API,
    we're now in a position to further explore the canvas state stack and see what
    it can do for us with respect to transformations. In [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites"), *Shape Drawing and Composites*, we covered the state
    stack, a very powerful yet sometimes overlooked property of the canvas API. Although
    the canvas state stack can help with managing styling, it's most common usage
    is to save and restore transformation states. In this recipe, we'll perform multiple
    transformations while saving the canvas state between each transformation, and
    then draw a sequence of rectangles after restoring each state to see the effects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地掌握了HTML5画布API的变换，我们现在可以进一步探索画布状态堆栈，并了解它在变换方面对我们有什么作用。在[第2章](ch02.html
    "第2章。形状绘制和合成")中，*形状绘制和合成*，我们介绍了状态堆栈，这是画布API的一个非常强大但有时被忽视的属性。尽管画布状态堆栈可以帮助管理样式，但它最常见的用法是保存和恢复变换状态。在本示例中，我们将在每次变换之间保存画布状态，并在恢复每个状态后绘制一系列矩形，以查看效果。
- en: '![Handling multiple transforms with the state stack](img/1369_04_08.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用状态堆栈处理多个变换](img/1369_04_08.jpg)'
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to construct a state stack with four different states and
    then draw a rectangle after popping each state:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建具有四种不同状态的状态堆栈，然后在弹出每个状态后绘制一个矩形：
- en: 'Define the canvas context and the dimensions for our rectangle:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义矩形的画布上下文和尺寸：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Push the current transformation state, the default state, onto the state stack,
    and translate the context:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前变换状态，即默认状态，推入状态堆栈，并平移上下文：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Push the current transformation state, the translated state, onto the stack,
    and rotate the context:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前变换状态，即已平移的状态，推入堆栈，并旋转上下文：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Push the current transformation state, the translated and rotated state, onto
    the stack, and scale the context:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前变换状态，即已平移和旋转的状态，推入堆栈，并缩放上下文：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Draw a blue rectangle:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个蓝色的矩形：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Restore the previous state from the state stack by popping off the current
    state, and then draw a red rectangle:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态堆栈中弹出当前状态以恢复先前的状态，然后绘制一个红色的矩形：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Restore the previous state from the state stack by popping off the current
    state, and then draw a yellow rectangle:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态堆栈中弹出当前状态以恢复先前的状态，然后绘制一个黄色的矩形：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Restore the previous state from the state stack by popping off the current
    state, and then draw a green rectangle:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态堆栈中弹出当前状态以恢复先前的状态，然后绘制一个绿色的矩形：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Embed the canvas tag into the body of the HTML document:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This recipe performs a series of three transformations, a translation, a rotation,
    and a scale transform, while pushing each transformation state onto the state
    stack with the `save()` operation. When the blue rectangle is drawn, it''s centered,
    rotated, and scaled. At this point, the state stack has four states (from bottom
    to top):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法执行了一系列三次变换，平移、旋转和缩放变换，同时使用`save()`操作将每个变换状态推送到状态堆栈上。当绘制蓝色矩形时，它被居中、旋转和缩放。此时，状态堆栈有四个状态（从底部到顶部）：
- en: Default state
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认状态
- en: Translated state
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已翻译状态
- en: Translated and rotated state
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已翻译和旋转状态
- en: Current state (translated, rotated, and scaled state)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前状态（已翻译、旋转和缩放状态）
- en: After the blue rectangle is drawn, we use the `restore()` method to pop off
    the top state in the state stack, and restore the canvas context to the third
    state, in which the canvas context is translated and rotated. The red rectangle
    is drawn, and you can see that it's been translated and rotated, but not scaled.
    Next, we use the `restore()` method once again to pop off the top state in the
    state stack, and restore the second state, in which the canvas context is merely
    translated. We then draw a yellow rectangle, which is indeed just translated.
    Finally, we call the `restore()` method one last time to pop off the top state
    in the state stack, and return us to the default state. When we draw the green
    rectangle, it appears at the origin, because no transformation has been applied.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制蓝色矩形后，我们使用`restore()`方法弹出状态堆栈中的顶部状态，并将画布上下文恢复到第三个状态，其中画布上下文被平移和旋转。然后绘制红色矩形，您会看到它已经被平移和旋转，但没有被缩放。接下来，我们再次使用`restore()`方法弹出状态堆栈中的顶部状态，并恢复第二个状态，其中画布上下文仅被平移。然后我们绘制一个黄色的矩形，它确实只是被平移。最后，我们再次调用`restore()`方法，弹出状态堆栈中的顶部状态，并返回到默认状态。当我们绘制绿色矩形时，它出现在原点，因为没有应用任何变换。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using the state stack, we can jump between transformation states so that we
    don't have to constantly reset the state back to its default state and then translate
    each element separately. In addition, we can also use save-restore combinations
    to encapsulate transformations for a small piece of code without affecting shapes
    drawn afterwards.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态堆栈，我们可以在变换状态之间跳转，这样我们就不必不断地将状态重置为默认状态，然后分别对每个元素进行平移。此外，我们还可以使用保存-恢复组合来封装一小段代码的变换，而不会影响后面绘制的形状。
- en: Transforming a circle into an oval
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将圆形变成椭圆
- en: One of the most common applications of the scale transform is to stretch a circle
    horizontally or vertically to create an oval. In this recipe, we'll create an
    oval by translating the canvas context, stretching it horizontally, and then drawing
    a circle.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放变换最常见的应用之一是将圆水平或垂直拉伸以创建椭圆。在这个方法中，我们将通过平移画布上下文、水平拉伸它，然后绘制一个圆来创建一个椭圆。
- en: '![Transforming a circle into an oval](img/1369_04_04.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![将圆形变成椭圆](img/1369_04_04.jpg)'
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw an oval:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个椭圆：
- en: 'Define a canvas context:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Push the current transformation state, which is the default state, onto the
    state stack:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前变换状态（默认状态）推送到状态堆栈上：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the dimensions of the circle:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义圆的尺寸：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Translate the canvas context to the center of the canvas, and then scale the
    context width to stretch it outwards:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布上下文平移到画布的中心，然后缩放上下文宽度以向外伸展：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Draw the circle:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制圆：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Restore the previous transformation state, which was the default state, and
    also pop off the current transformation state from the state stack:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复先前的变换状态，即默认状态，并从状态堆栈中弹出当前的变换状态：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Apply styling to the oval:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对椭圆应用样式：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Embed the canvas tag into the body of the HTML document:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布标签嵌入HTML文档的主体中：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To draw an oval using the HTML5 canvas API, we can simply translate the context
    to its desired position with the `translate()` method, stretch the context either
    vertically or horizontally with the `scale()` method, and then draw the circle.
    In this recipe, we've stretched the canvas context horizontally to create an oval
    that's twice as wide as it is tall.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTML5画布API绘制椭圆，我们可以简单地使用`translate()`方法将上下文平移到所需的位置，使用`scale()`方法在垂直或水平方向上拉伸上下文，然后绘制圆。在这个方法中，我们已经将画布上下文水平拉伸，以创建一个宽度是高度两倍的椭圆。
- en: As we want to apply a stroke style to the oval, we can use a save-restore combination
    to encapsulate the transformations used to create the oval so that they don't
    affect the styling of the oval afterwards.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要对椭圆应用描边样式，我们可以使用保存-恢复组合来封装用于创建椭圆的变换，以便它们不会影响椭圆后面的样式。
- en: If you try this recipe out for yourself, and you remove the `save()` and `restore()`
    methods, you'll find that the thickness of the line at the top and bottom of the
    oval is 5 pixels, and the thickness of the line on the sides of the oval is 10
    pixels, because the stroke style has also been stretched horizontally along with
    the circle.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您自己尝试这个方法，并且删除`save()`和`restore()`方法，您会发现椭圆顶部和底部的线条厚度为5像素，椭圆两侧的线条厚度为10像素，因为描边样式也随着圆形在水平方向被拉伸。
- en: See also...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Oscillating a bubble* in [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas
    to Life with Animation")'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。通过动画使画布生动起来")中*振荡一个气泡*'
- en: Rotating an image
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转图像
- en: In this recipe, we'll rotate an image by translating and rotating the canvas
    context, and then drawing an image on the transformed context.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过平移和旋转画布上下文来旋转图像，然后在变换后的上下文上绘制图像。
- en: '![Rotating an image](img/1369_04_16.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![旋转图像](img/1369_04_16.jpg)'
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to rotate an image:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤旋转图像：
- en: 'Define a canvas context:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个画布上下文：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a new `image` object and set its `onload` property:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`image`对象并设置其`onload`属性：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When the image loads, translate the context to the center of the canvas, rotate
    the context by 45 degrees counter-clockwise, and then draw the image:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图像加载时，将上下文转换到画布的中心，逆时针旋转上下文45度，然后绘制图像：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Set the source of the image:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置图像的来源：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body中嵌入canvas标签：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To rotate an image, we can simply position the canvas context with the `translate()`
    method, rotate the context with the `rotate()` method, and then draw the image
    with the `drawImage()` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要旋转图像，我们可以简单地使用`translate()`方法定位画布上下文，使用`rotate()`方法旋转上下文，然后使用`drawImage()`方法绘制图像。
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's also worth noting that in addition to rotating an image, another common
    transform used with images is the mirror transform. To mirror an image, we could
    have translated the context to the desired position, inverted the context horizontally
    with `scale(-1,1)` or inverted the context vertically with `scale(1,-1)`, and
    then drawn the image using `drawImage()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，除了旋转图像之外，与图像一起使用的另一个常见变换是镜像变换。要镜像图像，我们可以将上下文转换到所需的位置，使用`scale(-1,1)`水平反转上下文，或者使用`scale(1,-1)`垂直反转上下文，然后使用`drawImage()`绘制图像。
- en: See also...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating a mirror transform* recipe'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建镜像变换*食谱'
- en: Drawing a simple logo and randomizing its position, rotation, and scale
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个简单的标志并随机化其位置、旋转和比例
- en: The purpose of this recipe is to demonstrate the practical use of transformations
    by transforming a complex shape. In this case, our complex shape will be a logo,
    which is just some text with a couple of wavy lines below it. Transformations
    are exceedingly useful when we want to translate, rotate, or scale complex shapes.
    It's very common for developers to create functions that draw something complicated
    at the origin, and then use transforms to move it somewhere on the screen. In
    this recipe, we'll draw five randomly positioned, rotated, and scaled logos on
    the screen.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的目的是通过转换复杂的形状来演示变换的实际用途。在这种情况下，我们的复杂形状将是一个标志，它只是一些文本，下面有几条波浪线。当我们想要转换、旋转或缩放复杂的形状时，变换非常有用。开发人员经常创建函数，在原点绘制复杂的东西，然后使用变换将其移动到屏幕上的某个位置。在这个食谱中，我们将在屏幕上绘制五个随机位置、旋转和缩放的标志。
- en: '![Drawing a simple logo and randomizing its position, rotation, and scale](img/1369_04_09.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![绘制一个简单的标志并随机化其位置、旋转和比例](img/1369_04_09.jpg)'
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw five randomly positioned, rotated, and scaled logos:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制五个随机位置、旋转和缩放的标志：
- en: 'Define the `drawLogo()` function which draws a simple logo by writing out text
    and drawing two waves below it:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawLogo()`函数，通过写出文本并在其下方绘制两条波浪线来绘制一个简单的标志：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define the `getRandomX()` function that returns a random `X` value between
    0 and the canvas width:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getRandomX()`函数，返回0到画布宽度之间的随机`X`值：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define the `getRandomY()` function that returns a random `Y` value between
    0 and the canvas height:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getRandomY()`函数，返回0到画布高度之间的随机`Y`值：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define the `getRandomSize()` function that returns a random size between 0
    and 5:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getRandomSize()`函数，返回0到5之间的随机大小：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define the `getRandomAngle()` function that returns a random angle between
    0 and 2π:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getRandomAngle()`函数，返回0到2π之间的随机角度：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define the canvas context:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义画布上下文：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a loop that draws five randomly positioned, rotated, and scaled logos:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，绘制五个随机位置、旋转和缩放的标志：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Embed the canvas tag inside the body of the HTML document:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档的body中嵌入canvas标签：
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firstly, to draw our simple logo, we can create a function called `drawLogo()`
    that writes out the text **Hello Logo!** at the origin and then draws two wavy
    lines using the `bezierCurveTo()` method for each wave.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要绘制我们简单的标志，我们可以创建一个名为`drawLogo()`的函数，它在原点写出文本**Hello Logo!**，然后使用`bezierCurveTo()`方法为每个波绘制两条波浪线。
- en: Next, to draw five randomly positioned, rotated, and scaled logos, we can create
    a few utility functions that return random values for the position, rotation,
    and scale, and then create a `for` loop that uses a save-restore combination for
    each iteration to induce state scope, perform the three transformations, and then
    draw the logo with the `drawLogo()` method. If you try out this recipe for yourself,
    you'll see that each of the five logos are positioned, rotated, and scaled differently
    each time you refresh the screen.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要绘制五个随机位置、旋转和缩放的标志，我们可以创建一些实用函数，返回位置、旋转和缩放的随机值，然后创建一个`for`循环，每次迭代使用保存-恢复组合来引入状态范围，执行三次变换，然后使用`drawLogo()`方法绘制标志。如果你自己尝试这个食谱，你会发现每次刷新屏幕时，五个标志的位置、旋转和缩放都不同。
