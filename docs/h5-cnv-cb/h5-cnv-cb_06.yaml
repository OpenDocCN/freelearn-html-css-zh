- en: 'Chapter 6. Interacting with the Canvas: Attaching Event Listeners to Shapes
    and Regions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。与画布交互：将事件监听器附加到形状和区域
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating an Events class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Events类
- en: Working with canvas mouse coordinates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用画布鼠标坐标
- en: Attaching mouse event listeners to regions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标事件监听器附加到区域
- en: Attaching touch event listeners to regions on a mobile device
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将触摸事件监听器附加到移动设备上的区域
- en: Attaching event listeners to images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件监听器附加到图像
- en: Dragging-and-dropping shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖放形状
- en: Dragging-and-dropping images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖放图像
- en: Creating an image magnifier
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个图像放大器
- en: Creating a drawing application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个绘图应用程序
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we've learned how to draw on the canvas, work with images and video,
    and create fluid animations. This chapter focuses on canvas interactivity. Until
    now, all of our canvas projects have been very unresponsive and disengaged from
    the user. Although the HTML5 canvas API doesn't provide us with a means for attaching
    event listeners to shapes and regions, we can certainly achieve this functionality
    by extending the API. According to the HTML5 specification, once a shape is drawn,
    we have no access to it as an object like we do with DOM elements in an HTML document.
    Until the HTML5 canvas specification includes methods for attaching event listeners
    to shapes and regions, (hopefully it will some day), we'll need to construct our
    own Events class which will enable us to do so. Our class will enable us to attach
    event listeners to regions which wrap one or more shapes, similar to attaching
    event listeners to DOM elements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何在画布上绘制，处理图像和视频，并创建流畅的动画。本章重点是画布的交互性。到目前为止，我们所有的画布项目都非常不响应和与用户脱节。尽管HTML5画布API没有提供一种方法来将事件监听器附加到形状和区域，但我们可以通过扩展API来实现这种功能。根据HTML5规范，一旦形状被绘制，我们就无法像在HTML文档中对待DOM元素那样访问它。直到HTML5画布规范包括将事件监听器附加到形状和区域的方法（希望有一天会有），我们需要构建自己的Events类来实现这一点。我们的类将使我们能够将事件监听器附加到包装一个或多个形状的区域，类似于将事件监听器附加到DOM元素。
- en: '*This is quite a powerful notion because it enables us to draw shapes in the
    canvas that users can interact with. Our Events class will support* **mousedown**,
    **mouseup**, **mouseover**, **mouseout**, **mousemove**, **touchstart**, **touchend**,
    and **touchmove** events.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个非常强大的概念，因为它使我们能够在画布上绘制用户可以交互的形状。我们的Events类将支持* **mousedown**, **mouseup**,
    **mouseover**, **mouseout**, **mousemove**, **touchstart**, **touchend**, 和 **touchmove**
    事件。'
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although most of the recipes in this chapter utilize mouse events, they can
    also be modified to support mobile touch events by replacing `mousedown` with
    `touchstart`, `mouseup` with `touchend`, and `mousemove` with `touchmove`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章中的大多数示例都使用鼠标事件，但也可以通过用`touchstart`替换`mousedown`，用`touchend`替换`mouseup`，用`touchmove`替换`mousemove`来修改以支持移动触摸事件。
- en: Let's get started!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating an Events class
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Events类
- en: Similar to [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas to Life with
    Animation"), *Bringing the Canvas to Life with Animation*, where we created a
    custom class to handle animations, in this chapter we'll create a custom class
    to handle canvas events.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[第5章](ch05.html "第5章。通过动画使画布生动起来")，“通过动画使画布生动起来”，在那一章中，我们创建了一个自定义类来处理动画，本章中我们将创建一个自定义类来处理画布事件。
- en: 'As canvas shapes are not accessible as objects (bummer!), there''s nothing
    for us to attach event listeners to like we would with a div element as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于画布形状不可作为对象访问（遗憾！），我们无法像对待div元素那样附加事件监听器：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So what can we do? If we follow the pattern of the canvas API, in which the
    beginning of a shape is defined with `beginPath()` , and the end of the shape
    is defined by `closePath()` , we can extend this idea one step further by introducing
    the concept of regions, which encapsulate multiple shapes. Furthermore, it would
    be really nice if we could add event listeners to a region in a similar manner
    that we add event listeners to DOM elements as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们能做什么呢？如果我们遵循画布API的模式，在其中形状的开始由`beginPath()`定义，形状的结束由`closePath()`定义，我们可以通过引入封装多个形状的区域的概念进一步扩展这个想法。此外，如果我们能够以类似的方式向区域添加事件监听器，就像我们向DOM元素添加事件监听器一样，那将非常好：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The goal of the Events class is to do just that by extending the canvas API
    to support canvas events by introducing regions which can be attached with desktop
    event listeners such as `mousedown`, `mouseup`, `mouseover`, `mouseout`, and `mousemove`,
    and also mobile event listeners such as `touchstart`, `touchend`, and `touchmove`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Events类的目标就是通过扩展画布API来支持画布事件，引入可以附加桌面事件监听器（如`mousedown`，`mouseup`，`mouseover`，`mouseout`和`mousemove`）以及移动事件监听器（如`touchstart`，`touchend`和`touchmove`）的区域。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Rather than typing out the Events class by hand, you may consider downloading
    the class from the online resources for this book at [www.html5canvastutorials.com/cookbook](http://www.html5canvastutorials.com/cookbook).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与其手动输入Events类，不如考虑从本书的在线资源中下载该类[www.html5canvastutorials.com/cookbook](http://www.html5canvastutorials.com/cookbook)。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create an Events class which will enable us to attach
    event listeners to shapes and regions on the canvas:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个Events类，它将使我们能够将事件监听器附加到画布上的形状和区域：
- en: 'Define the `Events` constructor:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Events`构造函数：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define the `getContext()` method which returns the canvas context:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getContext()`方法，返回画布上下文：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the `getCanvas()` method which returns the canvas DOM element:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getCanvas()`方法，返回画布DOM元素：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the `clear()` method which clears the canvas:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`clear()`方法，清除画布：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define the `getCanvasPos()` method which returns the canvas position:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getCanvasPos()`方法，返回画布位置：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the `setStage()` method which sets the `stage()` function:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setStage()`方法，设置`stage()`函数：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the `reset()` method which sets the mouse position and the touch position,
    resets the region index, calls the `stage()` function, and then resets the event
    flags:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`reset()`方法，用于设置鼠标位置和触摸位置，重置区域索引，调用`stage()`函数，然后重置事件标志：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define the `listen()` method which adds event listeners to the canvas element:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`listen()`方法，向画布元素添加事件监听器：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the `getMousePos()` method which returns the mouse position for desktop
    applications:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getMousePos()`方法，用于桌面应用程序返回鼠标位置：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the `getTouchPos()` method which returns the touch position for mobile
    applications:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getTouchPos()`方法，用于移动应用程序返回触摸位置：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `setMousePos()` method which sets the mouse position:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setMousePos()`方法，用于设置鼠标位置：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define the `setTouchPos()` method which sets the touch position:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`setTouchPos()`方法，用于设置触摸位置：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the `beginRegion()` method which is used to define a new region:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`beginRegion()`方法，用于定义一个新区域：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the `addRegionEventListener()` method which is used to add an event
    listener to a region:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`addRegionEventListener()`方法，用于向区域添加事件监听器：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the `closeRegion()` method which is used to close a region and determine
    if an event has occurred with respect to the current region:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`closeRegion()`方法，用于关闭一个区域并确定是否发生了与当前区域相关的事件：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Even though the HTML5 canvas API doesn''t provide a way for us to easily handle
    event listeners, it does provide one key method that will make it possible:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HTML5画布API没有提供一种方便处理事件监听器的方法，但它提供了一个关键方法，使这成为可能：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `isPointInPath()` method returns true if the given coordinates reside within
    *any* path drawn on the canvas. As the canvas is a bitmap, the concept of layers
    and shapes has no meaning here, so we'll have to figure out a way to leverage
    the `isPointInPath()` method for determining whether or not a given coordinate,
    in particular the mouse coordinates, resides within a specific region of the canvas.
    Once we can detect whether or not the mouse cursor is on top of a particular region,
    we can add additional logic to handle `mouseover`, `mousemove`, `mouseout`, `mousedown`,
    `mouseup`, `touchstart`, `touchend`, and `touchmove` events.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`isPointInPath()`方法如果给定的坐标在画布上绘制的*任何*路径内，则返回true。由于画布是位图，这里没有图层和形状的概念，因此我们必须想办法利用`isPointInPath()`方法来确定特定区域的坐标，特别是鼠标坐标，是否在画布上。一旦我们能够检测鼠标光标是否在特定区域上方，我们可以添加额外的逻辑来处理`mouseover`、`mousemove`、`mouseout`、`mousedown`、`mouseup`、`touchstart`、`touchend`和`touchmove`事件。'
- en: Before getting in any deeper, let's make up an example and formulate a procedure
    for simulating region events, and then use what we've learned to lay out the methods
    we'll need to create the `Events` class. Let's say that we want to draw a triangle,
    a rectangle, and a circle on the canvas, and then we want to alert some text when
    the user places their cursor over the circle. We could first draw the triangle,
    and then see whether the mouse coordinates reside within the current path using
    `isPointInPath()`. If the method returns false, we know that the mouse cursor
    is somewhere outside of the triangle. Next, we could draw the rectangle, and again
    check whether the mouse coordinates reside within any path, which at this point
    includes the triangle and the rectangle. If `isPointInPath()` still returns false,
    we now know that the mouse cursor is somewhere outside of the triangle and the
    rectangle. Finally, we can draw the circle, and once again check whether the mouse
    coordinates reside within any path on the canvas, which now includes the triangle,
    rectangle, and circle. If the method returns true, then the mouse is indeed over
    the circle. If it returns false, then the mouse cursor is somewhere outside the
    triangle, rectangle, and circle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论之前，让我们举个例子，制定一个模拟区域事件的流程，然后利用所学知识来制定我们需要创建`Events`类的方法。假设我们想在画布上绘制一个三角形、一个矩形和一个圆，然后当用户将鼠标放在圆上时，我们想要弹出一些文本。我们可以先绘制三角形，然后使用`isPointInPath()`来检查鼠标坐标是否在当前路径内。如果该方法返回false，我们就知道鼠标光标在三角形外面。接下来，我们可以绘制矩形，再次检查鼠标坐标是否在任何路径内，这时包括了三角形和矩形。如果`isPointInPath()`仍然返回false，我们现在知道鼠标光标在三角形和矩形外面。最后，我们可以绘制圆，再次检查鼠标坐标是否在画布上的任何路径内，这时包括了三角形、矩形和圆。如果该方法返回true，则鼠标确实在圆上。如果返回false，则鼠标光标在三角形、矩形和圆外面。
- en: Of course, this only works if we assume that the cursor is already positioned
    somewhere on the canvas before the elements are actually drawn. The only way that
    we can detect whether the mouse cursor is on top of an element after the cursor
    has moved is to redraw our elements each time an event is triggered, and then
    check whether the mouse coordinates exist within a shape after drawing each element.
    We can accomplish this by defining the `stage()` function with the `setStage()`
    method of the `Events` class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这仅在我们假设在元素实际绘制之前，光标已经位于画布的某个位置时才有效。在光标移动后，我们能够检测鼠标光标是否在元素上方的唯一方法是在每次触发事件时重新绘制我们的元素，然后检查鼠标坐标是否在绘制每个元素后存在的形状内。我们可以通过使用`Events`类的`setStage()`方法来定义`stage()`函数来实现这一点。
- en: 'Next, we need a way to define the beginning and the end of a region. We can
    create a `beginRegion()` method which defines a new `Region` object. The `Region`
    object can have eight properties: `mouseover`, `mouseout`, `mousemove`, `mousedown`,
    `mouseup`, `touchstart`, `touchend`, and `touchmove`, all of which are user-defined
    functions. Next, we can create a method called `addRegionEventListener()` which
    can be used to attach region events which require an event type and the function
    to be called when the event occurs. Since we have a method that begins a new region,
    we also need to create a `closeRegion()` method. This method contains most of
    the logic required to determine if one of the eight events has occurred. Finally,
    we can create a `listen()` method which adds event listeners to the canvas element
    in order to appropriately handle the region events.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来定义区域的开始和结束。我们可以创建一个`beginRegion()`方法来定义一个新的`Region`对象。`Region`对象可以有八个属性：`mouseover`、`mouseout`、`mousemove`、`mousedown`、`mouseup`、`touchstart`、`touchend`和`touchmove`，所有这些都是用户定义的函数。接下来，我们可以创建一个名为`addRegionEventListener()`的方法，用于附加需要事件类型和事件发生时要调用的函数的区域事件。由于我们有一个开始新区域的方法，我们还需要创建一个`closeRegion()`方法。该方法包含了大部分逻辑，用于确定是否发生了八个事件中的一个。最后，我们可以创建一个`listen()`方法，该方法向画布元素添加事件监听器，以便适当处理区域事件。
- en: The Events class described in this recipe works by defining regions with the
    `beginRegion()` and `closeRegion()` methods, and then redrawing the regions each
    time an event is triggered in order to detect which which region the event belongs
    to. The advantage of this approach is that it's easy to implement and that we
    only need one canvas element.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍的Events类通过使用`beginRegion()`和`closeRegion()`方法定义区域，然后在每次触发事件时重新绘制区域，以便检测事件属于哪个区域。这种方法的优点是易于实现，而且我们只需要一个画布元素。
- en: Although, this approach works beautifully for canvas applications that have
    a reasonable number of regions with attached event listeners, it may not be the
    best approach for applications using a large number of regions. Applications that
    require thousands of regions, each with their own event listeners, may run into
    performance issues due to the number of shapes being redrawn each time the mouse
    moves.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法对于具有合理数量的区域和附加事件监听器的画布应用程序非常有效，但对于使用大量区域的应用程序来说可能不是最佳方法。需要成千上万个区域，每个区域都有自己的事件监听器的应用程序可能会因为每次鼠标移动时重绘的形状数量而遇到性能问题。
- en: For such applications, a more complex approach can be used by assigning each
    region its own canvas and then stacking the canvases on top of each other so that
    the regions don't have to be redrawn each time an event is triggered. One great
    example of this approach is the KineticJS library ([http://www.kineticjs.com](http://www.kineticjs.com)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的应用程序，可以使用更复杂的方法，为每个区域分配自己的画布，然后将画布堆叠在一起，这样每次触发事件时就不必重新绘制区域。这种方法的一个很好的例子是KineticJS库（[http://www.kineticjs.com](http://www.kineticjs.com)）。
- en: Working with canvas mouse coordinates
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用画布鼠标坐标
- en: To get our feet wet with the `Events` class, we'll keep it simple by getting
    the mouse coordinates of the cursor using the `getMousePos()` method from the
    `Events` class and then displaying it in the top-left corner of the canvas. The
    `getMousePos()` method returns the mouse coordinates relative to the canvas, which
    takes into account the offset position of the canvas relative to the page, and
    also the scroll position of the page.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉Events类，我们将简单地使用Events类的`getMousePos()`方法获取鼠标光标的坐标，然后在画布的左上角显示它。`getMousePos()`方法返回相对于画布的鼠标坐标，考虑了画布相对于页面的偏移位置，以及页面的滚动位置。
- en: '![Working with canvas mouse coordinates](img/1369_06_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用画布鼠标坐标](img/1369_06_01.jpg)'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to get the canvas mouse coordinates and display them in
    the upper-left corner of the canvas each time the mouse cursor moves:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤获取画布鼠标坐标，并在鼠标光标移动时将其显示在画布的左上角：
- en: 'Link to the `Events` class:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到“Events”类：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the `writeMessage()` function which writes out a message:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`writeMessage()`函数，用于写出消息：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instantiate a new `Events` object and get the canvas and context:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的Events对象并获取画布和上下文：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the user mouses out of the canvas, clear the canvas and then write out
    the message "Mouseover me!":'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户鼠标移出画布时，清除画布，然后写出消息“Mouseover me!”：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the user moves his/her mouse in the canvas, clear the canvas, and then
    write out the mouse position:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在画布中移动鼠标时，清除画布，然后写出鼠标位置：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Start listening for events:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始监听事件：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Write the initial message before the user begins:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户开始之前写出初始消息：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the page loads, we can instantiate an `Events` object so that we have access
    to the `getMousePos()` method. Next, we can attach a `mouseout` event listener
    to the `canvas` object which sets the event display to "Mouseover me!", and also
    attach a `mousemove` event listener to the `canvas` object that gets the mouse
    position using the `getMousePos()` method and then writes out the coordinates.
    Finally, we can start listening for events using the `listen()` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，我们可以实例化一个Events对象，以便我们可以访问`getMousePos()`方法。接下来，我们可以为canvas对象附加一个`mouseout`事件监听器，该监听器将事件显示设置为“Mouseover
    me!”，并且还可以为canvas对象附加一个`mousemove`事件监听器，该监听器使用`getMousePos()`方法获取鼠标位置，然后写出坐标。最后，我们可以使用`listen()`方法开始监听事件。
- en: Attaching mouse event listeners to regions
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将鼠标事件监听器附加到区域
- en: In this recipe, we'll get to the meat of the `Events` class by defining regions
    and adding event listeners to them. We'll draw a triangle, attach a `mouseout`
    and `mousemove` event listener to it, we'll draw a rectangle with no event listeners,
    and finally we'll draw a circle and attach a `mouseover`, `mouseout`, `mousedown`,
    and `mouseup` event listener to try out each of the different desktop event listeners
    supported by the `Events` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过定义区域并向其添加事件侦听器来深入了解`Events`类。我们将绘制一个三角形，为其附加`mouseout`和`mousemove`事件侦听器，然后绘制一个没有事件侦听器的矩形，最后绘制一个圆形，并为其附加`mouseover`、`mouseout`、`mousedown`和`mouseup`事件侦听器，以尝试`Events`类支持的不同桌面事件侦听器。
- en: '![Attaching mouse event listeners to regions](img/1369_06_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![将鼠标事件侦听器附加到区域](img/1369_06_02.jpg)'
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a triangle, a rectangle, and a circle, and then
    attach mouse event listeners to each shape:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个三角形、一个矩形和一个圆形，然后为每个形状附加鼠标事件侦听器：
- en: 'Link to the `Events` class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Events`类：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define the `writeMessage()` function which writes out a message:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`writeMessage()`函数，用于写出一条消息：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Instantiate a new `Events` object and get the canvas and context:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的`Events`对象并获取画布和上下文：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Begin defining the `stage()` function which starts by clearing the canvas:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始定义`stage()`函数，首先清除画布：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Begin a new region with `beginRegion()` and then draw a blue triangle:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`beginRegion()`开始一个新区域，然后绘制一个蓝色三角形：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add `mousemove` and `mouseout` event listeners to the triangle and close the
    region with `closeRegion()`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向三角形添加`mousemove`和`mouseout`事件侦听器，并使用`closeRegion()`关闭该区域：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Draw a yellow rectangle with no event listeners:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个没有事件侦听器的黄色矩形：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Begin a new region and draw a red circle:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新区域并绘制一个红色圆形：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Attach `mousedown`, `mouseup`, `mouseover`, and `mouseout` event listeners
    to the circle, and close the region:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向圆形附加`mousedown`、`mouseup`、`mouseover`和`mouseout`事件侦听器，并关闭该区域：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Write out a message:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出一条消息：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To attach events to the three shapes in this recipe, we first need to initialize
    an `Events` object and then set the `stage()` function. Inside the `stage()` function,
    we can define a new region using `beginRegion()`, draw the blue triangle, attach
    events using `addRegionEventListener()`, and then close the region using `closeRegion()`.
    Next, we can draw the yellow rectangle without defining a region because we aren't
    attaching any events to it. Finally, we can define a second region, draw the red
    circle, attach event listeners, and then close the region, completing the `stage()`
    function definition.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要将事件附加到本示例中的三个形状，我们首先需要初始化一个`Events`对象，然后设置`stage()`函数。在`stage()`函数内部，我们可以使用`beginRegion()`定义一个新区域，绘制蓝色三角形，使用`addRegionEventListener()`附加事件，然后使用`closeRegion()`关闭该区域。接下来，我们可以绘制黄色矩形，而不需要定义区域，因为我们不会为其附加任何事件。最后，我们可以定义第二个区域，绘制红色圆形，附加事件侦听器，然后关闭该区域，完成`stage()`函数的定义。
- en: See also...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a rectangle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and
    Composites")'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章.形状绘制和组合")中绘制一个矩形*'
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章.形状绘制和组合")中绘制一个圆形*'
- en: '*Working with custom shapes and fill styles* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章.形状绘制和组合")中使用自定义形状和填充样式*'
- en: '*Attaching touch event listeners to regions on a mobile device*'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在移动设备上将触摸事件侦听器附加到区域*'
- en: Attaching touch event listeners to regions on a mobile device
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在移动设备上附加触摸事件侦听器到区域
- en: For those of you crying "What about mobile devices? Desktops and laptops are
    a thing of the past!" – this recipe is just for you. As Internet surfers migrate
    away from their giant tethered desktops and begin consuming Internet content from
    mobile devices, it's becoming more evident every day that the future of the Web,
    including canvas, will reside mostly in the mobile space.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些喊着“移动设备怎么办？台式机和笔记本电脑已经过时了！”的人来说，这个示例就是为你准备的。随着互联网用户从巨大的桌面设备转向移动设备，并开始从移动设备消费互联网内容，每天都越来越明显，包括canvas在内的Web的未来主要在移动空间中。
- en: Unlike web applications running on desktops and laptops, where user interactions
    are detected using the mouse from `mousedown`, `mouseup`, `mouseover`, `mouseout`,
    and `mousemove` events, web applications running on mobile devices are interacted
    with touch events from `touchstart`, `touchend`, and `touchmove` events.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与在台式机和笔记本电脑上运行的Web应用程序不同，移动设备上运行的Web应用程序是通过`touchstart`、`touchend`和`touchmove`事件的触摸事件来检测用户交互的。
- en: In this recipe, we'll create a mobile version of the previous recipe by adding
    touch event listeners to the triangle and circle.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过向三角形和圆形添加触摸事件侦听器来创建前一个示例的移动版本。
- en: As mentioned earlier, any of the recipes in this chapter could be modified to
    support mobile devices by adding touch event listeners.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本章中的任何示例都可以通过添加触摸事件侦听器来修改以支持移动设备。
- en: '![Attaching touch event listeners to regions on a mobile device](img/1369_06_08.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![在移动设备上将触摸事件侦听器附加到区域](img/1369_06_08.jpg)'
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw a triangle, a rectangle, and a circle, and then
    attach mobile touch events to each shape:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制一个三角形、一个矩形和一个圆形，然后为每个形状附加移动触摸事件：
- en: 'Add a viewport meta tag inside the header tag to set the mobile device width,
    set the initial scale, and disable user scaling:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头标签内添加一个viewport meta标签，以设置移动设备的宽度，设置初始比例，并禁用用户缩放：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Link to the `Events` class:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Events`类：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define the `writeMessage()` function which writes out a message:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`writeMessage()`函数，用于写出一条消息：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instantiate a new `Events` object and get the canvas and context:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的`Events`对象并获取画布和上下文：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Begin defining the `sStage()` function which starts by clearing the canvas:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始定义`sStage()`函数，首先清除画布：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Begin a new region with `beginRegion()` and then draw a blue triangle:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`beginRegion()`开始一个新区域，然后绘制一个蓝色三角形：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the `touchmove` event listener to the triangle and close the region with
    `closeRegion()`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`touchmove`事件监听器添加到三角形上，并使用`closeRegion()`关闭区域：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Draw a yellow rectangle with no event listeners:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个没有事件监听器的黄色矩形：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Begin a new region and draw a red circle:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的区域并绘制一个红色圆：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Attach `touchstart` and `touchend` event listeners to the circle and close
    the region:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`touchstart`和`touchend`事件监听器附加到圆上并关闭区域：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Write out a message:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出一条消息：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Similar to the previous recipe, in this recipe we'll attach event listeners
    to the triangle and the circle, except this time we'll attach touch event listeners
    so that the demo can be run on a mobile device.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例类似，在这个示例中，我们将事件监听器附加到三角形和圆上，只是这一次我们将附加触摸事件监听器，以便演示可以在移动设备上运行。
- en: Touch events on mobile devices are actually quite simple, and work in much the
    same way as desktop events. The mobile equivalent of `mousedown` is `touchstart`,
    the equivalent of `mouseup` is `touchend`, and the equivalent of `mousemove` is
    `touchmove`. As mobile devices can't detect if your finger is hovering over a
    region, mobile devices don't have an equivalent for `mouseover` or `mouseout`,
    I wouldn't be surprised if sometime in the future mobile devices *could* detect
    when fingers are close to the screen but not quite touching it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备上的触摸事件实际上非常简单，并且工作方式与桌面事件基本相同。 `mousedown` 的移动设备等效是 `touchstart`，`mouseup`
    的等效是 `touchend`，`mousemove` 的等效是 `touchmove`。由于移动设备无法检测到手指是否悬停在区域上，因此移动设备没有 `mouseover`
    或 `mouseout` 的等效，我不会感到惊讶，如果将来移动设备*可以*检测到手指是否接近屏幕但没有触碰到它。
- en: To show the touch coordinates for the blue triangle, we can use the `touchmove`
    event listener, and to detect when the red circle is being touched or released,
    we can use the `touchstart` and `touchend` events.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示蓝色三角形的触摸坐标，我们可以使用`touchmove`事件监听器，并且为了检测红色圆何时被触摸或释放，我们可以使用`touchstart`和`touchend`事件。
- en: See also...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a rectangle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and
    Composites")'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章。形状绘制和组合")中绘制一个矩形*'
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章。形状绘制和组合")中绘制一个圆*'
- en: '*Working with custom shapes and fill styles* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章。形状绘制和组合")中使用自定义形状和填充样式*'
- en: '*Attaching mouse event listeners to regions*'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将鼠标事件监听器附加到区域*'
- en: Attaching event listeners to images
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加事件监听器到图像
- en: In this recipe, we'll attach event listeners to images. As we can only attach
    event listeners to paths with our `Events` class, and as images drawn on the canvas
    aren't classified as paths, we can create a rectangular region that overlays an
    image in order to attach event listeners to the rectangular region, and consequently
    attach event listeners to the image.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将事件监听器附加到图像上。由于我们只能使用`Events`类将事件监听器附加到路径上，并且在画布上绘制的图像不被归类为路径，因此我们可以创建一个覆盖图像的矩形区域，以便将事件监听器附加到矩形区域，并因此将事件监听器附加到图像。
- en: '![Attaching event listeners to images](img/1369_06_03.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![将事件监听器附加到图像](img/1369_06_03.jpg)'
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to draw two different images and then attach `mouseover`,
    `mouseout`, `mousedown`, and `mouseup` event listeners to them:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绘制两个不同的图像，然后将`mouseover`、`mouseout`、`mousedown`和`mouseup`事件监听器附加到它们：
- en: 'Link to the `Events` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Events`类：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define the `writeMessage()` function which writes out a message:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`writeMessage()`函数，用于写出一条消息：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create an image loader that loads a set of images and then calls a `callback`
    function whenever all of the images have loaded:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图像加载器，加载一组图像，然后在所有图像加载完成时调用`callback`函数：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define the `drawImages()` function which instantiates a new `Events` object
    and begins defining the `stage()` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawImages()`函数，该函数实例化一个新的`Events`对象并开始定义`stage()`函数：
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Begin a new region, draw the left image, define a rectangular region that represents
    the image path, attach event listeners to the rectangular region, and then close
    the region. Repeat these steps for the right image as well, and then write out
    a message:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的区域，绘制左侧图像，定义代表图像路径的矩形区域，将事件监听器附加到矩形区域，然后关闭区域。然后重复这些步骤来创建右侧图像，并写出一条消息：
- en: '[PRE53]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When the page loads create a hash of image sources and then pass it off to
    the `loadImages()` function:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载时创建图像源的哈希，然后将其传递给`loadImages()`函数：
- en: '[PRE54]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the page loads, we can use an image loader function to load two images.
    When both images have loaded, the `drawImages()` function is called and an `Events`
    object is instantiated. Inside the `stage()` function, we can begin a new region
    with `beginRegion()`, draw the first image, draw a rectangular path to define
    the image path, attach events using `addRegionEventListener()`, and then close
    the region. Next, we can repeat this process to create the second image with its
    own set of event listeners.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，我们可以使用图像加载器函数加载两个图像。当两个图像都加载完成时，将调用`drawImages()`函数并实例化一个`Events`对象。在`stage()`函数内部，我们可以使用`beginRegion()`开始一个新的区域，绘制第一张图像，绘制一个矩形路径来定义图像路径，使用`addRegionEventListener()`附加事件，然后关闭区域。接下来，我们可以重复此过程，创建第二个图像及其自己的一组事件监听器。
- en: See also...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html "第3章。使用图像和视频")中绘制一个图像*'
- en: Dragging-and-dropping shapes
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放形状
- en: In this recipe, we'll tackle the holy grail of event listeners—drag-and-drop.
    Without the `Events` class or some other lightweight JavaScript library, drag-and-drop
    operations can be quite cumbersome to develop. We can use the `Events` class to
    attach a `mouseover`, `mousedown`, `mousemove`, `mouseup`, and `mouseout` event
    listener to the rectangle to handle different phases of the drag-and-drop operation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将解决事件侦听器的圣杯——拖放。如果没有`Events`类或其他轻量级的JavaScript库，拖放操作可能会相当繁琐。我们可以使用`Events`类将`mouseover`、`mousedown`、`mousemove`、`mouseup`和`mouseout`事件侦听器附加到矩形上，以处理拖放操作的不同阶段。
- en: '![Dragging-and-dropping shapes](img/1369_06_04.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![拖放形状](img/1369_06_04.jpg)'
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to drag-and-drop a rectangle:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤拖放矩形：
- en: 'Link to the `Events` class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Events`类：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define the `writeMessage()` function which writes out a message:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`writeMessage()`函数，用于写出消息：
- en: '[PRE57]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When the page loads, instantiate a new `Events` object, define the starting
    position of the rectangle that will be dragged-and-dropped, and define `draggingRect`,
    `draggingRectOffsetX`, and `draggingRectOffsetY` for the drag-and-drop operation:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载时，实例化一个新的`Events`对象，定义将要拖放的矩形的起始位置，并为拖放操作定义`draggingRect`、`draggingRectOffsetX`和`draggingRectOffsetY`：
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the `stage()` function, begin by setting the coordinates of the rectangle
    based on the coordinates of the mouse if the `draggingRect` Boolean is true:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`stage()`函数，首先根据鼠标的坐标设置矩形的坐标，如果`draggingRect`布尔值为true：
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Clear the canvas, write out a message, begin a new region, draw the rectangle,
    attach events, and then close the region:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除画布，写出消息，开始一个新的区域，绘制矩形，附加事件，然后关闭区域：
- en: '[PRE60]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Drag-and-drop is handled with three phases:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放由三个阶段处理：
- en: Detect a `mousedown` event over a shape which begins the operation
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测形状上的`mousedown`事件，开始操作
- en: Position the shape according to the mouse coordinates using the `mousemove`
    event listener
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mousemove`事件侦听器根据鼠标坐标定位形状
- en: Drop the shape when the mouse button is released (`mouseup`)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当鼠标按钮释放时放下形状（`mouseup`）
- en: Inside the `stage()` function, we can set the position of the rectangle relative
    to the position of the mouse if the `draggingRect` Boolean is true. We can then
    begin a new region with `beginRegion()`, draw the rectangle, and then attach event
    listeners using the `addRegionEventListener()` method. We can add a `mousedown`
    event listener that sets the `draggingRect` Boolean to true, and then calculates
    the `draggingRectOffsetX` and `draggingRectOffsetY` variables which account for
    the position offset between the mouse and the top-left corner of the rectangle.
    Next, we can add a `mouseup` event listener that sets the `draggingRect` Boolean
    to false, completing the drag-and-drop operation. We can also attach a `mouseover`
    event listener to turn the cursor into a hand to show that the element can be
    interacted with, and we can also attach a `mouseout` event listener to restore
    the cursor image back to the default pointer to indicate that the mouse cursor
    is no longer over the element.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`stage()`函数内，如果`draggingRect`布尔值为true，我们可以设置矩形相对于鼠标位置的位置。然后我们可以使用`beginRegion()`开始一个新的区域，绘制矩形，然后使用`addRegionEventListener()`方法附加事件侦听器。我们可以添加一个`mousedown`事件侦听器，将`draggingRect`布尔值设置为true，然后计算`draggingRectOffsetX`和`draggingRectOffsetY`变量，这些变量考虑了鼠标和矩形左上角之间的位置偏移。接下来，我们可以添加一个`mouseup`事件侦听器，将`draggingRect`布尔值设置为false，完成拖放操作。我们还可以附加一个`mouseover`事件侦听器，将光标变成手形，以显示可以与元素交互，还可以附加一个`mouseout`事件侦听器，将光标图像恢复为默认指针，以指示鼠标光标不再位于元素上。
- en: See also...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见...
- en: '*Dragging-and-dropping images*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拖放图像*'
- en: Dragging-and-dropping images
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放图像
- en: This recipe essentially combines the concepts from the previous two recipes
    to demonstrate how we can drag-and-drop an image.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱基本上结合了前两个食谱的概念，演示了如何拖放图像。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to drag-and-drop an image:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤拖放图像：
- en: 'Link to the `Events` class:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Events`类：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define the `writeMessage()` function which writes out a message:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`writeMessage()`函数，用于写出消息：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define the `drawImage()` function which begins by instantiating a new `Events`
    object and setting the initial position of the rectangular region that overlays
    the image:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawImage()`函数，该函数首先实例化一个新的`Events`对象，并设置覆盖图像的矩形区域的初始位置：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Define the `stage()` function which begins by setting the position of the image
    based on the coordinates of the mouse if the `draggingRect` Boolean is true:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`stage()`函数，该函数首先根据鼠标的坐标设置图像的位置，如果`draggingRect`布尔值为true：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Clear the canvas and write out a message:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除画布并写出消息：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Begin a new region, draw the image, draw a rectangular region to define the
    image path, attach event listeners, and close the region:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的区域，绘制图像，绘制一个矩形区域来定义图像路径，附加事件侦听器，然后关闭区域：
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When the page loads, load the image and then call the `drawImage()` function:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载时，加载图像，然后调用`drawImage()`函数：
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Embed the canvas inside the body of the HTML document:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中：
- en: '[PRE69]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To drag-and-drop an image, we can draw an invisible rectangular path on top
    of the image to provide a path for the image, and we can attach the `mousedown`,
    `mouseup`, and `mousemove` events similar to the previous recipe to handle the
    three phases of drag-and-drop.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要拖放图像，我们可以在图像上方绘制一个不可见的矩形路径，为图像提供路径，并且可以像处理前一个食谱一样附加`mousedown`、`mouseup`和`mousemove`事件来处理拖放的三个阶段。
- en: When the user drags-and-drops an image, he/she is essentially dragging and dropping
    both the image and its corresponding rectangular path.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户拖放图像时，实质上是在拖放图像及其对应的矩形路径。
- en: See also...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见...
- en: '*Drawing an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html "第3章。处理图像和视频")中绘制图像'
- en: '*Dragging-and-dropping shapes*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拖放形状*'
- en: Creating an image magnifier
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像放大器
- en: In this recipe, we'll create a really neat image magnifier by cropping out a
    section of a large image based on the mouse coordinates of a small image and then
    displaying the result on top of the small image.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将通过根据小图像的鼠标坐标裁剪大图像的一部分来创建一个非常漂亮的图像放大器，然后在小图像上方显示结果。
- en: '![Creating an image magnifier](img/1369_06_06.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![创建图像放大器](img/1369_06_06.jpg)'
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to create an image magnifier that renders a magnified portion
    of an image when the user mouses over it:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个图像放大器，当用户将鼠标悬停在图像上方时，它会呈现图像的放大部分：
- en: 'Link to the `Events` class:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Events`类：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create an image loader that will load the small and large image and then call
    a callback function when the images have loaded:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图像加载器，加载小图像和大图像，然后在图像加载完成时调用回调函数：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Define the `drawMagnifier()` function which draws the magnified image:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawMagnifier()`函数，绘制放大的图像：
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Define the `drawImages()` function which begins by instantiating a new `Events`
    object and defines the magnifier properties:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawImages()`函数，该函数首先实例化一个新的`Events`对象，并定义放大镜的属性：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Set the `stage()` function which draws the small image and then calls `drawMagnifier()`
    to draw the magnified image:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，绘制小图像，然后调用`drawMagnifier()`绘制放大的图像：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add an event listener to the canvas element which redraws the stage if the
    user mouses out of the canvas in order to remove the magnified image:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向画布元素添加事件侦听器，如果用户将鼠标移出画布，则重新绘制舞台以移除放大的图像：
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When the page loads, build a hash of image sources, and pass it on to the image
    loader function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载时，构建图像源的哈希，并将其传递给图像加载器函数：
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Embed the canvas inside the body of the HTML document.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布嵌入到HTML文档的主体中。
- en: '[PRE77]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To create an image magnifier, we'll need two images, one small and one large.
    The small image will be the image that's always visible on the canvas, and the
    large image will be used as a buffer image to draw the magnifier. Once the page
    loads, and both images are loaded, we can instantiate an `Events` object and begin
    defining the `stage()` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建图像放大器，我们需要两个图像，一个小图像和一个大图像。小图像将始终显示在画布上，而大图像将用作缓冲图像以绘制放大镜。页面加载后，两个图像都加载完成后，我们可以实例化一个`Events`对象并开始定义`stage()`函数。
- en: After drawing the small image centered on the canvas, we can draw the magnified
    image by calculating the `sourceX`, `sourceY`, `destX`, and `destY` parameters
    of the `drawImage()` method which will crop out the magnified section of the large
    image, and then display the result on top of the smaller image.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制小图像后，我们可以通过计算`drawImage()`方法的`sourceX`、`sourceY`、`destX`和`destY`参数来绘制放大的图像，该方法将裁剪出大图像的放大部分，然后在小图像上方显示结果。
- en: 'To get `sourceX` and `sourceY`, we can get the mouse coordinates relative to
    the small image by taking the difference between the mouse position and the position
    of the top-left corner of the small image, and then we can get the corresponding
    coordinates for the large image by multiplying the result by the magnification
    (which is the large image width divided by the small width), and then subtracting
    half the size of the magnified window:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`sourceX`和`sourceY`，我们可以通过鼠标位置与小图像左上角位置的差值来获取相对于小图像的鼠标坐标，然后我们可以通过放大倍数（即大图像宽度除以小宽度）乘以结果，并减去放大窗口大小的一半，来获取大图像的相应坐标：
- en: '[PRE78]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To center the magnified image on the mouse cursor, we can set `destX` equal
    to the x position of the mouse offset by half the magnifier width, and we can
    set `destY` equal to the y position of the mouse offset by half the magnifier
    height:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使放大的图像居中在鼠标光标上，我们可以将`destX`设置为鼠标位置的x偏移量减去放大镜宽度的一半，并且我们可以将`destY`设置为鼠标位置的y偏移量减去放大镜高度的一半：
- en: '[PRE79]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See also...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html "第3章。处理图像和视频")中绘制图像*'
- en: '*Cropping an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html "第3章。处理图像和视频")中裁剪图像*'
- en: Creating a drawing application
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建绘图应用程序
- en: In this recipe, we'll create a nifty drawing application so users can draw pictures
    right in the browser.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个漂亮的绘图应用程序，以便用户可以在浏览器中绘制图片。
- en: '![Creating a drawing application](img/1369_06_07.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![创建绘图应用程序](img/1369_06_07.jpg)'
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to create a simple drawing application:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个简单的绘图应用程序：
- en: 'Style the toolbar, inputs, and buttons:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式化工具栏、输入和按钮：
- en: '[PRE80]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Link to the `Events` class:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接到`Events`类：
- en: '[PRE81]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Define the `addPoint()` function which adds a point to the points array:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`addPoint()`函数，向点数组添加一个点：
- en: '[PRE82]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Define the `drawPath()` function which clears the canvas, redraws the canvas
    drawing before the path was started, and then draws the drawing path using the
    points in the points array:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drawPath()`函数，清除画布，在路径开始之前重新绘制画布绘图，然后使用点数组中的点绘制绘图路径：
- en: '[PRE83]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Define the `updateColorSquare()` function which updates the color of the toolbar
    color square:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateColorSquare()`函数，更新工具栏颜色方块的颜色：
- en: '[PRE84]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define the `getCanvasImg()` method which returns an image object of the canvas
    drawing:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`getCanvasImg()`方法，返回画布绘图的图像对象：
- en: '[PRE85]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When the page loads, instantiate a new `Events` object, define the `isMouseDown`
    flag, get the canvas image, and initialize the drawing color, and size:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载时，实例化一个新的`Events`对象，定义`isMouseDown`标志，获取画布图像，并初始化绘图颜色和大小：
- en: '[PRE86]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Update the color square whenever a new color input is entered:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入新颜色时更新颜色方块：
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Clear the canvas when the clear button is pressed:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下清除按钮时清除画布：
- en: '[PRE88]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When the **Save** button is pressed, convert the canvas drawing into a data
    URL and open the drawing as an image in a new window:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**保存**按钮时，将画布绘图转换为数据URL，并在新窗口中打开绘图作为图像：
- en: '[PRE89]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'When the user `mousedowns` on the canvas, get the drawing position, color,
    and size, set the path style, add the first point to the points array, and then
    set the `isMouseDown` flag to true:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在画布上`mousedown`时，获取绘图位置、颜色和大小，设置路径样式，将第一个点添加到点数组中，然后将`isMouseDown`标志设置为true：
- en: '[PRE90]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'When the user `mouseups` from the canvas, set the `isMouseDown` flag to false,
    draw the path, and then save the current image drawing:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户从画布上`mouseup`时，将`isMouseDown`标志设置为false，绘制路径，然后保存当前图像绘制：
- en: '[PRE91]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When the user’s mouse leaves the canvas, simulate a `mouseup` event:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户的鼠标离开画布时，模拟一个`mouseup`事件：
- en: '[PRE92]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Set the `stage()` function which continuously adds new points to the current
    drawing path if the mouse is down and moving:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`stage()`函数，如果鼠标按下并移动，则不断向当前绘图路径添加新点：
- en: '[PRE93]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Construct the toolbar and add the canvas element:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建工具栏并添加画布元素：
- en: '[PRE94]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Drawing applications typically have the following core features:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图应用程序通常具有以下核心功能：
- en: A `mousedown` event starts a drawing path, and a `mouseup` event ends a drawing
    path
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mousedown`事件开始绘图路径，`mouseup`事件结束绘图路径'
- en: Line widths can be set
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以设置线宽
- en: Colors can be set
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以设置颜色
- en: The drawing can be cleared
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以清除绘图
- en: The drawing can be saved
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以保存绘图
- en: Of course, if you wanted to create a Photoshop or Gimp-like drawing application
    on the Web, there are hundreds of other features you could add, but here we are
    nailing down just the basics to get started.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想在网页上创建类似于Photoshop或Gimp的绘图应用程序，你可以添加数百种其他功能，但在这里，我们只是确定了一些基本功能来开始。
- en: 'The first bullet in the preceding list is clearly the most important – we need
    to figure out a way that users can draw lines on the screen. The most straight
    forward way to do this is to follow these steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中的第一条显然是最重要的-我们需要找出一种用户可以在屏幕上绘制线条的方法。最直接的方法是按照以下步骤进行：
- en: When the user `mousedowns` somewhere on the canvas, set the path style and add
    the mouse position coordinate to an array of points to define the beginning point
    of the drawing path.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在画布上的某个地方`mousedown`时，设置路径样式并将鼠标位置坐标添加到点数组中，以定义绘图路径的起点。
- en: When the user moves the mouse, get the mouse position and add another point
    to the array of points, and then redraw the path with the new point.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户移动鼠标时，获取鼠标位置并向点数组添加另一个点，然后用新点重新绘制路径。
- en: When the user `mouseups`, set a flag indicating that the path is and save the
    current drawing image to be used with the next drawing path.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户从画布上`mouseup`时，设置一个标志，表示路径结束，并保存当前绘图图像以便在下一个绘图路径中使用。
- en: To keep things simple, we can let the user set the line width with a text input,
    and we can let the user set the color with three text inputs (the red, green,
    and blue components of a color).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们可以让用户使用文本输入设置线宽，并让用户使用三个文本输入设置颜色（颜色的红色、绿色和蓝色分量）。
- en: Finally, we can create a clear button that clears the canvas with the `clear()`
    method of the `Events` object, and we can create a save button that converts the
    canvas drawing into a data URL using the to `DataURL()` method of the canvas context,
    and then opens a new window with the data URL. From there, the user can right-click
    on the image to save it to their computer.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个清除按钮，使用`Events`对象的`clear()`方法清除画布，并创建一个保存按钮，使用画布上下文的`toDataURL()`方法将画布绘图转换为数据URL，然后打开一个新窗口显示数据URL。然后，用户可以右键单击图像将其保存到计算机上。
- en: There's more...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here are some more ideas if you''re creating a more complex drawing application:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个更复杂的绘图应用程序，以下是一些更多的想法：
- en: Until the color picker input is supported by all of the major browsers, you
    could create a custom color picker widget that lets users choose a color graphically
    instead of inputting the red, green, and blue components of the color that they
    want
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有主要浏览器都支持颜色选择器输入之前，你可以创建一个自定义颜色选择器小部件，让用户以图形方式选择颜色，而不是输入他们想要的颜色的红色、绿色和蓝色分量
- en: You could create a slider bar using the HTML5 range input for the paint brush
    size
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用HTML5范围输入创建滑块条来设置画笔大小
- en: You could create layer support by dynamically creating a new canvas element
    for each layer. Similar to Photoshop and Gimp, you could provide an ability to
    delete layers and merge layers
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过动态创建每个图层的新画布元素来创建图层支持。类似于Photoshop和Gimp，你可以提供删除图层和合并图层的功能
- en: If your application supports layering, you could also add an opacity control
    for each layer
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序支持分层，你还可以为每个图层添加不透明度控制
- en: You could enhance the save feature by saving the drawing in local storage or
    in an offline database (see *Converting a canvas drawing into a data URL* in [Chapter
    3](ch03.html "Chapter 3. Working with Images and Videos"))
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将绘图保存在本地存储或离线数据库中来增强保存功能（参见[第3章](ch03.html "第3章.处理图像和视频")中的*将画布绘图转换为数据URL*）
- en: Provide pre-built drawing shapes such as lines, rectangles, and circles
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供预先构建的绘图形状，如直线、矩形和圆形
- en: Allow shapes to be scaled and rotated
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许形状进行缩放和旋转
- en: Allow users to import images into their drawings
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户将图像导入其绘图中
- en: The list goes on...
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表还在继续...
- en: Hopefully this recipe further sparks your interest in canvas and gets you thinking
    about other possibilities. I think it's safe to say that someone will eventually
    create a full-blown image editing web application powered entirely by canvas and
    give Adobe a run for their money. Maybe it will be you!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个教程能进一步激发你对画布的兴趣，并让你思考其他可能性。我认为可以肯定地说，最终会有人创建一个完全由画布驱动的全功能图像编辑网页应用程序，并让Adobe感到压力。也许这个人就是你！
- en: See also...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Drawing a spiral* in [Chapter 1](ch01.html "Chapter 1. Getting Started withPaths
    and Text")'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第1章](ch01.html "第1章.开始使用路径和文本")中绘制螺旋线*'
- en: '*Converting a canvas drawing into a data URL in* [Chapter 3](ch03.html "Chapter 3. Working
    with Images and Videos")'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html "第3章.处理图像和视频")中将画布绘制转换为数据URL*'
- en: '*Saving a canvas drawing as an image in* [Chapter 3](ch03.html "Chapter 3. Working
    with Images and Videos")'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。处理图像和视频")中将画布绘图保存为图像
- en: '*Working with canvas mouse coordinates*'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用画布鼠标坐标
