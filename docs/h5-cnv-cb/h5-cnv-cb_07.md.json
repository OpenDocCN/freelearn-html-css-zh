["```js\n    /*\n     * PieChart constructor\n     */\n    function PieChart(canvasId, data){\n      // user defined properties\n      this.canvas = document.getElementById(canvasId);\n      this.data = data;\n\n      // constants\n      this.padding = 10;\n      this.legendBorder = 2;\n      this.pieBorder = 5;\n      this.colorLabelSize = 20;\n      this.borderColor = \"#555\";\n      this.shadowColor = \"#777\";\n      this.shadowBlur = 10;\n      this.shadowX = 2;\n      this.shadowY = 2;\n      this.font = \"16pt Calibri\";\n\n        // relationships\n        this.context = this.canvas.getContext(\"2d\");\n        this.legendWidth = this.getLegendWidth();\n        this.legendX = this.canvas.width - this.legendWidth;\n        this.legendY = this.padding;\n        this.pieAreaWidth = (this.canvas.width - this.legendWidth);\n        this.pieAreaHeight = this.canvas.height;\n        this.pieX = this.pieAreaWidth / 2;\n        this.pieY = this.pieAreaHeight / 2;\n        this.pieRadius = (Math.min(this.pieAreaWidth, this.pieAreaHeight) / 2) - (this.padding);\n\n        // draw pie chart\n        this.drawPieBorder();\n        this.drawSlices();\n        this.drawLegend();\n    }\n    ```", "```js\n    /*\n     * gets the legend width based on the size\n     * of the label text\n     */\n    PieChart.prototype.getLegendWidth = function(){\n        /*\n         * loop through all labels and determine which\n         * label is the longest.  Use this information\n         * to determine the label width\n         */\n        this.context.font = this.font;\n        var labelWidth = 0;\n\n        for (var n = 0; n < this.data.length; n++) {\n            var label = this.data[n].label;\n            labelWidth = Math.max(labelWidth, this.context.measureText(label).width);\n        }\n\n        return labelWidth + (this.padding * 2) + this.legendBorder + this.colorLabelSize;\n    };\n    ```", "```js\n    PieChart.prototype.drawPieBorder = function(){\n        var context = this.context;\n        context.save();\n        context.fillStyle = \"white\";\n        context.shadowColor = this.shadowColor;\n        context.shadowBlur = this.shadowBlur;\n        context.shadowOffsetX = this.shadowX;\n        context.shadowOffsetY = this.shadowY;\n        context.beginPath();\n        context.arc(this.pieX, this.pieY, this.pieRadius + this.pieBorder, 0, Math.PI * 2, false);\n        context.fill();\n        context.closePath();\n        context.restore();\n    };\n    ```", "```js\n    /*\n     * draws the slices for the pie chart\n     */\n    PieChart.prototype.drawSlices = function(){\n        var context = this.context;\n        context.save();\n        var total = this.getTotalValue();\n        var startAngle = 0;\n        for (var n = 0; n < this.data.length; n++) {\n            var slice = this.data[n];\n\n            // draw slice\n            var sliceAngle = 2 * Math.PI * slice.value / total;\n            var endAngle = startAngle + sliceAngle;\n\n            context.beginPath();\n            context.moveTo(this.pieX, this.pieY);\n            context.arc(this.pieX, this.pieY, this.pieRadius, startAngle, endAngle, false);\n            context.fillStyle = slice.color;\n            context.fill();\n            context.closePath();\n            startAngle = endAngle;\n        }\n      context.restore();\n    };\n    ```", "```js\n    /*\n     * gets the total value of the labels by looping through\n     * the data and adding up each value\n     */\n    PieChart.prototype.getTotalValue = function(){\n        var data = this.data;\n        var total = 0;\n\n        for (var n = 0; n < data.length; n++) {\n            total += data[n].value;\n        }\n\n        return total;\n    };\n    ```", "```js\n    /*\n     * draws the legend\n     */\n    PieChart.prototype.drawLegend = function(){\n        var context = this.context;\n        context.save();\n        var labelX = this.legendX;\n        var labelY = this.legendY;\n\n        context.strokeStyle = \"black\";\n        context.lineWidth = this.legendBorder;\n        context.font = this.font;\n        context.textBaseline = \"middle\";\n\n        for (var n = 0; n < this.data.length; n++) {\n            var slice = this.data[n];\n\n            // draw legend label\n            context.beginPath();\n            context.rect(labelX, labelY, this.colorLabelSize, this.colorLabelSize);\n            context.closePath();\n            context.fillStyle = slice.color;\n            context.fill();\n            context.stroke();\n            context.fillStyle = \"black\";\n            context.fillText(slice.label, labelX + this.colorLabelSize + this.padding, labelY + this.colorLabelSize / 2);\n\n            labelY += this.colorLabelSize + this.padding;\n        }\n      context.restore();\n    };\n    ```", "```js\n    window.onload = function(){\n        var data = [{\n            label: \"Eating\",\n            value: 2,\n            color: \"red\"\n        }, {\n            label: \"Working\",\n            value: 8,\n            color: \"blue\"\n        }, {\n            label: \"Sleeping\",\n            value: 8,\n            color: \"green\"\n        }, {\n            label: \"Errands\",\n            value: 2,\n            color: \"yellow\"\n        }, {\n            label: \"Entertainment\",\n            value: 4,\n            color: \"violet\"\n        }];\n\n        new PieChart(\"myCanvas\", data);\n    };\n    ```", "```js\n    <canvas id=\"myCanvas\" width=\"600\" height=\"300\" style=\"border:1px solid black;\">\n    </canvas>\n    ```", "```js\n    /*\n     * BarChart constructor\n     */\n    function BarChart(config){\n        // user defined properties\n        this.canvas = document.getElementById(config.canvasId);\n        this.data = config.data;\n        this.color = config.color;\n        this.barWidth = config.barWidth;\n        this.gridLineIncrement = config.gridLineIncrement;\n        /*\n         * adjust max value to highest possible value divisible\n         * by the grid line increment value and less than\n         * the requested max value\n         */\n        this.maxValue = config.maxValue - Math.floor(config.maxValue % this.gridLineIncrement);\n        this.minValue = config.minValue;\n\n        // constants\n        this.font = \"12pt Calibri\";\n        this.axisColor = \"#555\";\n        this.gridColor = \"#aaa\";\n        this.padding = 10;\n\n        // relationships\n        this.context = this.canvas.getContext(\"2d\");\n        this.range = this.maxValue - this.minValue;\n        this.numGridLines = this.numGridLines = Math.round(this.range / this.gridLineIncrement);\n        this.longestValueWidth = this.getLongestValueWidth();\n        this.x = this.padding + this.longestValueWidth;\n        this.y = this.padding * 2;\n        this.width = this.canvas.width - (this.longestValueWidth + this.padding * 2);\n        this.height = this.canvas.height - (this.getLabelAreaHeight() + this.padding * 4);\n\n        // draw bar chart\n        this.drawGridlines();\n        this.drawYAxis();\n        this.drawXAxis();\n        this.drawBars();\n        this.drawYVAlues();\n        this.drawXLabels();\n    }\n    ```", "```js\n    /*\n     * gets the label height by finding the max label width and\n     * using trig to figure out the projected height since\n     * the text will be rotated by 45 degrees\n     */\n    BarChart.prototype.getLabelAreaHeight = function(){\n        this.context.font = this.font;\n        var maxLabelWidth = 0;\n\n        /*\n         * loop through all labels and determine which\n         * label is the longest.  Use this information\n         * to determine the label width\n         */\n        for (var n = 0; n < this.data.length; n++) {\n            var label = this.data[n].label;\n            maxLabelWidth = Math.max(maxLabelWidth, this.context.measureText(label).width);\n        }\n\n        /*\n         * return y component of the labelWidth which\n         * is at a 45 degree angle:\n         *\n         * a^2 + b^2 = c^2\n         * a = b\n         * c = labelWidth\n         * a = height component of right triangle\n         * solve for a\n         */\n        return Math.round(maxLabelWidth / Math.sqrt(2));\n    };\n    ```", "```js\n    BarChart.prototype.getLongestValueWidth = function(){\n        this.context.font = this.font;\n        var longestValueWidth = 0;\n        for (var n = 0; n <= this.numGridLines; n++) {\n            var value = this.maxValue - (n * this.gridLineIncrement);\n            longestValueWidth = Math.max(longestValueWidth, this.context.measureText(value).width);\n\n        }\n        return longestValueWidth;\n    };\n    ```", "```js\n    BarChart.prototype.drawXLabels = function(){\n        var context = this.context;\n        context.save();\n        var data = this.data;\n        var barSpacing = this.width / data.length;\n\n        for (var n = 0; n < data.length; n++) {\n            var label = data[n].label;\n            context.save();\n            context.translate(this.x + ((n + 1 / 2) * barSpacing), this.y + this.height + 10);\n            context.rotate(-1 * Math.PI / 4); // rotate 45 degrees\n            context.font = this.font;\n            context.fillStyle = \"black\";\n            context.textAlign = \"right\";\n            context.textBaseline = \"middle\";\n            context.fillText(label, 0, 0);\n            context.restore();\n        }\n        context.restore();\n    };\n    ```", "```js\n    BarChart.prototype.drawYVAlues = function(){\n        var context = this.context;\n        context.save();\n        context.font = this.font;\n        context.fillStyle = \"black\";\n        context.textAlign = \"right\";\n        context.textBaseline = \"middle\";\n\n        for (var n = 0; n <= this.numGridLines; n++) {\n            var value = this.maxValue - (n * this.gridLineIncrement);\n            var thisY = (n * this.height / this.numGridLines) + this.y;\n            context.fillText(value, this.x - 5, thisY);\n        }\n\n        context.restore();\n    };\n    ```", "```js\n    BarChart.prototype.drawBars = function(){\n        var context = this.context;\n        context.save();\n        var data = this.data;\n        var barSpacing = this.width / data.length;\n        var unitHeight = this.height / this.range;\n\n        for (var n = 0; n < data.length; n++) {\n            var bar = data[n];\n            var barHeight = (data[n].value - this.minValue) * unitHeight;\n\n            /*\n             * if bar height is less than zero, this means that its\n             * value is less than the min value.  Since we don't want to draw\n             * bars below the x-axis, only draw bars whose height is greater\n             * than zero\n             */\n            if (barHeight > 0) {\n                context.save();\n                context.translate(Math.round(this.x + ((n + 1 / 2) * barSpacing)), Math.round(this.y + this.height));\n                /*\n                 * for convenience, we can draw the bars upside down\n                 * starting at the x-axis and then flip\n                 * them back into the correct orientation using\n                 * scale(1, -1).  This is a great example of how\n                 * transformations can help reduce computations\n                 */\n                context.scale(1, -1);\n\n                context.beginPath();\n                context.rect(-this.barWidth / 2, 0, this.barWidth, barHeight);\n                context.fillStyle = this.color;\n                context.fill();\n                context.restore();\n            }\n        }\n        context.restore();\n    };\n    ```", "```js\n    BarChart.prototype.drawGridlines = function(){\n        var context = this.context;\n        context.save();\n        context.strokeStyle = this.gridColor;\n        context.lineWidth = 2;\n\n        // draw y axis grid lines\n        for (var n = 0; n < this.numGridLines; n++) {\n            var y = (n * this.height / this.numGridLines) + this.y;\n            context.beginPath();\n            context.moveTo(this.x, y);\n            context.lineTo(this.x + this.width, y);\n            context.stroke();\n        }\n        context.restore();\n    };\n    ```", "```js\n    BarChart.prototype.drawXAxis = function(){\n        var context = this.context;\n        context.save();\n        context.beginPath();\n        context.moveTo(this.x, this.y + this.height);\n        context.lineTo(this.x + this.width, this.y + this.height);\n        context.strokeStyle = this.axisColor;\n        context.lineWidth = 2;\n        context.stroke();\n        context.restore();\n    };\n    ```", "```js\n    BarChart.prototype.drawYAxis = function(){\n        var context = this.context;\n        context.save();\n        context.beginPath();\n        context.moveTo(this.x, this.y);\n        context.lineTo(this.x, this.height + this.y);\n        context.strokeStyle = this.axisColor;\n        context.lineWidth = 2;\n        context.stroke();\n        context.restore();\n    };\n    ```", "```js\n    window.onload = function(){\n        var data = [{\n            label: \"Eating\",\n            value: 2\n        }, {\n            label: \"Working\",\n            value: 8\n        }, {\n            label: \"Sleeping\",\n            value: 8\n        }, {\n            label: \"Errands\",\n            value: 2\n        }, {\n            label: \"Entertainment\",\n            value: 4\n        }];\n\n        new BarChart({\n            canvasId: \"myCanvas\",\n            data: data,\n            color: \"blue\",\n            barWidth: 50,\n            minValue: 0,\n            maxValue: 10,\n            gridLineIncrement: 2\n        });\n    };\n    ```", "```js\n    <canvas id=\"myCanvas\" width=\"600\" height=\"300\" style=\"border:1px solid black;\">\n    </canvas>\n    ```", "```js\n    function Graph(config){\n        // user defined properties\n        this.canvas = document.getElementById(config.canvasId);\n        this.minX = config.minX;\n        this.minY = config.minY;\n        this.maxX = config.maxX;\n        this.maxY = config.maxY;\n        this.unitsPerTick = config.unitsPerTick;\n        // constants\n        this.axisColor = \"#aaa\";\n        this.font = \"8pt Calibri\";\n        this.tickSize = 20;\n\n        // relationships\n        this.context = this.canvas.getContext(\"2d\");\n        this.rangeX = this.maxX - this.minX;\n        this.rangeY = this.maxY - this.minY;\n        this.unitX = this.canvas.width / this.rangeX;\n        this.unitY = this.canvas.height / this.rangeY;\n        this.centerY = Math.round(Math.abs(this.minY / this.rangeY) * this.canvas.height);\n        this.centerX = Math.round(Math.abs(this.minX / this.rangeX) * this.canvas.width);\n        this.iteration = (this.maxX - this.minX) / 1000;\n        this.scaleX = this.canvas.width / this.rangeX;\n        this.scaleY = this.canvas.height / this.rangeY;\n\n        // draw x and y axis \n        this.drawXAxis();\n        this.drawYAxis();\n    }\n    ```", "```js\n    Graph.prototype.drawXAxis = function(){\n        var context = this.context;\n        context.save();\n        context.beginPath();\n        context.moveTo(0, this.centerY);\n        context.lineTo(this.canvas.width, this.centerY);\n        context.strokeStyle = this.axisColor;\n        context.lineWidth = 2;\n        context.stroke();\n\n        // draw tick marks\n        var xPosIncrement = this.unitsPerTick * this.unitX;\n        var xPos, unit;\n        context.font = this.font;\n        context.textAlign = \"center\";\n        context.textBaseline = \"top\";\n\n        // draw left tick marks\n        xPos = this.centerX - xPosIncrement;\n        unit = -1 * this.unitsPerTick;\n        while (xPos > 0) {\n            context.moveTo(xPos, this.centerY - this.tickSize / 2);\n            context.lineTo(xPos, this.centerY + this.tickSize / 2);\n            context.stroke();\n            context.fillText(unit, xPos, this.centerY + this.tickSize / 2 + 3);\n            unit -= this.unitsPerTick;\n            xPos = Math.round(xPos - xPosIncrement);\n        }\n        // draw right tick marks\n        xPos = this.centerX + xPosIncrement;\n        unit = this.unitsPerTick;\n        while (xPos < this.canvas.width) {\n            context.moveTo(xPos, this.centerY - this.tickSize / 2);\n            context.lineTo(xPos, this.centerY + this.tickSize / 2);\n            context.stroke();\n            context.fillText(unit, xPos, this.centerY + this.tickSize / 2 + 3);\n            unit += this.unitsPerTick;\n            xPos = Math.round(xPos + xPosIncrement);\n        }\n        context.restore();\n    };\n    ```", "```js\n    Graph.prototype.drawYAxis = function(){\n        var context = this.context;\n        context.save();\n        context.beginPath();\n        context.moveTo(this.centerX, 0);\n        context.lineTo(this.centerX, this.canvas.height);\n        context.strokeStyle = this.axisColor;\n        context.lineWidth = 2;\n        context.stroke();\n\n        // draw tick marks  \n        var yPosIncrement = this.unitsPerTick * this.unitY;\n        var yPos, unit;\n        context.font = this.font;\n        context.textAlign = \"right\";\n        context.textBaseline = \"middle\";\n\n        // draw top tick marks\n        yPos = this.centerY - yPosIncrement;\n        unit = this.unitsPerTick;\n        while (yPos > 0) {\n            context.moveTo(this.centerX - this.tickSize / 2, yPos);\n            context.lineTo(this.centerX + this.tickSize / 2, yPos);\n            context.stroke();\n            context.fillText(unit, this.centerX - this.tickSize / 2 - 3, yPos);\n            unit += this.unitsPerTick;\n            yPos = Math.round(yPos - yPosIncrement);\n        }\n\n        // draw bottom tick marks\n        yPos = this.centerY + yPosIncrement;\n        unit = -1 * this.unitsPerTick;\n        while (yPos < this.canvas.height) {\n            context.moveTo(this.centerX - this.tickSize / 2, yPos);\n            context.lineTo(this.centerX + this.tickSize / 2, yPos);\n            context.stroke();\n            context.fillText(unit, this.centerX - this.tickSize / 2 - 3, yPos);\n            unit -= this.unitsPerTick;\n            yPos = Math.round(yPos + yPosIncrement);\n        }\n        context.restore();\n    };\n    ```", "```js\n    Graph.prototype.drawEquation = function(equation, color, thickness){\n        var context = this.context;\n        context.save();\n        context.save();\n        this.transformContext();\n\n        context.beginPath();\n        context.moveTo(this.minX, equation(this.minX));\n\n        for (var x = this.minX + this.iteration; x <= this.maxX; x += this.iteration) {\n            context.lineTo(x, equation(x));\n        }\n\n        context.restore();\n        context.lineJoin = \"round\";\n        context.lineWidth = thickness;\n        context.strokeStyle = color;\n        context.stroke();\n        context.restore();\n    };\n    ```", "```js\n    Graph.prototype.transformContext = function(){\n        var context = this.context;\n\n        // move context to center of canvas\n        this.context.translate(this.centerX, this.centerY);\n\n        /*\n         * stretch grid to fit the canvas window, and\n         * invert the y scale so that increments\n         * as you move upwards\n         */\n        context.scale(this.scaleX, -this.scaleY);\n    };\n    ```", "```js\n    window.onload = function(){\n        var myGraph = new Graph({\n            canvasId: \"myCanvas\",\n            minX: -10,\n            minY: -10,\n            maxX: 10,\n            maxY: 10,\n            unitsPerTick: 1\n        });\n\n        myGraph.drawEquation(function(x){\n            return 5 * Math.sin(x);\n        }, \"green\", 3);\n\n        myGraph.drawEquation(function(x){\n            return x * x;\n        }, \"blue\", 3);\n\n        myGraph.drawEquation(function(x){\n            return 1 * x;\n        }, \"red\", 3);\n    };\n    ```", "```js\n    <canvas id=\"myCanvas\" width=\"600\" height=\"300\" style=\"border:1px solid black;\">\n    </canvas>\n    ```", "```js\n    function LineChart(config){\n        // user defined properties\n        this.canvas = document.getElementById(config.canvasId);\n        this.minX = config.minX;\n        this.minY = config.minY;\n        this.maxX = config.maxX;\n        this.maxY = config.maxY;\n        this.unitsPerTickX = config.unitsPerTickX;\n        this.unitsPerTickY = config.unitsPerTickY;\n\n        // constants\n        this.padding = 10;\n        this.tickSize = 10;\n        this.axisColor = \"#555\";\n        this.pointRadius = 5;\n        this.font = \"12pt Calibri\";\n        /*\n         * measureText does not provide a text height\n         * metric, so we'll have to hardcode a text height\n         * value\n         */\n        this.fontHeight = 12;\n        // relationships  \n        this.context = this.canvas.getContext(\"2d\");\n        this.rangeX = this.maxX - this.minY;\n        this.rangeY = this.maxY - this.minY;\n        this.numXTicks = Math.round(this.rangeX / this.unitsPerTickX);\n        this.numYTicks = Math.round(this.rangeY / this.unitsPerTickY);\n        this.x = this.getLongestValueWidth() + this.padding * 2;\n        this.y = this.padding * 2;\n        this.width = this.canvas.width - this.x - this.padding * 2;\n        this.height = this.canvas.height - this.y - this.padding - this.fontHeight;\n        this.scaleX = this.width / this.rangeX;\n        this.scaleY = this.height / this.rangeY;\n\n        // draw x y axis and tick marks\n        this.drawXAxis();\n        this.drawYAxis();\n    }\n    ```", "```js\n    LineChart.prototype.getLongestValueWidth = function(){\n        this.context.font = this.font;\n        var longestValueWidth = 0;\n        for (var n = 0; n <= this.numYTicks; n++) {\n            var value = this.maxY - (n * this.unitsPerTickY);\n            longestValueWidth = Math.max(longestValueWidth, this.context.measureText(value).width);\n        }\n        return longestValueWidth;\n    };\n    ```", "```js\n    LineChart.prototype.drawXAxis = function(){\n        var context = this.context;\n        context.save();\n        context.beginPath();\n        context.moveTo(this.x, this.y + this.height);\n        context.lineTo(this.x + this.width, this.y + this.height);\n        context.strokeStyle = this.axisColor;\n        context.lineWidth = 2;\n        context.stroke();\n\n        // draw tick marks\n        for (var n = 0; n < this.numXTicks; n++) {\n            context.beginPath();\n            context.moveTo((n + 1) * this.width / this.numXTicks + this.x, this.y + this.height);\n            context.lineTo((n + 1) * this.width / this.numXTicks + this.x, this.y + this.height - this.tickSize);\n            context.stroke();\n        }\n\n        // draw labels\n        context.font = this.font;\n        context.fillStyle = \"black\";\n        context.textAlign = \"center\";\n        context.textBaseline = \"middle\";\n\n        for (var n = 0; n < this.numXTicks; n++) {\n            var label = Math.round((n + 1) * this.maxX / this.numXTicks);\n            context.save();\n            context.translate((n + 1) * this.width / this.numXTicks + this.x, this.y + this.height + this.padding);\n            context.fillText(label, 0, 0);\n            context.restore();\n        }\n        context.restore();\n    };\n    ```", "```js\n    LineChart.prototype.drawYAxis = function(){\n        var context = this.context;\n        context.save();\n        context.save();\n        context.beginPath();\n        context.moveTo(this.x, this.y);\n        context.lineTo(this.x, this.y + this.height);\n        context.strokeStyle = this.axisColor;\n        context.lineWidth = 2;\n        context.stroke();\n        context.restore();\n        // draw tick marks\n        for (var n = 0; n < this.numYTicks; n++) {\n            context.beginPath();\n            context.moveTo(this.x, n * this.height / this.numYTicks + this.y);\n            context.lineTo(this.x + this.tickSize, n * this.height / this.numYTicks + this.y);\n            context.stroke();\n        }\n\n        // draw values\n        context.font = this.font;\n        context.fillStyle = \"black\";\n        context.textAlign = \"right\";\n        context.textBaseline = \"middle\";\n\n        for (var n = 0; n < this.numYTicks; n++) {\n            var value = Math.round(this.maxY - n * this.maxY / this.numYTicks);\n            context.save();\n            context.translate(this.x - this.padding, n * this.height / this.numYTicks + this.y);\n            context.fillText(value, 0, 0);\n            context.restore();\n        }\n        context.restore();\n    };\n    ```", "```js\n    LineChart.prototype.drawLine = function(data, color, width){\n        var context = this.context;\n        context.save();\n        this.transformContext();\n        context.lineWidth = width;\n        context.strokeStyle = color;\n        context.fillStyle = color;\n        context.beginPath();\n        context.moveTo(data[0].x * this.scaleX, data[0].y * this.scaleY);\n\n        for (var n = 0; n < data.length; n++) {\n            var point = data[n];\n\n            // draw segment\n            context.lineTo(point.x * this.scaleX, point.y * this.scaleY);\n            context.stroke();\n            context.closePath();\n            context.beginPath();\n            context.arc(point.x * this.scaleX, point.y * this.scaleY, this.pointRadius, 0, 2 * Math.PI, false);\n            context.fill();\n            context.closePath();\n\n            // position for next segment\n            context.beginPath();\n            context.moveTo(point.x * this.scaleX, point.y * this.scaleY);\n        }\n        context.restore();\n    };\n    ```", "```js\n    LineChart.prototype.transformContext = function(){\n        var context = this.context;\n\n        // move context to center of canvas\n        this.context.translate(this.x, this.y + this.height);\n\n        // invert the y scale so that that increments\n        // as you move upwards\n        context.scale(1, -1);\n    };\n    ```", "```js\n    window.onload = function(){\n        var myLineChart = new LineChart({\n            canvasId: \"myCanvas\",\n            minX: 0,\n            minY: 0,\n            maxX: 140,\n            maxY: 100,\n            unitsPerTickX: 10,\n            unitsPerTickY: 10\n        });\n        var data = [{\n            x: 0,\n            y: 0\n        }, {\n            x: 20,\n            y: 10\n        }, {\n            x: 40,\n            y: 15\n        }, {\n            x: 60,\n            y: 40\n        }, {\n            x: 80,\n            y: 60\n        }, {\n            x: 100,\n            y: 50\n        }, {\n            x: 120,\n            y: 85\n        }, {\n            x: 140,\n            y: 100\n        }];\n\n        myLineChart.drawLine(data, \"blue\", 3);\n\n        var data = [{\n            x: 20,\n            y: 85\n        }, {\n            x: 40,\n            y: 75\n        }, {\n            x: 60,\n            y: 75\n        }, {\n            x: 80,\n            y: 45\n        }, {\n            x: 100,\n            y: 65\n        }, {\n            x: 120,\n            y: 40\n        }, {\n            x: 140,\n            y: 35\n        }];\n\n        myLineChart.drawLine(data, \"red\", 3);\n    };\n    ```", "```js\n    <canvas id=\"myCanvas\" width=\"600\" height=\"300\" style=\"border:1px solid black;\">\n    </canvas>\n    ```"]