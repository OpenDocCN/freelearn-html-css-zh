["```js\n    var WebGL = function(canvasId){\n        this.canvas = document.getElementById(canvasId);\n        this.context = this.canvas.getContext(\"experimental-webgl\");\n        this.stage = undefined;\n\n        // Animation \n        this.t = 0;\n        this.timeInterval = 0;\n        this.startTime = 0;\n        this.lastTime = 0;\n        this.frame = 0;\n        this.animating = false;\n    ```", "```js\n        // provided by Paul Irish\n        window.requestAnimFrame = (function(callback){\n            return window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function(callback){\n                window.setTimeout(callback, 1000 / 60);\n            };\n        })();\n    ```", "```js\n       /*\n       * encapsulte mat3, mat4, and vec3 from\n       * glMatrix globals\n       */\n        this.mat3 = mat3;\n        this.mat4 = mat4;\n     this.vec3 = vec3;\n    ```", "```js\n        // shader type constants\n        this.BLUE_COLOR = \"BLUE_COLOR\";\n        this.VARYING_COLOR = \"VARYING_COLOR\";\n        this.TEXTURE = \"TEXTURE\";\n        this.TEXTURE_DIRECTIONAL_LIGHTING = \"TEXTURE_DIRECTIONAL_LIGHTING\";\n\n        this.shaderProgram = null;\n        this.mvMatrix = this.mat4.create();\n        this.pMatrix = this.mat4.create();\n        this.mvMatrixStack = [];\n        this.context.viewportWidth = this.canvas.width;\n        this.context.viewportHeight = this.canvas.height;\n    ```", "```js\n        // init depth test\n        this.context.enable(this.context.DEPTH_TEST);\n    };\n    ```", "```js\n    WebGL.prototype.getContext = function(){\n        return this.context;\n    };\n\n    WebGL.prototype.getCanvas = function(){\n        return this.canvas;\n    };\n    ```", "```js\n    WebGL.prototype.clear = function(){\n        this.context.viewport(0, 0, this.context.viewportWidth, this.context.viewportHeight);\n        this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n    };\n    ```", "```js\n    WebGL.prototype.setStage = function(func){\n        this.stage = func;\n    };\n    ```", "```js\n    WebGL.prototype.isAnimating = function(){\n        return this.animating;\n    };\n    ```", "```js\n    WebGL.prototype.getFrame = function(){\n        return this.frame;\n    };\n    ```", "```js\n    WebGL.prototype.start = function(){\n        this.animating = true;\n        var date = new Date();\n        this.startTime = date.getTime();\n        this.lastTime = this.startTime;\n\n        if (this.stage !== undefined) {\n            this.stage();\n        }\n\n        this.animationLoop();\n    };\n    ```", "```js\n    WebGL.prototype.stopAnimation = function(){\n        this.animating = false;\n    };\n    ```", "```js\n    WebGL.prototype.getTimeInterval = function(){\n        return this.timeInterval;\n    };\n    ```", "```js\n    WebGL.prototype.getTime = function(){\n        return this.t;\n    };\n    ```", "```js\n    WebGL.prototype.getFps = function(){\n        return this.timeInterval > 0 ? 1000 / this.timeInterval : 0;\n    };\n    ```", "```js\n    WebGL.prototype.animationLoop = function(){\n        var that = this;\n\n        this.frame++;\n        var date = new Date();\n        var thisTime = date.getTime();\n        this.timeInterval = thisTime - this.lastTime;\n        this.t += this.timeInterval;\n        this.lastTime = thisTime;\n\n        if (this.stage !== undefined) {\n            this.stage();\n        }\n\n        if (this.animating) {\n            requestAnimFrame(function(){\n                that.animationLoop();\n            });\n        }\n    };\n    ```", "```js\n    WebGL.prototype.save = function(){\n        var copy = this.mat4.create();\n        this.mat4.set(this.mvMatrix, copy);\n        this.mvMatrixStack.push(copy);\n    };\n    ```", "```js\n    WebGL.prototype.restore = function(){\n        if (this.mvMatrixStack.length == 0) {\n            throw \"Invalid popMatrix!\";\n        }\n        this.mvMatrix = this.mvMatrixStack.pop();\n    };\n    ```", "```js\n    WebGL.prototype.getFragmentShaderGLSL = function(shaderType){\n        switch (shaderType) {\n            case this.BLUE_COLOR:\n                return \"#ifdef GL_ES\\n\" +\n                \"precision highp float;\\n\" +\n                \"#endif\\n\" +\n                \"void main(void) {\\n\" +\n                \"gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\\n\" +\n                \"}\";\n            case this.VARYING_COLOR:\n                return \"#ifdef GL_ES\\n\" +\n                \"precision highp float;\\n\" +\n                \"#endif\\n\" +\n                \"varying vec4 vColor;\\n\" +\n                \"void main(void) {\\n\" +\n                \"gl_FragColor = vColor;\\n\" +\n                \"}\";\n            case this.TEXTURE:\n                return \"#ifdef GL_ES\\n\" +\n                \"precision highp float;\\n\" +\n                \"#endif\\n\" +\n                \"varying vec2 vTextureCoord;\\n\" +\n                \"uniform sampler2D uSampler;\\n\" +\n                \"void main(void) {\\n\" +\n                \"gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\\n\" +\n                \"}\";\n            case this.TEXTURE_DIRECTIONAL_LIGHTING:\n                return \"#ifdef GL_ES\\n\" +\n                \"precision highp float;\\n\" +\n                \"#endif\\n\" +\n                \"varying vec2 vTextureCoord;\\n\" +\n                \"varying vec3 vLightWeighting;\\n\" +\n                \"uniform sampler2D uSampler;\\n\" +\n                \"void main(void) {\\n\" +\n                \"vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\\n\" +\n                \"gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);\\n\" +\n                \"}\";\n        }\n    };\n    ```", "```js\n    WebGL.prototype.getVertexShaderGLSL = function(shaderType){\n        switch (shaderType) {\n            case this.BLUE_COLOR:\n                return \"attribute vec3 aVertexPosition;\\n\" +\n                \"uniform mat4 uMVMatrix;\\n\" +\n                \"uniform mat4 uPMatrix;\\n\" +\n                \"void main(void) {\\n\" +\n                \"gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\\n\" +\n                \"}\";\n            case this.VARYING_COLOR:\n                return \"attribute vec3 aVertexPosition;\\n\" +\n                \"attribute vec4 aVertexColor;\\n\" +\n                \"uniform mat4 uMVMatrix;\\n\" +\n                \"uniform mat4 uPMatrix;\\n\" +\n                \"varying vec4 vColor;\\n\" +\n                \"void main(void) {\\n\" +\n                \"gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\\n\" +\n                \"vColor = aVertexColor;\\n\" +\n                \"}\";\n            case this.TEXTURE:\n                return \"attribute vec3 aVertexPosition;\\n\" +\n                \"attribute vec2 aTextureCoord;\\n\" +\n                \"uniform mat4 uMVMatrix;\\n\" +\n                \"uniform mat4 uPMatrix;\\n\" +\n                \"varying vec2 vTextureCoord;\\n\" +\n                \"void main(void) {\\n\" +\n                \"gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\\n\" +\n                \"vTextureCoord = aTextureCoord;\\n\" +\n                \"}\";\n            case this.TEXTURE_DIRECTIONAL_LIGHTING:\n                return \"attribute vec3 aVertexPosition;\\n\" +\n                \"attribute vec3 aVertexNormal;\\n\" +\n                \"attribute vec2 aTextureCoord;\\n\" +\n                \"uniform mat4 uMVMatrix;\\n\" +\n                \"uniform mat4 uPMatrix;\\n\" +\n                \"uniform mat3 uNMatrix;\\n\" +\n                \"uniform vec3 uAmbientColor;\\n\" +\n                \"uniform vec3 uLightingDirection;\\n\" +\n                \"uniform vec3 uDirectionalColor;\\n\" +\n                \"uniform bool uUseLighting;\\n\" +\n                \"varying vec2 vTextureCoord;\\n\" +\n                \"varying vec3 vLightWeighting;\\n\" +\n                \"void main(void) {\\n\" +\n                \"gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\\n\" +\n                \"vTextureCoord = aTextureCoord;\\n\" +\n                \"if (!uUseLighting) {\\n\" +\n                \"vLightWeighting = vec3(1.0, 1.0, 1.0);\\n\" +\n                \"} else {\\n\" +\n              \"vec3 transformedNormal = uNMatrix * aVertexNormal;\\n\" +\n                \"float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);\\n\" +\n                \"vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;\\n\" +\n                \"}\\n\" +\n                \"}\";\n        }\n    };\n\n    ```", "```js\n    WebGL.prototype.initShaders = function(shaderType){\n        this.initPositionShader();\n\n        switch (shaderType) {\n            case this.VARYING_COLOR:\n                this.initColorShader();\n                break;\n            case this.TEXTURE:\n                this.initTextureShader();\n                break;\n            case this.TEXTURE_DIRECTIONAL_LIGHTING:\n                this.initTextureShader();\n                this.initNormalShader();\n                this.initLightingShader();\n                break;\n        }\n    };\n    ```", "```js\n    WebGL.prototype.setShaderProgram = function(shaderType){\n        var fragmentGLSL = this.getFragmentShaderGLSL(shaderType);\n        var vertexGLSL = this.getVertexShaderGLSL(shaderType);\n\n        var fragmentShader = this.context.createShader(this.context.FRAGMENT_SHADER);\n        this.context.shaderSource(fragmentShader, fragmentGLSL);\n        this.context.compileShader(fragmentShader);\n\n        var vertexShader = this.context.createShader(this.context.VERTEX_SHADER);\n        this.context.shaderSource(vertexShader, vertexGLSL);\n        this.context.compileShader(vertexShader);\n\n        this.shaderProgram = this.context.createProgram();\n        this.context.attachShader(this.shaderProgram, vertexShader);\n        this.context.attachShader(this.shaderProgram, fragmentShader);\n        this.context.linkProgram(this.shaderProgram);\n\n        if (!this.context.getProgramParameter(this.shaderProgram, this.context.LINK_STATUS)) {\n            alert(\"Could not initialize shaders\");\n        }\n\n        this.context.useProgram(this.shaderProgram);\n\n        // once shader program is loaded, it's time to init the shaders\n        this.initShaders(shaderType);\n    };\n    ```", "```js\n    WebGL.prototype.perspective = function(viewAngle, minDist, maxDist){\n        this.mat4.perspective(viewAngle, this.context.viewportWidth / this.context.viewportHeight, minDist, maxDist, this.pMatrix);\n    };\n    ```", "```js\n    WebGL.prototype.identity = function(){\n        this.mat4.identity(this.mvMatrix);\n    };\n    ```", "```js\n    WebGL.prototype.translate = function(x, y, z){\n        this.mat4.translate(this.mvMatrix, [x, y, z]);\n    };\n    ```", "```js\n    WebGL.prototype.rotate = function(angle, x, y, z){\n        this.mat4.rotate(this.mvMatrix, angle, [x, y, z]);\n    };\n    ```", "```js\n    WebGL.prototype.initPositionShader = function(){\n        this.shaderProgram.vertexPositionAttribute = this.context.getAttribLocation(this.shaderProgram, \"aVertexPosition\");\n        this.context.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\n        this.shaderProgram.pMatrixUniform = this.context.getUniformLocation(this.shaderProgram, \"uPMatrix\");\n        this.shaderProgram.mvMatrixUniform = this.context.getUniformLocation(this.shaderProgram, \"uMVMatrix\");\n    };\n    ```", "```js\n    WebGL.prototype.initColorShader = function(){\n        this.shaderProgram.vertexColorAttribute = this.context.getAttribLocation(this.shaderProgram, \"aVertexColor\");\n        this.context.enableVertexAttribArray(this.shaderProgram.vertexColorAttribute);\n    };\n    ```", "```js\n    WebGL.prototype.initTextureShader = function(){\n        this.shaderProgram.textureCoordAttribute = this.context.getAttribLocation(this.shaderProgram, \"aTextureCoord\");\n        this.context.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);\n        this.shaderProgram.samplerUniform = this.context.getUniformLocation(this.shaderProgram, \"uSampler\");\n    };\n    ```", "```js\n    WebGL.prototype.initNormalShader = function(){\n        this.shaderProgram.vertexNormalAttribute = this.context.getAttribLocation(this.shaderProgram, \"aVertexNormal\");\n        this.context.enableVertexAttribArray(this.shaderProgram.vertexNormalAttribute);\n        this.shaderProgram.nMatrixUniform = this.context.getUniformLocation(this.shaderProgram, \"uNMatrix\");\n    };\n    ```", "```js\n    WebGL.prototype.initLightingShader = function(){\n        this.shaderProgram.useLightingUniform = this.context.getUniformLocation(this.shaderProgram, \"uUseLighting\");\n        this.shaderProgram.ambientColorUniform = this.context.getUniformLocation(this.shaderProgram, \"uAmbientColor\");\n        this.shaderProgram.lightingDirectionUniform = this.context.getUniformLocation(this.shaderProgram, \"uLightingDirection\");\n        this.shaderProgram.directionalColorUniform = this.context.getUniformLocation(this.shaderProgram, \"uDirectionalColor\");\n    };\n    ```", "```js\n    WebGL.prototype.initTexture = function(texture){\n        this.context.pixelStorei(this.context.UNPACK_FLIP_Y_WEBGL, true);\n        this.context.bindTexture(this.context.TEXTURE_2D, texture);\n        this.context.texImage2D(this.context.TEXTURE_2D, 0, this.context.RGBA, this.context.RGBA, this.context.UNSIGNED_BYTE, texture.image);\n        this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MAG_FILTER, this.context.NEAREST);\n        this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MIN_FILTER, this.context.LINEAR_MIPMAP_NEAREST);\n        this.context.generateMipmap(this.context.TEXTURE_2D);\n        this.context.bindTexture(this.context.TEXTURE_2D, null);\n    };\n    ```", "```js\n    WebGL.prototype.createArrayBuffer = function(vertices){\n        var buffer = this.context.createBuffer();\n        buffer.numElements = vertices.length;\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, buffer);\n        this.context.bufferData(this.context.ARRAY_BUFFER, new Float32Array(vertices), this.context.STATIC_DRAW);\n        return buffer;\n    };\n    ```", "```js\n    WebGL.prototype.createElementArrayBuffer = function(vertices){\n        var buffer = this.context.createBuffer();\n        buffer.numElements = vertices.length;\n        this.context.bindBuffer(this.context.ELEMENT_ARRAY_BUFFER, buffer);\n        this.context.bufferData(this.context.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertices), this.context.STATIC_DRAW);\n        return buffer;\n    };\n    ```", "```js\n    WebGL.prototype.pushPositionBuffer = function(buffers){\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, buffers.positionBuffer);\n        this.context.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 3, this.context.FLOAT, false, 0, 0);\n    };\n    ```", "```js\n    WebGL.prototype.pushColorBuffer = function(buffers){\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, buffers.colorBuffer);\n        this.context.vertexAttribPointer(this.shaderProgram.vertexColorAttribute, 4, this.context.FLOAT, false, 0, 0);\n    };\n    ```", "```js\n    WebGL.prototype.pushTextureBuffer = function(buffers, texture){\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, buffers.textureBuffer);\n        this.context.vertexAttribPointer(this.shaderProgram.textureCoordAttribute, 2, this.context.FLOAT, false, 0, 0);\n        this.context.activeTexture(this.context.TEXTURE0);\n        this.context.bindTexture(this.context.TEXTURE_2D, texture);\n        this.context.uniform1i(this.shaderProgram.samplerUniform, 0);\n    };\n    ```", "```js\n    WebGL.prototype.pushIndexBuffer = function(buffers){\n        this.context.bindBuffer(this.context.ELEMENT_ARRAY_BUFFER, buffers.indexBuffer);\n    };\n    ```", "```js\n    WebGL.prototype.pushNormalBuffer = function(buffers){\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, buffers.normalBuffer);\n        this.context.vertexAttribPointer(this.shaderProgram.vertexNormalAttribute, 3, this.context.FLOAT, false, 0, 0);\n    };\n    ```", "```js\n    WebGL.prototype.setMatrixUniforms = function(){\n        this.context.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);\n        this.context.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);\n\n        var normalMatrix = this.mat3.create();\n        this.mat4.toInverseMat3(this.mvMatrix, normalMatrix);\n        this.mat3.transpose(normalMatrix);\n        this.context.uniformMatrix3fv(this.shaderProgram.nMatrixUniform, false, normalMatrix);\n    };\n    ```", "```js\n    WebGL.prototype.drawElements = function(buffers){\n        this.setMatrixUniforms();\n\n        // draw elements\n        this.context.drawElements(this.context.TRIANGLES, buffers.indexBuffer.numElements, this.context.UNSIGNED_SHORT, 0);\n    };\n\n    ```", "```js\n    WebGL.prototype.drawArrays = function(buffers){\n        this.setMatrixUniforms();\n\n        // draw arrays\n        this.context.drawArrays(this.context.TRIANGLES, 0, buffers.positionBuffer.numElements / 3);\n    };\n    ```", "```js\n    WebGL.prototype.enableLighting = function(){\n        this.context.uniform1i(this.shaderProgram.useLightingUniform, true);\n    };\n    ```", "```js\n    WebGL.prototype.setAmbientLighting = function(red, green, blue){\n        this.context.uniform3f(this.shaderProgram.ambientColorUniform, parseFloat(red), parseFloat(green), parseFloat(blue));\n    };\n    ```", "```js\n    WebGL.prototype.setDirectionalLighting = function(x, y, z, red, green, blue){\n        // directional lighting\n        var lightingDirection = [x, y, z];\n        var adjustedLD = this.vec3.create();\n        this.vec3.normalize(lightingDirection, adjustedLD);\n        this.vec3.scale(adjustedLD, -1);\n        this.context.uniform3fv(this.shaderProgram.lightingDirectionUniform, adjustedLD);\n\n        // directional color\n        this.context.uniform3f(this.shaderProgram.directionalColorUniform, parseFloat(red), parseFloat(green), parseFloat(blue));\n    };\n\n    ```", "```js\n    <script type=\"text/javascript\" src=\"img/glMatrix-1.0.1.min.js\">\n    </script>\n    <script type=\"text/javascript\" src=\"img/WebGL.js\">\n    </script>\n    ```", "```js\n        function initBuffers(gl){\n            var triangleBuffers = {};\n            triangleBuffers.positionBuffer = gl.createArrayBuffer([\n                0, 1, 0,\n                -1, -1, 0,\n                1, -1, 0\n            ]);\n            return triangleBuffers;\n        }\n    ```", "```js\n        function stage(gl, triangleBuffers){\n            gl.clear();\n            // set field of view at 45 degrees\n            // set viewing range between 0.1 and 100.0 units away.\n            gl.perspective(45, 0.1, 100.0);\n            gl.identity();\n\n            // translate model-view matrix\n            gl.translate(0, 0, -5);\n\n            gl.pushPositionBuffer(triangleBuffers);\n            gl.drawArrays(triangleBuffers);\n        }\n    ```", "```js\n        window.onload = function(){\n            var gl = new WebGL(\"myCanvas\", \"experimental-webgl\");\n            gl.setShaderProgram(\"BLUE_COLOR\");\n            var triangleBuffers = initBuffers(gl);\n            stage(gl, triangleBuffers);\n        };\n    ```", "```js\n            <canvas id=\"myCanvas\" width=\"600\" height=\"250\"\n                style=\"border:1px solid black;\"></canvas>\n    ```", "```js\n    <script type=\"text/javascript\" src=\"img/glMatrix-1.0.1.min.js\">\n    </script>\n    <script type=\"text/javascript\" src=\"img/WebGL.js\">\n    </script>\n    ```", "```js\n        function initBuffers(gl){\n            var triangleBuffers = {};\n            triangleBuffers.positionBuffer = gl.createArrayBuffer([\n                0, 1, 0,\n                -1, -1, 0,\n                1, -1, 0\n            ]);\n\n            return triangleBuffers;\n        }\n    ```", "```js\n        function stage(gl, triangleBuffers, angle){                \n            // set field of view at 45 degrees\n            // set viewing range between 0.1 and 100.0 units away.\n            gl.perspective(45, 0.1, 100.0);\n            gl.identity();\n\n            // translate model-view matrix\n            gl.translate(0, 0, -5);\n            // rotate model-view matrix about y-axis\n            gl.rotate(angle, 0, 1, 0);\n\n            gl.pushPositionBuffer(triangleBuffers);\n            gl.drawArrays(triangleBuffers);\n        }\n    ```", "```js\n        window.onload = function(){\n            var gl = new WebGL(\"myCanvas\", \"experimental-webgl\");\n            gl.setShaderProgram(\"BLUE_COLOR\");\n            var triangleBuffers = initBuffers(gl);\n            var angle = 0;\n\n            gl.setStage(function(){\n                // update angle\n                var angularVelocity = Math.PI / 2; // radians / second\n                var angleEachFrame = angularVelocity * gl.getTimeInterval() / 1000;\n                angle += angleEachFrame;\n\n                this.clear();\n\n                stage(gl, triangleBuffers, angle);\n            });\n            gl.start();\n        };\n    ```", "```js\n            <canvas id=\"myCanvas\" width=\"600\" height=\"250\"\n                style=\"border:1px solid black;\"></canvas>\n    ```", "```js\n    <script type=\"text/javascript\" src=\"img/glMatrix-1.0.1.min.js\">\n    </script>\n    <script type=\"text/javascript\" src=\"img/WebGL.js\">\n    </script>\n    ```", "```js\n        function initBuffers(gl){ \n            var cubeBuffers = {}\n            cubeBuffers.positionBuffer = gl.createArrayBuffer([\n                // Front face\n                -1, -1,  1,\n                 1, -1,  1,\n                 1,  1,  1,\n                -1,  1,  1,\n\n                // Back face\n                -1, -1, -1,\n                -1,  1, -1,\n                 1,  1, -1,\n                 1, -1, -1,\n\n                // Top face\n                -1,  1, -1,\n                -1,  1,  1,\n                 1,  1,  1,\n                 1,  1, -1,\n\n                // Bottom face\n                -1, -1, -1,\n                 1, -1, -1,\n                 1, -1,  1,\n                -1, -1,  1,\n\n                // Right face\n                 1, -1, -1,\n                 1,  1, -1,\n                 1,  1,  1,\n                 1, -1,  1,\n\n                // Left face\n                -1, -1, -1,\n                -1, -1,  1,\n                -1,  1,  1,\n                -1,  1, -1\n            ]);\n\n            // build color Vertices\n            var colors = [\n                [1, 0, 1, 1], // Front face - Pink\n                [0, 1, 0, 1], // Back face - Green\n                [0, 0, 1, 1], // Top face - Blue\n                [0, 1, 1, 1], // Bottom face - Turquoise\n                [1, 1, 0, 1], // Right face - Yellow\n                [1, 0, 0, 1]  // Left face - Red\n            ];\n\n            var colorVertices = [];\n\n            for (var n in colors) {\n                var color = colors[n];\n                for (var i=0; i < 4; i++) {\n                    colorVertices = colorVertices.concat(color);\n                }\n            }\n\n            cubeBuffers.colorBuffer = gl.createArrayBuffer(colorVertices);\n            cubeBuffers.indexBuffer = gl.createElementArrayBuffer([\n                0, 1, 2,      0, 2, 3,    // Front face\n                4, 5, 6,      4, 6, 7,    // Back face\n                8, 9, 10,     8, 10, 11,  // Top face\n                12, 13, 14,   12, 14, 15, // Bottom face\n                16, 17, 18,   16, 18, 19, // Right face\n                20, 21, 22,   20, 22, 23  // Left face\n            ]);\n\n            return cubeBuffers;\n        }\n    ```", "```js\n        function stage(gl, cubeBuffers, angle){         \n            // set field of view at 45 degrees\n            // set viewing range between 0.1 and 100.0 units away.\n            gl.perspective(45, 0.1, 100);\n            gl.identity();\n\n            // translate model-view matrix\n            gl.translate(0, 0, -5);\n            // rotate model-view matrix about x-axis (tilt box downwards)\n            gl.rotate(Math.PI * 0.15, 1, 0, 0);\n            // rotate model-view matrix about y-axis\n            gl.rotate(angle, 0, 1, 0);\n\n            gl.pushPositionBuffer(cubeBuffers);\n            gl.pushColorBuffer(cubeBuffers);\n            gl.pushIndexBuffer(cubeBuffers);\n            gl.drawElements(cubeBuffers);\n        }\n    ```", "```js\n        window.onload = function(){\n            var gl = new WebGL(\"myCanvas\", \"experimental-webgl\");\n            gl.setShaderProgram(\"VARYING_COLOR\");\n            var cubeBuffers = initBuffers(gl);\n            var angle = 0;\n            gl.setStage(function(){\n                // update angle\n                var angularVelocity = Math.PI / 4; // radians / second\n                var angleEachFrame = angularVelocity * this.getTimeInterval() / 1000;\n                angle += angleEachFrame;\n\n                this.clear();\n\n                stage(this, cubeBuffers, angle);\n            });\n            gl.start();\n        };\n    ```", "```js\n            <canvas id=\"myCanvas\" width=\"600\" height=\"250\"\n                style=\"border:1px solid black;\"></canvas>\n    ```", "```js\n    <script type=\"text/javascript\" src=\"img/glMatrix-1.0.1.min.js\">\n    </script>\n    <script type=\"text/javascript\" src=\"img/WebGL.js\">\n    </script>\n    ```", "```js\n        function initBuffers(gl){\n            var cubeBuffers = {};\n            cubeBuffers.positionBuffer = gl.createArrayBuffer([\n                // Front face\n                -1, -1, 1, \n                1, -1, 1, \n                1, 1, 1, \n                -1, 1, 1, \n\n                // Back face\n                -1, -1, -1, \n                -1, 1, -1, \n                1, 1, -1, \n                1, -1, -1, \n\n                // Top face\n                -1, 1, -1, \n                -1, 1, 1, \n                1, 1, 1, \n                1, 1, -1, \n\n                // Bottom face\n                -1, -1, -1, \n                1, -1, -1, \n                1, -1, 1, \n                -1, -1, 1, \n\n                // Right face\n                1, -1, -1, \n                1, 1, -1, \n                1, 1, 1, \n                1, -1, 1, \n\n                // Left face\n                -1, -1, -1, \n                -1, -1, 1, \n                -1, 1, 1, \n                -1, 1, -1\n            ]);\n\n            cubeBuffers.normalBuffer = gl.createArrayBuffer([\n                // Front face\n                 0,  0,  1,\n                 0,  0,  1,\n                 0,  0,  1,\n                 0,  0,  1,\n\n                // Back face\n                 0,  0, -1,\n                 0,  0, -1,\n                 0,  0, -1,\n                 0,  0, -1,\n\n                // Top face\n                 0,  1,  0,\n                 0,  1,  0,\n                 0,  1,  0,\n                 0,  1,  0,\n\n                // Bottom face\n                 0, -1,  0,\n                 0, -1,  0,\n                 0, -1,  0,\n                 0, -1,  0,\n\n                // Right face\n                 1,  0,  0,\n                 1,  0,  0,\n                 1,  0,  0,\n                 1,  0,  0,\n\n                // Left face\n                -1,  0,  0,\n                -1,  0,  0,\n                -1,  0,  0,\n                -1,  0,  0\n            ]);\n\n            cubeBuffers.textureBuffer = gl.createArrayBuffer([ \n                // Front face\n                0, 0, \n                1, 0, \n                1, 1, \n                0, 1, \n\n                // Back face\n                 1, 0, \n                1, 1, \n                0, 1, \n                0, 0, \n\n                // Top face\n                 0, 1, \n                0, 0, \n                1, 0, \n                1, 1, \n\n                // Bottom face\n                 1, 1, \n                0, 1, \n                0, 0, \n                1, 0, \n\n                // Right face\n                 1, 0, \n                1, 1, \n                0, 1, \n                0, 0, \n\n                // Left face\n                 0, 0, \n                1, 0, \n                1, 1, \n                0, 1\n            ]);\n\n            cubeBuffers.indexBuffer = gl.createElementArrayBuffer([\n                 0, 1, 2,         0, 2, 3, // Front face\n                 4, 5, 6,         4, 6, 7, // Back face\n                 8, 9, 10,         8, 10, 11, // Top face\n                 12, 13, 14,     12, 14, 15, // Bottom face\n                 16, 17, 18,     16, 18, 19, // Right face\n                 20, 21, 22,     20, 22, 23 // Left face\n            ]); \n\n            return cubeBuffers;            \n        }\n    ```", "```js\n        function stage(gl, cubeBuffers, crateTexture, angle){\n            // set field of view at 45 degrees\n            // set viewing range between 0.1 and 100 units away.\n            gl.perspective(45, 0.1, 100.0);\n            gl.identity();\n\n            // translate model-view matrix\n            gl.translate(0, 0.0, -5);\n            // rotate model-view matrix about x-axis (tilt box downwards)\n            gl.rotate(Math.PI * 0.15, 1, 0, 0);\n            // rotate model-view matrix about y-axis\n            gl.rotate(angle, 0, 1, 0);\n\n                // enable lighting\n            gl.enableLighting();\n            gl.setAmbientLighting(0.5, 0.5, 0.5);\n            gl.setDirectionalLighting(-0.25, -0.25, -1, 0.8, 0.8, 0.8);\n\n            gl.pushPositionBuffer(cubeBuffers);\n            gl.pushNormalBuffer(cubeBuffers);\n            gl.pushTextureBuffer(cubeBuffers, crateTexture);\n            gl.pushIndexBuffer(cubeBuffers);\n            gl.drawElements(cubeBuffers);\n        }\n    ```", "```js\n        function init(gl, crateTexture){\n            var cubeBuffers = initBuffers(gl);\n            var angle = 0;\n            gl.initTexture(crateTexture);\n            gl.setStage(function(){\n                // update angle\n                var angularVelocity = Math.PI / 4; // radians / second\n                var angleEachFrame = angularVelocity * this.getTimeInterval() / 1000;\n                angle += angleEachFrame;\n                this.clear();\n\n                stage(this, cubeBuffers, crateTexture, angle);\n            });\n            gl.start();\n        }\n    ```", "```js\n        function loadTexture(gl){\n            var crateTexture = gl.getContext().createTexture();\n            crateTexture.image = new Image();\n\n            crateTexture.image.onload = function(){\n                init(gl, crateTexture);\n            };\n            crateTexture.image.src = \"crate.jpg\";\n        }\n    ```", "```js\n        window.onload = function(){\n            var gl = new WebGL(\"myCanvas\", \"experimental-webgl\");\n            gl.setShaderProgram(\"TEXTURE_DIRECTIONAL_LIGHTING\");\n            loadTexture(gl);\n        };\n    ```", "```js\n            <canvas id=\"myCanvas\" width=\"600\" height=\"250\"\n                style=\"border:1px solid black;\"></canvas>\n    ```", "```js\n    <script type=\"text/javascript\" src=\"img/glMatrix-1.0.1.min.js\">\n    </script>\n    <script type=\"text/javascript\" src=\"img/WebGL.js\">\n    </script>\n    ```", "```js\n        /*************************************\n         * Controller\n         */\n        function Controller(){\n            this.view = new View(this);\n            this.gl = new WebGL(\"myCanvas\");\n            this.gl.setShaderProgram(\"TEXTURE_DIRECTIONAL_LIGHTING\");\n            this.model = new Model(this);\n\n            this.attachListeners();\n\n            var sources = {\n                crate: \"crate.jpg\",\n                metalFloor: \"metalFloor.jpg\",\n                metalWall: \"metalWall.jpg\",\n                ceiling: \"ceiling.jpg\"\n            };\n\n            this.mouseDownPos = null;\n            this.mouseDownPitch = 0;\n            this.mouseDownYaw = 0;\n\n            var that = this;\n            this.loadTextures(sources, function(){\n                that.gl.setStage(function(){\n                    that.view.stage();\n                });\n\n                that.gl.start();\n            });\n        }\n    ```", "```js\n        Controller.prototype.loadTextures = function(sources, callback){\n            var gl = this.gl;\n            var context = gl.getContext();\n            var textures = this.model.textures;\n            var loadedImages = 0;\n            var numImages = 0;\n            for (var src in sources) {\n                // anonymous function to induce scope\n                (function(){\n                    var key = src;\n                    numImages++;\n                    textures[key] = context.createTexture();\n                    textures[key].image = new Image();\n                    textures[key].image.onload = function(){\n                        gl.initTexture(textures[key]);\n                        if (++loadedImages >= numImages) {\n                            callback();\n                        }\n                    };\n\n                    textures[key].image.src = sources[key];\n                })();\n            }\n        };\n    ```", "```js\n        Controller.prototype.getMousePos = function(evt){\n            return {\n                x: evt.clientX,\n                y: evt.clientY\n            };\n        };\n    ```", "```js\n        Controller.prototype.handleMouseDown = function(evt){\n            var camera = this.model.camera;\n            this.mouseDownPos = this.getMousePos(evt);\n            this.mouseDownPitch = camera.pitch;\n            this.mouseDownYaw = camera.yaw;\n        };\n    ```", "```js\n        Controller.prototype.handleMouseMove = function(evt){\n            var mouseDownPos = this.mouseDownPos;\n            var gl = this.gl;\n            if (mouseDownPos !== null) {\n                var mousePos = this.getMousePos(evt);\n\n                // update pitch\n                var yDiff = mousePos.y - mouseDownPos.y;\n                this.model.camera.pitch = this.mouseDownPitch + yDiff / gl.getCanvas().height;\n\n                // update yaw\n                var xDiff = mousePos.x - mouseDownPos.x;\n                this.model.camera.yaw = this.mouseDownYaw + xDiff / gl.getCanvas().width;\n            }\n        };\n    ```", "```js\n        Controller.prototype.handleKeyDown = function(evt){\n            var keycode = ((evt.which) || (evt.keyCode));\n            var model = this.model;\n            switch (keycode) {\n                case 37:\n                    // left key\n                    model.sideMovement = model.LEFT;\n                    break;\n                case 38:\n                    // up key\n                    model.straightMovement = model.FORWARD;\n                    break;\n                case 39:\n                    // right key\n                    model.sideMovement = model.RIGHT;\n                    break;\n                case 40:\n                    // down key\n                    model.straightMovement = model.BACKWARD;\n                    break;\n            }\n        };\n    ```", "```js\n        Controller.prototype.handleKeyUp = function(evt){\n            var keycode = ((evt.which) || (evt.keyCode));\n            var model = this.model;\n            switch (keycode) {\n                case 37:\n                    // left key\n                    model.sideMovement = model.STILL;\n                    break;\n                case 38:\n                    // up key\n                    model.straightMovement = model.STILL;\n                    break;\n                case 39:\n                    // right key\n                    model.sideMovement = model.STILL;\n                    break;\n                case 40:\n                    // down key\n                    model.straightMovement = model.STILL;\n                    break;\n            }\n        };\n    ```", "```js\n        Controller.prototype.attachListeners = function(){\n            var gl = this.gl;\n            var that = this;\n            gl.getCanvas().addEventListener(\"mousedown\", function(evt){\n                that.handleMouseDown(evt);\n            }, false);\n\n            gl.getCanvas().addEventListener(\"mousemove\", function(evt){\n                that.handleMouseMove(evt);\n            }, false);\n\n            document.addEventListener(\"mouseup\", function(evt){\n                that.mouseDownPos = null;\n            }, false);\n\n            document.addEventListener(\"mouseout\", function(evt){\n                // same as mouseup functionality\n                that.mouseDownPos = null;\n            }, false);\n\n            document.addEventListener(\"keydown\", function(evt){\n                that.handleKeyDown(evt);\n            }, false);\n\n            document.addEventListener(\"keyup\", function(evt){\n                that.handleKeyUp(evt);\n            }, false);\n        };\n    ```", "```js\n        /*************************************\n         * Model\n         */\n        function Model(controller){\n            this.controller = controller;\n            this.cubeBuffers = {};\n            this.floorBuffers = {};\n            this.wallBuffers = {};\n            this.angle = 0;\n            this.textures = {};\n            this.cratePositions = [];\n\n            // movements\n            this.STILL = \"STILL\";\n            this.FORWARD = \"FORWARD\";\n            this.BACKWARD = \"BACKWARD\";\n            this.LEFT = \"LEFT\";\n            this.RIGHT = \"RIGHT\";\n\n            // camera\n            this.camera = {\n                x: 0,\n                y: 1.5,\n                z: 5,\n                pitch: 0,\n                yaw: 0\n            };\n\n            this.straightMovement = this.STILL;\n            this.sideMovement = this.STILL;\n            this.speed = 8; // units per second    \n            this.initBuffers();\n            this.initCratePositions();\n        }\n    ```", "```js\n        Model.prototype.initCratePositions = function(){\n            var crateRange = 45;\n            // randomize 20 floor crates\n            for (var n = 0; n < 20; n++) {\n                var cratePos = {};\n                cratePos.x = (Math.random() * crateRange * 2) - crateRange;\n                cratePos.y = 0;\n                cratePos.z = (Math.random() * crateRange * 2) - crateRange;\n                cratePos.rotationY = Math.random() * Math.PI * 2;\n                this.cratePositions.push(cratePos);\n\n                if (Math.round(Math.random() * 3) == 3) {\n                    var stackedCratePosition = {};\n                    stackedCratePosition.x = cratePos.x;\n                    stackedCratePosition.y = 2.01;\n                    stackedCratePosition.z = cratePos.z;\n                    stackedCratePosition.rotationY = cratePos.rotationY + ((Math.random() * Math.PI / 8) - Math.PI / 16);\n                    this.cratePositions.push(stackedCratePosition);\n                }\n            }\n        };\n    ```", "```js\n        Model.prototype.initCubeBuffers = function(){\n            var gl = this.controller.gl;\n            this.cubeBuffers.positionBuffer = gl.createArrayBuffer([    \n                -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, // Front face    \n                -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, // Back face    \n                -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, // Top face    \n                -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // Bottom face    \n                1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, // Right face    \n                -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1 // Left face\n            ]);\n\n            this.cubeBuffers.normalBuffer = gl.createArrayBuffer([    \n                0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // Front face    \n                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, // Back face   \n                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // Top face    \n                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // Bottom face    \n                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // Right face    \n                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 // Left face\n            ]);\n\n            this.cubeBuffers.textureBuffer = gl.createArrayBuffer([    \n                0, 0, 1, 0, 1, 1, 0, 1, // Front face   \n                1, 0, 1, 1, 0, 1, 0, 0, // Back face   \n                0, 1, 0, 0, 1, 0, 1, 1, // Top face    \n                1, 1, 0, 1, 0, 0, 1, 0, // Bottom face   \n                1, 0, 1, 1, 0, 1, 0, 0, // Right face    \n                0, 0, 1, 0, 1, 1, 0, 1 // Left face\n            ]);\n\n            this.cubeBuffers.indexBuffer = gl.createElementArrayBuffer([\n                0, 1, 2, 0, 2, 3, // Front face\n                 4, 5, 6, 4, 6, 7, // Back face\n                 8, 9, 10, 8, 10, 11, // Top face\n                 12, 13, 14, 12, 14, 15, // Bottom face\n                 16, 17, 18, 16, 18, 19, // Right face\n                 20, 21, 22, 20, 22, 23 // Left face\n            ]);\n        };\n    ```", "```js\n        Model.prototype.initFloorBuffers = function(){\n            var gl = this.controller.gl;\n            this.floorBuffers.positionBuffer = gl.createArrayBuffer([\n                -50, 0, -50, -50, 0, 50, 50, 0, 50, 50, 0, -50\n            ]);\n\n            this.floorBuffers.textureBuffer = gl.createArrayBuffer([\n                0, 25, 0, 0, 25, 0, 25, 25\n            ]);\n\n            this.floorBuffers.indexBuffer = gl.createElementArrayBuffer([\n                0, 1, 2, 0, 2, 3\n            ]);\n\n            // floor normal points upwards\n            this.floorBuffers.normalBuffer = gl.createArrayBuffer([\n                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0\n            ]);\n        };\n    ```", "```js\n        Model.prototype.initWallBuffers = function(){\n            var gl = this.controller.gl;\n            this.wallBuffers.positionBuffer = gl.createArrayBuffer([\n                -50, 5, 0, 50, 5, 0, 50, -5, 0, -50, -5, 0\n            ]);\n\n            this.wallBuffers.textureBuffer = gl.createArrayBuffer([\n                0, 0, 25, 0, 25, 1.5, 0, 1.5\n            ]);\n\n            this.wallBuffers.indexBuffer = gl.createElementArrayBuffer([\n                0, 1, 2, 0, 2, 3\n            ]);\n\n            // floor normal points upwards\n            this.wallBuffers.normalBuffer = gl.createArrayBuffer([\n                0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1\n            ]);\n        };\n    ```", "```js\n        Model.prototype.initBuffers = function(){\n            this.initCubeBuffers();\n            this.initFloorBuffers();\n            this.initWallBuffers();\n        };\n    ```", "```js\n        Model.prototype.updateCameraPos = function(){\n            var gl = this.controller.gl;\n            if (this.straightMovement != this.STILL) {\n                var direction = this.straightMovement == this.FORWARD ? -1 : 1;\n                var distEachFrame = direction * this.speed * gl.getTimeInterval() / 1000;\n                this.camera.z += distEachFrame * Math.cos(this.camera.yaw);\n                this.camera.x += distEachFrame * Math.sin(this.camera.yaw);\n            }\n\n            if (this.sideMovement != this.STILL) {\n                var direction = this.sideMovement == this.RIGHT ? 1 : -1;\n                var distEachFrame = direction * this.speed * gl.getTimeInterval() / 1000;\n                this.camera.z += distEachFrame * Math.cos(this.camera.yaw + Math.PI / 2);\n                this.camera.x += distEachFrame * Math.sin(this.camera.yaw + Math.PI / 2);\n            }\n        };\n    ```", "```js\n        /*************************************\n         * View\n         */\n        function View(controller){\n            this.controller = controller;\n            this.canvas = document.getElementById(\"myCanvas\");\n            this.canvas.width = window.innerWidth;\n            this.canvas.height = window.innerHeight;\n        }\n    ```", "```js\n        View.prototype.drawFloor = function(){\n            var controller = this.controller;\n            var gl = controller.gl;\n            var model = controller.model;\n            var floorBuffers = model.floorBuffers;\n\n            gl.save();\n            gl.translate(0, -1.1, 0);\n            gl.pushPositionBuffer(floorBuffers);\n            gl.pushNormalBuffer(floorBuffers);\n            gl.pushTextureBuffer(floorBuffers, model.textures.metalFloor);\n            gl.pushIndexBuffer(floorBuffers);\n            gl.drawElements(floorBuffers);\n            gl.restore();\n        };\n    ```", "```js\n        View.prototype.drawCeiling = function(){\n            var controller = this.controller;\n            var gl = controller.gl;\n            var model = controller.model;\n            var floorBuffers = model.floorBuffers;\n\n            gl.save();\n            gl.translate(0, 8.9, 0);\n            // use floor buffers with ceiling texture\n            gl.pushPositionBuffer(floorBuffers);\n            gl.pushNormalBuffer(floorBuffers);\n            gl.pushTextureBuffer(floorBuffers, model.textures.ceiling);\n            gl.pushIndexBuffer(floorBuffers);\n            gl.drawElements(floorBuffers);\n            gl.restore();\n        };\n    ```", "```js\n        View.prototype.drawCrates = function(){\n            var controller = this.controller;\n            var gl = controller.gl;\n            var model = controller.model;\n            var cubeBuffers = model.cubeBuffers;\n\n            for (var n = 0; n < model.cratePositions.length; n++) {\n                gl.save();\n                var cratePos = model.cratePositions[n];\n                gl.translate(cratePos.x, cratePos.y, cratePos.z);\n                gl.rotate(cratePos.rotationY, 0, 1, 0);\n                gl.pushPositionBuffer(cubeBuffers);\n                gl.pushNormalBuffer(cubeBuffers);\n                gl.pushTextureBuffer(cubeBuffers, model.textures.crate);\n                gl.pushIndexBuffer(cubeBuffers);\n                gl.drawElements(cubeBuffers);\n                gl.restore();\n            }\n        };\n    ```", "```js\n        View.prototype.drawWalls = function(){\n            var controller = this.controller;\n            var gl = controller.gl;\n            var model = controller.model;\n            var wallBuffers = model.wallBuffers;\n            var metalWallTexture = model.textures.metalWall;\n\n            gl.save();\n            gl.translate(0, 3.9, -50);\n            gl.pushPositionBuffer(wallBuffers);\n            gl.pushNormalBuffer(wallBuffers);\n            gl.pushTextureBuffer(wallBuffers, metalWallTexture);\n            gl.pushIndexBuffer(wallBuffers);\n            gl.drawElements(wallBuffers);\n            gl.restore();\n\n            gl.save();\n            gl.translate(0, 3.9, 50);\n            gl.rotate(Math.PI, 0, 1, 0);\n            gl.pushPositionBuffer(wallBuffers);\n            gl.pushNormalBuffer(wallBuffers);\n            gl.pushTextureBuffer(wallBuffers, metalWallTexture);\n            gl.pushIndexBuffer(wallBuffers);\n            gl.drawElements(wallBuffers);\n            gl.restore();\n\n            gl.save();\n            gl.translate(50, 3.9, 0);\n            gl.rotate(Math.PI * 1.5, 0, 1, 0);\n            gl.pushPositionBuffer(wallBuffers);\n            gl.pushNormalBuffer(wallBuffers);\n            gl.pushTextureBuffer(wallBuffers, metalWallTexture);\n            gl.pushIndexBuffer(wallBuffers);\n            gl.drawElements(wallBuffers);\n            gl.restore();\n\n            gl.save();\n            gl.translate(-50, 3.9, 0);\n            gl.rotate(Math.PI / 2, 0, 1, 0);\n            gl.pushPositionBuffer(wallBuffers);\n            gl.pushNormalBuffer(wallBuffers);\n            gl.pushTextureBuffer(wallBuffers, metalWallTexture);\n            gl.pushIndexBuffer(wallBuffers);\n            gl.drawElements(wallBuffers);\n            gl.restore();\n        };\n    ```", "```js\n        View.prototype.stage = function(){\n            var controller = this.controller;\n            var gl = controller.gl;\n            var model = controller.model;\n            var view = controller.view;\n            var camera = model.camera;\n            model.updateCameraPos();\n            gl.clear();\n\n            // set field of view at 45 degrees\n            // set viewing range between 0.1 and 100 units away.\n            gl.perspective(45, 0.1, 150.0);\n            gl.identity();\n\n            gl.rotate(-camera.pitch, 1, 0, 0);\n            gl.rotate(-camera.yaw, 0, 1, 0);\n            gl.translate(-camera.x, -camera.y, -camera.z);\n\n            // enable lighting\n            gl.enableLighting();\n            gl.setAmbientLighting(0.5, 0.5, 0.5);\n            gl.setDirectionalLighting(-0.25, -0.25, -1, 0.8, 0.8, 0.8);\n\n            view.drawFloor();\n            view.drawWalls();\n            view.drawCeiling();\n            view.drawCrates();\n        };\n    ```", "```js\n        window.onload = function(){\n            new Controller();\n        };\n    ```", "```js\n            <canvas id=\"myCanvas\" width=\"\" height=\"\">\n            </canvas>\n    ```"]