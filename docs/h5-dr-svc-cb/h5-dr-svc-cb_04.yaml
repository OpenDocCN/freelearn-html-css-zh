- en: Chapter 4. Using HTML5 Input Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用HTML5输入组件
- en: 'In this chapter we will take a look at some of the great new element types
    added to HTML5\. Topics covered are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下HTML5中添加的一些出色的新元素类型。涵盖的主题有：
- en: Using the `text` input field
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`text`输入字段
- en: Using `textarea`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`textarea`
- en: Inputting dates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入日期
- en: Inputting time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入时间
- en: Telephone input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话输入
- en: Range input filed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围输入字段
- en: Color picker input
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色选择器输入
- en: Using single-choice dropdowns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单选下拉菜单
- en: Using multiple-choice select lists
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多选选择列表
- en: Getting geographical location input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取地理位置输入
- en: Using file inputs on client side
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端使用文件输入
- en: Using drag-and-drop file area
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用拖放文件区域
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Forms are part of everyday web application development. We did lot of re-inventions
    to enable various input features. HTML5 adds few new input types and many different
    attributes and extensions to the existing structure. Most of these new stuff are
    already available in modern browsers and make life easier for all of us. For the
    things that are not there yet, we use a fallback that works on legacy systems.
    There is no good reason why you should not start using at least some of the features
    today.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是日常Web应用程序开发的一部分。我们进行了大量的重新发明来启用各种输入功能。HTML5添加了一些新的输入类型以及对现有结构的许多不同属性和扩展。这些新的东西大多已经在现代浏览器中可用，并且使我们所有人的生活更加轻松。对于尚未存在的东西，我们使用在旧系统上运行的备用方案。没有理由您今天不应该开始使用至少其中一些功能。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are various ways to determine support for HTML5 features. Many sites provide
    a list of supported features but some of them worth mentioning are [http://caniuse.com/](http://caniuse.com/)
    and [http://html5please.com/](http://html5please.com/). You can often refer to
    them to get up to date information if you are not interested in adding fallback's.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法来确定对HTML5功能的支持。许多网站提供了支持的功能列表，但其中一些值得一提的是[http://caniuse.com/](http://caniuse.com/)和[http://html5please.com/](http://html5please.com/)。如果您不想添加备用方案，您通常可以参考它们以获取最新信息。
- en: Using the text input field
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文本输入字段
- en: 'We will take a look at one of the basic examples of using input data with HTML
    `<input type="text">`. This input type automatically removes line breaks from
    the input values, so it''s intended for single line text usage as shown in the
    following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下使用HTML `<input type="text">`输入数据的基本示例之一。这种输入类型会自动从输入值中删除换行符，因此适用于单行文本使用，如下面的屏幕截图所示：
- en: '![Using the text input field](img/9282OT_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![使用文本输入字段](img/9282OT_04_01.jpg)'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the body section of the HTML document, we will create a form where the inputs
    with type `text` will be placed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文档的body部分，我们将创建一个表单，其中类型为`text`的输入将被放置：
- en: 'First we add the most basic input type `text`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加最基本的输入类型`text`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Following that, we add one where audio input will be enabled:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个启用音频输入的表单：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also add one with the `placeholder` attribute and one with the `autofocus`
    attribute:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还添加一个带有`placeholder`属性和一个带有`autofocus`属性的输入：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At the end, we add `submit` and close the form:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加`submit`并关闭表单：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `<input name="firstname" type="text" >` element is the most basic HTML
    input element, where on submitting the form, the query parameter will be:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input name="firstname" type="text" >`元素是最基本的HTML输入元素，在提交表单时，查询参数将是：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next input element has an attribute `x-webkit-speech speech` that is, Chrome
    specific attribute allowing speech input, which means you can insert text using
    your microphone.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个输入元素具有一个属性`x-webkit-speech speech`，即Chrome特定属性，允许语音输入，这意味着您可以使用麦克风插入文本。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this will unlikely become standard since it relies on Google server-side
    processing for speech and as such is far from open web. In order to have widespread
    acceptance open speech providers should available.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不太可能成为标准，因为它依赖于谷歌服务器端处理语音，因此远非开放网络。为了获得广泛的接受，应该提供开放的语音提供者。
- en: For the third input element, we used the `placeholder` attribute that adds a
    beautiful hint inside the input field.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个输入元素，我们使用了`placeholder`属性，在输入字段内添加了一个漂亮的提示。
- en: One new attribute added in HTML5 is `autofocus`. It is the Boolean valued attributes
    that allow us to specify what form control should have initial focus once the
    page gets loaded. We used the the single word syntax in our case but `autofocus="true"`
    will do the same trick. An additional thing to note here is that this can be appliqued
    on only one form element since that is the element that will get the initial focus
    and also it cannot be applied to `input` `type="hidden"`, since it does not make
    much sense to do so.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5中添加的一个新属性是`autofocus`。它是一个布尔值属性，允许我们指定页面加载后应该具有初始焦点的表单控件。在我们的情况下，我们使用了单词语法，但`autofocus="true"`也会起到同样的作用。这里需要额外注意的一点是，这只能应用于一个表单元素，因为这是将获得初始焦点的元素，而且它不能应用于`input`
    `type="hidden"`，因为这样做没有太多意义。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we are using our own fallback method for inserting voice data we can simply
    check if there is support for it in the current one in order to support other
    browsers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在使用自己的备用方法来插入语音数据，我们可以简单地检查当前是否支持它，以支持其他浏览器：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is also an event being triggered that we can use for the voice input:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个触发的事件，我们可以用于语音输入：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The open alternative for speech input that is developed is the **Web Speech
    API**. The main goal of it is to provide developers with a means to have speech
    input and output as text to speech. The API definition does not include implementation
    on where the recognition will be done, meaning server-side or client-side implementations
    are up to the vendor. More on the API on [https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html](https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 开发的语音输入的开放替代方案是**Web Speech API**。其主要目标是为开发人员提供一种手段，以便将语音输入和输出作为文本到语音。API定义不包括识别将在何处进行的实现，这意味着服务器端或客户端实现取决于供应商。有关API的更多信息，请访问[https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html](https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html)。
- en: 'The incubator working group that took care of the initial requirements and
    specification regarding speech integration in HTML5 can be found on: [http://www.w3.org/2005/Incubator/htmlspeech/](http://www.w3.org/2005/Incubator/htmlspeech/).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 负责HTML5中关于语音集成的初始要求和规范的孵化工作组可以在以下网址找到：[http://www.w3.org/2005/Incubator/htmlspeech/](http://www.w3.org/2005/Incubator/htmlspeech/)。
- en: Using textarea
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文本区域
- en: In this recipe we will take a look at the `textarea` element and create a simple
    form to show some of the attributes that can be used. `textarea` is intended for
    use as a multiple line plain-text editing control.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看`textarea`元素，并创建一个简单的表单来展示一些可以使用的属性。`textarea`用于作为多行纯文本编辑控件。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an example `form` to demonstrate some of the uses of the `textarea`
    element:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个示例`form`来演示`textarea`元素的一些用法：
- en: 'First we add a `texarea` element with the `placeholder` attribute set:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个带有设置`placeholder`属性的`texarea`元素：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we add a textarea with the `rows` and `cols` attributes set:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个带有设置`rows`和`cols`属性的文本区域：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we add one with `maxlength` set:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个设置了`maxlength`的文本区域：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we add one with the `title` attribute set:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个设置了`title`属性的元素：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally we add `submit` and close the `form`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后我们添加`submit`并关闭`form`：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first example is a regular `<textarea />` element allowing text with multiple
    lines and line breaks. We can additionally use attributes, such as `rows` and
    `cols` to enable some initial size. This can also be achieved by setting initial
    size via CSS:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是一个常规的`<textarea />`元素，允许多行文本和换行。我们还可以使用`rows`和`cols`等属性来启用一些初始大小。这也可以通过CSS设置初始大小来实现：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most of the new browsers now have a small dragable right corner for a text area,
    enabling the user to resize it. This resizability for the text area can be disabled
    by setting `max-width` and `max-height` in CSS.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数新的浏览器都有一个可以拖动的文本区域的小右下角，使用户可以调整大小。可以通过在CSS中设置`max-width`和`max-height`来禁用文本区域的可调整大小。
- en: We can also limit the number of characters that can be inserted using the `maxlength`
    attribute, like setting it to maximum of 5 characters in our example `maxlength="5"`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`maxlength`属性限制可以插入的字符数，例如在我们的示例中将其设置为最多5个字符`maxlength="5"`。
- en: There is also the attribute `title` that can be used to add hint to the user
    about the input filed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`title`属性，可以用来向用户添加有关输入字段的提示。
- en: '![How it works...](img/9282OT_04_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_04_02.jpg)'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Attributes such as `title`, `maxlength`, and `placeholder` are not exclusive
    to `textarea`, but they can be used in other elements as well. For example, the
    `title` attribute is one of the global ones in HTML5 and can be added on any element.
    We could have the flowing snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`title`、`maxlength`和`placeholder`之类的属性不仅适用于`textarea`，还可以用于其他元素。例如，`title`属性是HTML5中的全局属性之一，可以添加到任何元素上。我们可以有以下片段：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: More on the input attributes and the global element attributes can be found
    at the website [http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#global-attributes](http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#global-attributes).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关输入属性和全局元素属性的更多信息，请访问网站[http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#global-attributes](http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#global-attributes)。
- en: Inputting dates
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入日期
- en: Before HTML5 we were forced into creating custom controls that always had some
    missing features or were not compatible with some browsers. Now, there are separate
    input types for dates, and in this recipe we will see how to use them. They are
    unfortunately still not fully implemented across various user agents, but then
    everyone is slowly catching up.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5之前，我们被迫创建自定义控件，这些控件总是缺少一些功能，或者与某些浏览器不兼容。现在，日期有单独的输入类型，在这个示例中我们将看到如何使用它们。不幸的是，它们在各种用户代理中仍然没有完全实现，但是每个人都在慢慢赶上。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will simply create a basic HTML document and create a form in the body element:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地创建一个基本的HTML文档，并在body元素中创建一个表单：
- en: 'First in the body section add `form` and inside it a `date input` element:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在body部分添加`form`，并在其中添加`date input`元素：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly we add an input element for `month` and `week`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们为`month`和`week`添加一个输入元素：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At the end we add a simple `submit` and close the `form`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个简单的`submit`并关闭`form`：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Depending on your browser''s support you will either get an empty input field
    or a full-fledged date input control:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的浏览器支持情况，您将获得一个空的输入字段或一个完整的日期输入控件：
- en: '![How it works...](img/9282OT_04_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_04_03.jpg)'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On form submit, the parameters being sent by the form are valid strings:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单提交时，表单发送的参数是有效的字符串：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The creation and numbering on the dates, weeks, and months is in accordance
    to the ISO 8601 that is widely accepted in most programming languages, or at least
    there is a standardized way of representation and access to the data. There is
    also an option to specify the `min` and `max` attributes that should be valid
    date, month, and week strings accordingly, as well as `step` that will define
    the step of the selection control, and is defaulted to `1`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 日期、周和月的创建和编号符合ISO 8601标准，在大多数编程语言中被广泛接受，或者至少有一种标准化的表示和访问数据的方式。还有一个选项可以指定`min`和`max`属性，这些属性应该是有效的日期、月份和周字符串，以及`step`，它将定义选择控件的步骤，并默认为`1`。
- en: Inputting time
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入时间
- en: 'In this recipe we will take a look at how to use time input controls and how
    they are combined with date selections. The general idea is to have the user agent
    render a clock that can be used as input. There are options to include the time
    zone and to have plain time representation and will try them out by creating a
    simple form as shown in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看如何使用时间输入控件以及它们如何与日期选择结合。总体思路是让用户代理呈现一个可以用作输入的时钟。有选项可以包括时区，并且有纯时间表示，并将通过创建一个简单的表单来尝试它们，如下面的屏幕截图所示：
- en: '![Inputting time](img/9282OT_04_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![输入时间](img/9282OT_04_04.jpg)'
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Similar to the other examples, we create a form containing few input elements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例类似，我们创建一个包含少量输入元素的表单：
- en: 'First we start the form and add the `time` input element:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们开始表单并添加`time`输入元素：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We add a `datetime-local` input:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个`datetime-local`输入：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also we add a `datetime` input:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了一个`datetime`输入：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally we add submit and close the form
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后我们添加提交并关闭表单
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'On form submission, the values selected are added as query parameters in the
    URL, for example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单提交时，所选的值将作为查询参数添加到URL中，例如：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `time` parameter here has a value of `00:00:00`, where the `%3A` is the
    `:` character URL encoded.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`time`参数的值为`00:00:00`，其中`%3A`是URL编码的`:`字符。
- en: Similarly, the `2012-11-02T12%3A00` value for `datetime-local` is actually `2012-11-02T12:00`
    giving the date and time in the parameters following the `YYYY-MM-DDThh:mm:ss`
    pattern.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`datetime-local`的`2012-11-02T12%3A00`值实际上是`2012-11-02T12:00`，遵循`YYYY-MM-DDThh:mm:ss`模式的日期和时间参数。
- en: As for the `datetime` variable the format of the string is `YYYY-MM-DDThh:mm:ssTZD`,
    where we have the additional information about the time zone.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`datetime`变量，字符串的格式为`YYYY-MM-DDThh:mm:ssTZD`，其中我们有关于时区的附加信息。
- en: Since we have a correct context for our input elements, when opened on a browser
    that has good support the control will be optimized.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对输入元素有了正确的上下文，当在具有良好支持的浏览器上打开时，控件将被优化。
- en: '![How it works...](img/9282OT_04_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_04_05.jpg)'
- en: Telephone input
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电话输入
- en: In this recipe, we will take a look at the input type for telephone numbers.
    Due to the very different telephone number formats between countries, the phone
    input does not require any specific pattern, if not explicitly specified. If we
    are required to have some specific pattern, we can do various types of validations
    as discussed in detail in [Chapter 6](ch06.html "Chapter 6. Data Validation"),
    *Data Validation*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看一下电话号码的输入类型。由于不同国家之间的电话号码格式非常不同，因此电话输入不需要任何特定的模式，除非明确指定。如果我们需要一些特定的模式，我们可以进行各种类型的验证，如在[第6章](ch06.html
    "第6章。数据验证")*数据验证*中详细讨论的那样。
- en: The main advantage of using a text input type is to be more semantically correct,
    and as such to bring about more optimization on mobile devices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本输入类型的主要优势在于更具语义，因此可以在移动设备上进行更多优化。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As the preceding related recipes, we simply add the `input` element in the
    body of the HTML document:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面相关的示例一样，我们只需在HTML文档的主体中添加`input`元素：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you try it out on a first look, it seams like it is a regular `input type="text"`
    element. But this one now is more semantically correct. Now why is this important,
    or why should we care about it?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次尝试时，它看起来像是常规的`input type="text"`元素。但这个现在更具语义正确性。现在为什么这很重要，或者为什么我们应该关心它呢？
- en: 'Mobile devices will pick this as a phone number and automatically open the
    numeric keyboard like the Android device displayed in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备将把这个识别为电话号码，并自动打开数字键盘，就像Android设备在下面的屏幕截图中显示的那样：
- en: '![How it works...](img/9282OT_04_06.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_04_06.jpg)'
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are also `input type="url"`, `input type="search"`, and `input type="email"`
    that give semantic to the elements, allowing mobile devices to pick up the correct
    keyboard. They also can have additional validations and logic about how the data
    can be inserted, allowing more type specific functions. Some of them will be covered
    in the validation-related recipes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`input type="url"`，`input type="search"`和`input type="email"`，它们为元素提供语义，允许移动设备选择正确的键盘。它们还可以具有关于数据如何插入的附加验证和逻辑，从而允许更多类型特定的功能。其中一些将在与验证相关的示例中介绍。
- en: 'In HTML5 for all input types, it was added an attribute called `inputmode`
    that is derived from the term **Input modalities**. These attributes provides
    hints to the browser on what kind of keyboard should be used. The attributes can
    have the following values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5中，对于所有输入类型，都添加了一个称为`inputmode`的属性，该属性源自术语**输入模式**。这些属性为浏览器提供了关于应使用何种类型的键盘的提示。这些属性可以具有以下值：
- en: '**verbatim**: This value specifies alphanumeric characters that can commonly
    be used with the intention to be non-prose text such as usernames, keywords, or
    passwords.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**verbatim**：此值指定可以常用于非散文文本的字母数字字符，例如用户名、关键字或密码。'
- en: '**latin**: This value specifies Latin input in the user''s input in the user''s
    preferred language with typing helpers like text prediction on mobile devices.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**latin**：此值指定用户首选语言中的拉丁输入，具有在移动设备上的文本预测等打字助手。'
- en: '**latin-name**: This value specifies same rules as `latin` but for names.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**latin-name**：此值指定与`latin`相同的规则，但用于名称。'
- en: '**latin-prose**: This value specifies the same rules as `latin` but with complete
    typing helpers intended to be used in implementations like email, chat, or comments.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**latin-prose**：此值指定与`latin`相同的规则，但具有完整的打字助手，用于在电子邮件、聊天或评论等实现中使用。'
- en: '**full-width-latin**: This value specifies same as `latin-prose`, but for the
    user''s secondary language.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**full-width-latin**：此值指定与`latin-prose`相同，但用于用户的辅助语言。'
- en: '**kana**, **katakana**: This value specifies **kana** or **romaji** input,
    typically **hiragana** input, using full-width characters, with support for converting
    to **kanji**. As for **katakana**, it is another form related to this. All of
    these are intended for Japanese input text. More about Japanese writing systems
    can be found on: [http://en.wikipedia.org/wiki/Japanese_writing_system](http://en.wikipedia.org/wiki/Japanese_writing_system).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假名**，**片假名**：此值指定**假名**或**罗马字**输入，通常使用全宽字符的**平假名**输入，并支持转换为**汉字**。至于**片假名**，它是与此相关的另一种形式。所有这些都是用于日语输入文本的。有关日语书写系统的更多信息，请访问：[http://en.wikipedia.org/wiki/Japanese_writing_system](http://en.wikipedia.org/wiki/Japanese_writing_system)。'
- en: '**numeric**: This value specifies numeric characters input for digits 0-9 including
    the user-selected thousand separator and character for indicating negative numbers.
    The purpose for this is to input numeric codes, such as some street numbers or
    credit cards. If we are sure that we use numbers the input `type="number"` should
    be preferred, since it is more semantically correct.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**numeric**：此值指定数字字符输入，包括用户选择的千位分隔符和表示负数的字符。其目的是输入数字代码，例如一些街道号码或信用卡。如果我们确定使用数字，应优先使用`type="number"`输入，因为这更语义正确。'
- en: '**tel**, **email**, **url**: This value can be used giving the same hints as
    we have used for the corresponding input types. We should prefer the input types
    in these values.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tel**，**email**，**url**：此值可用于提供与我们为相应输入类型使用的相同提示。我们应该优先使用这些值中的输入类型。'
- en: Browsers don't provide support for all of the states and have a fallback mechanism.
    Again here the states mostly makes sense for mobile or special purpose devices.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器不支持所有状态并具有回退机制。同样，在这里，状态大多对移动设备或特殊用途设备有意义。
- en: Range input field
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围输入字段
- en: We sometimes want to input a value that is something the user picks from a given
    range of values using a "slider". In order to enable this in HTML5 the `<input
    type="range" >` was added allowing imprecise control for setting the element's
    value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望输入一个用户从给定值范围中选择的值，使用“滑块”。为了在HTML5中实现这一点，添加了`<input type="range" >`，允许对元素的值进行不精确的控制。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With few simple steps, we will create few range controls that use different
    features of HTML5:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的步骤，我们将创建几个使用HTML5不同功能的范围控件：
- en: 'We start by adding an HTML page using the following part of the `body` text:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过添加以下部分的`body`文本来添加一个HTML页面：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And in order to show one of the sliders vertically, we can add CSS in the `head`
    tag of HTML:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了垂直显示其中一个滑块，我们可以在HTML的`head`标签中添加CSS：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also display the value that is selected using JavaScript:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用JavaScript显示所选的值：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `type = "range"` is picked up by the browser and the a slider is created
    where the value for `min` is `0` and value for `max` is `100` having a `step`
    of `1`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会捕获`type="range"`，并创建一个值为`0`的`min`和值为`100`的`max`的滑块，步长为`1`。
- en: '![How it works...](img/9282OT_04_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_04_07.jpg)'
- en: 'In order to display it vertically, set width and height using CSS. To make
    it work on Chrome, since the change of rendering via size is not yet implemented,
    you can add the following code in CSS, forcing it to be displayed vertically:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了垂直显示它，使用CSS设置宽度和高度。为了使其在Chrome上工作，由于尚未实现通过大小更改渲染，您可以在CSS中添加以下代码，强制其垂直显示：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we want to have a small display updated directly by changing the slider,
    we can achieve this with JavaScript, by adding an event listener to the input
    range element:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望通过更改滑块直接更新小型显示，我们可以通过JavaScript实现这一点，通过向输入范围元素添加事件侦听器：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is also an option to connect the `input type="range"` element with a
    `datalist` that will create ticks with the predefined options:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选项，可以将`input type="range"`元素与`datalist`连接起来，从而创建具有预定义选项的刻度：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![How it works...](img/9282OT_04_08.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_04_08.jpg)'
- en: The options in the `datalist` element can have invalid values or values outside
    the range that is specified with the attributes min and max, and as such will
    be ignored. On the other hand, the values that are valid will add a marker on
    the slider where they are selectable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`datalist`元素中的选项可以具有无效值或超出使用属性min和max指定的范围的值，因此将被忽略。另一方面，有效的值将在可选择的滑块上添加一个标记。'
- en: '![How it works...](img/9282OT_04_07.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_04_07.jpg)'
- en: There is also an optional `label` attribute to the `datalist` that can be added,
    and should render the text next to the markers displayed. This feature with the
    display of labels is not supported by the browsers, but is part of the specification.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`datalist`还有一个可选的`label`属性，可以添加，并应该在显示的标记旁边呈现文本。浏览器不支持此功能与标签的显示，但它是规范的一部分。'
- en: There 's more...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: At the time of writing, neither Firefox nor IE had full support for the `type="range"`
    element, and as a workaround, we can use JavaScript to add basic support. There
    is already a utility script allowing a workaround available on [http://frankyan.com/labs/html5slider/](http://frankyan.com/labs/html5slider/)
    and source is also available on [https://github.com/html5-ds-book/html5slider](http://
    https://github.com/html5-ds-book/html5slider) slider. In order to enable it, you
    just include the `html5slider.js`, and the magic happens.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Firefox和IE都没有完全支持`type="range"`元素，因此我们可以使用JavaScript添加基本支持。已经有一个实用程序脚本可用于解决此问题，可在[http://frankyan.com/labs/html5slider/](http://frankyan.com/labs/html5slider/)上找到，并且源代码也可在[https://github.com/html5-ds-book/html5slider](http://
    https://github.com/html5-ds-book/html5slider)上找到。为了启用它，只需包含`html5slider.js`，然后魔术就会发生。
- en: Color picker input
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色选择器输入
- en: 'As one of the new input types, we have the the `input type="color"` element,
    which lets you pick a color and the chosen color will have its simple colors representation
    that we are used to. The color representation has a more popular name of hexadecimal
    color representation, and in this recipe, we will see a simple example on how
    to use it by creating a form with color picker:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为新的输入类型之一，我们有`input type="color"`元素，它允许您选择颜色，并且所选颜色将具有我们习惯的简单颜色表示。颜色表示具有更常用的十六进制颜色表示名称，在本教程中，我们将通过创建一个带有颜色选择器的表单来看一个简单的示例：
- en: '![Color picker input](img/9282OT_04_09.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![颜色选择器输入](img/9282OT_04_09.jpg)'
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create a simple form where we will have a color picker added in a form
    that is part of the HTML body:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的表单，其中将添加一个颜色选择器，该表单是HTML主体的一部分：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The color input type gets picked up and the currently selected color is shown.
    On clicking the color, we can select a menu directly from the systems color picking
    control.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色输入类型被选中，并显示当前选定的颜色。单击颜色后，我们可以直接从系统颜色选择控件中选择菜单。
- en: Value selected is represented as a simple color string having a `#` character
    and six character representation that is a case-insensitive hexadecimal string.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所选值表示为一个简单的颜色字符串，其中包含一个`#`字符和一个不区分大小写的十六进制字符串。
- en: 'In case this is not supported in the browser, we can have a custom way of handling
    it. One of the ways to check for the support is to use the `modenrizer.js` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器不支持此功能，我们可以有一种自定义的处理方式。检查支持的一种方法是使用`modenrizer.js`方法：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It allows us to implement a fallback while the other browsers catch up with
    the implementation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们在其他浏览器跟上实现时实施一个回退。
- en: '![How it works...](img/9282OT_04_10.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_04_10.jpg)'
- en: Using single-choice dropdowns
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单选下拉菜单
- en: Single-choice dropdowns are a standard HTML component. Their usage, although
    straightforward, can sometimes be frustrating, both for the developer and the
    user. The browser requires that a "selected" attribute is added to the selected
    item. To set the value of the `select` element programmatically, the code must
    first find the item which is presently selected and remove its "selected" attribute,
    then find the item that has the specified value and add a "selected" attribute
    to it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 单选下拉菜单是标准的HTML组件。它们的使用虽然简单，但有时可能令开发人员和用户感到沮丧。浏览器要求向所选项目添加一个“selected”属性。要以编程方式设置`select`元素的值，代码必须首先找到当前选定的项目并删除其“selected”属性，然后找到具有指定值的项目并向其添加“selected”属性。
- en: However, the developer might want an easier way to specify the value of the
    dropdown field. Simply adding an attribute containing the value should be enough.
    In this recipe, we're going to solve this problem by adding a new attribute to
    dropdowns.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发人员可能希望以更简单的方式指定下拉字段的值。只需添加一个包含值的属性即可。在本示例中，我们将通过向下拉菜单添加一个新属性来解决这个问题。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'We will create an HTML page with a dropdown. In HTML, dropdowns are made with
    a `select` element. To add selection options, we add one or more option elements
    inside the `select` element. Normally, we would specify the pre-selected option
    by adding a selected attribute to it:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个带有下拉菜单的HTML页面。在HTML中，下拉菜单是使用`select`元素制作的。要添加选择选项，我们在`select`元素内添加一个或多个option元素。通常，我们会通过为其添加selected属性来指定预选选项：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, this can be inconvenient to generate on the server side or to generate
    with a template on the client side. More often than not, our list elements are
    static––its just the value that changes. To simplify templating, we can do it
    differently in our `index.html`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这可能不方便在服务器端生成或在客户端使用模板生成。往往情况下，我们的列表元素是静态的，只是值会改变。为了简化模板，我们可以在我们的`index.html`中以不同的方式进行：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then we can set the value in `example.js`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在`example.js`中设置值：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The code in `example.js` runs when the page is loaded. At that point, it finds
    all select elements that have a data-value attribute, and sets the selected option
    using jQuery's versatile function `$.fn.val`. Additionally, it binds a global
    event for all present and future select items that have a data-value attribute,
    which syncs that value to the actual value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.js`中的代码在页面加载时运行。此时，它找到所有具有data-value属性的select元素，并使用jQuery的多功能函数`$.fn.val`设置所选选项。此外，它为所有当前和未来具有data-value属性的select项目绑定了一个全局事件，该事件将该值同步到实际值。'
- en: This is a more natural model for single-choice dropdowns.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单选下拉菜单的更自然模型。
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Its important to note that this code will not work properly with client-side
    generated HTML, which was generated after the page was loaded. To handle this
    case, the `updateDropdowns` method is to be called after new `select` elements
    are added to the page.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，此代码将无法正确处理在页面加载后生成的客户端生成的HTML。要处理这种情况，必须在向页面添加新的`select`元素后调用`updateDropdowns`方法。
- en: Using multiple-choice select lists
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多选选择列表
- en: Select lists can be made to allow users to select multiple elements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 选择列表可以被制作成允许用户选择多个元素。
- en: Multiple-choice select lists have a special serialization model. In this recipe
    we're going to look at how that model works and how to use it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 多选选择列表具有特殊的序列化模型。在本示例中，我们将看看该模型是如何工作的以及如何使用它。
- en: We're going to create a page with a form containing a multiple-choice select
    list. This form will send a `GET` request to another page where we're going to
    extract the selected items via JavaScript.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含多选选择列表的表单页面。该表单将向另一个页面发送`GET`请求，我们将在那里通过JavaScript提取所选项目。
- en: '![Using multiple-choice select lists](img/9282OT_04_11.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![使用多选选择列表](img/9282OT_04_11.jpg)'
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤：
- en: 'Create a basic page with a form that has a multiple select list as shown in
    the following code snippet:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本页面，其中包含一个多选选择列表的表单，如下所示的代码片段：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we will create the page that receives the list and displays the selected
    values as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将创建接收列表并显示所选值的页面如下：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the `example.js` code snippet that displays the result:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是显示结果的`example.js`代码片段：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The address generated by the form submission looks as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表单提交生成的地址如下所示：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This format breaks many assumptions that popular frameworks make about the nature
    of form data. Often they treat form data as a dictionary, where a single name
    has a single value. In this case however, the data can't be put into such a dictionary
    because multi-select lists generate multiple parameters with the same name and
    different values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式打破了许多流行框架对表单数据性质的假设。通常，它们将表单数据视为字典，其中一个名称对应一个值。然而，在这种情况下，数据无法放入这样的字典中，因为多选列表会生成具有相同名称和不同值的多个参数。
- en: Instead, we treat the parameters as a list, which enables us to extract and
    filter both values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将参数视为列表，这使我们能够提取和过滤两个值。
- en: Getting geographical location input
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取地理位置输入
- en: One of the exciting new features in HTML5 is the geolocation API ([http://www.w3.org/TR/geolocation-API/](http://www.w3.org/TR/geolocation-API/)).
    It allows the developer to ask for the user's location. This API allows the developer
    to get geographic coordinates, such as latitude and longitude.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5中一个令人兴奋的新功能是地理位置API（[http://www.w3.org/TR/geolocation-API/](http://www.w3.org/TR/geolocation-API/)）。它允许开发人员请求用户的位置。此API允许开发人员获取地理坐标，如纬度和经度。
- en: Before this API developers had to rely on more crude methods, such as GeoIP
    databases. These methods produced results that had poor accuracy. Depending on
    the user's browser, device, and the availability of GPS on it, the geolocation
    API could give results with a few meters accuracy.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此API之前，开发人员必须依赖更原始的方法，例如GeoIP数据库。这些方法产生的结果精度较低。根据用户的浏览器、设备以及其上的GPS的可用性，地理位置API可以提供几米的精度。
- en: In this recipe, we're going to display the user's location on a map. To do this,
    we're going to use the **Leaflet** library. The use of this library to show maps
    is covered in the *Displaying a map* recipe, [Chapter 2](ch02.html "Chapter 2. Display
    of Graphical Data"), *Display of Graphical Data*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在地图上显示用户的位置。为此，我们将使用**Leaflet**库。使用此库显示地图的方法在*显示地图*一章中有介绍，[第2章](ch02.html
    "第2章. 图形数据的显示")，*图形数据的显示*。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's get started.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'We''re going to create a HTML page with a map placeholder, which will include
    the leaflet library (both CSS and JS files) and our code for getting and displaying
    the user''s location, located in `example.js` as shown in the following code snippet:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个包含地图占位符的HTML页面，其中将包括leaflet库（CSS和JS文件）以及我们用于获取和显示用户位置的代码，位于`example.js`中，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And we''re going to add the following code in `example.js`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将在`example.js`中添加以下代码：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The geolocation API is available through the `geolocation` object that can
    be found in the navigator object. There are multiple methods available, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 地理位置API可通过`navigator`对象中的`geolocation`对象找到。有多种可用方法，如下所示：
- en: '`getCurrentPosition`: This method calls its callback function parameter one
    time after a location is obtained'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCurrentPosition`：此方法在获得位置后调用其回调函数参数一次'
- en: '`watchCurrentPosition`: This method calls its first callback function parameter
    every time the location information is updated and returns a watcher ID'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watchCurrentPosition`：此方法在每次更新位置信息时调用其第一个回调函数参数，并返回一个观察者ID'
- en: '`clearWatch`: This method removes the watch callback by clearing it using our
    returned watcher ID'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearWatch`：此方法通过使用我们返回的观察者ID清除观察回调'
- en: In our example, we use `watchCurrentPosition`, and provide it with a callback,
    which sets the marker's position. The user will first be asked to give the website
    a permission to access his or her location. After the permission is given and
    a location is found, our callback will be called with a position object.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`watchCurrentPosition`，并为其提供一个回调，该回调设置标记的位置。用户将首先被要求允许网站访问他或她的位置。在获得许可并找到位置后，我们的回调将使用位置对象调用。
- en: The position object contains the properties `timestamp` and `coords`. The `coords`
    property is an object containing `latitude` and `longitude` information. The `timestamp`
    property is a UNIX UTC timestamp denoting the time of the location information
    update.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 位置对象包含`timestamp`和`coords`属性。`coords`属性是一个包含`纬度`和`经度`信息的对象。`timestamp`属性是一个UNIX
    UTC时间戳，表示位置信息更新的时间。
- en: There's more...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This example will not work when opened directly as a file. To view the example,
    a local server must be started in the same directory. For more information on
    how to start a local server, see *Appendix, Installing and using http-server*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在直接打开文件时将无法工作。要查看示例，必须在相同目录中启动本地服务器。有关如何启动本地服务器的更多信息，请参见*附录，安装和使用http-server*。
- en: Using file inputs at the client side
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端使用文件输入
- en: HTML has always lacked a convenient method to read the user's files. Before
    HTML5, the only way to access user files on the client side was to use an input
    element of type file, upload that file to the server then send it back to the
    browser.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: HTML一直缺乏一种方便的方法来读取用户的文件。在HTML5之前，客户端访问用户文件的唯一方法是使用文件类型的输入元素，将该文件上传到服务器，然后将其发送回浏览器。
- en: HTML5 brings the ability to read user files locally, inside the user's browser
    using JavaScript code. The implementation is an extension of the functionality
    of a file input element with additional API.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5通过JavaScript代码在用户的浏览器内本地读取用户文件的能力。该实现是文件输入元素功能的扩展，具有额外的API。
- en: In this recipe, we're going to display a text file that is selected by the user
    by using the new HTML5 file API ([http://www.w3.org/TR/FileAPI/](http://www.w3.org/TR/FileAPI/)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用用户选择的新HTML5文件API（[http://www.w3.org/TR/FileAPI/](http://www.w3.org/TR/FileAPI/)）来显示文本文件。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's write the code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码。
- en: 'Create an HTML page with a file `input` field and a content `div` to show the
    contents of the selected file:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含文件`input`字段和内容`div`的HTML页面，以显示所选文件的内容：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then we''re going to add the code to read the selected file in `example.js`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将添加代码来读取`example.js`中选择的文件：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can read the selected file from the input element's files property.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从输入元素的文件属性中读取所选文件。
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To read the contents, we use a `FileReader` object. We need to instantiate
    it, tell it what file to read (and in what way it should read it depending on
    its type), then attach an event listener when the reading completes that will
    access the file contents. This is done as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要读取内容，我们使用`FileReader`对象。我们需要实例化它，告诉它要读取哪个文件（以及根据其类型应该如何读取它），然后在读取完成时附加一个事件侦听器，该事件侦听器将访问文件内容。操作如下：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By the time the `onload` function is called, the variable `f` will change to
    be set to the value of the last file for each of the `onload` calls. To avoid
    this, we capture the variable using an anonymous function pattern.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`onload`函数时，变量`f`将在每个`onload`调用的最后一个文件的值上发生变化。为了避免这种情况，我们使用匿名函数模式捕获变量。
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The listener is called with an event, which in its target property contains
    our result or the text of the whole file.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听器被调用时会传入一个事件，其中目标属性包含我们的结果或整个文件的文本。
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The HTML5 file API consists of two new additions:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5文件API包括两个新添加：
- en: The file input element has a files property which contains a list of the selected
    files.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件输入元素具有一个包含所选文件列表的文件属性。
- en: A new type of object called `FileReader` exists that allows us to read the selected
    files in different ways by using its methods. Among others there are `readAsBinaryString`,
    `readAsText`, `readAsDataURL`, and `readAsArrayBuffer`. It also provides us with
    event listeners, which we can set to get the file contents when it is loaded or
    when an error occurs.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一种称为`FileReader`的新类型对象，它允许我们使用其方法以不同的方式读取所选文件。其中包括`readAsBinaryString`、`readAsText`、`readAsDataURL`和`readAsArrayBuffer`等。它还为我们提供了事件监听器，我们可以设置以在加载文件内容或发生错误时获取文件内容。
- en: To display the text file, we use the reader's `readAsText` property. As a result,
    the file data is provided to the `onload` listener of the reader. The content
    of the file is a simple string that we append to the `div` content inside an element
    that displays preformatted text.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示文本文件，我们使用读取器的`readAsText`属性。结果，文件数据将提供给读取器的`onload`监听器。文件的内容是一个简单的字符串，我们将其附加到显示预格式文本的元素内的`div`内容中。
- en: For retrieving images, we call `readAsDataURL`, and then easily create a new
    image element whose `src` attribute is set to that data URL. Then we add this
    element inside the content `div`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索图像，我们调用`readAsDataURL`，然后轻松地创建一个新的图像元素，其`src`属性设置为该数据URL。然后我们将此元素添加到内容`div`中。
- en: If a folder is selected our recipe will display the entire contents of the folder,
    both text and images.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了一个文件夹，我们的示例将显示文件夹的全部内容，包括文本和图像。
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Its possible to specify filters for the file selection dialog, which limits
    the category of the file. For example, adding `accept="image/*"` will tell the
    browser that the input expects images of any type, while adding `accept="image/jpeg"`
    will tell the browser that the input expects only JPEG images. This filter is
    based on media types. More information about available media types can be found
    at [http://www.iana.org/assignments/media-types](http://www.iana.org/assignments/media-types).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为文件选择对话框指定过滤器，限制文件的类别。例如，添加`accept="image/*"`将告诉浏览器输入期望任何类型的图像，而添加`accept="image/jpeg"`将告诉浏览器输入期望仅JPEG图像。此过滤器基于媒体类型。有关可用媒体类型的更多信息，请访问[http://www.iana.org/assignments/media-types](http://www.iana.org/assignments/media-types)。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although IE9 supports a lot of HTLM5 features, the HTML5 file API is not supported.
    Support was added in IE version 10.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管IE9支持许多HTLM5功能，但不支持HTML5文件API。支持是在IE版本10中添加的。
- en: Using a drag-and-drop file area
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用拖放文件区域
- en: 'With HTML5 we have another alternative for reading user files: we can use drag-and-drop
    areas. Often users find drag-and-drop intuitive and prefer it to other editing
    and manipulation methods.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML5，我们有另一种读取用户文件的选择：我们可以使用拖放区域。通常用户发现拖放直观，并且更喜欢它而不是其他编辑和操作方法。
- en: Drag-and-drop also enable the user to drag elements from a different window
    or tab into ours, meaning they have more uses than regular file upload buttons.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放还使用户能够将元素从不同的窗口或选项卡拖放到我们的窗口中，这意味着它们比常规文件上传按钮具有更多用途。
- en: In this recipe, we're going to make a drag-and-drop area for images. It will
    work both with dragged files and with images dragged from a different window or
    tab.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将为图像创建一个拖放区域。它将同时适用于拖动的文件和从不同窗口或选项卡中拖动的图像。
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the HTML5 drag-and-drop specification can be found at
    [http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有关HTML5拖放规范的更多信息，请访问[http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html)。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写代码。
- en: We're going to create an HTML page with a drop area. To make the area easier
    to drop to, we're going to add some padding, margin, and border to it.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个带有拖放区域的HTML页面。为了使区域更容易放置，我们将为其添加一些填充、边距和边框。
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then we're going to add the code to read the dropped files or images from another
    website in `example.js`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将在`example.js`中添加代码来读取放置的文件或从另一个网站中拖放的图像。
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The default browser action on drop is to navigate to the dropped item. We want
    to prevent this from happening.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放的默认浏览器操作是导航到被放置的项目。我们希望阻止这种情况发生。
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We're going to read images as `DataURL`s and text files as text with our file
    reader.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用文件读取器将图像读取为`DataURL`，将文本文件读取为文本。
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Capturing each file inside a closure allows us to reference it from the a sync
    `onload` callback. There we append it to the content element as shown in the following
    code snippet:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在闭包中捕获每个文件使我们能够从异步`onload`回调中引用它。在那里，我们将其附加到内容元素中，如下面的代码片段所示：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Alternatively, if the item was dragged from a different window or tab, we need
    to read it from the items property. We''re looking for an item of type `text/html`
    as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果项目是从不同的窗口或选项卡拖动的，我们需要从items属性中读取它。我们正在寻找类型为`text/html`的项目，如下所示：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first part of `example.js`, we used the standard HTML5 API. You can read
    more about it in the previous recipe *Using file inputs on the client-side*––in
    short, it allows us to read files as text or `DataURL`s and put them in the document.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在`example.js`的第一部分中，我们使用了标准的HTML5 API。您可以在前一个示例*在客户端使用文件输入*中了解更多信息——简而言之，它允许我们将文件读取为文本或`DataURL`并将其放入文档中。
- en: This part of the code supports both image files and text files.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这一部分支持图像文件和文本文件。
- en: The second part is slightly different and is called only when dragging elements
    or images from a different website. It works on any `draggable` HTML element—this
    element will also be added to our content page as HTML. The image data will not
    be accessible.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分略有不同，仅在从不同网站拖动元素或图像时才会调用。它适用于任何`draggable` HTML元素 - 此元素也将作为HTML添加到我们的内容页面。图像数据将无法访问。
- en: In combination, the API described here is very powerful for use in online rich
    text, UI, or graphic editors. We can combine it with image uploading services
    or with our own panels containing various pre-made elements which we can drop
    inside the drop area.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结合起来，这里描述的API在在线富文本、UI或图形编辑器中非常强大。我们可以将其与图像上传服务或包含各种预制元素的面板结合使用，然后将其拖放到拖放区域内。
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As can be seen in this recipe, the HTML5 drag-and-drop API is not limited to
    just files. By setting the `draggable="true"` attribute, any element on any page
    can be made dragable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在本教程中所看到的，HTML5拖放API不仅限于文件。通过设置`draggable="true"`属性，任何页面上的任何元素都可以被设置为可拖动。
- en: The `dragstart` event will be fired on the `draggable` element as soon as the
    dragging starts. As we move the element over potential drop targets, the `dragenter`,
    `dragover`, and `dragleave` events will be fired. Finally, the `drop` event that
    we used in this recipe is fired when the element is dropped, as well as `dragend`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`dragstart`事件将在拖动开始时立即在`draggable`元素上触发。当我们将元素移动到潜在的放置目标上时，将触发`dragenter`、`dragover`和`dragleave`事件。最后，当元素被放置时，我们在本教程中使用的`drop`事件将被触发，以及`dragend`事件。'
- en: 'Finally, to get fine, programmatic control over the content of the dragged
    object, the `DataTransfer` object can be used. For example, the following `dragStart`
    handler placed on a `draggable` element:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了对拖动对象的内容进行精细的编程控制，可以使用`DataTransfer`对象。例如，可以在`draggable`元素上放置以下`dragStart`处理程序：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: will cause the browser to place the specified HTML content inside the dragged
    object.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将导致浏览器将指定的HTML内容放置在拖动对象内部。
- en: The best feature of custom HTML5 `draggable` elements is the compatibility with
    other applications in the system. Dragable objects can "travel" outside the browser
    into other applications, such as mail clients, image editors, and so on. As a
    result, HTML5 apps are one step closer to becoming first-class citizens inside
    the operating system.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义HTML5 `draggable`元素的最佳功能是与系统中其他应用程序的兼容性。可拖动的对象可以“移动”到浏览器之外的其他应用程序中，例如邮件客户端、图像编辑器等。因此，HTML5应用程序距离成为操作系统内的一流公民又近了一步。
