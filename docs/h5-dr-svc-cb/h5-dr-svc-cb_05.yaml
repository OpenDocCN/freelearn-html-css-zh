- en: Chapter 5. Custom Input Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。自定义输入组件
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using contentEditable for basic rich text input
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 contentEditable 进行基本的富文本输入
- en: Advanced rich text input
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级富文本输入
- en: Creating a drop-down menu
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建下拉菜单
- en: Creating custom dialogs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义对话框
- en: Creating autocomplete for input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为输入创建自动完成
- en: Creating a custom single-selection list
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义单选列表
- en: Creating a multiple-selection list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多选列表
- en: Geographic location input using maps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地图进行地理位置输入
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we presented several different ways for getting input from the user.
    HTML5 offers many new features that enable the functionality of input components
    that was previously done with JavaScript.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们介绍了几种不同的从用户那里获取输入的方法。HTML5 提供了许多新功能，使得以前用 JavaScript 完成的输入组件的功能成为可能。
- en: Often, there comes the need to extend this standard functionality. In this chapter,
    we will see ways for creating some custom input components and using the already
    available ones, where we add additional functions to extend or simplify the end
    user experience.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要扩展这个标准功能。在本章中，我们将看到创建一些自定义输入组件的方法，并使用已有的输入组件，其中我们添加额外的功能以扩展或简化最终用户体验。
- en: Using contentEditable for basic rich text input
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 contentEditable 进行基本的富文本输入
- en: With the new `contentEditable` attribute in HTML5, we can turn every element
    into an editable rich text field. In theory, this could enable us to write complex
    rich text editors that would work right inside the browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML5 中，新的 `contentEditable` 属性使我们可以将每个元素转换为可编辑的富文本字段。理论上，这可以使我们编写在浏览器内部直接工作的复杂富文本编辑器。
- en: Among other things, the new APIs can be used to send editing commands. This
    is done using the `document.execCommand` function, which takes a command string
    as the first argument, and options as the third.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他功能，新的 API 还可以用于发送编辑命令。这是使用 `document.execCommand` 函数完成的，该函数将命令字符串作为第一个参数，选项作为第三个参数。
- en: In practice, every browser vendor implements the interface slightly differently.
    However, most modern browsers are fully compliant.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个浏览器供应商都以稍微不同的方式实现接口。然而，大多数现代浏览器都是完全兼容的。
- en: You can test your browser's compliance at [http://tifftiff.de/contenteditable/compliance_test.html](http://tifftiff.de/contenteditable/compliance_test.html);
    however, the test doesn't take into account the possibility that some browsers
    might act differently on the same command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://tifftiff.de/contenteditable/compliance_test.html](http://tifftiff.de/contenteditable/compliance_test.html)
    上测试您的浏览器的兼容性；然而，该测试并未考虑到一些浏览器可能在相同的命令上有不同的行为。
- en: In this recipe, we're going to make a very simple `contentEditable` field that
    supports few commands (paragraph style, undo/redo, bold/italic/underline, bullets,
    and numbered lists).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个非常简单的 `contentEditable` 字段，支持一些命令（段落样式、撤销/重做、粗体/斜体/下划线、项目符号和编号列表）。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We will create an HTML page with a `contentEditable` div inside.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含 `contentEditable` div 的 HTML 页面。
- en: 'We''re going to add some padding to the div to make it easier to click. Above
    the div, we''re going to place our formatting buttons and a dropdown:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 div 中添加一些填充，以便更容易点击。在 div 上方，我们将放置我们的格式化按钮和一个下拉菜单：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we can make the editing controls work in our `example.js` file:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以让编辑控件在我们的 `example.js` 文件中工作：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''re going to put all our `editCommand` bindings in an object:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把所有的 `editCommand` 绑定放在一个对象中：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we will apply them to the appropriate edit controls:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将它们应用到适当的编辑控件上：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we will define and add additional paragraph styles:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将定义并添加额外的段落样式：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `document.execCommand` function allows us to send commands to the currently
    active `contentEditable` field. These commands work just as toolbar buttons would
    in a regular rich text editor. For example, the command "bold" toggles the boldness
    of the text; applied the second time, it restores the text back to its original
    state. The function takes the following three arguments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.execCommand` 函数允许我们向当前活动的 `contentEditable` 字段发送命令。这些命令的工作方式就像工具栏按钮在常规富文本编辑器中的工作方式一样。例如，命令
    "bold" 切换文本的粗体; 第二次应用时，它将文本恢复到其原始状态。该函数接受以下三个参数：'
- en: '`commandName`: This is the name of the command to execute.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commandName`：这是要执行的命令的名称。'
- en: '`showDefaultUI` (`boolean`): This tells the browser if it should show a default
    user interface related to the command to the user, if such interface is needed.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showDefaultUI`（`boolean`）：这告诉浏览器是否应该向用户显示与命令相关的默认用户界面，如果需要的话。'
- en: '`Value`: This provides an argument for the command that depends on the type
    of the command. For example, bold, italic, and underline takes a `boolean` value.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Value`：这为取决于命令类型的命令提供参数。例如，粗体、斜体和下划线需要一个 `boolean` 值。'
- en: In this recipe, we're not tracking the state at the current selection of cursor.
    We're going to leave that kind of tracking for a recipe where we will create a
    more advanced version of the editor. However, it's worth mentioning here that
    we can use the `document.queryCommandState` function to retrieve the state pertaining
    to the command at the current cursor position (or if there is an active selection
    of the current selection).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们不会跟踪光标当前选择的状态。我们将把这种跟踪留给一个更高级版本的编辑器的示例。然而，值得在这里提到的是，我们可以使用 `document.queryCommandState`
    函数来检索与当前光标位置的命令相关的状态（或者如果当前选择有活动选择）。
- en: Advanced rich text input
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级富文本输入
- en: While the basic `contentEditable`-based rich text input field is sufficient
    in most cases, sometimes it is not enough. We might want to allow the users to
    insert more complex objects such as images and tables.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本的基于 `contentEditable` 的富文本输入字段在大多数情况下足够了，但有时还不够。我们可能希望允许用户插入更复杂的对象，如图片和表格。
- en: In this recipe, we're going to make an advanced rich text editor that supports
    inserting images and basic tables.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个支持插入图片和基本表格的高级富文本编辑器。
- en: We're going to build this editor based on the simple rich text editor demonstrated
    in the *Using contentEditable for basic rich text input* recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于*使用contentEditable进行基本富文本输入*配方中演示的简单富文本编辑器构建此编辑器。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We're going to start with the code from the *Using contentEditable for basic
    rich text input* recipe and improve upon it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*使用contentEditable进行基本富文本输入*配方中的代码开始，并对其进行改进。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's write the code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码。
- en: 'We''re going to take the original `index.html` and `example.js` files but we
    will modify the HTML file. We''re going to add two controls: a table button and
    a file picker to insert images:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用原始的`index.html`和`example.js`文件，但我们将修改HTML文件。我们将添加两个控件：一个表按钮和一个文件选择器来插入图像：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To add tables to our rich text, we will create a new script called `example-table.js`.
    The table button will have dual functionality. One function will be changing the
    number of rows/columns in the currently active table. If there is no active table,
    it will insert a new one with the specified number of rows and columns. The following
    is the code in `example-table.js`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向我们的富文本添加表格，我们将创建一个名为`example-table.js`的新脚本。表按钮将具有双重功能。一个功能将是更改当前活动表中的行/列数。如果没有活动表，它将插入一个具有指定行数和列数的新表。以下是`example-table.js`中的代码：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To add images to our rich text, we will create a new script called `example-image.js`.
    The image picker will insert the user-selected image at the specified position.
    The following is the content of `example-image.js`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向我们的富文本添加图像，我们将创建一个名为`example-image.js`的新脚本。图像选择器将在指定位置插入用户选择的图像。以下是`example-image.js`的内容：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We added two new controls to the editor: the table control and the insert image
    control.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向编辑器添加了两个新控件：表控件和插入图像控件。
- en: The table control asks the user to specify the number of rows and columns first.
    It figures out if the user is currently inside a table by inspecting the parent
    elements of the current cursor position. If a table is found, its content are
    remembered.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表控件要求用户首先指定行数和列数。它通过检查当前光标位置的父元素来确定用户当前是否在表内。如果找到表，则记住其内容。
- en: Afterward, a new table is constructed with the specified number of columns and
    rows. If the old table contained some content at that row/column position, that
    content is copied to the newly constructed cell. Finally, the old table is removed
    if present and the new table is added using the `insertHTML` command.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，将根据指定的列数和行数构建新表。如果旧表在该行/列位置包含一些内容，则将该内容复制到新构建的单元格中。最后，如果存在旧表，则将删除旧表，并使用`insertHTML`命令添加新表。
- en: The image insertion control uses the HTML5 File API for file inputs to read
    image files selected by the user as data URLs. After reading them, it adds them
    to the content using the same `insertHTML` command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图像插入控件使用HTML5文件API用于文件输入，以将用户选择的图像文件读取为数据URL。读取后，它使用相同的`insertHTML`命令将它们添加到内容中。
- en: There's more…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Using this method, it's easy to construct new controls that add any type of
    content to the `contentEditable` field. This enables us to create custom rich
    text or page editors with specialized functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，很容易构建新的控件，将任何类型的内容添加到`contentEditable`字段中。这使我们能够创建具有专业功能的自定义富文本或页面编辑器。
- en: However, if the goal is to add a fully capable generic rich text editor to our
    page, we recommend using one of the many excellent editor components already available,
    such as TinyMCE ([http://www.tinymce.com/](http://www.tinymce.com/)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果目标是向我们的页面添加一个功能齐全的通用富文本编辑器，我们建议使用已经可用的许多优秀的编辑器组件之一，例如TinyMCE（[http://www.tinymce.com/](http://www.tinymce.com/)）。
- en: Creating a drop-down menu
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建下拉菜单
- en: Drop-down menus are often used in web applications to show extended functionality.
    Actions that are used less often or useful to a small number of users can be added
    to the menu, resulting with a cleaner interface.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉菜单经常用于Web应用程序中以显示扩展功能。不经常使用或对少数用户有用的操作可以添加到菜单中，从而使界面更清晰。
- en: HTML5 and CSS3 allow us to build drop-down menus written entirely in CSS. We're
    going to create such a menu in this recipe.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5和CSS3允许我们完全使用CSS编写下拉菜单。我们将在本节中创建这样的菜单。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s analyze the structure of a drop-down menu. A drop-down menu has an activation
    button that displays it and one or more items from the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析下拉菜单的结构。下拉菜单有一个激活按钮，显示它和一个或多个项目如下：
- en: A regular (action) item
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规（操作）项
- en: A separator item
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分隔符项
- en: A submenu item (that activates a sub-menu)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子菜单项（激活子菜单）
- en: Our HTML element structure should reflect the drop-down menu structure. Our
    CSS code will control the positioning and display of the menu.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML元素结构应反映下拉菜单的结构。我们的CSS代码将控制菜单的定位和显示。
- en: We're going to have three buttons showing slightly different, yet structurally
    same, menus.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有三个按钮显示略有不同但结构相同的菜单。
- en: The first will have the default behavior—drops down, is left-aligned with a
    submenu appearing on the right-hand side.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将具有默认行为-下拉，左对齐，并在右侧显示子菜单。
- en: The second will have a modified behavior—right-aligned with a submenu appearing
    on the left-hand side.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个将具有修改后的行为-右对齐，并在左侧显示子菜单。
- en: Finally, the third will have a very different behavior; it will come above the
    button with submenus appearing to the right-hand side, but going up.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个将具有非常不同的行为；它将出现在按钮上方，子菜单出现在右侧，但向上移动。
- en: '![Getting ready](img/9282OT_05_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/9282OT_05_01.jpg)'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: To create the menu, we will use HTML and CSS.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建菜单，我们将使用HTML和CSS。
- en: 'Let''s first create the menu structures in the HTML file. Essentially, it''s
    the same structure discussed previously, copied three times with slight variations
    in styles, particularly on the unordered list elements that contain menus and
    submenus:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在HTML文件中创建菜单结构。基本上，它是之前讨论过的相同结构，复制了三次，但在样式上略有变化，特别是包含菜单和子菜单的无序列表元素：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then let''s add the appropriate CSS for this menu in `example.css`. We''re
    going to use a `border-box` sizing model. Unlike the regular model, where the
    borders and padding are outside the specified dimensions of the element (width
    or height), in the `border-box` model the padding and borders are included in
    the specified dimensions:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后让我们在`example.css`中为这个菜单添加适当的CSS。我们将使用`border-box`的尺寸模型。与常规模型不同，在常规模型中，边框和填充在元素的指定尺寸（宽度或高度）之外，而在`border-box`模型中，填充和边框包括在指定的尺寸中：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re going to add styling to the menu items that display the dropdowns as
    well as the menu itself. By default, the inner menu is absolutely positioned below
    the rest of the content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为显示下拉菜单的菜单项目以及菜单本身添加样式。默认情况下，内部菜单绝对定位在内容的下方：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to make the menu show on hover when the button is active:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮处于活动状态时，我们需要让菜单在悬停时显示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need submenus to be positioned relative to their parent items:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要子菜单相对于其父项目定位：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll set the style of a regular items and a separator item:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将设置常规项目和分隔符项目的样式：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Regular submenus will be positioned slightly differently: in-line with their
    parent item but 90% from the left-hand side:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常规子菜单的定位略有不同：与父项目内联，但距左侧90%：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, we apply the specialized styles for right-aligned and roll-up menus,
    as well as submenus that are bottom-aligned with their parent:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应用专门的样式，用于右对齐和卷起菜单，以及与父菜单底部对齐的子菜单：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: To display our menus dynamically, we use the `hover` and `active` CSS pseudo-selectors.
    They enable us to style elements differently when the cursor is hovering over
    them or when the elements are marked as `active`. Putting the entire menu inside
    the menu item allows us to display it by using these selectors on the menu item.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动态显示菜单，我们使用`hover`和`active` CSS伪选择器。它们使我们能够在光标悬停在元素上或元素被标记为`active`时以不同的样式显示元素。将整个菜单放在菜单项内允许我们通过在菜单项上使用这些选择器来显示它。
- en: To position the menus and submenus, we use a combination of a `position:relative`
    parent menu item and `position:absolute` submenu child items. When we use this
    combination, our child positioning attributes are relative to the first relative
    parent, namely, the item.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定位菜单和子菜单，我们使用`position:relative`的父菜单项目和`position:absolute`的子菜单项目的组合。当我们使用这种组合时，我们的子定位属性是相对于第一个相对父级，即项目。
- en: 'This allows us to place the menu anywhere: below the parent by default or above
    as an option (for submenus, to the right by default, to the left as an option).
    It also allows us to align the submenu any way we like: left by default, right
    as an option (for submenus, top-aligned by default, bottom-aligned as an option).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够将菜单放置在任何位置：默认情况下在父项目下方，或作为选项在上方（对于子菜单，默认情况下在右侧，作为选项在左侧）。它还允许我们以任何我们喜欢的方式对齐子菜单：默认情况下左对齐，作为选项右对齐（对于子菜单，默认情况下顶部对齐，作为选项底部对齐）。
- en: These combinations should allow us to construct menus at arbitrary locations
    without worrying that the menu might go off-screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组合应该使我们能够在任意位置构建菜单，而不必担心菜单可能超出屏幕。
- en: Creating custom dialogs
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义对话框
- en: Custom dialogs can be used for all kinds of user input. We can ask the user
    to fill a form (for example, a login form can be displayed as a dialog). We can
    also use them to ask the user to accept or decline some action that requires immediate
    attention (for example, a dialog asking the user "Are you sure you want to delete
    the selected items?").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义对话框可用于各种用户输入。我们可以要求用户填写表单（例如，登录表单可以显示为对话框）。我们还可以用它们来要求用户接受或拒绝需要立即注意的某些操作（例如，对话框询问用户“您确定要删除所选项目吗？”）。
- en: 'As we can theoretically display any other page segment in a dialog, it would
    be great if we had a single flexible method to do it. The easiest way to attain
    flexibility is to split the dialog into three parts: view, model, and controller.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于理论上我们可以在对话框中显示任何其他页面部分，如果我们有一个灵活的方法来做到这一点，那将是很好的。实现灵活性的最简单方法是将对话框分为三个部分：视图、模型和控制器。
- en: In this recipe, we're going to create a general dialog. It will consist of a
    view (HTML that supports JavaScript templating), a model (available from the template),
    and a list of event bindings that make the controller.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建一个通用对话框。它将包括一个视图（支持JavaScript模板的HTML）、一个模型（从模板中获取）、以及一个使控制器的事件绑定列表。
- en: This is an advanced recipe. If you're not familiar with **Embedded JavaScript
    Templates** (**EJS**), we recommend reading the EJS recipes in [Chapter 9](ch09.html
    "Chapter 9. Client-side Templates"), *Client-side Templates*, before reading this
    recipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高级教程。如果您不熟悉**嵌入式JavaScript模板**（**EJS**），我们建议在阅读本教程之前先阅读[第9章](ch09.html "第9章。客户端模板")中的EJS教程，*客户端模板*。
- en: '![Creating custom dialogs](img/9282OT_05_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义对话框](img/9282OT_05_02.jpg)'
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We're going to use John Resig's simple implementation of EJS-like templates.
    It's a compiler that converts EJS templates to JavaScript functions. We're not
    going to explain the compiler—it's sufficient to know that it takes the ID of
    the element containing the template content and returns a template function. This
    function gives an HTML output when applied to an object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用John Resig的类似EJS模板的简单实现。这是一个将EJS模板转换为JavaScript函数的编译器。我们不打算解释编译器——知道它接受包含模板内容的元素的ID并返回模板函数就足够了。应用于对象时，此函数会产生HTML输出。
- en: 'The following is the template compiler function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模板编译器函数：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The original article explaining JavaScript Micro-Templating can be found at
    [http://ejohn.org/blog/javascript-micro-templating/](http://ejohn.org/blog/javascript-micro-templating/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解释JavaScript微模板的原始文章可以在[http://ejohn.org/blog/javascript-micro-templating/](http://ejohn.org/blog/javascript-micro-templating/)找到。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We're going to write the page code and the dialog library.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写页面代码和对话框库。
- en: 'Let''s create a file named `index.html`. It will contain a secret `div` area
    and a template for a login dialog with the ability to pre-fill `username` and
    the ability to show an error message:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`index.html`的文件。它将包含一个秘密的`div`区域和一个登录对话框的模板，可以预先填充`用户名`并显示错误消息的能力：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To see how we would like the dialog API to work, we''re going to create `example.js`
    next. It will immediately show a login dialog that will close once a correct password
    is input, then the secret content will be shown. Otherwise, an error message will
    be displayed inside the dialog:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看看我们希望对话框API如何工作，接下来我们将创建`example.js`。它将立即显示一个登录对话框，一旦输入正确的密码，对话框将关闭，然后显示秘密内容。否则，对话框内将显示错误消息：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next let''s create `dialog.js`. It should export a function called `dialog`
    that takes three arguments: the ID of the dialog template, the data to fill into
    the template, and an object containing event bindings:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来让我们创建`dialog.js`。它应该导出一个名为`dialog`的函数，该函数接受三个参数：对话框模板的ID，要填充到模板中的数据，以及包含事件绑定的对象：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, build the `dialog` chrome:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建`dialog` chrome：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Fill it with the templated HTML, set the title, and display it:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用模板化的HTML填充它，设置标题，并显示它：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Apply the bindings that are in the `selector => event` format:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用`selector => event`格式的绑定：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build the `dialog` object to return. Provide the `find()` function for fields,
    the `data()`function to extract all form data as a JSON object, as well as event
    binding and close functions:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建要返回的`dialog`对象。提供`find()`函数用于字段，`data()`函数用于提取所有表单数据为JSON对象，以及事件绑定和关闭函数：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we will customize the positioning and style of the dialog in `dialog.css`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在`dialog.css`中自定义对话框的定位和样式。
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To make a flexible dialog library, we split the data needed to show the dialog
    into view, model, and controller.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个灵活的对话框库，我们将显示对话框所需的数据分为视图、模型和控制器。
- en: The `tmpl.js` library provides a function that processes an EJS template using
    the provided model object. The innards of this function are out of the scope of
    this recipe.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpl.js`库提供了一个使用提供的模型对象处理EJS模板的函数。此函数的内部超出了本示例的范围。'
- en: Our `dialog` function constructs a chrome containing a title bar, a Close button,
    and a form. Afterwards, it fills out the form with the template and data. Finally,
    it applies our bindings to the content of this form. The bindings are in the jQuery
    `selector => event` format and can be used to respond to any kind of user input.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`dialog`函数构建了一个包含标题栏、关闭按钮和表单的chrome。然后，它用模板和数据填充表单。最后，它将我们的绑定应用于此表单的内容。绑定采用jQuery的`selector
    => event`格式，可用于响应任何类型的用户输入。
- en: 'This function returns a `dialog` object (constructed in the variable self).
    The object provides the following convenience functions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个`dialog`对象（在变量self中构造）。该对象提供以下便利函数：
- en: '`find`: This allows the user to find elements within the form using selectors'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`：这允许用户使用选择器在表单中查找元素'
- en: '`data`: This extracts all data inputs into the form as an easy-to-use JSON
    object'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这将提取表单中的所有数据输入为易于使用的JSON对象'
- en: '`close`: This closes the dialog'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`：这将关闭对话框'
- en: '`on`: This allows the user to add extra bindings (for example, the `dialog:close`
    event)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on`：这允许用户添加额外的绑定（例如，`dialog:close`事件）'
- en: The object also provides a convenience event named `dialog:close` that gets
    triggered when the dialog is closed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象还提供了一个方便的事件，名为`dialog:close`，当对话框关闭时触发。
- en: 'We style this dialog using `dialog.css`. The dialog is positioned with a pure
    CSS-based positioning method: using fixed-width and negative margins, we avoid
    the need to read the width of the window, and hence manage to fully avoid using
    JS.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dialog.css`样式化这个对话框。对话框的定位采用纯CSS定位方法：使用固定宽度和负边距，我们避免了需要读取窗口宽度的需求，因此完全避免了使用JS。
- en: The flexible templating language allows us to create dialog content of any complexity,
    while the `bindings` syntax allows full control over of all user input. We can
    simplify the creation of some common dialogs by providing the template and some,
    or all, of the bindings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活的模板语言允许我们创建任何复杂度的对话框内容，而`bindings`语法允许完全控制所有用户输入。我们可以通过提供模板和一些或全部绑定来简化创建一些常见对话框。
- en: With this generic method, creating simple message boxes, generic text prompts,
    or complex dialog forms with a variable number of fields are all equally easy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种通用方法，创建简单的消息框、通用文本提示或具有可变数量字段的复杂对话框表单都同样容易。
- en: Creating autocomplete for input
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建输入自动完成
- en: One common functionality usually related to search fields or input is that we
    can guess the text after typing some of the data. This can be any field that we
    have in our database such as employee names. In this recipe, we will take a look
    at some of the possible ways to create autocomplete for input; it is up to you
    to decide what is best fit for your use case.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常与搜索字段或输入相关的一个常见功能是，我们可以在输入一些数据后猜测文本。这可以是我们数据库中的任何字段，比如员工姓名。在这个示例中，我们将看一下创建输入自动完成的一些可能方式；你可以决定什么最适合你的用例。
- en: '![Creating autocomplete for input](img/9282OT_05_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![创建输入自动完成](img/9282OT_05_03.jpg)'
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example we are going to use a sample JSON file that will simulate a
    result returned by a REST API. The file can be retrieved from the examples, and
    it's with the name `countries.json` where we have a list of objects—mapping of
    countries with their corresponding languages. In the example, we will use both
    **jQueryUI** ([http://jqueryui.com/](http://jqueryui.com/)) and a library called
    **Chosen** ([https://github.com/harvesthq/chosen](https://github.com/harvesthq/chosen)).
    Why use both? Well, we can use either of them, or none, but the idea here is to
    show different ways of creating a good user experience with list selection. Additionally,
    as we will be simulating the REST service, we need a server running; more on this
    is available in [Appendix A](apa.html "Appendix A. Installing Node.js and Using
    npm"), *Installing Node.js and Using npm*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一个样本JSON文件，模拟一个REST API返回的结果。该文件可以从示例中检索，文件名为`countries.json`，其中包含一个对象列表——国家与其对应语言的映射。在这个例子中，我们将同时使用**jQueryUI**（[http://jqueryui.com/](http://jqueryui.com/)）和一个名为**Chosen**的库（[https://github.com/harvesthq/chosen](https://github.com/harvesthq/chosen)）。为什么要同时使用两者？嗯，我们可以使用它们中的任何一个，或者都不用，但这里的想法是展示使用列表选择创建良好用户体验的不同方式。另外，由于我们将模拟REST服务，我们需要运行一个服务器；有关更多信息，请参阅[附录A](apa.html
    "附录 A. 安装 Node.js 和使用 npm")，*安装 Node.js 和使用 npm*。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For the example, we will use HTML and accompanying JavaScript and CSS:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用HTML和相应的JavaScript和CSS：
- en: 'We will first start with the `head` section and add the CSS dependencies for
    jQueryUI and Chosen. Also, we add a small CSS section in which we will define
    the size of the single selectors for Chosen:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从`head`部分开始，添加jQueryUI和Chosen的CSS依赖项。此外，我们还将添加一个小的CSS部分，其中我们将定义Chosen的单个选择器的大小：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we can add the body part of the HTML where we will create the form. First,
    we will create a block that will have an input text filed that shall be connected
    to a list of suggested fruits:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加HTML的主体部分，我们将在其中创建表单。首先，我们将创建一个块，其中将有一个输入文本字段，该字段将连接到建议水果的列表：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next input field is for the selection of country, where we will be using
    the Chosen type of selector that will have auto complete as part of the control:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个输入字段是用于选择国家，我们将使用Chosen类型的选择器，该选择器将作为控件的一部分具有自动完成功能：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another input element is for language selection. We are going to make it using
    the JSON data retrieved from the server, or a JSON file in our case. Also, we
    are going to add an input for occupation and a Submit button:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个输入元素用于语言选择。我们将使用从服务器检索的JSON数据，或者在我们的情况下是一个JSON文件。此外，我们将添加一个职业输入和一个提交按钮：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Don''t forget that this block needs to be part of a `form` in order to be submitted.
    One other option is to have the element specify a `form` attribute:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记这个块需要作为`form`的一部分才能提交。另一个选项是让元素指定一个`form`属性：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This sets who is the owner of the given element, allowing us to place the element
    anywhere in the document. The restriction here is that we can have only one form
    for a given element.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将设置给定元素的所有者，允许我们将元素放在文档的任何位置。这里的限制是对于给定元素只能有一个表单。
- en: 'The next part is to include the external vendor JavaScripts for jQuery, jQueryUI
    and Chosen:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是包含jQuery、jQueryUI和Chosen的外部供应商JavaScript：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, we can start the jQuery selections and logic:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以开始jQuery选择和逻辑：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To enable Chosen for elements, we select them and call the plugin directly
    on them; it''s as simple as that:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为元素启用Chosen，我们选择它们并直接在它们上调用插件；就是这么简单：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another option is to use the jQueryUI `autocomplete` plugin. One way is to
    have the data locally, and then apply it on some selection:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个选择是使用jQueryUI的`autocomplete`插件。一种方法是在本地拥有数据，然后将其应用于某些选择：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the configuration of the component, the `source` attribute can accept a list
    of possible string options, and the `minLength` attribute designates the minimal
    number of characters that should be inserted before the autocomplete is triggered.
    The `delay` can be set in milliseconds between a keystroke and a search on the
    source data.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的配置中，`source`属性可以接受可能的字符串选项列表，`minLength`属性指定应在触发自动完成之前插入的最小字符数。`delay`可以设置在按键和对源数据进行搜索之间的毫秒数。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that setting the delay to `low` can create a bad side-effect of making
    a lot requests to the data source.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将延迟设置为“低”可能会导致向数据源发送大量请求的副作用。
- en: 'The data can also be on a remote server and retrieved as source to the plugin
    where some additional filtering can be applied:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据也可以位于远程服务器上，并作为插件的源进行检索，可以应用一些额外的过滤：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The simplest case is one where we use the standard HMTL5 tags in order to get
    autocomplete. There we have the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是使用标准的HMTL5标签来实现自动完成。代码如下：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This `list="fruit"` attribute connects the input filed to the `datalist`. This
    attribute is used to identify a list of predefined options that will be suggested
    to the user.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`list="fruit"`属性将输入字段连接到`datalist`。此属性用于标识将建议给用户的预定义选项列表。'
- en: 'The other option was to use Chosen, a JavaScript plugin that enables user-friendly
    selections. This can be achieved by the following simple HTML:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用Chosen，这是一个使选择更加用户友好的JavaScript插件。可以通过以下简单的HTML实现：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will be picked up by the plugin using jQuery Selector to activate the
    plugin element:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过使用jQuery选择器来激活插件元素：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Chosen will automatically style the selection and add autocomplete, and if we
    have the `data-placeholder` attribute set, it will mimic the standard behavior
    of the HTML5 `placeholder` attributes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Chosen将自动样式化选择并添加自动完成功能，如果设置了`data-placeholder`属性，它将模仿HTML5的`placeholder`属性的标准行为。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, for simplicity, other countries are removed, in practical use cases
    you can use a list of countries defined in ISO 3166-1 ([http://www.iso.org/iso/country_codes.htm](http://www.iso.org/iso/country_codes.htm))
    and the corresponding Wikipedia article [http://en.wikipedia.org/wiki/ISO_3166-1](http://en.wikipedia.org/wiki/ISO_3166-1).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为简单起见，其他国家已被移除，在实际使用情况下，您可以使用ISO 3166-1（[http://www.iso.org/iso/country_codes.htm](http://www.iso.org/iso/country_codes.htm)）中定义的国家列表以及相应的维基百科文章[http://en.wikipedia.org/wiki/ISO_3166-1](http://en.wikipedia.org/wiki/ISO_3166-1)。
- en: 'Another option is to use the jQueryUI autocomplete component. That is why we
    are going to analyze in more detail an example with a server-side data source.
    There are three options to go with:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用jQueryUI自动完成组件。这就是为什么我们将更详细地分析一个带有服务器端数据源的示例。有三种选择：
- en: '**Client-side filtering**: We get the entire JSON document, or any other document
    for that matter, and we filter the data on the client side. This is generally
    a great approach if possible. This might not be the case for every situation.
    The data containing the list could be huge. Consider the autocomplete feature
    on a search engine, the possible result list is huge there.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端过滤**：我们获取整个JSON文档，或者其他任何文档，然后在客户端对数据进行过滤。如果可能的话，这通常是一个很好的方法。但并非所有情况都适用。包含列表的数据可能非常庞大。考虑搜索引擎上的自动完成功能，可能会有大量的可能结果列表。'
- en: '**Server-side filtering**: We get only a portion of the data filtered by some
    query parameter. The filtering is done on the server, making it slower in most
    of the cases. Making additional request adds some additional lagging even if the
    data is returned instantly without doing to much processing, which may not be
    the case.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端过滤**：我们只获取通过某个查询参数过滤的数据的一部分。过滤是在服务器端完成的，在大多数情况下会更慢。即使数据立即返回而不需要太多处理，额外的请求也会增加一些额外的延迟，这可能并非总是如此。'
- en: '**Server-side and client-side filtering**: When working with large datasets,
    a combination of the both methods may be our best way. We could only ask the server
    for more data only if a certain threshold is met.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端和客户端过滤**：在处理大型数据集时，这两种方法的结合可能是我们最好的方法。只有在满足一定的阈值时，我们才能向服务器请求更多的数据。'
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As as side note, it is worth mentioning that if we are creating a search input
    field, it is semantically correct to use the HTML5 `input type="search"`. This
    control enables a single-line input filed and can have the `autosave` attribute
    added to enable the out-of-the-box dropdown of previously searched terms. The
    code would be as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，如果我们创建一个搜索输入字段，使用HTML5的`input type="search"`是语义上正确的。此控件可以启用单行输入字段，并可以添加`autosave`属性以启用预先搜索过的术语的下拉列表。代码如下：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to use the data that is retrieved from the server as the user types,
    we can use a function in the `source` attribute of the configuration:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户输入时使用从服务器检索到的数据，我们可以在配置的`source`属性中使用一个函数：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `request` object, we can get the current data inserted in the `input`
    element via the `request.term` attribute. We can then create a regex matcher if
    we like to filter the data on the client side like in our case, as we always will
    access the same JSON file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`request`对象中，我们可以通过`request.term`属性获取插入`input`元素的当前数据。然后，如果我们想要在客户端过滤数据，我们可以创建一个正则表达式匹配器，就像在我们的情况下一样，因为我们总是访问相同的JSON文件：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, we read the data using an Ajax call to the service:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用Ajax调用服务来读取数据：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Please note that most of the REST API''s have their own functionality for filtering
    usually via `request` parameters, in our case we don''t have that, but to illustrate
    we could easily do something like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数REST API通常都有自己的过滤功能，通常通过`request`参数进行过滤，在我们的情况下，我们没有这样的功能，但是为了说明问题，我们可以很容易地做如下操作：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So the callback function receives the JSON data, but as we get all the data
    unfiltered, we do that using `jQuery.map( arrayOrObject, callback( value, indexOrKey
    ) )` that translates all the items in the new array from the original array of
    objects following the rules defined in the `callback` function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回调函数接收JSON数据，但由于我们获取了所有未经过滤的数据，我们使用`jQuery.map( arrayOrObject, callback(
    value, indexOrKey ) )`来将原始对象数组中的所有项目转换为新数组，遵循`callback`函数中定义的规则。
- en: 'In our case, the JSON has the following format:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，JSON的格式如下：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In order to filter the data using the `language` names, we should return a
    sublist of those objects that match our criteria defined in the `matcher`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`language`名称过滤数据，我们应该返回与我们在`matcher`中定义的条件匹配的对象子列表：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You may notice that the result returned has the `label` and `value` properties;
    this is because it is one of the possible formats for the `source` where we have
    an array of objects like these.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到返回的结果具有`label`和`value`属性；这是`source`的可能格式之一，其中我们有一个这样的对象数组。
- en: If we are to compare the jQueryUI method of handing data versus the Chosen library,
    we can conclude that jQueryUI is more flexible when working with different data
    sources. On the other hand, Chosen, in a way, just styles the standard HTML elements
    and is more compliant than doing clever hacks. Additionally, Chosen is very focused
    on doing few things very nicely, and makes a great user experience while not having
    the baggage that comes with a size-heavy library such as jQueryUI.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要比较jQueryUI处理数据的方法与Chosen库，我们可以得出结论，jQueryUI在处理不同数据源时更灵活。另一方面，Chosen在某种程度上只是为标准的HTML元素添加样式，比使用巧妙的技巧更加符合规范。此外，Chosen非常专注于做一些非常好的事情，并且在不具有jQueryUI这样体积庞大的库所带来的负担的情况下提供了出色的用户体验。
- en: There's more...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `list` attribute can be used on all input types except for `hidden`, `checkbox`,
    `radio`, `file`, or `button` types where it gets ignored. When you think about
    it, it makes a lot sense not to work those types because there is not much practical
    use in having autocomplete on them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`属性可以用于除`hidden`、`checkbox`、`radio`、`file`或`button`类型之外的所有输入类型，这些类型会被忽略。仔细想想，不在这些类型上工作是有道理的，因为在它们上面使用自动完成并没有太多实际用途。'
- en: 'If we need to have the same behavior on older browsers, or to have a fallback
    mode, we can place that content in the `datalist` element:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在旧版浏览器上具有相同的行为，或者需要回退模式，我们可以将该内容放在`datalist`元素中：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This data will not be displayed if the `datalist` element is supported, enabling
    us to add support for legacy browsers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果支持`datalist`元素，这些数据将不会显示，从而使我们能够为旧版浏览器添加支持。
- en: There are various other data sources that can be used with jQueryUI autocomplete,
    such as JSONP or XML, for example.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他各种数据源可以与jQueryUI自动完成一起使用，例如JSONP或XML。
- en: Creating a custom single-selection list
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义单选列表
- en: In the previous recipe, we used Chosen. In this recipe, we will take a deeper
    look into the creation of simple select boxes, making one the most user-friendly
    way pickers out there.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了Chosen。在这个示例中，我们将更深入地了解创建简单选择框的过程，使其成为最用户友好的选择器之一。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use Chosen ([https://github.com/harvesthq/chosen](https://github.com/harvesthq/chosen))
    and its dependency jQuery by adding them from a CDN.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Chosen ([https://github.com/harvesthq/chosen](https://github.com/harvesthq/chosen))及其依赖项jQuery，通过从CDN添加它们。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We create an HTML file and the accompanying JavaScript code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个HTML文件和相应的JavaScript代码：
- en: 'First, we will start with the head section of the HTML, where we will include
    the Chosen CSS style:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从HTML的head部分开始，包括Chosen的CSS样式：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are going to create a simple form where the user can select their favorite
    programming language and job title. To do that, we add `select` elements with
    several available options:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的表单，用户可以在其中选择他们最喜欢的编程语言和职位。为此，我们添加了带有多个可用选项的`select`元素：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The possible options can be grouped using the `optgroup` element:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`optgroup`元素对可能的选项进行分组：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And at last, we just add a simple submit for the form:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需为表单添加一个简单的提交：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In order to include Chosen, we add their implementation from a CDN:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了包含Chosen，我们从CDN添加它们的实现：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To designate to what element should have Chosen applied, we use jQuery selection:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了指定应该应用Chosen的元素，我们使用jQuery选择：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The best thing about Chosen is its simplicity; we just select the elements
    with jQuery and apply the plugin. There is an option allowing deselect that we
    can enable during creation of these kind of elements:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Chosen最好的地方在于它的简单性；我们只需使用jQuery选择元素并应用插件。有一个允许取消选择的选项，我们可以在创建这种元素时启用它：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Chosen can be used with **Prototype JS** instead of jQuery; there
    the selection of elements would be `new Chosen(someElement);`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Chosen可以与**Prototype JS**一起使用，而不是jQuery；在那里，元素的选择将是`new Chosen(someElement);`。
- en: Also, we can add an attribute named `data-placeholder` that will contain default
    text, such as `Occupation`, as in our example. If this is not specified, it will
    default to `Select Some Option` for single select.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以添加一个名为`data-placeholder`的属性，其中包含默认文本，例如我们的示例中的`Occupation`。如果未指定，单选默认为`Select
    Some Option`。
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: On `select` elements, the browser assumes the first element to be selected if
    `selectedIndex` is not specified or if there is no option with the `selected`
    attribute. In order to allow none selected, we can set the first option blank,
    thus enabling the `data-placeholder` text support.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`select`元素，如果未指定`selectedIndex`或没有带有`selected`属性的选项，浏览器会假定第一个元素被选中。为了允许未选择任何选项，我们可以将第一个选项设置为空，从而启用`data-placeholder`文本支持。
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you need to use data for the options that will change after the initial
    creation of Chosen, you can update the component dynamically and then trigger
    the `liszt:updated` event on the selected field. The `liszt:updated` event is
    a Chosen-specific internal event. Chosen, after calling the event, will rebuild
    the list based on the updated content. For example, on an element with ID as `countries`,
    the triggering would be as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要使用在Chosen初始创建后会更改的选项数据，您可以动态更新组件，然后在所选字段上触发`liszt:updated`事件。`liszt:updated`事件是Chosen特定的内部事件。调用事件后，Chosen将根据更新的内容重新构建列表。例如，在ID为`countries`的元素上，触发将如下所示：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Creating a multiple-selection list
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多选列表
- en: Chosen can be used to create beautiful-looking multiple selections. In this
    recipe, we will create a form for a menu ordering that uses this type of selections
    in a form.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Chosen可以用于创建漂亮的多选项。在这个示例中，我们将创建一个菜单订购表单，其中使用了这种类型的选择。
- en: '![Creating a multiple-selection list](img/9282OT_05_04.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![创建多选列表](img/9282OT_05_04.jpg)'
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will contain the same parts as *Creating a custom single-selection
    list*, and build upon them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将包含与*创建自定义单选列表*相同的部分，并在此基础上构建。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start by having the same base as *Creating a custom single-selection list*,
    and add the following parts:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要有与*创建自定义单选列表*相同的基础，并添加以下部分：
- en: 'First, we add the selections that will have the `drop-down` CSS class we created
    in the head section:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加将具有我们在head部分创建的`drop-down`CSS类的选择：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can also use grouping of the options for the `select` element having sections,
    such as `Starters` and `Pizza`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以对`select`元素的选项进行分组，如`Starters`和`Pizza`：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Simply select all elements that have the `drop-down` CSS class and enable Chosen
    for them:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需选择所有具有`drop-down`CSS类的元素，并为它们启用Chosen：
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Painless setup is one of the main features for Chosen so the JavaScript part
    is fairly simple because we only have a basic selection of elements. Options can
    be selected before the page is rendered to the user by having the `selected` attribute
    on options, such as `Mojito`. They can also be disabled from selection by using
    the `disabled` attribute, so in our case, the option `Long Island Iced Tea` will
    not appear in the selection.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Chosen的一个主要特点是轻松设置，因此JavaScript部分非常简单，因为我们只有基本的元素选择。可以通过在选项上使用`selected`属性在页面呈现给用户之前选择选项，例如`Mojito`。它们也可以通过使用`disabled`属性禁用选择，因此在我们的情况下，选项`Long
    Island Iced Tea`将不会出现在选择中。
- en: Optgroups, selected states, multiple attributes, as well as other attributes
    are respected just like the standard HTML5 behavior. This means that we are not
    required to expect something special or do some customization on the server side
    handling for the forms.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Optgroups、selected states、multiple attributes以及其他属性都像标准的HTML5行为一样受到尊重。这意味着我们不需要期望特殊的东西或在服务器端处理表单时进行一些定制。
- en: Geographic location input using maps
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地图的地理位置输入
- en: Since the introduction of the HTML5 geolocation API, reading the user's location
    became much simpler. However, sometimes we might want to allow the user to correct
    or verify his location or to specify a location different than their own.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 自从引入HTML5地理位置API以来，读取用户的位置变得更加简单。然而，有时我们可能希望允许用户更正或验证他们的位置，或者指定一个与他们自己不同的位置。
- en: In this chapter, we're going to make a location input that allows the user to
    specify a location by marking it on a map.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将制作一个位置输入，允许用户通过在地图上标记来指定位置。
- en: Our location picker will be represented as a link. Upon clicking the link, the
    user will have the option to search for their location using an input field, and
    then select the location by clicking on the map.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的位置选择器将表示为一个链接。单击链接后，用户将有选择使用输入字段搜索其位置的选项，然后通过单击地图选择位置。
- en: As with all our map recipes, we're going to use the popular Leaflet ([http://leafletjs.com/](http://leafletjs.com/))
    map library.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们所有的地图示例一样，我们将使用流行的Leaflet（[http://leafletjs.com/](http://leafletjs.com/)）地图库。
- en: Getting ready
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would like our map input to behave similar to most input fields. We're going
    to use a drop-down style mechanism, similar to most date picker components. The
    user will click on a link to modify the location, and a map dropdown will appear
    as a result. After the user makes their selection, the dropdown will disappear.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的地图输入行为类似于大多数输入字段。我们将使用一个下拉样式的机制，类似于大多数日期选择器组件。用户将点击一个链接来修改位置，然后地图下拉菜单将出现。用户做出选择后，下拉菜单将消失。
- en: 'We''re also going to add a search box to aid the user in finding the desired
    location on the map. To do this, we will use **Nominatim** ([http://nominatim.openstreetmap.org/](http://nominatim.openstreetmap.org/)),
    a free geocoding service provided by OpenStreetMap. The following is an example
    of how a Nominatim JSON response looks like:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在地图上添加一个搜索框，以帮助用户找到所需的位置。为此，我们将使用**Nominatim**（[http://nominatim.openstreetmap.org/](http://nominatim.openstreetmap.org/)），这是OpenStreetMap提供的免费地理编码服务。以下是Nominatim
    JSON响应的示例：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It's an array of search results containing various data among which the data
    that we will need, such as latitude, longitude, and display name, are present.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含各种数据的搜索结果数组，其中包括我们需要的数据，如纬度、经度和显示名称。
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's write the code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写代码。
- en: 'As always, we start with our HTML page. Our input field consists of three components:
    the link to be clicked, a hidden input field containing latitude and longitude
    data, and a map-based location picker. The map and search box are not included
    in the HTML—they''re created on demand.'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们的HTML页面一样，我们始终从HTML页面开始。我们的输入字段由三个组件组成：要单击的链接、包含纬度和经度数据的隐藏输入字段以及基于地图的位置选择器。地图和搜索框不包括在HTML中，它们是按需创建的。
- en: To make the map drop down below the link, it's positioned relatively to its
    container. To make autocomplete links appear on separate lines, their display
    style is set to `block`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使地图下拉菜单出现在链接下方，它相对于其容器进行定位。为了使自动完成链接出现在单独的行上，它们的显示样式设置为`block`。
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to make this picker work, the following code is added in `example.js`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使此选择器工作，将以下代码添加到`example.js`中：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '![How to do it...](img/9282OT_05_05.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9282OT_05_05.jpg)'
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The code found in `example.js` enables the user to click on the **Set location**
    link and choose a location using the map. The `click` event binding is added to
    the document body to make it easier to add a new location input to the page.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.js`中的代码使用户可以单击**设置位置**链接，并使用地图选择位置。`click`事件绑定添加到文档主体，以便更容易地向页面添加新的位置输入。'
- en: We parse the latitude and longitude from the hidden input field and then create
    a map centered at those coordinates with a marker placed at the same place.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从隐藏输入字段中解析纬度和经度，然后创建一个以这些坐标为中心的地图，并在同一位置放置一个标记。
- en: When the user clicks on the map, the location is updated and the map is removed
    after 500 milliseconds. This should be long enough for the user to notice that
    his change was successfully applied.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击地图时，位置将被更新，并且地图将在500毫秒后被移除。这应该足够长，让用户注意到他的更改已成功应用。
- en: Additionally, we added a search box next to the clicked link. When the user
    types in a search query inside, a search is performed by making an Ajax request
    to Nominatim. To avoid overloading the service, the search is delayed by 1 second;
    if the user types something before that second passes, the query is canceled and
    a new one is scheduled for sending 1 second later.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在点击的链接旁边添加了一个搜索框。当用户在其中输入搜索查询时，将通过向Nominatim发出Ajax请求来执行搜索。为了避免过载服务，搜索会延迟1秒；如果用户在那一秒内输入了内容，查询将被取消，并且将安排在1秒后发送新的查询。
- en: Upon fetching the results, the code displays them as a list of links. When clicked,
    they will reposition the map to be centered at the exact location of the clicked
    search result. The list of search results will be removed and the user will be
    allowed to select the exact location.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取结果后，代码将它们显示为链接列表。单击后，它们将重新定位地图，使其位于单击搜索结果的确切位置。搜索结果列表将被移除，并允许用户选择确切的位置。
