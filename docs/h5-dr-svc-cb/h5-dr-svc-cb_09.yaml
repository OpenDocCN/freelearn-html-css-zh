- en: Chapter 9. Client-side Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。客户端模板
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Rendering objects using Handlebars
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Handlebars渲染对象
- en: Rendering objects using EJS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EJS渲染对象
- en: Rendering objects using Jade
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jade渲染对象
- en: Rendering arrays using Handlebars
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Handlebars渲染数组
- en: Rendering arrays using EJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EJS渲染数组
- en: Rendering arrays using Jade
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jade渲染数组
- en: Simplifying templates with helpers in Handlebars
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Handlebars中使用助手简化模板
- en: Reusing templates with partials in Handlebars
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Handlebars中使用部分模板重用模板
- en: Reusing templates with partials in EJS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在EJS中使用部分模板重用模板
- en: Using filters in Jade
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jade中使用过滤器
- en: Using mixins in Jade
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jade中使用混合
- en: Using layouts and blocks in Jade
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jade中的布局和块
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Modern service apps are often built for multiple platforms, where only one of
    those platforms is the Web. Other platforms may include iOS, Android, and other
    websites that need to use the service through an API. Some of those platforms
    might not support HTML. They might also need to show different HTML for the same
    data or do preprocessing before displaying the data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现代服务应用程序通常为多个平台构建，其中只有一个平台是Web。其他平台可能包括iOS、Android和其他需要通过API使用服务的网站。其中一些平台可能不支持HTML。它们可能还需要为相同的数据显示不同的HTML或在显示数据之前进行预处理。
- en: As a result, there has been a shift in web apps from using server-side HTML
    rendering to client-side HTML rendering. The service serves the serialized raw
    data (most often as JSON, sometimes XML) and the client decides how to display
    the data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，Web应用程序已经从使用服务器端HTML渲染转变为使用客户端HTML渲染。服务提供序列化的原始数据（通常为JSON，有时为XML），客户端决定如何显示数据。
- en: 'In this chapter we''re going to take a look at several popular client-side
    template languages, each with a different approach to templating:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍几种流行的客户端模板语言，每种语言都有不同的模板方法。
- en: EJS, which combines HTML with the full power of JavaScript
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJS将HTML与JavaScript的全部功能结合在一起
- en: Handlebars, which combines HTML with a succinct but more restricted block structures
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Handlebars将HTML与简洁但更受限制的块结构相结合
- en: Jade, which replaces HTML syntax with a cleaner-looking version that has support
    for dynamic facilities
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jade将HTML语法替换为更清晰的版本，并支持动态功能
- en: We're going to learn how to do some common tasks in each, such as displaying
    basic objects, displaying lists (or looping), and using partial templates.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在每个模板语言中执行一些常见任务，比如显示基本对象，显示列表（或循环），以及使用部分模板。
- en: Rendering objects using Handlebars
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Handlebars渲染对象
- en: Handlebars is a template language that adds minimal syntax to HTML. Its goal
    is to minimize the amount of logic present in the template and force the passed
    model object to correspond to what should be rendered in the view.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars是一种模板语言，它在HTML中添加了最小的语法。它的目标是最小化模板中存在的逻辑量，并强制传递的模型对象与视图中应该呈现的内容相对应。
- en: In this recipe, we will demonstrate some of the advantages and shortcomings
    of Handlebars using a simple example. We're going to render a user greeting based
    on the time of the day.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将演示使用一个简单的例子来展示Handlebars的一些优点和缺点。我们将根据一天中的时间来呈现用户的问候语。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to download Handlebars from [https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js).
    The browser version is in the `dist` directory. Create a directory for the example
    and copy `handlebars.js` to this directory, or download directly (on Linux):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js)下载Handlebars。浏览器版本位于`dist`目录中。创建一个示例目录并将`handlebars.js`复制到该目录中，或直接下载（在Linux上）：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '如何做... '
- en: 'Let''s write the code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写下代码：
- en: 'Create `index.html` containing a `name` input, a `greeting` placeholder, and
    the Handlebars template:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含`name`输入、`greeting`占位符和Handlebars模板的`index.html`：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create `example.js` to bind the template to the data and the view:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`来将模板绑定到数据和视图：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We usually embed Handlebars templates inside an HTML page by adding them to
    a `script` element with a `type` attribute set to `text/x-handlebars-template`.
    The browser ignores scripts with unknown types, so we can be sure that the content
    is left intact.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过将Handlebars模板添加到带有`type`属性设置为`text/x-handlebars-template`的`script`元素中，将它们嵌入到HTML页面中。浏览器会忽略未知类型的脚本，因此我们可以确保内容保持不变。
- en: Using the template is done in two phases. In the first phase, we need to compile
    the template text. This process results with a compiled template in the form of
    a JavaScript function being returned. In the second phase, we pass a model object
    as a parameter to that function (the compiled template) and get the HTML output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板分为两个阶段。在第一阶段，我们需要编译模板文本。这个过程会返回一个以JavaScript函数形式的编译模板。在第二阶段，我们将模型对象作为参数传递给该函数（编译模板），并获得HTML输出。
- en: Handlebars is a very opinionated and minimal templating language. The use of
    program logic, such as comparison operators inside the template is strictly forbidden.
    This is by design, and it is a good idea, if the business logic changes we don't
    need to update the template. For example, if we start considering the period from
    midnight to 2 a.m. as evening, we don't need to change the template – we only
    need to add the condition when creating the model, which we pass to Handlebars.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars是一种非常有主见的和极简的模板语言。在模板中使用比较运算符等程序逻辑是严格禁止的。这是有意设计的，这是一个好主意，如果业务逻辑发生变化，我们不需要更新模板。例如，如果我们开始将午夜到凌晨2点视为晚上，我们不需要更改模板-我们只需要在创建模型时添加条件，然后将其传递给Handlebars。
- en: On the other hand, we can see that Handlebars sometimes goes a bit too far with
    its restrictions. For example, it doesn't support a case structure, enumerations
    or constructs such as `'else if'`. As a result, we must either resort to Boolean
    expressions for every possible state or keep the actual text or value inside the
    model. In some of those cases the model may interfere with information that belongs
    to the view.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以看到Handlebars有时会对其限制有些过分。例如，它不支持case结构，枚举或诸如'else if'之类的结构。因此，我们必须要么为每种可能的状态使用布尔表达式，要么将实际文本或值保留在模型中。在某些情况下，模型可能会干扰属于视图的信息。
- en: Rendering objects using EJS
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EJS渲染对象
- en: EJS is a template language that allows users to mix HTML and JavaScript inside
    the template. Similar to PHP and ERB, it works by adding extra tags to HTML which
    allow the user to "escape" from HTML to the programming language and use the full
    facilities of that language.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: EJS是一种模板语言，允许用户在模板中混合HTML和JavaScript。类似于PHP和ERB，它通过在HTML中添加额外的标记来使用户能够从HTML中“逃离”到编程语言，并使用该语言的全部功能。
- en: In this recipe, we're going to demonstrate EJS using a simple example. We're
    going to render a user greeting based on the time of the day.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用一个简单的示例来演示EJS。我们将根据一天中的时间来渲染用户问候。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download EJS from [http://embeddedjs.com/](http://embeddedjs.com/)
    and extract `ejs_production.js` in our `recipe` folder.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[http://embeddedjs.com/](http://embeddedjs.com/)下载EJS，并在我们的`recipe`文件夹中提取`ejs_production.js`。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create `index.html` containing a `name` input, a `greeting` placeholder, and
    an EJS `template`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含`name`输入，`greeting`占位符和EJS`template`的`index.html`：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create `example.js` to bind the template to the data and the view:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`以将模板绑定到数据和视图：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The common way to embed EJS templates inside the page is to add them inside
    a `script` element with a `type` attribute set to `text/ejs`. The browser ignores
    scripts with unknown types, so we can be sure that the content is left intact.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将EJS模板嵌入页面的常见方法是将它们添加到具有`type`属性设置为`text/ejs`的`script`元素中。浏览器会忽略未知类型的脚本，因此我们可以确保内容保持不变。
- en: In-between the EJS opening and closing tags, `<% %>`, we can write any arbitrary
    JavaScript, which will be executed when rendering the template. The rest of the
    template is plain HTML. This makes EJS very easy to use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在EJS的开放和关闭标签`<% %>`之间，我们可以编写任意的JavaScript，这将在渲染模板时执行。模板的其余部分是纯HTML。这使得EJS非常容易使用。
- en: When we want to print the value of a JavaScript expression, we use a different
    opening tag, `<%=`, which prints the expression value as plain text, escaping
    any HTML contained.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要打印JavaScript表达式的值时，我们使用不同的开标签`<%=`，它将表达式值打印为纯文本，转义任何包含的HTML。
- en: To use the template, we create a new EJS object. This calls the EJS compiler,
    which compiles the template into a more efficient form. Then we can call the `render`
    method of this object, passing it the variables (data model) to use when rendering
    the template.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模板，我们创建一个新的EJS对象。这将调用EJS编译器，将模板编译成更高效的形式。然后我们可以调用这个对象的`render`方法，传递变量（数据模型）以在渲染模板时使用。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To print the value of an HTML expression without escaping we can use the `<%-`
    tag instead of the `<%=` tag. This enables us to insert the HTML code as DOM nodes
    (as against treating them as plain text).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印HTML表达式的值而不转义，我们可以使用`<%-`标签而不是`<%=`标签。这使我们能够将HTML代码插入为DOM节点（而不是将它们视为纯文本）。
- en: Rendering objects using Jade
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jade渲染对象
- en: Jade is a clean, terse template language. It uses significant whitespace to
    denote block and element hierarchy. It supports many advanced features, for example,
    mixins, which are subtemplates and blocks, which are template sections replaceable
    by inheritance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Jade是一种简洁的模板语言。它使用显著的空格来表示块和元素的层次结构。它支持许多高级功能，例如混合，这是子模板，以及块，这是可以通过继承替换的模板部分。
- en: In this recipe, we're going to render a simple greeting using Jade. Later on
    in this chapter, we're going to look at some of the more advanced features.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用Jade渲染一个简单的问候语。在本章的后面，我们将看一些更高级的功能。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download `jade.min.js` in our `recipe` folder, available at [https://github.com/visionmedia/jade](https://github.com/visionmedia/jade).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`recipe`文件夹中下载`jade.min.js`，可以在[https://github.com/visionmedia/jade](https://github.com/visionmedia/jade)上找到。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create `index.html`, it will contain a small form asking the user for his or
    her name, a placeholder to render the greeting, and the greeting template:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`，它将包含一个要求用户输入姓名的小表单，一个用于渲染问候语的占位符，以及问候语模板：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create `example.js` to compile the template and bind it to the data and the
    view:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`以编译模板并将其绑定到数据和视图：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Jade templates are very similar to the resulting HTML structure. Our template
    produces a single `span` element containing the greeting text, and another `b`
    (bold) element containing the name of the user.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Jade模板与生成的HTML结构非常相似。我们的模板生成一个包含问候文本的单个`span`元素，以及另一个包含用户姓名的`b`（粗体）元素。
- en: Jade supports conditionals. Their syntax looks exactly similar to the element
    syntax, except that they're not rendered. The condition doesn't need to be wrapped
    in parenthesis, but otherwise the Boolean expression is evaluated as the JavaScript
    code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Jade支持条件语句。它们的语法看起来与元素语法完全相似，只是它们不会被渲染。条件不需要用括号括起来，但布尔表达式会被作为JavaScript代码进行评估。
- en: As shown in the "Good Morning" greeting, we can use the vertical pipe character
    to split the text into multiple lines
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如“早上好”问候所示，我们可以使用竖线字符将文本分成多行
- en: To display the contents of a variable (escaping HTML markup), we use the "`=`"
    (equals) character. If we don't want the content to be filtered we can use the
    character "`-`" (minus).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 显示变量的内容（转义HTML标记），我们使用"`=`"（等于）字符。如果我们不希望内容被过滤，可以使用"`-`"（减号）字符。
- en: To use a Jade template, we compile it using `jade.compile`. This results with
    a `template` function. If we pass an object to this function, we're going to get
    a rendered HTML as the result. We display the HTML inside the `#greeting` element.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Jade模板，我们使用`jade.compile`进行编译。这将得到一个`template`函数。如果我们将一个对象传递给这个函数，我们将得到一个渲染后的HTML作为结果。我们在`#greeting`元素内显示HTML。
- en: Rendering arrays using Handlebars
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Handlebars渲染数组
- en: Displaying a list of objects is the most common reason we need a separate template
    language, otherwise we could easily get by with direct DOM manipulation. Handlebars
    has an easy, clean, and straightforward syntax for array iteration—the `each`
    construct, which works very similarly to the `for each` loops in other languages.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象列表是我们需要单独的模板语言的最常见原因，否则我们可以轻松地通过直接操作DOM来完成。Handlebars对于数组迭代有一个简单、清晰和直接的语法——`each`结构，它的工作方式与其他语言中的`for
    each`循环非常相似。
- en: In this recipe, we're going to render a list of message objects. Each message
    object will have an author, arrival time, body, and read status. We're going to
    use a different style to distinguish between read and unread messages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将渲染一个消息对象列表。每个消息对象都有一个作者、到达时间、正文和阅读状态。我们将使用不同的样式来区分已读和未读的消息。
- en: As usual in this chapter, the template will be included in the HTML file inside
    a `script` tag. However, the compilation can be called on any string that we choose;
    it is therefore possible to download the template data by sending a request to
    the server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 像本章中的其他示例一样，模板将包含在HTML文件中的`script`标签内。然而，编译可以在我们选择的任何字符串上调用；因此可以通过向服务器发送请求来下载模板数据。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to download Handlebars from [https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js).
    The browser version is in the `dist` directory. Create a directory for the example
    and copy `handlebars.js` to this directory, or download directly (on Linux):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js)下载Handlebars。浏览器版本在`dist`目录中。创建一个示例目录并将`handlebars.js`复制到该目录，或直接下载（在Linux上）：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Create `index.html`, it will contain a header, the Handlebars template, the
    placeholder to render the message list, and some styles for the list:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`，其中包含一个标题，Handlebars模板，用于渲染消息列表的占位符，以及一些列表样式：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create `example.js` to display an example array in the placeholder element
    using the `template` variable:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`以在占位符元素中显示一个示例数组，使用`template`变量：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Handlebars have the `{{#each}}` helper, which iterates through the array passed
    as its first argument.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars有`{{#each}}`助手，它遍历作为第一个参数传递的数组。
- en: Inside the block, every member variable of the array element comes into the
    current scope and is directly accessible by name. This feature greatly simplifies
    this template because it avoids the repetition of the variable name inside the
    loop.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在块内，数组元素的每个成员变量都进入当前作用域，并且可以直接通过名称访问。这个特性极大地简化了这个模板，因为它避免了在循环内重复变量名。
- en: From this example we can see that we're not limited to using the variables inside
    the elements, we can also use them in the middle of attributes or anywhere else
    in the HTML.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个示例中我们可以看到，我们不仅限于在元素内部使用变量，还可以在属性中间或HTML的任何其他地方使用它们。
- en: Rendering arrays using EJS
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EJS渲染数组
- en: One of the most common tasks when using a template language is to render a list
    of items. Since EJS is based on escaping to JavaScript, rendering lists can be
    done using the loop constructs in the language.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板语言时，最常见的任务之一是渲染项目列表。由于EJS是基于转义到JavaScript的，可以使用语言中的循环结构来渲染列表。
- en: In this recipe, we're going to render a list of message objects. Each message
    object will have an author, arrival time, body, and read status. We're going to
    use a different style to distinguish between read and unread messages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将渲染一个消息对象列表。每个消息对象都有一个作者、到达时间、正文和阅读状态。我们将使用不同的样式来区分已读和未读的消息。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download EJS from [http://embeddedjs.com/](http://embeddedjs.com/)
    and extract `ejs_production.js` in our `recipe` folder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[http://embeddedjs.com/](http://embeddedjs.com/)下载EJS，并在我们的`recipe`文件夹中提取`ejs_production.js`。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create `index.html`, it will contain a header, the EJS template, the placeholder
    to render the message list, and some styles for the list:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`，其中包含一个标题，EJS模板，用于渲染消息列表的占位符，以及一些列表样式：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Call the `render` function from `example.js` with some text data:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`example.js`中的`render`函数并传递一些文本数据：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `render` function we pass a model object containing an array of messages
    to the renderer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`函数中，我们传递一个包含消息数组的模型对象给渲染器。
- en: To render the array we use a standard JavaScript `for` loop. We can add any
    valid JavaScript code between the opening and closing tags. In our example we
    assign a variable inside the body of the loop, and then use it throughout the
    template.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染数组，我们使用标准的JavaScript `for` 循环。我们可以在开放和闭合标签之间添加任何有效的JavaScript代码。在我们的示例中，我们在循环体内赋值一个变量，然后在整个模板中使用它。
- en: From the example it's clear that EJS allows you to escape to JavaScript at any
    point in the template text. Even escaping in HTML attributes is allowed (we are
    adding a class to our message that corresponds to the message status, read or
    unread) by escaping inside the `class` attribute.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中可以清楚地看出，EJS允许你在模板文本的任何地方转义到JavaScript。甚至在HTML属性中转义也是允许的（我们正在为消息添加一个与消息状态相对应的类，已读或未读），通过在`class`属性内转义。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This example shows that EJS is almost as powerful as JavaScript itself. However,
    it's not recommended to write any business logic code inside the template. Instead,
    prepare your model object in a way that makes the template code straightforward
    to write.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例表明EJS几乎和JavaScript本身一样强大。然而，不建议在模板内编写任何业务逻辑代码。相反，准备好你的模型对象，使模板代码编写起来更加直观。
- en: Rendering arrays using Jade
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jade渲染数组
- en: Jade also supports rendering lists of items as other template languages. We
    can use the `each` construct to iterate through the elements in the array and
    output some HTML elements for each.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Jade还支持将项目列表呈现为其他模板语言。我们可以使用`each`结构来迭代数组中的元素，并为每个元素输出一些HTML元素。
- en: In this recipe, we're going to render a list of message objects. Each message
    object will have an author, arrival time, body, and read status. We're going to
    use a different style to distinguish between read and unread messages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将呈现一系列消息对象。每个消息对象都将有一个作者、到达时间、正文和阅读状态。我们将使用不同的样式来区分已读和未读的消息。
- en: We're also going to use different backgrounds for odd and even rows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为奇数和偶数行使用不同的背景。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download `jade.min.js` in to our `recipe` folder available at [https://github.com/visionmedia/jade](https://github.com/visionmedia/jade).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`recipe`文件夹中下载`jade.min.js`，可在[https://github.com/visionmedia/jade](https://github.com/visionmedia/jade)中找到。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤：
- en: 'Create `index.html` containing the CSS style, placeholder, and the template
    `script` element:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含CSS样式、占位符和模板`script`元素的`index.html`：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create `example.js` to wrap the element and the template with some model data:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`来包装元素和模板与一些模型数据：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Besides allowing us to access the array element, the `each` construct in Jade
    can also provide the index of the element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许我们访问数组元素之外，Jade中的`each`结构还可以提供元素的索引。
- en: 'Using this index we demonstrate that Jade can support arbitrary expressions.
    We add an odd class to oddly-numbered messages, and an even class to evenly-numbered
    ones. Of course, it''s better to use CSS pseudo-selectors to do this, for example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个索引，我们演示了Jade可以支持任意表达式。我们为奇数编号的消息添加了一个奇数类，并为偶数编号的消息添加了一个偶数类。当然，最好使用CSS伪选择器来做到这一点，例如：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Jade allows us to omit the name of the element and only use a class and/or an
    ID attribute. In these cases the element is assumed to be a `div`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Jade允许我们省略元素的名称，只使用类和/或ID属性。在这些情况下，假定元素是`div`。
- en: We can append CSS style classes and an ID after the element tag. Jade will add
    the corresponding attributes to the element.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在元素标签后附加CSS样式类和ID。Jade将为元素添加相应的属性。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Instead of concatenating the style classes, we can also pass a variable which
    contains an array of classes to add to the element.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递一个包含要添加到元素的类数组的变量，而不是连接样式类。
- en: Simplifying templates with helpers in Handlebars
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Handlebars简化模板
- en: While writing templates we often have the task of displaying common visual elements,
    such as alerts, dialogs, and lists. These elements may have a complex internal
    structure, and writing a template every time to map the model to this structure
    can be an error-prone and repetitive process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写模板时，我们经常需要显示常见的视觉元素，例如警报、对话框和列表。这些元素可能具有复杂的内部结构，每次都编写模板将模型映射到这个结构可能是一个容易出错和重复的过程。
- en: Handlebars allows us to simplify the writing of templates containing common
    elements by replacing the template for the common element with a call to helpers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars允许我们通过将常见元素的模板替换为调用助手来简化包含常见元素的模板的编写。
- en: In this recipe, we're going to write Handlebars helpers to render links, images,
    and unordered lists. We're going to display a list of people with their name,
    photo, and link to their profile.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写Handlebars助手来呈现链接、图像和无序列表。我们将显示一个包含姓名、照片和链接到其个人资料的人员列表。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to download Handlebars from [https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js).
    The browser version is in the `dist` directory. Create a directory for the example
    and copy `handlebars.js` to this directory, or download directly (on Linux):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js)下载Handlebars。浏览器版本位于`dist`目录中。创建一个示例目录并将`handlebars.js`复制到该目录中，或者直接下载（在Linux上）：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤：
- en: 'Create `index.html`, which will contain the list style, list placeholder, and
    list template. The template will utilize our new helpers:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含列表样式、列表占位符和列表模板的`index.html`。模板将利用我们的新助手：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement the helpers, and render the template in `example.js`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现助手，并在`example.js`中呈现模板：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Inside our template, we're using two new helpers, `ul` to display lists and
    the `img` tag to display images.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板中，我们使用了两个新的助手，`ul`用于显示列表和`img`标签用于显示图像。
- en: 'Handlebars has two different types of helpers: regular and block. Block helpers
    are invoked in the following format:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars有两种不同类型的助手：常规和块。块助手以以下格式调用：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When Handlebars encounters a block, it invokes its block function, which takes
    one or two arguments:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当Handlebars遇到一个块时，它会调用它的块函数，该函数接受一个或两个参数：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If specified, the first argument is passed to the `helper` function. If the
    first argument is not available, the `options` argument becomes first.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定，第一个参数将传递给`helper`函数。如果第一个参数不可用，则`options`参数将成为第一个。
- en: The named parameters are also optional, and are available inside the `options`
    argument in the `hash` property that is, `options.hash`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数也是可选的，并在`hash`属性中作为`options`参数可用。
- en: Next comes the mandatory block argument, available inside the `helper` function
    as `options.fn`. The block argument is a function that takes a context and returns
    the result of rendering the block with that context
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是必需的块参数，在`helper`函数内部可用，称为`options.fn`。块参数是一个函数，它接受一个上下文并返回使用该上下文渲染块的结果
- en: The `else` block is also a block function (`options.inverse`). It is optional
    and can be omitted. If omitted, a default empty block function is passed as `options.inverse`
    instead.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`块也是一个块函数（`options.inverse`）。它是可选的，可以省略。如果省略，将一个默认的空块函数作为`options.inverse`传递。'
- en: In our example we pass the list contents to our `ul` helper. This helper uses
    the regular block on each item if there are items in the list; otherwise it uses
    the alternative block to display the empty list message.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将列表内容传递给我们的`ul`助手。如果列表中有项目，这个助手在每个项目上使用常规块；否则，它使用替代块来显示空列表消息。
- en: 'The other type of helper is a regular helper and can be invoked as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的助手是常规助手，可以按照以下方式调用：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Normal helpers work similarly, to the block helpers, except that they don't
    receive the block parameters. In our example, we pass the `alt` text to the rendered
    image as a named parameter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 普通助手的工作方式与块助手类似，只是它们不接收块参数。在我们的示例中，我们将`alt`文本作为命名参数传递给呈现的图像。
- en: Both types of helpers should return the rendered HTML.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的助手都应返回呈现的HTML。
- en: 'In our `example.js` file, we register our two new helpers by calling `Handlebars.registerHelper`.
    This makes them available to all subsequent templates that we need to render.
    Afterwards, we can call `render` on the template with our data, which in turn
    invokes the helpers to generate the resulting HTML:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`example.js`文件中，我们通过调用`Handlebars.registerHelper`注册了我们的两个新助手。这使它们可以用于需要呈现的所有后续模板。之后，我们可以对模板调用`render`，并使用我们的数据，这将调用助手来生成结果的HTML：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reusing templates with partials in Handlebars
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Handlebars中使用部分模板重用模板
- en: Handlebars partials are templates which can be invoked from other templates
    with a certain context.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars部分模板是可以从其他模板中调用的模板，并带有特定的上下文。
- en: One example use of a partial template is a user login box. Such a box would
    display the username, the number of unread notifications, and a logout link if
    the user is logged in; otherwise it would display regular login options which
    are available while using Facebook and Twitter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 部分模板的一个示例用途是用户登录框。这样的框将显示用户名、未读通知的数量，以及如果用户已登录则显示注销链接；否则将显示可在使用Facebook和Twitter时使用的常规登录选项。
- en: Partial templates can be used instead of helpers when there are no parameters
    to be passed to the helper or when no complex logic is necessary. They're particularly
    useful when the amount of dynamically generated content is small and the amount
    of HTML is large. This is because inside partial templates, HTML can be written
    directly without the need to convert it to strings.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有参数需要传递给助手或不需要复杂逻辑时，部分模板可以用来代替助手。当动态生成的内容量较小，HTML量较大时，它们特别有用。这是因为在部分模板内部，可以直接编写HTML，而无需将其转换为字符串。
- en: In this recipe, we're going to use partial templates to render a threaded conversation
    model. This example also demonstrates that partial templates can be re-used recursively
    from within themselves.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用部分模板来呈现一个分级对话模型。这个例子还表明，部分模板可以在自身内部递归地重复使用。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to download Handlebars from [https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js).
    The browser version is in the `dist` directory. Create a directory for the example
    and copy `handlebars.js` to this directory, or download directly (on Linux):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js)下载Handlebars。浏览器版本在`dist`目录中。创建一个示例目录，并将`handlebars.js`复制到该目录，或直接下载（在Linux上）：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's get started.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create `index.html` which will contain the conversation placeholder, the main
    conversation template, and the recursive partial thread template:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`，其中将包含对话占位符、主对话模板和递归部分线程模板：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To style the displayed messages, create `style.css` and add the following CSS
    code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给显示的消息添加样式，创建`style.css`并添加以下CSS代码：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The rendering will be done from `example.js`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染将从`example.js`中进行：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The data structure of the message in this recipe is recursive. It contains
    the message details: the username and user photo, message text, and message date.
    But it also contains the replies to that message, which are messages themselves.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中消息的数据结构是递归的。它包含消息的详细信息：用户名和用户照片、消息文本和消息日期。但它还包含对该消息的回复，这些回复本身也是消息。
- en: To render this structure we write a partial template for a single thread of
    conversation, specifying how to display the message details but also iterating
    through all the replies and invoking itself for every reply.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了呈现这个结构，我们编写了一个单个对话线程的部分模板，指定如何显示消息的详细信息，但也遍历所有的回复，并为每个回复调用自身。
- en: This partial template is then called once from the main template, resulting
    with a full conversation tree.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从主模板中调用这个部分模板，得到完整的对话树。
- en: 'Handlebars partial templates are called with the variables from the current
    context. Partials work just the same as we do directly to replace the call to
    the partial with the contents of the partial template:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars部分模板是使用当前上下文中的变量调用的。部分与我们直接替换部分模板的调用一样工作，用部分模板的内容替换部分的调用：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Partial templates can be used for headers, footers, menus, or even recursively.
    It's a recommended practice to split large reusable sections of a website into
    partial templates to avoid copying and to making these sections easier to change
    and reusable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 部分模板可以用于头部、尾部、菜单，甚至是递归。将网站的大部分可重用部分拆分为部分模板是一种推荐的做法，以避免复制并使这些部分更容易更改和重用。
- en: Reusing templates with partials in EJS
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在EJS中使用部分模板重用模板
- en: Partial templates are larger sections of HTML which need to be included multiple
    times from multiple pages. Common uses for partial templates include headers,
    footers, site menus, login boxes, alerts, and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 部分模板是需要从多个页面多次包含的较大的HTML部分。部分模板的常见用途包括头部、尾部、站点菜单、登录框、警报等。
- en: The latest version of EJS doesn't natively support partial templates; they have
    been removed. However, there is another way to use other templates from within
    a template, by including the compiled template itself in the data model.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的EJS不支持部分模板；它们已被移除。然而，还有另一种方法可以在模板中使用其他模板，即通过在数据模型中包含编译后的模板本身。
- en: In this recipe, we're going to render a conversation thread using a recursive
    partial template written in EJS.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用EJS中的递归部分模板来呈现对话线程。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download EJS from [http://embeddedjs.com/](http://embeddedjs.com/)
    and extract `ejs_production.js` in our `recipe` folder.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[http://embeddedjs.com/](http://embeddedjs.com/)下载EJS，并在我们的`recipe`文件夹中提取`ejs_production.js`。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create `index.html`, which will contain the conversation placeholder, the main
    conversation template, and the recursive partial thread template:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`，其中包含对话占位符、主对话模板和递归部分线程模板：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the styles necessary to render the template in `style.css`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`style.css`中添加必要的样式来呈现模板：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the rendering code in `example.js`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`example.js`中添加渲染代码：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The message thread is a recursive data structure. It contains the message details
    (such as date, user, and text) and also the replies which are themselves message
    threads.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 消息线程是一个递归数据结构。它包含消息细节（如日期、用户和文本）以及回复，这些回复本身也是消息线程。
- en: To make the partial template object available inside the template, we include
    it in the passed model. Then we can call it from the template, passing it further
    inside the model of the recursive partial thread template.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使部分模板对象在模板内可用，我们将其包含在传递的模型中。然后我们可以从模板中调用它，并将其进一步传递到递归部分线程模板的模型中。
- en: This partial template displays the message details, and then proceeds to call
    itself to render every reply if such replies are available. In each call we pass
    the partial template object to make it available within the next call.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分模板显示消息细节，然后继续调用自身以呈现每个回复（如果有的话）。在每次调用中，我们传递部分模板对象，以便在下一次调用中可用。
- en: 'The process ends when there are no more threads to be rendered, resulting with
    a complete message tree:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多的线程需要呈现时，过程结束，得到一个完整的消息树：
- en: '![How it works...](img/9282OT_09_01.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_09_01.jpg)'
- en: There is more...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Even though EJS doesn't natively support partials anymore, this recipe shows
    how we can still reuse EJS templates inside each other. We can easily extend this
    to full partial support by passing a table of all registered partials along with
    every model.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管EJS不再原生支持部分模板，但这个食谱展示了我们如何仍然可以在EJS模板之间重用。我们可以通过传递所有注册的部分模板的表格以及每个模型来轻松扩展到完整的部分支持。
- en: Using filters in Jade
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jade中使用过滤器
- en: Jade filters are powerful features which enable the users to use different markups
    inside Jade templates. Their primary use is to make templates even more succinct
    by enabling the user to use the appropriate tool for a particular section of the
    template.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Jade过滤器是强大的功能，使用户能够在Jade模板中使用不同的标记。它们的主要用途是通过使用户能够为模板的特定部分使用适当的工具，使模板更加简洁。
- en: In this recipe, we're going to use Jade filters to embed markdown inside our
    template and explain how filters work.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用Jade过滤器将markdown嵌入到我们的模板中，并解释过滤器的工作原理。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The client-side version of Jade [https://github.com/visionmedia/jade](https://github.com/visionmedia/jade)
    is found in the `jade.js` file and does not support markdown filters out of the
    box. To add support for markdown we need edit this file and find the line that
    starts defining the `markdown` filter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Jade的客户端版本[https://github.com/visionmedia/jade](https://github.com/visionmedia/jade)可以在`jade.js`文件中找到，但默认情况下不支持markdown过滤器。要添加对markdown的支持，我们需要编辑此文件并找到开始定义`markdown`过滤器的行：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And then replace it with the following function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用以下函数替换它：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will inform Jade to use the globally defined markdown object, which we're
    going to provide by including an external markdown script.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通知Jade使用全局定义的markdown对象，我们将通过包含外部markdown脚本来提供。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create `index.html` which will contain the placeholder for our template and
    the template itself:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`，其中包含我们模板的占位符和模板本身：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the simple `example.js` file to bind the template to the element:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建简单的`example.js`文件将模板绑定到元素：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When Jade encounters the `:markdown` block, it passes the text found inside
    it to the markdown `filter` function which we previously created. This `filter`
    function calls the markdown-js to the HTML method that processes the markdown
    and generates HTML.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当Jade遇到`:markdown`块时，它将块内找到的文本传递给我们之前创建的markdown`filter`函数。这个`filter`函数调用markdown-js的HTML方法来处理markdown并生成HTML。
- en: '![How it works...](img/9282OT_09_02.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_09_02.jpg)'
- en: Using mixins in Jade
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jade中使用mixin
- en: Similar to partial templates in other template languages, Jade mixins are smaller
    template pieces that can accept parameters. Mixins are useful when generating
    common HTML chunks such as alert boxes, dialogs, and menus.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模板语言中的部分模板类似，Jade的mixin是可以接受参数的较小的模板片段。当生成常见的HTML块时，如警报框、对话框和菜单时，mixin非常有用。
- en: In this recipe we're going to compare Jade's mixins with the partial templates
    found in the other template languages by reimplementing the threaded conversation
    template. This is a recursive template that renders a threaded conversation tree.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过重新实现线程对话模板来比较Jade的mixin和其他模板语言中的部分模板。这是一个递归模板，用于呈现线程对话树。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download `jade.min.js` in our `recipe` folder, available at [https://github.com/visionmedia/jade](https://github.com/visionmedia/jade).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`recipe`文件夹中下载`jade.min.js`，可在[https://github.com/visionmedia/jade](https://github.com/visionmedia/jade)找到。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get started.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Create `index.html` which will contain the conversation placeholder, the main
    conversation template, and the recursive partial thread template:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`，其中包含对话占位符、主对话模板和递归部分线程模板：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create `example.js` to pass the data to the template:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`将数据传递给模板：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create `style.css` to style the conversation thread:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`style.css`来为对话线程设置样式：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The message thread is a recursive data structure. It contains the message details
    (such as date, user, and text) and also the replies which are themselves message
    threads.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 消息线程是一个递归数据结构。它包含消息细节（如日期、用户和文本），还包括回复，这些回复本身就是消息线程。
- en: To render this structure we wrote a Jade mixin. The mixin takes the thread as
    an argument and displays its attributes as well as the text in the top node of
    the thread.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染这个结构，我们写了一个Jade混合。混合以线程作为参数，并显示其属性以及线程顶部节点中的文本。
- en: Finally, if there are replies inside the thread object, it iterates through
    all of those replies and recursively calls itself with each reply as an argument.
    Calling a mixin is done by prefixing the mixin name with the character "+".
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果线程对象中有回复，它会遍历所有这些回复，并递归地将每个回复作为参数调用自身。通过在混合名称前加上字符“+”来调用混合。
- en: The main template displays the topic of the top level message in a heading.
    Afterwards it invokes the mixin with the top level thread which results in the
    rendering of the complete thread tree.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 主模板显示顶级消息的主题。然后它调用混合与顶级线程，这导致完整线程树的渲染。
- en: Using layouts and blocks in Jade
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jade中使用布局和块
- en: To allow us to easily create different templates, Jade supports template inheritance.
    Jade's template inheritance allows us to define a master layout template, and
    then replace parts of this template by extending the master layout.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们轻松创建不同的模板，Jade支持模板继承。Jade的模板继承允许我们定义一个主布局模板，然后通过扩展主布局替换该模板的部分。
- en: In this recipe we're going to use template inheritance to simulate a complete
    website, containing a header, a menu, some content, and a footer. The content
    will be split into two pages.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用模板继承来模拟一个完整的网站，包含标题、菜单、一些内容和页脚。内容将分为两个页面。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The client-side version of Jade does not support layouts and blocks. Specifying
    the template to extend requires access to the filesystem which is not available
    inside the browser. However, we can precompile the templates using browserify.
    To do this we're going to write a browserify plugin that registers a handler for
    the Jade files.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Jade的客户端版本不支持布局和块。指定要扩展的模板需要访问文件系统，这在浏览器中不可用。但是，我们可以使用browserify预编译模板。为此，我们将编写一个browserify插件，该插件注册了Jade文件的处理程序。
- en: 'Let''s install the prerequisites first. We''re going to need `nodejs`, which
    can be downloaded from [http://nodejs.org/](http://nodejs.org/). After installing
    node from a command prompt, we''re going to install browserify Version 1 (Version
    2 has no support for plugins as of now):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们安装先决条件。我们需要`nodejs`，可以从[http://nodejs.org/](http://nodejs.org/)下载。在命令提示符中安装node后，我们将安装browserify
    Version 1（截至目前，Version 2不支持插件）：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we shall create a new directory for our example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的示例创建一个新目录：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In that directory we will install Jade (and markdown to add markdown support
    to Jade):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录中，我们将安装Jade（和markdown以添加markdown支持到Jade）：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤：
- en: 'Let''s write the browserify plugin, `browserify.jade.js`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写browserify插件，`browserify.jade.js`：
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then create `index.html`, which in this case is a simple placeholder for the
    content which will be filled by the templates:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建`index.html`，在这种情况下，它是一个简单的占位符，用于模板填充的内容：
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we can create `example.js`, which will load the two templates and make
    the menu clicks render a different template:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以创建`example.js`，它将加载两个模板，并使菜单点击呈现不同的模板：
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is the content of `layout.jade` (which also renders the menu):'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`layout.jade`的内容（也渲染菜单）：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add this to `example.jade`, which extends `layout.jade` by appending an item
    to the `menu` block and replacing the `content` block:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其添加到`example.jade`中，通过向`menu`块追加项目并替换`content`块来扩展`layout.jade`：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s add `style.css` to give it a nice look:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`style.css`，使其看起来漂亮：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally let''s wrap it all into `example.min.js` by typing the following command
    in the command prompt:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在命令提示符中输入以下命令，将所有内容包装到`example.min.js`中：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start with `browserify-jade.js`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`browserify-jade.js`开始。
- en: This plugin works by registering the new file extension '`jade`' with browserify
    and telling it to invoke our transformation function with the contents of every
    jade file it encounters being required in our code. This means it will intercept
    both `require('layout.jade')` and `require('example.jade')`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件通过使用browserify注册新的文件扩展名'`jade`'，并告诉它使用我们的转换函数处理它遇到的每个jade文件的内容来工作。这意味着它将拦截`require('layout.jade')`和`require('example.jade')`。
- en: Our plugin function compiles the received template content using Jade, and then
    writes the code of the resulting JavaScript function. However to make sure that
    Jade helper functions are available for the generated template, it also includes
    `runtime.js` via require. This file contains the basic Jade library that all compiled
    templates need to work (adding it this way will cause browserify to include it
    in the final bundle).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件函数使用Jade编译接收到的模板内容，然后编写生成的JavaScript函数的代码。但是，为了确保生成的模板可以使用Jade辅助函数，它还通过require包含`runtime.js`。该文件包含所有编译模板需要的基本Jade库（以这种方式添加将导致browserify将其包含在最终捆绑包中）。
- en: 'How blocks and inheritance work:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 块和继承的工作原理：
- en: To make a template an inheritable layout, all we need to do is place named blocks
    inside it. In our example we have two named blocks in `layout.jade` – one for
    the menu and one for the content.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要使模板成为可继承的布局，我们只需要在其中放置命名块。在我们的示例中，`layout.jade`中有两个命名块 - 一个用于菜单，一个用于内容。
- en: Named blocks allow us extend the template and then replace parts of the content
    with our own. We do this in the `example.jade` file. This file inherits from layout,
    appends a new menu item to the menu block using "`block append`", and completely
    replaces the content block with its own written in markdown.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 命名块允许我们扩展模板，然后用自己的内容替换部分内容。我们在`example.jade`文件中这样做。该文件继承自布局，使用“`block append`”在菜单块中追加一个新的菜单项，并完全用自己的markdown内容替换内容块。
- en: Tip
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's also possible to prepend content to a block by simply using "`block prepend`".
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过简单地使用“`block prepend`”来在块前添加内容。
- en: 'When we run the `browserify` command, it combines the templates and `example.js`
    into a single file called `example.min.js`, which we include in our page:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`browserify`命令时，它会将模板和`example.js`合并成一个名为`example.min.js`的单个文件，我们在页面中引入它：
- en: '![How it works...](img/9282OT_09_03.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_09_03.jpg)'
- en: The result is a simple page with a heading, menu, content, and a footer block.
    When a link from the menu is clicked, the appropriate template is loaded and rendered
    on this page.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个简单的页面，有一个标题、菜单、内容和一个页脚块。当菜单中的链接被点击时，适当的模板会被加载并在页面上呈现。
