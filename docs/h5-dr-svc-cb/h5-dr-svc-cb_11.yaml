- en: Chapter 11. Data Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。数据存储
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下配方：
- en: Data URI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Data URI
- en: Session and local storage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话和本地存储
- en: Reading data from files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中读取数据
- en: Using IndexedDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IndexedDB
- en: Limits of the storage and how to ask for more
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的限制以及如何请求更多
- en: Manipulating the browser history
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作浏览器历史记录
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When we talk about storage, most of the developers think about storing data
    on the server on some database. HTML5 really makes a leap forward on what can
    be passed around and saved to the client side. Whether is for some temporary use,
    caching, or full offline usage of entire apps, client-side storage is becoming
    more and more common.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论存储时，大多数开发人员会考虑将数据存储在服务器上的某个数据库中。HTML5确实在可以传递和保存到客户端方面取得了长足的进步。无论是用于临时使用、缓存，还是完全离线使用整个应用程序，客户端存储正在变得越来越普遍。
- en: All of these great features that enable us to store data at the client side
    making the applications ultimately faster, more usable and reachable. Even in
    cloud-based solutions we still need some local data that will make the user experience
    nicer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些伟大的功能使我们能够在客户端存储数据，从而使应用程序变得更快、更易用和更可达。即使在基于云的解决方案中，我们仍然需要一些本地数据，这将使用户体验更好。
- en: The chapter covers some of the features that are related to HTML5 and are about
    data storage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一些与HTML5相关的特性，涉及数据存储。
- en: Data URI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Data URI
- en: We have already used on several occasions Data **URI** (**Uniform resource identifier**)
    throughout this book, but never got into details on what can we use it for as
    well as what are the limitations. Data URI are often referred to as Data **URL**
    (**Uniform Resource Locator**) though technically speaking they don't actually
    locate anything from a remote site.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书中的多个场合使用了Data **URI**（**统一资源标识符**），但从未详细介绍过我们可以用它做什么，以及有什么限制。Data URI通常被称为Data
    **URL**（**统一资源定位符**），尽管从技术上讲，它们实际上并没有从远程站点定位任何内容。
- en: In this example, we will use different media types and check the size constraints.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用不同的媒体类型并检查大小约束。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will only need browser and some sample text files for this example. The files
    can be downloaded as part of the `files` folder in the example files.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们只需要浏览器和一些样本文本文件。这些文件可以作为示例文件中的`files`文件夹的一部分下载。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to see some of the options available we will create a simple HTML
    file with few different use scenarios:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看一些可用的选项，我们将创建一个简单的HTML文件，其中包含几种不同的使用场景：
- en: 'The `head` section will include the `example.css` file:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`head`部分将包括`example.css`文件：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `body` section we add a `div` element that will serve as a container
    for the CSS image Data URI:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`部分，我们添加一个`div`元素，用作CSS图像Data URI的容器：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By using Data URI we can create a simple editor that will be opened by clicking
    on a link:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用Data URI，我们可以创建一个简单的编辑器，通过点击链接打开：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'base64 is optional and character set can be used:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: base64是可选的，可以使用字符集：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Data URI can be a raw SVG:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Data URI可以是原始SVG：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The accompanying CSS code with Data URI is used to represent `background-image`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Data URI的伴随CSS代码用于表示`background-image`：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will display two images and links to simple editor and a small text file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示两个图像和链接到简单编辑器和一个小文本文件：
- en: '![How to do it...](img/9282OT_11_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9282OT_11_01.jpg)'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'One common misconception is that Data URI can be used only to represent images.
    As we have seen in our example this is not the case. Strictly speaking, Data URI
    is not an HTML5 feature but included in RFC-2397 ([http://tools.ietf.org/html/rfc2397](http://tools.ietf.org/html/rfc2397)),
    specified in 1998 with the original proposal of the idea in 1995\. The idea behind
    it is to have an embeddable data directly inline. The URI form is specified as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是Data URI只能用来表示图像。正如我们在例子中看到的，这并不是这样。严格来说，Data URI不是HTML5的特性，而是在RFC-2397（[http://tools.ietf.org/html/rfc2397](http://tools.ietf.org/html/rfc2397)）中包含的，1998年指定，最初在1995年提出了这个想法。其背后的想法是直接内联嵌入数据。URI形式被指定为：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `mediatype` attribute is Internet media type or its older name is MIME.
    In case we don't specify it, it defaults to `text/plain;charset=US-ASCII`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`mediatype`属性是Internet媒体类型，或者它的旧名称是MIME。如果我们不指定它，它默认为`text/plain;charset=US-ASCII`。'
- en: Besides being cool and different why should we use Data URI?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了酷和不同之外，我们为什么要使用Data URI？
- en: One good reason is to derive data from the currently displayed document. For
    example, we could create an image from a `canvas` element or have a CSV file generated
    from the current table.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的理由是从当前显示的文档中派生数据。例如，我们可以从`canvas`元素创建图像，或者从当前表格生成CSV文件。
- en: Another reason is speed of loading a web page. This is contradictory, since
    Data URI often is base64 encoded and this increases the size of the document to
    1/3rd. The principle behind the speed up is the reduction in the number of requests.
    This makes sense for transfer of small files that should be less than a few kilobytes,
    otherwise the gain from not making another request is small if it even exists.
    Another problem with this approach is that we are losing the individual cache
    for separate resources. What otherwise would be a separately cached file, now
    has the same properties as the document where it is embedded. If that document
    changes often, the embedded data will get reloaded each time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是网页加载速度。这是矛盾的，因为Data URI通常是base64编码的，这会增加文档的大小到1/3。加快速度的原则是减少请求的数量。这对于传输应该小于几千字节的小文件是有意义的，否则，不再发出另一个请求的收益很小，如果有的话。这种方法的另一个问题是，我们正在失去单独资源的缓存。否则将被单独缓存的文件，现在具有与嵌入它的文档相同的属性。如果该文档经常更改，则嵌入的数据将每次重新加载。
- en: The other use cases are environments with restrictions on various resources.
    E-mail is an example of this kind of case where, in order to enable a single document
    experience without having images as attachments, Data URI can be used.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用例是对各种资源有限制的环境。电子邮件就是这种情况的一个例子，在这种情况下，为了实现单一文档体验而不必将图像作为附件，可以使用Data URI。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In some applications of Data URI, security could be a concern, but if the client
    app in most of the browsers follow the specifications, then only the data with
    `mediatype` allowed will be handled.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些数据URI的应用中，安全性可能是一个问题，但如果大多数浏览器中的客户端应用程序遵循规范，那么只有允许的`mediatype`数据将被处理。
- en: There are also size limits for what the attributes in HTML5 can contain. HTML
    4 has the `ATTSPLEN` restrictions where it specifies that the maximum length of
    the attributes is `65536` characters. This is not the case for HTML5, where currently
    we have different state on each browser version. For Firefox 3.x it was 600 KB,
    for Chrome 19 it was 2 MB, and IE 8 has a limit of 32 KB. It is safe to say that
    it makes sense only for smaller resources.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5中的属性有大小限制。HTML 4有`ATTSPLEN`限制，其中指定属性的最大长度为`65536`个字符。HTML5不是这种情况，目前每个浏览器版本都有不同的状态。对于Firefox
    3.x，它是600 KB，对于Chrome 19，它是2 MB，IE 8的限制是32 KB。可以肯定地说，这只对较小的资源有意义。
- en: Session and local storage
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话和本地存储
- en: Cookies are a common way to save state from our application at the client side.
    This might be some checkboxes that were selected or some kind of temporary data,
    for example, current flow in a wizard app or even a session identifier.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie是保存应用程序状态的常用方式，可能是一些选中的复选框或某种临时数据，例如，向导应用程序中的当前流程，甚至是会话标识符。
- en: This is a proven method for quite some time, but there are a few use cases where
    it is just uncomfortable to create cookies and they impose certain limits and
    overhead that can be avoided.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经过验证的方法已经有一段时间了，但有一些使用情况是不舒服创建Cookie并且它们会施加一定的限制和开销，这是可以避免的。
- en: Session and local storage solve some of the issues with cookies and enable a
    simple storage of data on the client. In this recipe we will create a simple form
    that will take advantage of the HTML5 storage API.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 会话和本地存储解决了一些Cookie的问题，并且使数据在客户端上的简单存储成为可能。在这个示例中，我们将创建一个简单的表单，利用HTML5存储API。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe we will use several images that can be retrieved from the `images`
    folder or you can use your own selection. Additionally since we will use a simulated
    response from the REST API of a JSON object we need to start a local HTTP server
    that will serve our static files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用可以从`images`文件夹中检索的几个图像，或者您可以使用自己的选择。此外，由于我们将使用来自JSON对象的REST API的模拟响应，我们需要启动一个本地HTTP服务器来提供我们的静态文件。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can start off by creating a form that will have a dog selection and an area
    to leave comments. When we click on a button in the form, an image will be displayed
    of the selected dog. In addition to that, we shall have an output field for the
    number of visits made by the current user:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先创建一个表单，其中包含狗的选择和留下评论的区域。当我们在表单中点击一个按钮时，将显示所选狗的图像。除此之外，我们还将有一个输出字段，用于显示当前用户的访问次数：
- en: 'We link a simple CSS class in the `head` section:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`head`部分链接一个简单的CSS类：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The form will contain the following radio buttons and a text area:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单将包含以下单选按钮和文本区域：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We add a counter for the number of visits as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个访问次数的计数器如下：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also a simple `div` element as a placeholder for the selected dog image and
    the dependency to jQuery, and include the `example.js` file that we will write
    later on:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个简单的`div`元素作为所选狗图片的占位符和对jQuery的依赖，以及包括我们稍后将编写的`example.js`文件：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the `example.js` file we create a function that will store the comment
    in the session on clicking on a button. If the data is not available a request
    to the `"dogs.json"` variable will be made:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`example.js`文件，我们创建一个函数，将在点击按钮时将评论存储在会话中。如果数据不可用，将对`"dogs.json"`变量进行请求：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: With `#dogPicker :radio:checked`, we select all the checked input `radio` subelements
    of the element with ID `dogPicker`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`#dogPicker :radio:checked`，我们选择`dogPicker`ID的元素的所有选中输入`radio`子元素。
- en: 'Since the data for the comment is stored in the session, upon clicking on that
    we can have a way of loading it for the next time:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于评论的数据存储在会话中，点击后我们可以有一种加载它的方式，以备下次使用：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But using `localStorage` we can increment the `viewCount` variable or else
    initialize it for the first time:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是使用`localStorage`，我们可以递增`viewCount`变量，或者首次初始化它：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `showSelectedImages` method goes through each of the dog object, in the
    list we have in `localStorage` and creates an image element with the selected
    file:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`showSelectedImages`方法遍历每个狗对象，在我们的`localStorage`列表中创建一个带有所选文件的图像元素：'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we select a radio button and click on the it, an image of a dog should be
    displayed, if we try to reload that cache then (*Ctrl* + *F5*) in most browsers
    the comment data will still remain there. If we open the same URL it in another
    tab then the comment should not be there, meaning that the session is tied to
    a single browser window or a tab. On the other hand the counter should increment
    each time and no additional requests are done for the `dogs.json` file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一个单选按钮并单击它，狗的图像应该显示出来，如果我们尝试重新加载缓存，那么（*Ctrl* + *F5*）在大多数浏览器中，评论数据仍然会保留。如果我们在另一个标签中打开相同的URL，那么评论就不应该存在，这意味着会话与单个浏览器窗口或标签相关联。另一方面，计数器应该每次递增，而且不会为`dogs.json`文件执行额外的请求。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Both `sessionStorage` and `localStorage` share the common `Storage` interface,
    and they are defined as part of [http://www.w3.org/TR/webstorage/](http://www.w3.org/TR/webstorage/).
    We can use the dot notation to read or write to the storage, for example `storage.key
    = someValu`e and `someValue = storage.key`. The longer form is to access data
    using method calls, `storage.setItem(key, value)` and `storage.getItem(key)`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionStorage`和`localStorage`共享通用的`Storage`接口，并且它们被定义为[http://www.w3.org/TR/webstorage/](http://www.w3.org/TR/webstorage/)的一部分。我们可以使用点表示法来读取或写入存储，例如`storage.key
    = someValue`和`someValue = storage.key`。更长的形式是使用方法调用访问数据，`storage.setItem(key,
    value)`和`storage.getItem(key)`。'
- en: Tne restriction we have for the key and values here is that is that they need
    to be "strings". In our example, we needed to store JSON, so in order to make
    it compatible for values, we used `JSON.stringify` and `JSON.parse`. There is
    also a method `storage.removeItem(key)` to delete an item, or to clear the entire
    storage with `storage.clear()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对键和值的限制是它们必须是“字符串”。在我们的例子中，我们需要存储JSON，所以为了使其与值兼容，我们使用了`JSON.stringify`和`JSON.parse`。还有一个方法`storage.removeItem(key)`来删除一个项目，或者用`storage.clear()`来清除整个存储。
- en: '`sessionStorage` is an object that can be used for storing information that
    last for the duration of a browser''s session, this is where the name originates.
    Information is retained even after reload occurred making it a powerful alternative
    to session cookies. The context of which the items stored are valid is the current
    website domain for the duration of the session of the currently opened tab. For
    example, if we store an item on domain [http://example.com/1.html](http://example.com/1.html),
    it will be accessible at [http://example.com/2.html](http://example.com/2.html)
    or any other page of the same domain.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionStorage`是一个用于存储在浏览器会话期间持续存在的信息的对象，这就是名称的由来。即使重新加载后信息仍然保留，使其成为会话cookie的强大替代品。存储的项目的有效上下文是当前网站域，在当前打开的选项卡的会话期间。例如，如果我们在域[http://example.com/1.html](http://example.com/1.html)上存储一个项目，它将在[http://example.com/2.html](http://example.com/2.html)或同一域的任何其他页面上都可以访问。'
- en: '`LocalStorage`, on the other hand, is a persistent storage, and unlike `sessionStorage`,
    it applies even after the end of session. This is similar to the behavior of standard
    cookies, but unlike them which can hold very limited amount of data. `localStorage`
    comes with 5 MB by default on most of the browsers and 10 MB on IE. You need to
    keep in mind that we are storing the data as strings rather than their original
    form, for example, integers or floats, so the final representation that will be
    stored will be larger. If we happen to overcome the size limit of our storage,
    then an exception with the `QUOTA_EXCEEDED_ERR` error message will be thrown.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalStorage`是一种持久存储，与`sessionStorage`不同，它在会话结束后仍然有效。这类似于标准cookie的行为，但与cookie不同的是，cookie只能保存非常有限的数据。`localStorage`在大多数浏览器上默认为5MB，在IE上为10MB。需要记住的是，我们将数据存储为字符串而不是它们的原始形式，例如整数或浮点数，因此最终存储的表示将更大。如果我们超出存储限制，那么将抛出一个带有`QUOTA_EXCEEDED_ERR`错误消息的异常。'
- en: In our code, we used `localStorage` to cache a JSON resource, giving us a full
    control of invalidation. Also, we created a simple counter for the number of visits
    by a given user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用`localStorage`来缓存JSON资源，从而完全控制了失效。此外，我们为给定用户的访问次数创建了一个简单的计数器。
- en: The obvious isolation for which separate storage exists is the combination of
    `hostname` and `port`. Less common knowledge is the isolation of the web storage
    depending on the tuple of `scheme/host/port`. Scheme contains the subdomain and
    protocol. So, if a page has a mixed type of resources loaded with `https` and
    `http`, you might not get so obvious results. Having mixed resources similar to
    that is not a good security practice, but it often happens nonetheless. In either
    case, no sensitive data should be stored in local or session storage.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的隔离是`hostname`和`port`的组合，需要单独存储。较少人知道的是，Web存储还取决于`scheme/host/port`的元组。Scheme包含子域和协议。因此，如果页面加载了混合类型的资源，有些是用`https`，有些是用`http`，你可能得不到那么明显的结果。虽然混合资源不是一个好的安全实践，但它经常发生。无论哪种情况，敏感数据都不应存储在本地或会话存储中。
- en: Another case is the private/incognito mode that most of the browsers nowadays
    have. While the page is opened in that mode, a new temporary database for those
    values will be used. Everything that will be stored while in this mode will only
    be part of that session.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是大多数现代浏览器都有的私人/无痕模式。在该模式下打开页面时，将使用一个新的临时数据库来存储这些值。在此模式下存储的所有内容只会成为该会话的一部分。
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**Local Storage** uses an synchronous API that runs on the main UI thread in
    the browser. Because of that, there is a very small possibility that a race condition
    can happen if we have the same site opened on multiple, different windows. This
    is not a real problem for most of the use cases. For clearing data from the client
    side, we can always call `storage.clear()`, but most browsers now have developer
    tools that ease the manipulation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地存储**使用一个在浏览器的主UI线程上运行的同步API。因此，如果我们在多个不同的窗口上打开相同的网站，就有很小的可能发生竞争条件。对于大多数用例来说，这并不是一个真正的问题。要从客户端清除数据，我们可以随时调用`storage.clear()`，但大多数浏览器现在都有开发者工具来简化操作：'
- en: '![There''s more...](img/9282OT_11_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/9282OT_11_02.jpg)'
- en: 'When it comes to polyfills there are plenty of them available, for example
    [https://code.google.com/p/sessionstorage/](https://code.google.com/p/sessionstorage/)
    or [https://gist.github.com/remy/350433](https://gist.github.com/remy/350433).
    You might be wondering how they work, because storage is a new feature that is
    added to the browsers. Most of them use cookies to store data, so they are usually
    limited to 2 KB, the maximum size of cookie. Others use the IE userData([http://msdn.microsoft.com/en-us/library/ms531424%28VS.85%29.aspx](http://msdn.microsoft.com/en-us/library/ms531424%28VS.85%29.aspx))
    object to enable its usage on an older version of IE. There are also libraries,
    for example, [http://www.jstorage.info/](http://www.jstorage.info/) that provide
    the same interface for multiple browser versions. Also, there is `Persists.js`
    that enables multiple different fallback solutions: flash – Flash 8 persistent
    storage, gears – Google gears-based persistent storage, localstorage – HTML5 draft
    storage, whatwg_db – HTML5 draft database storage, globalstorage – HTML5 draft
    storage (now obsolete), IE – Internet Explorer user data behaviors, and cookie
    – Cookie-based persistent storage.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充方面有很多可用的，例如[https://code.google.com/p/sessionstorage/](https://code.google.com/p/sessionstorage/)或[https://gist.github.com/remy/350433](https://gist.github.com/remy/350433)。您可能想知道它们是如何工作的，因为存储是添加到浏览器的新功能。它们大多使用cookie来存储数据，因此通常受到2
    KB的限制，即cookie的最大大小。其他使用IE userData([http://msdn.microsoft.com/en-us/library/ms531424%28VS.85%29.aspx](http://msdn.microsoft.com/en-us/library/ms531424%28VS.85%29.aspx))对象在旧版本的IE上启用其使用。还有一些库，例如[http://www.jstorage.info/](http://www.jstorage.info/)，为多个浏览器版本提供相同的接口。此外，还有`Persists.js`，它可以启用多种不同的回退解决方案：flash
    - Flash 8持久存储，gears - 基于Google gears的持久存储，localstorage - HTML5草案存储，whatwg_db -
    HTML5草案数据库存储，globalstorage - HTML5草案存储（现已过时），IE - Internet Explorer用户数据行为，和cookie
    - 基于cookie的持久存储。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is also a custom object-based fallback that can be created to enable `localStorage`
    on older browsers. More info on MDN can be found at [https://developer.mozilla.org/en-US/docs/DOM/Storage#Compatibility](https://developer.mozilla.org/en-US/docs/DOM/Storage#Compatibility).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个基于自定义对象的回退，可以创建以在旧浏览器上启用`localStorage`。有关更多信息，请访问MDN的[https://developer.mozilla.org/en-US/docs/DOM/Storage#Compatibility](https://developer.mozilla.org/en-US/docs/DOM/Storage#Compatibility)。
- en: '`globalStorage` is implemented in several versions of Firefox, but because
    there was a lot of confusion related to the implementations, it has been removed
    from Firefox 13, as well as the specification for Web storage.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`globalStorage`在几个版本的Firefox中实现了，但由于与实现相关的混乱很多，它已经从Firefox 13中移除，以及Web存储的规范。'
- en: When it comes to security, it is never a good idea to have sensitive data at
    the client side storage. If there is an XSS vulnerability in your site then the
    storage can be read. It does not make much sense to encrypt the data with server
    side-based key, since that will make us dependent on the server data. There is
    also a possible DNS spoofing attack that can happen on non-TLS sites. If the domain
    is spoofed the browser will not be able to tell if the data is accessed from a
    "wrong" site.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全性方面，将敏感数据存储在客户端存储中从来都不是一个好主意。如果您的站点存在XSS漏洞，那么存储可以被读取。使用服务器端密钥加密数据并没有太多意义，因为这将使我们依赖于服务器数据。在非TLS站点上还可能发生DNS欺骗攻击。如果域名被欺骗，浏览器将无法判断数据是否是从“错误”的站点访问的。
- en: A lot of criticism has been directed towards Web storage mostly due to user
    tracking. If we have the same advertiser in several different sites then he can
    easily track the user visits in those sites. This make the users a lot less anonymous
    and an easy target. There are several proposed solution to fix this problem, for
    example, having restrictions for third-party `iframes` and blacklisting of domains
    that create such data but none of them fix the problem fully at the moment.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对Web存储提出了很多批评，主要是由于用户跟踪。如果我们在几个不同的站点中有相同的广告商，那么他可以轻松地跟踪用户在这些站点上的访问。这使得用户的匿名性大大降低，成为易受攻击的目标。有几种提出的解决方案来解决这个问题，例如，对第三方`iframes`进行限制和创建此类数据的域名黑名单，但目前没有一种完全解决问题。
- en: Reading data from files
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取数据
- en: 'We have already used file input to read some of the data, but never went into
    details about file reading and the objects that are available to us. In this recipe,
    we will create a simple file reader using input file that will act as a mini demonstration
    of some of the options provided in the File API: Directories and System, [http://www.w3.org/TR/file-system-api/](http://www.w3.org/TR/file-system-api/).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用文件输入来读取一些数据，但从未详细介绍过文件读取和可用于我们的对象。在这个示例中，我们将使用输入文件创建一个简单的文件阅读器，它将作为文件API提供的一些选项的迷你演示：目录和系统，[http://www.w3.org/TR/file-system-api/](http://www.w3.org/TR/file-system-api/)。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will create an HTML file containing a file input control and a progress
    output for the state of the upload:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含文件输入控件和上传状态的进度输出的HTML文件：
- en: 'We create the controls and a few output placeholders:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建控件和一些输出占位符：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add dependencies to jQuery and our `example.js`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加依赖项到jQuery和我们的`example.js`：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can proceed to the creation of the `example.js` file; here we attach an
    event handler on the `abort` button and use a `FileReader` object:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以继续创建`example.js`文件；在这里，我们在`abort`按钮上附加一个事件处理程序，并使用`FileReader`对象：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From the selected file input, we will iterate over the uploaded files with
    our current configuration item, and add event handles for some of the common events:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从所选的文件输入中，我们将使用当前配置项迭代上传的文件，并为一些常见事件添加事件处理程序：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `getMetaData` function will read the available metadata form the `file`
    object and create a simple HTML representation:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getMetaData`函数将从`file`对象中读取可用的元数据，并创建一个简单的HTML表示：'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the File interface in W3C File API specification at
    [http://www.w3.org/TR/FileAPI/#dfn-file](http://www.w3.org/TR/FileAPI/#dfn-file).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在W3C文件API规范的[http://www.w3.org/TR/FileAPI/#dfn-file](http://www.w3.org/TR/FileAPI/#dfn-file)中阅读有关文件接口的更多信息。
- en: 'By reading the file type, we can also determine what will be the output. In
    our case, if we have file, that is, image we append the data as `src` on a `img`
    tag, on the other hand for other file types, we just print the text representation:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过读取文件类型，我们还可以确定输出内容。在我们的情况下，如果我们有文件，即图像，我们将数据附加为`img`标签上的`src`，另一方面，对于其他文件类型，我们只是打印文本表示：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is also another way to read the files list in file input by accessing
    the property files. The `slice` button will only read the first 15 bytes from
    the file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有另一种通过访问属性文件来读取文件输入中的文件列表的方法。`slice`按钮将仅从文件中读取前15个字节：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this point we should have a running site where once we upload a file, the
    file will be read and displayed. In order to see the progress events you can try
    out with a large file, because otherwise it could be run in an instant. As for
    the `slice` button it is best if you try it out with a simple `.txt` file so that
    you can see the contents.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该有一个正在运行的网站，一旦上传文件，文件将被读取和显示。为了查看进度事件，您可以尝试使用大文件，否则它可能会立即运行。至于`slice`按钮，最好尝试使用一个简单的`.txt`文件，以便您可以查看内容。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main idea behind these specifications is to enable fully-featured API for
    handing the file system at the client side. One unfortunate thing about the current
    state of matter is that only Chrome has implemented most of the features from
    the Filesystem and FileWriter API, while the others support the FileReader and
    File API. That is why we decided on having a working example that is supported
    in all of the major browsers and uses the features that are most common.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规范背后的主要思想是在客户端实现完整功能的文件系统API。关于当前状态的不幸之处在于，只有Chrome实现了大多数来自文件系统和FileWriter
    API的功能，而其他浏览器支持FileReader和File API。这就是为什么我们决定使用在所有主要浏览器中都受支持并使用最常见功能的工作示例。
- en: 'For reading and simple manipulation, we use `FileList` that contains the `File`
    objects that can be read with `FileReader`. HTML5 defines a files property on
    a `<input type="file">` control that can be accessed using jQuery (`$(''#file'').prop(''files''))`
    or directly from the selected HTML element like we did in case of `this.files.length`.
    This property is actually an array-like object called `FileList` that contains
    the `File` objects. The `FileList` instance has a method, `item(index)` , and
    an attribute `length`. Each item is a `File` object, an interface that extends
    a `Blob`, immutable raw binary data. The File is a representation and has the
    following attributes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读取和简单操作，我们使用包含可以使用`FileReader`读取的`File`对象的`FileList`。HTML5在`<input type="file">`控件上定义了一个文件属性，可以使用jQuery（`$('#file').prop('files'))`）或直接从所选的HTML元素中访问，就像我们在`this.files.length`的情况下所做的那样。此属性实际上是一个称为`FileList`的类似数组的对象，其中包含`File`对象。`FileList`实例具有一个方法`item(index)`和一个属性`length`。每个项目都是一个`File`对象，一个扩展了`Blob`的接口，不可变的原始二进制数据。文件是一个表示，并具有以下属性：
- en: '`name`: This attribute represents the name of the file.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：此属性表示文件的名称。'
- en: '`lastModifiedDate`: This attribute represents the last modified date of the
    file. If this is not available to the browser, then the current date and time
    are set as the `Date` object.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastModifiedDate`：此属性表示文件的最后修改日期。如果浏览器无法获取此信息，则将当前日期和时间设置为`Date`对象。'
- en: 'But besides them, there are also the ones that come from the `Blob` interface,
    which are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但除此之外，还有来自`Blob`接口的方法，如下所示：
- en: '`size`: This attribute represents the size of the file in bytes'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：此属性表示文件的大小（以字节为单位）'
- en: '`type`: The MIME type. This metadata can be read directly as we did in our
    `getMetaData` function. The metadata can be used in various different ways, for
    example in our case depending on the type of file we are matching the images `f.type&&f.type.match(''image/.+'')`,
    and then displaying a `img` tag or text otherwise.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：MIME类型。此元数据可以直接读取，就像我们在`getMetaData`函数中所做的那样。元数据可以以各种不同的方式使用，例如在我们的情况下，根据文件类型匹配图像`f.type&&f.type.match(''image/.+'')`，然后显示`img`标签或其他文本。'
- en: The `Blob` type also contains the definition of the `slice` method and since
    `File` extends `Blob` it can also be used there. The `slice(start, end, contentType)`
    method returns a new object with the new `contentType` attribute being sliced,
    the new file will have the slice from the original.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blob`类型还包含`slice`方法的定义，由于`File`扩展了`Blob`，因此也可以在那里使用。`slice(start, end, contentType)`方法返回一个新对象，其中新的`contentType`属性被切片，新文件将从原始文件中切片。'
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In older browser versions, for example, Firefox version less than 12 and Chrome
    version less than 21 you needed to use a prefixed version of the `slice` method.
    For Chrome it was `File.webkitSlice()` and for Firefox, `File.mozSlice()`. The
    `Blob` object can also be created from a byte array.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧的浏览器版本中，例如，Firefox版本小于12和Chrome版本小于21，您需要使用`slice`方法的前缀版本。对于Chrome，它是`File.webkitSlice()`，对于Firefox，它是`File.mozSlice()`。`Blob`对象也可以从字节数组创建。
- en: 'The `FileReader` object is the actually object that does the reading of the
    data contained in a file, since by itself the `File` object is just a reference
    to the real data. In `FileReader` there are methods for reading from `Blob`, which
    are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReader`对象实际上是执行文件中包含的数据读取的对象，因为`File`对象本身只是对真实数据的引用。在`FileReader`中有用于从`Blob`中读取的方法，如下所示：'
- en: '`void readAsArrayBuffer(blob)`: This method reads the file as a binary array'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void readAsArrayBuffer(blob)`: 此方法将文件读取为二进制数组'
- en: '`void readAsText(blog, optionalEncoding)`: This method reads the file as text
    where the optional string name of the encoding can be added to designate the one
    that should be used. If the encoding is omitted, then the encoding is picked automatically
    using the encoding determination algorithm, as defined in the specification which
    should be sufficient in most cases.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void readAsText(blog, optionalEncoding)`: 此方法将文件读取为文本，其中可以添加可选的编码字符串名称以指定应使用的编码。如果省略编码，则将使用编码确定算法自动选择编码，如规范中所定义的，在大多数情况下应该足够。'
- en: '`void readAsDataUrl(blob)`: This method creates a data URL from the given file'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void readAsDataUrl(blob)`: 该方法从给定的文件创建一个数据URL'
- en: You may notice that the methods don't actually return the read data. This is
    because the `FileReader` object is reading data asynchronously, so a callback
    will be run once the data is read. There is also an `abort` method that can stop
    the reading of a file once called, this is the method we call upon clicking the
    `abort` button in our example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这些方法实际上并不返回读取的数据。这是因为`FileReader`对象是异步读取数据的，所以一旦数据被读取，就会运行回调函数。还有一个`abort`方法，可以在调用后停止文件的读取，这是我们在示例中点击`abort`按钮时调用的方法。
- en: 'Event handlers that can be attached to a file reader that could get triggered
    on certain cases. In our example, we only print the state of the file reader.
    The following events can be handled:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以附加到文件读取器的事件处理程序可能会在某些情况下触发。在我们的示例中，我们只打印文件读取器的状态。以下事件可以被处理：
- en: '`onabort`: This event gets triggered once the reading operation is aborted.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onabort`: 一旦读取操作被中止，就会触发此事件。'
- en: '`onerror`: This event is called when an error happens. This is the one we often
    want to handle it or at least know when it happened even though the handler is
    optional. The errors can happen for various different reasons, and our handler
    can accept an argument to check the `FileError` error code. For example, the handler
    could do the following:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onerror`: 当发生错误时调用此事件。这是我们经常想要处理或至少知道何时发生的事件，尽管处理程序是可选的。错误可能发生在各种不同的原因，我们的处理程序可以接受一个参数来检查`FileError`错误代码。例如，处理程序可以执行以下操作：'
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `FileError` object contains the corresponding error that has happened, but
    we handle only some of these cases for a given scenario.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileError`对象包含已发生的相应错误，但我们只处理给定情况下的一些情况。'
- en: 'onload – This event is the one that gets called once the read, operation is
    successfully completed. The handler accepts and progresses an event from where
    we can read the data:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: onload – 一旦读取操作成功完成，就会调用此事件。处理程序接受并处理事件，从中我们可以读取数据：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`onloadstart`: This method is called at the very beginning of the reading process.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onloadstart`: 此方法在读取过程的最开始调用。'
- en: '`onloadend`: This method is called when we have successful read but also even
    if an error has happened, making it a good candidate for clearing up the resources
    that we don''t need.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onloadend`: 当我们成功读取时调用此方法，但即使发生错误，它也是一个很好的清理资源的候选者。'
- en: '`onprogress`: This method is called periodically while we are reading the data.
    In the progress handler, we can read several properties that are of use to us
    for making an update on a `progress` element. We can read the total amount of
    bytes for that file that is read, meaning that we can simply calculate the percentage
    of data:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onprogress`: 在读取数据时定期调用此方法。在进度处理程序中，我们可以读取几个对我们有用的属性，以便在`progress`元素上进行更新。我们可以读取已读取该文件的总字节数，这意味着我们可以简单地计算数据的百分比：'
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In most use cases, `onload` and `onerror` are sufficient, but we may need to
    show a visual display to the user or notify him or her of the reading state.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`onload`和`onerror`就足够了，但我们可能需要向用户显示视觉显示或通知他们读取状态。
- en: 'For checking if the functionality we used is supported by a browser we can
    use:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查浏览器是否支持我们使用的功能，我们可以使用：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For more advanced logic and writing to files, there is `FileWriter`, `DirectoryReader`,
    `FileEntry`, `DirectoryEntry`, `LocalFileSystem`, and so on. The issue with this
    is that at the time of this writing only Chrome has support for them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的逻辑和文件写入，有`FileWriter`、`DirectoryReader`、`FileEntry`、`DirectoryEntry`、`LocalFileSystem`等等。问题在于，目前只有Chrome支持它们。
- en: To request a sandboxed filesystem, we make a call to `window.requestFileSystem(type,
    size, successCallback, errorCallback)` that is a part of the FileSystem API. The
    sandbox means that this filesystem is separate from the one of the user, so you
    can't really write anywhere you wish to do so.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求受限文件系统，我们调用`window.requestFileSystem(type, size, successCallback, errorCallback)`，这是FileSystem
    API的一部分。受限环境意味着这个文件系统与用户的文件系统是分开的，所以你不能随意写入任何地方。
- en: 'The filesystem has been prefixed since Chrome 12 and the current version of
    Chrome 25 are still using that version. A simple request for filesystem would
    be:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 自Chrome 12以来，文件系统已经被添加前缀，当前版本的Chrome 25仍在使用该版本。一个简单的文件系统请求可能是：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The files in the sandboxed environment are represented with `FileEntry`, and
    the directories with `DirectoryEntry`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 受限环境中的文件用`FileEntry`表示，目录用`DirectoryEntry`表示。
- en: 'Once we have successfully opened the filesystem, we can read the `FileEntries`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功打开了文件系统，我们就可以读取`FileEntries`：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This `fs.root` call is a reference to the root of the filesystem, as for the
    `fileEntry` parameter there are a lot of methods that can be used for moving the
    file, deleting the file, converting it to a URL, copying, and all the other functionality
    you might expect from a filesystem. The URLs are relative for the given sandboxed
    filesystem so we can expect to have something similar to `/docs/books/dragon/`
    for the `root` directory for that specific sandboxed file system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`fs.root`调用是对文件系统根目录的引用，至于`fileEntry`参数，有很多方法可以用于移动文件、删除文件、将其转换为URL、复制以及您可能期望从文件系统中获得的所有其他功能。这些URL是相对于给定的受限文件系统的，因此我们可以期望在特定受限文件系统的`root`目录中有类似`/docs/books/dragon/`的内容。
- en: Erick Bidelman, one of the programmers behind the FileSystem API has implemented
    great wrapper of the functionality that uses well known UNIX commands such as
    `cp`, `mv`, `ls`. The lib is called `filer.js`, [https://github.com/ebidel/filer.js](https://github.com/ebidel/filer.js).
    He also has polyfill for FileSystem API called `ibd.filesystem.js`, ([https://github.com/ebidel/idb.filesystem.js](https://github.com/ebidel/idb.filesystem.js)),
    that uses IndexedDB to simulate the functionality in other browsers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Erick Bidelman是FileSystem API背后的程序员之一，他实现了一个使用众所周知的UNIX命令（如`cp`，`mv`，`ls`）的功能的包装器。该库称为`filer.js`，[https://github.com/ebidel/filer.js](https://github.com/ebidel/filer.js)。他还有一个名为`ibd.filesystem.js`的FileSystem
    API polyfill，([https://github.com/ebidel/idb.filesystem.js](https://github.com/ebidel/idb.filesystem.js))，它使用IndexedDB在其他浏览器中模拟功能。
- en: There is also a synchronous version of the API where we call it using `webkitRequestFileSystemSync`.
    The reason why we would want to use synchronous reading is Web workers, where
    it makes sense, since we are not blocking the main application like that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个API的同步版本，我们使用`webkitRequestFileSystemSync`调用它。我们希望使用同步读取的原因是Web workers，因为这样做是有意义的，因为我们不会像那样阻塞主应用程序。
- en: 'There are several use cases mentioned in the specification, so a summarized
    version of these use cases would be as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中提到了几种用例，因此这些用例的概述版本如下：
- en: Persistent uploader is a way to upload a file to the server one chunk at a time,
    so that when we have a server or browser failure it can continue with the last
    chunk that the server received, rather than reuploading the whole file all over
    again.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久上传器是一种一次上传一个文件块到服务器的方式，因此当服务器或浏览器发生故障时，它可以继续使用服务器接收到的最后一个文件块，而不是重新上传整个文件。
- en: Game or a rich media application where the resources are downloaded as tarballs
    and are expanded locally, the same resources could be prefetched having only one
    request instead of many small requests, which can reduce the lookup times.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏或富媒体应用程序中，资源作为tarballs下载并在本地展开，相同的资源可以预取，只需一个请求而不是许多小请求，这可以减少查找时间。
- en: The files that will get created by applications such as offline video, audio
    or any other type of binary file viewer, and editor can be saved in local system
    for further processing.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序创建的文件，如离线视频、音频或任何其他类型的二进制文件查看器和编辑器，可以保存在本地系统中以供进一步处理。
- en: Using IndexedDB
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IndexedDB
- en: 'Besides local and session storage, IndexedDB also provides us with a way to
    store user data in the browser. IndexedDB is more advanced than local storage:
    it allows us to store data in object stores and supports indexing the data.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本地和会话存储外，IndexedDB还为我们提供了一种在浏览器中存储用户数据的方式。IndexedDB比本地存储更先进：它允许我们在对象存储中存储数据，并支持对数据进行索引。
- en: In this recipe, we're going to create a simple todo list app which stores its
    data in IndexedDB. We're going to use the Angular framework covered in [Chapter
    10](ch10.html "Chapter 10. Data Binding Frameworks"), *Data Binding Frameworks*
    to simplify our code. We're going to find out if IndexedDB is a better choice
    for larger, more complicated data models with more complex search and retrieval
    needs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个简单的待办事项列表应用程序，它将其数据存储在IndexedDB中。我们将使用[第10章](ch10.html "第10章。数据绑定框架")中介绍的Angular框架，*数据绑定框架*来简化我们的代码。我们将找出IndexedDB是否是更适合更大、更复杂的数据模型和更复杂的搜索和检索需求的选择。
- en: The todo list application will support current and archived items and will allow
    filtering the items by date.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项列表应用程序将支持当前和已归档的项目，并允许按日期筛选项目。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write the code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写代码：
- en: 'Create `index.html`. To simplify our application code, we''re going to use
    `angular.js` templates. Our template will contain the following elements:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`。为了简化我们的应用程序代码，我们将使用`angular.js`模板。我们的模板将包含以下元素：
- en: A select to pick between current and archived todos
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择以在当前和已归档的待办事项之间进行选择
- en: A date range filter using HTML5 date components
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5日期组件的日期范围过滤器
- en: A todo list with a checkbox and age for each item
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有复选框和每个项目的年龄的待办事项列表
- en: A form to add a new item
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新项目的表单
- en: An archive button for current items that are done
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对已完成的当前项目进行归档的归档按钮
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create `example.js`, which will define the controller that sets up and manipulates
    the scope of the template in `index.html` and defines the age filter for dates:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`example.js`，它将定义设置和操作`index.html`模板范围的控制器，并为日期定义年龄过滤器：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the `DBTodo` service required by the controller in `service.js`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`service.js`中定义控制器所需的`DBTodo`服务：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'First, we need to remove the prefix from the global definitions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从全局定义中删除前缀：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our initialization function opens the database and specifies the requested
    version. When the database doesn''t exist, the `onupgradeneeded` function is called,
    and we can use it to create our object store and indices. We also populate the
    database with some randomly generated items:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始化函数打开数据库并指定请求的版本。当数据库不存在时，将调用`onupgradeneeded`函数，我们可以使用它来创建我们的对象存储和索引。我们还使用一些随机生成的项目填充数据库：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function populates the database with `50` random items that are spread
    within `25` days:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数用`25`天内分布的`50`个随机项目填充数据库：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`withDB` is a helper function that makes sure the database is initialized before
    executing the specified function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`withDB`是一个辅助函数，确保在执行指定函数之前初始化数据库：'
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`withScope` is a helper function that creates a function which is called within
    `$rootScope.$apply` to indicate an update of angular scope objects:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`withScope`是一个辅助函数，它创建一个函数，在其中调用`$rootScope.$apply`来指示angular范围对象的更新：'
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, `getItems`, `updateItem`, `archive`, and `addItem` are the public
    API of the `DBTodo` service:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`getItems`，`updateItem`，`archive`和`addItem`是`DBTodo`服务的公共API：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Open `index.html` in a browser that supports IndexedDB and date inputs (for
    example, Google Chrome).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在支持IndexedDB和日期输入（例如Google Chrome）的浏览器中打开`index.html`。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Compared to the average JavaScript API, the IndexedDB API is quite verbose.
    IndexedDB uses DOM events to signal the completion of an asynchronous task. Most
    API calls return a request object. To get the results, we need to attach event
    listeners to this object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的JavaScript API相比，IndexedDB API相当冗长。IndexedDB使用DOM事件来表示异步任务的完成。大多数API调用都会返回一个请求对象。要获取结果，我们需要将事件监听器附加到这个对象上。
- en: 'For example, opening the database results with a request object. We can attach
    three event listeners to this object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，打开数据库的结果是一个请求对象。我们可以将三个事件监听器附加到这个对象上：
- en: '`onsuccess`: This is called when the database has been successfully opened'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onsuccess`: 当数据库成功打开时调用'
- en: '`onerror`: This is called when there is an error'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onerror`: 当发生错误时调用'
- en: '`onupgradeneeded`: This is called when the database is not the specified version
    or doesn''t exist yet'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onupgradeneeded`: 当数据库不是指定版本或尚不存在时调用'
- en: An IndexedDB database is an object-oriented database that contains one or more
    object stores.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB数据库是一个包含一个或多个对象存储的面向对象数据库。
- en: Object stores have a primary key index. The primary key is autogenerated in
    our example, but we can also specify an exiting property to serve as the primary
    key.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储具有主键索引。在我们的例子中，主键是自动生成的，但我们也可以指定一个现有属性作为主键。
- en: Every object store may have one or more indexes. Indexes can be added by specifying
    the path of the property that should be indexed – in our case, we define two indexes
    for our `todos` store on the date and archived fields.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象存储可能有一个或多个索引。索引可以通过指定应该被索引的属性路径来添加 - 在我们的例子中，我们为`todos`存储在日期和归档字段上定义了两个索引。
- en: 'All queries to the database are performed within transactions. When creating
    a transaction, we define the object store that will be used in the transaction.
    Like requests, transactions also have event listeners:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对数据库的查询都在事务中执行。创建事务时，我们定义将在事务中使用的对象存储。与请求一样，事务也有事件监听器：
- en: '`oncomplete`: This is called when the transaction is complete'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oncomplete`: 当事务完成时调用'
- en: '`onerror`: This is called if an error occured'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onerror`: 如果发生错误，则调用此方法'
- en: '`onabort`: This is called if a transaction was aborted'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onabort`: 如果事务被中止，则调用此方法'
- en: Within the transaction we can access the object store by calling `transaction.objectStore('name')`.
    All operations on this object store will be done inside the transaction.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务中，我们可以通过调用`transaction.objectStore('name')`来访问对象存储。对该对象存储的所有操作都将在事务内完成。
- en: The object store supports multiple methods to add, get, and delete items, as
    well as means to access the indexes. To add items we use the `add` method. To
    access items we need to show or update, we use the index by calling `objectStore.index('name')`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储支持多种方法来添加、获取和删除项目，以及访问索引的方法。要添加项目，我们使用`add`方法。要访问需要显示或更新的项目，我们使用索引，通过调用`objectStore.index('name')`。
- en: The index provides a subset of the object store API used to retreive data, such
    as `get`, `count`, and `openCursor`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 索引提供了对象存储API的子集，用于检索数据，如`get`、`count`和`openCursor`。
- en: To update an item or fetch multiple items, we use the `openCursor` method. It
    returns a `request` to which we can attach an `onsuccess` listener. This listener
    will be called for every item accessed by the cursor. The `cursor` can be accessed
    via `request.result`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新项目或获取多个项目，我们使用`openCursor`方法。它返回一个`request`，我们可以将`onsuccess`监听器附加到该请求上。该监听器将对游标访问的每个项目调用。可以通过`request.result`访问游标。
- en: When we're done with the visited item, we can call `cursor.continue` to advance
    to the next item. The `onsuccess` listener will be called again, this time with
    the cursor pointing to the next item.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理完访问的项目后，可以调用`cursor.continue`来前进到下一个项目。`onsuccess`监听器将再次被调用，这次游标指向下一个项目。
- en: 'We can restrict the cursor by specifying a key range to visit, as well as the
    direction (ascending or descending). A key range can be generated with the `IDBKeyRange`
    methods:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定键范围和方向（升序或降序）来限制游标的访问。键范围可以使用`IDBKeyRange`方法生成：
- en: '`upperBound`: This method is used to specify an upper bound range'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upperBound`: 该方法用于指定上限范围'
- en: '`lowerBound`: This method is used to specify a lower bound range'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowerBound`: 该方法用于指定下限范围'
- en: '`bound`: This method is used to specify both upper and lower bound range'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bound`: 该方法用于指定上限和下限范围'
- en: '`only`: This method is used to specify a range that includes only one key.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`only`: 该方法用于指定仅包含一个键的范围。'
- en: Besides specifying the bounds, `upperBound`, `lowerBound`, and `bound`, they
    also support additional Boolean parameters which allow us to specify if the bounds
    are inclusive.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定边界`upperBound`、`lowerBound`和`bound`之外，它们还支持额外的布尔参数，允许我们指定边界是否包含。
- en: 'To sum it all up, when implementing our `getItems` method to fetch all the
    items between the specified dates, we need to:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，当我们实现`getItems`方法来获取指定日期之间的所有项目时，我们需要：
- en: Open a transaction to the todos object store
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个到todos对象存储的事务
- en: Open the todos object store from the transaction
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从事务中打开todos对象存储
- en: Open the `date` index from the object store
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从对象存储中打开`date`索引
- en: Create a `IDBKeyRange` bound specifying the first date as the lower bound and
    the second date as the upper bound (and two true parameters indicating that the
    bounds are inclusive)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`IDBKeyRange`边界，指定第一个日期作为下限，第二个日期作为上限（并指示边界包含两个true参数）
- en: Open a cursor from the `date` index using the created key range
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用创建的键范围从`date`索引中打开游标
- en: Use the cursor request to iterate through all the items and add them into an
    array
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用游标请求来迭代所有项目并将它们添加到数组中
- en: Use the transaction `oncomplete` handler to call the callback function with
    the list when all the items are added
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务的`oncomplete`处理程序在添加所有项目时调用回调函数
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The IndexedDB API is very verbose and low-level. It is not meant to be used
    directly by web applications; instead, it's meant to provide means to write more
    high-level database implementations on top of it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB API非常冗长和低级。它不是用于直接被Web应用程序使用的；相反，它旨在提供手段在其上编写更高级的数据库实现。
- en: 'But more than that, IndexedDB doesn''t support some fundamental features we''ve
    come to accept as standard in real databases:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是，IndexedDB不支持一些我们已经接受为标准的真实数据库中的一些基本功能：
- en: There are no compound indexes, which means we can't write efficient queries
    that bound multiple properties of the object.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有复合索引，这意味着我们无法编写有效的查询来绑定对象的多个属性。
- en: If we wish to order the items in an order different than the one that the index
    key provides, we will have to fill an array and sort the result manually.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们希望按照与索引键提供的顺序不同的顺序对项目进行排序，我们将不得不填充一个数组并手动对结果进行排序。
- en: There are no joins, which means that we would need to write the code to join
    two object stores and pick the most appropriate indexes to minimize the workload
    by hand.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有连接，这意味着我们需要手动编写代码来连接两个对象存储，并选择最合适的索引来最小化工作量。
- en: As a result, we cannot recommend using the IndexedDB API until it matures, or
    other more complete and less verbose database implementations are written on top
    of it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不建议在IndexedDB API成熟之前使用它，或者在其上编写更完整和不那么冗长的数据库实现。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Check out PouchDB ([http://pouchdb.com/](http://pouchdb.com/)) for a more complete
    solution, or `db.js` ([http://aaronpowell.github.com/db.js/](http://aaronpowell.github.com/db.js/))
    for a more succinct API.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 查看PouchDB ([http://pouchdb.com/](http://pouchdb.com/))以获取更完整的解决方案，或者查看`db.js`
    ([http://aaronpowell.github.com/db.js/](http://aaronpowell.github.com/db.js/))以获取更简洁的API。
- en: Limits of the storage and how to ask for more
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储的限制以及如何请求更多
- en: So far we have seen several different ways to have storage and access it at
    the client side. All these ways gives us the option to store large amounts of
    data at the client side. The question arises how come there are no hacks out there
    that fills up the storage of all the devices?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了在客户端有多种不同的方式来存储和访问数据。所有这些方式都给了我们在客户端存储大量数据的选择。问题是为什么没有一种方法可以填满所有设备的存储空间？
- en: We will see why this is not happening everywhere, at least not without some
    browser vulnerability. To do this, we shall create a simple case where we will
    store data to the browser using `localStorage`, as long as we are allowed by the
    user agent.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到为什么这并不是无处不在的，至少不是没有一些浏览器漏洞。为了做到这一点，我们将创建一个简单的案例，我们将使用`localStorage`将数据存储到浏览器中，只要用户代理允许。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can start by creating a file called `example.js`, there we will generate
    data with size of `1 k` and size of `100 k`. The data for 1k can be generated
    by creating an array of `1025` elements, which we will join with the letter `"a"`,
    resulting in `1024` character string of `"a"`''S:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以开始创建一个名为`example.js`的文件，在那里我们将生成大小为`1k`和大小为`100k`的数据。1k的数据可以通过创建一个包含`1025`个元素的数组来生成，然后我们将其与字母`"a"`连接，得到一个包含`1024`个字符的字符串`"a"`。
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Following that we will create a simple function that will accept number of
    entries and data for each of them:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个简单的函数，该函数将接受条目数量和每个条目的数据：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will also add a function that will clear the entire `localStorage` object:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将添加一个函数，用于清除整个`localStorage`对象：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After having this we can create an HTML file, where we will have a few buttons,
    one for clearing all the data and others for filling the storage up with generated
    data:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这之后，我们可以创建一个HTML文件，在那里我们将有几个按钮，一个用于清除所有数据，其他用于填充生成的数据到存储中：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Storage limitations as well as the behavior depend on the browser. The specification
    itself says that user agents should limit the total amount of space allowed for
    storage area. Additionally they should grant the same amount of storage for each
    subdomain (for example, `a.example.com`, `b.example.com`, and so on). There is
    also an option to prompt the user to request more storage; unfortunately, this
    is only currently done by Opera.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 存储限制以及行为取决于浏览器。规范本身说用户代理应该限制存储区域的总空间量。此外，他们应该为每个子域（例如`a.example.com`，`b.example.com`等）提供相同数量的存储空间。还有一个选项可以提示用户请求更多的存储空间；不幸的是，目前只有Opera才这样做。
- en: '![How it works...](img/9282OT_11_03.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9282OT_11_03.jpg)'
- en: There is a configurable property in Firefox called `dom.storage.default_quota`
    that can be found in `about:config`, but you can't really expect the user to set
    an increased value manually there. For IndexDB, there are no limitations on the
    storage size but the initial quota is set to 50 MB.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中有一个名为`dom.storage.default_quota`的可配置属性，可以在`about:config`中找到，但你不能真的指望用户在那里手动设置一个增加的值。对于IndexDB，存储大小没有限制，但初始配额设置为50MB。
- en: There's more...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we are talking about limitations in HTML5 Filesystem API, we have several
    storage type definitions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们谈论HTML5文件系统API中的限制，我们有几种存储类型定义。
- en: Temporary storage is the basic one, so we do not need special permissions to
    obtain it; making it a good pick for caching. Chrome currently has a temporary
    pool of 1 GB and there are plans for IndexedDB and WebSQL to become part of the
    same pool. For temporary storage there are no guarantees for persistence, so it
    can be removed at any time.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 临时存储是基本的，所以我们不需要特殊权限来获取它；这使得它成为缓存的一个不错的选择。Chrome目前有一个1GB的临时池，并且计划将IndexedDB和WebSQL纳入相同的池中。对于临时存储，没有持久性的保证，因此它可以随时被移除。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More on WebSQL can be found on W3C, although the specification is no longer
    developed or maintained [http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WebSQL的更多信息可以在W3C上找到，尽管该规范已不再开发或维护[http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/)。
- en: Persistent storage on the other hand is well persistent. Data remains there
    after restart, and it is there until manually deleted by the user or our application.
    When we do a request file system call, the browser will prompt us for permission
    and if we spend that we will get `QUOTA_EXCEEDE_ERR`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，持久存储是持久的。数据在重新启动后仍然存在，并且直到用户或我们的应用手动删除为止。当我们进行请求文件系统调用时，浏览器将提示我们是否同意，如果我们同意，我们将收到`QUOTA_EXCEEDE_ERR`。
- en: There is also a storage that is of type unlimited, but that is Chrome-specific,
    and intended to be used from extensions and Chrome apps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种类型为无限的存储，但这是Chrome特有的，并且旨在从扩展和Chrome应用中使用。
- en: Some efforts have been taken to standardize the way storage is requested, so
    the Quota API specification, [http://www.w3.org/TR/quota-api/](http://www.w3.org/TR/quota-api/),
    was created for the purpose. The specification itself defines an API to manage
    the usage and availability of local storage resources for various persistent API's.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 已经采取了一些努力来标准化存储请求的方式，因此为此目的创建了Quota API规范，[http://www.w3.org/TR/quota-api/](http://www.w3.org/TR/quota-api/)。规范本身定义了一个API，用于管理各种持久API的本地存储资源的使用和可用性。
- en: 'There is a `StorageQuota` interface where the process of getting more `PERSISTENT`
    data is described. A prefixed version of the implementation is available in Chrome:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`StorageQuota`接口，描述了获取更多`PERSISTENT`数据的过程。Chrome中提供了实现的带前缀版本：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By calling the method, a prompt will appear to the user to ask for permission.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用该方法，将出现提示要求用户请求权限。
- en: Manipulating the browser history
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵浏览器历史
- en: History API allows you to manipulate the browser history using JavaScript. Some
    of the manipulations were available in the user agents for a long time. A new
    feature is an option to add new entries in the history, change the URL show in
    the location bar, and so on.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 历史API允许您使用JavaScript操纵浏览器历史。一些操作在用户代理中很长时间以来就已经可用了。一个新功能是可以在历史中添加新条目，更改在位置栏中显示的URL等。
- en: This means that we can create a single page app that will respect the REST way.
    The pages now can have unique identifier that will lead directly to certain view
    with specific state without doing page reloads or some client-side hacks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以创建一个遵守REST方式的单页面应用。现在页面可以具有唯一的标识符，将直接导航到具有特定状态的特定视图，而无需进行页面重新加载或进行一些客户端端的黑客攻击。
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will use few images, so you can pick your own selection or
    use the ones provided in the example files located under the `img/` folder. The
    images will also be served in `img/` for our web page, so you should have the
    HTTP server running.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一些图片，因此您可以选择自己的选择，或者使用位于`img/`文件夹下的示例文件中提供的图片。这些图片也将在我们的网页中的`img/`中提供，因此您应该运行HTTP服务器。
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s get started:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'We create the HTML code for a cat viewer:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为猫查看器创建HTML代码：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We include a dependency to jQuery and our script, `example.js`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含了对jQuery和我们的脚本`example.js`的依赖：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Optionally we can add some very basic style to make the behavior of the div
    elements more like links, although in the general case we could also use `<a>`
    elements but it''s not always the best idea to override the click behavior on
    anchors. The style could be something similar to the following:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们可以添加一些非常基本的样式，使div元素的行为更像链接，尽管在一般情况下我们也可以使用`<a>`元素，但覆盖锚点的点击行为并不总是最佳主意。样式可能类似于以下内容：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As for the `example.js` file we have a small JSON like structure called `catson`
    that describes our data:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于`example.js`文件，我们有一个称为`catson`的小型类似JSON的结构，描述了我们的数据：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the document is loaded, we check for the support of the history API in
    the current user agent:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档加载时，我们检查当前用户代理中是否支持历史API：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Following this we add an on-click handler for our navigation elements:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的导航元素添加一个点击处理程序：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: At this point you should have a running example, where if you click around,
    you will notice that the browser URL gets changed but we rely on having only one
    page.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该有一个运行中的示例，如果您点击周围，您会注意到浏览器URL已更改，但我们依赖于只有一个页面。
- en: 'If you do a refresh on some of the other URL''s that are generated, you should
    get a message similar to:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新一些其他生成的URL，您应该会收到类似的消息：
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is because we are only simulating the web page, while the page itself does
    not exist.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们只是模拟网页，而页面本身并不存在。
- en: How it works...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The idea behind the History API is simple. It's an object that allows us to
    manipulate browser history through the `window.history` object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 历史API背后的思想很简单。它是一个允许我们通过`window.history`对象操纵浏览器历史的对象。
- en: 'If we want to go one page back we simply call:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想回到上一页，我们只需调用：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Or to go to the next page:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 或者前往下一页：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There is also a more general method that allows us to go + or – `n` pages in
    the history, for example to go three pages back we call:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个更一般的方法，允许我们在历史中向前或向后移动`n`页，例如，要后退三页，我们调用：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The most interesting of all of these methods that come with this API are probably
    the `pushState(state`, `title`, `url)` and `replaceState(state`, `title`, `url)`.
    The first one we used in our example adds a URL to the history stack with the
    given state object. To be completely conformist with the rules we should have
    used the first argument of the method which is the state object that represents
    the current document state. In our case this would have been one cat object for
    the `catison` list.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API提供的所有方法中最有趣的可能是`pushState(state`，`title`，`url)`和`replaceState(state`，`title`，`url)`。我们在示例中使用的第一个方法将具有给定状态对象的URL添加到历史堆栈中。为了完全符合规则，我们应该使用方法的第一个参数，即代表当前文档状态的状态对象。在我们的例子中，这将是`catison`列表的一个cat对象。
- en: Similarly as the `pushState`, the `replaceState` methods are updated rather
    than adding a new state on the history stack with the same arguments.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pushState`类似，`replaceState`方法是更新而不是使用相同参数在历史堆栈上添加新状态。
- en: The state object itself is reachable under the `history.state` variable, similar
    to the `history.state` variable there is also a `history.length` variable for
    the size of the current stack. The `history.state` variable can be used to store
    data for the given segment, making it yet another option for storing data in the
    browser.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 状态对象本身可以通过`history.state`变量访问，类似于`history.state`变量，当前堆栈的大小也有一个`history.length`变量。`history.state`变量可用于存储给定段的数据，这使得它成为浏览器中存储数据的另一个选项。
- en: Note
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about History API on the live specification on WHATWG: [http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在WHATWG的实时规范中阅读有关History API的更多信息：[http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html)。
- en: The first thing you need to consider is making a clever routing so that you
    will not have broken and non-existent URL's. This means that we might need some
    work at the server side so that the state of the URL will be available for rendering.
    The main goal is to improve usability and not to overuse the cool new features,
    so be careful where you really need this functionality.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑的第一件事是制定一个聪明的路由，这样你就不会有损坏和不存在的URL。这意味着我们可能需要在服务器端做一些工作，以便URL的状态可用于呈现。主要目标是提高可用性，而不是过度使用新功能，所以要小心在哪里真正需要这个功能。
- en: For older browsers there is a great polyfill called `history.js`, ([https://github.com/browserstate/history.js](https://github.com/browserstate/history.js))
    that additionally adds few other nice features for development.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旧版浏览器，有一个名为`history.js`的出色polyfill，（[https://github.com/browserstate/history.js](https://github.com/browserstate/history.js)），它还为开发添加了一些其他不错的功能。
- en: There is also a library called `Path.js`, that uses History API for advanced
    routing, but also abuses `hashbangs` (`#`) to achieve nice functionality.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`Path.js`的库，它使用History API进行高级路由，但也滥用`hashbangs`（`#`）来实现良好的功能。
- en: While we are talking about complete abuse, there is a whole game written that
    uses `history.replaceState` to make the URL bar a screen. The game is called Abaroids
    and can be found at [http://www.thegillowfamily.co.uk/](http://www.thegillowfamily.co.uk/).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论完全滥用时，有一个整个游戏是使用`history.replaceState`来使URL栏成为一个屏幕。这个游戏叫做Abaroids，可以在[http://www.thegillowfamily.co.uk/](http://www.thegillowfamily.co.uk/)找到。
