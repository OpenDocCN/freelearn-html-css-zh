- en: Chapter 4. Building Robust Applications with HTML5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用HTML5构建健壮的应用程序
- en: Since the advent of ActionScript 3, Flash developers have become accustomed
    to developing in an **object-oriented programming** (**OOP**) paradigm. When transitioning
    to JavaScript, many developers with an experience of OOP would initially be put
    off by the syntax JavaScript uses to accomplish the same functionality. However,
    a misunderstanding of the syntax may lead to a misunderstanding of the functionality.
    Therefore, in this chapter we will cover the use of JavaScript OOP, Events, and
    Event Listeners as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从ActionScript 3出现以来，Flash开发人员已经习惯于以面向对象编程（OOP）范式进行开发。当转换到JavaScript时，许多具有OOP经验的开发人员可能会对JavaScript用于实现相同功能的语法感到不满。然而，对语法的误解可能导致对功能的误解。因此，在本章中，我们将介绍JavaScript
    OOP、事件和事件监听器的使用。
- en: 'In this chapter we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: JavaScript class structure, usage, and syntax
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript类结构、用法和语法
- en: Object inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象继承
- en: Class constructors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类构造函数
- en: Tools and frameworks to aid in development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助开发的工具和框架
- en: Creating custom events and listeners
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义事件和监听器
- en: Writing object-oriented JavaScript
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写面向对象的JavaScript
- en: In 2006, when Adobe released Flash Player 9 with the inclusion of ActionScript
    3 support, the Flash development community saw a major paradigm shift in the way
    they developed their Flash applications. Prior to the use of ActionScript 3, developers
    were tasked with writing their applications in ActionScript 2, which is primarily
    used as a scripting programming language. ActionScript 3 was designed as a true
    object-oriented programming language with strict typing, which allows for code
    to be written in a reusable, more controlled manner.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年，当Adobe发布带有ActionScript 3支持的Flash Player 9时，Flash开发社区看到了他们开发Flash应用程序的一次重大范式转变。在使用ActionScript
    3之前，开发人员被要求用ActionScript 2编写他们的应用程序，这主要用作脚本编程语言。ActionScript 3被设计为一个真正的面向对象编程语言，具有严格的类型，允许以可重用、更受控制的方式编写代码。
- en: With the use of ActionScript 3 and the new ActionScript Virtual Machine compiler
    released for Flash Player 9, the code within Flash applications was not only written
    in an OOP structure but could also run up to 10 times faster than the previous
    legacy Flash applications. Over time, Flash developers have become accustomed
    to writing proper OOP structured code, which has allowed them to easily transition
    their programming skill set to other languages such as Java, C++, or C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用ActionScript 3和为Flash Player 9发布的新ActionScript虚拟机编译器，Flash应用程序中的代码不仅以OOP结构编写，而且还可以比以前的传统Flash应用程序运行快10倍。随着时间的推移，Flash开发人员已经习惯于编写适当的OOP结构化代码，这使他们能够轻松地将他们的编程技能转移到其他语言，如Java、C++或C#。
- en: 'The use of the OOP paradigm in JavaScript is a bit tricky to understand at
    first, so let''s create an example class structure in ActionScript 3 and port
    it directly to JavaScript to see the visual syntax differences. In this example,
    we will create a sample "Player" class that will emulate the basic functionality
    of a character in a game. Rather than setting up each Player in our game with
    a separate code, based on functionality, we will use the `Player` class to create
    as many players as we need in our game and alter their properties via constructors,
    getters, setters, and public variables. To get a better idea of this concept,
    consider the following code example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中使用OOP范式起初有点难以理解，因此让我们创建一个在ActionScript 3中的示例类结构，并直接将其移植到JavaScript中，以查看视觉语法的差异。在这个示例中，我们将创建一个名为“Player”的示例类，它将模拟游戏中角色的基本功能。我们将使用“Player”类来创建我们游戏中所需的任意数量的玩家，并通过构造函数、getter、setter和公共变量来改变它们的属性，而不是根据功能为我们的游戏中的每个玩家设置单独的代码。为了更好地理解这个概念，请考虑以下代码示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although simplified for example purposes, this class example should look pretty
    familiar to any developer with the experience of coding in ActionScript 3\. With
    this class within our Flash project, we can import it and instantiate it at any
    time within our application. Declared within the object are properties and methods
    that can be called by the parent object to manipulate the data for the specific
    `Player` object, and this is typical of any class. When you are ready to add a
    new Player into your application, we can instantiate a new object with the following
    ActionScript 3 code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管为了示例目的而简化，这个类示例对于任何有ActionScript 3编码经验的开发人员来说应该看起来非常熟悉。在我们的Flash项目中声明了这个类，我们可以随时导入它并实例化它。在对象内部声明了可以被父对象调用以操纵特定“Player”对象数据的属性和方法，这是任何类的典型特征。当你准备在你的应用程序中添加一个新的玩家时，我们可以用以下ActionScript
    3代码实例化一个新对象：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By appending the required values into the constructor, we give our Player a
    unique name as well as an initial value as to how many lives this Player will
    have. We now have our new Player, which we can manipulate in our imaginary game.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所需的值附加到构造函数中，我们为我们的玩家提供了一个独特的名称，以及这个玩家将拥有多少生命的初始值。现在我们有了我们的新玩家，在我们的想象游戏中可以操纵它。
- en: 'Now let''s take a look at the same class that is rewritten in JavaScript:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下在JavaScript中重新编写的相同类：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At first glance one can see that there is no class declaration, which one would
    be familiar with, as in many other programming languages. Instead, when creating
    "classes" in JavaScript, one uses a function to simulate the usage of a traditional
    class structure. Package declarations are removed from the equation as well as
    the inclusion of JavaScript is appended to the HTML document rendering the web
    page. By all means, pending it was logical; one could separate all one's JavaScript
    classes into separate files for ease of development. However, when publishing
    large amounts of JavaScript to a public-hosted environment, to conserve the amount
    of requests to the web server for data, JavaScript should be consolidated as much
    as possible. We will dig further into the preparation of your HTML5 projects for
    production environments in [Chapter 10](ch10.html "Chapter 10. Preparing for Release"),
    *Preparing for Release*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，人们会发现没有类声明，这是许多其他编程语言中熟悉的。相反，在JavaScript中创建“类”时，使用函数来模拟传统类结构的使用。包声明也从等式中移除，JavaScript的包含也附加到HTML文档中，渲染网页。在逻辑上，可以将所有JavaScript类分开放在单独的文件中以便于开发。但是，当将大量JavaScript发布到公共托管环境时，为了节省对Web服务器的数据请求，应尽可能合并JavaScript。我们将在[第10章](ch10.html
    "第10章。准备发布")中更深入地探讨为生产环境准备HTML5项目，*准备发布*。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One thing must be noted at this point of time. With the lack of strict typing
    and many other specific class structure rules, the same JavaScript functionality
    can be written in numerous ways. During the course of this chapter, I have written
    the examples to be as user-friendly as possible in order to allow us to examine
    the syntax better.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此时必须注意一点。由于缺乏严格的类型和许多其他特定的类结构规则，同样的JavaScript功能可以用多种方式编写。在本章的过程中，我已经尽可能地编写了示例，以便让我们更好地检查语法。
- en: Class syntax
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类语法
- en: In the initial JavaScript class example, we examined the differences between
    ActionScript 3's class structure as compared to JavaScript when creating object-oriented
    code. The example used one of the more traditional methods of creating a class
    in JavaScript by using a function in place of the typical class declaration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始的JavaScript类示例中，我们比较了ActionScript 3的类结构与JavaScript在创建面向对象代码时的差异。该示例使用了JavaScript中创建类的更传统方法之一，即使用函数代替典型的类声明。
- en: Functions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'Many of the example JavaScript functions we have used in code examples so far
    have shown some of the different ways in which we can define a new function. As
    I just mentioned, depending on what the developers are comfortable with, they
    may choose to write their functions in JavaScript in one of the following ways:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在代码示例中使用的许多JavaScript函数示例已经展示了定义新函数的不同方式。正如我刚才提到的，根据开发人员的舒适程度，他们可能选择以以下一种方式之一在JavaScript中编写函数：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each of the three `console.log` outputs in the previous example would yield
    the proper Boolean return of *true*. It is also worth noting that the order of
    the function definitions and function usage is not required to be as demonstrated
    in the preceding sample of code. The following example would yield the exact same
    result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，三个`console.log`输出中的每一个都将产生正确的布尔返回值*true*。值得注意的是，函数定义和函数使用的顺序不需要像前面的代码示例中所示的那样。以下示例将产生完全相同的结果：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When attempting to call a function that has not been defined, a `ReferenceError`
    error will be dispatched and displayed in the JavaScript console.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调用未定义的函数时，将会触发`ReferenceError`错误，并在JavaScript控制台中显示。
- en: '![Functions](img/3325OT_04_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![函数](img/3325OT_04_01.jpg)'
- en: Although our application would continue running despite this runtime error,
    it would generally mean that there is an issue with our code. Rather than having
    the default `ReferenceError` error sent to the JavaScript console, we could use
    a simple condition to handle this issue within our code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序可能会继续运行，尽管出现此运行时错误，但这通常意味着我们的代码存在问题。我们可以使用简单的条件来处理代码中的此问题，而不是将默认的`ReferenceError`错误发送到JavaScript控制台。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Variable scope
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量范围
- en: Understanding properly how variables scope in JavaScript is a critical step
    in understanding the core aspects of the language. Scope refers to the accessibility
    that the variables have to other parts of the code when they are created somewhere
    within your code. Variables can be instantiated and referenced depending on the
    syntax used to declare them. JavaScript utilizes what many refer to as *function
    scope*, whereby all variables and functions scope in the same manner. At the top
    of the scope chain are the global variables and functions. As with all programming
    paradigms, global means everything, and a global variable or function is accessible
    anywhere else within your code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正确理解JavaScript中变量范围是理解语言核心方面的关键步骤。范围是指变量在代码的其他部分创建时对其可访问性。变量可以根据用于声明它们的语法进行实例化和引用。JavaScript利用许多人所说的*函数范围*，在其中所有变量和函数的范围都相同。在范围链的顶部是全局变量和函数。与所有编程范式一样，全局意味着一切，全局变量或函数可以在代码的任何其他地方访问。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code demonstrates the use of a global variable. Since the variable name
    is declared above the scope of the function that uses it, there would be no errors
    when running this code. However, variables can also be locally declared from within
    a function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了全局变量的使用。由于变量名在使用它的函数范围之上声明，因此运行此代码时不会出现错误。但是，变量也可以在函数内部局部声明。
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the Player's name (which in this case is John) is created within the `getName`
    function, it is not globally accessible to any of the code outside of that function.
    As simple as the concept of global and local variables is, when you begin to consider
    the lack of strict typing and the use of exact variable names for global and local
    variables, your head may begin to spin. Not to worry, this is another one of the
    typical learning curve issues developers have with JavaScript. But as mentioned
    before, mastering variable scope in JavaScript is one of the essential skills
    every good HTML5 developer must have.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Player的名称（在这种情况下是John）是在`getName`函数内创建的，因此无法全局访问该函数之外的任何代码。全局和局部变量的概念虽然简单，但当你开始考虑严格类型的缺乏以及全局和局部变量的确切变量名称时，你可能会感到头晕。不用担心，这是JavaScript开发人员在典型学习曲线问题中遇到的另一个问题。但正如之前提到的，掌握JavaScript中的变量作用域是每个优秀的HTML5开发人员必须具备的基本技能之一。
- en: 'To demonstrate some of the issues presented, and to allow you to fully view
    scoping in action, let''s review the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一些问题，并允许您完全查看作用域的运行情况，让我们回顾以下示例：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The previous example, although an illogical way to output the characters A to
    F, demonstrates many of the ways in which variables and functions can be manipulated
    to access data from specific areas in your application's scope chain.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上面的例子是一个不合逻辑的输出字符A到F的方式，但它展示了许多变量和函数可以被操纵以访问应用程序作用域链中特定区域数据的方式。
- en: Public and private variables and functions
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共和私有变量和函数
- en: The next step for understanding variables and functions within JavaScript is
    by learning how to create and utilize public and private members. Unlike in ActionScript
    3, variables are not typed as private or public, thus making the syntax a little
    harder to understand.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 理解JavaScript中的变量和函数的下一步是学习如何创建和利用公共和私有成员。与ActionScript 3不同，变量不是私有或公共类型的，因此语法稍微难以理解。
- en: Local or private variables
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 局部或私有变量
- en: Private (or local) variables are declared by utilizing the `var` keyword when
    creating variables within an object. The resulting variable will only be accessible
    within that specific object and would require a getter and setter method to allow
    for external manipulation. This manner of variable declaration is similar to using
    the `private` keyword when creating variables in ActionScript 3\. A general rule
    of thumb in OOP development is to use private variables whenever possible as it
    will lead to far less issues with variable corruption or other misusage.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在对象内创建变量时使用`var`关键字声明私有（或局部）变量。结果变量只能在特定对象内部访问，并且需要getter和setter方法来允许外部操作。这种变量声明方式类似于在ActionScript
    3中创建变量时使用`private`关键字。面向对象编程开发的一个一般准则是尽可能使用私有变量，因为这将大大减少变量损坏或其他错误使用的问题。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Public variables
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公共变量
- en: Public variables or properties are declared by using the `this.myVariableName`
    syntax. Similar to the `public` keyword when creating variables in ActionScript
    3, public variables in JavaScript are accessible not only to the code within the
    object's scope chain but also from outside of the object it was created in as
    well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`this.myVariableName`语法声明公共变量或属性。与在ActionScript 3中创建变量时使用`public`关键字类似，JavaScript中的公共变量不仅可以在对象作用域链内的代码中访问，还可以在创建它的对象之外访问。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Private functions
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 私有函数
- en: Private functions, which are only accessible within the object scope, can be
    written in a couple of different ways.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 只能在对象作用域内访问的私有函数可以用几种不同的方式编写。
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both examples demonstrated previously yield a private function. Any attempt
    to call the function from outside of the object scope would result in a runtime
    error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 先前演示的两个例子都产生了一个私有函数。任何尝试从对象作用域之外调用该函数的尝试都会导致运行时错误。
- en: Public functions
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公共函数
- en: Public or privileged functions, like public variables, are accessible from outside
    of the object they were created in, and are created using the `this.myFunctionName
    = function() {...}` syntax.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 公共或特权函数，像公共变量一样，可以从创建它们的对象之外访问，并使用`this.myFunctionName = function() {...}`语法创建。
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Prototype
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型
- en: One of the more confusing aspects of a JavaScript object's syntax is the use
    of the prototype object. As we have seen in the examples and explanations up to
    this point, everything in JavaScript is an object, and within every JavaScript
    object is a prototype property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象语法中更令人困惑的一个方面是原型对象的使用。正如我们在此之前的示例和解释中所看到的，JavaScript中的一切都是对象，而每个JavaScript对象中都有一个原型属性。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you were using Flash back in the days of ActionScript 1 or ActionScript 2,
    you may be familiar with the concept of the prototype object ([http://help.adobe.com/en_US/as2/reference/flashlite/WS5b3ccc516d4fbf351e63e3d118ccf9c47f-7ec2.html](http://help.adobe.com/en_US/as2/reference/flashlite/WS5b3ccc516d4fbf351e63e3d118ccf9c47f-7ec2.html)).
    This object was utilized in both programming languages, but dropped on the release
    of ActionScript 3.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在ActionScript 1或ActionScript 2的时代使用Flash，您可能熟悉原型对象的概念（[http://help.adobe.com/en_US/as2/reference/flashlite/WS5b3ccc516d4fbf351e63e3d118ccf9c47f-7ec2.html](http://help.adobe.com/en_US/as2/reference/flashlite/WS5b3ccc516d4fbf351e63e3d118ccf9c47f-7ec2.html)）。这个对象在两种编程语言中都被使用，但在ActionScript
    3发布时被放弃。
- en: To see this concept in action, let's start simple and work our way forward into
    more complex usages of the prototype object. We will start by looking at the prototype
    object for a new empty object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个概念的运行情况，让我们从简单开始，逐步向更复杂的原型对象用法前进。我们将首先查看一个新空对象的原型对象。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running this code in a web browser would result in a JavaScript log that would
    resemble something very close to the following code, if not the same:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中运行此代码将导致JavaScript日志，其结果非常接近以下代码，如果不是相同的话：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This output can give us a lot more sense of what the prototype object is really
    about. As you already know from previous ActionScript 3 development, object variable
    types come with many built-in methods to manipulate the content within it. Looking
    at the output of the prototype of our `Player` object, you may notice that many
    of these familiar methods and properties are listed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出可以让我们更加了解原型对象的真正含义。正如你已经从之前的ActionScript 3开发中了解到的，对象变量类型带有许多内置方法来操作其中的内容。查看我们的“Player”对象的原型的输出，你可能会注意到列出了许多这些熟悉的方法和属性。
- en: 'We can use this prototype object to append new properties to an object at any
    time. Consider the following example where we create a simplified `Player` object
    and append the move functionality to it via the prototype object rather than directly
    within the object itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原型对象随时向对象附加新属性。考虑以下示例，我们创建了一个简化的“Player”对象，并通过原型对象而不是直接在对象本身内部附加移动功能：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The same concept could be used for overriding the default object behavior. By
    modifying the move properties via the prototype object, any further calls to the
    move method would result in a newly appended behavior.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的概念可以用于覆盖默认对象行为。通过修改原型对象的移动属性，对移动方法的任何进一步调用都将导致新附加的行为。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Keep in mind that these changes are targeted to the object itself and not the
    instance. Therefore, these changes will affect each and every Player instance
    demonstrated as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些更改是针对对象本身而不是实例。因此，这些更改将影响到每个“Player”实例，如下所示：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So why is this important? While depending on how your application is built,
    by utilizing the prototype object, you can easily append shared code to objects
    directly, without the need for coding the same thing more than once. Less code
    means less memory, and it will always make your life easier when it comes to maintaining
    your projects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么这很重要呢？根据你的应用程序是如何构建的，通过利用原型对象，你可以直接向对象附加共享代码，而无需多次编写相同的代码。代码越少意味着内存占用越少，这将使你在维护项目时更加轻松。
- en: Instance types
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例类型
- en: 'As you begin to float around all of this new JavaScript code and syntax in
    these examples and in your own, adding checks and conditions for instance types
    will prove to be an important addition. The lack of strict typing will require
    you to write and maintain clean and optimized code to get your applications working
    properly. Consider some of the following code snippets for acquiring information
    on the instance type of our `Player` object:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在这些示例和自己的JavaScript代码中浮动时，添加检查和条件以获取实例类型将证明是一个重要的补充。缺乏严格的类型将要求你编写和维护干净和优化的代码，以使你的应用程序正常工作。考虑一些以下代码片段，以获取有关我们的“Player”对象实例类型的信息：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each of these calls to the `console.log` method are performing different ways
    to look up the instance of the `Player` object. When we run this code in a web
    browser and open up the developer console, we get the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对`console.log`方法的每次调用都执行查找“Player”对象实例的不同方式。当我们在Web浏览器中运行此代码并打开开发者控制台时，我们会得到以下输出：
- en: '![Instance types](img/3325OT_04_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![实例类型](img/3325OT_04_02.jpg)'
- en: The initial `object` output is a result of the `typeof()` function call made
    on the `Player` object. The second output is the code block returned when calling
    the constructor of the `Player` object. Finally, the conditional console call
    (`console.log(player instanceof Object)`) results in the Boolean return in the
    console letting us know that the `instanceof` condition is true.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的“object”输出是对“Player”对象的`typeof()`函数调用的结果。第二个输出是调用“Player”对象的构造函数时返回的代码块。最后，条件控制台调用（`console.log(player
    instanceof Object)`）在控制台中返回布尔值，让我们知道“instanceof”条件为真。
- en: Object literals
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象字面量
- en: 'Literals are simply a shorter method to define arrays and objects within JavaScript.
    We are already creating new objects in JavaScript with the following syntax:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量只是在JavaScript中定义数组和对象的一种更简短的方法。我们已经使用以下语法在JavaScript中创建新对象：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can further extend the preceding syntax by creating the internals of the
    object directly within the variable declaration.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在变量声明中直接创建对象的内部来进一步扩展前面的语法。
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This `Object` syntax, however, creates major issues with its lack of reusability
    as its instance already will have existed when it is created. Since there is no
    need to instantiate the object, we can continue our code by referencing its properties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种“Object”语法在重用方面存在重大问题，因为它的实例在创建时已经存在。由于不需要实例化对象，我们可以通过引用其属性来继续我们的代码。
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Constructors
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: As we have seen in some of the previous examples, in comparison to ActionScript
    3, the object constructor syntax is a bit different than one would typically be
    used to. Since classes are just functions, we can just place the code typically
    found within the constructor directly within the class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的一些示例中所看到的，与ActionScript 3相比，对象构造函数的语法与通常使用的有些不同。由于类只是函数，我们可以直接将通常在构造函数中找到的代码放在类内部。
- en: You can easily look up the reference to the function that initially created
    an object, by calling the `constructor` property on it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用对象的`constructor`属性，你可以轻松查找最初创建对象的函数的引用。
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When attempting to look up the constructor of a built-in object type such as
    an array, string, or date, the output will conceal the inner code and display
    a warning of the use of native code as follows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试查找内置对象类型（如数组、字符串或日期）的构造函数时，输出将隐藏内部代码，并显示使用原生代码的警告。
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This would generate the following in the browser''s JavaScript console:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器的JavaScript控制台中生成以下内容：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inheritance
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: By using the `call()` method on a pre-existing object, we can update the reference
    to `this` from the object itself to somewhere else in the code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在现有对象上使用`call()`方法，我们可以将对`this`的引用从对象本身更新到代码中的其他位置。
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example demonstrates a simple inheritance of the `Player` object within
    the new `John` object. This allows us to access the internal values within `Player`
    and use them externally within the `John` class. In this example case, we make
    John 35 years older than the default `Player`. We can also use the prototype object
    to declare object inheritance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了在新的“John”对象中简单继承“Player”对象。这使我们能够访问“Player”中的内部值，并在“John”类中外部使用它们。在这个例子中，我们让John比默认的“Player”大35岁。我们还可以使用原型对象来声明对象继承。
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the new `jill` object is created, it inherits all of the base properties
    and functions from `Player` as the prototype reference has declared object inheritance.
    The resulting output for this example on page load would display the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的“jill”对象时，它继承了来自“Player”的所有基本属性和函数，因为原型引用已经声明了对象继承。在页面加载时，此示例的输出将显示以下内容：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Listing object properties
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出对象属性
- en: 'At any point you can look up the available properties within an object by using
    the `Object.getOwnPropertyNames()` method. Keeping private and public syntax in
    mind, let''s review the following example to view the output when looking up an
    object''s properties:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，您都可以使用`Object.getOwnPropertyNames()`方法查找对象中可用的属性。在考虑私有和公共语法的情况下，让我们回顾以下示例，查看查找对象属性时的输出：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Again, with public and private variables in mind, only variables created with
    the keyword `this` are visible outside of the object scope. Executing the preceding
    code example would provide the following array of properties'' names as the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，考虑到公共和私有变量，只有使用关键字“this”创建的变量才能在对象范围之外可见。执行前面的代码示例将提供以下属性名称数组作为输出：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Making OOP in JavaScript easier
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使JavaScript中的面向对象编程更容易
- en: To many developers, the culmination of all of these workarounds and syntax changes
    that come with developing object-oriented JavaScript may seem just like a laundry
    list of "hacks". Regardless of your point of view on the matter, there are many
    options available to aid in building large-scale JavaScript-based applications
    with a more traditional development flow. In [Chapter 6](ch06.html "Chapter 6. HTML5
    Frameworks and Libraries"), *HTML5 Frameworks and Libraries*, we will dig into
    many of the popular JavaScript libraries and frameworks available, and how they
    can be used to not only speed up your development time but also provide a more
    solid end result on all modern browsers and devices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多开发人员来说，开发面向对象JavaScript所需的所有这些变通和语法更改似乎就像是一长串“黑客”清单。无论您对此事的看法如何，都有许多选项可用于帮助构建具有更传统开发流程的大规模基于JavaScript的应用程序。在[第6章](ch06.html
    "第6章。HTML5框架和库")中，*HTML5框架和库*，我们将深入研究许多流行的JavaScript库和框架，以及它们如何不仅可以加快您的开发时间，还可以在所有现代浏览器和设备上提供更可靠的最终结果。
- en: JavaScript events
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript事件
- en: 'As with most languages, events are what really brings an application to life.
    Without the use of events, programs would usually just run from start to finish
    without the need for human interaction. JavaScript events are built around the
    asynchronous event model. Rather than checking continually to see if a condition
    is met, events can use call-back structures, like in ActionScript, to execute
    code once an event has been fired. A great example of this, which you may have
    already seen in many other examples thus far:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，事件是真正使应用程序活跃起来的。如果没有事件的使用，程序通常只会从开始到结束运行，而不需要人类交互。JavaScript事件建立在异步事件模型的基础上。事件可以使用回调结构，例如在ActionScript中，来执行一旦事件被触发就执行代码，而不是不断地检查是否满足条件。这方面的一个很好的例子，你可能已经在许多其他示例中看到过：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We use this Event Listener on the `window` object to allow our code to determine
    when the `window` object will finish loading, so that we can call our initial
    method to begin JavaScript manipulation of our document.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“window”对象上使用此事件监听器，以便让我们的代码确定“window”对象何时完成加载，以便我们可以调用我们的初始方法来开始JavaScript操作我们的文档。
- en: Keyboard and mouse events
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘和鼠标事件
- en: 'Mouse events are another one of the core elements almost all JavaScript projects
    contain. Although we will be using these events within the examples all throughout
    this book, it''s worth reviewing a consolidated list of not only the mouse, but
    keyboard and touch events as well, so that you can have a better understanding
    of what is easily available to you for input event listening. The different keyboard
    and mouse events are listed as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件是几乎所有JavaScript项目都包含的核心元素之一。虽然我们将在整本书中的示例中使用这些事件，但值得回顾一下不仅是鼠标，还有键盘和触摸事件的整合列表，这样你就可以更好地了解可供您用于输入事件监听的内容。不同的键盘和鼠标事件列举如下：
- en: '**mousedown:** A mouse button has been pressed down'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mousedown：**鼠标按钮已被按下'
- en: '**mouseup:** A mouse button has been released'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mouseup：**鼠标按钮已被释放'
- en: '**click:** A mouse button has been clicked'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**click：**鼠标按钮已被单击'
- en: '**dblclick:** A mouse button has been double-clicked'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dblclick：**鼠标按钮已被双击'
- en: '**contextmenu:** Some action to trigger a context menu has occurred'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**contextmenu：**已触发某个操作以显示上下文菜单'
- en: '**scrolling:** The context has been moved on the scroll axis'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scrolling：**上下文已在滚动轴上移动'
- en: '**keydown:** A keyboard key has been pressed into the down state'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**keydown：**键盘键已被按下'
- en: '**keypress:** A keyboard key has been pressed and released'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**keypress：**键盘键已被按下并释放'
- en: '**keyup:** A keyboard key has been released'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**keyup：**键盘键已被释放'
- en: Touch events
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸事件
- en: 'Touch event support is growing closer to a set standard; however, you will
    notice support and feature set differences depending on what device and browser
    you are testing on. It''s worth noting that just like Flash applications running
    on a touch interface, you can use the mouse events with no issues, and still support
    the use of an actual mouse. However, as a mouse can only click on one point at
    a time, if your application will need multitouch support, you will have to begin
    utilizing the touch event structure. In the next two chapters, we will look further
    into the use of HTML on touch devices and how the development differs. The touch
    events supported are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸事件支持正逐渐接近一套标准；但是，您会注意到根据您正在测试的设备和浏览器的支持和功能集的差异。值得注意的是，就像在触摸界面上运行的Flash应用程序一样，您可以使用鼠标事件而没有问题，并且仍然支持实际鼠标的使用。但是，由于鼠标一次只能点击一个点，如果您的应用程序需要多点触控支持，您将不得不开始使用触摸事件结构。在接下来的两章中，我们将进一步探讨在触摸设备上使用HTML的方式以及开发的区别。支持的触摸事件如下：
- en: '**touchstart:** A user has started to touch an element'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: touchstart：用户已开始触摸元素
- en: '**touchmove:** A user has moved the touch position since touchstart'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: touchmove：用户自touchstart以来移动了触摸位置
- en: '**touchend:** A user has removed his/her finger from the element'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: touchend：用户已经从元素中移开手指
- en: Custom events
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义事件
- en: 'Having the ability to create custom events and dispatch them to waiting Event
    Listeners allows you to further extend your application''s OOP syntax and structure.
    Typically, as a Flash developer using ActionScript 3, you would utilize the `flash
    events` class to create custom events so as to create the flow of communication
    from class to class. In its simplest form, it would look like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有创建自定义事件并将其分派给等待事件监听器的能力，可以进一步扩展应用程序的面向对象编程语法和结构。通常，作为使用ActionScript 3的Flash开发人员，您会利用`flash
    events`类来创建自定义事件，以便从一个类到另一个类创建通信流。在其最简单的形式中，它看起来像下面这样：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As with most of the functionality in ActionScript 3, to optimize the application''s
    file size and execution speed, packages must be directly imported into the project
    when utilizing extended internal functionality. Therefore, when creating and dispatching
    events in ActionScript 3, we should always import the `Event` and `EventDispatcher`
    classes, after which we can instantiate a new event with our custom event type
    that is supplied as a string. When the event is dispatched, there will need to
    be an Event Listener to execute further code to complete the event sequence within
    your application. I am sure you are well aware that the typical Event Listener
    in ActionScript 3 is described in the following syntax:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与ActionScript 3中的大多数功能一样，为了优化应用程序的文件大小和执行速度，在使用扩展的内部功能时，必须直接导入包。因此，在ActionScript
    3中创建和分派事件时，我们应该始终导入`Event`和`EventDispatcher`类，之后我们可以用提供为字符串的自定义事件类型实例化一个新事件。当事件被分派时，将需要一个事件监听器来执行进一步的代码，以完成应用程序中的事件序列。我相信您非常清楚，ActionScript
    3中的典型事件监听器描述如下语法：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the same ActionScript 3 syntax like all Event Listener setups, the custom
    event type, which is again in the form of a string, is supplied to the identifier.
    The second parameter supplied is always the function to be called once this listener
    has fired. The final three parameters control bubbling and weak referencing for
    event control and memory cleanup.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与所有事件监听器设置相同的ActionScript 3语法，自定义事件类型再次以字符串形式提供给标识符。提供的第二个参数始终是一旦此监听器触发将要调用的函数。最后三个参数控制事件控制和内存清理的冒泡和弱引用。
- en: Fortunately, the customized events' setup and structure in JavaScript are extremely
    similar with some obvious differences. Consider this working example in comparison
    to what we just reviewed and what you already know about events in ActionScript
    3.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript中自定义事件的设置和结构与一些明显的区别非常相似。考虑这个工作示例，与我们刚刚审查过的内容以及您已经了解的ActionScript
    3中的事件相比。
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Apart from the lack of imported classes, this event example should look pretty
    familiar in the eyes of any Flash developer. As with majority of the examples
    in this book, we wait for the window to load with an Event Listener that we have
    often seen up to this point. Within the `init` function, we start by creating
    our Event Listener. In this case, we append the listener to the document; however,
    this could be appended to any object within your code. Note that not only is the
    method to create a new Event Listener exactly the same (`addEventListener`), but
    the syntax of the initial two parameters is the same as well. The final Boolean
    value supplied controls event bubbling, which we will refer back to in a while.
    The remaining code within the `init` function contains our event instantiation
    as well as the dispatching of that event. Again, thanks to the glory that is,
    ECMAScript, the syntax and structure of the custom event is nearly identical.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缺少导入的类之外，这个事件示例在任何Flash开发人员眼中应该看起来非常熟悉。与本书中大多数示例一样，我们等待窗口加载一个我们到目前为止经常看到的事件监听器。在`init`函数中，我们首先创建我们的事件监听器。在这种情况下，我们将监听器附加到文档；但是，这可以附加到代码中的任何对象。请注意，不仅创建新事件监听器的方法完全相同（`addEventListener`），而且初始两个参数的语法也是相同的。提供的最后一个布尔值控制事件冒泡，我们稍后将回顾。`init`函数中的剩余代码包含我们的事件实例化以及该事件的分派。再次感谢ECMAScript的荣耀，自定义事件的语法和结构几乎是相同的。
- en: While creating our event type in JavaScript with the `createEvent()` method,
    the availability of event modules depends on the DOM Level support that the viewing
    browser has. At the time of writing this book, majority of the browsers are moving
    towards full support of the DOM Level 3 Events, which include UIEvent, DOMFocus,
    DOMActivate, Event, MouseEvent, MutationEvent, TextEvent, KeyboardEvent, and HTMLEvent.
    You can always check out the complete list of currently available or future specified
    DOM Level 3 Events by heading over to [http://www.w3.org/TR/DOM-Level-3-Events/](http://www.w3.org/TR/DOM-Level-3-Events/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中使用`createEvent()`方法创建我们的事件类型时，事件模块的可用性取决于浏览器的DOM级别支持。在撰写本书时，大多数浏览器都在向全面支持DOM级别3事件迈进，其中包括UIEvent、DOMFocus、DOMActivate、Event、MouseEvent、MutationEvent、TextEvent、KeyboardEvent和HTMLEvent。您可以通过访问[http://www.w3.org/TR/DOM-Level-3-Events/](http://www.w3.org/TR/DOM-Level-3-Events/)来查看当前可用或未来指定的DOM级别3事件的完整列表。
- en: The third parameter of the `addEventListener` method specifies whether the registered
    Event Handler captures the specified event or not. If the Event Handler captures
    an event, then each time the event occurs on the element or its descendants, the
    Event Handler will be called.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener`方法的第三个参数指定注册的事件处理程序是否捕获指定的事件。如果事件处理程序捕获事件，那么每次事件发生在元素或其后代上时，事件处理程序都将被调用。'
- en: Event bubbling
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件冒泡
- en: When an event is dispatched, it will follow the object's parent tree to the
    absolute parent object until it is either handled or stopped. This behavior is
    known as event bubbling and is found in ActionScript 3 as well as JavaScript event
    structure. In Flash projects, an event will bubble all the way to the main object
    or in most cases, the Stage. In JavaScript, the event will bubble to the document
    object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被分派时，它将遵循对象的父树直到绝对父对象，直到它被处理或停止。这种行为称为事件冒泡，它也存在于ActionScript 3和JavaScript事件结构中。在Flash项目中，事件将一直冒泡到主对象或在大多数情况下是舞台。在JavaScript中，事件将冒泡到文档对象。
- en: 'In the following example, we will examine dealing with the `mousedown` event
    on the document and object by controlling the propagation of the event:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将研究如何通过控制事件的传播来处理文档和对象上的`mousedown`事件：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This JavaScript snippet applies a `mousedown` Event Listener to both an element
    within the document as well as the document itself. If the user was to click on
    the element within the page, both Event Listeners would be called, resulting in
    two different handlers handling the same mouse click. Although this may be handy
    in some applications, the natural way to deal with this issue and only allow a
    single handler to be called is by stopping the flow of the event bubbling with
    the `stopPropagation()` method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JavaScript片段为文档中的元素以及文档本身都应用了`mousedown`事件监听器。如果用户在页面中的元素上点击，那么两个事件监听器都会被调用，导致两个不同的处理程序处理相同的鼠标点击。虽然在某些应用程序中这可能很方便，但处理这个问题的自然方式是通过使用`stopPropagation()`方法停止事件冒泡的流程，从而只允许调用单个处理程序。
- en: Dealing with event propagation in JavaScript is identical to what you are used
    to in ActionScript 3\. At any point in the event flow, you can easily stop the
    traversal of the event by calling either the `stopPropagation()` or `stopImmediatePropagation()`
    method. If you are familiar with these methods from ActionScript 3 development,
    you will already know that they are almost identical by nature. The only difference
    is that the `stopImmediatePropagation()` call stops the event flow from reaching
    any further Event Listeners in the current node.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中处理事件传播与在ActionScript 3中所习惯的方式是相同的。在事件流的任何时刻，您都可以通过调用`stopPropagation()`或`stopImmediatePropagation()`方法轻松地停止事件的传播。如果您熟悉ActionScript
    3开发中的这些方法，您将知道它们在本质上几乎是相同的。唯一的区别是`stopImmediatePropagation()`调用会阻止事件流到达当前节点中的任何其他事件侦听器。
- en: Putting it all together
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: At the end of the day, all of these code examples only define each of the individual
    pieces of JavaScript's functionality. Continuing with our `Player` class concept
    that we have been using throughout this chapter, we then put some finishing touches
    to our example "Player in a game" class structure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，所有这些代码示例只是定义了JavaScript功能的各个部分。继续使用本章节中一直在使用的`Player`类概念，我们对我们的示例“游戏中的玩家”类结构进行了一些润色。
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Though still a simple example of what all this could look like in a single
    package, this example encompasses many of the features we have looked at within
    this chapter:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这仍然是一个简单的例子，展示了在一个单一包中可能具备的许多我们在本章中看到的特性：
- en: '![Putting it all together](img/3325OT_04_03.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![把所有东西放在一起](img/3325OT_04_03.jpg)'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Although this chapter covers the main concepts surrounding the syntax and structure
    of objects in JavaScript development, in reality we could write a whole book on
    the topic. That being said, we will continue to cover these and more aspects of
    the more advanced side of JavaScript development throughout this book. As mentioned
    in the introduction of this chapter, many of the differences and paradigm changes
    presented with advanced JavaScript development may seem a bit daunting to some
    Flash developers. However, once you get your head wrapped around most of these
    core concepts, the rest of the puzzle pieces begin to fit together with ease.
    In the next chapter, we will be looking into some of the tools available for porting
    pre-existing Flash content to HTML5.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章涵盖了JavaScript开发中对象的语法和结构的主要概念，但实际上我们可以写一整本书来讨论这个主题。话虽如此，我们将继续在本书中涵盖这些以及更多JavaScript开发的高级方面。正如本章的介绍中所提到的，许多高级JavaScript开发中呈现的差异和范式变化可能对一些Flash开发人员来说有些令人生畏。然而，一旦您掌握了这些核心概念中的大部分，其他的拼图就会变得轻而易举地拼合在一起。在下一章中，我们将探讨一些可用于将现有Flash内容移植到HTML5的工具。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Looking for even more advanced JavaScript syntax and structure tips and techniques?
    You can check these books from Packt Publishing, *Object-Oriented JavaScript*
    by *Stoyan Stefanov*, *Learning jQuery, Third Edition* by *Jonathan Chaffer* and
    *Karl Swedberg*, and *jQuery for Designers: Beginner''s Guide* by *Natalie MacLees*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '寻找更高级的JavaScript语法和结构技巧？您可以查看Packt Publishing出版的这些书籍，*Object-Oriented JavaScript*
    by *Stoyan Stefanov*，*Learning jQuery, Third Edition* by *Jonathan Chaffer* and
    *Karl Swedberg*，以及*jQuery for Designers: Beginner''s Guide* by *Natalie MacLees*。'
