- en: Chapter 4. Building the Untangle Game with Canvas and Drawing API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Canvas和绘图API构建Untangle游戏
- en: One new highlighted feature in HTML5 is the Canvas element. We can treat the
    canvas element as a dynamic area that we can draw graphics and shapes on with
    scripts.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HTML5中一个突出的新功能是Canvas元素。我们可以将画布元素视为一个动态区域，可以使用脚本在上面绘制图形和形状。
- en: Images in websites have been static for years. There is animation gif but it
    cannot interact with its visitors. Canvas is dynamic. We draw and modify the context
    in canvas dynamically through JavaScript drawing API. We can also add interaction
    to the canvas and thus make games.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网站中的图像多年来一直是静态的。有动画gif，但它无法与访问者进行交互。画布是动态的。我们可以通过JavaScript绘图API动态绘制和修改画布中的上下文。我们还可以向画布添加交互，从而制作游戏。
- en: In the past two chapters, we have discussed DOM-based game development with
    CSS3 and few HTML5 features. In the coming two chapters, we will focus on using
    new HTML5 features to create games. In this chapter, we will take a look at a
    core feature, canvas, and some basic drawing techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们已经讨论了基于DOM的游戏开发与CSS3和一些HTML5功能。在接下来的两章中，我们将专注于使用新的HTML5功能来创建游戏。在本章中，我们将介绍一个核心功能，即画布，以及一些基本的绘图技术。
- en: 'In this chapter, we shall cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the HTML5 canvas element
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍HTML5画布元素
- en: Drawing a circle in canvas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布中绘制圆
- en: Drawing lines in the canvas element
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布元素中绘制线条
- en: Interacting with drawn objects in canvas with mouse events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与画布中绘制的对象进行交互的鼠标事件
- en: Detecting line intersection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测线交点
- en: Building the Untangle puzzle game with canvas
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canvas和绘图API构建Untangle解谜游戏
- en: The Untangle puzzle game is a game where players are given circles with some
    lines connecting them. The lines may intersect the others and the players need
    to drag the circles so that no line intersects anymore.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Untangle解谜游戏是一个玩家被给予一些连接的圆的游戏。这些线可能会相交，玩家需要拖动圆圈，使得没有线再相交。
- en: 'The following screenshot previews the game that we are going to achieve through
    this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图预览了我们将通过本章实现的游戏：
- en: '![Building the Untangle Game with Canvas and Drawing API](img/1260_04_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![使用Canvas和绘图API构建Untangle游戏](img/1260_04_01.jpg)'
- en: So let's start making our canvas game from scratch.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们从头开始制作我们的画布游戏。
- en: Introducing the HTML5 Canvas Element
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍HTML5 Canvas元素
- en: 'W3C community states that the canvas element and the drawing functions are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: W3C社区表示画布元素和绘图功能是：
- en: A resolution-dependent bitmap canvas, which can be used for rendering graphs,
    game graphics, or other visual images on the fly.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个分辨率相关的位图画布，可用于实时渲染图形、游戏图形或其他视觉图像。
- en: The canvas element contains context for drawing and the actual graphics and
    shapes are drawn by the JavaScript drawing API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 画布元素包含用于绘制的上下文，实际的图形和形状是由JavaScript绘图API绘制的。
- en: Drawing a circle in canvas
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布中绘制圆
- en: Let's start our drawing on canvas from the basic shape—circle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本形状——圆开始在画布上绘制。
- en: Time for action Drawing color circles on canvas
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上绘制彩色圆圈的时间
- en: First, let's set up the new environment for the example. That is an HTML file
    that will contain the canvas element, a jQuery library to help us on JavaScript,
    a JavaScript file containing the actually drawing logic, and a style sheet.![Time
    for action Drawing color circles on canvas](img/1260_04_02.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为示例设置新环境。这是一个包含画布元素、一个帮助我们进行JavaScript的jQuery库、一个包含实际绘图逻辑的JavaScript文件和一个样式表的HTML文件。![在画布上绘制彩色圆圈的时间](img/1260_04_02.jpg)
- en: 'Put the following HTML code into the `index.html`. It is a basic HTML document
    containing the canvas element:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下HTML代码放入`index.html`中。这是一个包含画布元素的基本HTML文档：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Use CSS to set the background color of the canvas inside `untangle.css:`
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CSS在`untangle.css`中设置画布的背景颜色：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `html5games.untangle.js` JavaScript file, we put a jQuery `ready` function
    and draw a color circle inside it:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`html5games.untangle.js` JavaScript文件中，我们放置了一个jQuery `ready`函数，并在其中绘制了一个彩色圆圈：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open the `index.html` file in a web browser and we will get the following screenshot:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中打开`index.html`文件，我们将得到以下截图：
- en: '![Time for action Drawing color circles on canvas](img/1260_04_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![在画布上绘制彩色圆圈的时间](img/1260_04_03.jpg)'
- en: What just happened?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have just created a simple canvas **context** with circles on it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在上面创建了一个简单的带有圆圈的画布**上下文**。
- en: 'There are not many settings for the canvas element itself. We set the width
    and height of the canvas, same as we have a fixed the dimensions of a real drawing
    paper. Also, we assign an ID attribute to the canvas for easier reference again
    in JavaScript:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 画布元素本身没有太多设置。我们设置了画布的宽度和高度，就像我们固定了真实绘图纸的尺寸一样。此外，我们为画布分配了一个ID属性，以便在JavaScript中更容易地引用它：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Putting fallback content when the web browser does not support canvas
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当Web浏览器不支持画布时放置回退内容
- en: Not every web browser supports the canvas element. Especially, those aged old
    version ones. The Canvas element provides an easy way to provide **fallback content**
    if the canvas element is not supported. Anything inside the canvas open and close
    tag is the fallback content. This content is hidden if the web browser supports
    the element. Browsers that don't support canvas will instead display that fallback
    content. It is good practice to provide useful information in the fallback content.
    For instance, if the canvas purpose is a dynamic picture, we may consider placing
    a`<img>` alternative there. Or we may also provide some links to modern web browsers
    for the visitor to upgrade their browser easily.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的Web浏览器都支持画布元素。特别是那些古老的版本。Canvas元素提供了一种简单的方法来提供**回退内容**，如果不支持画布元素。在画布的开放和关闭标记内的任何内容都是回退内容。如果Web浏览器支持该元素，则此内容将被隐藏。不支持画布的浏览器将显示该回退内容。在回退内容中提供有用的信息是一个好的做法。例如，如果画布的目的是动态图片，我们可以考虑在那里放置一个`<img>`的替代内容。或者我们还可以为访问者提供一些链接，以便轻松升级他们的浏览器。
- en: 'In this example, we provided a sentence inside the canvas element. This sentence
    is hidden from any browsers that support the canvas element. It will show to the
    visitor if their browsers do not support the new HTML5 canvas feature. The following
    screenshot shows the old version of Internet Explorer displaying the fallback
    content instead of drawing the canvas element:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在画布元素内提供了一个句子。这个句子对于支持画布元素的任何浏览器都是隐藏的。如果他们的浏览器不支持新的HTML5画布功能，它将显示给访问者。以下截图显示了旧版本的Internet
    Explorer显示回退内容，而不是绘制画布元素：
- en: '![Putting fallback content when the web browser does not support canvas](img/1260_04_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![在Web浏览器不支持画布时放置回退内容](img/1260_04_04.jpg)'
- en: Drawing circles and shapes with canvas arc function
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用画布弧函数绘制圆圈和形状
- en: There is no circle function to draw a circle. Canvas drawing API provides a
    function to draw different arcs, including the circle. The Arc function accepts
    following arguments
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 没有绘制圆的圆函数。画布绘图API提供了一个绘制不同弧的函数，包括圆。弧函数接受以下参数
- en: '| Arguments | Discussion |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 讨论 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| X | The center point of the arc in x axis. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| X | 弧的x轴中心点。 |'
- en: '| Y | The center point of the arc in y axis. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Y | 弧的y轴中心点。 |'
- en: '| radius | The radius is the distance between the center point and the arc
    perimeter. When drawing a circle, a larger radius means a larger circle. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 半径 | 半径是中心点和弧周围的距离。绘制圆时，较大的半径意味着较大的圆。 |'
- en: '| startAngle | The starting point is an angle in radian. It defines where to
    start drawing the arc on the perimeter. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| startAngle | 起始点是弧度角。它定义了在周边开始绘制弧的位置。 |'
- en: '| endAngle | The ending point is an angle in radian. The arc is drawn from
    the position of the starting angle to this end angle. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| endAngle | 结束点是弧度角。弧是从起始角度的位置绘制到这个结束角度。 |'
- en: '| counter-clockwise | This is a Boolean indicating the arc from `startingAngle`
    to `endingAngle` drawn in a clockwise or counter-clockwise direction.This is an
    optional argument with the default value false. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 逆时针 | 这是一个布尔值，指示从`startingAngle`到`endingAngle`的弧是顺时针还是逆时针绘制的。这是一个可选参数，默认值为false。
    |'
- en: Converting degree to radians
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将度数转换为弧度
- en: 'The angle arguments used in the arc function are in **radian** instead of **degree**.
    If you are familiar with the degrees angle, you may need to convert the degree
    into radians before putting the value into the arc function. We can convert the
    angle unit by using the following formula:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 弧函数中使用的角度参数是**弧度**，而不是**度**。如果您熟悉度角，您可能需要在将值放入弧函数之前将度转换为弧度。我们可以使用以下公式转换角度单位：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following graph contains some common angle values in both degree and radian
    units. The graph also indicates the position of the angle value for us to easily
    pick the starting angle and ending angle argument when drawing arc in canvas.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表包含了一些常见的角度值，分别以度和弧度为单位。图表还指示了角度值的位置，以便我们在绘制画布中的弧时轻松选择起始角度和结束角度参数。
- en: '![Converting degree to radians](img/1260_04_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![将度数转换为弧度](img/1260_04_05.jpg)'
- en: In order to be clearer on drawing different arcs with the starting angle and
    ending angle, let's draw some arcs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地绘制具有起始角度和结束角度的不同弧，让我们绘制一些弧。
- en: Time for action Drawing different arcs with arc function
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动 用弧函数绘制不同的弧
- en: 'Let''s do some experiments on using the `arc` function by giving different
    starting and ending angles:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过给出不同的起始和结束角度来对`arc`函数进行一些实验：
- en: Open the `html5games.untangle.js` file we just used to draw the circle.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们刚刚用来绘制圆的`html5games.untangle.js`文件。
- en: 'Replace the circle drawing code by using the following arcs drawing codes:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下弧绘制代码替换圆绘制代码：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is time to test it in a web browser. There should be six different half
    circles and arcs on the canvas as shown in the following screenshot:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候在Web浏览器中测试它了。如下截图所示，画布上应该有六个不同的半圆和弧：
- en: '![Time for action Drawing different arcs with arc function](img/1260_04_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![采取行动 用弧函数绘制不同的弧](img/1260_04_06.jpg)'
- en: What just happened?
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We have used different `startAngle` and `endAngle` arguments in the arc function
    to draw six different arc shapes. These arc shapes demonstrate how the arc function
    works.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在弧函数中使用了不同的`startAngle`和`endAngle`参数来绘制六种不同的弧形状。这些弧形状演示了弧函数的工作原理。
- en: 'Let''s recall the degrees and radians relationship circle and take a look at
    the top half circle. The top half circle begins at angle 0 and ends at angle π,
    and the arc is drawn in an counter-clockwise direction. If we take a look at the
    circle, it looks like the following graph:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下度和弧度的关系圆，并看一下顶部的半圆。顶部的半圆从角度0开始，到角度π结束，弧是逆时针绘制的。如果我们看一下圆，它看起来像下面的图表：
- en: '![What just happened?](img/1260_04_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: 发生了什么？
- en: 'And if we start at angle 210 degrees and end at angle 120 degrees, in a clockwise
    direction, we will get the following arc:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从210度开始，到120度结束，顺时针方向，我们将得到以下弧：
- en: '![What just happened?](img/1260_04_08.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/1260_04_08.jpg)'
- en: Pop quiz
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: Which arc command we can use to draw the following arc?![Pop quiz](img/1260_04_09.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个弧命令来绘制以下弧？![小测验](img/1260_04_09.jpg)
- en: a. ctx.arc(300, 250, 50 , Math.PI*3/2, Math.PI/2, true);
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: a. ctx.arc(300, 250, 50 , Math.PI*3/2, Math.PI/2, true);
- en: b. ctx.arc(300, 250, 50 , Math.PI*3/2, Math.PI/2);
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: b. ctx.arc(300, 250, 50 , Math.PI*3/2, Math.PI/2);
- en: c. ctx.arc(300, 250, 50 , Math.PI*3/2, 0, true);
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: c. ctx.arc(300, 250, 50 , Math.PI*3/2, 0, true);
- en: d. ctx.arc(300, 250, 50 , Math.PI*3/2, 0);
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: d. ctx.arc(300, 250, 50 , Math.PI*3/2, 0);
- en: Executing the path drawing in canvas
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布中执行路径绘制
- en: When we are calling the arc function or other path drawing functions, we are
    not drawing the path immediately on the canvas. Instead, we are adding it into
    a list of the paths. These paths will not be drawn until we execute the drawing
    command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用弧函数或其他路径绘制函数时，我们并没有立即在画布上绘制路径。相反，我们将其添加到路径列表中。这些路径直到我们执行绘图命令才会被绘制。
- en: There are two drawing executing commands. One command for filling the paths
    and the other for drawing the stroke.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个绘制执行命令。一个用于填充路径，另一个用于绘制描边。
- en: 'We fill the paths by calling the `fill` function and draw the stroke of the
    paths by calling the `stroke` function, which we will use later when drawing lines:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`fill`函数填充路径，并通过调用`stroke`函数绘制路径的描边，这在绘制线条时会用到：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Beginning a path for each style
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每种样式开始一个路径
- en: 'The `fill` and `stroke` function fills and draws the paths on canvas but it
    does not clear the list of paths. Take the following code snippet as an example.
    After filling our circle with red color, we add other circles and fill it with
    green. What happens to the code is both the circles are filled with green color,
    instead of only the new circle being filled by green color:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill`和`stroke`函数填充和绘制画布上的路径，但不清除路径列表。以以下代码片段为例。在用红色填充我们的圆之后，我们添加其他圆并用绿色填充。代码的结果是两个圆都被绿色填充，而不仅仅是新圆被绿色填充：'
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is because when calling the second `fill` command, the list of paths in the
    canvas contain both circles. Therefore, the `fill` command fills both circles
    with green and overrides the red color circle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在调用第二个`fill`命令时，画布中的路径列表包含两个圆。因此，`fill`命令会用绿色填充两个圆，并覆盖红色圆。
- en: In order to fix this issue, we want to ensure we call `beginPath` before drawing
    a new shape every time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们希望确保每次绘制新形状时都调用`beginPath`。
- en: '`beginPath` empties the list of paths so next time we call the `fill` and `stroke`
    command, it will only apply to all paths after the last `beginPath`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`beginPath`清空路径列表，所以下次调用`fill`和`stroke`命令时，它只会应用于`beginPath`之后的所有路径。'
- en: Have a go hero
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看
- en: We have just discussed a code snippet where we intend to draw two circles with
    one in red color and the other in green. The code turns out drawing both circles
    in green color. How can we add a `beginPath` command to the code so that it draws
    one red circle and one green circle correctly?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了一个代码片段，我们打算用红色绘制两个圆，另一个用绿色。结果代码绘制出来的两个圆都是绿色的。我们如何向代码添加`beginPath`命令，以便正确绘制一个红色圆和一个绿色圆？
- en: Closing a path
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭路径
- en: The `closePath` function will draw a straight line from the last point of the
    latest path to the first point of the path. That is closing the path. If we are
    only going to fill the path and not going to draw the stroke outline, the `closePath`
    function does not affect the result. The following screenshot compares the result
    on a half circle with one calling `closePath` and the other not calling `closePath:`
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`closePath`函数将从最新路径的最后一个点绘制一条直线到路径的第一个点。这是关闭路径。如果我们只打算填充路径而不打算绘制描边轮廓，`closePath`函数不会影响结果。以下屏幕截图比较了在半圆上调用`closePath`和不调用`closePath`的结果：'
- en: '![Closing a path](img/1260_04_10.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![关闭路径](img/1260_04_10.jpg)'
- en: Pop quiz
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验
- en: Do we need to use the `closePath` function on the shape we are drawing if we
    just want to fill the color and not draw the outline stroke?
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只想填充颜色而不绘制轮廓描边，我们需要在绘制的形状上使用`closePath`函数吗？
- en: a. Yes, we need the `closePath` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: a. 是的，我们需要`closePath`函数。
- en: b. No, it does not care if we have the `closePath` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: b. 不，它不在乎我们是否有`closePath`函数。
- en: Wrapping the circle drawing in function
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将绘制圆形包装在函数中
- en: Drawing a circle is a common function that we will use a lot. It is better to
    create a function for drawing a circle instead of entering several code lines
    now.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆形是一个常见的函数，我们将经常使用它。最好创建一个绘制圆形的函数，而不是现在输入几行代码。
- en: Time for action Putting the circle drawing code into a function
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行操作将绘制圆形的代码放入函数中
- en: 'Let''s make a function for the circle drawing and draw some circles on the
    canvas:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为绘制圆形创建一个函数，并在画布上绘制一些圆圈：
- en: Open the `html5games.untangle.js` file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.untangle.js`文件。
- en: 'Replace the original code in the JavaScript file with the following code. It
    basically puts the circle drawing code we just used into a function and uses a
    for-loop to randomly place five circles on the canvas:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换JavaScript文件中的原始代码。它基本上将我们刚刚使用的绘制圆形的代码放入一个函数中，并使用for循环在画布上随机放置五个圆圈：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Open the HTML file in the web browser to see the result.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中打开HTML文件以查看结果。
- en: '![Time for action Putting the circle drawing code into a function](img/1260_04_11.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![执行操作将绘制圆形的代码放入函数中](img/1260_04_11.jpg)'
- en: What just happened?
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: The code of drawing circles is executed after the page is loaded and ready.
    We used a loop to draw several circles in random places on the canvas.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆形的代码在页面加载和准备就绪后执行。我们使用循环在画布上随机绘制了几个圆圈。
- en: Generating random numbers in JavaScript
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中生成随机数
- en: In game development, we often use `random` functions. We may want to randomly
    summon a monster for the player to fight, we may want to randomly drop a reward
    price when the player makes progress, and we may want a random number to be the
    result of rolling a dice. In this code, we place the circles randomly in the canvas.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，我们经常使用`random`函数。我们可能希望随机召唤一个怪物让玩家战斗，我们可能希望玩家取得进展时随机掉落奖励，我们可能希望随机数成为掷骰子的结果。在这段代码中，我们随机放置圆圈在画布上。
- en: To generate a random number in JavaScript, we use the `Math.random()` function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JavaScript中生成一个随机数，我们使用`Math.random()`函数。
- en: There is no argument in the `random` function. It always returns a floating
    number between 0 and 1\. The number is equal or bigger than 0 and smaller than
    1.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`函数中没有参数。它总是返回一个介于0和1之间的浮点数。这个数字大于或等于0，小于1。'
- en: There are two common ways to use the `random` function. One way is to generate
    random numbers within a given range. The other way is generating a true or false
    value
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种常见的使用`random`函数的方式。一种方式是在给定范围内生成随机数。另一种方式是生成真或假值
- en: '| Usage | Code | Discussion |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 用法 | 代码 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Getting a random integer between A and B | Math.floor(Math.random()*B)+A
    | `Math.floor()` function cuts the decimal point of the given number.Take `Math.floor(Math.random()*10)+5`
    as an example.`Math.random()` returns a decimal number between 0 to 0.9999….`Math.random()*10`
    is a decimal number between 0 to 9.9999….`Math.floor(Math.random()*10)` is an
    integer between 0 to 9.Finally, `Math.floor(Math.random()*10) + 5` is an integer
    between 5 to 14. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: 获取A和B之间的随机整数`Math.floor(Math.random()*B)+A` `Math.floor()`函数去掉给定数字的小数点。以`Math.floor(Math.random()*10)+5`为例。`Math.random()`返回0到0.9999之间的小数。`Math.random()*10`是0到9.9999之间的小数。`Math.floor(Math.random()*10)`是0到9之间的整数。最后，`Math.floor(Math.random()*10)
    + 5`是5到14之间的整数。
- en: '| Getting a random Boolean | (Math.random() > 0.495) | `(Math.random() > 0.495)`
    means there is 50 percent false and 50 percent true.We can further adjust the
    true/false ratio.`(Math.random() > 0.7)` means there is almost 70 percent false
    and 30 percent true. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: 获取一个随机的布尔值（Math.random() > 0.495）`(Math.random() > 0.495)`意味着有50%的假和50%的真。我们可以进一步调整真/假比例。`(Math.random()
    > 0.7)`意味着几乎有70%的假和30%的真。
- en: Saving the circle position
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存圆的位置
- en: When we are developing a DOM-based game, such as the games we built in previous
    chapters, we often put the game objects into DIV elements and access them later
    in code logic. It is a different story in canvas-based game development.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发基于DOM的游戏时，比如我们在前几章中构建的游戏，我们经常将游戏对象放入DIV元素中，并在代码逻辑中稍后访问它们。在基于画布的游戏开发中情况就不同了。
- en: In order to access our game objects after they are drawn on the canvas, we need
    to remember their states ourselves. Lets say now we want to know how many circles
    are drawn and where they are, and we will need an array to store their position.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在画布上绘制游戏对象后访问它们，我们需要自己记住它们的状态。比如现在我们想知道有多少个圆被绘制了，它们在哪里，我们需要一个数组来存储它们的位置。
- en: Time for action Saving the circle position
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间保存圆的位置
- en: Open the `html5games.untangle.js` file in the text editor.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`html5games.untangle.js`文件。
- en: 'Add the following `circle` object definition code at the top of the JavaScript
    file:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript文件的顶部添加以下`circle`对象定义代码：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we need an array to store the circles position. Add a new array to the
    `untangleGame` object:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个数组来存储圆的位置。向`untangleGame`对象添加一个新数组：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After drawing every circle on the canvas, we save the position of the circle
    into the `circles` array. Add the highlighted line after calling the `drawCircle`
    function:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上绘制每个圆之后，我们将圆的位置保存到`circles`数组中。在调用`drawCircle`函数后添加突出显示的行：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we can test the code in the web browser. There is no visual difference between
    this code and the last example when drawing random circles on canvas. It is because
    we are saving the circles but have not changed any code that affects the appearance.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在web浏览器中测试代码。在画布上绘制随机圆时，这段代码与上一个示例之间没有视觉差异。这是因为我们保存了圆圈，但没有改变任何影响外观的代码。
- en: What just happened?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We saved the position and color of each circle. This is because we cannot directly
    access the drawn object in canvas. All lines and shapes are drawn on the canvas
    and we cannot access the lines or shapes as individual objects. The drawn items
    are drawn on a canvas. We cannot just move a house in an oil painting, the same
    way we cannot directly manipulate any drawn items in the canvas element.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存了每个圆的位置和颜色。这是因为我们无法直接访问画布中绘制的对象。所有线条和形状都是在画布上绘制的，我们无法将线条或形状作为单独的对象访问。绘制的项目都是在画布上绘制的。我们不能像在油画中移动房子一样，也不能直接操作画布元素中的任何绘制项目。
- en: Defining a basic class definition in JavaScript
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中定义一个基本的类定义
- en: JavaScript is **object-oriented programming** language. We can define some object
    structure for our use. The `Circle` object provides a data structure for us to
    easily store a collection of x and y positions and the radii.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是**面向对象编程**语言。我们可以为我们的使用定义一些对象结构。`Circle`对象为我们提供了一个数据结构，可以轻松存储一组x和y位置以及半径。
- en: 'After defining the `Circle` object, we can create a new `Circle` instance with
    an x, y, and radius value by the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`Circle`对象之后，我们可以通过以下代码创建一个新的`Circle`实例，具有x、y和半径值：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more detail usage on object-oriented programming JavaScript, please read
    the Mozilla Developer Center in the following link:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有关面向对象编程JavaScript的更详细用法，请阅读以下链接中的Mozilla Developer Center：
- en: '[https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript](http://https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript](http://https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript)'
- en: Have a go hero
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试一试
- en: We have drawn several circles randomly on the canvas. They are in the same style
    and same size. How about we randomly draw the size of the circles? And fill the
    circles with different colors? Try modifying the code and play with the drawing
    API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在画布上随机画了几个圆。它们是相同风格和相同大小的。我们如何随机绘制圆的大小？并用不同的颜色填充圆？尝试修改代码并使用绘图API进行操作。
- en: Drawing lines in canvas
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上绘制线条
- en: Now we have several circles here, how about connecting them with lines? Let's
    draw a straight line between each circle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们这里有几个圆，怎么样用线连接它们？让我们在每个圆之间画一条直线。
- en: Time for action Drawing straight lines between each circle
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间在每个圆之间绘制直线
- en: Open the `index.html` we have just used in the circle drawing example.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们刚刚在圆形绘制示例中使用的`index.html`。
- en: Change the wordings **drawing circles in Canvas** to **drawing lines in Canvas**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**在Canvas中绘制圆**的措辞更改为**在Canvas中绘制线条**。
- en: Open the `html5games.untangle.js` JavaScript file.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.untangle.js` JavaScript文件。
- en: 'We are going to add the line drawing code on top of our existing circles drawing
    code. Replace the original code with the following. The modified code is highlighted:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在现有圆形绘制代码的基础上添加线条绘制代码。用以下代码替换原始代码。修改后的代码已突出显示：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Test the code in the web browser. We should see there are lines connected with
    each randomly placed circle.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在web浏览器中测试代码。我们应该看到有线连接到每个随机放置的圆。
- en: '![Time for action Drawing straight lines between each circle](img/1260_04_12.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![时间进行绘制每个圆圈之间的直线](img/1260_04_12.jpg)'
- en: What just happened?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: Similar to the way we saved the circles position, we have an array to save every
    line segment we draw. We declare a line class definition to store some essential
    information of a line segment. That is, we save the start and end point and the
    thickness of the line.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与保存圆圈位置的方式类似，我们有一个数组来保存我们绘制的每个线段。我们声明一个线条类定义来存储线段的一些基本信息。也就是说，我们保存线段的起始点和终点以及线条的粗细。
- en: Introducing the line drawing API
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍线条绘制API
- en: There are some drawing APIs for us to draw and style the line stroke
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些绘制API供我们绘制和设置线条样式
- en: '| Line drawing functions | Discussion |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 线条绘制函数 | 讨论 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| MoveTo | The `Moveto` function is like holding the pen in our hand and moving
    it on top of the paper without touching it with the pen. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| MoveTo | `Moveto`函数就像我们手中拿着笔在纸上移动而不用笔触到纸。|'
- en: '| LineTo | This function is like putting the pen down on the paper and drawing
    a straight line to the destination point. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| LineTo | 这个函数就像在纸上放下笔并画一条直线到目标点。|'
- en: '| lineWidth | `LineWidth` sets the thickness of the strokes we draw afterwards.
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| lineWidth | `LineWidth`设置我们之后绘制的线条的粗细。|'
- en: '| Stroke | `stroke` is the function to execute the drawing. We set up a collection
    of `moveTo, lineTo`, or styling functions and finally call the `stroke` function
    to execute it on canvas. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 描边 | `stroke`是执行绘制的函数。我们设置了一系列的`moveTo, lineTo`或样式函数，最后调用`stroke`函数在画布上执行它。|'
- en: We usually draw lines by using the `moveTo` and `lineTo` pairs. Just like in
    the real world, we move our pen on top of the paper to the starting point of a
    line and put down the pen to draw a line. Then, keep on drawing another line or
    move to the other position before drawing. This is exactly the flow in which we
    draw lines on canvas.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们使用`moveTo`和`lineTo`对来绘制线条。就像在现实世界中，我们在纸上移动笔到线条的起始点并放下笔来绘制一条线。然后，继续绘制另一条线或在绘制之前移动到其他位置。这正是我们在画布上绘制线条的流程。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We just demonstrated drawing a simple line. We can set different line styles
    to lines in canvas. For more line styling detail, please read the styling guide
    in W3C ([http://dev.w3.org/html5/2dcontext/#line-styles](http://dev.w3.org/html5/2dcontext/#line-styles))
    and Mozilla Developer Center ([https://developer.mozilla.org/En/Canvas_tutorial/Applying_styles_and_colors](https://developer.mozilla.org/En/Canvas_tutorial/Applying_styles_and_colors)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚演示了绘制一条简单的线。我们可以在画布中为线条设置不同的样式。有关更多线条样式的详细信息，请阅读W3C的样式指南（[http://dev.w3.org/html5/2dcontext/#line-styles](http://dev.w3.org/html5/2dcontext/#line-styles)）和Mozilla开发者中心（[https://developer.mozilla.org/En/Canvas_tutorial/Applying_styles_and_colors](https://developer.mozilla.org/En/Canvas_tutorial/Applying_styles_and_colors)）。
- en: Interacting with drawn objects in canvas with mouse events
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过鼠标事件与画布中的绘制对象交互
- en: So far, we have shown that we can draw shapes in canvas dynamically based on
    our logic. There is one part missing in the game development that is, input.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了我们可以根据逻辑动态在画布中绘制形状。游戏开发中还有一个缺失的部分，那就是输入。
- en: Imagine now we can drag the circles around on the canvas, the connected lines
    will follow the circles. In this section, we will add mouse events to the canvas
    to make our circles **draggable.**
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们可以在画布上拖动圆圈，连接的线条会跟随圆圈移动。在这一部分，我们将在画布上添加鼠标事件，使我们的圆圈**可拖动**。
- en: Time for action Dragging the circles in canvas
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖动画布中的圆圈的时间
- en: Let's continue with our previous code. Open the `html5games.untangle.js` file.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续之前的代码。打开`html5games.untangle.js`文件。
- en: 'We will need a function to clear all the drawing in the canvas. Add the following
    function to the end of the JavaScript file:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个函数来清除画布中的所有绘制。将以下函数添加到JavaScript文件的末尾：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remove the line drawing code in the jQuery `ready` function. We are going to
    separate it into two parts, the line data and the drawing.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery的`ready`函数中删除线条绘制代码。我们将其分成两部分，线条数据和绘制。
- en: 'Add the following function that assigns lines to connect each circle. These
    lines will be drawn later:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，为每个圆圈分配连接线。这些线将稍后绘制：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the mouse event listener code to the jQuery `ready` function. The following
    code is how the function looks now. The highlighted code is the mouse event handlers:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标事件监听器代码添加到jQuery的`ready`函数中。以下是函数现在的样子。高亮显示的代码是鼠标事件处理程序：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we add the `gameloop` function that is responded to draw the updated circles
    and lines:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加`gameloop`函数，用于绘制更新后的圆圈和线条：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open `index.html` in a web browser. There should be five circles with lines
    connecting them. Try dragging the circles. The dragged circle will follow the
    mouse cursor and the connected lines will follow too.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络浏览器中打开`index.html`。应该有五个圆圈，它们之间有连线。尝试拖动圆圈。被拖动的圆圈会跟随鼠标光标移动，连接的线也会跟随移动。
- en: '![Time for action Dragging the circles in canvas](img/1260_04_13.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![时间进行在画布中拖动圆圈](img/1260_04_13.jpg)'
- en: What just happened?
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have set up three mouse event listeners in the jQuery `ready` function. They
    are the mouse down, move, and up events.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在jQuery的`ready`函数中设置了三个鼠标事件监听器。它们是鼠标按下、移动和松开事件。
- en: Getting the mouse position in the canvas element
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取画布元素中的鼠标位置
- en: 'We can get the mouse cursor position relative to the element in the mouse event
    from the `layerX` and `layerY` property. The following shows the code snippet
    we used in our code example. The `|| 0` is to make the result 0 when the `layerX`
    or `layerY` is undefined:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过鼠标事件中的`layerX`和`layerY`属性获取相对于元素的鼠标光标位置。以下是我们在代码示例中使用的代码片段。`|| 0`是为了在`layerX`或`layerY`未定义时使结果为0：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Please note that we need to explicitly set the position property of the element
    in order to get the correct `layerX` and `layerY` property.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要显式设置元素的位置属性，以便获取正确的`layerX`和`layerY`属性。
- en: Detecting mouse events on circles in canvas
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布中检测圆圈上的鼠标事件
- en: After discussing the difference between DOM-based development and Canvas-based
    development, we cannot directly listen to the mouse events of any drawn shapes
    in the canvas. There is no such thing. We cannot monitor the event on any drawn
    shapes in the canvas. We can only get the mouse event of the canvas element and
    calculate the relative position of the canvas. Then we change the states of the
    game objects according to the mouse position and finally redraw it on canvas.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了基于DOM开发和基于画布开发之间的区别之后，我们不能直接监听画布中任何绘制形状的鼠标事件。这是不可能的。我们不能监视画布中任何绘制形状的事件。我们只能获取画布元素的鼠标事件，并计算画布的相对位置。然后根据鼠标位置改变游戏对象的状态，最后在画布上重新绘制它。
- en: How do we know we are clicking on a circle?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们点击了一个圆？
- en: We can use the **point-in-circle** formula. That is to check the distance between
    the center point of the circle and the mouse position. The mouse clicks on the
    circle when the distance is less than the circle radius.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**点在圆内**的公式。这是为了检查圆的中心点与鼠标位置之间的距离。当距离小于圆的半径时，鼠标点击了圆。
- en: 'We use the following formula to get the distance between two points:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下公式来计算两点之间的距离：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following graph shows that when the distance between the center point and
    the mouse cursor is smaller than the radius, the cursor is in the circle:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了当中心点与鼠标光标之间的距离小于半径时，光标在圆内的情况：
- en: '![Detecting mouse events on circles in canvas](img/1260_04_14.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![在画布上检测圆上的鼠标事件](img/1260_04_14.jpg)'
- en: 'The following code we used explains how we can apply the distance checking
    to know whether the mouse cursor is inside the circle in the mouse down event
    handler:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的以下代码解释了如何在鼠标按下事件处理程序中应用距离检查来知道鼠标光标是否在圆内：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we know that the mouse cursor is pressing the circle in canvas, we mark
    it as the targeted circle to be dragged on the mouse move event. During the mouse
    move event handler, we update the target dragged circle's position to the latest
    cursor position. When the mouse is up, we clear the target circle's reference.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道鼠标光标按在画布上的圆上时，我们将其标记为在鼠标移动事件上被拖动的目标圆。在鼠标移动事件处理程序中，我们将目标拖动的圆的位置更新为最新的光标位置。当鼠标松开时，我们清除目标圆的引用。
- en: Pop quiz
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: Can we directly access an already drawn shape in the canvas?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能直接访问画布中已经绘制的形状吗？
- en: a. Yes
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: a. 是的
- en: b. No
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: b. 不
- en: Which method can we use to check whether a point is inside a circle?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪种方法来检查一个点是否在圆内？
- en: a. The coordinate of the point is smaller than the coordinate of the center
    of the circle.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: a. 点的坐标小于圆的中心点的坐标。
- en: b. The distance between the point and the center of the circle is smaller than
    the circle radius.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: b. 点与圆的中心之间的距离小于圆的半径。
- en: c. The x coordinate of the point is smaller than the circle radius.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: c. 点的x坐标小于圆的半径。
- en: d. The distance between the point and the center of the circle is bigger than
    the circle radius.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: d. 点与圆的中心之间的距离大于圆的半径。
- en: Game loop
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环
- en: In Chapter 2, *Getting Started with DOM-based Game Development*, we discussed
    the game loop approach. In the Ping Pong game in Chapter 2, the **game loop**
    manipulates the keyboard input and updates the position of the DOM-based game
    objects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章《使用基于DOM的游戏开发入门》中，我们讨论了游戏循环的方法。在第2章的乒乓球游戏中，**游戏循环**操作键盘输入并更新基于DOM的游戏对象的位置。
- en: Here, the game loop is used to redraw the canvas to present the later game states.
    If we do not redraw the canvas after changing the states, say the position of
    the circles, we will not see it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，游戏循环用于重新绘制画布以呈现后来的游戏状态。如果我们在改变状态后不重新绘制画布，比如圆的位置，我们将看不到它。
- en: It is like refreshing the image on television. The TV refreshes the screen 12
    times per second. We also redraw the canvas scene several times a second. In each
    redraw, we draw the game state on canvas based on the current circle position.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是在电视上刷新图像。电视每秒刷新屏幕12次。我们也会每秒重新绘制画布场景。在每次重绘中，我们根据当前圆的位置在画布上绘制游戏状态。
- en: Clearing the canvas
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除画布
- en: 'When we drag the circle, we redraw the canvas. The problem is the already drawn
    shapes on canvas won''t disappear automatically. We will keep adding new paths
    to the canvas and finally mess up everything on the canvas. The following screenshot
    is what will happen if we keep dragging the circles without clearing the canvas
    on every redraw:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拖动圆时，我们重新绘制画布。问题是画布上已经绘制的形状不会自动消失。我们将继续向画布添加新路径，最终搞乱画布上的一切。如果我们在每次重绘时不清除画布，将会发生以下截图中的情况：
- en: '![Clearing the canvas](img/1260_04_15.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: 清除画布
- en: 'Since we have saved all game statuses in the JavaScript, we can safely clear
    the entire canvas and draw the updated lines and circles with the latest game
    status. To clear the canvas, we use the `clearRect` function provided by canvas
    drawing API. The `clearRect` function clears a rectangle area by providing a rectangle
    clipping region. It accepts the following arguments as the clipping region:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在JavaScript中保存了所有游戏状态，我们可以安全地清除整个画布，并根据最新的游戏状态绘制更新的线条和圆。要清除画布，我们使用画布绘制API提供的`clearRect`函数。`clearRect`函数通过提供一个矩形裁剪区域来清除矩形区域。它接受以下参数作为裁剪区域：
- en: ctx.clearRect(x,context.clearRect(x, y, width, height)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ctx.clearRect(x,context.clearRect(x, y, width, height)
- en: '| Argument | Definition |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| Argument | Definition |'
- en: '| --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| x | The top left point of the rectangle clipping region, in x-axis. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| x | 矩形裁剪区域的左上角点的x轴坐标。 |'
- en: '| y | The top left point of the rectangle clipping region, in y-axis. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| y | 矩形裁剪区域的左上角点的y轴坐标。 |'
- en: '| width | The width of the rectangle region. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| width | 矩形区域的宽度。 |'
- en: '| height | The height of the rectangle region. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| height | 矩形区域的高度。 |'
- en: 'The `x` and `y` set the top left position of the region to be cleared. The
    `width` and `height` defines how much area is to be cleared. To clear the entire
    canvas, we can provide (0,0) as the top left position and the width and height
    of the canvas to the `clearRect` function. The following code clears all drawn
    things on the entire canvas:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`和`y`设置了要清除的区域的左上位置。`width`和`height`定义了要清除的区域大小。要清除整个画布，我们可以将(0,0)作为左上位置，并将画布的宽度和高度提供给`clearRect`函数。以下代码清除了整个画布上的所有绘制内容：'
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pop quiz
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: Can we clear a portion of the canvas by using the `clearRect` function?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`clearRect`函数清除画布的一部分吗？
- en: a. Yes
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: a. 是
- en: b. No
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: b. 否
- en: Does the following code clear things on the drawn canvas?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码是否清除了画布上的绘制内容？
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: a. Yes
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: a. 是
- en: b. No
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: b. 否
- en: Detecting line intersection in canvas
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布中检测线相交
- en: We have draggable circles and connected lines on the canvas. Some lines intersect
    others and some do not. Imagine now we want to distinguish the intersected lines.
    We need some mathematics formula to check them and bold those intersected lines.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在画布上有可拖动的圆圈和连接的线条。一些线相交，而另一些则不相交。现在想象我们想要区分相交的线。我们需要一些数学公式来检查它们，并加粗这些相交的线。
- en: Time for action Distinguishing the intersected lines
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 区分相交的线
- en: 'Let''s increase the thickness of those intersected lines so we can distinguish
    them in the canvas:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加这些相交线的粗细，这样我们就可以在画布中区分它们：
- en: Open the `html5games.untangle.js` file in the text editor.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`html5games.untangle.js`文件。
- en: 'We have the `thinLineThickness` setting as the default line thickness. We add
    the following code to define a thickness for bold lines:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`thinLineThickness`设置为默认线条粗细。我们添加以下代码来定义粗线的粗细：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to make the code more reusable and readable, we want to isolate the
    line intersection logic from the game logic. We create a function to check whether
    the given two lines intersect. Add the following functions to the end of the JavaScript
    file:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使代码更具可重用性和可读性，我们希望将线相交逻辑与游戏逻辑隔离开来。我们创建一个函数来检查给定的两条线是否相交。将以下函数添加到JavaScript文件的末尾：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we have a function to check whether our lines intersect and mark that
    line in bold. Add the following new function to the code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个函数来检查我们的线是否相交，并用粗体标记该线。将以下新函数添加到代码中：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally we update the line intersection by adding the following function call
    in two places. One after connecting our circles and the other in the mouse move
    event handler:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过在两个地方添加以下函数调用来更新线相交。一个是在连接我们的圆圈之后，另一个是在鼠标移动事件处理程序中：
- en: updateLineIntersection();
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: updateLineIntersection();
- en: It is time to test the intersection in the web browser. When viewing the circles
    and lines in canvas the lines with intersection should be thicker than those without
    intersection. Try dragging the circles to change the intersection relationship
    and the lines will become thin or thick.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是在Web浏览器中测试相交的时间了。在画布中查看圆圈和线条，相交的线应该比没有相交的线更粗。尝试拖动圆圈以改变相交关系，线条将变细或变粗。
- en: '![Time for action Distinguishing the intersected lines](img/1260_04_16.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![时间行动 区分相交的线](img/1260_04_16.jpg)'
- en: What just happened?
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have just added **line intersection** checking code to our existing circle
    dragging example. The line intersection code involves some mathematical formula
    to get the **intersection point** of two lines and checks whether the point is
    inside the line segment we provide. Let's look at the mathematics part and see
    how it works.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在现有的拖动圆圈示例中添加了**线相交**检查代码。线相交代码涉及一些数学公式，以获得两条线的**交点**，并检查该点是否在我们提供的线段内。让我们看看数学部分，看看它是如何工作的。
- en: Determining whether two line segments intersect
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定两条线段是否相交
- en: According to the intersection equation we learnt from geometry, with two given
    lines in general form, we can get the intersection point.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们从几何学中学到的相交方程，对于一般形式中的两条给定线，我们可以得到交点。
- en: What is **general form?** In our code, we have the starting point and ending
    point of a line in x and y coordinates. This is a **line segment** because it
    is just a segment part of the line in mathematics. A general form of a line is
    represented by `Ax + By = C`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般形式是什么？** 在我们的代码中，我们有线段的起点和终点的x和y坐标。这是一个**线段**，因为在数学中它只是线的一部分。线的一般形式由`Ax
    + By = C`表示。'
- en: 'The following graph explains the line segment on a line in general form:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了一般形式上的线段：
- en: '![Determining whether two line segments intersect](img/1260_04_17.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![确定两条线段是否相交](img/1260_04_17.jpg)'
- en: 'We can transform the line segment with point 1 in x1, y1 and point 2 in x2,
    y2 into general form by the following equation:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方程将具有点1的线段转换为x1，y1和具有点2的线段转换为x2，y2的一般形式：
- en: '[PRE26]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we have a line equation `AX+BY = C` where `A, B, C` are known and `X` and
    `Y` are unknown.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个线方程`AX+BY = C`，其中`A，B，C`是已知的，`X`和`Y`是未知的。
- en: 'We are checking two lines intersecting. We can transform both lines into general
    form and get two line equations:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在检查两条相交的线。我们可以将两条线都转换为一般形式，并得到两条线方程：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By putting the two general form equations together, X and Y are two variables
    that are unknown. We can then solve these two equations and get the intersection
    point of X and Y.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将两个一般形式方程放在一起，X和Y是两个未知的变量。然后我们可以解这两个方程，得到X和Y的交点。
- en: 'If `A1 * B2 - A2 * B1` is zero, then two lines are parallel and there is no
    intersection point. Otherwise we get the interception point by using the following
    equation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`A1 * B2 - A2 * B1`为零，则两条线是平行的，没有交点。否则，我们可以使用以下方程得到交点：
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The intersection point of the general forms only provides that the two lines
    are not parallel to each other and will intersect each other at some point. It
    does not guarantee the intersection point is on both line segments.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一般形式的交点只能说明两条线不相互平行，并且将在某一点相交。它并不保证交点在两条线段上。
- en: 'The following graphs show two possible results of the intersection point and
    the given line segments. The intersection point is not in between both line segments
    in the left graph, in this case, the two line segments are not intersected to
    each other. In the right-hand side graph, the point is in between both line segments
    so these two line segments intersect to each other:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了交点和给定线段的两种可能结果。在左图中，交点不在两条线段之间，在这种情况下，两条线段互不相交。在右侧图中，点在两条线段之间，因此这两条线段相互相交：
- en: '![Determining whether two line segments intersect](img/1260_04_18.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![确定两条线段是否相交](img/1260_04_18.jpg)'
- en: Therefore, we need another function named `isInBetween` to determine if a provided
    value is in between the beginning and ending value. Then we use this function
    to check whether the intersection point from the equation is in between both line
    segments that we are checking.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要另一个名为`isInBetween`的函数来确定提供的值是否在开始和结束值之间。然后我们使用这个函数来检查方程的交点是否在我们正在检查的两条线段之间。
- en: After getting the result of the lines intersection, we draw the thick line to
    indicate those intersected lines.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得线条相交的结果后，我们绘制粗线以指示那些相交的线条。
- en: Making the untangle puzzle game
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作解开谜题游戏
- en: Now that we have created an interaction canvas we can drag the circles and the
    lines connecting the circles intersecting with other lines. How about we make
    it a game? There are some pre-defined circles and lines and our aim is to drag
    the circles so that there are no lines intersecting with others. This is called
    an **untangle puzzle game**.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个交互画布，我们可以拖动圆圈和连接圆圈的线条与其他线条相交。我们来玩个游戏吧？有一些预定义的圆圈和线条，我们的目标是拖动圆圈，使没有线条与其他线条相交。这就是所谓的**解开谜题游戏**。
- en: Time for action Making the untangle puzzle game in canvas
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：在画布中制作解开谜题游戏
- en: 'Let''s add the game logic to our line intersection code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的线交点代码中添加游戏逻辑：
- en: Open the `index.html` file in text editor.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`index.html`文件。
- en: 'First, let''s set the title as the following:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将标题设置为以下内容：
- en: '[PRE29]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also need to display the current level and the progress to the player. Add
    the following code after the canvas element:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要向玩家显示当前级别和进度。在画布元素之后添加以下代码：
- en: '<p>Puzzle <span id="level">0</span>, Completeness: <span id="progress">0</span>%</p>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <p>谜题<span id="level">0</span>，完成度：<span id="progress">0</span>%</p>
- en: Open the `html5games.untangle.js` JavaScript file to add the game logic.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.untangle.js` JavaScript文件以添加游戏逻辑。
- en: 'Add the variable info, the `untangleGame`. It stores the current level of the
    game:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加变量info，`untangleGame`。它存储游戏的当前级别：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need some pre-defined level data for the players to play. It is a collection
    of data defining where the circles are placed and how they connect to each other
    initially. Add the following level data code to the `untangleGame` object:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一些预定义的级别数据供玩家玩。这是一个定义圆圈放置位置以及它们最初如何连接到彼此的数据集合。将以下级别数据代码添加到`untangleGame`对象中：
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When starting on each level, we need to set up the initial level data. To help
    make the code more readable, we create a function. Add the following code to the
    end of the JavaScript file:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个级别开始时，我们需要设置初始级别数据。为了帮助使代码更易读，我们创建一个函数。在JavaScript文件的末尾添加以下代码：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a game with several levels. We need to check whether the player solves
    the puzzle in the current level and jumps to the next puzzle. Add the following
    function to the end of the file:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个有几个级别的游戏。我们需要检查玩家是否解决了当前级别的谜题并跳转到下一个谜题。在文件末尾添加以下函数：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We update the original mouse up event handler to check whether the player completes
    the level:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更新原始的鼠标抬起事件处理程序以检查玩家是否完成了级别：
- en: '[PRE34]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are going to draw the circles based on the level data instead of drawing
    them randomly. Therefore, we delete the circle drawing code in the jQuery `ready`
    function.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将根据级别数据绘制圆圈，而不是随机绘制它们。因此，我们删除jQuery`ready`函数中的圆圈绘制代码。
- en: 'On the place we deleted the circle drawing code in the jQuery `ready` function,
    we add the following code to set up the circles level data for game loop to use:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们删除jQuery`ready`函数中的圆圈绘制代码的地方，我们添加以下代码来设置游戏循环使用的圆圈级别数据：
- en: setupCurrentLevel();
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: setupCurrentLevel();
- en: 'Next, we update the `connectCircles` function to connect circles based on the
    level data:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新`connectCircles`函数以根据级别数据连接圆圈：
- en: '[PRE35]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need another function to update the game progress. Add the following function
    to the code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要另一个函数来更新游戏进度。将以下函数添加到代码中：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, we need to update the level progress in the following mouse move event
    handler.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在以下鼠标移动事件处理程序中更新级别进度。
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save all files and test the game in the browser. We can drag the circles and
    the line thickness will indicate if it is intersected with other lines. During
    the mouse dragging, the level completeness percentage should change when more
    or less line intersections are detected. If we solve the puzzle, that is no lines
    are intersected, the game will jump to the next level. When the game reaches the
    last level, it will keep showing the last level again. It is because we have not
    yet added the game over screen.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并在浏览器中测试游戏。我们可以拖动圆圈，线条的粗细将指示它是否与其他线条相交。在鼠标拖动期间，当检测到更多或更少的线交点时，级别完成百分比应该发生变化。如果我们解决了谜题，也就是说没有线条相交，游戏将跳转到下一个级别。当游戏达到最后一个级别时，它将继续显示最后一个级别。这是因为我们还没有添加游戏结束画面。
- en: '![Time for action Making the untangle puzzle game in canvas](img/1260_04_19.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间：在画布中制作解开谜题游戏](img/1260_04_19.jpg)'
- en: What just happened?
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have added the game logic to our canvas so that we can play our circle dragging
    code that was created throughout the chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的画布中添加了游戏逻辑，以便我们可以玩我们在整章中创建的圆圈拖动代码。
- en: 'Let''s recall the variables we added to the `untangleGame` object. The following
    table lists the description and usage of these:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们添加到`untangleGame`对象的变量。以下表格列出了这些变量的描述和用法：
- en: '| Variable | Description |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| circleRadius | The radius setting of all drawing circles. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| circleRadius | 所有绘制圆圈的半径设置。 |'
- en: '| thinLineThickness | The line thickness when drawing thin lines. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| thinLineThickness | 绘制细线时的线条粗细。 |'
- en: '| boldLineThickness | The line thickness when drawing bold lines. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| boldLineThickness | 绘制粗线时的线条粗细。 |'
- en: '| circles | An array to store all drawn circles in the canvas. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| circles | 一个数组，用来存储画布中所有绘制的圆圈。 |'
- en: '| lines | An array to store all drawn lines in the canvas. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| lines | 一个数组，用来存储画布中所有绘制的线条。 |'
- en: '| targetCircle | Keeping track of the circle that we are dragging. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| targetCircle | 跟踪我们正在拖动的圆圈。 |'
- en: '| levels | Stores all initial data of each level in the JSON format. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| levels | 以JSON格式存储每个级别的所有初始数据。 |'
- en: '| currentLevel | A number to remember the current level. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| currentLevel | 一个数字，用来记录当前级别。 |'
- en: Defining the leveling data
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义级别数据
- en: 'In each level, we have an initial position of the circles for the untangle
    puzzle. The level data is designed as an array of objects. Each object contains
    every level data. Inside every level data, there are three properties: level number,
    circles, and lines connecting the circles. The following table shows the properties
    in each level data:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个级别中，我们有解谜游戏中圆圈的初始位置。级别数据被设计为对象数组。每个对象包含每个级别的数据。在每个级别数据中，有三个属性：级别编号、圆圈和连接圆圈的线。下表显示了每个级别数据中的属性：
- en: '| Level property | Definition | Discussion |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 级别属性 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| level | The level number of the object. | This is a number in each level
    object to let us easily know which level we are in. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| level | 对象的级别编号。 | 这是每个级别对象中的一个数字，让我们轻松地知道我们在哪个级别。'
- en: '| circles | An array of circles'' position in the level. | This defines how
    the circles are placed initially when the level is set up. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| circles | 一个数组，用来存储级别中圆圈的位置。 | 这定义了当级别设置时圆圈的初始位置。'
- en: '| relationships | An array of relationships defining which circles connect
    to each other. | There are some lines connecting the circles in each level. We
    design the line connections so that there is a solution in each level. The line
    relationship defines which circle connects to which circle. For example, the following
    code means circle 1 is connected to circle 2:{"connectedPoints" : [1,2]} |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| relationships | 一个定义哪些圆圈连接到彼此的关系数组。 | 每个级别中有一些连接圆圈的线。我们设计线条连接，使每个级别都有解决方案。线条关系定义了哪个圆圈连接到哪个圆圈。例如，以下代码表示圆圈1连接到圆圈2：{"connectedPoints"
    : [1,2]} |'
- en: After every level data is defined well with our custom structure
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个级别数据都以我们自定义的结构定义好之后
- en: Determining level-up
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定升级
- en: 'The level is complete when there are no lines intersecting with each other.
    We loop through each line and see how many lines are thin. Thin lines mean they
    are not intersected with others. We can use the thin lines to all line ratios
    to get the percentage of the level of completeness:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有线条相互交叉时，级别完成。我们遍历每条线，并查看有多少条线是细线。细线意味着它们没有与其他线条相交。我们可以使用细线与所有线条的比率来得到级别完成的百分比：
- en: '[PRE38]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then simply determine the level has been completed when the progress
    is 100 percent:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当进度达到100%时，我们可以简单地确定级别已经完成：
- en: '[PRE39]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Displaying current level and completeness progress
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示当前级别和完成进度
- en: 'We have a sentence below the canvas game describing the current level status
    and progress. It is used for displaying the game status to the players so they
    know that they are making progress in the game:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布游戏下方有一句话描述当前级别的状态和进度。它用于向玩家显示游戏状态，让他们知道他们在游戏中取得了进展：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We use the jQuery HTML function that we discussed in Chapter 2, *Getting Started
    with DOM-based Game development*, to update the completeness progress:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了我们在第2章中讨论的jQuery HTML函数，*开始DOM游戏开发*，来更新完成进度。
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Have a go hero
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Have a go hero
- en: We have only defined three levels in the example untangle puzzle game. It is
    not fun enough to play with three levels. How about adding more levels to the
    game? If you cannot come up a level, try searching similar untangle games on the
    Internet and get some inspiration on the leveling.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例解谜游戏中，我们只定义了三个级别。只有三个级别是不够有趣的。要不要给游戏添加更多级别？如果你想不出级别，可以在互联网上搜索类似的解谜游戏，获取一些级别设计的灵感。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We learned a lot in this chapter about drawing shapes and creating interaction
    with the new HTML5 canvas element and the drawing API.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于绘制形状和与新的HTML5画布元素和绘图API交互的知识。
- en: 'Specifically, we covered:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: Drawing different paths and shapes in canvas, including circles, arcs, and lines.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布中绘制不同的路径和形状，包括圆圈、弧线和直线。
- en: Adding mouse events and interaction with the drawn paths in the canvas.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加鼠标事件和与画布中绘制的路径的交互。
- en: Dragging drawn paths in the canvas.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布中拖动绘制的路径。
- en: Checking line intersection with the help of mathematics formulas.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数学公式来检查线条的交叉。
- en: Creating an untangle puzzle game in which players need to drag the circles so
    the connecting lines are not intersected by each other.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个解谜游戏，玩家需要拖动圆圈，使连接线不相交。
- en: Now that we've learned about basic drawing functions in the canvas and drawing
    API, use them to create a puzzle solving game in canvas. We're ready to learn
    some advanced drawing techniques in canvas. In the next chapter, we will enhance
    our untangle puzzle game with more canvas drawing APIs, such as drawing text,
    drawing images, and drawing gradients.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了关于画布和绘图API中的基本绘图功能，可以使用它们在画布中创建一个解谜游戏。我们准备学习一些高级的画布绘图技术。在下一章中，我们将使用更多的画布绘图API来增强我们的解谜游戏，比如绘制文本、绘制图像和绘制渐变。
