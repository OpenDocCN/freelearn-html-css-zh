- en: Chapter 7. Using Local Storage to Store Game Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用本地存储存储游戏数据
- en: Local storage is a new specification from HTML5\. It allows a website to store
    information in the browser locally and access the stored data later. This is a
    useful feature in game development because we can use it as a memory slot to save
    any game data locally in a web browser.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本地存储是HTML5的一个新规范。它允许网站在浏览器中本地存储信息，并在以后访问存储的数据。这是游戏开发中的一个有用功能，因为我们可以将其用作内存插槽，在Web浏览器中本地保存任何游戏数据。
- en: We are going to add game data storing in the CSS3 memory matching game we built
    in *Chapter 3, Building* a *Memory Matching Game in CSS3*. Besides storing and
    loading the game data, we will also notify the player for breaking a record with
    a nice 3D ribbon with pure CSS3 styling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们在*第3章构建CSS3记忆匹配游戏*中构建的游戏中添加游戏数据存储。除了存储和加载游戏数据，我们还将使用纯CSS3样式向玩家通知打破记录的好消息，通过一个漂亮的3D丝带。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Storing data by using HTML5 local storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5本地存储存储数据
- en: Saving the object in the local storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地存储中保存对象
- en: Notifying players for breaking a new record with a nice ribbon effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用漂亮的丝带效果通知玩家打破新纪录
- en: Saving the entire game progress
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存整个游戏进度
- en: 'The following screenshot shows the final result we will create through this
    chapter. So, let''s get on with it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将通过本章创建的最终结果。那么，让我们开始吧：
- en: '![Using Local Storage to Store Game Data](img/1260_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![使用本地存储存储游戏数据](img/1260_07_01.jpg)'
- en: Storing data by using HTML5 local storage
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML5本地存储存储数据
- en: Remember the CSS3 memory matching game we made in *Chapter 3?* Imagine now we
    have published our game and players are trying their best to perform well in the
    game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在*第3章*中制作的CSS3记忆匹配游戏吗？现在想象一下我们已经发布了我们的游戏，玩家们正在努力表现得很好。
- en: We want to show the players whether they played better or worse than the last
    time. We will save the latest score and inform players whether they are better
    or not this time by comparing the scores.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想告诉玩家他们是否比上次玩得更好或更差。我们将保存最新的分数，并通过比较分数来告知玩家这次是否比上次更好。
- en: They may feel proud when performing better. This may make them addicted and
    they may keep trying to get higher scores.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们表现更好时，他们可能会感到自豪。这可能使他们上瘾，他们可能会继续努力获得更高的分数。
- en: Creating a game over dialog
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏结束对话框
- en: Before actually saving anything in the local storage, we need a game over screen.
    We have made a few games in previous chapters. We made a Ping Pong game, memory
    matching game, Untangle puzzle game, and a music game. In these games, we did
    not create any game over screen. Imagine now we are playing the CSS3 memory matching
    game that we built in *Chapter 3*. We successfully match and remove all cards.
    Once we finish, a game over screen pops up and shows the time we utilized to complete
    the game.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地存储中实际保存任何内容之前，我们需要一个游戏结束画面。在之前的章节中，我们制作了一些游戏。我们制作了一个乒乓球游戏，记忆匹配游戏，解开谜题游戏和音乐游戏。在这些游戏中，我们没有创建游戏结束画面。现在想象一下我们正在玩我们在*第3章*中构建的CSS3记忆匹配游戏。我们成功匹配并移除了所有卡片。一旦我们完成，游戏结束画面弹出并显示我们用来完成游戏的时间。
- en: Time for action Creating a game over dialog with the elapsed played time
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行操作-使用经过的播放时间创建游戏结束对话框
- en: 'We will continue with the code from the memory matching game we made in *Chapter
    3*. Carry out the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用*第3章*中制作的记忆匹配游戏的代码。执行以下步骤：
- en: Open the CSS3 matching game folder as our working directory.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将CSS3匹配游戏文件夹作为我们的工作目录。
- en: 'Download a background image from the following URL (we will use it as the background
    of the pop up):'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下网址下载背景图片（我们将用它作为弹出窗口的背景）：
- en: '[http://gamedesign.cc/html5games/popup_bg.jpg](http://gamedesign.cc/html5games/popup_bg.jpg
    )'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://gamedesign.cc/html5games/popup_bg.jpg](http://gamedesign.cc/html5games/popup_bg.jpg
    )'
- en: Place the image in the `images` folder.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像放在`images`文件夹中。
- en: Open `index.html` into any text editor.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`index.html`打开到任何文本编辑器中。
- en: 'We will need a font for the game over pop up. Add the following font embedding
    CSS into the `head` section:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个字体用于游戏结束弹出窗口。将以下字体嵌入CSS添加到`head`部分中：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before the `game` section, we add a `div` named `timer` to show the elapsed
    playing time. In addition, we add a new `popup` section containing the HTML markup
    of the pop-up dialog:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`game`部分之前，我们添加一个名为`timer`的`div`，以显示经过的游戏时间。此外，我们添加一个包含弹出窗口对话框的HTML标记的新`popup`部分：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will now move on to the style sheet. As it is just for styling and not related
    to our logic yet, we can simply copy the `matchgame.css` file from `matching_game_with_game_over`
    in the code example bundle.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将转移到样式表。因为它只是用于样式，与我们的逻辑无关，所以我们可以简单地从代码示例包中的`matching_game_with_game_over`中复制`matchgame.css`文件。
- en: It is time to edit the game logic part. Open the `html5games.matchgame.js` file
    in an editor.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是编辑游戏逻辑部分的时候了。在编辑器中打开`html5games.matchgame.js`文件。
- en: 'In the jQuery ready function, we need a variable to store the elapsed time
    of the game. Then, we create a timer to count the game every second as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery ready函数中，我们需要一个变量来存储游戏的经过时间。然后，我们创建一个计时器，每秒计算游戏时间，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, add a `countTimer` function which will be executed every second. It displays
    the elapsed seconds in the minute and second format:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`countTimer`函数，每秒执行一次。它以分钟和秒的格式显示经过的秒数：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `removeTookCards` function which we wrote earlier, add the following
    highlighted code that executes the game over logic after removing all cards:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前编写的`removeTookCards`函数中，添加以下突出显示的代码，以在移除所有卡片后执行游戏结束逻辑：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At last, we create the following `gameover` function. It stops the counting
    timer, displays the elapsed time in the game over pop up, and finally shows the
    pop up:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建以下`gameover`函数。它停止计时器，显示游戏结束弹出窗口中的经过时间，并最终显示弹出窗口：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, save all files and open the game in a browser. Try finishing the memory
    matching game and the game over screen will pop up, as shown in the following
    screenshot:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存所有文件并在浏览器中打开游戏。尝试完成记忆匹配游戏，游戏结束画面将弹出，如下截图所示：
- en: '![Time for action Creating a game over dialog with the elapsed played time](img/1260_07_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![执行创建带有经过时间的游戏结束对话框](img/1260_07_02.jpg)'
- en: What just happened?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have used the CSS3 transition animation to show the game over pop up. We
    benchmark the score by using the time a player utilized to finish the game.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用CSS3过渡动画来显示游戏结束弹出窗口。我们通过玩家完成游戏所用的时间来评估得分。
- en: Saving scores in the browser
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在浏览器中保存得分
- en: Imagine now we are going to display how well the player played the last time.
    The game over screen includes the elapsed time as the last score alongside the
    current game score. Players can then see how well they do this time compared to
    last time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示玩家上次的游戏表现。游戏结束画面包括上次的经过时间和当前游戏得分。玩家可以看到这次和上次的表现有多大差异。
- en: Time for action Saving the game score
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行保存游戏得分的操作
- en: First, we need to add a few markups in the `popup` section to display the last
    score. Add the following HTML in the `popup` section in `index.html:`
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`popup`部分添加一些标记，以显示上次的得分。在`index.html`的`popup`部分中添加以下HTML：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, we open the `html5games.matchgame.js` to modify some game logic in the
    `gameover` function.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开`html5games.matchgame.js`文件，修改`gameover`函数中的一些游戏逻辑。
- en: 'Add the following highlighted code in the `gameover` function. It loads the
    saved score from local storage and displays it as the score last time. Then, save
    the current score in the local storage:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameover`函数中添加以下突出显示的代码。它从本地存储加载保存的得分，并将其显示为上次的得分。然后，将当前得分保存在本地存储中：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is now time to save all files and test the game in the browser. When you
    finish the game for the first time, the last score should be `00:00`. Then, try
    to finish the game for the second time. The game over pop up will show the elapsed
    time you played the last time. The following screenshot shows the game over screen
    with the current and last score:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候保存所有文件并在浏览器中测试游戏了。当您第一次完成游戏时，上次的得分应该是`00:00`。然后，尝试第二次完成游戏。游戏结束弹出窗口将显示您上次玩游戏的经过时间。以下截图显示了游戏结束画面与当前和上次得分：
- en: '![Time for action Saving the game score](img/1260_07_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![执行保存游戏得分的操作](img/1260_07_03.jpg)'
- en: What just happened?
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just built a basic scoring system that compares a player's score with his/her
    last score.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚建立了一个基本的得分系统，用于比较玩家的得分和上次的得分。
- en: Storing and loading data with local storage
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本地存储存储和加载数据
- en: 'We can store data by using the `setItem` function from the `localStorage` object.
    The following table shows the usage of the function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`localStorage`对象的`setItem`函数来存储数据。以下表格显示了该函数的用法：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Argument | Definition | Description |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `key` | The key is the name of the record that we used to identify an entry.
    | The key is a string and each record has a unique key. Writing a new value to
    an existing key overwrites the old value. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `key` | 键是我们用来标识条目的记录名称。 | 键是一个字符串，每个记录都有一个唯一的键。向现有键写入新值会覆盖旧值。'
- en: '| `value` | The value is any data which will be stored. | It can be any data,
    but the final storage is in a string. We will discuss this shortly. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `value` | 值是要存储的任何数据。 | 它可以是任何数据，但最终存储的是一个字符串。我们将很快讨论这一点。|'
- en: In our example, we save the game elapsed time as the score with the following
    code by using the key `last-elapsed-item:`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用以下代码将游戏经过的时间保存为得分，使用键`last-elapsed-item`：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Complementary to `setItem`, we get the stored data by using the `getItem` function
    in the following way:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与`setItem`相辅相成，我们可以通过以下方式使用`getItem`函数获取存储的数据：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function returns the stored value of the given key. It returns `null` when
    trying to get a non-existent key. This can be used to check whether we have stored
    any data for a specific key.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回给定键的存储值。当尝试获取一个不存在的键时，它会返回`null`。这可以用来检查我们是否为特定键存储了任何数据。
- en: The local storage saves the string value
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地存储保存了字符串值
- en: The local storage stores data in a key-value pair. The key and value are both
    strings. If we save numbers, Boolean, or any type other than string, then it will
    convert the value into a string while saving.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储以键值对的形式存储数据。键和值都是字符串。如果我们保存数字、布尔值或任何类型的数据而不是字符串，那么在保存时它会将值转换为字符串。
- en: Usually, problems occur when we load a saved value from the local storage. The
    loaded value is a string regardless of the type we are saving. We need to explicitly
    parse the value into the correct type before using it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们从本地存储加载保存的值时会出现问题。加载的值是一个字符串，而不管我们保存的类型是什么。在使用之前，我们需要明确将值解析为正确的类型。
- en: 'For example, if we save a floating number into the local storage, we need to
    use the `parseFloat` function when loading it. The following code snippet shows
    how we can use `parseFloat` to retrieve a stored floating number:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将一个浮点数保存到本地存储中，那么在加载时我们需要使用`parseFloat`函数。以下代码片段显示了如何使用`parseFloat`来检索存储的浮点数：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, the manipulation may be incorrect if we forget
    to convert the `gameScore` from string to float. For instance, if we add the `gameScore`
    by 1 without the `parseFloat` function, the result will be **13.2341** instead
    of **14.234**. So, be sure to convert the value from local storage to its correct
    type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，如果我们忘记将`gameScore`从字符串转换为浮点数，操作可能是不正确的。例如，如果我们在没有使用`parseFloat`函数的情况下将`gameScore`增加1，结果将是**13.2341**而不是**14.234**。因此，请确保将值从本地存储转换为其正确的类型。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Size limitation of local storage**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地存储的大小限制**'
- en: There is a size limitation on the data stored through `localStorage` for each
    domain. This size limitation may be slightly different in different browsers.
    Normally, the size limitation is 5 MB. If the limit is exceeded, then the browser
    throws a `QUOTA_EXCEEDED_ERR` exception when setting a key-value into `localStorage`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个域通过`localStorage`存储的数据都有大小限制。这个大小限制在不同的浏览器中可能略有不同。通常，大小限制为5MB。如果超过了限制，那么当向`localStorage`设置键值时，浏览器会抛出`QUOTA_EXCEEDED_ERR`异常。
- en: Treating the local storage object as an associated array
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将本地存储对象视为关联数组
- en: Besides using the `setItem` and `getItem` functions, we can treat the `localStorage`
    object as an associated array and access the stored entries by using square brackets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`setItem`和`getItem`函数外，我们还可以将`localStorage`对象视为关联数组，并通过使用方括号访问存储的条目。
- en: 'For instance, we can replace the following code with the latter version:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以用后一种版本替换以下代码：
- en: Using the `setItem` and `getItem:`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setItem`和`getItem：`
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Access `localStorage` as an array as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`localStorage`的方式如下：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Saving objects in the local storage
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地存储中保存对象
- en: Now, imagine that we are saving not only the score, but also the date and time
    when the ranking is created. We can either save two separate keys for the score
    and date time of playing, or pack the two values into one object and store it
    in the local storage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们不仅保存分数，还保存排名创建时的日期和时间。我们可以保存分数和游戏时间的两个单独的键，或者将两个值打包到一个对象中并将其存储在本地存储中。
- en: We will pack all the game data into one object and store it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有游戏数据打包到一个对象中并进行存储。
- en: Time for action Saving the time alongside the score
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间保存得分的时间
- en: 'Carry out the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: First, open the `index.html` file from our CSS3 memory matching game.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从我们的CSS3记忆匹配游戏中打开`index.html`文件。
- en: 'Replace the HTML markup with the last score by the following HTML (it shows
    both scores and the date time in the game over pop up):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下HTML替换最后得分的HTML（它显示游戏结束弹出窗口中的得分和日期时间）：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The HTML markup is now ready. We will move on to the game logic. Open the `html5games.matchgame.js`
    file in a text editor.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML标记现在已经准备好。我们将继续进行游戏逻辑。在文本编辑器中打开`html5games.matchgame.js`文件。
- en: 'We will modify the `gameover` function. Add the following highlighted code
    to the `gameover` function. It gets the current date time when the game ends and
    packs a formatted date time with elapsed time together into local storage:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改`gameover`函数。将以下突出显示的代码添加到`gameover`函数中。当游戏结束时，它获取当前日期时间并将格式化的日期时间与经过的时间一起打包到本地存储中：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will save the files and open the game in a web browser.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保存文件并在Web浏览器中打开游戏。
- en: When we finish the game for the first time, we will get a screen similar to
    the following screenshot which will show our game score and state that there are
    no previous records:![Time for action Saving the time alongside the score](img/1260_07_04.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们第一次完成游戏时，我们将得到一个类似以下截图的屏幕，它将显示我们的游戏得分并指出没有先前的记录：![行动时间保存得分的时间](img/1260_07_04.jpg)
- en: 'Now try reloading the page and play the game again. When we finish the game
    for the second time, the game over dialog will show our saved record. The following
    screenshot shows how it should look:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试重新加载页面并再次玩游戏。当我们第二次完成游戏时，游戏结束对话框将显示我们保存的记录。以下截图显示了它应该是什么样子的：
- en: '![Time for action Saving the time alongside the score](img/1260_07_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间保存得分的时间](img/1260_07_05.jpg)'
- en: What just happened?
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have just used a `Date` object in JavaScript to get the current date and
    time when the game is over. In addition, we packed the game over date and time
    and the game elapsed time in one object and saved it into the local storage. The
    saved object is encoded in a JSON string. It will also load the last saved date
    and time and the game elapsed time from the storage and parse it back to the JavaScript
    object from a string.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用了JavaScript中的`Date`对象来获取游戏结束时的当前日期和时间。此外，我们将游戏结束的日期和时间以及游戏经过的时间打包到一个对象中并保存到本地存储中。保存的对象被编码为JSON字符串。它还将从存储中加载上次保存的日期和时间以及游戏经过的时间，并将其从字符串解析回JavaScript对象。
- en: Getting the current date and time in JavaScript
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中获取当前日期和时间
- en: 'The `Date` object in JavaScript is used to working with date and time. When
    we create an instance from the `Date` object, by default it stores the current
    date and time. Therefore, we can easily get the current date and time information
    by using the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`Date`对象用于处理日期和时间。当我们从`Date`对象创建一个实例时，默认情况下它会存储当前的日期和时间。因此，我们可以通过以下代码片段轻松地获取当前的日期和时间信息：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we display the date and time in a human-friendly format, we also need to
    add zero padding to minutes and seconds when they are less than 10\. We do this
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以人类友好的格式显示日期和时间时，当分钟和秒钟小于10时，我们还需要添加零填充。我们可以这样做：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following table lists some useful functions in the `Date` object to get
    the date and time:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了`Date`对象中一些有用的函数以获取日期和时间：
- en: '| Function | Description |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 描述 |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getFullYear` | Returns the year in four digits |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `getFullYear` | 返回四位数的年份 |'
- en: '| `getMonth` | Returns the month in integer, starting from 0 (Jan is 0 and
    Dec is 11) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `getMonth` | 返回整数月份，从0开始（1月为0，12月为11） |'
- en: '| `getDate` | Returns the day of the month, starting from 1 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `getDate` | 返回月份的日期，从1开始 |'
- en: '| `getDay` | Returns the day of the week, starting from 0 (Sunday is 0 and
    Saturday is 6) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `getDay` | 返回星期几，从0开始（星期日为0，星期六为6） |'
- en: '| `getHours` | Returns the hour, starting from 0 to 23 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `getHours` | 返回小时，从0到23 |'
- en: '| `getMinutes` | Returns the minutes |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `getMinutes` | 返回分钟 |'
- en: '| `getSeconds` | Returns the seconds |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `getSeconds` | 返回秒数 |'
- en: '| `getMilliseconds` | Returns the milliseconds in 3 digits |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `getMilliseconds` | 返回3位数的毫秒 |'
- en: '| `getTime` | Returns the number of milliseconds since 1 Jan, 1970 00:00 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `getTime` | 返回自1970年1月1日00:00以来的毫秒数 |'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Mozilla Developer Network provides a detailed reference for using the `Date`
    object at the following URL:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla开发者网络提供了使用`Date`对象的详细参考，网址如下：
- en: '[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date](http://https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date](http://https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date)'
- en: Using the native JSON to encode an object into a string
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本机JSON将对象编码为字符串
- en: We used JSON to represent the game level data in *Chapter 4, Building an Untangle
    Game with Canvas and Drawing API.*
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第4章，使用Canvas和Drawing API构建Untangle游戏*中使用JSON表示游戏级别数据。
- en: 'JSON is an object notation format that is friendly for machines to parse and
    generate. In this example, we packed the final elapsed time and the date and time
    into an object. Then, we encoded the object into JSON. Modern web browsers come
    with a native JSON support. We can easily encode any JavaScript object into JSON
    by using the `stringify` function as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种友好的对象表示格式，便于机器解析和生成。在这个例子中，我们将最终经过的时间和日期时间打包到一个对象中。然后，我们将对象编码为JSON。现代Web浏览器都具有本机的JSON支持。我们可以通过使用`stringify`函数轻松地将任何JavaScript对象编码为JSON。
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Normally, we only use the first parameter for the `stringify` function. It
    is the object that we are going to encode as a string. The following code snippet
    demonstrates the result of an encoded JavaScript object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只使用`stringify`函数的第一个参数。这是我们要编码为字符串的对象。以下代码片段演示了编码为JavaScript对象的结果：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `stringify` method can parse objects with data structure into a string well.
    However, it cannot convert anything from an object into a string. For instance,
    it will return an error if we try to pass a DOM element into it. It will return
    the string representing the date if we pass a Date object. Alternatively, it will
    drop all methods definition of the parsing object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringify`方法可以很好地将具有数据结构的对象解析为字符串。但是，它无法将任何对象转换为字符串。例如，如果我们尝试将DOM元素传递给它，它将返回错误。如果我们传递一个日期对象，它将返回表示日期的字符串。或者，它将删除解析对象的所有方法定义。'
- en: Loading a stored object from a JSON string
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从JSON字符串中加载存储的对象
- en: The complete form of **JSON** is **JavaScript Object Notation**. From the name,
    we know that it uses the syntax from JavaScript to represent an object. Therefore,
    it is very easy to parse a JSON formatted string back to a JavaScript object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**的完整形式是**JavaScript对象表示法**。从名称上我们知道它使用JavaScript的语法来表示对象。因此，将JSON格式的字符串解析回JavaScript对象非常容易。'
- en: 'The following code snippet shows how we can use the parse function in the JSON
    object:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们如何在JSON对象中使用解析函数：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can open the console in the Web Inspector to test the JSON JavaScript functions.
    The following screenshot shows the running result of the code snippets we just
    discussed when encoding an object and parsing them:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Web Inspector中打开控制台来测试JSON JavaScript函数。以下屏幕截图显示了我们刚刚讨论的代码片段在编码对象和解析它们时的运行结果：
- en: '![Loading a stored object from a JSON string](img/1260_07_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![从JSON字符串中加载存储的对象](img/1260_07_06.jpg)'
- en: Inspecting the local storage in a console window
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制台窗口中检查本地存储
- en: After we have saved something in the local storage, we may want to know what
    is exactly saved before we write the loading part. We can inspect what we have
    saved by using the storage panel in the Web Inspector. It lists all the saved
    key-value pairs under the same domain. The following screenshot shows that we
    have the **last-score** saved with value **{"savedTime":"23/2/2011 19:27:02","score":23}**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将某些内容保存在本地存储后，我们可能想知道在编写加载部分之前究竟保存了什么。我们可以使用Web Inspector中的存储面板来检查我们保存了什么。它列出了同一域下保存的所有键值对。以下屏幕截图显示了我们保存了**last-score**，值为**{"savedTime":"23/2/2011
    19:27:02","score":23}**。
- en: 'The value is the result of the `JSON.stringify` function we used to encode
    the object into JSON. You may also try saving an object directly into local storage:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该值是我们用于将对象编码为JSON的`JSON.stringify`函数的结果。您也可以尝试直接将对象保存到本地存储中：
- en: '![Inspecting the local storage in a console window](img/1260_07_07.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![在控制台窗口中检查本地存储](img/1260_07_07.jpg)'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Besides `localStorage`, there are other storage approaches that were not discussed.
    These approaches include the **Web SQL Database** ([http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/)),
    which uses SQLite to store data, and **IndexedDB** ([https://developer.mozilla.org/en/IndexedDB](https://developer.mozilla.org/en/IndexedDB)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`localStorage`，还有其他未讨论的存储方法。这些方法包括**Web SQL Database**（[http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/)），它使用SQLite来存储数据，以及**IndexedDB**（[https://developer.mozilla.org/en/IndexedDB](https://developer.mozilla.org/en/IndexedDB)）。
- en: Notifying players of breaking a new record with a nice ribbon effect
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过一个漂亮的缎带效果通知玩家打破了新纪录
- en: Imagine that we want to encourage players by informing them that they broke
    a new record compared to the last score. We want to show a ribbon with `New Record`
    text on it. Thanks to the new CSS3 properties, we can create a ribbon effect completely
    in CSS.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想通过通知玩家他们打破了与上次得分相比的新纪录来鼓励他们。我们想在上面显示一个带有`New Record`文本的缎带。由于新的CSS3属性，我们可以完全在CSS中创建缎带效果。
- en: Time for action Creating a ribbon in CSS3
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CSS3中的缎带的操作时间
- en: 'We will create a new record ribbon and display it when a player breaks his/her
    last score. So, carry out the following steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家打破上次得分时，我们将创建一个新的记录缎带并显示它。因此，请执行以下步骤：
- en: First, open `index.html` where we will add the ribbon HTML markup.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`index.html`，我们将在那里添加缎带HTML标记。
- en: Add the following highlighted HTML right after `popup-box` and before `popup-box-content:`
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`popup-box`后面和`popup-box-content`前面添加以下突出显示的HTML：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we need to focus on the style sheet. The entire ribbon effect is done
    in CSS. Open the `matchgame.css` file in a text editor.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要关注样式表。整个缎带效果是通过CSS完成的。在文本编辑器中打开`matchgame.css`文件。
- en: 'In the `popup-box` styling, we need to add a relative position to it. We do
    this as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`popup-box`样式中，我们需要为其添加相对位置。我们可以这样做：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we need to add the following styles that create the ribbon effect to
    the CSS file:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加以下样式，以在CSS文件中创建缎带效果：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Lastly, we need to modify the game over logic a little bit. Open the `html5games.matchgame.js`
    file and locate the `gameover` function.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要稍微修改游戏结束逻辑。打开`html5games.matchgame.js`文件，找到`gameover`函数。
- en: 'Add the following code to the `gameover` function which compares the current
    score with the last score to determine the new record:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`gameover`函数中，用于比较当前得分和上次得分以确定新纪录：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will test the game in a web browser. Try finishing a game slowly and then
    finish another game fast. When you break the last score, the game over pop up
    shows a nice **NEW RECORD** ribbon, as shown in the following screenshot:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在Web浏览器中测试游戏。尝试慢慢完成一局游戏，然后再快速完成一局游戏。当你打破最高分时，游戏结束弹出窗口会显示一个漂亮的**NEW RECORD**丝带，如下面的屏幕截图所示：
- en: '![Time for action Creating a ribbon in CSS3](img/1260_07_08.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间 在CSS3中创建丝带](img/1260_07_08.jpg)'
- en: What just happened?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We have just created a ribbon effect in a pure CSS3 style with some help from
    JavaScript to show and hide it. The ribbon is composited by a little triangle
    overlaid by a rectangle, as shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚以纯CSS3样式创建了一个丝带效果，并借助JavaScript来显示和隐藏它。丝带由一个小三角形叠加在一个矩形上组成，如下面的屏幕截图所示：
- en: '![What just happened?](img/1260_07_09.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_07_09.jpg)'
- en: 'Now, how can we create a triangle in CSS? We can create a triangle by setting
    both width and height to 0 and drawing only one border. The size of the triangle
    is then decided by the border width. The following code is for the triangle CSS
    we used in our new record ribbon:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何在CSS中创建一个三角形？我们可以通过将宽度和高度都设置为0，并只绘制一个边框来创建一个三角形。然后，三角形的大小由边框宽度决定。以下代码是我们在新记录丝带中使用的三角形CSS：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following PVM Garage website provides a detailed explanation on pure CSS3
    ribbon usage:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下PVM Garage网站提供了关于纯CSS3丝带使用的详细解释：
- en: '[http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/](http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/](http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/)'
- en: Have a go hero Saving and comparing only to the fastest time
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看英雄 只保存和比较最快时间
- en: Each time the game finishes, it compares the last score with the current score.
    Then, it saves the current score.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每次游戏结束时，它会将最后得分与当前得分进行比较。然后，它保存当前得分。
- en: How about changing the code to save the highest score and show the new record
    ribbon when breaking the highest score?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如何修改代码以保存最高分并在打破最高分时显示新记录丝带？
- en: Saving the entire game progress
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存整个游戏进度
- en: We have enhanced our CSS3 memory matching game by adding a game over screen
    and storing the game record. Imagine now that a player is in the mid game and
    accidentally closes the web browser. Once the player opens the game again, the
    game starts from the beginning and the game that the player was playing is lost.
    With the local storage, we can encode the entire game data into JSON and store
    them. In this way, players can resume their game later.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加游戏结束画面和存储游戏记录来增强了我们的CSS3记忆匹配游戏。现在想象一下，玩家正在进行游戏，然后意外关闭了Web浏览器。一旦玩家再次打开游戏，游戏将从头开始，玩家正在玩的游戏将丢失。通过本地存储，我们可以将整个游戏数据编码为JSON并存储起来。这样，玩家可以稍后恢复他们的游戏。
- en: Saving the game progress
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存游戏进度
- en: We are going to pack the game data into one object and save it into the local
    storage every second.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把游戏数据打包到一个对象中，并在每秒保存到本地存储中。
- en: Time for action Saving all essential game data in the local storage
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 在本地存储中保存所有必要的游戏数据
- en: 'We will continue work with our CSS3 memory matching game:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的CSS3记忆匹配游戏：
- en: Open the `html5games.matchgame.js` JavaScript file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.matchgame.js` JavaScript文件。
- en: 'Add the following code at the top of the JavaScript file after declaring the
    `matchingGame` variable. This code creates an object named `savingObject` to save
    the array of deck and removed cards and the current elapsed time:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明`matchingGame`变量后，在JavaScript文件的顶部添加以下代码。此代码创建一个名为`savingObject`的对象，用于保存牌组和移除的卡片数组以及当前经过的时间：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the jQuery function, add the following highlighted code. It clones the order
    of the deck to the `savingObject`. In addition, it assigns an index to each card
    in the DOM data attribute:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery函数中添加以下突出显示的代码。它将牌组的顺序克隆到`savingObject`中。此外，它为DOM数据属性中的每张卡分配一个索引：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have a `countTimer` function that executes every second. We add the following
    highlighted code in the `countTimer` function. It saves the current elapsed time
    in the `savingObject` and also saves the object in the local storage:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个`countTimer`函数，每秒执行一次。我们在`countTimer`函数中添加了以下突出显示的代码。它将当前经过的时间保存在`savingObject`中，并将对象保存在本地存储中：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The game removes cards when the player finds a matching pair. We replace the
    original `$(".card-removed").remove()`; code with the following highlighted code
    in the `removeTookCards` function. It remembers which cards are removed in the
    `savingObject:`
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家找到一对匹配的卡片时，游戏会移除卡片。我们将原始的`$(".card-removed").remove()`代码替换为`removeTookCards`函数中的以下突出显示的代码。它记住了`savingObject`中移除的卡片：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have to remove the saved game data in the local storage when the game is
    over. Add the following code in the `gameover` function:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏结束时，我们必须删除本地存储中保存的游戏数据。在`gameover`函数中添加以下代码：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At last, we have a function to save the `savingObject` in the local storage:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有一个函数将`savingObject`保存在本地存储中：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have modified the code a lot and it is now time to test the game in a web
    browser. After the game runs, try clearing several matching cards. Then, open
    the storage panel in the Web Inspector. The local storage should contain an entry
    similar to the one shown in the following screenshot. It is a record with a key
    `savingObject` and a value with a long string in a JSON format. The JSON string
    contains the shuffled deck, removed cards, and the current elapsed time:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经修改了很多代码，现在是时候在Web浏览器中测试游戏了。游戏运行后，尝试清除几张匹配的卡片。然后，在Web检查器中打开存储面板。本地存储应该包含类似于下面屏幕截图中所示的条目。它是一个具有键`savingObject`和值为JSON格式的长字符串的记录。JSON字符串包含洗牌后的牌组、移除的卡片和当前经过的时间：
- en: '![Time for action Saving all essential game data in the local storage](img/1260_07_10.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间 在本地存储中保存所有必要的游戏数据](img/1260_07_10.jpg)'
- en: What just happened?
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have just entered all essential game data into an object named `savingObject`.
    This `savingObject` contains all information that we need to recreate the game
    later. It includes the order of cards, removed cards, and the current elapsed
    time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将所有必要的游戏数据输入到一个名为`savingObject`的对象中。这个`savingObject`包含了我们以后重建游戏所需的所有信息。它包括卡片的顺序、已删除的卡片和当前经过的时间。
- en: Lastly, we saved `savingObject` in `localStorage` on each second. The object
    is encoded into JSON using the `stringify` function we used earlier in this chapter.
    Then, we recreated the game by parsing the JSON string from the local storage.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在每秒钟将`savingObject`保存在`localStorage`中。该对象使用我们在本章前面使用的`stringify`函数进行JSON编码。然后，我们通过解析来自本地存储的JSON字符串来重新创建游戏。
- en: Removing a record from the local storage
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从本地存储中删除记录
- en: We need to remove the saved record when the game is over. Otherwise, the new
    game will not start. Local storage provides a `remoteItem` function to remove
    a specific record.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，我们需要删除保存的记录。否则，新游戏将无法开始。本地存储提供了一个`remoteItem`函数来删除特定记录。
- en: 'Here is how we use the function to remove the record with the given key:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用该函数来删除具有给定键的记录：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to remove all stored records, then you can use the `localStorage.clear()`
    function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除所有存储的记录，可以使用`localStorage.clear()`函数。
- en: Cloning an array in JavaScript
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中克隆数组
- en: 'We cloned the shuffled deck in `savingObject`, so that we could use the order
    of the deck to recreate the cards when we resumed the game. However, we cannot
    copy an array by assigning the array to another variable. The following code fails
    to copy an array A to array B:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`savingObject`中克隆了洗过的牌组，这样我们就可以在恢复游戏时使用牌组的顺序来重新创建卡片。但是，我们不能通过将数组分配给另一个变量来复制数组。以下代码无法将数组A复制到数组B：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `slice` function provides an easy way to clone an array with only primitive
    types of elements. We can clone an array with the `slice` function as long as
    it does not contain another array or object as an element. The following code
    successfully clones an array A to B:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice`函数提供了一种简单的方法来克隆只包含基本类型元素的数组。只要数组不包含另一个数组或对象作为元素，我们就可以使用`slice`函数来克隆数组。以下代码成功地将数组A克隆到B：'
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `slice` function is normally used to create a new array by selecting a
    range of elements from an existing array. When using the `slice` function without
    any arguments, it clones the entire array. The Mozilla Developer Network provides
    a detailed usage on the `slice` function at the following URL:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice`函数通常用于通过从现有数组中选择一系列元素来创建一个新数组。当使用`slice`函数而没有任何参数时，它会克隆整个数组。Mozilla开发者网络在以下URL提供了有关`slice`函数的详细用法：'
- en: '[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice](http://https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice](http://https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)'
- en: Resuming the game progress
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复游戏进度
- en: We have saved the game progress, but have not yet written the logic for resuming
    the game. So, let's move on to the resuming part.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已保存了游戏进度，但尚未编写恢复游戏的逻辑。所以，让我们继续进行恢复部分。
- en: Time for action Resuming a game from the local storage
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 从本地存储中恢复游戏
- en: 'Carry out the following steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `html5games.matchgame.js` JavaScript file.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.matchgame.js` JavaScript文件。
- en: 'In the jQuery ready function, we used the saved order of deck in the previous
    game instead of shuffling a new deck. Add the following highlighted code into
    the `ready` function:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery的ready函数中，我们使用了上一局游戏中牌组的保存顺序，而不是洗牌一个新的牌组。将以下突出显示的代码添加到`ready`函数中：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After initializing the cards in the ready function, we remove cards which were
    removed in the previous game. We also restore the saved elapsed time from the
    saved value. Add the following highlighted code in the jQuery ready function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ready函数中初始化卡片后，我们删除了上一局游戏中删除的卡片。我们还从保存的值中恢复了经过的时间。在jQuery的ready函数中添加以下突出显示的代码：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we create the following function to retrieve `savingObject` from the
    local storage:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建了以下函数来从本地存储中检索`savingObject`：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Save all files and open the game in web a browser. Try playing the game by
    removing several matching cards. Then, close the browser window and open the game
    again. The game should resume from the state where we closed the window, as shown
    in the following screenshot:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并在web浏览器中打开游戏。尝试通过移除几张匹配的卡片来玩游戏。然后关闭浏览器窗口并再次打开游戏。游戏应该从我们关闭窗口的状态恢复，如下图所示：
- en: '![Time for action Resuming a game from the local storage](img/1260_07_11.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 从本地存储中恢复游戏](img/1260_07_11.jpg)'
- en: What just happened?
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just finished the game loading part by parsing the saved JSON string of the
    entire game status.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过解析整个游戏状态的保存JSON字符串完成了游戏加载部分。
- en: 'Then, we restored the elapsed time and order of deck from the loaded `savingObject`.
    Restoring these two properties is simply variable assigning. The tricky part is
    recreating the card removing. In the game saving section, we assigned an index
    to each card DOM by **custom data attribute** `data-card-index`. We stored the
    index of each removed card when saving the game, so we can know which cards are
    removed when loading the game. Then, we can remove those cards when the game sets
    up. The following code removes the cards in a jQuery game `ready` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从加载的`savingObject`中恢复了经过的时间和牌组的顺序。恢复这两个属性只是简单的变量赋值。棘手的部分是重新创建卡片的移除。在游戏保存部分，我们为每张卡片DOM分配了一个索引，使用**自定义数据属性**
    `data-card-index`。当保存游戏时，我们存储了每张已移除卡片的索引，因此我们可以在加载游戏时知道哪些卡片已被移除。然后，我们可以在游戏设置时移除这些卡片。以下代码在jQuery游戏`ready`函数中移除卡片：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Tracking the storage changes with the storage event**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用存储事件跟踪存储更改**'
- en: 'Sometimes, we may want to listen to the changes of the `localStorage`. We can
    do that by listening to the `storage` event. It is fired when anything is changed
    in the `localStorage`. The following link from *Dive into HTML5* provides a detailed
    discussion on how we can use the event:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能想要监听`localStorage`的变化。我们可以通过监听`storage`事件来实现。当`localStorage`中的任何内容发生变化时，该事件将被触发。来自*Dive
    into HTML5*的以下链接提供了关于如何使用该事件的详细讨论：
- en: '[http://diveintohtml5.org/storage.html#storage-event](http://diveintohtml5.org/storage.html#storage-event)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://diveintohtml5.org/storage.html#storage-event](http://diveintohtml5.org/storage.html#storage-event)'
- en: Pop quiz Using local storage
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验 使用本地存储
- en: 'Consider whether each of the following statements is true or not:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下每个陈述是否为真：
- en: We can save an integer or object directly in the local storage.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接将整数或对象保存在本地存储中。
- en: We can save the data of an object into the local storage by encoding them into
    a string.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将对象编码为字符串来将对象的数据保存到本地存储中。
- en: We can use `localStorage["hello"] = "world"` to save the value "world" with
    key "hello" in the local storage.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`localStorage["hello"] = "world"`将值"world"与键"hello"保存在本地存储中。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We learned a lot in this chapter about using the local storage to save the game
    data in a web browser.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了如何使用本地存储在Web浏览器中保存游戏数据。
- en: 'Specifically, we covered:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: Saving and retrieving basic data into the key-value pair local storage
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基本数据保存和检索到键值对本地存储中
- en: Encoding an object into the JSON formatted string and parsing the string back
    to a JavaScript object
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象编码为JSON格式的字符串，然后将字符串解析回JavaScript对象
- en: Saving the entire game progress, so the game can resume even if left mid way
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存整个游戏进度，以便即使中途离开，游戏也可以恢复
- en: We also created a nice 3D ribbon as a **new record** badge in pure CSS3 styling.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用纯CSS3样式创建了一个漂亮的3D丝带作为**新记录**徽章。
- en: Now that we have learned about improving our previous games by using the local
    storage, we are ready to move on to an advanced feature named **WebSocket** which
    connects players together in a real time interaction.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何通过使用本地存储来改进我们以前的游戏，我们准备进入一个名为**WebSocket**的高级功能，它可以在实时互动中连接玩家。
