- en: Chapter 8. Building a Multiplayer Draw-and-Guess Game with WebSockets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用WebSockets构建多人绘画和猜词游戏
- en: We built several local single player games in previous chapters. In this chapter,
    we will build a multiplayer game with the help of WebSockets. WebSockets enable
    us to create event-based server-client architecture. The messages passed between
    all connected browsers become instant. We will combine the canvas drawing, JSON
    data packing, and several techniques learned in previous chapters to build the
    draw-and-guess game.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们构建了几个本地单人游戏。在本章中，我们将借助WebSockets构建一个多人游戏。WebSockets使我们能够创建基于事件的服务器-客户端架构。所有连接的浏览器之间传递的消息都是即时的。我们将结合Canvas绘图、JSON数据打包和在之前章节中学到的几种技术来构建绘画和猜词游戏。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Trying an existing multiuser sketchpad which shows drawings from different connected
    users through WebSockets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试现有的多用户绘图板，通过WebSockets显示来自不同连接用户的绘画
- en: Installing a WebSockets server which is implemented by `node.js`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装由`node.js`实现的WebSockets服务器
- en: Connecting the server from a browser
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浏览器连接服务器
- en: Creating an instant chat room with WebSocket API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebSocket API创建一个即时聊天室
- en: Creating a multiuser drawing pad in Canvas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Canvas中创建一个多用户绘图板
- en: Building a draw-and-guess game by integrating the chat room and drawing with
    game logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集成聊天室和游戏逻辑进行绘画和猜词游戏的构建
- en: 'The following screenshot shows the draw-and-guess game that we will create
    in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了我们将在本章中创建的绘画和猜词游戏：
- en: '![Building a Multiplayer Draw-and-Guess Game with WebSockets](img/1260_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![使用WebSockets构建多人绘画和猜词游戏](img/1260_08_01.jpg)'
- en: So, let's get on with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧。
- en: Trying an existing WebSockets web application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试现有的WebSockets网络应用程序
- en: Before we start to build our WebSockets example, we will take a look at an existing
    multiuser sketchpad example. This example lets us know how the data is sent between
    browsers by using the WebSockets server instantly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建WebSockets示例之前，我们将看一下现有的多用户绘图板示例。这个示例让我们知道如何使用WebSockets服务器立即在浏览器之间发送数据。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A browser''s capability of using WebSockets**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器使用WebSockets的能力**'
- en: At the time of writing this book, only Apple Safari and Google Chrome supported
    the WebSockets API. Mozilla Firefox and Opera dropped support on WebSockets because
    of a potential security issue on the protocol. Google Chrome is also planning
    to drop WebSockets until the security hole is fixed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，只有苹果Safari和Google Chrome支持WebSockets API。Mozilla Firefox和Opera因协议上的潜在安全问题而放弃了对WebSockets的支持。Google
    Chrome也计划在安全漏洞修复之前放弃WebSockets。
- en: 'The following link from Mozilla explains why they disabled WebSockets:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla的以下链接解释了他们为什么禁用了WebSockets：
- en: '[http://hacks.mozilla.org/2010/12/websockets-disabled-in-firefox-4/](http://hacks.mozilla.org/2010/12/websockets-disabled-in-firefox-4/)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://hacks.mozilla.org/2010/12/websockets-disabled-in-firefox-4/](http://hacks.mozilla.org/2010/12/websockets-disabled-in-firefox-4/)'
- en: Time for action Trying the multiuser sketchpad
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试多用户绘图板的时间
- en: 'Carry out the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Open the following link in a web browser:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中打开以下链接：
- en: '[http://www.chromeexperiments.com/detail/multiuser-sketchpad/](http://www.chromeexperiments.com/detail/multiuser-sketchpad/)'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://www.chromeexperiments.com/detail/multiuser-sketchpad/](http://www.chromeexperiments.com/detail/multiuser-sketchpad/)'
- en: You will get an introduction page of the multiuser sketchpad. Right click on
    the **Launch Experiment** option and choose **Open link in new window**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个多用户绘图板的介绍页面。右键单击**启动实验**选项，选择**在新窗口中打开链接**。
- en: The browser prompts a new window with the sketchpad application. Then, we repeat
    the preceding step again to open another instance of the sketchpad.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器会提示一个新窗口，显示绘图板应用程序。然后，我们重复上一步，再次打开绘图板的另一个实例。
- en: Put the two browsers side by side on the desktop.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个浏览器并排放在桌面上。
- en: Try to draw something on either sketchpad. The drawing should appear on both
    sketchpads. In addition, the sketchpad is shared with everyone who is connecting.
    You may also see drawings from other users.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在任一绘图板上画些东西。绘画应该会出现在两个绘图板上。此外，绘图板是与所有连接的人共享的。您还可以看到其他用户的绘画。
- en: 'The following screenshot shows a cup drawn on the sketchpad by two users:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了两个用户在绘图板上画的一个杯子：
- en: '![Time for action Trying the multiuser sketchpad](img/1260_08_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![尝试多用户绘图板的时间](img/1260_08_02.jpg)'
- en: What just happened?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have just seen how browsers can be connected together in real time. We draw
    something on the sketchpad and all other connected users can view the drawings.
    In addition, we can see what others are drawing too.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到浏览器如何实时连接在一起。我们在绘图板上画了些东西，所有其他连接的用户都可以看到这些图画。此外，我们也可以看到其他人正在画什么。
- en: The example is made by using the HTML5 WebSockets feature with a backend server
    to broadcast drawing data to all connected browsers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例是使用HTML5 WebSockets功能与后端服务器制作的，以向所有连接的浏览器广播绘图数据。
- en: The drawing part is built on a canvas which we already covered in *Chapter 4,
    Building* the *Untangle Game with Canvas and Drawing API*. The WebSocket API enables
    browsers to establish a persistent connection with the server. The backend is
    an event-based server named `node.js` which we will install and use in this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 绘画部分是建立在Canvas上的，我们已经在*第4章，使用Canvas和绘图API构建Untangle游戏*中介绍过。WebSocket API使浏览器能够与服务器建立持久连接。后端是一个名为`node.js`的基于事件的服务器，我们将在本章中安装和使用。
- en: Installing a WebSocket server
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装WebSocket服务器
- en: The HTML5, WebSockets provides a client-side API to connect a browser to a backend
    server. This server has to support WebSockets protocol in order to keep the connection
    persistent.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5的WebSockets提供了一个客户端API，用于将浏览器连接到后端服务器。该服务器必须支持WebSockets协议，以保持连接持久。
- en: Installing the Node.JS WebSocket server
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.JS WebSocket服务器
- en: In this section, we will download and install a server named `Node.JS` on which
    we can install a WebSockets module.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将下载并安装一个名为`Node.JS`的服务器，我们可以在上面安装一个WebSockets模块。
- en: Time for action Installing Node.JS
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node.JS的时间
- en: 'Carry out the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Go to the following URL which contains the source code of the `Node.JS` server:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到包含`Node.JS`服务器源代码的以下URL：
- en: '[https://github.com/joyent/node](https://github.com/joyent/node)'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://github.com/joyent/node](https://github.com/joyent/node)'
- en: Click on the **Downloads** button on the page. It prompts a dialog asking which
    format to download. Just select the ZIP format.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击页面上的**下载**按钮。它会提示一个对话框询问要下载哪种格式。只需选择ZIP格式。
- en: Unzip the ZIP file in a working directory.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作目录中解压ZIP文件。
- en: In Linux or Mac OSX, use Terminal and change the directory to where the `node.js`
    file is located.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux或Mac OSX中，使用终端并切换到`node.js`文件所在的目录。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Node.JS` works out of the box in Linux and Mac. The following link provides
    an installer for installing it on Windows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.JS`在Linux和Mac上可以直接使用。以下链接提供了一个安装程序，用于在Windows上安装`Node.JS`：'
- en: '[http://node-js.prcn.co.cc/](http://node-js.prcn.co.cc/)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://node-js.prcn.co.cc/](http://node-js.prcn.co.cc/)'
- en: 'Run the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `sudo make install` command installs `Node.JS` with root ownership and also
    installs the required third party libraries with root access. The following link
    discusses how we can install the `Node.JS` without using `sudo:`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sudo make install`命令以root权限安装`Node.JS`，并以root访问权限安装所需的第三方库。以下链接讨论了如何在不使用`sudo`的情况下安装`Node.JS`：
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '[http://increaseyourgeek.wordpress.com/2010/08/18/install-node-js-without-using-sudo/](http://increaseyourgeek.wordpress.com/2010/08/18/install-node-js-without-using-sudo/)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://increaseyourgeek.wordpress.com/2010/08/18/install-node-js-without-using-sudo/](http://increaseyourgeek.wordpress.com/2010/08/18/install-node-js-without-using-sudo/)'
- en: The `sudo make install` command requires typing the password of the user in
    a system who has admin privileges. Type the password to continue the installation.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sudo make install`命令需要输入具有管理员特权的系统用户的密码。输入密码以继续安装。'
- en: 'After the installation, we can check whether the `node.js` is installed by
    checking its version with the following command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，可以使用以下命令检查`node.js`是否已安装：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command should print a version number of the `node.js`. In my
    case, it is version 0.5 pre:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令应该打印出`node.js`的版本号。在我的情况下，它是0.5预发布版：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will install the WebSockets library for the `Node.JS` server. Go to
    the following URL in a browser:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为`Node.JS`服务器安装WebSockets库。在浏览器中转到以下URL：
- en: '[https://github.com/miksago/node-websocket-server](http://https://github.com/miksago/node-websocket-server)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://github.com/miksago/node-websocket-server](http://https://github.com/miksago/node-websocket-server)'
- en: Click on the **Downloads** button on the page and download the ZIP file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击页面上的**下载**按钮并下载ZIP文件。
- en: Unzip the ZIP file in a directory. We will need the `lib` directory in this
    package later.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个目录中解压ZIP文件。我们稍后会需要这个包中的`lib`目录。
- en: What just happened?
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just downloaded and installed the `Node.JS` server. We also downloaded the
    WebSockets library for the `node.js` server. We will build server logic on top
    of this server and the WebSockets library through the examples in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚下载并安装了`Node.JS`服务器。我们还下载了`node.js`服务器的WebSockets库。通过本章的示例，我们将在此服务器和WebSockets库的基础上构建服务器逻辑。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Node.js` server installation runs well on Unix or Linux operating systems.
    However, it requires a few more steps to install and run the `node.js` server
    on Windows. The following link shows how we can install the `node.js` server on
    Windows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.js`服务器安装在Unix或Linux操作系统上运行良好。但是，在Windows上安装和运行`node.js`服务器需要更多步骤。以下链接显示了如何在Windows上安装`node.js`服务器：'
- en: '[https://github.com/joyent/node/wiki/Building-node.js-on-Cygwin-(Windows)](http://https://github.com/joyent/node/wiki/Building-node.js-on-Cygwin-(Windows))'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/joyent/node/wiki/Building-node.js-on-Cygwin-(Windows)](http://https://github.com/joyent/node/wiki/Building-node.js-on-Cygwin-(Windows))'
- en: Creating a WebSockets server to broadcast the connection count
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用于广播连接计数的WebSockets服务器
- en: We just installed the `node.js` server with the WebSockets library. Now, we
    will build something to test the WebSockets. Imagine now we want a server that
    accepts connections from browsers and then broadcasts the connection count to
    all users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚安装了带有WebSockets库的`node.js`服务器。现在，我们将构建一些内容来测试WebSockets。现在想象一下，我们需要一个服务器来接受浏览器的连接，然后向所有用户广播连接计数。
- en: Time for action Creating a WebSocket server that sends the total count of connections
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行以下操作创建一个发送连接总数的WebSocket服务器
- en: 'Carry out the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a new directory named `server`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`server`的新目录。
- en: Copy the entire `lib` folder in the `node-websocket-server` package in the `server`
    directory.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`node-websocket-server`包中的整个`lib`文件夹复制到`server`目录中。
- en: 'Create a new file named `server.js` under the `server` directory with the following
    content:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server`目录下创建一个名为`server.js`的新文件，并包含以下内容：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open the terminal and change to the server directory.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并切换到服务器目录。
- en: 'Type the following command to execute the server:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以执行服务器：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We should get the following result if it works:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，应该得到以下结果：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What just happened?
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just created a simple server logic that initialized the WebSockets library
    and listened to the connection event.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个简单的服务器逻辑，初始化了WebSockets库，并监听了连接事件。
- en: Initializing the WebSockets server
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化WebSockets服务器
- en: 'In `Node.JS`, different functions are packed into modules. When we need a functionality
    in a specific module, we use `require` to load it. We load the WebSockets module
    and then initialize the server using the following code in the server logic:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Node.JS`中，不同的功能被打包到模块中。当我们需要特定模块中的功能时，我们使用`require`进行加载。我们加载WebSockets模块，然后在服务器逻辑中使用以下代码初始化服务器：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`__dirname` represents the current directory of the server JavaScript file
    that is being executed. We placed the `lib` folder under the same folder of our
    server logic file. Therefore, the WebSockets server is in **current directory**
    | **lib** | **ws** | **server**.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dirname`表示正在执行的服务器JavaScript文件的当前目录。我们将`lib`文件夹放在服务器逻辑文件的同一文件夹下。因此，WebSockets服务器位于**当前目录**
    | **lib** | **ws** | **server**。'
- en: 'At last, we need to assign a port for the server to listen to by the following
    code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为服务器分配一个端口来监听以下代码：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code snippet, `8000` is the port number with which a client
    connects to this server. We may choose a different port number, but we have to
    ensure that the chosen port number is not overlapped by other common server services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`8000`是客户端连接到此服务器的端口号。 我们可以选择不同的端口号，但必须确保所选的端口号不会与其他常见服务器服务重叠。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to get more information about the global scope objects and variables
    from the `node.js` server, please visit their official document at the following
    link:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取有关`node.js`服务器的全局范围对象和变量的更多信息，请访问以下链接的官方文档：
- en: '[http://nodejs.org/docs/v0.4.3/api/globals.html](http://nodejs.org/docs/v0.4.3/api/globals.html)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://nodejs.org/docs/v0.4.3/api/globals.html](http://nodejs.org/docs/v0.4.3/api/globals.html)'
- en: Listening to the connection event on the server side
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端监听连接事件
- en: 'The `node.js` server is event-based. This means that most logic is executed
    when a certain event is fired. The following code we used in the example listens
    to the `connection` event and handles it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`node.js`服务器是基于事件的。 这意味着大多数逻辑是在触发某个事件时执行的。 我们在示例中使用的以下代码监听`connection`事件并处理它：'
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `connection` event comes with a connection argument. We have an `id` property
    in the connection instance that we can use to distinguish each connected client.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection`事件带有一个连接参数。 我们在连接实例中有一个`id`属性，我们可以用它来区分每个连接的客户端。'
- en: 'The following table lists two commonly used server events:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表列出了两个常用的服务器事件：
- en: '| Server-side event for WebSockets node.js | Description |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| WebSockets node.js的服务器端事件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `connection` | Event fires when there is a new connection established by
    the client |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `connection` | 当客户端建立新连接时触发事件 |'
- en: '| `close` | Event fires when a connection closes |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 当连接关闭时触发事件 |'
- en: Getting a count of connected clients on the server side
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取服务器端连接的客户端计数
- en: 'We can get the count of connected clients in the WebSockets `node.js` server
    by accessing the server manager. We can get the count by using the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问服务器管理器来获取WebSockets `node.js`服务器中连接的客户端数。 我们可以使用以下代码获取计数：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Broadcasting a message to all connected browsers
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向所有连接的浏览器广播消息
- en: Once the server gets a new `connection` event, we broadcast the updated count
    of the connection to all clients. Broadcasting a message to clients is easy. We
    just need to call the `broadcast` function in the `server` instance with a `string`
    argument as the message.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器收到新的`connection`事件，我们就会向所有客户端广播连接的更新计数。 向客户端广播消息很容易。 我们只需要在`server`实例中使用`string`参数调用`broadcast`函数。
- en: 'The following code snippet broadcasts a server message to all connected browsers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段向所有连接的浏览器广播服务器消息：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating a client that connects to a WebSocket server and getting the total
    connections count
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个连接到WebSocket服务器并获取总连接数的客户端
- en: We built the server in the last example and now we will build a client that
    connects to our WebSocket server and receives messages from the server. The message
    will contain the total connection count from the server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个示例中构建了服务器，现在我们将构建一个客户端，连接到我们的WebSocket服务器并从服务器接收消息。 该消息将包含来自服务器的总连接计数。
- en: Time for action Showing the connection count in a WebSocket application
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间在WebSocket应用程序中显示连接计数
- en: 'Carry out the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a new directory named `client`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`client`的新目录。
- en: Create an HTML file named `index.htm` in the `client` folder.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client`文件夹中创建一个名为`index.htm`的HTML文件。
- en: 'We will add a few markups in our HTML file. Put the following code in the `index.htm`
    file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在我们的HTML文件中添加一些标记。 将以下代码放入`index.htm`文件中：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Create a directory named `js` and put the jQuery JavaScript file inside.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`js`的目录，并将jQuery JavaScript文件放入其中。
- en: 'Create a new file named `html5games.websockets.js` as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`html5games.websockets.js`的新文件，如下所示：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will test the code. First, we need to run the node server with our `server.js`
    code by node `server.js`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将测试代码。 首先，我们需要通过`node server.js`运行带有我们的`server.js`代码的节点服务器。
- en: Next, open the `index.htm` file in a client directory in a web browser twice.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Web浏览器中的客户端目录中打开`index.htm`文件两次。
- en: 'Inspect the server terminal. There should be log messages similar to the following
    indicating the connection information and total connection count:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查服务器终端。 应该有类似以下的日志消息，指示连接信息和总连接数：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we inspect the console panel in a browser. We get the total connection
    count once we have loaded the page. The following screenshot shows the result
    on the client side:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在浏览器中检查控制台面板。 一旦加载页面，我们就可以获得总连接数。 以下屏幕截图显示了客户端端的结果：
- en: '![Time for action Showing the connection count in a WebSocket application](img/1260_08_03.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间在WebSocket应用程序中显示连接计数](img/1260_08_03.jpg)'
- en: What just happened?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just built a client that established a WebSockets connection to the server
    we built in the last section. The client then prints any message received from
    the server to the console panel in the Inspector.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个客户端，它与我们在上一节中构建的服务器建立了WebSockets连接。 然后，客户端将从服务器接收的任何消息打印到检查器中的控制台面板中。
- en: Establishing a WebSocket connection
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立WebSocket连接
- en: 'In any browser that supports WebSockets, we can establish a connection by creating
    a new WebSocket instance with the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持WebSockets的任何浏览器中，我们可以通过使用以下代码创建一个新的WebSocket实例来建立连接：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `url` argument is a string with the WebSockets URL. In our example, we are
    running our server locally. Therefore, the URL we have used is `ws://127.0.0.1:8000`,
    where 8000 represents the port number of the server to which we are connecting.
    It is 8000 because the server is listening to the port 8000 when we built the
    server-side logic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`参数是一个带有WebSockets URL的字符串。 在我们的示例中，我们正在本地运行我们的服务器。 因此，我们使用的URL是`ws://127.0.0.1:8000`，其中8000表示我们正在连接的服务器的端口号。
    这是8000，因为当我们构建服务器端逻辑时，服务器正在监听端口8000。'
- en: WebSockets client events
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSockets客户端事件
- en: 'Similar to the server, we have several WebSockets events on the client side.
    The following table lists the events we will use to deal with WebSockets:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器类似，客户端端有几个WebSockets事件。以下表格列出了我们将用于处理WebSockets的事件：
- en: '| Event name | Description |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `onopen` | Fired when a connection to the server is established |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `onopen` | 当与服务器的连接建立时触发 |'
- en: '| `onmessage` | Fired when any message from the server is received |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `onmessage` | 当从服务器接收到任何消息时触发 |'
- en: '| `onclose` | Fired when the server closes the connection |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `onclose` | 当服务器关闭连接时触发 |'
- en: '| `onerror` | Fired when there is any error in the connection |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `onerror` | 当连接出现任何错误时触发 |'
- en: Building a chatting application with WebSockets
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebSockets构建聊天应用程序
- en: We now know how many browsers are connected. Suppose we want to build a chat
    room where users can type a message in their respective browsers and broadcast
    the message to all the connected users instantly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道有多少浏览器连接。假设我们想要构建一个聊天室，用户可以在各自的浏览器中输入消息，并立即将消息广播给所有连接的用户。
- en: Sending a message to the server
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向服务器发送消息
- en: We will let the user input a message and then send the message to the `node.js`
    server. The server will then forward the message to all connected browsers. Once
    the browser receives the messages, it displays it in the chat area. In this case,
    the users are connected to the instant chat room once they load the web page.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让用户输入消息，然后将消息发送到`node.js`服务器。然后服务器将消息转发到所有连接的浏览器。一旦浏览器接收到消息，它就会在聊天区域显示出来。在这种情况下，用户一旦加载网页就连接到即时聊天室。
- en: Time for action Sending a message to the server through WebSockets
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动 通过WebSockets向服务器发送消息
- en: 'Carry out the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: First, code the server logic.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编写服务器逻辑。
- en: 'Open `server.js` and add the following highlighted code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`server.js`并添加以下突出显示的代码：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now move on to the `client` folder.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`client`文件夹。
- en: 'Open the `index.htm` file and add the following markup in the `body` section.
    It provides inputs for the user to type and send messages to the server:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.htm`文件，并在`body`部分中添加以下标记。它为用户提供了输入并发送消息到服务器的输入：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, add the following code to the `html5games.websocket.js` JavaScript file.
    It sends the message to the server when the user clicks on the `send` button or
    presses the **Enter** key:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下代码添加到`html5games.websocket.js` JavaScript文件中。当用户单击`send`按钮或按**Enter**键时，它将消息发送到服务器：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Before testing our code, check the server terminal and see whether the node
    server is still running. Press **Ctrl+C** to terminate it and run it again by
    using the `node server.js` command.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试我们的代码之前，检查服务器终端，看看node服务器是否仍在运行。按**Ctrl+C**终止它，然后使用`node server.js`命令再次运行它。
- en: Open `index.htm` in a web browser. You should see an input text field with a
    **Send** button as shown in the following screenshot:![Time for action Sending
    a message to the server through WebSockets](img/1260_08_04.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中打开`index.htm`。您应该看到一个带有**Send**按钮的输入文本字段，如下面的屏幕截图所示：![采取行动 通过WebSockets向服务器发送消息](img/1260_08_04.jpg)
- en: Try to type something in the input text field and then click on the **Send**
    button or press **Enter**. The input text is cleared.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在输入文本字段中输入一些内容，然后单击**Send**按钮或按**Enter**。输入文本将被清除。
- en: 'Now, switch to the server terminal and we will see the server printing the
    text we just sent. You can also put the browser and server terminal side by side
    to see how instantly the message is sent from the client to the server. The following
    screenshot shows the server terminal with messages from two connected browsers:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到服务器终端，我们将看到服务器打印我们刚刚发送的文本。您还可以将浏览器和服务器终端并排放置，以查看消息从客户端发送到服务器的实时性。以下屏幕截图显示了服务器终端上来自两个连接的浏览器的消息：
- en: '![Time for action Sending a message to the server through WebSockets](img/1260_08_05.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![采取行动 通过WebSockets向服务器发送消息](img/1260_08_05.jpg)'
- en: What just happened?
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just extended our connection example by adding an input text field for the
    users to type some text there and send it out. The text is sent as a message to
    the WebSockets server. The server will then print the received message in the
    terminal.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过添加一个输入文本字段来扩展了我们的连接示例，让用户在其中输入一些文本并将其发送出去。文本作为消息发送到WebSockets服务器。然后服务器将在终端中打印接收到的消息。
- en: Sending a message from the client to the server
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端向服务器发送消息
- en: 'In order to send a message from the client to the server, we call the following
    `send` method in the `WebSocket` instance:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从客户端向服务器发送消息，我们在`WebSocket`实例中调用以下`send`方法：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the following code snippet from our example, we get the message from the
    input text field and send it to the server:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，以下代码片段从输入文本字段中获取消息并将其发送到服务器：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Receiving a message on the server side
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端接收消息
- en: On the server side, we need to handle the message we just sent from the client.
    We have an event named `message` in the connection instance in the WebSocket `node.js`
    library. We can listen to the connection message event to receive a message from
    each client connection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们需要处理刚刚从客户端发送的消息。在WebSocket `node.js`库中的连接实例中有一个名为`message`的事件。我们可以监听连接消息事件以接收来自每个客户端连接的消息。
- en: 'The following code snippet shows how we use the message event listener to print
    the message and the unique connection ID on the server terminal:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们如何使用消息事件监听器在服务器终端上打印消息和唯一连接ID：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only string is accepted when sending and receiving messages between the server
    and the client. We cannot directly send objects. However, we can convert the data
    into a JSON-formatted string before transmitting. We will show an example of sending
    data objects later in this chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器和客户端之间发送和接收消息时，只接受字符串。我们不能直接发送对象。但是，我们可以在传输之前将数据转换为JSON格式的字符串。我们将在本章后面展示发送数据对象的示例。
- en: Broadcasting every received message on the server side to create a chat room
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器端广播每条接收到的消息以创建聊天室
- en: In the last example, the server could receive messages sent from browsers. However,
    the server does nothing except print the received messages in the terminal. Therefore,
    we will add some logic to the server to broadcast the messages out.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，服务器可以接收来自浏览器的消息。但是，服务器除了在终端中打印接收到的消息之外，什么也不做。因此，我们将向服务器添加一些逻辑，以广播消息。
- en: Time for action Broadcasting the messages to all connected browsers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行广播消息到所有连接的浏览器的操作
- en: 'Carry out the following steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `server.js` file for the server-side logic.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开服务器端逻辑的`server.js`文件。
- en: 'Add the following highlighted code to the message event listener handler:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到消息事件监听器处理程序中：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That is it for the server side. Move on to the `client` folder and open the
    `index.htm` file.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端就是这样。转到`client`文件夹并打开`index.htm`文件。
- en: 'We want to display the chat messages in the chat history area. Add the following
    code to the HTML file:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想在聊天历史区域显示聊天消息。将以下代码添加到HTML文件中：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need the client-side JavaScript to handle the received message from
    the server. We used it to print it out into the console panel, replace the `console.log`
    code by the following highlighted code in the `onmessage` event handler:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要客户端JavaScript来处理从服务器接收的消息。我们用它将消息打印到控制台面板中，用以下突出显示的代码替换`onmessage`事件处理程序中的`console.log`代码：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's test our code. Terminate any running node server by **Ctrl + C**. Then
    run the server again.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试我们的代码。通过**Ctrl + C**终止任何正在运行的node服务器。然后再次运行服务器。
- en: 'Open the `index.htm` file twice and put them side by side. Type something in
    the text field and press **Enter**. The message will appear on both opened browsers.
    If you open many instances of the HTML file, the message should appear on all
    browsers. The following screenshot shows two browsers displaying the chat history
    side by side:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.htm`文件两次，将它们并排放置。在文本字段中输入一些内容，然后按**Enter**。消息将出现在所有打开的浏览器上。如果打开多个HTML文件实例，则消息应该出现在所有浏览器上。下面的截图显示了两个并排显示聊天历史记录的浏览器：
- en: '![Time for action Broadcasting the messages to all connected browsers](img/1260_08_06.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![执行广播消息到所有连接的浏览器的操作](img/1260_08_06.jpg)'
- en: What just happened?
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: This is an extension of our previous examples. We discussed how a server broadcasts
    the connection count to all connected clients. We also discussed how the client
    sends a message to the server. In this example, we combine these two techniques
    to let the server broadcast the received messages to all connected users.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前示例的延伸。我们讨论了服务器如何向所有连接的客户端广播连接计数。我们还讨论了客户端如何向服务器发送消息。在这个例子中，我们将这两种技术结合起来，让服务器将接收到的消息广播给所有连接的用户。
- en: Comparing between WebSockets and polling approaches
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较WebSocket和轮询方法
- en: If you have ever built a web page chat room by using a server-side language
    and a database, then you may wonder what is the difference between the WebSocket
    implementation and the traditional one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用服务器端语言和数据库构建过网页聊天室，那么您可能会想知道WebSocket实现和传统实现之间有什么区别。
- en: The traditional chat room method is often implemented by using a **polling**
    approach. The client asks the server for an update periodically. The server responds
    to the client with either no update or updated data. However, the traditional
    approach has several problems. The client does not get new data updated from the
    server until the next time it asks the server. This means that the data update
    is delayed with the periodic time and the response is not instant enough. If we
    want to improve this issue by shortening the polling duration, then more bandwidth
    is utilized because clients need to keep sending requests to the server.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的聊天室方法通常使用**轮询**方法实现。客户端定期向服务器请求更新。服务器会用没有更新或更新的数据来响应客户端。然而，传统方法存在一些问题。客户端直到下一次向服务器请求之前，才能从服务器获取新的更新数据。这意味着数据更新会延迟一段时间，响应不够即时。如果我们想通过缩短轮询持续时间来改善这个问题，那么会利用更多的带宽，因为客户端需要不断向服务器发送请求。
- en: 'The following graph shows requests between the client and the server. It shows
    that many useless requests are sent, but the server responds to the client without
    any new data:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了客户端和服务器之间的请求。它显示了许多无用的请求被发送，但服务器在没有新数据的情况下响应客户端：
- en: '![Comparing between WebSockets and polling approaches](img/1260_08_07.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![WebSocket和轮询方法之间的比较](img/1260_08_07.jpg)'
- en: 'There is a better polling approach named **long polling**. The client sends
    a request to the server and waits for the response. Instead of the traditional
    polling approach where the server responds with "no update", the server does not
    respond at all until there is something that needs to be pushed to the server.
    In this approach, the server can push something to clients whenever there is an
    update. Once the client receives a response from the server, it creates another
    request and waits for the next server notification. The following graph shows
    the long polling approach where clients ask for updates and the server responds
    only when there is an update:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更好的轮询方法叫做**长轮询**。客户端向服务器发送请求并等待响应。与传统的轮询方法不同，服务器不会以“没有更新”的方式响应，直到有需要推送给服务器的内容。在这种方法中，服务器可以在有更新时向客户端推送内容。一旦客户端从服务器收到响应，它会创建另一个请求并等待下一个服务器通知。下面的图显示了长轮询方法，客户端请求更新，服务器只在有更新时响应：
- en: '![Comparing between WebSockets and polling approaches](img/1260_08_13.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![WebSocket和轮询方法之间的比较](img/1260_08_13.jpg)'
- en: 'In the WebSockets approach, the number of requests are way less than the polling
    approach. It is because the connection between the client and server is persistent.
    Once the connection is established, a request from either the client side or the
    server side is sent only when there is any update. For instance, a client sends
    a message to the server when it wants to update something to the server. The server
    also sends messages to clients only when it needs to notify the clients of a data
    update. No other useless requests are sent during the connection. Therefore, less
    bandwidth is utilized. The following graph shows the WebSockets approach:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebSockets方法中，请求的数量远少于轮询方法。这是因为客户端和服务器之间的连接是持久的。一旦建立连接，只有在有任何更新时才会从客户端或服务器端发送请求。例如，当客户端想要向服务器更新某些内容时，客户端向服务器发送消息。服务器也只在需要通知客户端数据更新时才向客户端发送消息。在连接期间不会发送其他无用的请求。因此，利用的带宽更少。以下图显示了WebSockets方法：
- en: '![Comparing between WebSockets and polling approaches](img/1260_08_08.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![WebSockets和轮询方法之间的比较](img/1260_08_08.jpg)'
- en: Pop quiz The benefit of WebSockets verses the polling approach
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验：WebSockets相对于轮询方法的好处
- en: What are the benefits of using an event-based WebSockets approach to implement
    the multiuser chat room? How do these benefits make the message-passing so instant?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于事件的WebSockets方法实现多用户聊天室的好处是什么？这些好处如何使消息传递如此即时？
- en: Making a shared drawing whiteboard with Canvas and WebSockets
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas和WebSockets制作共享绘图白板
- en: Suppose we want a shared sketchpad. Anyone can draw something on the sketchpad
    and all others can view it, just like the sketchpad example we played at the beginning
    of this chapter. We learned how messages are communicated between clients and
    servers. We will go further and send drawing data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个共享的素描本。任何人都可以在素描本上画东西，所有其他人都可以查看，就像我们在本章开头玩的素描本示例一样。我们学习了如何在客户端和服务器之间传递消息。我们将进一步发送绘图数据。
- en: Building a local drawing sketchpad
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建本地绘图素描本
- en: Before we deal with the data sending and the server handling, let's focus on
    making a drawing whiteboard. We will use the canvas to build a local drawing sketchpad.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据发送和服务器处理之前，让我们专注于制作一个绘图白板。我们将使用画布来构建一个本地绘图素描本。
- en: Time for action Making a local drawing whiteboard with the Canvas
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：使用Canvas制作本地绘图白板
- en: 'Carry out the following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We will focus only on the client side in this section. Open the `index.htm`
    file and add the following `canvas` markup:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们只关注客户端。打开`index.htm`文件并添加以下`canvas`标记：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will draw something on the canvas and we will need the mouse position relative
    to the canvas. We did this in *Chapter 4, Building* an *Untangle Game with Canvas
    and Drawing API*. Add the following style to the canvas:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在画布上画一些东西，我们将需要相对于画布的鼠标位置。我们在*第4章，使用Canvas和Drawing API构建Untangle游戏*中做到了这一点。将以下样式添加到画布：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then, we open the `html5games.websocket.js` JavaScript file to add the drawing
    logic.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开`html5games.websocket.js` JavaScript文件来添加绘图逻辑。
- en: 'Replace the `websocketGame` global object with the following variable at the
    top of the JavaScript file:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript文件的顶部用以下变量替换`websocketGame`全局对象：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the jQuery `ready` function, we add the following mouse event handler code.
    The code handles the mouse down, move, and up events:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery的`ready`函数中，我们添加以下鼠标事件处理程序代码。该代码处理鼠标按下、移动和松开事件：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At last, we have the following function to draw a line on the canvas with the
    given starting and ending point:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有以下函数来在画布上画一条线，给定起点和终点：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Save all files and open the `index.htm` file. We should see an empty space
    where we can draw something by using the mouse. The drawings are not sent to the
    server yet, so others cannot view our drawings:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并打开`index.htm`文件。我们应该看到一个空白的空间，我们可以使用鼠标绘制一些东西。绘图尚未发送到服务器，因此其他人无法查看我们的绘图：
- en: '![Time for action Making a local drawing whiteboard with the Canvas](img/1260_08_09.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间：使用Canvas制作本地绘图白板](img/1260_08_09.jpg)'
- en: What just happened?
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just created a local drawing pad. This is like a whiteboard where the player
    can draw on the canvas by dragging the mouse. However, the drawing data is not
    sent to the server yet; all drawings are only displayed locally.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个本地绘图板。这就像一个白板，玩家可以通过拖动鼠标在画布上绘图。但是，绘图数据尚未发送到服务器；所有绘图只在本地显示。
- en: The `drawing line` function is the same that we used in *Chapter 4*. We also
    used the same code to get the mouse position relative to the canvas element. However,
    the logic of the mouse events is different from *Chapter 4*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`画线`函数与我们在*第4章*中使用的相同。我们还使用相同的代码来获取鼠标相对于画布元素的位置。但是，鼠标事件的逻辑与*第4章*不同。'
- en: Drawing on the canvas
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在画布上绘制
- en: When we draw something on the computer, it often means that we click on the
    canvas and drag the mouse (or pen). The line is drawn until the mouse button is
    up. Then, the user clicks on another place and drags again to draw lines.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在计算机上画东西时，通常意味着我们点击画布并拖动鼠标（或笔）。直到鼠标按钮松开为止才画线。然后，用户再次点击另一个地方并拖动以绘制线条。
- en: In our example, we have a Boolean flag named `isDrawing` to indicate if the
    user is drawing. The `isDrawing` flag is false by default. When the mouse button
    is down, we turn the flag to true. When the mouse is moving, we draw a line between
    the moved point and the last point when the mouse button is down. Then, we set
    the `isDrawing` flag to false again when the mouse button is up.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们有一个名为`isDrawing`的布尔标志，用于指示用户是否正在绘图。`isDrawing`标志默认为false。当鼠标按钮按下时，我们将标志设置为true。当鼠标移动时，我们在鼠标按钮按下时的移动点和上一个点之间画一条线。然后，当鼠标按钮松开时，我们再次将`isDrawing`标志设置为false。
- en: This is how the drawing logic works.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是绘图逻辑的工作方式。
- en: Have a go hero Drawing with colors
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下：使用颜色绘图
- en: Can we modify the drawing sketchpad by adding color support? How about adding
    five buttons with red, blue, green, black, and white color? The player can choose
    the color when drawing.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否通过添加颜色支持来修改绘图画板？再加上五个按钮，分别是红色、蓝色、绿色、黑色和白色？玩家可以在绘图时选择颜色。
- en: Broadcasting the drawing to all connected browsers
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将绘图广播到所有连接的浏览器
- en: We will go further by sending our drawing data to the server and let the server
    broadcast the drawing to all connected browsers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步通过将我们的绘图数据发送到服务器，并让服务器将绘图广播到所有连接的浏览器。
- en: Time for action Sending the drawing through WebSockets
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过WebSockets发送绘图的时间
- en: 'Carry out the following steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, we need to modify the server logic. Open the `server.js` file and replace
    the following code. It uses a JSON-formatted string for broadcasting, so we can
    send and receive data object:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要修改服务器逻辑。打开`server.js`文件并替换以下代码。它使用JSON格式的字符串进行广播，因此我们可以发送和接收数据对象：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: On the client side, we need the logic to respond to the server with the same
    data object definition. Open the `html5games.websocket.js` JavaScript file in
    the **client** | **js** directory.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端，我们需要逻辑来对服务器做出相同的数据对象定义的响应。在**client** | **js**目录中打开`html5games.websocket.js`
    JavaScript文件。
- en: Add the following constants to the `websocketGame` global variable. The same
    constants with the same values are also defined in the server side logic.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下常量添加到`websocketGame`全局变量中。相同的常量与相同的值也在服务器端逻辑中定义。
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When handling the message event on the client-side, we convert the JSON formatted
    string back to the data object. If the data is a chat message, then we display
    it as chat history, otherwise we draw it on the canvas as a line segment. Replace
    the `onmessage` event handler with the following code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端处理消息事件时，我们将JSON格式的字符串转换回数据对象。如果数据是聊天消息，那么我们将其显示为聊天历史记录，否则我们将其绘制在画布上作为线段。用以下代码替换`onmessage`事件处理程序：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the mouse is moving, we not only draw the line on the canvas but also
    send the line data to the server. Add the following highlighted code to the mouse
    move event handler:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当鼠标移动时，我们不仅在画布上绘制线条，还将线条数据发送到服务器。将以下突出显示的代码添加到鼠标移动事件处理程序中：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, we need to modify the send message logic. We now pack the message in
    an object and format it as JSON when sending it to the server. Change the `sendMessage`
    function to the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要修改发送消息的逻辑。现在，当将消息发送到服务器时，我们将消息打包成一个对象并格式化为JSON。将`sendMessage`函数更改为以下代码：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save all files and re-launch the server.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并重新启动服务器。
- en: Open the `index.htm` file in two browser instances.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个浏览器实例中打开`index.htm`文件。
- en: 'First, try the chat room feature by typing some messages and sending them.
    Then, try drawing something on the canvas. Both browsers should display the same
    drawing as shown in the following screenshot:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过输入一些消息并发送它们来尝试聊天室功能。然后，在画布上画一些东西。两个浏览器应该显示与以下截图中相同的绘图：
- en: '![Time for action Sending the drawing through WebSockets](img/1260_08_10.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![通过WebSockets发送绘图的时间](img/1260_08_10.jpg)'
- en: What just happened?
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have just built a multiuser sketchpad. This is similar to the sketchpad we
    tried at the beginning of this chapter. We extended what we learned when building
    a chat room by sending a complex data object as a message.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个多用户绘图画板。这类似于我们在本章开头尝试的绘图画板。我们通过发送一个复杂的数据对象作为消息，扩展了构建聊天室时所学到的内容。
- en: Defining a data object to communicate between the client and the server
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个数据对象来在客户端和服务器之间通信
- en: In order to communicate correctly between the server and clients with several
    data packed into one message, we have to define a data object that both client
    and server understand.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地在服务器和客户端之间传递多个数据，我们必须定义一个数据对象，服务器和客户端都能理解。
- en: 'There are several properties in the data object. The following table lists
    the properties with why we need them:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对象中有几个属性。以下表格列出了这些属性以及我们为什么需要它们：
- en: '| Property name | Why we need this property |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 属性名称 | 我们为什么需要这个属性 |'
- en: '| --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dataType` | This is an important property that helps us to understand about
    the entire data. The data is either a chat message or a drawing line segment data.
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `dataType` | 这是一个重要的属性，帮助我们了解整个数据。数据要么是聊天消息，要么是绘图线段数据。 |'
- en: '| `sender` | If the data is a chat message, the client needs to know who sent
    the message. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `sender` | 如果数据是聊天消息，客户端需要知道谁发送了消息。 |'
- en: '| `message` | When the data type is a chat message, we surely need to include
    the message content itself into the data object. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `message` | 当数据类型是聊天消息时，我们肯定需要将消息内容本身包含到数据对象中。 |'
- en: '| `startX` | When the data type is a drawing line segment, we include the x/y
    coordinate of the starting point of the line. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `startX` | 当数据类型是绘图线段时，我们包含线的起点的x/y坐标。 |'
- en: '| `startY` |   |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `startY` |   |'
- en: '| `endX` | When the data type is a drawing line segment, we include the x/y
    coordinate of the ending point of the line. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `endX` | 当数据类型是绘图线段时，我们包含线的终点的x/y坐标。 |'
- en: '| `endY` |   |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `endY` |   |'
- en: 'In addition, we have the following constants defined on both the client side
    and the server side. These constants are for the `dataType` property:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在客户端和服务器端都定义了以下常量。这些常量是用于`dataType`属性的：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With these constants, we can compare the `dataType` by the following readable
    code instead of using the meaningless integer:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些常量，我们可以通过以下可读的代码来比较`dataType`，而不是使用无意义的整数：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Packing the drawing lines data into JSON for broadcasting
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将绘图线数据打包成JSON进行广播
- en: We used the `JSON.stringify` function in the last chapter when storing a JavaScript
    object into a JSON-formatted string in the local storage. Now, we need to send
    the data in a string format between the server and the client. We used the same
    method to pack the drawing lines data into an object and send it as a JSON string.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当将JavaScript对象存储到本地存储中时，我们使用了`JSON.stringify`函数将其转换为JSON格式的字符串。现在，我们需要在服务器和客户端之间以字符串格式发送数据。我们使用了相同的方法将绘画线条数据打包成对象，并将其作为JSON字符串发送。
- en: 'The following code snippet shows how we pack the line segment data on the client
    side and send it to the server with a JSON-formatted string:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们如何在客户端打包线段数据并以JSON格式的字符串发送到服务器：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Recreating the drawing lines after receiving them from other clients
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在从其他客户端接收到绘画线条后重新创建它们
- en: 'The JSON parsing often comes as a pair of `stringify`. When we receive a message
    from the server, we have to parse it to the JavaScript object. The following code
    on the client side parses the data and either updates the chat history or draws
    a line based on the data:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: JSON解析通常成对出现，与`stringify`一起使用。当我们从服务器接收到消息时，我们必须将其解析为JavaScript对象。以下是客户端上的代码，它解析数据并根据数据更新聊天历史或绘制线条：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Building a multiplayer draw-and-guess game
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建多人绘画和猜词游戏
- en: We built an instant chat room earlier in this chapter. Moreover, we just built
    a multiuser sketchpad. How about combining these two techniques and building a
    draw-and-guess game? A draw-and-guess game is a game in which one player is given
    a word to draw. All other players do not know the word and guess the word according
    to the drawing. The one who draws and who correctly guesses the word earn points.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们构建了一个即时聊天室。此外，我们刚刚构建了一个多用户草图本。那么，如何将这两种技术结合起来构建一个绘画和猜词游戏呢？绘画和猜词游戏是一种游戏，其中一个玩家被给予一个词来绘制。所有其他玩家不知道这个词，并根据绘画猜测这个词。绘画者和正确猜测词语的玩家将获得积分。
- en: Time for action Building the draw-and-guess game
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动构建绘画和猜词游戏
- en: 'We will implement the game flow of the draw-and-guess game as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式实现绘画和猜词游戏的游戏流程：
- en: First, we will add the game logic on the client side.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在客户端添加游戏逻辑。
- en: 'Open the `index.htm` file in the client directory. Add the following restart
    button right after the *send* button:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端目录中打开`index.htm`文件。在*发送*按钮之后添加以下重新启动按钮：
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Open the `html5games.websocket.js` JavaScript.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.websocket.js` JavaScript文件。
- en: 'We need a few more constants to determine different states during the game
    play. Add the following highlighted code to the top of the file:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一些额外的常量来确定游戏进行过程中的不同状态。将以下突出显示的代码添加到文件顶部：
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition, we want a flag to indicate this player to in charge of drawing.
    Add the following Boolean global variable to the code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们需要一个标志来指示此玩家负责绘制。将以下布尔全局变量添加到代码中：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When the client receives a message from the server, it parses it and checks
    whether it is a chat message of line drawing. We have another type of message
    now for handling the game logic named `GAME_LOGIC`. The game logic message contains
    different data for different game states. Add the following code to the `onmessage`
    event handler:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端从服务器接收到消息时，它会解析并检查是否是一条线条绘制的聊天消息。现在我们有另一种处理游戏逻辑的消息类型，名为`GAME_LOGIC`。游戏逻辑消息包含不同的数据，用于不同的游戏状态。将以下代码添加到`onmessage`事件处理程序中：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We have added the game logic to the client side. There is some minor code on
    the client side containing the restart logic and preventing the non-drawing player
    to draw on the canvas. These codes can be found in the code bundle.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经在客户端添加了游戏逻辑。客户端上有一些包含重新启动逻辑和防止非绘图玩家在画布上绘制的小代码。这些代码可以在代码包中找到。
- en: It is time to move on to the server side.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候转向服务器端了。
- en: 'In the previous example, the server side is just in charge of broadcasting
    any incoming message to all connected browsers. This is not enough for a multiplayer
    game. The server will act as the game master that controls the game flow and winning
    determination. Therefore, delete the existing code in `server.js` and use the
    following code. The changes are highlighted:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前的示例中，服务器端只负责将任何传入的消息广播给所有连接的浏览器。这对于多人游戏来说是不够的。服务器将充当控制游戏流程和确定胜利的游戏主持人。因此，请删除`server.js`中的现有代码，并使用以下代码。更改部分已经突出显示：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We will save all files and re-launch the server. Then, launch the `index.htm`
    file in two browser instances. One browser gets a message from the server informing
    the player to draw something. The other browser, on the other hand, informs the
    player to guess what the other is drawing within one minute.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保存所有文件并重新启动服务器。然后，在两个浏览器实例中启动`index.htm`文件。一个浏览器收到来自服务器的消息，通知玩家绘制某物。另一个浏览器则通知玩家在一分钟内猜测其他人正在绘制什么。
- en: The player who is told to draw something can draw on the canvas. The drawings
    are broadcasted to other connected players. The players who are told to guess
    cannot draw anything on the canvas. Instead, players type what they guess in the
    text field and send to the server. If the guessing is correct, then the game ends.
    Otherwise, the game continues until the one-minute countdown finishes.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被告知绘制某物的玩家可以在画布上绘制。绘画将广播给其他连接的玩家。被告知猜测的玩家不能在画布上绘制任何东西。相反，玩家在文本字段中输入他们的猜测并发送到服务器。如果猜测正确，则游戏结束。否则，游戏将持续直到一分钟倒计时结束。
- en: '![Time for action Building the draw-and-guess game](img/1260_08_11.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![采取行动构建绘画和猜词游戏](img/1260_08_11.jpg)'
- en: What just happened?
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just created a multiplayer draw-and-guess game in WebSockets and Canvas.
    The main difference between the game and the multiuser sketchpad is that the server
    now controls the game flow instead of letting all users draw.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在WebSockets和Canvas中创建了一个多人绘画和猜词游戏。游戏和多用户草图本之间的主要区别在于，服务器现在控制游戏流程，而不是让所有用户绘制。
- en: Controlling the game flow of a multiplayer game
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制多人游戏的游戏流程
- en: Controlling the game flow of a multiplayer game is much more difficult than
    a single game. We can simply use a few variables to control the game flow of a
    single game, but we have to use message passing to inform each player of specific
    updated game flow.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 控制多人游戏的游戏流程比单人游戏要困难得多。我们可以简单地使用几个变量来控制单人游戏的游戏流程，但是我们必须使用消息传递来通知每个玩家特定的更新游戏流程。
- en: 'First, we require the following highlighted constant `GAME_LOGIC` for `dataType`.
    We use this `dataType` to send and receive a message which is related to the game
    logic control:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要以下突出显示的常量`GAME_LOGIC`用于`dataType`。我们使用这个`dataType`来发送和接收与游戏逻辑控制相关的消息：
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There are several states in the game flow. Before the game starts, the connected
    players are waiting for the game to start. Once there are enough connections for
    the multiplayer game, the server sends a game logic message to all players to
    inform them to start the game.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏流程中有几种状态。在游戏开始之前，连接的玩家正在等待游戏开始。一旦有足够的连接进行多人游戏，服务器向所有玩家发送游戏逻辑消息，通知他们开始游戏。
- en: When the game is over, the server sends a game over state to all players. Then,
    the game finishes and the game logic halts until any player clicks on the restart
    button. Once the restart button is clicked, the client sends a game restart state
    to the server instructing the server to prepare a new game. Then, the game starts
    again.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，服务器向所有玩家发送游戏结束状态。然后，游戏结束，游戏逻辑暂停，直到有玩家点击重新开始按钮。一旦重新开始按钮被点击，客户端向服务器发送游戏重新开始状态，指示服务器准备新游戏。然后，游戏重新开始。
- en: 'We declare the four game states as the following constants in both client and
    server, so they understand them:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在客户端和服务器中将四个游戏状态声明为以下常量，以便它们理解：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following code on the server side holds an index to indicate which player
    is in turn now:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的以下代码保存了一个指示哪个玩家轮到的索引：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The data which is sent to the player (whose turn it is) is different from the
    data that is sent to other players. The other players receive the following data
    with only a game start signal:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到玩家（轮到他的回合）的数据与发送到其他玩家的数据不同。其他玩家只收到一个游戏开始信号的数据：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On the other hand, the player (who is in turn to draw) receives the following
    data with the word information:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，玩家（轮到他画画）收到以下包含单词信息的数据：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Enumerating connected clients on the serverside
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端枚举连接的客户端
- en: 'We can enumerate all connected clients by using the `forEach` method in the
    `server manager` class. The following code shows the usage. It loops through each
    connection and calls the given `callback` function as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`server manager`类中的`forEach`方法枚举所有连接的客户端。以下代码显示了用法。它循环遍历每个连接，并调用给定的`callback`函数，如下所示：
- en: '[PRE48]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For example, the following code snippet prints all connections ID on the server
    terminal:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段在服务器终端上打印所有连接的ID：
- en: '[PRE49]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Sending a message to a specific connection on the server side
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端向特定连接发送消息
- en: 'We used broadcast in our previous examples to send a message to all connected
    clients. Besides sending the message to everyone, we can send it to a specific
    connection by using the `send` method as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们使用广播向所有连接的客户端发送消息。除了向每个人发送消息，我们可以使用`send`方法将消息发送到特定的连接，如下所示：
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `send` method requires two arguments. The `connectionID` is the unique ID
    of the target connection and `message` is the string that we want to send.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`方法需要两个参数。`connectionID`是目标连接的唯一ID，`message`是我们要发送的字符串。'
- en: 'In the following code extracted from our draw-and-guess game, we send special
    data to the player''s browser who now has to draw something. We use the `forEach`
    function to loop through the connections and check whether the connection is in
    turn to draw. Then, we pack the answer and send this data to this target connection
    as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从画画和猜图游戏中提取的以下代码中，我们向现在必须画画的玩家的浏览器发送特殊数据。我们使用`forEach`函数循环遍历连接，并检查连接是否轮到画画。然后，我们打包答案并将这些数据发送给目标连接，如下所示：
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Improving the game
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进游戏
- en: We just created a multiplayer game which is playable. However, there is still
    lots to improve. In the following sections, we list two possible improvements
    in the game.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个可玩的多人游戏。但是，还有很多需要改进的地方。在接下来的几节中，我们列出了游戏中的两个可能的改进。
- en: Storing drawn lines on each game
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在每个游戏中存储绘制的线条
- en: In the game, the drawer draws lines and other players guess the drawing. Now,
    imagine that two players are playing and the third player joins. As there is no
    storage for the drawn lines anywhere, the third player cannot see what the drawer
    has drawn. This means that the third player has to wait until the game ends to
    play.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，画画者画线，其他玩家猜图。现在，想象两个玩家在玩，第三个玩家加入。由于没有任何地方存储绘制的线条，第三个玩家无法看到画画者画了什么。这意味着第三个玩家必须等到游戏结束才能玩。
- en: Have a go hero
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: How can we let a player who has joined late continue the game without losing
    those drawn lines? How can we reconstruct the drawing for a newly connected player?
    How about storing all drawing data of the current game on the server?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让晚加入的玩家继续游戏而不丢失那些绘制的线条？我们如何为新连接的玩家重建绘图？在服务器上存储当前游戏的所有绘图数据怎么样？
- en: Improving the answer checking mechanism
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进答案检查机制
- en: The answer checking on the server side compares the message with the `currentAnswer`
    variable to determine whether a player guessed correctly. The answer is treated
    as incorrect if the case does not match. It looks strange when the answer is "apples"
    and the player is told wrong when guessing "apple".
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的答案检查与`currentAnswer`变量比较消息，以确定玩家是否猜对。如果情况不匹配，答案将被视为不正确。当答案是“apples”时，玩家猜“apple”时被告知错误，这看起来很奇怪。
- en: Have a go hero
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: How can we improve the answer checking mechanism? How about improving the answer
    checking logic to treat the answer as correct when using a different case or even
    similar words?
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进答案检查机制？如果使用不同的大小写或者相似的单词来改进答案检查逻辑，会怎么样？
- en: Decorating the draw-and-guess game with CSS
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用CSS装饰猜画游戏
- en: The game logic is basically finished and the game is playable already. However,
    we forgot to decorate the game to make it look appealing. We will use CSS styles
    to decorate our draw-and-guess game.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏逻辑基本上已经完成，游戏已经可以玩了。但是，我们忘记了装饰游戏以使其看起来更吸引人。我们将使用CSS样式来装饰我们的猜画游戏。
- en: Time for action Decorating the game
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰游戏的时间
- en: 'Carry out the following steps:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: The decoration only applies to the client side. Open the `index.htm` file.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰只适用于客户端。打开`index.htm`文件。
- en: 'Add the following CSS style link in the head:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头部添加以下CSS样式链接：
- en: '[PRE52]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We put all markups in the `body` inside `section` with `id=game`. Also, we
    add an `h1` title for the game as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有标记放在`body`中的`id=game`的`section`内。此外，我们添加了一个游戏的`h1`标题，如下所示：
- en: '[PRE53]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Add a wording **Chat or Guess:** in front of the text field input, so the player
    knows where to type their guessing words.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本字段输入前添加一个**聊天或猜测：**，这样玩家就知道在哪里输入他们的猜测词。
- en: Next, create a directory named `css` inside the `client` folder.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`client`文件夹内创建一个名为`css`的目录。
- en: Create a new file named `drawguess.css` and save it in the `css` directory.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`drawguess.css`的新文件，并将其保存在`css`目录中。
- en: 'Put the following styles in the CSS file:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下样式放入CSS文件中：
- en: '[PRE54]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Save all files and open the `index.htm` file again in two browsers to play
    the game. As we only changed the decoration code, the game should look better
    now as shown in the following screenshot:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，并在两个浏览器中再次打开`index.htm`文件以开始游戏。由于我们只改变了装饰代码，游戏现在应该看起来更好，如下面的截图所示：
- en: '![Time for action Decorating the game](img/1260_08_12.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action Decorating the game](img/1260_08_12.jpg)'
- en: What just happened?
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just applied styles to our game and embedded a font from the **Google Font
    Directory** that looks like sketching text. The canvas is now styled to look more
    like a canvas with a thick border and subtle shadow.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为我们的游戏应用了样式，并嵌入了一个来自**Google Font Directory**的字体，看起来像是涂鸦文本。画布现在被设计成更像是一个带有粗边框和微妙阴影的画布。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We learned a lot in this chapter about connecting browsers to WebSockets. The
    messages and events from one browser are broadcasted to another browser in almost
    real time.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学到了很多关于将浏览器连接到WebSockets的知识。一个浏览器的消息和事件会几乎实时地广播到另一个浏览器。
- en: 'Specifically, we:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们：
- en: Learned how WebSockets provide real-time events by drawing on an existing multiplayer
    sketchpad. It shows drawings from other users who are connected.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会了WebSockets如何通过在现有的多人涂鸦板上绘制来提供实时事件。它显示了其他连接用户的绘画。
- en: Installed a `Node.js` server with the WebSocket library. By using this server,
    we can easily build an event-based server to handle WebSocket requests from browsers.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了一个带有WebSocket库的`Node.js`服务器。通过使用这个服务器，我们可以轻松地构建一个基于事件的服务器来处理来自浏览器的WebSocket请求。
- en: Discussed the relationship between the server and a client.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了服务器和客户端之间的关系。
- en: Built an instant chat room application. We learned how to implement a server
    script to broadcast incoming messages to other connected browsers. We also learned
    how to display a received message from the server on the client side.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建了一个即时聊天室应用程序。我们学会了如何实现一个服务器脚本来将传入的消息广播到其他连接的浏览器。我们还学会了如何在客户端上显示从服务器接收到的消息。
- en: Built a multiuser drawing board. We learned how to pack data in the JSON format
    to pass a message between the server and browsers.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建了一个多用户绘图板。我们学会了如何将数据打包成JSON格式，以在服务器和浏览器之间传递消息。
- en: Built a draw-and-guess game by integrating the chatting and drawing pad. We
    also learned how to create the game logic in a multiplayer game.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过整合聊天和绘图板来构建一个猜画游戏。我们还学会了如何在多人游戏中创建游戏逻辑。
- en: Now that we have learned to build a multiplayer game, we are ready to build
    physics games with the help of the physics engine in the next chapter.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何构建一个多人游戏，我们准备在下一章中借助物理引擎来构建物理游戏。
