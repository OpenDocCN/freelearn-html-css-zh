- en: Chapter 9. Building a Physics Car Game with Box2D and Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用Box2D和Canvas构建物理汽车游戏
- en: 2D Physics Engine is a hot topic in game development. With the help of a physics
    engine, we can easily create a playable game by just defining an environment and
    a simple rule. Taking existing games as examples, players in the Angry Birds game
    fly birds to destruct the enemy's castle. In Cut the Rope, candy drops into the
    monster's mouth to progress to the next level.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2D物理引擎是游戏开发中的热门话题。借助物理引擎，我们可以通过定义环境和简单规则轻松创建可玩的游戏。以现有游戏为例，愤怒的小鸟游戏中的玩家将小鸟飞向敌人的城堡以摧毁它。在《切断绳子》中，糖果掉进怪物的嘴里以进入下一关。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Installing the Box2D JavaScript library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Box2D JavaScript库
- en: Creating a static ground body in the physics world
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理世界中创建一个静态地面实体
- en: Drawing the physics world on the Canvas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Canvas上绘制物理世界
- en: Creating a dynamic box in the physics world
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理世界中创建一个动态方块
- en: Advancing the world time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推进世界时间
- en: Adding wheels to the game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏添加车轮
- en: Creating the physics car
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建物理汽车
- en: Adding force to the car with a keyboard input
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键盘输入向汽车施加力
- en: Checking a collision in the Box2D world
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Box2D世界中检查碰撞
- en: Restarting the game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动游戏
- en: Adding a level support to our car game
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的汽车游戏添加关卡支持
- en: Replacing the Box2D outline drawing with graphics
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用图形替换Box2D轮廓绘制
- en: Adding a final touch to make the game fun to play
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加最后一点以使游戏有趣
- en: 'The following screenshot shows what we will get by the end of this chapter.
    It is a car game in which a player moves the car towards the destination point:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了本章结束时我们将获得的内容。这是一个汽车游戏，玩家将汽车移向目的地点：
- en: '![Building a Physics Car Game with Box2D and Canvas](img/1260_09_16.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![使用Box2D和Canvas构建物理汽车游戏](img/1260_09_16.jpg)'
- en: So, let's get on with it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧。
- en: Installing the Box2D JavaScript library
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Box2D JavaScript库
- en: Now, suppose that we want to create a car game. We apply force to the car to
    make it move forward. The car moves on a ramp and then flies through the air.
    Afterwards, the car falls on the destination ramp and the game finishes. Every
    collision in every part of the physics world counts on this movement. If we have
    to make this game from scratch, then we have to calculate at least the velocity
    and angle of each part. Luckily, the physics library helps us to handle all these
    physical problems. All we have to do is to create the physics model and present
    it in the canvas.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想创建一个汽车游戏。我们对汽车施加力使其向前移动。汽车在坡道上移动，然后飞过空中。之后，汽车落在目的地坡道上，游戏结束。物理世界的每个部分的每次碰撞都会影响这一运动。如果我们必须从头开始制作这个游戏，那么我们至少要计算每个部分的速度和角度。幸运的是，物理库帮助我们处理所有这些物理问题。我们所要做的就是创建物理模型并在画布中呈现它。
- en: Time for action Installing the Box2D physics library
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 安装Box2D物理库
- en: 'Carry out the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: We will get the Box2D JavaScript library. The original Box2D JavaScript library
    is based on the prototype JavaScript library. The prototype library provides similar
    functions from jQuery but with a little different API. Thanks to KJ ([http://kjam.org/post/105](http://kjam.org/post/105))
    who ported it into the jQuery capable version, we can use the jQuery library on
    which we have based our whole book. The Box2D library with the starting code can
    be found from the code bundle named `box2d_game`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将获得Box2D JavaScript库。原始的Box2D JavaScript库基于原型JavaScript库。原型库提供了类似于jQuery的函数，但API略有不同。由于KJ（[http://kjam.org/post/105](http://kjam.org/post/105)）将其移植为适用于jQuery的版本，我们可以使用jQuery库，而我们的整本书都是基于它的。Box2D库与起始代码可以在名为`box2d_game`的代码包中找到。
- en: Now, we should have the following setup:![Time for action Installing the Box2D
    physics library](img/1260_09_17.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该有以下设置：![行动时间 安装Box2D物理库](img/1260_09_17.jpg)
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We have already imported the essential JavaScript files. It is worth remembering
    that if you want to later use this base to create another physics game, Box2D
    JS recommends copying the JavaScript import codes in exactly the same order because
    there are dependencies between files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了必要的JavaScript文件。值得记住的是，如果您以后想使用此基础创建另一个物理游戏，Box2D JS建议按照完全相同的顺序复制JavaScript导入代码，因为文件之间存在依赖关系。
- en: 'Now, we will create an empty world to test our Box2D library installation.
    Open the `html5games.box2dcargame.js` JavaScript file and put the following code
    in the file to create the world:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个空世界来测试我们的Box2D库安装。打开`html5games.box2dcargame.js` JavaScript文件，并将以下代码放入文件中以创建世界：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the `index.html` file in a web browser. We should see a grey canvas with
    nothing there.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络浏览器中打开`index.html`文件。我们应该看到一个灰色的画布，什么也没有。
- en: 'We have not presented the physics world in the canvas yet. That is why we only
    see a blank canvas on the page. However, we have printed the newly created world
    in the console log. The following screenshot shows the console tracing the world
    object with many properties beginning with `m_`. These are the physical states
    of the world:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有在画布中呈现物理世界。这就是为什么我们在页面上只看到一个空白画布。但是，我们已经在控制台日志中打印了新创建的世界。以下屏幕截图显示了控制台跟踪带有许多以`m_`开头的属性的世界对象。这些是世界的物理状态：
- en: '![Time for action Installing the Box2D physics library](img/1260_09_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 安装Box2D物理库](img/1260_09_04.jpg)'
- en: What just happened?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We have just installed the Box2D JavaScript library and created an empty world
    to test the installation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚安装了Box2D JavaScript库，并创建了一个空世界来测试安装。
- en: Using b2World to create a new world
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用b2World创建新世界
- en: 'The `b2World` is a core class in the Box2D environment. All our physics bodies,
    including the ground and car, are created in this world. The following code shows
    how to create a world:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`b2World`是Box2D环境中的核心类。我们所有的物理实体，包括地面和汽车，都是在这个世界中创建的。以下代码显示了如何创建一个世界：'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `b2World` class takes three arguments to initialize, which are listed in
    the following table with their description:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`b2World`类需要三个参数来初始化，这些参数在下表中列出并附有描述：'
- en: '| Arguments | Type | Discussion |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `worldAABB` | b2AABB | Represents the bounding area of the world |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `worldAABB` | b2AABB | 代表世界的边界区域 |'
- en: '| `gravity` | b2Vec2 | Represents the gravity of the world |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `gravity` | b2Vec2 | 代表世界的重力 |'
- en: '| `doSleep` | Bool | Defines whether the world ignores slept objects or not
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `doSleep` | Bool | 定义世界是否忽略休眠的物体 |'
- en: Using b2AABB to define a bounding area
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用b2AABB定义边界区域
- en: In the physics world, we need a lot of bounding area. The first bounding we
    need is for the world. All things within the world bounding will be calculated
    and things outside the bounding area will be destroyed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理世界中，我们需要很多边界区域。我们需要的第一个边界是世界边界。世界边界内的所有物体都将被计算，而边界外的物体将被销毁。
- en: 'We can treat `b2AABB` as a rectangle with the lowest bounding point and highest
    bounding point. The following code snippet shows how to use the `b2AABB` class.
    The `minVertex` is the top left-most point of the bound while `maxVertex` is the
    bottom right-most point. The following world defines a world with 8000x8000:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`b2AABB`视为具有最低边界点和最高边界点的矩形。以下代码片段显示了如何使用`b2AABB`类。`minVertex`是边界的左上角点，而`maxVertex`是右下角点。以下世界定义了一个8000x8000的世界：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The unit in the Box2D mathematics model is different from what we commonly use
    in the computer world. The length unit is in meters instead of pixels. Moreover,
    the rotation unit is in radians.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D数学模型中的单位与我们在计算机世界中通常使用的不同。长度单位是米，而不是像素。此外，旋转单位是弧度。
- en: Setting the gravity of the world
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置世界的重力
- en: 'We have to define the gravity of the world. The gravity is defined by `b2Vec2`.
    The `b2Vec2` is a vector with a 1x2 matrix. We can treat it as a vector of X and
    Y-axis. Therefore, the following code defines the gravity with 300 units downwards:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义世界的重力。重力由`b2Vec2`定义。`b2Vec2`是一个1x2矩阵的向量。我们可以将其视为X和Y轴的向量。因此，以下代码定义了向下300个单位的重力：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Setting the Box2D to ignore the slept object
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Box2D忽略休眠的物体
- en: A slept body is a dynamic body that does not move or change states anymore.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 休眠的物体是一个不再移动或改变状态的动态物体。
- en: The physics library calculates the mathematical data and collision of all bodies
    in the world. The performance will slow down when there are more bodies in the
    world to get calculated in every frame. When creating the physics world, we need
    to set the library to either ignore slept bodies or calculate all of them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 物理库计算世界中所有物体的数学数据和碰撞。当世界中有更多物体需要在每一帧中计算时，性能会变慢。在创建物理世界时，我们需要设置库来忽略休眠的物体或计算所有物体。
- en: In our game, there are only a few bodies, so the performance is not yet a problem.
    Moreover, if later our created bodies get into an idle or sleep state, we cannot
    interact with them anymore. Therefore, we set this flag to false in this example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，只有很少的物体，所以性能还不是问题。此外，如果以后我们创建的物体进入空闲或休眠状态，我们将无法再与它们交互。因此，在本例中，我们将此标志设置为false。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At the time of writing this book, only Google Chrome runs the Box2D JavaScript
    library in canvas smoothly. Therefore, it is suggested to test the game in Google
    Chrome until other web browsers can run it smoothly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，只有Google Chrome可以在画布中流畅运行Box2D JavaScript库。因此，建议在Google Chrome中测试游戏，直到其他网络浏览器可以流畅运行为止。
- en: Creating a static ground body in the physics world
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在物理世界中创建一个静态地面物体
- en: The world is empty now. If we are going to place objects there, those objects
    will fall and finally leave our sight. Now suppose that we want to create a static
    ground body in the world, so that objects can stand there. We can do this in Box2D.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在世界是空的。如果我们要放置物体，那些物体将会掉下来，最终离开我们的视线。现在假设我们想在世界中创建一个静态地面物体，以便物体可以站在那里。我们可以在Box2D中做到这一点。
- en: Time for action Creating a ground in the world
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行在世界中创建地面的操作
- en: 'Carry out the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `html5games.box2dcargame.js` JavaScript file.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.box2dcargame.js` JavaScript文件。
- en: 'Add the following function to the end of the JavaScript file. It creates a
    fixed body as the playground:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到JavaScript文件的末尾。它创建一个固定的物体作为游乐场：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Call the `createGround` function after creating the world as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建世界后调用`createGround`函数如下：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we are still defining the logic and have not yet presented the physics world
    visually, we will see nothing if we open the browser. However, it is a good habit
    to try it and inspect the console window for an error message if there is any.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们仍在定义逻辑，并且尚未以可视化的方式呈现物理世界，所以如果我们打开浏览器，我们将看不到任何东西。但是，如果有错误消息，尝试并检查控制台窗口是一个好习惯。
- en: What just happened?
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have created a ground body with the shape and body definitions. This is a
    common process we will use a lot to create different kinds of physical bodies
    in the world. So, let's get into details on how we made it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用形状和物体定义创建了一个地面物体。这是一个我们将经常使用的常见过程，用来在世界中创建不同类型的物体。因此，让我们详细了解一下我们是如何做到的。
- en: Creating a shape
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建形状
- en: 'A shape defines the geometrical data. In the JavaScript port of Box2D, a shape
    also defines material properties such as density, friction, and restitution. The
    shape can be a circle, rectangle, or a polygon. The following code that we used
    in the preceding example defines a box shape definition. In the box shape, we
    have to define the size of the box by setting the `extents` property. The `extents`
    property takes two arguments: half width and half height. It is a half value,
    so the final area of the shape is four times the value:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 形状定义了几何数据。在Box2D的JavaScript端口中，形状还定义了密度、摩擦和恢复等材料属性。形状可以是圆形、矩形或多边形。在前面的示例中使用的以下代码定义了一个框形状定义。在框形状中，我们必须通过设置`extents`属性来定义框的大小。`extents`属性接受两个参数：半宽和半高。这是一个半值，因此形状的最终面积是该值的四倍：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating a body
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个物体
- en: 'After defining the shape, we can then create a body definition with the given
    shape definition. Then, we set the initial position of the body and finally ask
    the world instance to create a body from our body definition. The following code
    shows how we create a body in the world with the given shape definition:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义形状之后，我们可以使用给定的形状定义创建一个物体定义。然后，我们设置物体的初始位置，最后要求世界实例根据我们的物体定义创建一个物体。下面的代码显示了我们如何在世界中创建一个物体，给定形状定义：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A body set without a mass is considered as a static body, or fixed body. These
    bodies are immovable and will not have collisions with other static bodies. Therefore,
    these bodies can be used as a ground or walls to become the level environment.
    On the other hand, a dynamic body will move following the gravity and collision
    with other bodies. We will create a dynamic box body later.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 没有质量的物体被视为静态物体，或固定物体。这些物体是不可移动的，不会与其他静态物体发生碰撞。因此，这些物体可以用作地面或墙壁，成为关卡环境。另一方面，动态物体将根据重力移动并与其他物体发生碰撞。我们稍后将创建一个动态箱子物体。
- en: Drawing the physics world in the canvas
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布中绘制物理世界
- en: We have created a ground but it is only in the mathematics model. We do not
    see anything in the canvas because we have not drawn anything on it yet. In order
    to show what the physics looks like, we have to draw something according to the
    physics world.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个地面，但它只存在于数学模型中。我们在画布上看不到任何东西，因为我们还没有在上面画任何东西。为了展示物理世界的样子，我们必须根据物理世界画一些东西。
- en: Time for action Drawing the physics world into the canvas
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间将物理世界绘制到画布中
- en: 'Carry out the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: First, open the `html5games.box2dcargame.js` JavaScript file.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`html5games.box2dcargame.js` JavaScript文件。
- en: 'Add a `drawWorld` function call to the page loaded event handler as the following
    code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面加载事件处理程序中添加`drawWorld`函数调用，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, open the `draw_world.js` JavaScript file from the Box2D JavaScript example
    code. There are two functions named `drawWorld` and `drawShapes`. Copy the entire
    file, which is shown in the following code, to the end of our JavaScript file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开Box2D JavaScript示例代码中的`draw_world.js` JavaScript文件。有两个名为`drawWorld`和`drawShapes`的函数。将下面的整个文件复制到我们的JavaScript文件的末尾：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now re-open the game in a browser and we should see the outline of the ground
    body in the canvas, as shown in the following screenshot:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新在浏览器中打开游戏，我们应该在画布中看到地面物体的轮廓，如下面的屏幕截图所示：
- en: '![Time for action Drawing the physics world into the canvas](img/1260_09_05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间将物理世界绘制到画布中](img/1260_09_05.jpg)'
- en: What just happened?
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just created a function to draw every shape in the world as a box with
    a dark green outline.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个函数，用于将世界中的每个形状绘制为带有深绿色轮廓的框。
- en: 'The following code shows how we loop through each shape in the world to draw
    it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们如何循环遍历世界中的每个形状进行绘制：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is the `drawJoint` function and related code from the Box2D JS library
    too. This joint drawing function is optional for our example. Adding the joint
    drawing function can let us see the invisible joint connected between two bodies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawJoint`函数和Box2D JS库中的相关代码也是如此。这个关节绘制函数对于我们的示例来说是可选的。添加关节绘制函数可以让我们看到连接两个物体之间的不可见关节。'
- en: Now we will take a look at the `drawShape` function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下`drawShape`函数。
- en: 'On every shape, we want to draw the outline of the object in the canvas to
    present it. We set the line style to dark green before drawing anything. Then,
    we check whether the shape is a circle, rectangle box, or a polygon. If it is
    a circle, then we use the pole coordinate to draw the circle with the given radius
    of the shape. If it is a polygon, then we draw each side of the polygon as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个形状上，我们想在画布中绘制对象的轮廓。在绘制任何东西之前，我们将线条样式设置为深绿色。然后，我们检查形状是圆形、矩形框还是多边形。如果是圆形，我们就使用极坐标来绘制给定形状的半径的圆。如果是多边形，我们就按照以下方式绘制多边形的每一条边：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating a dynamic box in the physics world
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在物理世界中创建一个动态框
- en: Imagine now we drop a box into the world. The box falls from the air and finally
    hits the ground. The box bounces up a little and finally stops on the ground.
    This is different from what we created in the last section. In the last section,
    we created a static ground which is immovable and will not be affected by gravity.
    Now we will create a dynamic box.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象我们把一个箱子放入世界中。箱子从空中掉下来，最后撞到地面。箱子会弹起一点，最后停在地面上。这与我们在上一节中创建的不同。在上一节中，我们创建了一个静态地面，它是不可移动的，不会受到重力的影响。现在我们将创建一个动态框。
- en: Time for action Putting a dynamic box in the world
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间将动态框放入世界中
- en: 'Carry out the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Open our JavaScript logic file and add the following box creation code to the
    page loaded event handler. Place the code after the `createGround` function:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们的JavaScript逻辑文件，并将以下框创建代码添加到页面加载事件处理程序中。将代码放在`createGround`函数之后：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we will test the physics world in a browser. We should see that a box is
    created at the given initial position. However, the box is not falling down; it
    is because we still have something to do to make it fall:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在浏览器中测试物理世界。我们应该看到一个箱子被创建在给定的初始位置。然而，箱子并没有掉下来；这是因为我们还有一些事情要做才能让它掉下来：
- en: '![Time for action Putting a dynamic box in the world](img/1260_09_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间将动态框放入世界中](img/1260_09_06.jpg)'
- en: What just happened?
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just created a dynamic body in the world. In contrast to the ground
    body that is immovable, this box is affected by the gravity and the velocity changes
    during a collision. When a body contains a shape with any mass or density, it
    is a dynamic body. Otherwise, it is static. Therefore, we define a density to
    our box. Box2D will make it dynamic and calculate the mass according to the density
    and the size of the body automatically.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在世界中创建了一个动态物体。与不可移动的地面物体相比，这个箱子受到重力的影响，并且在碰撞过程中速度会发生变化。当一个物体包含有质量或密度的形状时，它是一个动态物体。否则，它是静态的。因此，我们为我们的箱子定义了一个密度。Box2D会使它成为动态的，并根据密度和物体的大小自动计算质量。
- en: Setting the bouncing effect with the restitution property
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用恢复属性设置弹跳效果
- en: The restitution value is between 0 and 1\. In our case, the box is falling down
    on the ground. When the restitution value is 0 on both the ground and the box,
    the box does not bounce at all. When either the box or ground has restitution
    value 1, the collision is perfectly elastic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复值在0和1之间。在我们的情况下，箱子掉在地面上。当地面和箱子的恢复值都为0时，箱子根本不会弹跳。当箱子或地面中的一个恢复值为1时，碰撞是完全弹性的。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When two bodies collide, the restitution value of that collision is the maximum
    value between both restitution values of the bodies. Therefore, if a box with
    a restitution of 0.4 drops on the ground with restitution 0.6, this collision
    uses 0.6 to calculate the bouncing velocity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个物体发生碰撞时，碰撞的恢复值是两个物体的恢复值中的最大值。因此，如果一个恢复值为0.4的箱子掉在恢复值为0.6的地面上，这次碰撞会使用0.6来计算弹跳速度。
- en: Advancing the world time
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推进世界时间
- en: The box is dynamic but it does not fall down. Are we doing anything wrong here?
    The answer is no. We have setup the box correctly, but we forget to advance the
    time in the physics world.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 箱子是动态的，但它不会掉下来。我们做错了什么吗？答案是否定的。我们已经正确设置了箱子，但是忘记在物理世界中推进时间。
- en: In the Box2D physics world, all calculations are done in a systematic iteration.
    The world calculates the physical transformation of all things according to the
    current step. When we move the `step` to the next level, the world calculates
    again as the new state.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Box2D物理世界中，所有计算都是按照系统化的迭代进行的。世界根据当前步骤计算所有事物的物理变换。当我们将“步骤”移动到下一个级别时，世界会根据新状态再次进行计算。
- en: Time for action Setting up the world step loop
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行操作 设置世界步骤循环
- en: 'We will make the world time advance by carrying out the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤推进世界时间：
- en: 'In order to advance the world step, we have to call the `step` function in
    the world instance periodically. We used `setTimeout` to keep calling the `step`
    function. Put the following function in our JavaScript logic file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了推进世界步骤，我们必须定期调用世界实例中的`step`函数。我们使用`setTimeout`来不断调用`step`函数。将以下函数放入我们的JavaScript逻辑文件中：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will kick-start the world by calling the first `step` function in
    the document ready event handler. Add the following highlighted code to the loaded
    handler function:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在文档准备好的事件处理程序中调用第一个`step`函数来启动世界。将以下突出显示的代码添加到加载处理程序函数中：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will again simulate the world in a browser. The box is created at the initialized
    position and falls on the ground correctly. The following screenshot shows the
    sequence of a box dropping on the ground:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在浏览器中再次模拟世界。箱子被创建在初始化位置并正确地落在地面上。以下截图显示了箱子落在地面上的顺序：
- en: '![Time for action Setting up the world step loop](img/1260_09_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![进行操作 设置世界步骤循环](img/1260_09_07.jpg)'
- en: What just happened?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have advanced the time of the world. Now the physics library simulates the
    world every 10 milliseconds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经推进了世界的时间。现在物理库每10毫秒模拟一次世界。
- en: The `step` function is similar to our `gameloop` function in *Chapter 2, Getting
    Started with DOM-based Game Development*. It executes periodically to calculate
    the new state of the game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`step`函数类似于我们在*第2章，使用基于DOM的游戏开发入门*中的`gameloop`函数。它定期执行以计算游戏的新状态。'
- en: Adding wheels to the game
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为游戏添加车轮
- en: Now we have a box in the game. Imagine now we create two circular shaped bodies
    as the wheels. Then, we will have the basic component of a car, the body, and
    the wheels.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在游戏中有一个箱子。现在想象我们创建两个圆形的车轮。然后，我们将拥有汽车的基本组件，车身和车轮。
- en: Time for action Putting two circles in the world
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行操作 将两个圆放入世界中
- en: 'We will add two circles to the world by carrying out the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤向世界中添加两个圆：
- en: Open the `html5games.box2dcargame.js` JavaScript file to add the wheel bodies.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.box2dcargame.js` JavaScript文件以添加车轮物体。
- en: 'Add the following code after the box creation code. It calls the `createWheel`
    function which we will write to create a circular shaped body:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在箱子创建代码之后添加以下代码。它调用了我们将编写的`createWheel`函数来创建一个圆形的物体：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s work on the `createWheel` function. We design this function to create
    a circle shaped body in the given world at the given x and y coordinates in the
    world. Put the following function in our JavaScript logic file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来处理`createWheel`函数。我们设计这个函数在给定的世界中以给定的x和y坐标创建一个圆形的物体。将以下函数放入我们的JavaScript逻辑文件中：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will now reload the physics world in a web browser. This time, we should
    see the result similar to the one shown in the following screenshot with a box
    and two wheels falling down from the air. These bodies collide with others and
    bounce away when they hit the wall:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在Web浏览器中重新加载物理世界。这次，我们应该看到类似以下截图的结果，其中有一个箱子和两个车轮从空中掉下来。这些物体与其他物体碰撞并在撞到墙壁时弹开：
- en: '![Time for action Putting two circles in the world](img/1260_09_08.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![进行操作 将两个圆放入世界中](img/1260_09_08.jpg)'
- en: What just happened?
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: When simulating the physics world, both the box and wheels drop and collide
    with each other and the ground.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟物理世界时，箱子和车轮都会掉下来并相互碰撞以及与地面碰撞。
- en: Creating a circular body is similar to creating a box body. The only difference
    is that we use a `CircleDef` class instead of the box shape definition. In the
    circle definition, we define the circle size by using the `radius` property instead
    of the `extents` property.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建圆形物体类似于创建方形物体。唯一的区别是我们使用`CircleDef`类而不是方形形状定义。在圆形定义中，我们使用`radius`属性而不是`extents`属性来定义圆的大小。
- en: Creating a physical car
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个物理汽车
- en: We have prepared the car box body and two wheel bodies. We are just one step
    away from making a car. Imagine now we have a glue to glue the wheels to the car
    body. Then, the car and wheels will not separate anymore and we will have a car.
    We can use **joint** to achieve that. In this section, we will use `joint` to
    stick the wheels and the car body together.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了汽车箱体和两个轮子箱体。我们离制作汽车只差一步。现在想象我们有一种胶水可以把车轮粘在车身上。然后，汽车和轮子就不会再分开，我们就会有一辆车。我们可以使用**关节**来实现这一点。在本节中，我们将使用`joint`将车轮和车身粘在一起。
- en: Time for action Connecting the box and two circles with revolute joint
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行连接框和两个圆的旋转关节的操作的时间
- en: 'Carry out the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: We are still working only on the logic part. Open our JavaScript logic file
    in a text editor.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然只在逻辑部分工作。在文本编辑器中打开我们的JavaScript逻辑文件。
- en: 'Add the following global variable at the top of the document to reference the
    car body:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档顶部添加以下全局变量，以引用汽车车身：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a function named `createCarAt` which takes the coordinate as arguments.
    Then, we move the body and the wheel creation code in this function. Afterwards,
    add the following highlighted Joint creation code. At last, return the car body:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`createCarAt`的函数，它接受坐标作为参数。然后，我们将身体和轮子创建代码移到这个函数中。然后，添加以下突出显示的关节创建代码。最后，返回汽车车身：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, all we need to do is to create a car with the initial position. Add the
    following code to the page loaded event handler after the world creation:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需要创建一个具有初始位置的汽车。在创建世界之后，将以下代码添加到页面加载事件处理程序中：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is time to save the file and run the physics world in a browser. At this
    time, the wheels and the car body are not separate pieces. They glue together
    as a car and drop on the ground correctly, as shown in the following screenshot:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候保存文件并在浏览器中运行物理世界了。此时，车轮和车身不是分开的部分。它们像一辆车一样粘在一起，正确地掉在地面上，如下面的截图所示：
- en: '![Time for action Connecting the box and two circles with revolute joint](img/1260_09_09.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![执行连接框和两个圆的旋转关节的操作的时间](img/1260_09_09.jpg)'
- en: What just happened?
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Joint is useful to add constraint between two bodies (or between a body and
    the world). There are many kinds of joints and what we used in this example is
    called **revolute joint**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关节对于在两个身体之间（或者在一个身体和世界之间）添加约束很有用。有许多种类型的关节，我们在这个例子中使用的是**旋转关节**。
- en: Using a revolute joint to create an anchor point between two bodies
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用旋转关节在两个身体之间创建一个锚点
- en: 'The revolute joint sticks two bodies together with a common anchor point. The
    two bodies are then glued together and are only allowed to rotate based on the
    common anchor point. The left hand side of the following screenshot shows that
    two bodies are connected with an anchor. In our code example, we set the anchor
    point to be exactly the center point of the wheel. The right hand side of the
    following screenshot shows how we set the joint. The wheel rotates as a wheel
    because the rotation origin is at the center. This setup makes the car and wheels
    look real:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转关节使用一个公共锚点将两个身体粘在一起。然后，这两个身体被粘在一起，只允许基于公共锚点旋转。下面截图的左侧显示了两个身体是如何连接的。在我们的代码示例中，我们将锚点设置为轮子的中心点。下面截图的右侧显示了我们如何设置关节。轮子因为旋转原点在中心而旋转。这种设置使得汽车和轮子看起来很真实：
- en: '![Using a revolute joint to create an anchor point between two bodies](img/1260_09_10.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用旋转关节在两个身体之间创建一个锚点](img/1260_09_10.jpg)'
- en: 'There are other types of joints which are useful in different ways. Joints
    are useful in creating a game environment and as there are several types of joints,
    each joint type is worth a try and you should think how to use them. The following
    link is the Box2D manual which explains each type of joint and how we can use
    them on different environment setups:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的关节，它们以不同的方式很有用。关节在创建游戏环境中很有用，因为有几种类型的关节，每种关节类型都值得一试，你应该考虑如何使用它们。以下链接是Box2D手册，解释了每种类型的关节以及我们如何在不同的环境设置中使用它们：
- en: '[http://www.box2d.org/manual.html#_Toc258082974](http://www.box2d.org/manual.html#_Toc258082974)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.box2d.org/manual.html#_Toc258082974](http://www.box2d.org/manual.html#_Toc258082974)'
- en: Adding force to the car with a keyboard input
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过键盘输入对汽车施加力
- en: We have the car ready now. Let's move it with our keyboard.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了汽车。让我们用键盘移动它。
- en: Time for action Adding force to the car
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行对汽车施加力的操作
- en: 'Carry out the following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `html5games.box2dcargame.js` JavaScript file in a text editor.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`html5games.box2dcargame.js` JavaScript文件。
- en: 'In the page loaded event handler, we add the following `keydown` event handler
    to the beginning. It listens to the **X** key and **Z** key to apply force in
    different directions:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面加载事件处理程序中，我们在开头添加了以下`keydown`事件处理程序。它监听**X**键和**Z**键以在不同方向施加力：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That is all. Save the files and run our game in the browser. When you press
    the **X** or **Z** key, the car starts moving. If you keep pressing the key, the
    world will keep adding force to the car and make it fly away:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。保存文件并在浏览器中运行我们的游戏。当你按下**X**或**Z**键时，汽车就会开始移动。如果你一直按着键，世界就会不断给汽车施加力量，让它飞走：
- en: '![Time for action Adding force to the car](img/1260_09_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![执行对汽车施加力的操作的时间](img/1260_09_11.jpg)'
- en: What just happened?
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just created an interaction with our car body. We can move the car left and
    right by pressing the **Z** and **X** keys. It seems like the game is getting
    interesting now.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了与我们的汽车车身的交互。我们可以通过按下**Z**和**X**键来左右移动汽车。现在游戏似乎变得有趣起来了。
- en: Applying force to a body
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对身体施加力
- en: 'We can apply force to any body by calling the `ApplyForce` function in that
    body. The following code shows the usage of the function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`ApplyForce`函数向任何身体施加力。以下代码显示了该函数的用法：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This function takes two arguments, which are listed in the following table:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数，列在下表中：
- en: '| Arguments | Type | Discussion |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `force` | `b2Vec2` | The force vector to apply to the body |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `force` | `b2Vec2` | 要施加到物体上的力向量 |'
- en: '| `point` | `b2Vec2` | The point where the force applies |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `point` | `b2Vec2` | 施加力的点 |'
- en: Understanding the difference between ApplyForce and ApplyImpulse
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解ApplyForce和ApplyImpulse之间的区别
- en: Besides the `ApplyForce` function, we can also move any body by using the `ApplyImpulse`
    function. Both functions move the body, but they move them in a different approach.
    If we want to change the instance velocity of a body, then we use `ApplyImpulse`
    once on the body to change velocity to our target value. On the other hand, we
    need to constituently apply force to a body to increase the speed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ApplyForce`函数，我们还可以使用`ApplyImpulse`函数移动任何物体。这两个函数都可以移动物体，但它们的移动方式不同。如果我们想改变物体的瞬时速度，那么我们可以在物体上使用`ApplyImpulse`一次，将速度改变为目标值。另一方面，我们需要不断地对物体施加力以增加速度。
- en: For example, we want to increase the velocity of the car like stepping on the
    pedal. In this case, we apply force to the car. If we are creating a ball game
    that needs to kick-start the ball, we may use the `ApplyImpulse` function to add
    an instance impulse to the ball body.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要增加汽车的速度，就像踩油门一样。在这种情况下，我们对汽车施加力。如果我们正在创建一个需要启动球的球类游戏，我们可以使用`ApplyImpulse`函数向球体添加一个瞬时冲量。
- en: Have a go hero
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试一试吧
- en: Can you think about a different situation where we will need to apply force
    or impulse to the body?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到另一种情况吗，我们需要对物体施加力或冲量吗？
- en: Adding ramps to our game environment
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的游戏环境添加坡道
- en: Now we can move the car. However, the environment is not interesting enough
    to play. Imagine now there are some ramps for the car to jump, and there is a
    gap between two platforms that a player has to fly the car over. It will become
    more interesting to play with different ramp setups.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以移动汽车。然而，环境还不够有趣。现在想象一下，有一些坡道供汽车跳跃，两个平台之间有一个间隙，玩家必须飞过汽车。使用不同的坡道设置玩起来会更有趣。
- en: Time for action Creating the world with ramps
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 创建具有坡道的世界
- en: 'Carry out the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: We will open the game logic JavaScript file.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将打开游戏逻辑JavaScript文件。
- en: 'Move the current ground creation code into a new function named `createGround`.
    Then, change the code to use the four given arguments as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前的地面创建代码移入一个名为`createGround`的新函数中。然后，更改代码以使用给定的四个参数，如下所示：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we have a function to create the ground body. We will now replace the ground
    creation code in the page loaded handler function with the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个创建地面物体的函数。我们将用以下代码替换页面加载处理程序函数中的地面创建代码：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save the file and preview the game in a browser. We should see a ramp now and
    a destination platform as shown in the following screenshot. Try to control the
    car, jump over the ramp, and reach the destination without falling down. Refresh
    the page to restart the game if you fail:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中预览游戏。我们应该看到一个坡道和一个目的地平台，如下截图所示。尝试控制汽车，跳过坡道，到达目的地而不掉下来。如果失败，刷新页面重新开始游戏：
- en: '![Time for action Creating the world with ramps](img/1260_09_12.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![时间行动 创建具有坡道的世界](img/1260_09_12.jpg)'
- en: What just happened?
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just wrapped the ground box creating code into a function, so that we can
    easily create a combination of ground bodies. These ground bodies composite the
    level environment of the game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将地面箱子创建代码封装到一个函数中，这样我们就可以轻松地创建一组地面物体。这些地面物体构成了游戏的级别环境。
- en: 'In addition, this is the first time we are rotating a body. We set the rotation
    of the body by using the `rotation` property which takes a value in radian. Most
    people may get used to the degree unit; we can get the radian value from degree
    by using the following formula:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是我们第一次旋转物体。我们使用`rotation`属性设置物体的旋转，该属性以弧度值为参数。大多数人可能习惯于度单位；我们可以使用以下公式从度获取弧度值：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By setting the rotation of a box, we can have a ramp of varying slope setup
    in our game.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置箱子的旋转，我们可以在游戏中设置不同坡度的坡道。
- en: Have a go hero Creating different environments with different joints
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试一试吧 创建具有不同连接器的不同环境
- en: We have a ramp setup now and we can play with the car within the environment.
    How about using different kinds of joints to setup the playground? For example,
    how about a pulley joint to act as a lift? On the other hand, how about including
    a dynamic board with a joint at the center?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个坡道，并且可以在环境中玩汽车。如何使用不同类型的连接器来设置游乐场？例如，使用滑轮连接器作为升降机怎么样？另一方面，包括一个带有中心连接器的动态板怎么样？
- en: Checking collisions in the Box2D world
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Box2D世界中检查碰撞
- en: The Box2D physics library calculates all collisions automatically. Imagine now
    we setup a ground body as the destination. Players win when they successfully
    move the car to hit the destination. As Box2D already calculates all collisions,
    all we have to do is get the detected collision list and determine whether our
    car has hit the destination ground.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D物理库会自动计算所有碰撞。现在想象一下，我们设置了一个地面物体作为目的地。玩家成功将汽车移动到目的地时获胜。由于Box2D已经计算了所有碰撞，我们所要做的就是获取检测到的碰撞列表，并确定我们的汽车是否撞到了目的地地面。
- en: Time for action Checking a collision between the car and the destination body
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 检查汽车和目的地物体之间的碰撞
- en: 'Carry out the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Again, we start from our game logic. Open the `html5games.box2dcargame.js` JavaScript
    file in a text editor.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们从游戏逻辑开始。在文本编辑器中打开`html5games.box2dcargame.js` JavaScript文件。
- en: 'We setup a destination ground in the ground creation code and assign it to
    our `gamewinWall` reference inside the `carGame` global object instance as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在地面创建代码中设置了一个目标地面，并将其分配给`carGame`全局对象实例内的`gamewinWall`引用，如下所示：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we move on to the `step` function. In each step, we get the complete
    contact list from the world and check whether any two colliding objects are car
    and the destination ground:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们转向`step`函数。在每一步中，我们从世界中获取完整的接触列表，并检查是否有任何两个相互碰撞的对象是汽车和目标地面：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will now save the code and open the game in a browser again. This time,
    we have to open the console window to track if we get the **Level Passed!** output
    when the car hits that wall. Try to finish the game and we should see the output
    in the console once the car hits the destination:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存代码并再次在浏览器中打开游戏。这一次，我们必须打开控制台窗口，以跟踪当汽车撞到墙时是否获得**Level Passed!**输出。尝试完成游戏，我们应该在汽车到达目的地后在控制台中看到输出：
- en: '![Time for action Checking a collision between the car and the destination
    body](img/1260_09_13.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![执行检查汽车和目的地物体之间的碰撞](img/1260_09_13.jpg)'
- en: What just happened?
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just created the game winning logic by checking the collision contacts. The
    player wins when the car successfully reaches the destination ground object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过检查碰撞联系人创建了游戏获胜逻辑。当汽车成功到达目的地地面物体时，玩家获胜。
- en: Getting the collision contact list
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取碰撞联系人列表
- en: 'In each step, Box2D calculates all collisions and puts them into a **contact
    list** in the `world` instance. We can get the contact list by using the `carGame.world.GetContactList()`
    function. The returned contact list is a **link list**. We can travel through
    the entire link list by using the following for-loop:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤中，Box2D计算所有碰撞并将它们放入“world”实例中的**contact list**中。我们可以使用`carGame.world.GetContactList()`函数获取联系人列表。返回的联系人列表是一个**链接列表**。我们可以通过以下for循环遍历整个链接列表：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we get the collided shapes, we check whether the body of that shape is
    a car or the destination body. As the car shape may be in shape 1 or shape 2,
    and the same applies to the `gamewinWall`, we use the following code to check
    both combinations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获得碰撞的形状时，我们检查该形状的主体是否是汽车或目的地主体。由于汽车形状可能在形状1或形状2中，`gamewinWall`也是如此，我们使用以下代码来检查两种组合：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Have a go hero
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看英雄
- en: We created a game over dialog in *Chapter 7, Using Local Storage to Store Game
    Data*. How about using that technique here to create a dialog showing the player
    passed the level when hitting the winning wall? It will also be useful as level
    transition later when we add different level setups to the game.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第7章，使用本地存储存储游戏数据*中创建了一个游戏结束对话框。在这里使用该技术创建一个对话框，显示玩家通过了级别，怎么样？当我们向游戏添加不同的级别设置时，它也将作为级别过渡的工具。
- en: Restarting the game
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新开始游戏
- en: You may have already tried refreshing the page several times in the last example
    to make the car successfully jump to the destination. Imagine now we can press
    a key to re-initialize the world. Then, we can follow the trial-and-error method
    until success.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经尝试在上一个示例中多次刷新页面，以使汽车成功跳到目的地。现在想象一下，我们可以按键重新初始化世界。然后，我们可以按照试错的方法直到成功。
- en: Time for action Restarting the game while pressing the R key
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按下R键重新启动游戏的时间
- en: 'We will assign the **R** key as the restart key for our game:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将**R**键指定为游戏的重新启动键：
- en: Again, we only need to change the JavaScript file. Open the `html5games.box2dcargame.js`
    JavaScript file in a text editor.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们只需要更改JavaScript文件。在文本编辑器中打开`html5games.box2dcargame.js` JavaScript文件。
- en: 'We move the create world, ramp, and the car code into a function named `restartGame`.
    They were originally in the page loaded handler function:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建世界、坡道和汽车代码移入名为“restartGame”的函数中。它们最初位于页面加载处理程序函数中：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, in the page loaded event handler, we call the `restartGame` function
    to initialize the game as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在页面加载事件处理程序中，我们调用`restartGame`函数来初始化游戏，如下所示：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we add the following highlighted code to the `keydown` handler to
    restart the game when the **R** key is pressed:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将以下突出显示的代码添加到`keydown`处理程序中，以在按下**R**键时重新启动游戏：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'How about restarting the game when the player passes the level? Add the following
    highlighted code to the game win logic:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家通过级别时，怎么样重新开始游戏？将以下突出显示的代码添加到游戏获胜逻辑中：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is time to test the game in a browser. Try playing the game and press the
    **R** key to restart the game.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候在浏览器中测试游戏了。尝试玩游戏并按**R**键重新启动游戏。
- en: What just happened?
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We refractor our code to create a `restartGame` function. The world is destroyed
    and initialized again each time we call this function. We can destroy the existing
    world and create a new empty one by creating a new world instance of our world
    variable as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构我们的代码来创建一个“restartGame”函数。每次调用此函数时，世界都会被销毁并重新初始化。我们可以通过创建我们的世界变量的新世界实例来销毁现有世界并创建一个新的空世界，如下所示：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Have a go hero Creating the game over wall
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看英雄 创建游戏结束墙
- en: Now the only way to restart the game is by pressing the restart key. How about
    creating a ground at the bottom of the world that checks any falling car? When
    the car drops and hits the bottom ground, we know that the player has failed and
    then restart the game.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新启动游戏的唯一方法是按重新启动键。在世界底部创建一个地面，检查任何下落的汽车怎么样？当汽车掉落并撞到底部地面时，我们知道玩家失败了，然后重新开始游戏。
- en: Adding a level support to our car game
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的汽车游戏添加级别支持
- en: Imagine now we can level up to the next environment setup when finishing each
    game. We will need several environment setups for each level.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，当完成每个游戏时，我们可以升级到下一个环境设置。对于每个级别，我们将需要几个环境设置。
- en: Time for action Loading game with levels data
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载具有级别数据的游戏的时间
- en: 'We will refractor our code to support loading the static ground bodies from
    a levels data structure. Let''s work on it by carrying out the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的代码以支持从级别数据结构加载静态地面物体。让我们通过以下步骤来完成它：
- en: Open the `html5games.box2dcargame.js` JavaScript file in a text editor.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`html5games.box2dcargame.js` JavaScript文件。
- en: 'We will need each ground setup on each level. Put the following code at the
    top of the JavaScript file. It is an array of levels. Each level is another array
    of objects with the position, dimension, and rotation of the static ground body:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要每个级别的地面设置。将以下代码放在JavaScript文件的顶部。这是一个级别数组。每个级别都是另一个对象数组，其中包含静态地面物体的位置、尺寸和旋转：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we use the following variable in the `carGame` object instance to store
    the current level:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`carGame`对象实例中的以下变量来存储当前级别：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace the `restartGame` function with the following code. It changes the
    function to accept a `level` argument. Then, create the ground or car by the level
    data:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换`restartGame`函数。它将函数更改为接受一个`level`参数。然后，根据关卡数据创建地面或汽车：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the page loaded handler function, we change the `restartGame` function calling
    by providing `currentLevel` as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面加载处理程序函数中，我们通过提供`currentLevel`来更改`restartGame`函数的调用：
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also need to provide the `currentLevel` value in the restart key handler:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在重启键处理程序中提供`currentLevel`值：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Lastly, we change the following highlighted code in the game win logic. We
    level up the game when the car hits the destination:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在游戏获胜逻辑中更改以下突出显示的代码。当汽车撞到目的地时，我们升级游戏：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will now run the game in the web browser. Finish the level and the game
    should restart at the next level:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在Web浏览器中运行游戏。完成关卡后，游戏应该重新开始下一关：
- en: '![Time for action Loading game with levels data](img/1260_09_14.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action Loading game with levels data](img/1260_09_14.jpg)'
- en: What just happened?
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We just created a data structure to store the levels. Then, we created the game
    with the given level number and constructed the world with the level data.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个数据结构来存储关卡。然后，我们根据给定的关卡号创建了游戏，并使用关卡数据构建了世界。
- en: 'Each level data is an array of objects. Each object contains properties of
    each ground body in the world. This includes basic properties such as position,
    size, and rotation. There is also a property named `type`. It defines whether
    the body is a normal box body, car data, or the destination winning ground:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关卡数据都是一个对象数组。每个对象包含世界中每个地面物体的属性。这包括基本属性，如位置、大小和旋转。还有一个名为`type`的属性。它定义了物体是普通的箱子物体、汽车数据，还是获胜的目的地地面：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When creating the world, we use the following code to loop through all objects
    in the level array. We then create the car and ground bodies and reference the
    game winning ground according to the type:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建世界时，我们使用以下代码循环遍历关卡数组中的所有对象。然后根据类型创建汽车和地面物体，并引用游戏获胜的地面：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Have a go hero Creating more levels
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试创建更多关卡
- en: Now we have several levels setup for our game. How about duplicating the level
    data to create more interesting levels to play? Create your own levels and play
    with them. It is just as if a kid builds blocks and plays with them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为游戏设置了几个关卡。如何复制关卡数据以创建更有趣的关卡来玩？创建你自己的关卡并玩耍。就像一个孩子搭积木玩一样。
- en: Replacing the Box2D outline drawing with graphics
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用图形替换Box2D轮廓绘图
- en: We have created the game that is at least playable with several levels. However,
    they are just some outline boxes. We cannot even distinguish between the destination
    body and other ground bodies in the game. Imagine now the destination is a racing
    flag and there is a car graphic to represent it. It will make the game purpose
    clearer.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个至少可以玩几个关卡的游戏。然而，它们只是一些轮廓框。我们甚至无法区分游戏中的目的地和其他地面物体。现在想象一下，目的地是一个赛车旗，有一辆汽车图形来代表它。这将使游戏目的更加清晰。
- en: Time for action Adding a flag graphic and a car graphic to the game
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加旗帜图形和汽车图形到游戏
- en: 'Carry out the following steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We will first download the graphics we need for this example. Go to the following
    link to download the graphics:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要下载这个示例所需的图形。转到以下链接下载图形：
- en: '[http://gamedesign.cc/html5games/1260_09_example_graphics.zip](http://gamedesign.cc/html5games/1260_09_example_graphics.zip
    )'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://gamedesign.cc/html5games/1260_09_example_graphics.zip](http://gamedesign.cc/html5games/1260_09_example_graphics.zip
    )'
- en: Extract the ZIP file in the `images` folder.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`images`文件夹中提取ZIP文件。
- en: 'Now it is time to edit the `index.htm` file. Add the following HTML markup
    to the body:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编辑`index.htm`文件了。在body中添加以下HTML标记：
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We want to hide the asset DIV that contains our `img` tags. Open the `cargame.css`
    file and add the following CSS rule to keep the asset DIV out of our sight:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要隐藏包含我们`img`标签的资产DIV。打开`cargame.css`文件，并添加以下CSS规则以使资产DIV不可见：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We will now move on to the logic part. Open the `html5games.box2dcargame.js`
    JavaScript file.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将进入逻辑部分。打开`html5games.box2dcargame.js` JavaScript文件。
- en: 'In the `createGround` function, we add a new argument named `type` to pass
    in the type. Then, we add the highlighted code to assign the reference of the
    `flag` image to the ground shape user data if it is a winning destination ground:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createGround`函数中，我们添加一个名为`type`的新参数以传递类型。然后，如果是获胜的目的地地面，我们添加了突出显示的代码来分配`flag`图像的引用给地面形状的用户数据：
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When creating the ground, we need to pass the `type` property now. Replace
    the ground creation code with the following one:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建地面时，现在需要传递`type`属性。用以下代码替换地面创建代码：
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we assign the reference of the `bus` image tag to the user data in the
    car shape. Add the following highlighted code to the car box definition creation:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`bus`图像标签的引用分配给汽车形状的用户数据。将以下突出显示的代码添加到汽车框定义创建中：
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We used to get the reference of an element by the jQuery `$(selector)` method.
    The jQuery selector returns an array of the element objects with additional jQuery
    data wrapped. If we want to get the original document element reference, then
    we can either use the `document.getElementById` method or `$(selector).get(0)`.
    As `$(selector)` returns an array, `get(0)` gives the first original document
    element in the list
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾经通过jQuery的`$(selector)`方法获取元素的引用。jQuery选择器返回一个带有额外jQuery数据包装的元素对象数组。如果我们想要获取原始文档元素引用，那么我们可以使用`document.getElementById`方法或`$(selector).get(0)`。由于`$(selector)`返回一个数组，`get(0)`给出列表中的第一个原始文档元素
- en: 'Then, we need to handle the wheels. We assign the `wheel` image tag to the
    wheel body''s `userData` property. Add the following highlighted code to the `createWheel`
    function:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要处理车轮。我们将`wheel`图像标签分配给车轮的`userData`属性。将以下突出显示的代码添加到`createWheel`函数中：
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we have to draw the images in the canvas. Replace the `drawWorld`
    function with the following code. The highlighted code is the changed part:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须在画布中绘制图像。用以下代码替换`drawWorld`函数。突出显示的代码是更改的部分：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, save all files and run the game in a web browser. We should see a
    yellow bus graphic, two wheels, and a flag as the destination. Play the game now
    and the game should move on to the next level when the bus hits the flag:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存所有文件并在Web浏览器中运行游戏。我们应该看到一个黄色的公共汽车图形，两个车轮和一个旗帜作为目的地。现在玩游戏，当公共汽车撞到旗帜时游戏应该进入下一关：
- en: '![Time for action Adding a flag graphic and a car graphic to the game](img/1260_09_15.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action Adding a flag graphic and a car graphic to the game](img/1260_09_15.jpg)'
- en: What just happened?
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We are now presenting our game with minimal graphics. At least, players can
    easily know what they are controlling and where they should go.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在以最少的图形呈现我们的游戏。至少，玩家可以轻松知道他们在控制什么，以及他们应该去哪里。
- en: The Box2D library uses a canvas to render the physics world. Therefore, all
    techniques that we learned about a canvas can be applied here. In *Chapter 5,
    Building* a *Canvas Games Masterclass*, we learned the use of the `drawImage`
    function to display an image in the canvas. We used this technique to draw the
    flag graphic in the canvas of the physics world.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D库使用画布来渲染物理世界。因此，我们学到的所有关于画布的技术都可以应用在这里。在*第5章，构建*一个*Canvas Games Masterclass*中，我们学习了使用`drawImage`函数在画布中显示图像。我们使用这种技术在物理世界的画布上绘制旗帜图形。
- en: Using userData in shape and body
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在形状和物体中使用userData
- en: How do we know which physics body needs to be displayed as the flag image? There
    is a property named `userData` in every Box2D shape and body. This property is
    used to store any custom data related to that shape or body. For example, we may
    store the filename of the graphic file or we just directly store the reference
    to the image tag.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道哪个物理体需要显示为旗帜图像？每个Box2D形状和物体中都有一个名为`userData`的属性。此属性用于存储与该形状或物体相关的任何自定义数据。例如，我们可以存储图形文件的文件名，或者直接存储图像标签的引用。
- en: 'We have a list of image tags referencing the graphic assets that we need in
    the game. However, we do not want to display the image tags, they are just for
    the purpose of loading and referencing. We hide those asset image tags by setting
    their position out of the HTML bound with the following CSS style. We do not use
    `display:none` because we cannot get the width and height of the element that
    is not displayed at all. We need the width and height to position graphics correctly
    in the physics world:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个图像标签列表，引用了游戏中需要的图形资源。然而，我们不想显示这些图像标签，它们只是用于加载和引用。我们通过以下CSS样式将这些资源图像标签隐藏在HTML边界之外。我们不使用`display:none`，因为我们无法获取根本没有显示的元素的宽度和高度。我们需要宽度和高度来正确定位物理世界中的图形：
- en: '[PRE49]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Drawing graphics every frame according to the state of its physics body
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据其物理体的状态在每帧绘制图形
- en: The drawing from Box2D is just for development use before we replace it with
    our graphics.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从Box2D绘制只是用于开发，然后我们用我们的图形替换它。
- en: The following code checks whether the shape has a user data assigned. In our
    example, the user data is used for referencing the `image` tag of that graphics
    asset. We get the image tag and pass it to the canvas context `drawImage` function
    to draw.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查形状是否分配了用户数据。在我们的示例中，用户数据用于引用该图形资源的`image`标签。我们获取图像标签并将其传递给画布上下文的`drawImage`函数进行绘制。
- en: 'All box and circle shapes in Box2D have the origin point at the center. However,
    the image drawing in the canvas needs the top-left point. Therefore, we have both
    x/y coordinates and offset of top-left x/y points which is a negative half width
    and height of the image:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D中的所有盒形和圆形形状的原点都在中心。然而，在画布中绘制图像需要左上角点。因此，我们有x/y坐标和左上角x/y点的偏移量，这是图像宽度和高度的负一半：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Rotating and translating an image in the canvas
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布中旋转和平移图像
- en: 'We used the `drawImage` function to draw an image directly with the coordinate.
    However, the situation is different here. We need to rotate the drawn image. This
    is done by rotating the context before drawing and then restoring the rotation
    afterwards. We can do this by saving the context state, translating it, rotating
    it, and then calling the `restore` function. The following code shows how we draw
    an image at a given position and rotation. The `topleftX` and `topleftY` are the
    offset distances from the image center origin to the top left point:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`drawImage`函数直接绘制图像与坐标。然而，在这里情况不同。我们需要旋转绘制的图像。这是通过在绘制之前旋转上下文，然后在绘制后恢复旋转来完成的。我们可以通过保存上下文状态，平移它，旋转它，然后调用`restore`函数来实现这一点。以下代码显示了我们如何在给定位置和旋转角度绘制图像。`topleftX`和`topleftY`是从图像中心原点到左上角点的偏移距离：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We do not need to make the physics body area exactly the same as its graphics.
    For example, if we have a round circle chicken, we can represent it in the physics
    world by just a ball body. Using a simple physics body can improve the performance
    a lot.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使物理体积与其图形完全相同。例如，如果我们有一个圆形的鸡，我们可以通过一个球体来在物理世界中表示它。使用简单的物理体可以大大提高性能。
- en: Have a go hero Applying the previously learned technique to the car game
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下，将之前学到的技术应用到汽车游戏中
- en: We have learned using CSS3 transition to animate a scoreboard. How about applying
    it to this car game? Moreover, how about adding some engine sounds to the car?
    Just try applying what we have learned through this book to give players a complete
    game experience.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了使用CSS3过渡来为记分牌添加动画。将它应用到这个汽车游戏怎么样？此外，怎么样给汽车添加一些引擎声音？尝试应用我们通过这本书学到的知识，为玩家提供完整的游戏体验。
- en: Adding a final touch to make the game fun to play
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加最后的修饰，使游戏更有趣
- en: Imagine now we want to publish the game. The game logic is basically here, but
    it looks quite ugly with the black and white environment. In this section, we
    will add some final touches to the game so it is much more attractive. We will
    also apply some constraints to limit the time of ApplyForce. This constraint makes
    the game more fun because it requires a player to think before he applies too
    much force to the car.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象我们想要发布游戏。游戏逻辑基本上已经完成，但是在黑白环境下看起来相当丑陋。在本节中，我们将为游戏添加一些最后的修饰，使其更具吸引力。我们还将应用一些限制来限制ApplyForce的时间。这种限制使游戏更有趣，因为它要求玩家在对汽车施加过多力之前先考虑。
- en: Time for action Decorating the game and adding a fuel limitation
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 装饰游戏并添加燃料限制
- en: 'Carry out the following steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: First, we need some background images for the starting screen, game winning
    screen, and environment backgrounds for each level. These graphics can be found
    from the code bundle named `box2d_final_game`. The following screenshot shows
    the graphics we need in this section:![Time for action Decorating the game and
    adding a fuel limitation](img/1260_09_18.jpg)
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一些起始画面、游戏获胜画面和每个级别的环境背景的背景图像。这些图形可以从名为`box2d_final_game`的代码包中找到。以下截图显示了本节中所需的图形：![行动时间
    装饰游戏并添加燃料限制](img/1260_09_18.jpg)
- en: 'Open the `index.htm` file and replace the canvas element with the following
    markup. It creates two more game components named current level and fuel remaining,
    and groups the game components into a `game-container` DIV:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.htm`文件，并用以下标记替换画布元素。它创建了两个更多的游戏组件，名为当前级别和剩余燃料，并将游戏组件分组到一个`game-container`
    DIV中：
- en: '[PRE52]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, we will copy the `cargame.css` file from the code bundle. It contains
    several class style definitions for the game. The game should look similar to
    the one shown in the following screenshot when we have applied the new stylesheet:![Time
    for action Decorating the game and adding a fuel limitation](img/1260_09_19.jpg)
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从代码包中复制`cargame.css`文件。它包含了游戏的几个类样式定义。当我们应用新的样式表时，游戏应该看起来类似于以下截图中显示的游戏：
- en: Now we will move on to the JavaScript part. Open the `html5games.box2dcargame.js`
    file.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将继续进行JavaScript部分。打开`html5games.box2dcargame.js`文件。
- en: 'Update the `carGame` object declaration with the following additional variable:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下额外变量更新`carGame`对象声明：
- en: '[PRE53]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we have the starting screen. Instead of starting the game once, the page
    is loaded. We show the starting screen and wait for the player to click on the
    game canvas. Add the following logic to the page `ready` function:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了起始画面。页面加载后不再立即开始游戏。我们显示起始画面，并等待玩家点击游戏画布。在页面`ready`函数中添加以下逻辑：
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We need to remove the original `step()` function calling at the end of the page
    `ready` function because we are calling it on a mouse click.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在页面`ready`函数的末尾删除原始的`step()`函数调用，因为我们在鼠标点击时调用它。
- en: 'Next, we need to handle the game winning screen when the player passes all
    levels. In the winning flag collision checking logic, we replace the original
    `restartGame` function calling with the following logic which checks whether we
    show the next level or the ending screen:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理玩家通过所有级别时的游戏获胜画面。在获胜旗帜碰撞检查逻辑中，我们用以下逻辑替换了原始的`restartGame`函数调用，该逻辑检查我们是显示下一个级别还是结束画面：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we will handle the game playing background. We prepared each game background
    for each level setting. We will switch the background in the `restartGame` function
    which responds to reconstruct the world:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将处理游戏播放背景。我们为每个级别设置准备了每个游戏背景。我们将在`restartGame`函数中切换背景，该函数响应重构世界：
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With the game graphics now, we do not need the physics object outline drawing
    any more. We can remove the `drawShape(s, context)`; code in the `drawWorld` function.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在游戏图形已经完成，我们不再需要物理对象轮廓绘制。我们可以在`drawWorld`函数中删除`drawShape(s, context)`的代码。
- en: 'Finally, let''s add some constraints. Remember that in our level data, we include
    a mystery fuel data to the car. It is an indicator indicating how much fuel the
    car contains. We will use this fuel to limit the player''s input. The fuel reduces
    each time a force is applied to the car. The player cannot apply any additional
    force once the fuel runs out. This limitation makes the game more fun to play:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加一些限制。请记住，在我们的级别数据中，我们包括了一些神秘的燃料数据给汽车。它是一个指示器，指示汽车包含多少燃料。我们将使用这个燃料来限制玩家的输入。每次对汽车施加力时，燃料都会减少。一旦燃料用完，玩家就不能再施加额外的力。这种限制使游戏更有趣：
- en: 'Update the **x** and **z** `keydown` function with the following logic:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下逻辑更新**x**和**z**的`keydown`函数：
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In addition, in the car creating logic in the restart game function, we initialize
    the fuel as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在重新开始游戏函数中的汽车创建逻辑中，我们初始化燃料如下：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, run the game in a browser. We should get five graphic levels. The following
    screenshot shows how the last four levels look:![Time for action Decorating the
    game and adding a fuel limitation](img/1260_09_22.jpg)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在浏览器中运行游戏。我们应该得到五个图形级别。以下截图显示了最后四个级别的外观：![行动时间 装饰游戏并添加燃料限制](img/1260_09_22.jpg)
- en: 'After passing all levels, we get the following winning screen:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过所有级别后，我们得到以下获胜画面：
- en: '![Time for action Decorating the game and adding a fuel limitation](img/1260_09_20.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 装饰游戏并添加燃料限制](img/1260_09_20.jpg)'
- en: What just happened?
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We just decorated our game with more graphics. We also draw each level environment
    a background image. The following screenshot illustrates how the visual ground
    represents the logical physics boxes. Unlike the car and the winning flag, the
    ground graphics are not associated with the physics ground. It is just a background
    image with the graphics in their respective positions. We can use this approach
    because those boxes will never move:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚用更多的图形装饰了我们的游戏。我们还为每个级别环境绘制了背景图像。以下截图说明了视觉地面如何表示逻辑物理框。与汽车和获胜旗帜不同，地面图形与物理地面无关。它只是一个背景图像，其图形位于各自的位置。我们可以使用这种方法，因为这些框永远不会移动：
- en: '![What just happened?](img/1260_09_21.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1260_09_21.jpg)'
- en: 'We can then prepare several CSS styles for each level with the level number
    in the class name, such as `.gamebg_level_1` and `.gamebg_level_2`. With each
    class linked with each level background, we can change the background when switching
    a level in the following code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为每个级别准备几种CSS样式，类名中带有级别编号，例如`.gamebg_level_1`和`.gamebg_level_2`。通过将每个类与每个级别的背景链接起来，我们可以在切换级别时更改背景，如下代码所示：
- en: '[PRE59]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Adding fuel to add a constraint when applying force
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加燃料以在施加力时增加约束
- en: 'Now we limit the player''s input by providing limited fuel to use. The fuel
    decreases when players apply force to the car. We used the following `keydown`
    logic to decrease the fuel and prevent additional force when running out of fuel:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过提供有限的燃料来限制玩家的输入。当玩家对汽车施加力时，燃料会减少。我们使用以下`keydown`逻辑来减少燃料并在燃料耗尽时阻止额外的力量：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Presenting the remaining fuel in a CSS3 progress bar
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在CSS3进度条中呈现剩余燃料
- en: 'In our game, we present the remaining fuel as a progress bar. The progress
    bar is actually a `DIV` inside another `DIV`. The following markup shows the structure
    of the progress bar. The outer `DIV` defines the maximum value and the inner `DIV`
    shows the actual value:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将剩余燃料呈现为进度条。进度条实际上是另一个`DIV`内部的`DIV`。以下标记显示了进度条的结构。外部`DIV`定义了最大值，内部`DIV`显示了实际值：
- en: '[PRE61]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following screenshot illustrates the structure of the progress bar:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了进度条的结构：
- en: '![Presenting the remaining fuel in a CSS3 progress bar](img/1260_09_23.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![在CSS3进度条中呈现剩余燃料](img/1260_09_23.jpg)'
- en: 'With this structure, we can show a specific progress by setting the width as
    a percentage value. We use the following code to update the progress bar according
    to the percentage of the fuel:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个结构，我们可以通过将宽度设置为百分比值来显示特定的进度。我们使用以下代码根据燃料的百分比来更新进度条：
- en: '[PRE62]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is the basic logic to setup a progress bar and control it with the width
    style. Furthermore, we give the progress bar''s background a nice gradient as
    shown in the following screenshot:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置进度条并使用宽度样式控制的基本逻辑。此外，我们给进度条的背景添加了漂亮的渐变，如下截图所示：
- en: '![Presenting the remaining fuel in a CSS3 progress bar](img/1260_09_24.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![在CSS3进度条中呈现剩余燃料](img/1260_09_24.jpg)'
- en: 'It is done in the stylesheet with the following CSS3 gradient background definition:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在样式表中完成的，使用以下CSS3渐变背景定义：
- en: '[PRE63]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We learned a lot in this chapter about using the Box2D physics engine to create
    a car adventure game in canvas.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了如何使用Box2D物理引擎在画布中创建汽车冒险游戏。
- en: 'Specifically, we covered the following topics:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了以下主题：
- en: Installing the JavaScript ported physics engine
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装JavaScript移植的物理引擎
- en: Creating static and dynamic bodies in the physics world
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理世界中创建静态和动态物体
- en: Setting up the car by using joints to constrain bodies and wheels
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关节来设置汽车的约束和车轮
- en: Getting a keyboard input with the prototype library
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型库获取键盘输入
- en: Interacting with the car by adding force to it
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过向汽车添加力与其进行交互
- en: Checking collisions in the physics world as the level destination
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理世界中检查碰撞作为级别目的地
- en: Drawing an image to replace the outline of our physical game objects
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像绘制为替换我们的物理游戏对象轮廓
- en: We also discussed adding a fuel bar to limit the player's input to give some
    constraint and add more fun to the game play.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了添加燃料条以限制玩家的输入，增加游戏乐趣。
- en: We have now learned about using the Box2D physics library to create a canvas-based
    physics game.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了使用Box2D物理库来创建基于画布的物理游戏。
- en: We discussed different aspects of making HTML5 games with CSS3 and JavaScript
    through all nine chapters. We learned building a traditional Ping Pong game in
    DOM, we built a card matching game in CSS3, and an Untangle puzzle game with the
    canvas. Then, we explored adding sounds to the game and created a mini piano musical
    game around it. Next, we discussed saving and loading game statuses by using the
    local storage. Moreover, we tried building a draw-and-guess real-time multiplayer
    game with WebSockets. Finally, we created a car game with a physics engine in
    this chapter.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过九章讨论了使用CSS3和JavaScript制作HTML5游戏的不同方面。我们学会了在DOM中构建传统的乒乓球游戏，在CSS3中构建卡片匹配游戏，并在画布中创建了一个解谜游戏。然后，我们探索了向游戏添加声音，并围绕它创建了一个迷你钢琴音乐游戏。接下来，我们讨论了使用本地存储保存和加载游戏状态。此外，我们尝试使用WebSockets构建了一个实时多人游戏。最后，在本章中，我们创建了一个带有物理引擎的汽车游戏。
- en: 'Throughout the book, we built different types of games and learned some essential
    techniques that we need to make HTML5 games. The next step is to go on and deploy
    your own games. To help develop your own games, there are some resources that
    can help. The following list gives some useful links for HTML5 games development:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们构建了不同类型的游戏，并学习了一些制作HTML5游戏所需的基本技术。下一步是继续开发自己的游戏。为了帮助开发自己的游戏，有一些资源可以提供帮助。以下列表提供了一些HTML5游戏开发的有用链接：
- en: HTML5 game engines
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML5游戏引擎
- en: Impact ([http://impactjs.com/](http://impactjs.com/))
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Impact ([http://impactjs.com/](http://impactjs.com/))
- en: Rocket Engine ([http://rocketpack.fi/engine/](http://rocketpack.fi/engine/))
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rocket Engine ([http://rocketpack.fi/engine/](http://rocketpack.fi/engine/))
- en: LimeJS ([http://www.limejs.com/](http://www.limejs.com/))
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LimeJS ([http://www.limejs.com/](http://www.limejs.com/))
- en: Game sprites, and textures
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏精灵和纹理
- en: Lost Garden([http://lunar.lostgarden.com/labels/free%20game%20graphics.html](http://lunar.lostgarden.com/labels/free%20game%20graphics.html))
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lost Garden（[http://lunar.lostgarden.com/labels/free%20game%20graphics.html](http://lunar.lostgarden.com/labels/free%20game%20graphics.html)）
- en: Some free sprites from The_Protagonist's Domain ([http://www.freewebs.com/teh_pro/sprites.htm](http://www.freewebs.com/teh_pro/sprites.htm))
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自The_Protagonist's Domain的一些免费精灵（[http://www.freewebs.com/teh_pro/sprites.htm](http://www.freewebs.com/teh_pro/sprites.htm)）
- en: HasGraphics sprites, textures, and tilesets ([http://hasgraphics.com/category/sprites/](http://hasgraphics.com/category/sprites/))
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HasGraphics精灵、纹理和瓦片集（[http://hasgraphics.com/category/sprites/](http://hasgraphics.com/category/sprites/)）
- en: CG Textures ([http://cgtextures.com/](http://cgtextures.com/))
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CG纹理（[http://cgtextures.com/](http://cgtextures.com/)）
- en: Sound effects
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音效
- en: PacDV ([http://www.pacdv.com/sounds/](http://www.pacdv.com/sounds/))
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PacDV（[http://www.pacdv.com/sounds/](http://www.pacdv.com/sounds/)）
- en: FlashKit Sound Effects ([http://www.flashkit.com/soundfx/](http://www.flashkit.com/soundfx/))
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FlashKit音效（[http://www.flashkit.com/soundfx/](http://www.flashkit.com/soundfx/)）
- en: FlashKit Sound Loops ([http://www.flashkit.com/loops/](http://www.flashkit.com/loops/))
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FlashKit声音循环（[http://www.flashkit.com/loops/](http://www.flashkit.com/loops/)）
