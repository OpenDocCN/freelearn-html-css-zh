- en: Chapter 4. The Adventure Begins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。冒险开始
- en: In this chapter, we will create a fun little action adventure game that will
    build upon our foundational knowledge. We will start with an animated player character
    that can navigate the world and has a short range melee attack. The game world
    will consist of multiple rooms, and the player will be able to move from one room
    to another while keeping all their stats. We will place all the code for the player
    controls and deal with wall collision in a single script to create a more efficient
    project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个有趣的小动作冒险游戏，这将建立在我们的基础知识之上。我们将从一个可以在世界中导航并具有短程近战攻击的动画玩家角色开始。游戏世界将由多个房间组成，玩家将能够从一个房间移动到另一个房间，同时保留所有他们的统计数据。我们将把所有玩家控制的代码和处理墙壁碰撞的代码放在一个脚本中，以创建一个更高效的项目。
- en: 'As can be seen in the next screenshot, the theme of this game is the horrors
    of high school, and there will be three enemies in the world with basic artificial
    intelligence: a Ghost Librarian, a Brawl, and a Coach. The Ghost Librarian will
    appear if the player approaches its resting place and will chase the player until
    it gets too far away, and then return to where it came from. The Brawl will wander
    through the room on a path, and if it spots the player, it will increase in size
    and velocity. The Coach is the protector of trophies and will navigate the world
    on its own. If it sees the player it will pursue while avoiding walls and other
    Coaches, and if it is close enough it will melee attack the player.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，这个游戏的主题是高中的恐怖，世界里会有三个基本人工智能的敌人：一个幽灵图书管理员，一个乱斗，和一个教练。幽灵图书管理员会在玩家接近它的休息地点时出现，并追逐玩家直到距离太远，然后返回原来的位置。乱斗会在房间里漫游，如果它发现玩家，它会增加体积和速度。教练是奖杯的守护者，会独自在世界中导航。如果它看到玩家，它会追击并避开墙壁和其他教练，如果足够接近，它会对玩家进行近战攻击。
- en: '![The Adventure Begins](img/4100OT_04_16.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![冒险开始](img/4100OT_04_16.jpg)'
- en: Creating animated characters
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画角色
- en: 'So far, the player objects we have created have been very basic. In [Chapter
    1](ch01.html "Chapter 1. Getting to Know the Studio with Your First Game"), *Getting
    to Know the Studio with Your First Game*, the player had no animation. In [Chapter
    3](ch03.html "Chapter 3. Shoot ''em Up: Creating a Side-scrolling Shooter"), *Shoot
    ''em Up: Creating a Side-scrolling Shooter*, the ship had animation, but always
    faced to the right. In this chapter, we are going to have a character that can
    move in four directions and have an animated sprite for each direction. We will
    also implement a melee attack that can be used in the direction the character
    is facing.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的玩家对象非常基本。在[第1章](ch01.html "第1章。与您的第一个游戏一起了解Studio")中，*与您的第一个游戏一起了解Studio*，玩家没有动画。在[第3章](ch03.html
    "第3章。射击游戏：创建一个横向卷轴射击游戏")中，*射击游戏：创建一个横向卷轴射击游戏*，飞船有动画，但始终面向右侧。在本章中，我们将拥有一个可以朝四个方向移动并具有每个方向的动画精灵的角色。我们还将实现一个近战攻击，可以在角色面对的方向上使用。
- en: Simplifying the character movement
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化角色移动
- en: There are four separate sprites necessary for the player character's walk cycle.
    We will walk through the first one and then you can create the other three.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色的行走循环需要四个单独的精灵。我们将先介绍第一个，然后您可以创建其他三个。
- en: Let's start by creating a new project called `Chapter_04`.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`Chapter_04`的新项目开始。
- en: Create a Sprite and name it `spr_Player_WalkRight`.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个精灵，命名为`spr_Player_WalkRight`。
- en: Load `Chapter 4/Sprites/ Player_WalkRight.gif` with **Remove Background** checked.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`第4章/精灵/Player_WalkRight.gif`，并勾选**删除背景**。
- en: Set **Origin** to **Center**.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**原点**设置为**中心**。
- en: Click on **Modify Mask** to open the **Mask Properties** editor, and select
    the radio button of **Full image** under **Bounding Box**. The will set the collision
    box to be the entire sprite as shown in the following screenshot:![Simplifying
    the character movement](img/4100OT_04_01.jpg)
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**修改掩码**以打开**掩码属性**编辑器，并在**边界框**下选择**完整图像**的单选按钮。这将设置碰撞框为整个精灵，如下截图所示：![简化角色移动](img/4100OT_04_01.jpg)
- en: Click on **OK**. Repeat this process to load `spr_Player_WalkLeft`, `spr_Player_WalkUp`,
    and `spr_Player_WalkDown`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。重复此过程以加载`spr_Player_WalkLeft`，`spr_Player_WalkUp`和`spr_Player_WalkDown`。
- en: Create an Object, `obj_Player`, and assign `spr_Player_WalkRight` as the Sprite.
    It actually doesn't matter which of the player sprites we set here, as we will
    be using code to change what sprite is being displayed.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象，`obj_Player`，并将`spr_Player_WalkRight`分配为精灵。实际上，在这里设置玩家精灵的哪一个并不重要，因为我们将使用代码来改变显示的精灵。
- en: 'We need to set up some initial variables, so create a new Script, `scr_Player_Create`,
    and write the following code:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置一些初始变量，因此创建一个新脚本，`scr_Player_Create`，并编写以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first two variables are placeholders for the speed and direction of the
    player. This will be useful as we can affect these values without affecting the
    object's local `mySpeed` and `myDirection` variables for things, such as a knockback
    effect in which the object would be facing one direction while moving in the other.
    The variable `isAttacking` will be used to indicate when we have initiated combat,
    and `isWalking` will indicate when the player is moving. Next, we have the global
    variable `health`, which is set to 100 percent. Finally, we set the animation
    speed at 50 percent, so that the walk cycle plays properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个变量是玩家速度和方向的占位符。这将很有用，因为我们可以影响这些值，而不影响对象的本地`mySpeed`和`myDirection`变量，比如在对象面对一个方向移动时产生的击退效果。变量`isAttacking`将用于指示我们何时发起战斗，`isWalking`将指示玩家何时移动。接下来，我们有全局变量`health`，设置为100%。最后，我们将动画速度设置为50%，以便行走循环播放正确。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To know more about GameMaker: Studio''s built-in variables and functions, check
    out the GameMaker User Manual by clicking on **Help** | **Contents**.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '要了解更多关于GameMaker: Studio内置变量和函数的信息，请点击**帮助** | **目录**查看GameMaker用户手册。'
- en: 'Now we can go onto the player movement. Instead of having multiple scripts
    for each key, we are going to simplify the code by placing all the controls into
    a single script. Create a new Script, `scr_Player_Step`, and we will start with
    the following code:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始玩家的移动了。我们不再为每个键创建多个脚本，而是将所有控件放入一个单独的脚本中，简化代码。创建一个新脚本，`scr_Player_Step`，并从以下代码开始：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start by setting `isWalking` to `false`, so that it becomes the default state
    of what the player is doing. After that we are checking whether the keyboard has
    the right arrow key (`vk_right`), currently pressed down, and we check whether
    there is a solid object to the right of the current position. The `place_free`
    function will return whether the specified point is collision free. If the player
    is able to move and the key is pressed, we then move to the right and set the
    direction to zero to indicate right. We change the sprite to the right facing
    walk cycle, and then we change `isWalking` to `true`, which will overwrite the
    first line of code where we set it to `false`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`isWalking`设置为`false`，使其成为玩家正在进行的默认状态。之后，我们检查键盘是否按下右箭头键（`vk_right`），并检查当前位置右侧是否有实体物体。`place_free`函数将返回指定点是否无碰撞。如果玩家能够移动并且按下了键，我们就向右移动，并将方向设置为零以表示向右。我们将精灵更改为面向右侧的行走循环，然后将`isWalking`更改为`true`，这将覆盖我们将其设置为`false`的第一行代码。
- en: Repeat this code for each of the remaining three directions and adjust accordingly.
    Each one should look at what key is being held, and see if there is any collision
    ahead from that position.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这段代码，针对剩下的三个方向进行调整。每个方向都应该查看哪个键被按下，并查看从该位置是否有任何碰撞。
- en: 'We have one more thing to do before the movement controls are complete. If
    the player is not moving, we want the animation to stop and start playing again
    once it starts moving. At the end of the script, add the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移动控件完成之前，我们还有一件事要做。如果玩家没有移动，我们希望动画停止，并在开始移动时重新开始播放。在脚本的末尾，添加以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created the variable `isWalking` to switch between a walking and stopped
    state. If the player is moving, the sprite will animate. If the player isn't moving,
    we stop the animation as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了变量`isWalking`来在行走和停止状态之间切换。如果玩家在移动，精灵将播放动画。如果玩家没有移动，我们也停止动画。
- en: 'The code should look like the following when it is complete:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码完成时，应该如下所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Apply these scripts to the appropriate events, a **Create** event for `scr_Player_Create`,
    and a **Step** event for `scr_Player_Step`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些脚本应用到适当的事件中，`scr_Player_Create`的**创建**事件，以及`scr_Player_Step`的**步进**事件。
- en: The player is ready to move and animate properly, but we won't be able to fully
    test out the code without adding in some solid obstacles. Let's make a wall.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家已经准备好移动和正确播放动画了，但如果没有添加一些实体障碍物，我们将无法完全测试代码。让我们建一堵墙。
- en: Create a new Sprite, `spr_Wall`, load `Chapter 4/Sprites/Wall.png`, and uncheck
    **Remove Background**. We are using a PNG file, as this wall is slightly transparent
    which will be useful later when we decorate the room.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个精灵，`spr_Wall`，加载`第4章/精灵/墙.png`，并取消选中**删除背景**。我们使用PNG文件，因为这堵墙略微透明，这在以后装饰房间时会很有用。
- en: Create a new Object, `obj_Wall`, and set the sprite to `spr_Wall`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Wall`，并将精灵设置为`spr_Wall`。
- en: Check the box for **Solid**. The wall is now identified as being a collidable
    object.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**实体**框。现在这堵墙被标识为可碰撞的对象。
- en: Create a new Room and name it `Sandbox`. We will use this room for testing out
    features.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的房间，命名为`沙盒`。我们将使用这个房间来测试功能。
- en: Place a single instance of `obj_Player` somewhere in the center of the room.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在房间的中心某处放置一个`obj_Player`的实例。
- en: Place instances of `obj_Wall` around the perimeter of the room, and add a few
    extra sections as can be seen in the following screenshot:![Simplifying the character
    movement](img/4100OT_04_02.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在房间的周边放置`obj_Wall`的实例，并添加一些额外的部分，如下屏幕截图所示：![简化角色移动](img/4100OT_04_02.jpg)
- en: Run the game. The player at this point should be able to move around the room
    freely in the open areas, and stop when they collide with a wall.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。此时玩家应该能够在开放区域自由移动，并在与墙碰撞时停止。
- en: Implementing a melee attack
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施近战攻击
- en: Now that we have the player movement functioning we can move onto the attack.
    The attack we are creating needs to only affect objects in front of the player
    character. To achieve this we will create a melee attack object that will spawn
    on command and remove itself from the game on its own.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让玩家移动正常了，我们可以开始进行攻击了。我们正在创建的攻击只需要影响玩家角色前面的物体。为了实现这一点，我们将创建一个近战攻击对象，它将在命令下生成并在游戏中自行移除。
- en: Create a Sprite, `spr_Player_Attack`, and load `Chapter 4/Sprites/Player_Attack.gif`
    with **Remove Background** checked. This is an animated Sprite that will represent
    a swinging melee attack.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个精灵，`spr_Player_Attack`，加载`第4章/精灵/Player_Attack.gif`，并选中**删除背景**。这是一个动画精灵，代表挥动的近战攻击。
- en: We want the collision area to affect the entire height of the sprite, but not
    the entire width. Click on **Modify Mask** and in the **Mask Properties** editor,
    select the radio button for **Manual** under **Bounding Box**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望碰撞区域影响精灵的整个高度，但不影响整个宽度。点击**修改掩码**，在**掩码属性**编辑器中，选择**边界框**下的**手动**单选按钮。
- en: 'Adjust the **Bounding Box** values for **Left**: `0`, **Right**: `24`, **Top**:
    `0` and **Bottom**: `4`. The end result should look like the following screenshot.
    Click on **OK**.![Implementing a melee attack](img/4100OT_04_03.jpg)'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整**边界框**的值为**左**：`0`，**右**：`24`，**顶部**：`0`和**底部**：`4`。最终结果应该看起来像以下的屏幕截图。点击**确定**。![实施近战攻击](img/4100OT_04_03.jpg)
- en: We want this object to always spawn in front of the player. One of the easiest
    ways to ensure this is to have this object rotate along with the player. To achieve
    this, set **Origin** to **X:** `-16` **Y:** `24`. Setting the X coordinate off
    to the left means that this object will have a 16 pixel offset when spawned. We
    can then rotate the attack to match the player's direction.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个对象始终出现在玩家的前面。确保这一点的最简单方法之一是让这个对象随着玩家一起旋转。为了实现这一点，将**原点**设置为**X:** `-16`
    **Y:** `24`。将X坐标设置为左侧意味着这个对象在生成时将有16像素的偏移。然后我们可以旋转攻击以匹配玩家的方向。
- en: Create an Object, `obj_Player_Attack`, and assign `spr_Player Attack` as its
    Sprite.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象，`obj_Player_Attack`，并将`spr_Player Attack`分配为其精灵。
- en: Set **Depth** to `-100`. **Depth** determines whether an instance of an object
    is drawn on-screen behind or above another object. Setting it to a negative value
    means that it will draw on top of any object with a higher depth value. Setting
    the value to `-100` allows us to have other objects with depths between the default
    `0` and `-99` without needing to worry about readjusting things later.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**深度**设置为`-100`。**深度**决定了一个对象实例在屏幕上是在另一个对象的后面还是上面。将其设置为负值意味着它将在具有更高深度值的任何对象上绘制。将值设置为`-100`允许我们在默认的`0`和`-99`之间拥有其他深度的对象，而无需担心以后需要重新调整事物。
- en: 'Create a new Script, `scr_Player_Attack_Create` with the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Player_Attack_Create`，其中包含以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here is where we rotate the image to face the same direction as the player,
    which with the offset origin we set means it will be in front of the player. We
    also slow the animation speed down and set an alarm for six frames. This alarm
    will remove the attack object when it goes off. Finally we tell the player that
    it is attacking.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将图像旋转到与玩家面向相同方向的地方，结合我们设置的偏移原点，这意味着它将出现在玩家的前面。我们还会减慢动画速度，并设置一个六帧的警报。这个警报将在触发时移除攻击对象。最后，我们告诉玩家正在进行攻击。
- en: Add a **Create** event in `obj_Player_Attack` and attach this script.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player_Attack`中添加一个**创建**事件，并附上这个脚本。
- en: 'Let''s move onto the alarm script, `scr_Player_Attack_Alarm`. It will not only
    need to remove the attack, but it also needs to let the player know that it is
    gone and that they can attack once again. We only need two lines of code to do
    all this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续进行警报脚本，`scr_Player_Attack_Alarm`。它不仅需要移除攻击，还需要让玩家知道它已经消失，他们可以再次进行攻击。我们只需要两行代码就可以做到这一切：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can talk directly to the player's `isAttacking` variable and set it back
    to `false`. Then we destroy the instance of the melee attack. Attach this script
    to an **Alarm 0** event.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接与玩家的`isAttacking`变量交谈，并将其设置回`false`。然后我们销毁近战攻击的实例。将这个脚本附加到**Alarm 0**事件。
- en: 'All we need to do now is to get the player to spawn an instance of the attack.
    Reopen `scr_Player_Step` and at the bottom, add the following code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要让玩家生成一个攻击的实例。重新打开`scr_Player_Step`，在底部添加以下代码：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `keyboard_check_pressed` function only activates on the actual pressing
    down action of a key, as opposed to being in the down position, and in this case,
    we are checking for the *Z* key. There are no special commands for the various
    letters on the keyboard, so we need to use the `ord` function that returns the
    corresponding ASCII code for the character it has been passed. We also check to
    see if the player is currently not attacking already. If that is all true, we
    spawn the attack, and that attack will change the `isAttacking` variable to true,
    so that this only happens once.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyboard_check_pressed`函数只在按下键时激活，而不是在按下位置，而在这种情况下，我们正在检查*Z*键。键盘上的各种字母没有特殊命令，因此我们需要使用`ord`函数，它返回传递给它的字符的相应ASCII代码。我们还检查玩家当前是否没有进行攻击。如果一切顺利，我们生成攻击，攻击将改变`isAttacking`变量为true，这样就只会发生一次。'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `ord` function, always use capital letters, or it may give the
    wrong number!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ord`函数时，始终使用大写字母，否则可能会得到错误的数字！
- en: Run the game. You should be able to tap the *Z* key and see the distinctive
    swinging motion in front of the player no matter which way the character is facing
    as shown in the following screenshot. The player is now ready for battle!![Implementing
    a melee attack](img/4100OT_04_04.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。你应该能够按下*Z*键，无论角色面向哪个方向，都能看到玩家面前独特的挥动动作，如下截图所示。玩家现在已经准备好战斗了！[实施近战攻击](img/4100OT_04_04.jpg)
- en: Navigating between rooms
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在房间之间导航
- en: An adventure game would be quite boring if everything took place in one incredibly
    large room. Not only is it not very efficient, but the world will also lack the
    feeling of exploration. Switching from one room to another is easy to do, but
    it does pose a problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切都发生在一个非常大的房间里，冒险游戏会变得相当无聊。这不仅效率低下，而且世界也会缺乏探索的感觉。从一个房间切换到另一个房间很容易，但确实会带来问题。
- en: The first issue is retaining the player stats, such as health, from one room
    to the next. One solution to this is to activate **persistence** on the player.
    Persistence means that we only need to place a single instance of an object in
    a room, and from that point onwards it will remain in the game world.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是保留玩家的统计数据，比如健康，从一个房间到另一个房间。解决这个问题的一个方法是在玩家身上激活**持久性**。持久性意味着我们只需要在一个房间放置一个对象的单个实例，从那时起它将一直存在于游戏世界中。
- en: The second issue is where to place the player in a room with multiple entry
    points. If the player isn't persistent, we can place the player in the room, but
    it would always start in the same spot. If the player is persistent, then when
    they change rooms they will remain at the exact same coordinates they were at
    in the previous room. This means we are going to need to relocate the player to
    a position of our choice in each room.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是在一个有多个入口点的房间中放置玩家。如果玩家不是持久的，我们可以将玩家放在房间里，但它总是从同一个地方开始。如果玩家是持久的，那么当他们切换房间时，他们将保持在上一个房间中的完全相同的坐标。这意味着我们需要将玩家重新定位到每个房间中我们选择的位置。
- en: This could end up being a lot of work if your game is going to have a lot of
    rooms. There is a simple way to solve this by creating self-aware teleporters
    and the use of room creation code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的游戏将有很多房间，这可能会成为很多工作。通过创建自我感知的传送门和使用房间创建代码，有一种简单的解决方法。
- en: Setting up the rooms
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置房间
- en: Let's start by building a few rooms, starting with a title screen.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一些房间开始，首先是标题屏幕。
- en: Create a new Room and in the **Settings**, name it `TitleScreen`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新房间，在**设置**中命名为`TitleScreen`。
- en: Create a new Background, `bg_Title`, and load `Chapter 4/Backgrounds/Title.png`
    with **Remove Background** left unchecked.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的背景，`bg_Title`，并加载`Chapter 4/Backgrounds/Title.png`，不勾选**Remove Background**。
- en: In the **Backgrounds** tab of `TitleScreen`, apply `bg_Title` as **Background
    0** and check **Visible at Start**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TitleScreen`的**Backgrounds**选项卡中，将`bg_Title`应用为**Background 0**，并勾选**Visible
    at Start**。
- en: Create another Room and name it `C04_R01`. The names here represent the chapter
    and the room, as in Chapter 4, Room 1.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个房间，命名为`C04_R01`。这里的名称代表章节和房间，如第4章，第1房间。
- en: Set **Width** and **Height** to `1024`. This will allow us to have lots of space
    to explore.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Width**和**Height**设置为`1024`。这将允许我们有很多探索空间。
- en: We don't want to see everything in the room all at once, therefore we need to
    constrain the view. Click on the **Views** tab and check the box for **Enable
    the Use of Views**. Select **View 0** and check the box for **Visible when room
    starts**. This will activate the camera system for the room.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望一次看到房间中的所有东西，因此我们需要限制视图。点击**Views**选项卡，勾选**Enable the Use of Views**。选择**View
    0**，并勾选**Visible when room starts**。这将激活房间的摄像机系统。
- en: We will also want the view to focus on the player and move with it. Still in
    the **Views** tab, select `obj_Player` under **Object following** and set **Vbor:**
    and **Hbor:** to `200`. This will make the camera follow the player and leave
    a buffer of 200 pixels around the edges of the view. Look at the following screenshot
    to ensure you have everything set up correctly:![Setting up the rooms](img/4100OT_04_06.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望视图关注玩家并随之移动。在**Views**选项卡中，选择**Object following**下的`obj_Player`，并将**Vbor:**和**Hbor:**设置为`200`。这将使摄像机跟随玩家，并在视图边缘留下200像素的缓冲区。查看以下截图，确保一切设置正确：![设置房间](img/4100OT_04_06.jpg)
- en: Create two more rooms `C04_R02`, and `C04_R03` with the same settings we just
    used with `C04_R01`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用刚才与`C04_R01`相同的设置，创建另外两个房间`C04_R02`和`C04_R03`。
- en: In the Resource tree, reorder the room by dragging `Sandbox` down to the bottom
    and `TitleScreen` to the very top. It should look like the following screenshot:![Setting
    up the rooms](img/4100OT_04_05.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源树中，通过将`Sandbox`拖动到底部和`TitleScreen`拖动到最顶部来重新排序房间。它应该看起来像以下截图：![设置房间](img/4100OT_04_05.jpg)
- en: Finally with all three rooms, create a labyrinth using the wall objects. The
    design isn't important at the moment; just make sure that the player would be
    able to get from one side to the other. An example of what it could look like
    can be seen in the following screenshot:![Setting up the rooms](img/4100OT_04_07.jpg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用墙对象创建一个迷宫，包括所有三个房间。设计目前并不重要；只需确保玩家能够从一边到达另一边。可以在以下截图中看到它可能的样子：![设置房间](img/4100OT_04_07.jpg)
- en: Creating Room Portals
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建房间传送门
- en: In order to change rooms we are going to create reusable Portals. Each portal
    actually consists of two separate objects, a **Start** object and an **Exit**
    object. The Start object will represent the landing pad for where the player should
    be placed when they enter a room. The Exit object is the teleporter that changes
    what room the player is in. We will utilize four unique portals which will allow
    us to have one door on each side of the map if we want.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变房间，我们将创建可重复使用的传送门。每个传送门实际上由两个单独的对象组成，一个是**Start**对象，一个是**Exit**对象。**Start**对象将代表玩家进入房间时应该放置的着陆点。**Exit**对象是改变玩家所在房间的传送器。我们将利用四个独特的传送门，这将允许我们在地图的每一侧都有一个门。
- en: 'For the room teleportation system to work we are going to need to use some
    global variables, which need to be initialized at the start of the game. Create
    a new Script, `scr_Globals_StartGame`, with the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使房间传送系统工作，我们需要使用一些全局变量，这些变量需要在游戏开始时初始化。创建一个新脚本，`scr_Globals_StartGame`，并使用以下代码：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We create global variables for the four portals and give them a zero value to
    start. We also keep track of the last room we were in, so that we know what portal
    we need to go to in the new room.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为四个传送门创建全局变量，并给它们一个零值。我们还跟踪我们上次所在的房间，这样我们就知道我们需要去新房间的哪个传送门。
- en: Create a new Object, `obj_Globals`, add a **Game Start** event, and attach this
    script. This object does not need a sprite, as it is a data object only.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Globals`，添加一个**Game Start**事件，并附加此脚本。这个对象不需要精灵，因为它只是一个数据对象。
- en: Place a single instance of `obj_Globals` into `TitleScreen`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`obj_Globals`的实例放入`TitleScreen`。
- en: 'We need to be able to enter the game from the title screen, so let''s create
    a quick fix by adding a **Draw** event and creating a new Script, `scr_Globals_Draw`,
    and with this code add the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要能够从标题屏幕进入游戏，因此让我们通过添加**Draw**事件并创建一个新脚本`scr_Globals_Draw`来快速修复，并使用以下代码添加以下内容：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we are just writing some white, centered text letting the player know how
    they can start the game. We use the special variable `vk_anykey` to see if the
    keyboard has been pressed, and if it has, we go to the next room as ordered in
    the Resource tree.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是编写一些白色的居中文本，让玩家知道他们如何开始游戏。我们使用特殊变量`vk_anykey`来查看键盘是否被按下，如果按下了，我们就按照资源树中的顺序进入下一个房间。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You don't always have to close your scripts, as the game will run even if multiple
    script windows are open.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必总是关闭脚本，因为即使打开多个脚本窗口，游戏也会运行。
- en: Let's make some portals! Create a new Sprite, `spr_Portal_A_Start`, load `Chapter
    4/Sprites/Portal_A_Start.png`, and uncheck **Remove Background**. Center the origin
    and then click on **OK**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们制作一些传送门！创建一个新精灵，`spr_Portal_A_Start`，加载`Chapter 4/Sprites/Portal_A_Start.png`，并取消勾选**Remove
    Background**。居中原点，然后点击**OK**。
- en: Create a new Object, `obj_Portal_A_Start`, set the Sprite to `spr_Portal_A_Start`.
    This is the landing pad that we will move the player to when they enter into a
    room. It does not need any code, so click on **OK**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Portal_A_Start`，将精灵设置为`spr_Portal_A_Start`。这是我们将玩家移动到的着陆点，当他们进入房间时。它不需要任何代码，所以点击**确定**。
- en: Create a new Sprite, `spr_Portal_A_Exit`, and load `Chapter 4/Sprites/Portal_A_Exit.png`,
    with **Remove Background** unchecked and the origin centered.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，`spr_Portal_A_Exit`，并加载`Chapter 4/Sprites/Portal_A_Exit.png`，取消**删除背景**，并将原点居中。
- en: Create a new Object, `obj_Portal_A_Exit`, and set the Sprite accordingly. This
    is the actual teleporter and we will change rooms upon collision with the player.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Portal_A_Exit`，并相应地设置精灵。这是实际的传送门，当玩家与之碰撞时，我们将改变房间。
- en: 'For an `obj_Player` event, create a new Script, `scr_Portal_A_Exit_Collision`,
    and write the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`obj_Player`事件，创建一个新的脚本，`scr_Portal_A_Exit_Collision`，并编写以下代码：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we can teleport we need to set the last room to the room the player is
    currently in. To do this we use the built-in variable `room`, which stores the
    index number of the room the game is currently displaying. After that we go to
    the room that this portal's global variable indicates we should go to.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以传送之前，我们需要将上一个房间设置为玩家当前所在的房间。为此，我们使用内置变量`room`，它存储游戏当前显示的房间的索引号。之后，我们去到这个传送门的全局变量指示我们应该去的房间。
- en: Repeat steps 5 to 9 for portals B, C, and D making sure to change all the appropriate
    values to reflect the proper portal name.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤5到9，为传送门B、C和D做同样的操作，确保更改所有适当的值以反映正确的传送门名称。
- en: The portals are complete and we can add them into the rooms. It is not necessary
    to utilize all four portals in every room; you just need a minimum of one Start
    and one Exit. When placing these objects in the room, it is important that there
    be only one of the same type of portal used. The Start portal should always be
    placed in the playable area and ensure that the Exit can only be accessed from
    one direction. You should also make sure that if one room has **PORTAL A** at
    the bottom, the room it is to enter should have the **PORTAL A** on top, as can
    be seen in the following screenshot. This will help the player understand where
    they are in the world.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 传送门已经完成，我们可以将它们添加到房间中。在每个房间中不必使用所有四个传送门；您只需要至少一个起点和一个终点。在放置这些对象时，重要的是同一类型的传送门只能有一个。起点传送门应始终放置在可玩区域，并确保只能从一个方向访问终点。您还应确保，如果一个房间的**PORTAL
    A**在底部，那么它要进入的房间应该在顶部有**PORTAL A**，如下面的截图所示。这将帮助玩家理解他们在世界中的位置。
- en: '![Creating Room Portals](img/4100OT_04_08.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![创建房间传送门](img/4100OT_04_08.jpg)'
- en: Now comes the interesting part. We need to change the global portal values in
    each room and we don't want to have a massive script that checks all rooms to
    see what is happening. Instead, we can use **Creation Code** in the rooms themselves
    to change these values upon the player entering. Let's try this out by making
    Portal A in `C04_R01` go to `C04_R02` and vice-versa.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。我们需要在每个房间中更改全局传送门数值，我们不想有一个检查所有房间发生情况的大型脚本。相反，我们可以在房间本身使用**创建代码**来在玩家进入时更改这些值。让我们尝试一下，通过使`C04_R01`中的传送门A去到`C04_R02`，反之亦然。
- en: 'In the `C04_R01` **Settings** tab, click on **Creation Code** to open a code
    editor and write the following code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`C04_R01`的**设置**选项卡中，单击**创建代码**以打开代码编辑器，并编写以下代码：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We set **PORTAL A** to be the second room. All the other portals are not being
    used, so we set the variables to zero. Every room needs to have all of these variables
    set to some value, either a specific room or zero, otherwise it can cause errors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将**PORTAL A**设置为第二个房间。所有其他传送门都没有被使用，所以我们将变量设置为零。每个房间都需要将所有这些变量设置为某个值，要么是特定的房间，要么是零，否则可能会导致错误。
- en: 'In the `C04_R02` **Settings** tab, click on **Creation Code** to open a code
    editor and write the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`C04_R02`的**设置**选项卡中，单击**创建代码**以打开代码编辑器，并编写以下代码：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we have set PORTAL A to the first room, which makes sense. If we go through
    that portal, we should be able to go back through it. Feel free to change these
    settings to apply to all the portals you want.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将PORTAL A设置为第一个房间，这是有道理的。如果我们通过那个传送门，我们应该能够再次通过它回去。随意更改这些设置，以适用于您想要的所有传送门。
- en: Teleporting a persistent player
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传送持久玩家
- en: The rooms have all been built and are ready to go. All that is left for us is
    to have the player move from room to room. Let's start by making the player persistent,
    so that we only need one in the game.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 房间都已经建好，准备就绪。我们唯一需要做的就是让玩家从一个房间移动到另一个房间。让我们首先使玩家持久，这样我们在游戏中只需要一个玩家。
- en: Open `obj_Player` and check **Persistent**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`obj_Player`并勾选**持久**。
- en: Next, we need to relocate the player to the proper portal. We will create a
    new Script, `scr_Player_RoomStart`, with this code on a **Room Start** event for
    `obj_Player`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将玩家重新定位到正确的传送门。我们将创建一个新的脚本，`scr_Player_RoomStart`，并在`obj_Player`的**房间开始**事件中使用以下代码。
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the player enters a room we check to see which portal is associated with
    the room the player just exited from. We then move the player to the appropriate
    landing pad. To make sure the player is built correctly, its properties should
    look like the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入一个房间时，我们检查玩家刚刚离开的房间与哪个传送门相关联。然后将玩家移动到适当的着陆点。为了确保玩家被正确构建，其属性应如下截图所示：
- en: '![Teleporting a persistent player](img/4100OT_04_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![传送持久玩家](img/4100OT_04_09.jpg)'
- en: Place an instance of the player into `C04_R01`. Do not put the player into any
    other room or you will end up with multiple instances of the player in the game.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将玩家实例放入`C04_R01`。不要将玩家放入其他任何房间，否则游戏中将会出现多个玩家实例。
- en: Run the game. We should be able to move around the first room and go through
    PORTAL A, which will take us to the PORTAL A landing pad in the second room. With
    this system, a game could have hundreds of rooms and there only ever needs to
    be four portals to manage.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。我们应该能够在第一个房间四处移动，并通过A门，这将把我们带到第二个房间的A门着陆点。有了这个系统，一个游戏可以有数百个房间，只需要四个传送门来管理。
- en: Bringing enemies to life
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给敌人生命
- en: Enemies are more than just obstacles to be avoided. Good enemies give the player
    a sense that there is some underlying **artificial intelligence** (**AI**). The
    enemies seem to know when you are near, can chase you around walls, and wander
    on their own. In this chapter we will create three creatures that will inhabit
    the world, each with their own unique AI.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人不仅仅是要避免的障碍物。好的敌人让玩家感到有一些潜在的**人工智能**（**AI**）。敌人似乎知道你何时靠近，可以在墙上追逐你，并且可以自行徘徊。在本章中，我们将创建三种生物，它们将在世界中生存，每种都有自己独特的AI。
- en: Summoning the Ghost Librarian
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 召唤幽灵图书管理员
- en: 'The first creature will consist of two parts: the overdue BookPile and the
    Ghost Librarian that protects it. If the player approaches a BookPile, a Ghost
    will spawn and chase the player. If the player gets too far away from the Ghost,
    the Ghost will return to the BookPile that spawned it. If the player attacks the
    Ghost, it will disappear and respawn from the BookPile. If the player destroys
    the BookPile, the Ghost it spawned will be destroyed as well.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个生物将由两部分组成：过期的BookPile和保护它的幽灵图书管理员。如果玩家靠近一个BookPile，幽灵将生成并追逐玩家。如果玩家离幽灵太远，幽灵将返回生成它的BookPile。如果玩家攻击幽灵，它将消失并从BookPile重新生成。如果玩家摧毁BookPile，生成的幽灵也将被摧毁。
- en: Let's start with the BookPile. Create a new Sprite, `spr_BookPile`, and load
    `Chapter 4/Sprites/BookPile.gif` with **Remove Background** checked.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从BookPile开始。创建一个新的精灵，`spr_BookPile`，并加载`Chapter 4/Sprites/BookPile.gif`，勾选**删除背景**。
- en: Center the origin and click on **OK**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点居中，然后点击**确定**。
- en: We will also want a scary noise to alert the player of the danger. Create a
    new Sound, `snd_GhostMoan`, and load `Chapter 4/Sounds/GhostMoan.wav`. Click on
    **OK**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个可怕的声音来警告玩家危险。创建一个新的声音，`snd_GhostMoan`，并加载`Chapter 4/Sounds/GhostMoan.wav`。点击**确定**。
- en: Create a new Object, `obj_BookPile`, and assign `spr_BookPile` as the Sprite.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_BookPile`，并分配`spr_BookPile`作为精灵。
- en: We don't want the player to be able to walk through the BookPile, so check the
    box for **Solid**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望玩家能够穿过BookPile，所以勾选**固体**。
- en: 'We will need to initialize some variables, so create a new Script, `scr_BookPile_Create`,
    and write the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要初始化一些变量，所以创建一个新的脚本，`scr_BookPile_Create`，并编写以下代码：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first variable sets the value for how close the player needs to be to become
    active and the second variable is Boolean that will determine if this BookPile
    has spawned a Ghost or not.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量设置玩家需要多接近才能变得活跃，第二个变量是布尔值，将确定这个BookPile是否生成了幽灵。
- en: Add a **Create** event and apply this script.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**创建**事件并应用此脚本。
- en: 'Next we need a new Script, `scr_BookPile_Step`, which will be applied to a
    **Step** event and contain the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要一个新的脚本，`scr_BookPile_Step`，它将应用于**步骤**事件，并包含以下代码：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first line of the code is incredibly important. Here we are checking to
    see if the player exists before we do anything else. If the player does exist,
    we check if the distance to the player object is within the range, and whether
    this BookPile has spawned a Ghost yet. If the player is within range and hasn't
    spawned anything, we spawn a Ghost. We will also send the unique ID of this BookPile,
    using the `self` variable, into the ghost so it knows where it came from. Next
    we play the Ghost moaning sound, making sure that it does not loop. Finally, we
    indicate that we have spawned a Ghost by changing the `hasSpawned` variable to
    `true`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行非常重要。在这里，我们首先检查玩家是否存在，然后再进行其他操作。如果玩家存在，我们检查玩家对象的距离是否在范围内，以及这个BookPile是否已经生成了幽灵。如果玩家在范围内并且还没有生成任何东西，我们就生成一个幽灵。我们还会将这个BookPile的唯一ID使用`self`变量发送到幽灵中，这样它就知道自己来自哪里。接下来播放幽灵的呻吟声音，确保不要循环播放。最后，我们通过将`hasSpawned`变量更改为`true`来指示我们已经生成了一个幽灵。
- en: 'The only element remaining is to add an `obj_Player_Attack` event with a new
    Script, `scr_BookPile_Collision`, and write the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一剩下的元素是添加一个`obj_Player_Attack`事件，使用一个新的脚本，`scr_BookPile_Collision`，并编写以下代码：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once again, we start by checking to see if a Ghost has spawned from this BookPile
    and is still in existence. If it is, we destroy that Ghost and then remove the
    BookPile itself. The BookPile is now complete and should look like the following
    screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先检查是否有幽灵从这个BookPile生成并且仍然存在。如果是，我们销毁那个幽灵，然后移除BookPile本身。BookPile现在已经完成，应该看起来像以下截图：
- en: '![Summoning the Ghost Librarian](img/4100OT_04_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![召唤幽灵图书管理员](img/4100OT_04_10.jpg)'
- en: Now we need to build the Ghost. For this we will need to bring in two sprites,
    one for the spawning and one for the chase. Create sprites with **Remove Background**
    checked for `spr_Ghost` and `spr_Ghost_Spawn`, and load `Chapter 4/Sprites/Ghost.gif`
    and `Chapter 4/Sprites/Ghost_spawn.gif`, respectively.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要构建幽灵。为此，我们需要引入两个精灵，一个用于生成，一个用于追逐。创建精灵时勾选**删除背景**，分别为`spr_Ghost`和`spr_Ghost_Spawn`，并加载`Chapter
    4/Sprites/Ghost.gif`和`Chapter 4/Sprites/Ghost_spawn.gif`。
- en: In both the sprites, center the origin.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个精灵中，将原点居中。
- en: Set the **Depth:** field to `-50` so that the ghost will appear over most objects,
    but below the player attack object. There is nothing else we need to do, so click
    on **OK**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**深度：**字段设置为`-50`，这样幽灵将出现在大多数物体上方，但在玩家攻击物体下方。没有其他需要做的事情，所以点击**确定**。
- en: Create a new Object, `obj_Ghost`, and apply `spr_Ghost_Spawn` as the Sprite.
    This will make the spawn animation the initial sprite, and then we will change
    it to the regular Ghost through code.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Ghost`，并应用`spr_Ghost_Spawn`作为精灵。这将使生成动画成为初始精灵，然后我们将通过代码将其更改为常规幽灵。
- en: 'We have several variables that we need to initialize in a new Script, `scr_Ghost_Create`,
    as seen in the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有几个变量需要在一个新的脚本`scr_Ghost_Create`中初始化，如下所示的代码：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We set variables for the movement speed, the range the Ghost will track within,
    who spawned the Ghost, (which we will change through the BookPile),and one for
    whether the Ghost has returned to the BookPile. Notice that the range of the Ghost
    is larger than the range of the BookPile. This will ensure that the Ghost starts
    chasing the player immediately. We then set the animation speed and set an alarm
    for six steps which we will use to change sprites.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了移动速度的变量，幽灵将在其中追踪的范围，生成幽灵的人（我们将通过书堆改变），以及幽灵是否已经返回到书堆的变量。请注意，幽灵的范围比书堆的范围大。这将确保幽灵立即开始追逐玩家。然后我们设置了动画速度，并设置了一个六步的警报，我们将用它来改变精灵。
- en: 'Add an **Alarm0** event and then apply a new script, `scr_Ghost_Alarm0`, that
    has the following line of code to change sprites:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Alarm0**事件，然后应用一个新的脚本，`scr_Ghost_Alarm0`，其中包含以下代码来改变精灵：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are now ready to start implementing some artificial intelligence. The Ghost
    is going to be the most basic enemy that will chase the player through the room,
    including passing through walls and other enemies, until the player gets out of
    range. At that point the Ghost will float back to the BookPile it came from.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始实现一些人工智能。幽灵将是最基本的敌人，会追逐玩家穿过房间，包括穿过墙壁和其他敌人，直到玩家超出范围。在那时，幽灵将漂浮回到它来自的书堆。
- en: 'We will start with chasing the player. Create a new script, `scr_Ghost_Step`,
    and write the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从追逐玩家开始。创建一个新的脚本，`scr_Ghost_Step`，并编写以下代码：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After checking to ensure that the player is alive, we create a variable that
    will hold the distance from the Ghost to the player. The reason we have created
    a `targetDist` variable is that we will be needing this information a few times
    and this will save us from having to recheck the distance each time we have an
    `if` statement. We then compare the distance to the chase range and if the player
    is within range, we move towards the player. The `move_towards_point` function
    calculates the direction and applies a velocity to the object in that direction.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保玩家还活着之后，我们创建一个变量来保存幽灵到玩家的距离。我们创建`targetDist`变量的原因是我们将需要这个信息几次，这样可以避免每次有`if`语句时都重新检查距离。然后我们比较距离和追逐范围，如果玩家在范围内，我们就朝着玩家移动。`move_towards_point`函数会计算方向并将速度应用到该方向的对象上。
- en: Add a **Step** event and apply this script. We will be continuing to add code
    to this script, but it will function properly already.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Step**事件并应用这个脚本。我们将继续向这个脚本添加代码，但它已经可以正常运行了。
- en: Let's take a moment to test everything we have done so far. First, in the Resource
    tree, move `Sandbox` up to the near top, so that it is the room immediately after
    the title screen. Open the `Sandbox` room and place a couple of instances of `obj_BookPile`
    around the edges as shown in the following screenshot:![Summoning the Ghost Librarian](img/4100OT_04_11.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们花一点时间来测试我们到目前为止所做的一切。首先，在资源树中，将`Sandbox`移到接近顶部，这样它就是标题屏幕后的房间。打开`Sandbox`房间，并像以下截图所示，在边缘放置几个`obj_BookPile`的实例：![召唤幽灵图书管理员](img/4100OT_04_11.jpg)
- en: Run the game. If you get too close to a BookPile, a single Ghost will spawn
    from it and it will slowly chase the player. If the player gets too far away from
    the Ghost, the Ghost will continue moving in the direction it was last heading
    in and will eventually go offscreen.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。如果你离书堆太近，一个幽灵会从中产生，并慢慢追逐玩家。如果玩家离幽灵太远，幽灵将继续朝着它最后的方向移动，并最终消失在屏幕外。
- en: 'Let''s get the Ghost to return to its BookPile. In `scr_Ghost_Step`, within
    the braces for the player existence check, add the following code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让幽灵返回到它的书堆。在`scr_Ghost_Step`中，添加以下代码到玩家存在检查的大括号内：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First we check to see if the player is out of range and that the Ghost isn't
    near its own BookPile. Here we are using `distance_to_point`, so that we are checking
    the origin of the BookPile rather than the edges of the collision area that `distance_to_object`
    would look for. If this is all true, the Ghost will start moving back to its BookPile.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们检查玩家是否超出范围，而幽灵又不靠近自己的书堆。在这里，我们使用`distance_to_point`，这样我们就是检查书堆的原点而不是`distance_to_object`会寻找的碰撞区域的边缘。如果这一切都是真的，幽灵将开始向它的书堆移动。
- en: Let's run the game again. As before, the Ghost will chase the player, and if
    the player gets too far away, the Ghost will return to its BookPile.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行游戏。和以前一样，幽灵会追逐玩家，如果玩家离得太远，幽灵将返回到它的书堆。
- en: 'There is an issue with the fact that the Ghost ends up ping-ponging over the
    top of the BookPile. This is due to the Ghost having velocity-based speed and
    not having any code telling it to stop. We can fix this by adding this code after
    the last `else if` statement:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幽灵最终会在书堆的顶部来回移动，这是一个问题。这是因为幽灵具有基于速度的速度，并且没有任何代码告诉它停下来。我们可以通过在最后的`else if`语句后添加以下代码来解决这个问题：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we have a final `else` statement that will execute if the player is out
    of range and the Ghost is near its BookPile. We start by stopping the speed of
    the Ghost. Then we check to see if it can dissolve. If so, we tell the BookPile
    that the Ghost can be spawned again, we change the sprite back to the spawn animation,
    and by setting the `image_speed` to `-1` it will play that animation in reverse.
    We also set another alarm, so that we can remove the Ghost from the world and
    deactivate the dissolve check.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个最终的`else`语句，如果玩家超出范围，幽灵靠近它的书堆，将执行。我们首先停止幽灵的速度。然后我们检查它是否可以溶解。如果可以，我们告诉书堆可以再次生成幽灵，我们将精灵改回生成动画，并通过将`image_speed`设置为`-1`来以相反的方式播放该动画。我们还设置了另一个警报，这样我们就可以将幽灵从世界中移除并停用溶解检查。
- en: 'Altogether the entire `scr_Ghost_Step` should look like the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`scr_Ghost_Step`应该如下所示的代码：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'One last Script is needed, `scr_Ghost_Alarm1`, that is attached to an **Alarm
    1** event and has one line of code to remove the instance:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一个最后的脚本，`scr_Ghost_Alarm1`，它附加在**Alarm 1**事件上，并有一行代码来移除实例：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Ghost is almost complete. It spawns, chases the player, and returns to its
    BookPile, but what happens if it catches the player? With this Ghost we will want
    it to smash into the player, cause some damage, and then vanish in a puff of smoke.
    For this we will need to create a new asset for the dead Ghost.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 幽灵几乎完成了。它生成，追逐玩家，然后返回到它的BookPile，但是如果它抓住了玩家会发生什么？对于这个幽灵，我们希望它撞到玩家，造成一些伤害，然后在一团烟雾中消失。为此，我们需要为死去的幽灵创建一个新的资源。
- en: Create a new Sprite, `spr_Ghost_Dead`, and load `Chapter 4/Sprites/Ghost_Dead.gif`
    with **Remove Background** checked.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新精灵`spr_Ghost_Dead`，并加载`Chapter 4/Sprites/Ghost_Dead.gif`，勾选**删除背景**。
- en: Center the origin and click on **OK**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 居中原点，然后点击**确定**。
- en: Create a new Object, `obj_Ghost_Dead`, and apply the Sprite.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象`obj_Ghost_Dead`，并应用该精灵。
- en: 'In a new Script, `scr_Ghost_Dead_AnimEnd`, write the following line of code
    and attach it to an **Animation End** event:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的脚本`scr_Ghost_Dead_AnimEnd`中，编写以下代码并将其附加到**动画结束**事件上：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The **Animation End** event will execute code when the last image of the Sprite
    is played. In this case, we have a poof of smoke animation that at the end will
    remove the object from the game.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画结束**事件将在播放精灵的最后一帧图像时执行代码。在这种情况下，我们有一个烟雾的动画，在结束时将从游戏中移除对象。'
- en: 'All we need now is to reopen `obj_Ghost` and add an **obj_Player** event with
    a new script, `scr_Ghost_Collision`, with the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要重新打开`obj_Ghost`，并添加一个带有新脚本`scr_Ghost_Collision`的**obj_Player**事件，其中包含以下代码：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We start by removing five points of health, and then telling the Ghost''s BookPile
    that it can be respawned. Next we create the Ghost death object which will hide
    the real Ghost when we remove it from the game. If everything is built correctly,
    it should look like the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先减少五点生命值，然后告诉幽灵的BookPile它可以重新生成。接下来，我们创建幽灵死亡对象，当我们将其从游戏中移除时，它将隐藏真正的幽灵。如果一切构建正确，它应该看起来像以下截图：
- en: '![Summoning the Ghost Librarian](img/4100OT_04_12.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![召唤幽灵图书管理员](img/4100OT_04_12.jpg)'
- en: Run the game. The Ghost should now function exactly as designed. It will spawn
    and chase the player. If it catches the player it will cause damage and disappear.
    If the player gets away, the Ghost will return to its BookPile and dissolve out
    of existence. Great work!
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。现在，幽灵应该能够完全按照设计的方式运行。它会生成并追逐玩家。如果它抓住了玩家，它会造成伤害并消失。如果玩家逃脱，幽灵将返回到它的BookPile并消失。干得好！
- en: One last thing, as the room is meant to be a sandbox for experimenting in and
    not part of the actual game, we should clean up the room to prepare for the next
    enemy.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事，由于房间是用来进行实验而不是实际游戏的一部分，我们应该清理房间，为下一个敌人做准备。
- en: Open the `Sandbox` room and remove all instances of the BookPiles.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Sandbox`房间，并删除所有的BookPiles实例。
- en: Building a wandering Brawl
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个漫游的Brawl
- en: The next enemy we will create is a Brawl that will wander around the room. If
    the player gets too close to this enemy, the Brawl will become enraged by growing
    larger and moving faster, though it won't leave its path. Once the player is out
    of range, it will calm back down and shrink to its original size and speed. The
    player won't be able to kill this enemy, but the Brawl will damage the player
    if there is contact.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的下一个敌人是一个Brawl，它将在房间里漫游。如果玩家离这个敌人太近，Brawl会变得愤怒，变得更大并移动得更快，尽管它不会离开它的路径。一旦玩家离开范围，它会恢复冷静，并缩小到原来的大小和速度。玩家无法杀死这个敌人，但是如果接触到Brawl，它会对玩家造成伤害。
- en: 'For the Brawl, we will be utilizing a path and we will need three sprites:
    one for the normal state, one for the transition of states, and another for the
    enraged state.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Brawl，我们将利用一个路径，并且我们需要三个精灵：一个用于正常状态，一个用于状态转换，另一个用于愤怒状态。
- en: Create a new Sprite, `spr_Brawl_Small`, and load `Chapter 4/Sprites/Brawl_Small.gif`
    with **Remove Background** checked. This is the Sprite for the normal state. Center
    the origin and click on **OK**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新精灵`spr_Brawl_Small`，并加载`Chapter 4/Sprites/Brawl_Small.gif`，勾选**删除背景**。这是正常状态的精灵。居中原点，然后点击**确定**。
- en: Create another new Sprite, `spr_Brawl_Large`, and load `Chapter 4/Sprites/Brawl_Large.gif`
    with **Remove Background** checked. We need to center the origin, so that the
    Brawl will scale properly with this image. The enraged state is twice the size
    of the normal state.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个新的精灵`spr_Brawl_Large`，并加载`Chapter 4/Sprites/Brawl_Large.gif`，勾选**删除背景**。我们需要将原点居中，以便Brawl能够正确缩放这个图像。愤怒状态是正常状态的两倍大小。
- en: We also need to undergo transition between these two states, so let's create
    a new Sprite, `spr_Brawl_Change` and load `Chapter 4/Sprites/Brawl_Change.gif`,
    still with **Remove Background** checked. Don't forget to center the origin.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在这两种状态之间进行转换，因此让我们创建一个新的精灵`spr_Brawl_Change`，并加载`Chapter 4/Sprites/Brawl_Change.gif`，仍然勾选**删除背景**。不要忘记居中原点。
- en: Next we need a path for the Brawl to follow. Create a new Path and name it `pth_Brawl_01`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个Brawl要遵循的路径。创建一个新路径，并命名为`pth_Brawl_01`。
- en: We want the Brawl to move smoothly, so check **Smooth Curve** under **Connection
    Kind** and change the **Precision** to `8`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望Brawl移动起来更加平滑，因此在**连接类型**下勾选**平滑曲线**，并将**精度**更改为`8`。
- en: To see what we can do with paths, let's make the Path in the shape of a figure
    eight as can be seen in the following screenshot:![Building a wandering Brawl](img/4100OT_04_13.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看看我们可以用路径做些什么，让我们制作一个八字形状的路径，如下截图所示：![创建一个漫游的Brawl](img/4100OT_04_13.jpg)
- en: Let's also create a new Sound, `snd_Brawl`, and load `Chapter 4/Sounds/Brawl.wav`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还创建一个新声音`snd_Brawl`，并加载`Chapter 4/Sounds/Brawl.wav`。
- en: Create a new Object, `obj_Brawl`, and apply `spr_Brawl_S` as the default Sprite.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象`obj_Brawl`，并将`spr_Brawl_S`应用为默认精灵。
- en: We'll start with initializing some variables in a Create event script, `scr_Brawl_Create`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从一个创建事件脚本`scr_Brawl_Create`中初始化一些变量。
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first variable sets the base speed of the Brawl. The next three variables
    are checks for the transformation and enraged states, and whether it has attacked.
    Next, we set the animation speed and then we play the Brawl sound, and in this
    case we want the sound to loop. Finally, we set the Brawl onto the path with a
    speed of two; when it hits the end of the path it will loop and most importantly,
    the path is set to absolute, which means it will run based as designed in the
    Path editor.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量设置了Brawl的基本速度。接下来的三个变量是变身和愤怒状态以及是否已攻击的检查。接下来，我们设置了动画速度，然后播放了Brawl声音，在这种情况下，我们希望声音循环。最后，我们将Brawl设置到速度为2的路径上；当它到达路径的尽头时，它将循环，最重要的是，路径设置为绝对，这意味着它将按照路径编辑器中设计的方式运行。
- en: We can now start working on the AI of the Brawl. Create a new script for a **Step**
    event named `scr_Brawl_Step` and we will start by getting the movement working.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始处理Brawl的人工智能。为**Step**事件创建一个名为`scr_Brawl_Step`的新脚本，我们将从使移动工作开始。
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we start by rotating the Sprite itself to face in the proper direction.
    This will work, because we have the Sprite images facing to the right, which is
    the same as zero degrees. Next, we check to see if the Brawl is big or not. If
    the Brawl is the enraged version, we set the path speed to be the base speed times
    two. Otherwise, we set the speed to the default base speed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过旋转Sprite本身来使其面向正确的方向。这将起作用，因为我们的Sprite图像面向右侧，这与零度相同。接下来，我们检查Brawl是否变大。如果Brawl是愤怒版本，我们将路径速度设置为基本速度的两倍。否则，我们将速度设置为默认的基本速度。
- en: Place an instance of the Brawl anywhere in the room and run the game. The Brawl
    should move around the figure eight and properly face in the proper direction.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在房间的任何位置放置一个Brawl实例并运行游戏。Brawl应该围绕数字八移动，并正确面向正确的方向。
- en: 'Next, we will add in the first transformation, becoming enraged. Right after
    the previous line of code, add:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加第一个变身，变得愤怒。在上一行代码之后，添加：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start by making sure the player exists, and then we check to see if the player
    is within range. If the player is in range, we check to see if we have become
    enraged or not. If the Brawl hasn't grown yet, we use the `collision_line` function
    to see if the Brawl can actually see the player or not. This function draws a
    line between two points, in this case the location of the Brawl and the player
    positions, and determines if an instance of an object, or a wall crosses that
    line. If the Brawl can see the player, we change the sprite to the transformation
    sprite, set an alarm so we can finalize the transformation, and indicate that
    the Brawl has grown.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保玩家存在，然后检查玩家是否在范围内。如果玩家在范围内，我们检查自己是否已经愤怒。如果Brawl还没有变大，我们使用`collision_line`函数来查看Brawl是否真的能看到玩家。这个函数在两个点之间绘制一条线，即Brawl和玩家位置，然后确定一个对象实例或墙壁是否穿过了该线。如果Brawl能看到玩家，我们将Sprite更改为变身Sprite，设置一个警报以便我们可以完成变身，并指示Brawl已经变大。
- en: Let's create a script `scr_Brawl_Alarm0` for an **Alarm 0** event with the code
    that will switch to the enraged sprite and indicate that the Brawl is now full
    size.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为**Alarm 0**事件创建一个名为`scr_Brawl_Alarm0`的脚本，其中包含将切换到愤怒的sprite并指示Brawl现在已经完全大小的代码。
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the game to make sure that the code is working. The Brawl should remain
    small until it can clearly see the player, in which case it will then transform
    into the large, enraged Brawl.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏以确保代码正常工作。Brawl应该保持小尺寸，直到能清楚看到玩家，此时它将变换为大型、愤怒的Brawl。
- en: 'We have the Brawl growing larger, now we need to calm it down and have it shrink.
    Back in `scr_Brawl_Step`, add an `else` statement on the distance check, which
    would be before the final brace and add the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Brawl正在变大，现在我们需要让它平静下来并缩小。在`scr_Brawl_Step`中，添加一个距离检查的`else`语句，该语句将位于最终大括号之前，并添加以下代码：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the player is out of range, this `else` statement will become active. We
    check to see if the Brawl is still enraged. If it is, we change the Sprite to
    the transformation, set a second alarm, and indicate that the Brawl is back to
    normal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家超出范围，这个`else`语句将变为活动状态。我们检查Brawl是否仍然处于愤怒状态。如果是，我们将Sprite更改为变身状态，设置第二个警报，并指示Brawl已恢复正常。
- en: 'Here is the full `scr_Brawl_Step` script:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的`scr_Brawl_Step`脚本：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Duplicate the `scr_Brawl_Alarm0` script, name it `scr_Brawl_Alarm1`, and adjust
    the values as shown in the following code. Remember to add this as an **Alarm
    1** event.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`scr_Brawl_Alarm0`脚本，将其命名为`scr_Brawl_Alarm1`，并根据以下代码调整值。记得将其添加为**Alarm 1**事件。
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the game and confirm that the Brawl grows larger and faster when the player
    is near and in sight, and returns to normal when out of range.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并确认，当玩家接近并在视线范围内时，Brawl会变得更大更快，并在超出范围时恢复正常。
- en: 'The only thing we have left is the attack. Create a new Script, `scr_Brawl_Collision`,
    for a **obj_Player** event with the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们唯一剩下的就是攻击。为**obj_Player**事件创建一个名为`scr_Brawl_Collision`的新脚本，其中包含以下代码：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the player collides with the Brawl for the first time, we remove 10 points
    of health and set an alarm for two seconds that will allow the Brawl to attack
    again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家第一次与Brawl碰撞，我们会减少10点生命值并设置一个两秒的警报，让Brawl可以再次攻击。
- en: 'To wrap up the Brawl, all we need is the final **Alarm 2** event with a new
    Script, `scr_Brawl_Alarm2`, that contains the following line of code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成Brawl，我们只需要最终的**Alarm 2**事件和一个新的脚本`scr_Brawl_Alarm2`，其中包含以下代码行：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The Brawl is now complete and functions as designed. If everything is implemented
    correctly, the object properties should look like the following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Brawl现在已经完成并按设计进行。如果一切实现正确，对象属性应该如下截图所示：
- en: '![Building a wandering Brawl](img/4100OT_04_14.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个漫游的Brawl](img/4100OT_04_14.jpg)'
- en: Remove any instances of `obj_Brawl` from the `Sandbox` room, so that we can
    start fresh for the final enemy.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Sandbox`房间中删除任何`obj_Brawl`实例，以便我们可以为最终敌人重新开始。
- en: Creating the Coach
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建教练
- en: The final enemy we will create, the Coach, is going to be the most challenging
    opponent yet. This enemy will move all around the room, randomly going from trophy
    to trophy to make sure it is still there. If it sees the player, it will chase
    them and if it gets close enough, it will have a melee attack. If the player escapes,
    it will wait for a moment before returning to duty. The Coach has a body, so it
    will need to go around obstacles and even avoid other coaches. This also means
    that it can die if the player is able to attack it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的最后一个敌人，教练，将是迄今为止最具挑战性的对手。这个敌人将在房间中四处移动，随机地从一个奖杯到另一个奖杯，以确保奖杯仍在那里。如果它看到玩家，它会追逐他们，如果足够接近，它会进行近战攻击。如果玩家逃脱，它会等一会儿然后返回岗位。教练有一个身体，所以它需要绕过障碍物，甚至避开其他教练。这也意味着如果玩家能够攻击它，它可能会死亡。
- en: As this enemy is guarding something, we will start by creating the trophy. Create
    a new Sprite, `spr_Trophy`, and load `Chapter 4/Sprites/Trophy.gif` with **Remove
    Background** checked.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个敌人正在守卫某物，我们将从创建奖杯开始。创建一个新的精灵，`spr_Trophy`，并加载`Chapter 4/Sprites/Trophy.gif`，勾选**移除背景**。
- en: Create a new Object, `obj_Trophy`, and apply `scr_Trophy` as its Sprite.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Trophy`，并将`scr_Trophy`应用为其精灵。
- en: 'As this is an animated sprite, we will want to add a **Create** event and have
    it not animate by writing the following code in a new Script, `scr_Trophy_Create`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个动画精灵，我们将添加一个**创建**事件，并通过在新脚本`scr_Trophy_Create`中编写以下代码来使其不进行动画：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is all we need for now for the trophy, so click on **OK**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对于奖杯来说，这就是我们需要的全部，所以点击**确定**。
- en: Much like the player, we will need four sprites for the four directions this
    enemy will move in.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与玩家一样，我们需要四个精灵，代表敌人将移动的四个方向。
- en: Create a new Sprite, `spr_Coach_WalkRight`, and load `Chapter 4/Sprites/Coach_WalkRight.gif`
    with **Remove Background** checked.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，`spr_Coach_WalkRight`，并加载`Chapter 4/Sprites/Coach_WalkRight.gif`，勾选**移除背景**。
- en: Center the origin, click on **Modify Mask**, and check **Full image** under
    **Bounding Box**.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点居中，点击**修改掩码**，并在**边界框**下勾选**完整图像**。
- en: Repeat this process for `spr_Coach_LWalkLeft`, `spr_Coach_WalkDown`, and `spr_Coach_WalkUp`
    sprites.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`spr_Coach_LWalkLeft`、`spr_Coach_WalkDown`和`spr_Coach_WalkUp`精灵，重复此过程。
- en: Create a new Object, `obj_Coach`, and apply `spr_Coach_WalkRight` as its Sprite.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Coach`，并将`spr_Coach_WalkRight`应用为其精灵。
- en: We are going to be dynamically creating paths for this enemy, so that it can
    navigate to the trophies on its own. We also want it to avoid obstacles and other
    enemies. This isn't too difficult to achieve, but it is going to require a lot
    of setup on initialization.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个敌人动态创建路径，以便它可以自行导航到奖杯。我们还希望它避开障碍物和其他敌人。这并不难实现，但在初始化时需要进行大量设置。
- en: 'Create a new Script, `scr_Coach_Create`, apply it to a **Create** event, and
    then we will start with some basic variables:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Coach_Create`，将其应用于**创建**事件，然后我们将从一些基本变量开始：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once again we start by setting the speed of the object. Then we have four variables
    representing the various states we will need to check, all set to `false`. We
    also set the animation speed for the sprite.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先设置对象的速度。然后我们有四个变量，表示我们需要检查的各种状态，全部设置为`false`。我们还设置了精灵的动画速度。
- en: Next we need to set up the pathing system which will utilize some of GameMaker's
    **motion planning** functions. The basic concept here is that we create a grid
    that covers the area we want to be able to move the enemy in. We then locate all
    the objects we want the enemy to avoid, such as walls, and mark those areas of
    the grid as forbidden. We can then assign a start and goal location in the free
    area and create a path between them while avoiding obstacles.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置路径系统，该系统将利用GameMaker的一些**运动规划**功能。基本概念是我们创建一个覆盖敌人移动区域的网格。然后我们找到所有我们希望敌人避开的对象，比如墙壁，并将网格的这些区域标记为禁区。然后我们可以在自由区域中分配起点和目标位置，并在避开障碍物的情况下创建路径。
- en: 'Still in `scr_Coach_Create`, add the following code to the end of the script:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`scr_Coach_Create`中，将以下代码添加到脚本的末尾：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first thing needed is an empty path that we can use for all future paths.
    Next we create a grid that will set the dimensions of the pathing map. The `mp_grid_create`
    attribute has parameters for where it's located in the world, how many grids in
    width and height, and the size of each grid cell. In this case, we start in the
    grid in the upper-left corner and cover the entire room in 32 pixel increments.
    Dividing the room dimensions by 32 means that this will work in any size room
    without having to adjust the code. Finally, we take all instances of the wall
    found in the room and add it to the grid as areas where pathing is not allowed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要一个空路径，我们可以用于所有未来的路径。接下来，我们创建一个网格，该网格将设置路径地图的尺寸。`mp_grid_create`属性有参数，用于确定其在世界中的位置，宽度和高度有多少个网格，以及每个网格单元的大小。在这种情况下，我们从左上角的网格开始，以32像素的增量覆盖整个房间。将房间尺寸除以32意味着这将适用于任何尺寸的房间，而无需调整代码。最后，我们将在房间中找到的所有墙的实例添加到网格中，作为不允许路径的区域。
- en: 'Now, we need to find a destination for the Coach to go. Continue adding the
    following code at the end of the script:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为教练找到一个目的地。继续在脚本的末尾添加以下代码：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by getting a rounded random number that is based on the amount of trophies
    in the room. Notice that we subtracted one from the number of trophies. We need
    to do this because in the following line of code, we are searching for a specific
    instance using the `instance_find` function. This function is pulling from an
    array and the first item in an array always starts with a zero. Lastly, we have
    created a second variable for when we want to change destinations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先得到一个基于房间中奖杯数量的四舍五入随机数。请注意，我们从奖杯数量中减去了一个。我们需要这样做，因为在下一行代码中，我们使用`instance_find`函数搜索特定实例。这个函数是从数组中提取的，数组中的第一项总是从零开始。最后，我们创建了第二个变量，用于当我们想要改变目的地时。
- en: 'All we have to do now is make a path and use it. Add the following code at
    the end of the script:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们所要做的就是创建路径并使用它。在脚本的末尾添加以下代码：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here we select the grid we created and the empty path, and have a new path created
    that goes from the Coach's position to the targeted location and will not go on
    diagonals. Then we set the Coach into motion and this time, when it hits the end
    of the path, it will come to a stop. The final value in the `path_start` function
    sets the path to absolute, which we want in this case as the path is created dynamically.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择了我们创建的网格和空路径，并创建了一个新的路径，该路径从教练的位置到目标位置，并且不会对角线移动。然后我们让教练动起来，这一次，当它到达路径的尽头时，它将停下来。`path_start`函数中的最终值将路径设置为绝对值，在这种情况下我们需要这样做，因为路径是动态创建的。
- en: 'Here is the entire `scr_Coach_Create` script:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个`scr_Coach_Create`脚本：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Open up Sandbox, and place two instances of `obj_Coach` in the corners and three
    instances of `obj_Trophy` as seen in the following screenshot:![Creating the Coach](img/4100OT_04_15.jpg)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Sandbox，在角落放置两个`obj_Coach`实例，以及三个`obj_Trophy`实例，如下截图所示：![Creating the Coach](img/4100OT_04_15.jpg)
- en: Run the game. You should see the coaches randomly select a trophy and move towards
    it. Try and restart it a few times to see the different paths each Coach takes.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。您应该看到教练们随机选择一个奖杯并朝它移动。尝试重新启动几次，看看每个教练所采取的不同路径。
- en: 'With the basic setup complete, we can move on to the AI. We will start by switching
    the sprites based on the direction of movement. Create a new Script, `scr_Coach_Step`,
    apply it to a **Step** event and write the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本设置完成后，我们可以继续进行AI。我们将从根据移动方向切换精灵开始。创建一个新的脚本`scr_Coach_Step`，将其应用于**Step**事件，并编写以下代码：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we are changing the Sprite based on the direction of the instance as it
    moves. We can do this here, because we are not allowing diagonal movement on the
    path.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据实例移动的方向更改精灵。我们可以在这里做到这一点，因为我们不允许在路径上进行对角线移动。
- en: 'Next, we will get the Coach to watch for the player, and if spotted, they will
    leave their path in pursuit. Add the following code after the Sprite change code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将让教练观察玩家，如果被发现，他们将离开原来的路径进行追逐。在精灵更改代码之后添加以下代码：
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once again we are using a variable to hold the value of how far away the player
    is to save us some coding time and minimize function calls. If the player is within
    range and not within striking distance, we do a sightline check. The `collision_line`
    function returns the ID of any wall instance that the line crosses. If it does
    not intersect with any wall instances, it will return a special variable called
    `noone`. If the player is in sight, we end the path the Coach is following, and
    start moving towards the player. The `mp_potential_step` function will make an
    object move in the desired direction while avoiding obstacles, and in this case
    we are avoiding all instances. Finally we indicate that the Coach is chasing the
    player.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用一个变量来保存玩家距离的值，以节省编码时间并最小化函数调用。如果玩家在范围内且不在攻击距离内，我们进行视线检查。`collision_line`函数返回线穿过的任何墙实例的ID。如果它不与任何墙实例相交，它将返回一个名为`noone`的特殊变量。如果玩家在视线中，我们结束教练正在遵循的路径，并开始朝玩家移动。`mp_potential_step`函数将使对象朝着期望的方向移动，同时避开障碍物，在这种情况下，我们避开所有实例。最后，我们指示教练正在追逐玩家。
- en: 'This works well for starting the chase, but what if the player escapes? Let''s
    have the Coach wait for a moment and then go back to patrolling. Add an `else`
    statement to the sightline check with the following code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这对于开始追逐很有效，但是如果玩家逃脱了怎么办？让教练等待一会儿，然后回到巡逻。在进行视线检查的`else`语句中添加以下代码：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This `else` statement states that if the player cannot be seen and the Coach
    is chasing, it will set an alarm for finding a new destination, tell it to wait,
    and the chase is over.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`else`语句表示，如果玩家看不见并且教练正在追逐，它将设置一个警报以寻找新目的地，告诉它等待，追逐结束。
- en: 'We have set an alarm, so let''s create a new Script, `scr_Coach_Alarm0`, and
    apply it to an **Alarm 0** event. Write the following code in the script:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一个警报，因此让我们创建一个新的脚本`scr_Coach_Alarm0`，并将其应用于**Alarm 0**事件。在脚本中写入以下代码：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We start with a `while` loop checking to see if the next location is the same
    as the old location. This will ensure that the Coach always moves to another trophy.
    Just as we did in the initial setup, we select a new target and set the current
    location variable. We also create a Path and start moving on it, which means the
    Coach is no longer waiting.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一个`while`循环来检查下一个位置是否与旧位置相同。这将确保教练总是移动到另一个奖杯。就像我们在初始设置中所做的那样，我们选择一个新的目标并设置当前位置变量。我们还创建一个路径并开始在其上移动，这意味着教练不再等待。
- en: We have one last element we need to add to the chase sequence, the attack. If
    the Coach gets close enough to the player, it should melee attack the player.
    For this we need to first create a new Sprite, `spr_Coach_Attack`, with `Chapter
    4/Sprites/Coach_Attack.gif` loaded and **Remove Background** checked.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加一个元素到追逐序列中，即攻击。如果教练靠近玩家，它应该对玩家进行近战攻击。为此，我们首先需要创建一个新的精灵`spr_Coach_Attack`，加载`Chapter
    4/Sprites/Coach_Attack.gif`并勾选**Remove Background**。
- en: 'Just like the player''s attack, set **Origin** to **X:** `-16`, **Y:** `24`
    and adjust the **Bounding Box** values to **Left**: `0`, **Right**: `24`, **Top**:
    `0`, and **Bottom**: `4`.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像玩家的攻击一样，将**Origin**设置为**X:**`-16`，**Y:**`24`，并调整**Bounding Box**的值为**Left:**`0`，**Right:**`24`，**Top:**`0`，和**Bottom:**`4`。
- en: Create a new Object, `obj_Coach_Attack`, apply the Sprite to it, and set **Depth**
    to `-100`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象`obj_Coach_Attack`，应用精灵，并将**Depth**设置为`-100`。
- en: Add a **Create** event and apply a new Script, `scr_Coach_Attack_Create`, with
    code to control the animation speed, set an alarm to remove the instance, and
    a variable that we can turn on.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Create**事件，并应用一个新的脚本`scr_Coach_Attack_Create`，其中包含控制动画速度的代码，设置一个用于移除实例的警报，并一个我们可以打开的变量。
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Add an **Alarm 0** event with a new Script, `scr_Coach_Attack_Alarm0`, that
    removes the instance.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的脚本`scr_Coach_Attack_Alarm0`添加一个**Alarm 0**事件，该脚本会移除实例。
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, add an **obj_Player** event, and apply a new Script, `scr_Coach_Attack_Collision`
    with the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个**obj_Player**事件，并应用一个新的脚本`scr_Coach_Attack_Collision`，其中包含以下代码：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If this is the first collision, we remove a point of health and then deactivate
    this check.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是第一次碰撞，我们减少一点生命值，然后停用此检查。
- en: 'We are done with the attack. Now to have it activated in the Coach, reopen
    `scr_Coach_Step` and add the attack code as an `else if` statement, after the
    last brace:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击已经完成。现在要在教练中激活它，重新打开`scr_Coach_Step`，并在最后的大括号后添加攻击代码作为`else if`语句：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If the Coach is near the player and has not attacked yet, we create an instance
    of the Coach Attack. We then rotate the attack Sprite to face the same direction
    as the Coach. An alarm is set for three seconds to allow for a breather before
    this code can be run again.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果教练靠近玩家但尚未发动攻击，我们创建一个教练攻击的实例。然后我们旋转攻击精灵，使其面向与教练相同的方向。设置一个三秒的闹钟，以便在再次运行此代码之前有时间喘口气。
- en: We need an **Alarm 1** event to reset the attack, so create a new script, `scr_Coach_Alarm1`
    and turn off the attack.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个**Alarm 1**事件来重置攻击，因此创建一个新脚本，`scr_Coach_Alarm1`，并关闭攻击。
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run the game. The Coach will now chase the player, and if it gets close enough
    to the player it will attack.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。现在教练会追逐玩家，如果它靠近玩家足够近，它就会发动攻击。
- en: The Coach is now only doing half of its job, chasing the player. We still need
    to add in the regular patrol duties. Currently, if the Coach doesn't see the player
    and it gets to the end of the path, it stops and does nothing again. It should
    only wait a few seconds and then move on to the next trophy.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 教练现在只完成了一半的工作，追逐玩家。我们还需要添加正常的巡逻任务。目前，如果教练看不到玩家并且到达路径的尽头，它就会停下来再次什么都不做。它应该只等几秒，然后继续移动到下一个奖杯。
- en: 'Reopen `scr_Coach_Step` and add an `else` statement to the very end of the
    script with this code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Coach_Step`，并在脚本的最后添加一个`else`语句，包含以下代码：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This `else` statement means that the player is out of range. We then check to
    see if the Coach is waiting or not. If it isn't waiting, but is within eight pixels
    of its targeted trophy, we set the alarm for choosing a new destination for two
    seconds, end the path to stop movement, and state that we are now waiting.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`else`语句表示玩家超出范围。然后我们检查教练是否在等待。如果它不在等待，但距离目标奖杯不到八个像素，我们设置两秒钟的选择新目的地的闹钟，结束路径以停止移动，并声明我们现在在等待。
- en: Run the game and you should see the coaches, when not chasing the player, stopping
    near a trophy, pausing for a moment, and then moving to another trophy.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏，你会看到教练在不追逐玩家时，停在奖杯附近，停顿片刻，然后移动到另一个奖杯。
- en: 'There is an issue, however, if both coaches go to the same trophy. Sometimes
    they will both overlap each other. Let''s fix that by adding the following code
    after the distance check for the trophy:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果两个教练都去同一个奖杯，就会出现问题。让我们通过在检查奖杯的距离后添加以下代码来解决这个问题：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first thing we need to do is do a variable check to see if the Coach needs
    to avoid something. If it does, we use the `mp_potential_step` function which
    will move an instance towards a specified goal while attempting to avoid certain
    objects, or in this case, all instances.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是检查变量，看教练是否需要避让。如果需要，我们使用`mp_potential_step`函数，该函数将使实例朝着指定目标移动，同时尝试避开某些对象，或者在这种情况下，避开所有实例。
- en: 'Now, we need to set up the condition for when avoidance should occur. Immediately
    after the last code is inserted, write the following:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要设置避让发生的条件。在最后的代码之后立即插入以下内容：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First we check to see if an instance of the Coach is nearby and it hasn't tried
    to avoid it. If that is true then we take the Coach off of its path and start
    to avoid. We follow this with an `else if` statement checking to see if we are
    far enough away from another Coach that we were trying to avoid. If so, we set
    a new path to the destination, start moving on it, and end the avoidance.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查教练实例是否附近，且尚未尝试避让。如果是，则我们让教练脱离路径并开始避让。接着是一个`else if`语句，检查我们是否与另一个教练足够远，以便我们可以避让。如果是，我们为目的地设置一个新路径，开始移动，并结束避让。
- en: 'There is still one little issue remaining, which you can see if you run the
    game for a while. Sometimes two coaches will get too close together and they both
    stop. This is because they are trying to avoid each other, but are actually touching
    and can''t let go. At the very end of the `scr_Coach_Step` Script, write the following:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个小问题尚未解决，如果你运行游戏一段时间就会发现。有时两辆教练会靠得太近，它们就会停下来。这是因为它们试图避开彼此，但实际上它们是在接触并且无法分开。在`scr_Coach_Step`脚本的最后，写入以下内容：
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will check to see if two instances of the Coach are colliding with each
    other. If they are, we set the `x` and `y` coordinates to the special variables
    `xprevious` and `yprevious`, which represent the position of the instance in the
    previous step. Once they have taken a step back, we can then attempt to move around
    them again.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查两个教练实例是否相互碰撞。如果是，我们将`x`和`y`坐标设置为特殊变量`xprevious`和`yprevious`，它们代表实例在上一步中的位置。一旦它们退后一步，我们就可以再次尝试绕过它们。
- en: 'The Coach is now complete. To check to see if you have all the code for `scr_Coach_Step`
    written correctly, here it is in its completed form:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 教练现在已经完成。要检查`scr_Coach_Step`的所有代码是否都写正确，这里是完整的代码：
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Adding finishing details to the game
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为游戏添加最后的细节
- en: The game is now functionally complete, but there are a few elements left to
    polish up. To start, the player takes damage but never dies, nor is there a **heads-up
    display** (**HUD**) to show this. Let's create a quick Overlord.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在在功能上已经完成，但还有一些元素需要完善。首先，玩家会受到伤害，但从不会死亡，也没有**头顶显示**（**HUD**）来显示这一点。让我们快速创建一个Overlord。
- en: Create a new Object, `obj_Overlord`, with no sprite applied and persistence
    is checked.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Overlord`，不应用精灵并检查持久性。
- en: 'Add a **Draw GUI** event and a new Script for it, `scr_Overlord_DrawGUI`, with
    the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Draw GUI**事件和一个新的脚本，`scr_Overlord_DrawGUI`，其中包含以下代码：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, we use the function `draw_healthbar` which you can see has a lot of parameters.
    The first four are the size and placement of a rectangular bar. Next is the variable
    to be used for how full the bar is, in our case, the global health variable. The
    next three are the background color, and the min/max colors. Next is the direction
    the bar should fall, zero being to the left. The final two Booleans are for drawing
    the background and border that we want.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了函数`draw_healthbar`，你可以看到它有很多参数。前四个是矩形条的大小和位置。接下来是用于控制条的满度的变量，在我们的例子中是全局健康变量。接下来的三个是背景颜色和最小/最大颜色。接下来是条应该下降的方向，零表示向左。最后两个布尔值是用于绘制我们想要的背景和边框。
- en: After that we do a health check and if the player should be dead, we remove
    the player, return to the frontend, and then remove the Overlord itself. It is
    important to remove any persistent instances in the world or they won't go away!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们进行健康检查，如果玩家应该死了，我们移除玩家，返回前端，然后移除Overlord本身。移除世界中的任何持久实例是很重要的，否则它们就不会消失！
- en: Place a single instance of `obj_Overlord` into `C04_R01`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`obj_Overlord`的实例放入`C04_R01`中。
- en: Populate the rooms with a variety of enemies. If we use the Brawl we will either
    need to create a room that works with the path we created, or even better, redraw
    the path to fit our room layout.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用各种敌人填充房间。如果我们使用Brawl，我们要么需要创建一个适用于我们创建的路径的房间，要么更好的是重新绘制路径以适应我们的房间布局。
- en: Make sure the `Sandbox` room is moved back to the bottom of the Resource tree
    and run the game. We should see the health bar at the top of the screen and if
    you take damage, the health bar should go down. If the player takes too much damage,
    the game will end and return to the frontend.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`Sandbox`房间被移回到资源树的底部并运行游戏。我们应该在屏幕顶部看到健康条，如果受到伤害，健康条应该下降。如果玩家受到了太多伤害，游戏将结束并返回到前端。
- en: 'All that is left is to create levels, paint the world with a tile set, and
    add some background music. At this point you should know how to do that, so we
    will leave it up to you. We have supplied some additional assets for this purpose
    in the `Chapter 4` folder. You should have something that looks like the following
    screenshot when you are done:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 所有剩下的就是创建关卡，用瓷砖集来绘制世界，并添加一些背景音乐。在这一点上，你应该知道如何做了，所以我们会把它留给你。我们已经在“第4章”文件夹中提供了一些额外的资源。完成后，你应该会看到类似以下截图的东西：
- en: '![Adding finishing details to the game](img/4100OT_04_16.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![为游戏添加最后的细节](img/4100OT_04_16.jpg)'
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on completing your second game! We learned how to simplify the
    player controls by placing the keyboard checks and collision forecasting into
    a single script. We covered several ways to deal with Sprite animation from rotating
    the image to setting what sprites should be displayed. We dealt with global variables
    and used them to implement a room transitioning system. We covered some new object
    properties in depth and persistence. Then we spent some time dealing with artificial
    intelligence through the use of proximity detection and path finding. We even
    discovered how to make an object navigate a room on its own while avoiding obstacles.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了你的第二个游戏！我们学会了通过将键盘检查和碰撞预测放入一个脚本来简化玩家控制。我们涵盖了处理精灵动画的几种方法，从旋转图像到设置应该显示哪些精灵。我们处理了全局变量，并用它们来实现了一个房间过渡系统。我们深入讨论了一些新的对象属性和持久性。然后我们花了一些时间处理人工智能，通过接近检测和路径查找。我们甚至发现了如何使一个对象在避开障碍物的同时自己导航到一个房间。
- en: With the skills you have honed in this chapter, you will now be able to build
    games with multiple rooms with enemies that appear to think. It's your turn now
    to extend this game by adding more unique enemies, have the trophy open, and spawn
    loot. Have fun and explore your new found abilities!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章中所学的技能，你现在可以构建具有多个房间和敌人的游戏，这些敌人看起来会思考。现在轮到你通过添加更多独特的敌人、打开奖杯并生成战利品来扩展这个游戏了。玩得开心，探索你新发现的能力！
- en: In the next chapter we are going to build an epic boss fight for a platformer
    style game. There will be guns and lasers, and lots of fun. We will be starting
    to make our code more efficient by looking at creating reusable scripts, and learning
    how to structure our code systematically. All of this will help us to make our
    games faster and easier, so let's get going!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为平台游戏构建一场史诗般的boss战。将会有枪支和激光，还有很多乐趣。我们将开始通过创建可重复使用的脚本，以及学习如何系统地构建我们的代码来提高代码的效率。所有这些都将帮助我们使游戏变得更快更容易，所以让我们开始吧！
