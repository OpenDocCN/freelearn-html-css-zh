- en: Chapter 5. Platform Fun
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。平台乐趣
- en: Now that we have a good grounding in the basics of building a game, we are ready
    to create more complex and more efficient projects. In this chapter we are going
    to develop a classic platforming game with an epic boss battle. We will focus
    on building systems and utilizing reusable scripts to simplify our code and save
    time. This will also reduce the total size of the game, making it faster to download.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对构建游戏的基础有了很好的基础，我们准备创建更复杂和更高效的项目。在本章中，我们将开发一个经典的平台游戏，其中包括一场史诗般的Boss战。我们将专注于构建系统，并利用可重复使用的脚本简化我们的代码并节省时间。这也将减少游戏的总体大小，使其下载速度更快。
- en: The gameplay itself will consist of a player character that can run around the
    world, jump onto platforms, and shoot in several directions. The player will need
    to defeat a giant machine Boss that will have three distinct stages. In the first
    stage the player will need to blow up three powerful Cannons that are exposed
    for a short period of time. The second stage requires the destruction of a large
    Laser Cannon that will move up and down firing its massive Laser Beam intermittently.
    The final stage will have Shields that protect the Boss Core, occasionally opening
    to allow the player to eradicate the heart of the boss. All of this will happen
    while the player tries to avoid being hit by an indestructible turret.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏本身将包括一个玩家角色，可以在世界中奔跑，跳上平台，并朝多个方向射击。玩家需要击败一个巨型机器Boss，它将有三个不同的阶段。在第一阶段，玩家需要摧毁三门暴露一小段时间的强大火炮。第二阶段需要摧毁一个大型激光炮，它会上下移动，不时地发射巨大的激光束。最后一个阶段将有护盾保护Boss核心，偶尔打开以允许玩家消灭Boss的核心。所有这些都将发生在玩家试图避免被一门不可摧毁的炮塔击中的情况下。
- en: Structuring systems-based code
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于系统的代码结构
- en: When making a game, it is common to build each component all on its own and
    not to think about how it will affect the game as a whole. The developer will
    build a basic framework and then add features as they come along, often resorting
    to special conditional statements to make the code work without breaking the game.
    This methodology eventually will start creating bugs in the software requiring
    more time and effort to fix each one. The bigger the game, the more likely problems
    will be to arise. It can be an incredibly frustrating experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 制作游戏时，通常会单独构建每个组件，而不考虑它将如何影响整个游戏。开发人员将构建一个基本框架，然后在需要时添加功能，通常会使用特殊的条件语句使代码能够正常工作而不破坏游戏。这种方法最终会在软件中产生错误，需要更多的时间和精力来修复每一个错误。游戏越大，出现问题的可能性就越大。这可能是一种令人沮丧的经历。
- en: This is where breaking the code into individual systems can really save time
    and effort. Rather than rewriting elements of code over and over again for each
    object, we can write self-contained processes into scripts that can be shared.
    For this game we are going to separate out some of the more basic components,
    such as gravity and animation, into their own systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分解为单独的系统可以真正节省时间和精力。我们可以将代码的各个元素写入脚本中，以便共享，而不是为每个对象一遍又一遍地重写代码。对于这个游戏，我们将把一些更基本的组件，比如重力和动画，分离成它们自己的系统。
- en: Creating gravity
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建重力
- en: 'The first system we are going to build is one for dealing with gravity. While
    GameMaker: Studio does have a gravity property, it adds a level of complexity
    not needed in a platformer game. Gravity is a force that is applied to an object''s
    speed cumulatively, which means that the longer an object is falling, that faster
    it will move. The issue we have is that setting gravity to zero just means it
    will not move faster. We need the object to come to a full stop. Therefore, we
    we will create our own gravity system that not only makes objects fall, but will
    deal with landing on the ground as well. Instead we will create our own gravity
    system that not only makes objects fall, but will deal with landing on the ground
    as well.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '我们要构建的第一个系统是处理重力的系统。虽然GameMaker: Studio确实有一个重力属性，但在平台游戏中并不需要这种复杂性。重力是一个作用于物体速度的力，这意味着物体下落的时间越长，速度就越快。我们的问题是将重力设置为零只意味着它不会移动得更快。我们需要物体完全停下来。因此，我们将创建自己的重力系统，不仅使物体下落，还将处理着陆的情况。我们将创建自己的重力系统，不仅使物体下落，还将处理着陆的情况。'
- en: 'We are going to start by introducing **constants** . Constants allow us to
    use names to represent values that will never change. This has the double benefit
    of making it easier for us to read the code and help improve performance as compared
    to variables:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍**常量**。常量允许我们使用名称来表示永远不会改变的值。这不仅使我们更容易阅读代码，还有助于提高性能，与变量相比：
- en: Let's get started by creating a **New Project** called `Chapter_03`.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始创建一个名为`Chapter_03`的**新项目**。
- en: Open the **Resources** | **Define Constants** editor. In the **Name** column
    write `MAXGRAVITY` with a **Value** of `16`. At this speed we can be sure that
    a falling object will not move so fast that it will miss the bounding box of another
    object in the game. From now on, whenever we see `MAXGRAVITY` the computer will
    see `16`.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**资源** | **定义常量**编辑器。在**名称**列中写入`MAXGRAVITY`，**值**为`16`。以这个速度，我们可以确保下落的物体不会移动得太快，以至于错过游戏中另一个物体的边界框。从现在开始，每当我们看到`MAXGRAVITY`，计算机将看到`16`。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: It is convention to write all constants in all capital letters, though it won't
    break if the convention isn't followed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，将所有常量都用大写字母写出，尽管如果不遵循惯例，也不会出错。
- en: 'Next we can create a new Script , `scr_Gravity`, and write the following code
    to create gravity:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个新的脚本，`scr_Gravity`，并编写以下代码来创建重力：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First we check to see whether the area below the instance is clear of any collidable
    objects at the speed the instance is currently travelling. If it is clear, then
    we know that we are in the air and that gravity should be applied. We do this
    by increasing the vertical speed each step by a small amount. If there is a collidable
    object, then we are about to hit the ground, so we move the instance to the surface
    of the object in the direction the instance is travelling up to our `MAXGRAVITY`,
    16 pixels. At that point, the instance is on the ground so we set the vertical
    speed to zero.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查实例下方的区域是否没有任何可碰撞的对象以当前速度行进。如果清晰，那么我们知道我们在空中，应该施加重力。我们通过每一步增加垂直速度的小量来实现这一点。如果有可碰撞的对象，那么我们即将着地，所以我们将实例移动到对象表面，以实例当前向上行进的方向到我们的`MAXGRAVITY`，即16像素。在那一点，实例在地面上，所以我们将垂直速度设为零。
- en: 'We now have gravity working, but it will pick up too much speed if we don''t
    limit how fast an instance can fall. Add this code to the bottom of the script:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经让重力起作用了，但如果我们不限制实例下落的速度，它将会加速得太快。将以下代码添加到脚本的底部：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we are setting the `vspeed` value to the lower value between the current
    `vspeed` and `MAXGRAVITY`. If the instance is moving too fast, this code will
    slow it down to the maximum allowed speed. We now have a simple gravity system
    that all objects in the game could utilize.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`vspeed`值设置为当前`vspeed`和`MAXGRAVITY`之间的较小值。如果实例移动得太快，这段代码将使其减速到允许的最大速度。现在我们有了一个简单的重力系统，游戏中的所有对象都可以利用它。
- en: Building an animation system
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建动画系统
- en: The next system we will create is for animation and it will be implemented as
    a state machine. A state machine breaks down all the conditions of an object into
    distinct states. An object can only be in one stage at any one time, so the code
    related to it can be contained and managed more effectively.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的下一个系统是动画系统，它将作为状态机实现。状态机将所有对象的条件分解为不同的状态。一个对象在任何时候只能处于一个阶段，因此与之相关的代码可以更有效地被包含和管理。
- en: To understand this concept better, think about a door. A door has several unique
    states of being. The two states that probably spring to mind are that the door
    can be open or it can be closed. There are also two other states, opening and
    closing, as can be seen in the following image. If the door is opening, it is
    neither open nor is it closed, but rather it is in a unique state of action. This
    makes state machines perfect for animation. Almost every interactive object in
    a game is likely to have some animation or utilize several different images.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个概念，想想一扇门。一扇门有几种独特的状态。可能首先想到的两种状态是门可以打开或者关闭。还有两种其他状态，即打开和关闭，如下图所示。如果门正在打开，它既不是打开的，也不是关闭的，而是处于一种独特的动作状态。这使得状态机非常适合动画。游戏中几乎每个可交互的对象都可能有一些动画或利用几个不同的图像。
- en: '![Building an animation system](img/4100_05_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![构建动画系统](img/4100_05_01.jpg)'
- en: 'Since the player character is generally the most robust object in terms of
    different animations, we will start by breaking down its unique states. Our player
    can be either in the air or on the ground, so we will want to make sure to separate
    those controls. We also want the player to be able to shoot in multiple directions
    and take damage. All together we will have a total of eight different states:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家角色通常是在不同动画方面最强大的对象，我们将首先分解其独特的状态。我们的玩家可以在空中或地面上，所以我们希望确保分开这些控制。我们还希望玩家能够朝多个方向射击并受到伤害。总共我们将有八种不同的状态：
- en: Idle
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空闲
- en: Idle aiming up
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空闲向上瞄准
- en: Idle aiming down
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空闲向下瞄准
- en: Run
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奔跑
- en: Run aiming up
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奔跑向上瞄准
- en: Run aiming down
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下瞄准
- en: InAir
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在空中
- en: Damage
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伤害
- en: 'Let''s start by defining these states as constants:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将这些状态定义为常量：
- en: Open the **Resources** | **Define Constants** editor and in the **Name** column
    write `IDLE` with a **Value** of `0`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**资源** | **定义常量**编辑器，在**名称**列中写入`IDLE`，**值**为`0`。
- en: Click on **Add** or just press *Enter* to add a new row and write `IDLEUP` with
    a value of `1`. Repeat this process for all the states with increasing numbers
    as can be seen in the following screenshot. Then click on **OK**.![Building an
    animation system](img/4100_05_02.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**或直接按*Enter*添加新行，并写入`IDLEUP`，值为`1`。重复这个过程，为所有状态添加递增的数字，如下截图所示。然后点击**确定**。![构建动画系统](img/4100_05_02.jpg)
- en: 'Create a new Script and name it `scr_Animation_Control`. We will start by using
    a `switch` statement to control the various states. We also want this script to
    be reusable, so we will want to use some generic variables to make the code more
    universal. Let''s start by adding in the idle state with the following code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`scr_Animation_Control`。我们将首先使用`switch`语句来控制各种状态。我们还希望这个脚本是可重用的，所以我们将使用一些通用变量来使代码更通用。让我们首先添加空闲状态的以下代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we are going to use a variable called `action` to switch states. If the
    action happens to be `IDLE`, we then change the sprite; in this case we are using
    another variable, `myIdle`, that we will define in each object which will allow
    us to reuse this script. We also set the animation rate which will allow us to
    have different playback speeds for different actions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用一个名为`action`的变量来切换状态。如果动作恰好是`IDLE`，那么我们就改变精灵；在这种情况下，我们使用另一个变量`myIdle`，我们将在每个对象中定义它，这将允许我们重用这个脚本。我们还设置了动画速率，这将允许我们对不同的动作有不同的播放速度。
- en: 'We will need to insert all the cases into this script with a similar setup
    of changing the sprite and setting the image playback speed. Here is the rest
    of the code for the states:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将所有的情况插入到这个脚本中，并设置改变精灵和设置图像播放速度的类似设置。以下是其他状态的代码：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have all the states we need, but what about dealing with the direction that
    the player is facing. It''s a platformer so they will need to go right and left.
    For this we will just flip the image by scaling it inversely with the following
    code after the switch statement closing brace:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经拥有了所有需要的状态，但是如何处理玩家面对的方向呢？这是一个平台游戏，所以他们需要向左和向右移动。为此，我们将通过以下代码在switch语句结束括号后翻转图像：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once again we are utilizing a variable, `facing`, to make the script more universal.
    We are now done with this script and the animation system is ready to be implemented.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次利用一个变量`facing`，使脚本更通用。我们现在已经完成了这个脚本，动画系统已经准备好实施了。
- en: Creating a collision forecasting system
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建碰撞预测系统
- en: 'The next system we are going to build is for dealing with world collision.
    We want to move away from using GameMaker: Studio''s collision system as it requires
    two instances to intersect with each other. This works great for a bullet colliding
    with a player, but it is less effective if the player needs to sink into the ground
    in order to know when to stop. Instead, we want to forecast whether a collision
    will happen before an instance moves:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来我们要构建的系统是处理世界碰撞。我们希望摆脱使用GameMaker: Studio的碰撞系统，因为它需要两个实例相互交叉。这对于子弹与玩家的碰撞效果很好，但如果玩家需要陷入地面以知道何时停止，这种方法就不太有效。相反，我们希望在实例移动之前预测碰撞是否会发生：'
- en: 'We will start with forecasting wall collision to the left and right of the
    instance. Create a new Script, `scr_Collision_Forecasting` and write the following
    code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从预测实例左右两侧的墙壁碰撞开始。创建一个新的脚本，`scr_Collision_Forecasting`，并写入以下代码：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We start by checking to see if the area to the left of the instance is free
    of collidable objects. The distance away that we are looking is determined by
    a variable, `mySpeed`, which will allow this check to be adjustable to whatever
    speed the instance may be travelling at. If the area is clear we set the `canGoLeft`
    variable to `true`, otherwise the area is blocked and we stop the horizontal speed
    of the instance. We then repeat this check for collision to the right.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查实例左侧的区域是否没有可碰撞的对象。我们正在查看的距离由变量`mySpeed`确定，这将允许此检查根据实例可能的移动速度进行调整。如果区域清晰，我们将`canGoLeft`变量设置为`true`，否则该区域被阻塞，我们将停止实例的水平速度。然后我们重复此检查以检查右侧的碰撞。
- en: 'Next we need to check for the ground collision. After the previous code we
    need to add:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要检查地面碰撞。在上一段代码之后，我们需要添加：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we are checking if there is a collidable object directly beneath the instance.
    If there is collision, we set the variable `isOnGround` to `true`, to stop the
    vertical speed and then change the state of the instance to `IDLE`. Changing the
    state like this will guarantee that the instance escapes from an `INAIR` state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查实例正下方是否有可碰撞的对象。如果发生碰撞，我们将变量`isOnGround`设置为`true`，以停止垂直速度，然后将实例的状态更改为`IDLE`。像这样更改状态将确保实例从`INAIR`状态中逃脱。
- en: At this point we have the majority of our collision detection built, but we
    haven't covered all the edge cases. We are currently only checking to the left,
    right, and below the instance, but not on diagonals. The issue here is that it
    is possible for all conditions to prove true, but when the instance is moved on
    an angle it can result in the instance becoming stuck within a collidable object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经构建了大部分碰撞检测，但我们还没有涵盖所有边缘情况。我们目前只检查实例的左侧、右侧和下方，而不是对角线。问题在于所有条件可能都成立，但当实例以角度移动时，可能导致实例被卡在可碰撞的对象内。
- en: 'Rather than building conditional checks for all angles, we will instead allow
    the collision to happen and then pop it back into the proper position. Add this
    next code at the end of the script:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其为所有角度构建条件检查，我们将允许碰撞发生，然后将其弹回到正确的位置。在脚本的末尾添加下面的代码：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here we are checking to see if the instance is currently intersecting with
    a collidable object. If so we set the X and Y coordinates to their position on
    the previous step, then snap it to the surface in the direction of the movement
    and set the vertical speed to zero. This will clean up the edge case scenario
    in a realistic manner. The whole script should look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查实例当前是否与可碰撞的对象相交。如果是，我们将X和Y坐标设置为上一步的位置，然后将其捕捉到移动方向的表面并将垂直速度设置为零。这将以一种现实的方式清理边缘情况。整个脚本应该如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Checking the keyboard
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查键盘
- en: As we are breaking systems down into more usable scripts we might as well put
    all the keyboard controls into a single script. This will simplify the code that
    we will be creating in the future and also allow us to easily change the controls
    or offer alternative controls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将系统分解为更可用的脚本时，我们也可以将所有键盘控件放入一个单独的脚本中。这将简化我们将来要创建的代码，并且还可以轻松更改控件或提供替代控件。
- en: 'Create a new Script, `scr_Keyboard_Input` and write the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Keyboard_Input`，并写入以下代码：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our code will be much easier to read with variables such as `keyJump` and `keyShoot`
    to represent the controls than actual key names. In order to use the letter keys
    on a keyboard we need the associated ASCII number. Rather than having to look
    up each key number we can use the `ord` function, which will convert a letter
    into the proper number.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将更容易阅读，例如使用`keyJump`和`keyShoot`等变量来表示控件，而不是实际的键名。为了在键盘上使用字母键，我们需要相关的ASCII编号。我们可以使用`ord`函数，而不必查找每个键的编号，它将把字母转换为正确的数字。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `ord` function, always use capital letters or it may give the
    wrong number!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ord`函数时，始终使用大写字母，否则可能会得到错误的数字！
- en: We now have all our universal systems that we will need for this game. Next
    we will implement them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了这个游戏所需的所有通用系统。接下来我们将实施它们。
- en: Building the player
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建玩家
- en: 'The player character we are building is the most complex object we have created
    yet. Not only will the player run and jump, the controls themselves will be slightly
    different depending on whether the player is on the ground or in the air. The
    player will need to know what direction they are facing, what animation to be
    playing, whether they can shoot their weapon, and at what angle. Let''s construct
    this, starting with importing all the sprites:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的玩家角色是我们迄今为止创建的最复杂的对象。玩家不仅会奔跑和跳跃，控制本身也会因玩家是在地面上还是在空中而略有不同。玩家需要知道他们面向的方向，要播放什么动画，是否可以射击武器以及射击的角度。让我们从导入所有精灵开始构建这个：
- en: Create a new Sprite, `spr_Player_Idle`, and load `Chapter 5/Sprites/Player_Idle.gif`
    with **Remove Background** checked.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新精灵，`spr_Player_Idle`，并加载`Chapter 5/Sprites/Player_Idle.gif`，勾选**删除背景**。
- en: 'Set the **Origin** to **X**: `32` **Y**: `63` so that it rests in the center
    horizontally and rests on the bottom of the sprite vertically.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**原点**设置为**X**：`32` **Y**：`63`，使其在水平中心和垂直底部休息。
- en: 'Click on **Modify Mask** to open the **Mask Properties** editor and select
    **Bounding Box** | **Manual**. Set the values to **Left**: `16`, **Right**: `48`,
    **Top**: `8`, and **Bottom**: `63`.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**修改蒙版**以打开**蒙版属性**编辑器，并选择**边界框**|**手动**。将值设置为**左**：`16`，**右**：`48`，**上**：`8`，**下**：`63`。
- en: 'Repeat this process, including the same **Origin** and **Mask Properties**
    for the following sprites:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，包括以下精灵的相同**原点**和**蒙版属性**：
- en: '`spr_Player_IdleUp`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Player_IdleUp`'
- en: '`spr_Player_IdleDown`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Player_IdleDown`'
- en: '`spr_Player_Run`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Player_Run`'
- en: '`spr_Player_RunUp`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Player_RunUp`'
- en: '`spr_Player_RunDown`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Player_RunDown`'
- en: '`spr_Player_InAir`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Player_InAir`'
- en: '`spr_Player_Damage`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Player_Damage`'
- en: Create an Object, `obj_Player`, and assign `spr_Player_Idle` as the **Sprite**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象，`obj_Player`，并将`spr_Player_Idle`分配为**精灵**。
- en: 'First we need to initialize all the variables the player character will need,
    starting with the ones necessary for animation. Create a new Script, `scr_Player_Create`,
    with the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要初始化玩家角色所需的所有变量，从必要的动画变量开始。创建一个新脚本，`scr_Player_Create`，并使用以下代码：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we are establishing what sprites are to be used for the various states
    of animation. The variables we are using here must be the same as the ones we
    declared in `scr_Animation_Control` in order to use the animation system we created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在确定要用于各种动画状态的精灵。我们在这里使用的变量必须与我们在`scr_Animation_Control`中声明的变量相同，以便使用我们创建的动画系统。
- en: Next we will add the variables for the collision system, but before we do that,
    we should add two more constants for the facing direction. Open the **Resources**
    | **Define Constants** and add `RIGHT` with a value of `1` and `LEFT` with a value
    of `-1`. These numbers will represent the scale of the drawn image, with the negative
    value inverting the sprite.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为碰撞系统添加变量，但在这之前，我们应该添加两个用于面向方向的常量。打开**资源**|**定义常量**，并添加`RIGHT`，值为`1`，和`LEFT`，值为`-1`。这些数字将代表绘制图像的比例，负值将反转精灵。
- en: 'At the end of `scr_Player_Create` add the rest of the variables we need:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`scr_Player_Create`的末尾添加我们需要的其余变量：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we have variables for the speed of the player, the direction the player
    is aiming, the direction they are facing, and the state they are in. We have also
    added variables for whether the player can take damage or is invulnerable, and
    whether they are able to shoot or not. We now have all our variables initialized.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有玩家速度、玩家瞄准方向、玩家面向方向和玩家状态的变量。我们还添加了玩家是否能受到伤害或无敌，以及是否能射击的变量。现在我们已经初始化了所有变量。
- en: In `obj_Player`, add a **Create** event and apply the `scr_Player_Create` script.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，添加一个**创建**事件并应用`scr_Player_Create`脚本。
- en: 'We have a collision forecasting system ready to go, we just need to use it
    appropriately. Create a new Script, `scr_Player_BeginStep`, and use it to call
    the forecasting script and the keyboard checks:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好了一个碰撞预测系统，我们只需要适当地使用它。创建一个新脚本，`scr_Player_BeginStep`，并使用它来调用预测脚本和键盘检查：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Every script you create is actually an executable function. As seen here you
    just need to write the name of the script and place parentheses at the end to
    have that code run. We will be using this method often.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的每个脚本实际上都是一个可执行函数。如您在这里所见，您只需编写脚本的名称并在末尾放置括号，即可运行该代码。我们将经常使用这种方法。
- en: In `obj_Player` add a **Step** | **Begin Step** event and apply `scr_Player_BeginStep`.
    The **Begin Step** event is the very first event in every step to be executed.
    The **Step** event follows it and **End Step** is the last event before the instance
    is drawn on screen. This allows us more control over when the code is run.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中添加一个**步骤**|**开始步骤**事件，并应用`scr_Player_BeginStep`。**开始步骤**事件是每个步骤中要执行的第一个事件。**步骤**事件紧随其后，**结束步骤**是在实例被绘制在屏幕上之前的最后一个事件。这使我们能够更好地控制代码的运行时间。
- en: 'Next we need to create the controls. As we mentioned earlier, there are actually
    two separate control systems, one for on the ground and one for in the air. We
    will start with the latter as it is the simplest. Create a new Script, name it
    `scr_Player_AirControls` with the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建控件。正如我们之前提到的，实际上有两个独立的控制系统，一个用于在地面上，一个用于在空中。我们将从后者开始，因为它最简单。创建一个新脚本，命名为`scr_Player_AirControls`，并使用以下代码：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first thing you should notice is that we are no longer using operators such
    as `==` in our code. These variables are all Booleans, so they can only be true
    or false. Writing `keyLeft` is the same as writing `keyLeft == true`, but is more
    efficient.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到的第一件事是，我们不再在代码中使用`==`等运算符。这些变量都是布尔变量，因此它们只能是真或假。编写`keyLeft`与编写`keyLeft
    == true`是相同的，但更有效率。
- en: Now, since the player is in the air, the first thing we do is apply gravity.
    Next we have the controls for horizontal movement. We check to see if the appropriate
    key is pressed and if the player is able to move in said direction. If these are
    true, we check the horizontal speed against the maximum speed. If the player is
    able to increase speed, we increment it slightly. This prevents the player from
    changing directions too quickly while in the air. We follow this up by setting
    the facing and aiming directions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于玩家在空中，我们首先要做的是施加重力。接下来是水平移动的控制。我们检查适当的键是否被按下，以及玩家是否能够朝着该方向移动。如果这些条件成立，我们就检查水平速度是否达到了最大速度。如果玩家能够增加速度，我们就稍微增加它。这可以防止玩家在空中太快地改变方向。然后我们设置面向和瞄准方向。
- en: 'We can now move on to the much more complicated ground controls. Create a new
    Script and name it `scr_Player_GroundControls`. We will start by writing the idle
    state:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以转向更加复杂的地面控制。创建一个新的脚本，命名为`scr_Player_GroundControls`。我们将从编写空闲状态开始：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start by checking whether neither the left nor right keys are being pressed.
    If the keys aren't pressed and the player is moving, we check to see which way
    they are moving and then reduce the speed accordingly. What this really means
    is that the player will slide to a halt.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查左右键是否都没有被按下。如果键没有被按下而玩家正在移动，我们就检查他们的移动方向，然后相应地减少速度。这实际上意味着玩家会滑行停下来。
- en: 'The player has come to a stop, but it is not yet idling. To do this we need
    to determine if the player is using the up or down keys as that will affect which
    direction the player is aiming. Insert this next code immediately after the last
    line of code, but inside the last brace:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家已经停下来，但还没有进入空闲状态。为了做到这一点，我们需要确定玩家是否正在使用上下键，因为这将影响玩家瞄准的方向。在最后一行代码之后，但在最后一个大括号内立即插入下一个代码：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We start by checking if the up key is pressed, and if it is, we change the action
    to `IDLEUP` and set the aim to 45 degrees so that the player will shoot upwards.
    If that isn't true, we check the down key and change the action and aim if appropriate.
    Finally, if neither of those keys is pressed, we go into the standard `IDLE`.
    For the aim, however, we need to see which way the player is facing first. The
    player will properly idle from now on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查上键是否被按下，如果是，我们将动作更改为`IDLEUP`，并将瞄准设置为45度，这样玩家就会向上射击。如果不是，我们检查下键，如果合适的话，更改动作和瞄准。最后，如果这两个键都没有被按下，我们就进入标准的`IDLE`状态。不过，对于瞄准，我们需要先看一下玩家面对的方向。从现在开始，玩家将正确地进入空闲状态。
- en: 'Next we can add the left and right controls. After the very last brace, write
    the following code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们可以添加左右控制。在最后一个大括号之后，写下以下代码：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We check to see if the left key has been pressed and that the player is able
    to move left. If so, we set the horizontal speed and set the facing direction
    to go left. Once again, we check to see if the up or down keys are currently pressed
    or not and then set the action and aim to their proper values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查左键是否被按下，以及玩家是否能够向左移动。如果是，我们就设置水平速度，并将面向方向设置为向左。再次检查当前是否按下了上下键，然后将动作和瞄准设置为适当的值。
- en: Repeat the last step for the right key with the values accordingly. The player
    will now be able to move left and right.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相应的值重复上一步，为右键添加相同的检查。玩家现在可以向左和向右移动了。
- en: 'All we need now is to add in the jump. Immediately after the previous code
    add:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要添加跳跃。在上一个代码之后立即添加：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We check to see if the jump key has been pressed and if the player is on the
    ground or not. If this is true, we set the vertical speed upwards to the maximum
    gravity and set the action to `INAIR`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查跳跃键是否被按下，以及玩家是否在地面上。如果是，我们就将垂直速度向上设置为最大重力，并将动作设置为`INAIR`。
- en: 'The ground controls are now complete; here is what `scr_Player_GroundControls`
    should look like:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地面控制现在已经完成；这就是`scr_Player_GroundControls`应该看起来的样子：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's move onto the player attack. First we need to build the Bullet, so create
    a new Sprite, `spr_Bullet`, and load `Chapter 5/Sprites/Bullet.gif` with **Remove
    Background** checked. Center the **Origin** and then click on **OK**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续进行玩家攻击。首先我们需要构建子弹，所以创建一个新的精灵，`spr_Bullet`，并加载`Chapter 5/Sprites/Bullet.gif`，勾选**去除背景**。居中**原点**，然后点击**确定**。
- en: Create a new Object, `obj_Bullet`, and apply `spr_Bullet` as the **Sprite**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Bullet`，并将`spr_Bullet`应用为**精灵**。
- en: We will want the Bullet to always be in front of everything, so set the **Depth**
    to `-2000`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望子弹始终在所有物体的前面，所以将**深度**设置为`-2000`。
- en: 'We are now done with the Bullet and can now write the attack code. Create a
    new Script, `scr_Player_Attack`, and write the following:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了子弹，可以编写攻击代码了。创建一个新的脚本，`scr_Player_Attack`，并写下以下内容：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We start by checking to see if the attack key is pressed and whether the player
    is allowed to shoot. If so, we create an instance of the Bullet from the tip of
    the gun and capture the unique ID into a variable. The horizontal position of
    this Bullet uses the facing variable to offset it to the left or right. We set
    the speed of the Bullet and then set the direction and image rotation to where
    the player is aiming. We then set an alarm which will be used to reset the `canFire`
    variable, which we are changing to `false`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查攻击键是否被按下，以及玩家是否被允许射击。如果是，我们就从枪口创建一个子弹实例，并将唯一的ID捕获到一个变量中。这个子弹的水平位置使用面向变量来偏移它向左或向右。我们设置子弹的速度，然后设置方向和图像旋转到玩家瞄准的位置。然后我们设置一个警报，用于重置`canFire`变量，我们将其更改为`false`。
- en: 'At this point we have several scripts for movement, attacking, and animation,
    but none of them have been applied. To do this we need one more script, `scr_Player_Step`,
    calling the other scripts as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们已经有了几个用于移动、攻击和动画的脚本，但还没有应用它们。为了做到这一点，我们需要另一个脚本，`scr_Player_Step`，调用其他脚本如下：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First we determine what controls we need to use by seeing if the player is on
    the ground or not. We then run the appropriate control script, followed by the
    attack script and finally the animation controls.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过检查玩家是否在地面上来确定需要使用哪些控制。然后我们运行适当的控制脚本，然后是攻击脚本，最后是动画控制。
- en: In `obj_Player`, add a **Step** | **Step** event and apply `scr_Player_Step`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，添加一个**Step** | **Step**事件，并应用`scr_Player_Step`。
- en: Before we test this out, we still need to reset that alarm. Create a new Script,
    `scr_Player_Alarm0`, and set `canFire` to `true`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试之前，我们仍然需要重置那个警报。创建一个新脚本，`scr_Player_Alarm0`，并将`canFire`设置为`true`。
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add an **Alarm** | **Alarm 0** event and apply this script.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Alarm** | **Alarm 0**事件，并应用此脚本。
- en: 'The player is ready to be tested. To ensure that you have the player set up
    properly, it should look like the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家已经准备好测试。为了确保您已经正确设置了玩家，它应该看起来像下面的截图：
- en: '![Building the player](img/4100_05_03.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![构建玩家](img/4100_05_03.jpg)'
- en: Setting up the room
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置房间
- en: 'We have the player, now we need a world to place it in. Since we are making
    a platformer, we are going to use two types of building block: a ground object
    and a platform object. The ground will be impassable to the player and will be
    used for the outer perimeter. The platform object will allow the player to jump
    through and then land upon it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了玩家，现在我们需要一个世界来放置它。由于我们正在制作一个平台游戏，我们将使用两种类型的构建块：地面对象和平台对象。地面将对玩家不可通过，并将用于外围。平台对象将允许玩家跳过并着陆在上面：
- en: Create a new Sprite, `spr_Ground`, and load `Chapter 5/Sprites/Ground.gif` with
    **Remove Background** not checked. Click **OK**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，`spr_Ground`，并加载`Chapter 5/Sprites/Ground.gif`，不勾选**Remove Background**。点击**OK**。
- en: Create a new Object, `obj_Ground`, and assign `spr_Ground` as the **Sprite**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Ground`，并将`spr_Ground`分配为**Sprite**。
- en: Check the box for **Solid**. This is necessary as our collision code is looking
    for solid objects.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**Solid**框。这是必要的，因为我们的碰撞代码正在寻找实心物体。
- en: Let's test this out. Create a new Room, and under the **Settings** tab, change
    the name to `BossArena` and change the **Width** to `800`. We will want a good
    size room to fight in.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来测试一下。创建一个新房间，在**Settings**选项卡下，将名称更改为`BossArena`，将**Width**更改为`800`。我们希望有一个足够大的房间来进行战斗。
- en: Add instances of `obj_Ground` around the border of the room. Also add a single
    instance of `obj_Player` near the floor of the room.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在房间的边界周围添加`obj_Ground`的实例。还在房间的地板附近添加一个`obj_Player`的单个实例。
- en: Run the game. At this point the player should be able to run and jump around
    the room, but not be able to pass through the walls or floor. You should also
    be able to shoot your weapon in a variety of directions. Also notice that the
    animation system is working as intended, with sprites changing based on the player's
    actions.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。此时，玩家应该能够在房间内奔跑和跳跃，但不能穿过墙壁或地板。您还应该能够以各种方向射击武器。还要注意，动画系统正在按预期工作，精灵根据玩家的动作而改变。
- en: Now to build the platforms. Create a new Sprite, `spr_Platform`, and load `Chapter
    5/Sprites/Platform.gif` with **Remove Background** not checked. Click on **OK**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来构建平台。创建一个新的精灵，`spr_Platform`，并加载`Chapter 5/Sprites/Platform.gif`，不勾选**Remove
    Background**。点击**OK**。
- en: Create a new Object, `obj_Platform`, and assign `spr_Platform` as the **Sprite**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Platform`，并将`spr_Platform`分配为**Sprite**。
- en: 'We want the platform to be solid only when the player is above it. For this
    we will need to create a new Script, `scr_Platform_EndStep`, with the following
    code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望平台只在玩家在其上方时才是实心的。为此，我们需要创建一个新脚本，`scr_Platform_EndStep`，其中包含以下代码：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we compare the player's Y coordinate with the Y coordinate of the instance.
    If the player is above it, then the platform should be solid. Otherwise it is
    not solid and the player can jump through it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将玩家的Y坐标与实例的Y坐标进行比较。如果玩家在上面，那么平台应该是实心的。否则它不是实心的，玩家可以跳过它。
- en: In `obj_Platform`, add a **Step** | **End Step** event and apply this script.
    We run this code at the end of the step because we want to change only after the
    player has actually moved, but before it does another forecast.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Platform`中，添加一个**Step** | **End Step**事件，并应用此脚本。我们在步骤结束时运行此代码，因为我们只想在玩家实际移动之后，但在它进行另一个预测之前进行更改。
- en: Go back into the `BossArena` and add some platforms for the player to jump onto.
    The player can only jump around 128 pixels, so make sure the platforms are placed
    appropriately, such as can be seen below.![Setting up the room](img/4100_05_04.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`BossArena`并添加一些玩家可以跳上的平台。玩家只能跳大约128像素，因此确保平台放置得当，如下所示。![设置房间](img/4100_05_04.jpg)
- en: Run the game. The player should be able to jump through the platforms and land
    on top.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。玩家应该能够跳过平台并站在上面。
- en: We have successfully developed a series of systems for a platforming game. It
    required us to separate common elements such as the animation system and controls
    into unique scripts. If we were to stop here, it may feel like we did a lot of
    extra work for nothing. However, as we start building our boss battle, we will
    start reaping the rewards for this effort.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功为平台游戏开发了一系列系统。这要求我们将动画系统和控制等常见元素分离为独特的脚本。如果我们停在这里，可能会感觉做了很多额外的工作却毫无意义。然而，当我们开始构建Boss战时，我们将开始收获这一努力的回报。
- en: Building a boss battle
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Boss战
- en: Boss battles are one of the most enjoyable experiences in games. Building a
    good boss battle is always a challenge, but the theory behind it is quite simple.
    The first rule to follow is that a boss should consist of three unique stages
    of increasing difficulty. The second rule is that the boss should emphasize the
    latest skills that the user has acquired. The third and final rule is that the
    player should always have something to do.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Boss战是游戏中最令人愉快的体验之一。构建一个好的Boss战总是一个挑战，但其背后的理论却非常简单。遵循的第一条规则是，Boss应该由三个不断增加难度的独特阶段组成。第二条规则是，Boss应该强调用户最新掌握的技能。第三条也是最后一条规则是，玩家应该始终有事可做。
- en: Our boss battle will not be against another character, but against a fortress.
    The first stage will consist of three retractable Cannons that will shoot Cannonballs
    across the room. All three Cannons must be destroyed to move onto the second stage.
    Stage two will have a powerful LaserCannon that will move up and down and shoot
    a room wide Laser Beam that the player will need to avoid. The final stage will
    be to destroy the Boss Core that is protected by two Shields. The Shields will
    only be open for a short period of time. During the entire boss fight, there will
    be an indestructible Gun that will shoot bullets at the player wherever they are
    in the room. Each progressing stage, this Gun will fire more rapidly, making the
    game more challenging. Let's start building the boss!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的boss战将不是与另一个角色对抗，而是与一座堡垒对抗。第一阶段将包括三门可伸缩的大炮，它们将在房间各处发射炮弹。必须摧毁所有三门大炮才能进入第二阶段。第二阶段将有一门强大的激光炮，它将上下移动并发射全屋范围的激光束，玩家需要避开。最后一阶段将是摧毁由两个护盾保护的boss核心。护盾只会在短时间内打开。在整个boss战中，将有一把不可摧毁的枪，它将在房间中的任何位置向玩家射击子弹。随着每个阶段的进行，这把枪将射击得更加频繁，使游戏更具挑战性。让我们开始建立boss！
- en: Creating the indestructible Gun
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建不可摧毁的枪
- en: 'We will start with the indestructible Gun since it will be the primary boss
    attack through the battle. The Gun will need to rotate so that it always points
    towards the player. When it shoots a Gun Bullet, the instance of the Gun Bullet
    will come from the tip of the Gun and move in the direction that the Gun is pointing:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从不可摧毁的枪开始，因为它将是整个战斗中的主要boss攻击。枪需要旋转，以便始终指向玩家。当它射出枪子弹时，枪子弹的实例将从枪的尖端出现，并朝着枪指向的方向移动。
- en: Let's start by building the Gun Bullet. Create a new Sprite, `spr_Gun_Bullet`,
    and load `Chapter 5/Sprites/Gun_Bullet.gif` with **Remove Background** checked.
    Center the **Origin** and click on **OK**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从构建枪子弹开始。创建一个新精灵，`spr_Gun_Bullet`，并加载`Chapter 5/Sprites/Gun_Bullet.gif`，勾选**删除背景**。将**原点**居中，然后点击**确定**。
- en: Create a new Object, `obj_Gun_Bullet`, and assign `spr_Gun_Bullet` as the **Sprite**.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Gun_Bullet`，并将`spr_Gun_Bullet`分配为**精灵**。
- en: We want the bullets to always appear on top of the ground and platforms. Set
    the **Depth** to -`2000`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望子弹始终出现在地面和平台的上方。将**深度**设置为-`2000`。
- en: 'The Gun Bullet is going to damage the player on contact, as will all the other
    projectiles. Once again, let''s build a single system that all weapons can use.
    Create a new Script, `scr_Damage`, with the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枪子弹将在接触时对玩家造成伤害，所有其他抛射物也是如此。让我们再次建立一个所有武器都可以使用的单一系统。创建一个新脚本，`scr_Damage`，其中包含以下代码：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This script is specifically for the enemy weapons. We start by checking to see
    if the player is not already damaged so that the player isn't punished repetitively.
    Then we reduce the global health by the value indicated by the variable `myDamage`.
    By using a variable like this, we can have different weapons apply differing amounts
    of damage. We then affect the player directly through a `with` statement. We want
    to launch the player into the air, but first we need to raise the player off the
    ground by one pixel first to ensure the ground collision code doesn't snap it
    back down. Next we apply a vertical velocity and a horizontal velocity in the
    opposite direction that they are facing for a push back effect. We set the player's
    action to the `DAMAGE` state and indicate that damage has happened.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本专门用于敌人的武器。我们首先检查玩家是否已经受伤，以免玩家受到重复惩罚。然后我们通过变量`myDamage`减少全局生命值。通过使用这样的变量，我们可以让不同的武器造成不同数量的伤害。然后我们通过`with`语句直接影响玩家。我们想要将玩家抛入空中，但首先我们需要将玩家提高一像素以确保地面碰撞代码不会将其弹回。接下来我们施加垂直速度和水平速度，以相反的方向推开。我们将玩家的动作设置为`DAMAGE`状态，并指示发生了伤害。
- en: Create another new Script, `scr_Gun_Bullet_Create`, and initialize the `myDamage`
    variable. Then apply it to a **Create** event in `obj_Gun_Bullet`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个新脚本，`scr_Gun_Bullet_Create`，并初始化`myDamage`变量。然后将其应用于`obj_Gun_Bullet`的**创建**事件。
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next let''s create a collision script, `scr_Gun_Bullet_Collision`, which calls
    the damage script and removes the Bullet. We did not put the destruction of the
    instance into `scr_Damage` so that we have the option for weapons that can''t
    be destroyed, use this script:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来让我们创建一个碰撞脚本，`scr_Gun_Bullet_Collision`，它调用伤害脚本并移除子弹。我们没有将实例的销毁放入`scr_Damage`中，这样我们就可以选择无法被摧毁的武器使用这个脚本：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can now add a **Collision** | **obj_Player** event to `obj_Gun_Bullet` with
    this script attached. The Gun Bullet is now complete.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在附有此脚本的`obj_Gun_Bullet`上添加一个**碰撞**|**obj_Player**事件。枪子弹现在已经完成。
- en: We can now move onto the Gun itself. Start by creating two new Sprites, `spr_Gun_Idle`
    and `spr_Gun_Run`. Load `Chapter 5/Sprites/Gun_Idle.gif` and `Chapter 5/Sprites/Gun_Run.gif`
    to their associated sprite with **Remove Background** checked.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以移动到枪本身。首先创建两个新的精灵，`spr_Gun_Idle`和`spr_Gun_Run`。加载`Chapter 5/Sprites/Gun_Idle.gif`和`Chapter
    5/Sprites/Gun_Run.gif`到它们关联的精灵中，勾选**删除背景**。
- en: 'The Gun sprite has the barrel facing to the right so we need to set the origin
    on the left side so that it pivots properly. Set the **Origin** to **X**: `0`
    and **Y**: `16` on both sprites and click on **OK**.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枪精灵的枪管朝右，所以我们需要在左侧设置原点，以便正确地进行旋转。在两个精灵上将**原点**设置为**X**:`0`和**Y**:`16`，然后点击**确定**。
- en: Create a new Object, `obj_Gun`, and assign `spr_Gun_Idle` as the **Sprite**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Gun`，并将`spr_Gun_Idle`分配为**精灵**。
- en: We will want to make sure that the Gun remains visually on top of the Boss at
    all times so set the **Depth** to `-1000`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望确保枪始终在boss的视觉上方，所以将**深度**设置为`-1000`。
- en: 'We need to initialize some variables in a new Script, `scr_Gun_Create`, which
    will be added to `obj_Gun` as a **Create** event:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在一个新脚本`scr_Gun_Create`中初始化一些变量，然后将其添加到`obj_Gun`作为**创建**事件：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will be using the animation system here, so we need to set values for the
    action and facing variables which are required. The following four variables relate
    to the shooting of the Gun. First is `tipOfGun` for where the end of the barrel
    is located, `canFire` is the trigger, `delay` is how long to pause between shots,
    and the alarm will shoot the Gun Bullet. Finally, we have two states of animation
    that we need to apply. We do not need to add all the other variables such as `myDamage`
    unless the object utilizes that state.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用动画系统，因此需要设置所需的动作和面向变量的值。以下四个变量与枪的射击有关。首先是`tipOfGun`，用于确定枪口的位置，`canFire`是触发器，`delay`是射击间隔时间，警报将发射枪子弹。最后，我们有两种动画状态需要应用。除非对象使用该状态，否则我们不需要添加所有其他变量，如`myDamage`。
- en: 'Next we will have the Gun track the player and determine when to shoot. Create
    a new Script, `scr_Gun_Step`, which will be placed in a **Step** | **Step** event.
    Here''s the code we need:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将让枪跟踪玩家并确定何时射击。创建一个新的脚本，`scr_Gun_Step`，将其放置在**步骤** | **步骤**事件中。以下是我们需要的代码：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start by running the animation script. We want the Gun to play the firing
    animation only once, so we check the currently displayed image against the last
    image of the sprite. Using `image_number` gives us the number of frames, but we
    need to subtract by one as frames of animation start at zero. If it is the last
    frame, then the Gun goes into the `IDLE` state. Next we check to see if the Gun
    is to shoot. If it is, we change states to play the shooting animation, set a
    second alarm for 5 frames, and then turn off `canFire`. Finally we track the player
    by rotating the sprite based on the angle between the Gun and the player.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先运行动画脚本。我们希望枪只播放一次射击动画，因此我们将当前显示的图像与精灵的最后一个图像进行比较。使用`image_number`可以得到帧数，但由于动画帧从零开始，我们需要减去一。如果是最后一帧，那么枪就进入“空闲”状态。接下来，我们检查枪是否要射击。如果是，我们改变状态以播放射击动画，设置第二个警报为5帧，然后关闭`canFire`。最后，我们通过根据枪和玩家之间的角度旋转精灵来跟踪玩家。
- en: 'We are using two alarms on this object. The first alarm starts the firing animation
    and the second creates the Gun Bullet. Let''s start with the first alarm by creating
    a new Script, `scr_Gun_Alarm0`, for an **Alarm** | **Alarm 0** event:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个对象上使用了两个警报。第一个警报开始射击动画，第二个创建枪子弹。让我们从第一个警报开始，创建一个新的脚本，`scr_Gun_Alarm0`，用于**警报**
    | **警报 0**事件：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second alarm has the code for firing the Gun Bullet. Create a new Script,
    `scr_Gun_Alarm1`, that will be added as an **Alarm** | **Alarm 1** event:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个警报包含了开枪的代码。创建一个新的脚本，`scr_Gun_Alarm1`，将其添加为**警报** | **警报 1**事件：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we need the bullet to leave the end of the barrel of the gun we are going
    to need some trigonometry. We could use sine and cosine to calculate the X and
    Y values from the origin of the circle and radial distance, but there is a much
    easier way. Here we are using `lengthdir_x` and `lengthdir_y` to do the math for
    us. All that it needs is the radial distance and the angle which we can then add
    to the local coordinates of the Gun. Once we have those variables, we can create
    the bullet in the proper position, set its speed, and direction. Finally we reset
    the first alarm so that the Gun will fire again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要子弹离开枪口，我们需要一些三角函数。我们可以使用正弦和余弦来计算X和Y值，但有一个更简单的方法。在这里，我们使用`lengthdir_x`和`lengthdir_y`来为我们进行数学计算。它所需要的只是径向距离和角度，然后我们可以将其添加到枪的本地坐标中。一旦我们有了这些变量，我们就可以在正确的位置创建子弹，设置其速度和方向。最后，我们重置第一个警报，以便枪再次开火。
- en: We are ready to test the Gun. Open BossArena and place an instance of the Gun
    on the far right side of the room. Once we are done testing we will be removing
    the gun from the room, so exact placement doesn't matter at this time.![Creating
    the indestructible Gun](img/4100_05_05.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备测试枪。打开BossArena并在房间的最右侧放置一把枪的实例。一旦测试完成，我们将从房间中移除枪，因此此时确切的放置位置并不重要。![创建不可摧毁的枪](img/4100_05_05.jpg)
- en: Run the Game. The Gun should follow the player wherever they are in the room
    and fire Gun Bullets every three seconds. If the player is hit by a Gun Bullet,
    they will be launched into the air and pushed back with the damage animation playing
    as seen in the previous screenshot.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。枪应该会跟随玩家在房间中的任何位置，并且每三秒发射一次枪子弹。如果玩家被枪子弹击中，他们将被击飞并受到伤害动画的影响，就像在之前的截图中看到的那样。
- en: 'There is one issue, however, with the player''s damage state; the player can
    still move and shoot. This isn''t much of a deterrent to being shot, so let''s
    fix this. Create a new Script, `scr_Player_Damage`, with the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，玩家的伤害状态存在一个问题；玩家仍然可以移动和射击。这对于被射击并不是多大的威慑力，因此让我们解决这个问题。创建一个新的脚本，`scr_Player_Damage`，其中包含以下代码：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We check to see if the player is on the ground or not as that will deactivate
    the damage state. If the player is in the air, we apply gravity and that is it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查玩家是否在地面上，因为这将停用伤害状态。如果玩家在空中，我们施加重力，就这样。
- en: 'Now we need to call this script. Reopen `scr_Player_Step` and add a conditional
    statement for whether the player is damaged or not. Here is the entire script
    with the new code in bold:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要调用这个脚本。重新打开`scr_Player_Step`，并添加一个条件语句，用于判断玩家是否受伤。以下是包含新代码的整个脚本，新代码用粗体标出：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We check to see if the player is in damage mode, and if it is, we run the damage
    script. Otherwise, we function as normal with all the control systems in the `else`
    statement. The animation script is always called regardless of damage.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查玩家是否处于伤害模式，如果是，我们运行伤害脚本。否则，我们像平常一样使用所有控制系统在`else`语句中。无论是否受伤，动画脚本都会被调用。
- en: Run the game. Now when the player is hit, the impact is really noticeable.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。现在当玩家被击中时，冲击效果非常明显。
- en: 'Constructing the first phase: The Cannons'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建第一阶段：大炮
- en: 'The first stage weapon is a Cannon that hides itself for protection and only
    exposes itself to shoot. We will have three Cannons stacked on top of each other
    to make the player have to jump onto platforms. To destroy the Cannons the player
    will need to shoot each Cannon while it is exposed:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段的武器是一个大炮，它会隐藏自己以保护自己，只有在射击时才会暴露出来。我们将有三门大炮堆叠在一起，使玩家必须跳上平台。要摧毁大炮，玩家需要在大炮暴露时射击每门大炮：
- en: Starting with the Cannonball, create a new Sprite, `spr_Cannonball`, and load
    `Chapter 5/Sprites/Cannonball.gif` with **Remove Background** checked.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Cannonball开始，创建一个新的精灵`spr_Cannonball`，并加载`Chapter 5/Sprites/Cannonball.gif`，勾选**Remove
    Background**。
- en: 'Set the **Origin** to **X**: `12`, **Y**: `32` and click on **OK**.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Origin**设置为**X**:`12`，**Y**:`32`，然后点击**OK**。
- en: Create a new Object, `obj_Cannonball`, and assign `spr_Cannonball` as the **Sprite**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象`obj_Cannonball`，并将`spr_Cannonball`分配为**Sprite**。
- en: Set the **Depth** to `-900` so that it will appear in front of most objects.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Depth**设置为`-900`，这样它将出现在大多数对象的前面。
- en: 'To use the damage system, we need to set the proper variables in the **Create**
    event with a new script, `scr_Cannonball_Create`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用伤害系统，我们需要在**Create**事件中设置正确的变量，使用一个新的脚本`scr_Cannonball_Create`：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This weapon is powerful and will cause 10 points of damage. We also set the
    horizontal velocity so that it quickly moves across the room.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个武器很强大，会造成10点伤害。我们还设置了水平速度，以便它可以快速穿过房间。
- en: We are not going to destroy the Cannonball if it contacts the player, so all
    we need to do is apply `scr_Damage` to a **Collision** | **obj_Player** event.
    The Cannonball is now ready to be shot.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Cannonball接触到玩家，我们不会摧毁它，所以我们只需要在**Collision** | **obj_Player**事件中应用`scr_Damage`。Cannonball现在已经准备好被射击。
- en: The Cannon is going to need five sprites, `spr_Cannon_IdleDown`, `spr_Cannon_IdleUp`,
    `spr_Cannon_RunDown`, `spr_Cannon_RunUp`, and `spr_Cannon_Damage`. Load the associated
    files from the `Chapter 5/Sprites/` folder without checking **Remove Background**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大炮将需要五个精灵，`spr_Cannon_IdleDown`，`spr_Cannon_IdleUp`，`spr_Cannon_RunDown`，`spr_Cannon_RunUp`和`spr_Cannon_Damage`。从`Chapter
    5/Sprites/`文件夹加载相关文件，不勾选**Remove Background**。
- en: Create a new Object, `obj_Cannon`, and assign `spr_Cannon_IdleDown` as the **Sprite**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象`obj_Cannon`，并将`spr_Cannon_IdleDown`分配为**Sprite**。
- en: Set the **Depth** to `-1000` so that the Cannon will be in front of the rest
    of the Boss parts.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Depth**设置为`-1000`，这样大炮将位于其他Boss部件的前面。
- en: 'As always, let''s create a new Script, `scr_Cannon_Create`, to initialize all
    the variables in the **Create** event:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，让我们创建一个新的脚本`scr_Cannon_Create`，在**Create**事件中初始化所有变量。
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Cannon will take several hits before it is destroyed, so we have a `myHealth`
    variable to track the damage. We then set the action state by facing to the right,
    as we are not flipping the sprite, and establish a shooting variable. We then
    have all the animation states we need for the Cannon to work.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 大炮在被摧毁之前需要承受多次打击，所以我们有一个`myHealth`变量来跟踪伤害。然后通过面向右侧来设置动作状态，因为我们不会翻转精灵，并建立一个射击变量。然后我们有了大炮工作所需的所有动画状态。
- en: 'Next we can create a new Script, `scr_Cannon_Step`, for a **Step** | **Step**
    event with the functionality for switching states and firing the Cannonballs:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们可以创建一个新的脚本`scr_Cannon_Step`，在**Step** | **Step**事件中实现切换状态和发射Cannonballs的功能：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Similar to the Gun, we start with calling the animation system script. We then
    check if the Cannon is on the last frame of the animation. Here we have two different
    idle states depending on whether the Cannon is exposed or not. We check to see
    which state we are in and set the appropriate idle state. Next we check if the
    Cannon should shoot, and if it should, we expose the Cannon and set an alarm to
    create the Cannonball in two seconds. Finally, we do a health check and if the
    Cannon is out of life, it removes itself from the game.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与枪类似，我们首先调用动画系统脚本。然后检查大炮是否在动画的最后一帧。这里有两种不同的空闲状态，取决于大炮是否暴露出来。我们检查我们处于哪种状态，并设置适当的空闲状态。接下来，我们检查大炮是否应该射击，如果应该，我们就会暴露大炮，并设置一个警报，在两秒后创建Cannonball。最后，我们进行健康检查，如果大炮没有生命力了，它就会从游戏中移除。
- en: 'Create a new Script, `scr_Cannon_Alarm0`, and add it to an **Alarm** | **Alarm
    0** event with the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本`scr_Cannon_Alarm0`，并将其添加到**Alarm** | **Alarm 0**事件中，使用以下代码：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here we just create a Cannonball and then set the animation to retract the Cannon.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们只是创建一个Cannonball，然后设置动画以收回大炮。
- en: 'The last thing we need to do with the Cannon is have it take damage. Create
    a new Script, `scr_Cannon_Collision`, and apply it to a **Collision** | **obj_Bullet**
    event with the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大炮的最后一件事是承受伤害。创建一个新的脚本`scr_Cannon_Collision`，并将其应用到**Collision** | **obj_Bullet**事件中，使用以下代码：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start by making sure that damage will only be applied if the Cannon is exposed.
    If it is, then we take 10 points of its health, change to the damage animation,
    and remove the bullet. The Cannon is now complete.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保只有在大炮暴露时才会应用伤害。如果是的话，我们就会减少它的10点生命值，切换到伤害动画，并移除子弹。大炮现在已经完成。
- en: Before we try to test the Cannon out, we are going to start constructing the
    Boss. The Cannon doesn't run on its own, but is controlled by the Boss. Create
    a new Object called `obj_Boss`. There is no sprite to assign as the Boss is comprised
    of other objects.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们尝试测试大炮之前，我们将开始构建Boss。大炮不能自行运行，而是由Boss控制。创建一个名为`obj_Boss`的新对象。没有精灵可分配，因为Boss由其他对象组成。
- en: 'Create a new Script, `scr_Boss_Create`, to initialize variables in the **Create**
    event:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本`scr_Boss_Create`，在**Create**事件中初始化变量：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by establishing variables for the three phases and whether the boss
    has been defeated. We then create a variable for the X location of the boss with
    the indestructible Gun located in the upper left corner of the room and a tower
    of Cannons right where the Boss is. We establish variables for each weapon so
    that the Boss can control them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先建立了三个阶段和Boss是否被击败的变量。然后创建了一个Boss的X位置变量，其中包括不可摧毁的位于房间左上角的枪和Boss所在位置的一堆大炮。我们为Boss的每个武器建立变量，以便Boss可以控制它们。
- en: We want the Cannons to shoot in a sequence rather than all together. To do this
    we are going to use a Time Line. Create a new Time Line and name it `tm_Boss_Phase01`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望大炮按顺序射击，而不是一起射击。为此，我们将使用时间轴。创建一个新的时间轴并命名为`tm_Boss_Phase01`。
- en: Add a **Moment** and set **Indicate the moment** to `180`. This will start six
    seconds into the battle.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**时刻**，并将**指示时刻**设置为`180`。这将在战斗开始后的六秒钟内开始。
- en: 'Create a new Script, `scr_Phase01_180`, and fire the middle Cannon. Apply this
    script to the Time Line:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Phase01_180`，并发射中间的大炮。将此脚本应用于时间轴：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since the player can destroy the Cannons, we need to check to see if the Cannon
    is still in existence. If it is, we set the Cannon's `canFire` variable to true
    and the Cannon code will handle the rest.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家可以摧毁大炮，我们需要检查大炮是否仍然存在。如果是，我们将大炮的`canFire`变量设置为true，大炮的代码将处理其余部分。
- en: Add another **Moment** at `360`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`360`处添加另一个**时刻**。
- en: 'Create a Script, `scr_Phase01_360`, and activate the other two Cannons:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个脚本，`scr_Phase01_360`，并激活另外两门大炮：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We need to check both Cannons individually so that if one is destroyed, the
    other will still shoot.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分别检查两门大炮，以便如果其中一门被摧毁，另一门仍然会射击。
- en: 'Reopen `scr_Boss_Create` and start a looping Time Line after the last line
    of code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Boss_Create`，并在代码的最后开始一个循环时间轴：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Reopen `BossArena` and make sure you remove the instance of the Gun if it is
    still in the room.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`BossArena`，确保如果房间内仍有枪的实例，则将其移除。
- en: Place an instance of `obj_Boss` on the right side of the map, though the actual
    location does not matter.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地图的右侧放置一个`obj_Boss`的实例，实际位置并不重要。
- en: 'None of the parts of the Boss have the **Solid** attribute, which means the
    player can run through them. To fix that, create a barrier wall in front of the
    Boss with instances of `obj_Ground` as seen in the following screenshot:![Constructing
    the first phase: The Cannons](img/4100_05_06.jpg)'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boss的任何部分都没有**固体**属性，这意味着玩家可以穿过它们。为了解决这个问题，在Boss的前面创建一个障碍墙，使用`obj_Ground`的实例，如下截图所示：![构建第一阶段：大炮](img/4100_05_06.jpg)
- en: 'Run the game. At the start we should see three Cannons stacked on top of each
    other and the indestructible Gun. The Gun should aim at the player and shoot a
    Gun Bullet every few seconds. Six seconds into the game we should see the middle
    Cannon power up and shortly afterwards shoot a Cannonball. Six seconds after that,
    the upper and lower Cannons should do the same. If the player is hit by an enemy
    projectile they will be knocked back. The player''s bullets will pass by the Cannons
    unless they have been exposed, in which case the Cannon will go into its damage
    state and the bullet disappears. If any Cannon is hit two separate times it will
    blink out of existence. The first phase is now complete and should look like the
    following screenshot:![Constructing the first phase: The Cannons](img/4100_05_07.jpg)'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。在开始时，我们应该看到三门大炮堆叠在一起，还有一个不可摧毁的枪。枪应该瞄准玩家，并每隔几秒钟射出一颗子弹。游戏进行到第六秒时，我们应该看到中间的大炮开始充能，并很快射出一颗炮弹。再过六秒，上下两门大炮也应该做同样的动作。如果玩家被敌人的抛射物击中，他们会被击退。玩家的子弹会从大炮旁边飞过，除非它们被暴露，此时大炮将进入受损状态，子弹会消失。如果任何一门大炮被击中两次，它将消失。第一阶段现在已经完成，应该看起来像下面的截图：![构建第一阶段：大炮](img/4100_05_07.jpg)
- en: 'Building the second phase: The giant LaserCannon'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建第二阶段：巨大的激光炮
- en: 'Once the player destroys all the Cannons, the second phase will begin. Here
    we will have a giant LaserCannon that moves constantly up and down. Every few
    seconds it will fire a large Laser Beam that will stretch across the entire room.
    The player can damage the LaserCannon at all times, though it will have much more
    health:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家摧毁了所有的大炮，第二阶段就会开始。在这里，我们将有一个巨大的激光炮，不断上下移动。每隔几秒钟，它将发射一道横跨整个房间的巨大激光束。玩家可以随时对激光炮造成伤害，尽管它的生命值要多得多：
- en: First we will create the Laser Beam. Create a new Sprite, `spr_LaserBeam`, and
    load `Chapter 5/Sprites/LaserBeam.gif` without checking **Remove Background**.
    The sprite may appear small, being only eight pixels wide, but we will stretch
    this sprite across the screen so it could work in any room.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们将创建激光束。创建一个新的精灵，`spr_LaserBeam`，并加载`Chapter 5/Sprites/LaserBeam.gif`，不勾选**移除背景**。精灵可能看起来很小，只有八个像素宽，但我们将把这个精灵拉伸到整个屏幕，这样它可以在任何房间中使用。
- en: 'We need the origin to be on the right side so that it lines up with the LaserCannon
    barrel properly. Set the **Origin** to **X**: `8` and **Y**: `32`.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将原点放在右侧，以便与激光炮的枪管正确对齐。将**原点**设置为**X**：`8`，**Y**：`32`。
- en: Create a new Object, `obj_LaserBeam`, apply `spr_LaserBeam` as the **Sprite**
    and set the **Depth** to `-600`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_LaserBeam`，应用`spr_LaserBeam`作为**精灵**，并将**深度**设置为`-600`。
- en: 'Create a new Script, `scr_LaserBeam_Create`, to initialize variables in a **Create**
    event:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_LaserBeam_Create`，在**创建**事件中初始化变量：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The amount of damage from this weapon is much higher than the other weapons,
    which is fitting for the second phase. We also have a `myLaserCannon` variable
    that will be used to keep the Laser Beam aligned with the LaserCannon as it moves.
    The value has been set to zero, though this will become the ID of the LaserCannon
    that spawns it, which we will get to in a moment. Finally, we stretch the sprite
    across the room. The variable `image_xscale` is a multiplier, which is why we
    are dividing the room width by eight, the width of the sprite.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个武器的伤害量比其他武器高得多，这非常适合第二阶段。我们还有一个`myLaserCannon`变量，将用于使激光束与移动的激光炮保持对齐。该值已设置为零，尽管这将成为生成它的激光炮的ID，我们稍后会讨论。最后，我们将精灵拉伸到整个房间。变量`image_xscale`是一个乘数，这就是为什么我们要将房间宽度除以八，即精灵的宽度。
- en: Next we will use a **Step** | **End Step** event with a new Script, `scr_LaserBeam_EndStep`,
    to make the beam move with the LaserCannon.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用一个**步骤** | **结束步骤**事件，使用一个新的脚本`scr_LaserBeam_EndStep`，使激光炮的激光束移动。
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We move the X and Y coordinates with the LaserCannon that creates the Laser
    Beam. We are placing this into the **End Step** event because the LaserCannon
    will move on a **Step** event and this will ensure that it is always in the correct
    position.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用创建激光束的激光炮的X和Y坐标。我们将其放入**End Step**事件中，因为激光炮将在**Step**事件中移动，这将确保它始终处于正确的位置。
- en: All that is left is for `scr_Damage` to be added to a **Collision** | **obj_Player**
    event. The Laser Beam is now complete.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只剩下将`scr_Damage`添加到**Collision** | **obj_Player**事件中。激光束现在已经完成。
- en: 'Moving onto the LaserCannon, we will need to create three sprites: `spr_LaserCannon_Idle`,
    `spr_LaserCannon_Run`, and `spr_LaserCannon_Damage`. Load the associated files
    from the `Chapter 5/Sprites/` folder all of which need to have **Remove Background**
    checked.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是激光炮，我们需要创建三个精灵：`spr_LaserCannon_Idle`，`spr_LaserCannon_Run`和`spr_LaserCannon_Damage`。从`Chapter
    5/Sprites/`文件夹中加载相关文件，所有文件都需要勾选**Remove Background**。
- en: 'Set the **Origin** of all three sprites to **X**: `16` and **Y**: `56`. This
    will help place the Laser Beam where we want it to be.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有三个精灵的**Origin**设置为**X**：`16`和**Y**：`56`。这将有助于将激光束放置在我们想要的位置。
- en: Create a new Object, `obj_LaserCannon`, and assign `spr_LaserCannon _Idle` as
    the **Sprite**.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_LaserCannon`，并将`spr_LaserCannon _Idle`分配为**Sprite**。
- en: Set the **Depth** to `-700` so that the LaserCannon is behind the Cannons and
    Gun, but in front of the Laser Beam.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Depth**设置为`-700`，以便激光炮位于炮台和枪的后面，但在激光束的前面。
- en: 'For initializing variables in the **Create** event, create a new Script, `scr_Laser_Create`,
    with the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Create**事件中初始化变量，创建一个新脚本，`scr_Laser_Create`，代码如下：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We first set all the standard variables for the LaserCannon's health, current
    state, facing direction, and that it isn't shooting. We then set all the animation
    system variables for the three states that the LaserCannon has.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置激光炮的健康、当前状态、面向方向和非射击的所有标准变量。然后设置激光炮的三种状态的所有动画系统变量。
- en: 'Next is building the functionality of the laser. Create a new Script, `scr_LaserCannon_Step`,
    and add it to a **Step** | **Step** event with the following code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是构建激光的功能。创建一个新脚本，`scr_LaserCannon_Step`，并将其添加到**Step** | **Step**事件中，代码如下：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This should be starting to look quite familiar. We start by running the animation
    system script. We then check to see if the last frame of animation has played,
    and if so, set the LaserCannon to its idle state. Next, if the LaserCannon is
    to shoot, we change states and set a short alarm so that the Laser Beam is created
    after the shooting animation has played. Finally, we do a health check and remove
    the LaserCannon if it is out of health.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该开始看起来相当熟悉了。我们首先运行动画系统脚本。然后检查动画的最后一帧是否已播放，如果是，则将激光炮设置为待机状态。接下来，如果激光炮要射击，我们改变状态并设置一个短暂的警报，以便在射击动画播放后创建激光束。最后，我们进行健康检查，并在健康状况不佳时移除激光炮。
- en: We aren't done with this script yet. We still need to add in the movement. When
    the LaserCannon is first created, it will not be moving. We don't want it to start
    moving until the second phase has started. After that point we want the LaserCannon
    to take care of the vertical motion.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本还没有完成。我们仍然需要添加移动。当激光炮首次创建时，它不会移动。我们希望它在第二阶段开始后才开始移动。在那之后，我们希望激光炮负责垂直运动。
- en: 'To make the LaserCannon move up and down, all we need to do is send it in the
    opposite direction when it passes an end point. Add this code immediately after
    the last line of code in `scr_LaserCannon_Step`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让激光炮上下移动，我们只需要在它通过终点时发送相反方向的指令。在`scr_LaserCannon_Step`的最后一行代码之后立即添加以下代码：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are going to have the LaserCannon move the entire height of the room. If
    the Y coordinate is less than 64 pixels from the top, we send it downwards. If
    it is greater than 64 pixels from the bottom of the room, we send it upwards.
    We will start the movement in the Boss script in a while.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将让激光炮在整个房间的高度上移动。如果Y坐标距离顶部小于64像素，我们将其向下移动。如果距离房间底部大于64像素，我们将其向上移动。我们将在Boss脚本中开始移动。
- en: 'Let''s get the LaserCannon shooting a Laser Beam! The Laser Beam will be created
    in an **Alarm** | **Alarm 0** event with a new Script, `scr_LaserCannon_Alarm0`,
    attached with the Laser Beam creation code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让激光炮射出激光束！激光束将在**Alarm** | **Alarm 0**事件中创建，附加一个新脚本`scr_LaserCannon_Alarm0`，其中包含激光束创建的代码：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We create an instance of the beam right at the tip of the LaserCannon and then
    we set the Laser Beam's `myLaserCannon` variable to be the unique ID of the LaserCannon
    that created it. The benefit of doing this means that we could have more than
    one LaserCannon in the room if we wanted.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在激光炮的尖端创建一个激光束的实例，然后将激光束的`myLaserCannon`变量设置为创建它的激光炮的唯一ID。这样做的好处是，如果需要，我们可以在房间中放置多个激光炮。
- en: 'The last element we need to construct is the damage state. Create a new Script,
    `scr_LaserCannon_Collision`, and place it into a **Collision** | **obj_Bullet**
    event:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要构建的最后一个元素是伤害状态。创建一个新脚本，`scr_LaserCannon_Collision`，并将其放入**Collision** |
    **obj_Bullet**事件中：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Since we don't want the player to be able to destroy the LaserCannon before
    the second phase, we check what phase the Boss is currently in, to determine if
    damage should be applied or not. If the Boss is in the second phase, we reduce
    the LaserCannon's health, change it to the damage state and remove the Bullet.
    The LaserCannon is now complete and ready to be implemented into the Boss.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望玩家在第二阶段之前就能摧毁激光炮，因此我们检查Boss当前所处的阶段，以确定是否应该施加伤害。如果Boss处于第二阶段，我们会减少激光炮的生命值，将其改为受损状态并移除子弹。激光炮现在已经完整，并准备好实现到Boss中。
- en: 'The first thing we need to do is add an instance of the LaserCannon. Reopen
    `scr_Boss_Create` and insert this code before the Time Line is run:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是添加一个激光炮的实例。重新打开`scr_Boss_Create`，并在运行时间轴之前插入以下代码：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next we will build the functionality of the LaserCannon by creating a new Time
    Line and naming it `tm_Boss_Phase02`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过创建一个新的时间轴并命名为`tm_Boss_Phase02`来构建LaserCannon的功能。
- en: To shoot the Laser Beam, add a **Moment** and set **Indicate the moment** to
    `210`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发射激光束，添加一个**时刻**并将**指示时刻**设置为`210`。
- en: 'Create a new Script, `scr_Phase02_210`, and assign it with the code to activate
    the LaserCannon:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Phase02_210`，并将其与激活LaserCannon的代码分配：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We want to have full control over the duration of the LaserCannon, so we will
    use the Time Line to remove the Laser Beam. Add a **Moment** at `270`. This will
    give us a Laser Beam that lasts two seconds.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望完全控制LaserCannon的持续时间，因此我们将使用时间轴来移除激光束。在`270`处添加一个**时刻**。这将给我们一个持续两秒的激光束。
- en: Create a new Script, `scr_Phase02_270`, and remove the Laser Beam.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Phase02_270`，并移除激光束。
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When the LaserCannon shoots, it creates the `beam` variable which we can now
    use to remove it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当LaserCannon射击时，它会创建`beam`变量，现在我们可以使用它来移除它。
- en: 'All that is left is to have the Boss change from the first phase to the second
    phase. For this we will need to add a **Step** | **Step** event to `obj_Boss`
    with a new Script, `scr_Boss_Step`, assigned with the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一剩下的就是让Boss从第一阶段变为第二阶段。为此，我们需要在`obj_Boss`上添加一个**步骤**|**步骤**事件，分配一个新的脚本`scr_Boss_Step`，其中包含以下代码：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We start by checking if there are any instances of the Cannon remaining in the
    world and if they have all been destroyed, we check to see if the second phase
    has started. Upon the second phase starting, we set the LaserCannon into motion
    downwards and switch the Time Line to the new phase and reset the Time Line to
    the beginning. We are also going to make the challenge a bit more difficult by
    decreasing the delay between shots from the Gun. We end this code by changing
    `isPhase_02` to true so that this is only executed once.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查世界中是否还有Cannon的实例，如果它们都被摧毁了，我们检查第二阶段是否已经开始。第二阶段开始时，我们将LaserCannon向下移动，并切换时间轴到新阶段，并将时间轴重置到开始。我们还将通过减少Gun射击之间的延迟来增加挑战的难度。最后，我们将`isPhase_02`更改为true，以便这个代码只执行一次。
- en: 'Run the game. The gameplay starts out the same as before, but after the three
    Cannons have been destroyed, we should see the LaserCannon starts to move up and
    down and fire a Laser Beam every seven seconds. The LaserCannon can be hit at
    any time and will take several hits before being destroyed. The indestructible
    Gun should still function as before, but shoot twice as often. The second phase
    is now complete and should look like the following screenshot:![Building the second
    phase: The giant LaserCannon](img/4100_05_08.jpg)'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。游戏玩法开始与以前相同，但在三个Cannon被摧毁后，我们应该看到LaserCannon开始上下移动，并且每七秒发射一次激光束。LaserCannon可以在任何时候被击中，并且需要多次击中才能被摧毁。无法摧毁的Gun应该仍然像以前一样运行，但是射击频率增加了一倍。第二阶段现在已经完成，并且应该看起来像以下截图：![构建第二阶段：巨型LaserCannon](img/4100_05_08.jpg)
- en: 'Setting the final stage: The shielded Boss Core'
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置最终阶段：有护盾的Boss Core
- en: 'For the final stage we are not going to add another weapon, but instead we
    will create a destructible Boss Core that is protected by two Shields. The Shields
    will open every few seconds to expose the Boss Core. We will also change the Gun
    to shoot in quick bursts:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后阶段，我们不会添加另一种武器，而是创建一个受到两个护盾保护的可摧毁的Boss Core。护盾将每隔几秒打开一次，以暴露Boss Core。我们还将改变Gun，使其快速连发：
- en: We will start with the Boss Core. We need to create two new Sprites, `spr_BossCore_Idle`
    and `spr_BossCore_Damage`. With **Remove Background** checked, load `Chapter 5/Sprites/BossCore_Idle.gif`
    and `Chapter 5/Sprites/BossCore_Damage.gif` to the appropriate sprite.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从Boss Core开始。我们需要创建两个新的精灵，`spr_BossCore_Idle`和`spr_BossCore_Damage`。勾选**移除背景**，加载`Chapter
    5/Sprites/BossCore_Idle.gif`和`Chapter 5/Sprites/BossCore_Damage.gif`到相应的精灵上。
- en: 'Set the **Origin** of both sprites to **X**: `-32` and **Y**: `64` so that
    it will be properly located behind the Shields.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个精灵的**原点**设置为**X**：`-32`和**Y**：`64`，这样它们将正确地位于护盾后面。
- en: Create a new Object, `obj_BossCore`, and assign `spr_BossCore_Idle` as the **Sprite**.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_BossCore`，并将`spr_BossCore_Idle`分配为**精灵**。
- en: 'The Boss Core is a simple object that only requires some animation states and
    health. Create a new Script, `scr_BossCore_Create`, and initialize the required
    variables as follows. Remember to assign this to a **Create** event:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boss Core是一个简单的对象，只需要一些动画状态和生命值。创建一个新的脚本，`scr_BossCore_Create`，并初始化所需的变量如下。记得将其分配给**创建**事件：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We need a **Step** | **Step** event to control the animation states and deal
    with the health, so create another new Script, `scr_BossCore_Step` with the following
    code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个**步骤**|**步骤**事件来控制动画状态和处理生命值，因此创建另一个新脚本，`scr_BossCore_Step`，其中包含以下代码：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'All the Boss Core now needs is a **Collision** | **obj_Bullet** event to deal
    with damage. Create a new Script, `scr_BossCore_Collision`, and write the following
    code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boss Core现在所需要的就是一个**碰撞**|**obj_Bullet**事件来处理伤害。创建一个新的脚本，`scr_BossCore_Collision`，并编写以下代码：
- en: '[PRE54]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We first check to see if the Boss is in the final phase and that the Boss Core
    is in its idle state. If it is, we reduce the health and switch over to the damage
    animation. We also make sure that the Bullet is removed. The Boss Core is now
    complete and we can move onto the Shields.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查Boss是否处于最终阶段，并且Boss Core处于空闲状态。如果是，我们减少生命值并切换到受损动画。我们还确保子弹被移除。Boss Core现在已经完成，我们可以转移到护盾。
- en: We will have two Shields, one that lifts up and the other that will drop down.
    Let's bring in the two sprites that we will need. Create two new Sprites, `spr_Shield_Upper`
    and `spr_Shield_Lower`. Load `Chapter 5/Sprites/Shield_Upper.gif` and `Chapter
    5/Sprites/Shield_Lower.gif` to the associated sprite. Remember to check **Remove
    Background**.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将有两个护盾，一个是上升的，另一个是下降的。让我们引入我们需要的两个精灵。创建两个新的精灵，`spr_Shield_Upper`和`spr_Shield_Lower`。加载`Chapter
    5/Sprites/Shield_Upper.gif`和`Chapter 5/Sprites/Shield_Lower.gif`到相应的精灵上。记得勾选**移除背景**。
- en: 'Set the **Origin** of `spr_Shield_Upper` to **X**: `0` and **Y**: `269` so
    that the origin is on the bottom of the image. We don''t need to change the **Origin**
    of `spr_Shield_Lower`.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`spr_Shield_Upper`的**Origin**设置为**X**：`0`和**Y**：`269`，以便原点位于图像底部。我们不需要更改`spr_Shield_Lower`的**Origin**。
- en: Create two new Objects, `obj_Shield_Upper` and `obj_Shield_Lower`, and assign
    the appropriate sprites.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个新对象，`obj_Shield_Upper`和`obj_Shield_Lower`，并分配适当的精灵。
- en: On both the Shields, set the **Depth** to `-500` so that they are in front of
    the Boss Core but behind all the other parts of the Boss.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个护盾上，将**深度**设置为`-500`，这样它们就在Boss核心的前面，但在Boss的所有其他部分的后面。
- en: 'We will build the upper Shield first and we need to initialize some variables
    in a new Script, `scr_ShieldUpper_Create`, applied to a **Create** event in `obj_Shield_Upper`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先建造上层护盾，并且我们需要在一个新的脚本`scr_ShieldUpper_Create`中初始化一些变量，应用于`obj_Shield_Upper`的**Create**事件：
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first variable will activate whether the Shield is up or down. The second
    variable sets the value for how high to lift the Shield; in this case it will
    move up 64 pixels. Finally we set a variable for the movement speed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量将激活护盾是上升还是下降。第二个变量设置抬起护盾的高度值；在这种情况下，它将上升64像素。最后，我们设置一个移动速度的变量。
- en: 'The lower Shield is almost exactly the same except that it moves in the opposite
    direction. Once again, create a new Script, `scr_ShieldLower_Create`, and apply
    it to the **Create** event of `obj_Shield_Lower`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下层护盾几乎完全相同，只是移动方向相反。再次创建一个新脚本`scr_ShieldLower_Create`，并将其应用于`obj_Shield_Lower`的**Create**事件：
- en: '[PRE56]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next we will add a **Step** | **Step** event to `obj_Shield_Upper`, with a
    new Script, `scr_ShieldUpper_Step`, attached with the following code to control
    the shield''s movement:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`obj_Shield_Upper`上添加一个**Step** | **Step**事件，附加一个新脚本`scr_ShieldUpper_Step`，其中包含以下代码来控制护盾的移动：
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We start by checking if the Shield is supposed to be down and whether it is
    all the way down or not. If it isn't all the way down, we move the Shield a bit
    down. The second `if` statement does the opposite, checking to see if the Shield
    is supposed to be up and whether it is all the way up. If not, we lift the Shield
    up a bit.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查护盾是否应该关闭，以及它是否完全关闭。如果没有完全关闭，我们将护盾稍微关闭一点。第二个`if`语句则相反，检查护盾是否应该打开，以及它是否完全打开。如果没有，我们将抬起护盾一点。
- en: 'Once again, the lower Shield is almost exactly the same. Create a new Script,
    `scr_ShieldLower_Step`, attached to a **Step** | **Step** event in `obj_Shield_Lower`:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下层护盾几乎完全相同。在`obj_Shield_Lower`的**Step** | **Step**事件中再次创建一个新脚本`scr_ShieldLower_Step`，附加以下代码：
- en: '[PRE58]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The last element we need to deal with is a **Collision** | **obj_Bullet** event,
    which both the Shields can use. Create a new Script, `scr_Shield_Collision`, with
    the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要处理的最后一个元素是**Collision** | **obj_Bullet**事件，两个护盾都可以使用。创建一个新脚本`scr_Shield_Collision`，其中包含以下代码：
- en: '[PRE59]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The Shields will never take damage, but they should only detect collision during
    the final phase.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 护盾永远不会受到伤害，但它们只应在最后阶段检测碰撞。
- en: 'Now that all the objects have been prepared, it is time to implement them into
    the Boss. Reopen `scr_Boss_Create` and insert the following code after the last
    weapon:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有对象都已准备就绪，是时候将它们实现到Boss中了。重新打开`scr_Boss_Create`，并在最后一个武器后插入以下代码：
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We create the Boss Core and the Shields all at the same location.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在同一位置创建Boss核心和护盾。
- en: Next we will create a Timeline, `tm_Boss_Phase03`, to deal with the Shields
    and Gun functionality.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个时间轴`tm_Boss_Phase03`来处理护盾和枪的功能。
- en: 'Add a **Moment** at `120`, and then create a new Script, `scr_Phase03_120`,
    with the following code:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`120`处添加一个**Moment**，然后创建一个新脚本`scr_Phase03_120`，其中包含以下代码：
- en: '[PRE61]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here we are setting the Shields to open and increasing the shooting rate of
    the Gun.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在设置护盾打开，并增加枪的射击速率。
- en: Add a **Moment** at `180` and create a new Script, `scr_Phase03_180`. All we
    are going to do here is turn off the Gun's alarm so that there is a brief respite
    in the shooting. This is achieved by setting the delay to -1.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`180`处添加一个**Moment**，并创建一个新脚本`scr_Phase03_180`。我们要做的就是关闭枪的警报，以便射击有一个短暂的休息。这是通过将延迟设置为-1来实现的。
- en: '[PRE62]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Add another **Moment** at `300`, and create a new Script, `scr_Phase03_300`.
    Now we reactivate the Gun's alarm.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`300`处添加另一个**Moment**，并创建一个新脚本`scr_Phase03_300`。现在我们重新激活枪的警报。
- en: '[PRE63]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally we add a **Moment** at `360` with another new Script, `scr_Phase03_360`,
    where we lower the Shields and return the Gun to a regular shooting rate:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`360`处添加一个**Moment**，使用另一个新脚本`scr_Phase03_360`，在那里我们降低护盾并将枪的射击速率恢复正常：
- en: '[PRE64]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now we need to add in the switch from the second phase to the final phase.
    Reopen `scr_Boss_Step` and add the following code at the end:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加从第二阶段到最后阶段的切换。重新打开`scr_Boss_Step`，并在末尾添加以下代码：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We check whether the LaserCannon has been destroyed and if we are supposed to
    be in the final phase or not. If we are, all we need to do is switch the `timeline`,
    set it to the beginning, and set it to the final phase.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查激光炮是否被摧毁，以及我们是否应该处于最后阶段。如果是，我们需要做的就是切换`timeline`，将其设置为开始，并设置为最后阶段。
- en: 'All we need now is a win condition which we will add to the same script. At
    the end of `scr_Boss_Step` write the last conditional statement:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要一个胜利条件，我们将把它添加到同一个脚本中。在`scr_Boss_Step`的末尾写上最后的条件语句：
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We check to see if the Boss Core has been destroyed and if the win condition
    has been called. If the Boss has been defeated, we stop the Timeline and declare
    the defeat.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查Boss核心是否被摧毁，以及是否已调用胜利条件。如果Boss被打败，我们停止时间轴并宣布失败。
- en: 'Run the game. It will take some time, but the first two phases should be the
    same as before and once the LaserCannon has been destroyed, the final phase activates.
    The Shields should open and the Gun shoots a burst of bullets. There then should
    be a quiet moment where the player can attack the Boss Core. A few seconds later
    the Gun should start firing and the Shields will close. This will repeat until
    the player defeats the Boss. This phase should look like the following screenshot:![Setting
    the final stage: The shielded Boss Core](img/4100_05_09.jpg)'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。这会花费一些时间，但前两个阶段应该与以前一样，一旦激光炮被摧毁，最后一个阶段就会激活。护盾应该会打开，枪会射出一连串的子弹。然后应该会有一个安静的时刻，玩家可以攻击Boss核心。几秒钟后，枪应该开始射击，护盾会关闭。这将重复，直到玩家击败Boss。这个阶段应该看起来像下面的截图：![设置最终阶段：有护盾的Boss核心](img/4100_05_09.jpg)
- en: Winding it up
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束
- en: We are wrapping up this chapter with some elements still left undone, but you
    already have the ability to do this on your own. There are still all the sounds,
    background art, and front end to build. Not only that, but you may have noticed
    that the player cannot be killed. Making the player invincible made it easier
    for us to test out the boss battle, so try the fight again after you have added
    it in. The boss battle is pretty difficult, but also easily altered. Why not try
    changing up the timing in each phase or try adjusting the values of the damage.
    To take this even further you can build levels and enemies that lead up to the
    battle. Have fun with it and it could look something like the following screenshot
    below!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在结束这一章，还有一些未完成的元素，但你已经有能力自己完成。仍然有所有的声音、背景艺术和前端要构建。不仅如此，你可能已经注意到玩家无法被杀死。让玩家无敌使我们更容易测试Boss战斗，所以在添加后再试一次战斗。Boss战斗非常困难，但也很容易改变。为什么不尝试改变每个阶段的时间或尝试调整伤害的值。为了更进一步，你可以构建导致战斗的关卡和敌人。玩得开心，它可能看起来像下面的截图！
- en: '![Winding it up](img/4100_05_10.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![结束](img/4100_05_10.jpg)'
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations, you have just built an epic boss battle! We started this chapter
    by delving into systems design and creating some very useful scripts. We built
    an animation system that most objects in the game utilized. We learned how to
    forecast for collision and apply our own custom gravity on the player. We even
    created platforms that the player could jump through and land on. We were introduced
    to constants, which has the benefit of making the code easier to read for us and
    more efficient to the computer. We then went on to build a three-phase boss fight
    utilizing all our previous knowledge along with our new systems.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你刚刚建立了一场史诗般的Boss战！我们从探讨系统设计和创建一些非常有用的脚本开始这一章。我们建立了一个动画系统，游戏中的大多数对象都使用了它。我们学会了预测碰撞并在玩家身上应用我们自己的自定义重力。我们甚至创建了玩家可以跳跃和着陆的平台。我们介绍了常量，这使得代码对我们来说更容易阅读，对计算机更有效。然后，我们继续构建了一个利用我们之前的知识和新系统的三阶段Boss战斗。
- en: 'In the next chapter we are going to move onto creating a physics-based game
    utilizing GameMaker: Studio''s Box2D implementation. This will use a completely
    different method of collision detection and physics systems. It will also allow
    us to have objects that react to the world with little or no code!'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一章中，我们将开始创建一个基于物理的游戏，利用GameMaker: Studio的Box2D实现。这将使用完全不同的碰撞检测和物理系统的方法。这也将允许我们拥有对世界做出反应的对象，几乎不需要编写代码！'
