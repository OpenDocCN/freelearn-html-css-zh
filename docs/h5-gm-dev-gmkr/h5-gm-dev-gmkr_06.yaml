- en: Chapter 6. Toppling Towers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 倾倒的塔
- en: 'For the rest of the book we are going to focus on creating a single game from
    concept to a completed, released product. We will be utilizing everything we have
    learned so far and will be introduced to a variety of additional features, such
    as GameMaker: Studio''s physics and particle systems. We will build some more
    systems to allow character dialog and an inventory. Finally, we will look at the
    different ways to release the game, including onto Facebook.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在本书的其余部分，我们将专注于从概念到完成、发布的单个游戏的创建。我们将利用到目前为止学到的一切，并将介绍各种其他功能，如GameMaker: Studio的物理和粒子系统。我们将构建一些系统来允许角色对话和一个库存。最后，我们将探讨发布游戏的不同方式，包括发布到Facebook。'
- en: 'In this chapter we are going to build a physics-based tower toppling game that
    will demonstrate GameMaker: Studio''s implementation of the Box2D open source
    physics engine. It will feature towers made out of a variety of different materials,
    such as glass, wood, and steel. The goal of the game will be to clear a restricted
    zone by destroying these towers utilizing a variety of tools. We will create TNT
    that will blast outwards, a Wrecking Ball that will swing down, and a Magnet that
    will attract loose parts. Best of all, all the collision and movement will be
    done by the engine itself!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将构建一个基于物理的塔倾倒游戏，展示GameMaker: Studio对Box2D开源物理引擎的实现。游戏将包括由各种不同材料制成的塔，如玻璃、木头和钢铁。游戏的目标是通过摧毁这些塔来清除受限区域，利用各种工具。我们将创建TNT来爆炸，一个会摆动的破坏球，以及一个会吸引松散部件的磁铁。最重要的是，所有的碰撞和移动都将由引擎自己完成！'
- en: Understanding the physics engine
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解物理引擎
- en: When building a physics-based game, it requires a different way of thinking
    about how you go about creating things. So far, we have focused on applying movement
    to an instance by either teleporting it via the X/Y coordinates, or by changing
    the `speed`, `vspeed`, and `hspeed` variables. When we use the physics engine,
    these properties are ignored. Instead, the system itself deals with movement by
    applying a force onto the instance. That instance will react to the force based
    on its own properties and will act accordingly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建基于物理的游戏时，需要以不同的方式思考如何创建事物。到目前为止，我们专注于通过X/Y坐标来对实例应用移动，或者通过改变`speed`、`vspeed`和`hspeed`变量来实现。当我们使用物理引擎时，这些属性将被忽略。相反，系统本身通过对实例施加力来处理移动。实例将根据自身的属性对力做出反应，并相应地行动。
- en: 'Additionally, the direction of the world coordinates is not the same in physics
    world. Zero degrees in the GameMaker standard physics world indicates a direction
    of right, whereas in the Box2D physics world, zero degrees indicates up, as can
    be seen in the following diagram:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，世界坐标的方向在物理世界中并不相同。在GameMaker标准物理世界中，零度表示右方向，而在Box2D物理世界中，零度表示向上，如下图所示：
- en: '![Understanding the physics engine](img/4100OT_06_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![理解物理引擎](img/4100OT_06_01.jpg)'
- en: 'To fully understand how the Box2D physics engine works, we need to take a look
    at the following four components that it is comprised of:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解Box2D物理引擎的工作原理，我们需要看一下它由以下四个组件组成：
- en: The physics world
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理世界
- en: Fixtures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fixture
- en: Joints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接
- en: Forces
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力
- en: Activating the world
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活世界
- en: Much like the real world, the physics world starts with the application of gravity.
    The amount of gravity will determine how fast the objects will fall and how much
    force is necessary to counteract it. Before we can use any of the physics functions
    in a game, we need to activate the world physics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现实世界一样，物理世界从施加重力开始。重力的大小将决定物体下落的速度以及抵消它所需的力量。在游戏中使用任何物理函数之前，我们需要激活世界物理。
- en: Let's start a new project called `Chapter_06`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始一个名为`Chapter_06`的新项目。
- en: Create a new Room, and name it `Sandbox`. We will use this Room for testing
    purposes only.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的房间，命名为`Sandbox`。我们将只用这个房间进行测试。
- en: Click on the **physics** tab and check **Room is Physics World**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**物理**选项卡，勾选**房间是物理世界**。
- en: In the **Physics World Properties:**, set **Gravity:** to **X:** `0.0` and **Y:**
    `20.0`. This will set the direction and strength of the gravity in the world.
    If you wanted to have gravity as it is on Earth, we would set the value to **Y:**
    `9.8`. We are setting it to `20.0`, so objects appear to fall faster.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**物理世界属性**中，将**重力**设置为**X:** `0.0` 和 **Y:** `20.0`。这将设置世界中重力的方向和强度。如果你想让重力像地球上一样，我们会将值设置为**Y:**
    `9.8`。我们将其设置为`20.0`，这样物体看起来会下落得更快。
- en: Finally, there is an option to set **Pixels To Meters:**. The entire physics
    system is based on real-world measurements, so we need to determine how many real-world
    meters are represented by a single pixel so that the calculations are accurate.
    We will leave this at the default value of 0.1 meters per pixel, or about 10 centimeters.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，还有一个选项可以设置**像素到米**。整个物理系统都是基于真实世界的测量，所以我们需要确定一个像素代表多少米，以便计算准确。我们将保持默认值为每像素0.1米，或约10厘米。
- en: 'The world is now ready to use the physics engine! The physics settings of the
    room should look like the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 世界现在已经准备好使用物理引擎了！房间的物理设置应该如下截图所示：
- en: '![Activating the world](img/4100OT_06_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![激活世界](img/4100OT_06_02.jpg)'
- en: Defining properties with fixtures
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Fixture定义属性
- en: 'In order for something to be affected by gravity and other such forces, an
    object requires a **Fixture**. A Fixture is what defines the shape and properties
    of a physics object. We will need to build two Objects: a Ground object that will
    never move, and a Steel Pillar which will react to gravity.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让物体受到重力和其他力的影响，物体需要一个**Fixture**。Fixture定义了物理对象的形状和属性。我们需要构建两个对象：一个永远不会移动的地面对象，和一个会受到重力影响的钢柱。
- en: 'We will start by creating the Ground object. Create a new Sprite, `spr_Ground`,
    and load `Chapter 6/Sprites/Ground.png` with **Remove Background** unchecked.
    Leave **Origin** at **X**: `0`, **Y**: `0`, and click on **OK**.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从创建地面对象开始。创建一个新的精灵，`spr_Ground`，并加载`Chapter 6/Sprites/Ground.png`，取消**删除背景**的勾选。将**原点**保留在**X**：`0`，**Y**：`0`，然后点击**确定**。
- en: Create a new Object, `obj_Ground`, and assign `spr_Ground` as the Sprite.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Ground`，并将`spr_Ground`分配为精灵。
- en: In order to make this object responsive in the physics engine, we need to check
    **Uses Physics**. This will display **Physics Properties** as shown in the following
    screenshot:![Defining properties with fixtures](img/4100OT_06_03.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使物体在物理引擎中响应，我们需要勾选**使用物理**。这将显示**物理属性**，如下面的屏幕截图所示：![使用夹具定义属性](img/4100OT_06_03.jpg)
- en: 'The first element we need to set up is **Collision Shape**. There are three
    options to choose from: **Circle**, **Box**, and **Shape**. The most common shape
    is **Box**, which just has four points and is always in a rectangular form. The
    **Circle** shape is useful for perfectly round objects as it is determined by
    a radius, thus not useful for round shapes like an egg. **Shape** is the most
    useful option in that you can have up to eight points of collision. One drawback
    for this is that all shapes must be convex, or it will not work. See the following
    screenshot to better understand what is acceptable:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置的第一个元素是**碰撞形状**。有三个选项可供选择：**圆形**，**矩形**和**形状**。最常见的形状是**矩形**，它只有四个点，总是呈矩形形状。**圆形**形状适用于完全圆形的物体，因为它是由半径确定的，因此不适用于像鸡蛋这样的圆形。**形状**是最有用的选项，因为你可以有多达八个碰撞点。这种形状的一个缺点是所有形状必须是凸的，否则将无法工作。请参考下面的屏幕截图，以更好地理解什么是可接受的：
- en: '![Defining properties with fixtures](img/4100OT_06_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![使用夹具定义属性](img/4100OT_06_04.jpg)'
- en: The Ground is a rectangular object, so in **Collision Shape** under **Physics
    Properties**, select **Box**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地面是一个矩形物体，所以在**物理属性**下的**碰撞形状**中选择**矩形**。
- en: The default shape will be created with its starting point based on the origin
    of the Sprite, which in this case is in the upper-left corner. That means we will
    need to either adjust the **Origin**, or the **Physics Shape** to make it fit
    properly. For this object we will do the latter. Click on **Modify Collision Shape**
    to open the **Physics Shape** editor. Place the points so that they are correctly
    positioned on the sprite, as seen in the following screenshot, and then click
    on **OK**.![Defining properties with fixtures](img/4100OT_06_05.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认形状将根据精灵的原点创建，这种情况下是在左上角。这意味着我们需要调整**原点**或**物理形状**以使其正确适配。对于这个对象，我们将选择后者。点击**修改碰撞形状**以打开**物理形状**编辑器。将点放置在精灵上正确的位置，如下面的屏幕截图所示，然后点击**确定**。![使用夹具定义属性](img/4100OT_06_05.jpg)
- en: 'Now that the shape is complete, we can set the other physics properties. There
    are six adjustable properties available to us here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在形状已经完成，我们可以设置其他物理属性。这里有六个可调整的属性可供我们使用：
- en: '**Density**: This represents the mass of the Object per unit of volume. You
    can think of this as how heavy an object is compared to its overall size.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度**：这代表单位体积内物体的质量。你可以把它想象成物体相对于其整体大小有多重。'
- en: '**Restitution**: This represents how bouncy an object is. Higher the number,
    more bounce the object will have on collision. This does not mean that the shape
    of the object will deform. It won''t as this is a rigid body physics simulation.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这代表物体有多有弹性。数字越高，物体在碰撞时弹跳得越多。这并不意味着物体的形状会变形。因为这是一个刚体物理模拟。'
- en: '**Collision Group**: These groups help simplify what objects can collide with
    each other. A positive number here will mean that all objects within that group
    number will always collide. A negative number means that the objects in that group
    number never collide with each other. If set to zero, a collision event will need
    to be placed into each object in order for it to collide. Using groups should
    be kept to a minimum, as it will dramatically increase processing time.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞组**：这些组有助于简化物体之间的碰撞。这里的正数意味着该组编号内的所有物体将始终发生碰撞。负数意味着该组编号内的物体永远不会相互碰撞。如果设置为零，碰撞事件将需要放置到每个物体中才能发生碰撞。使用组应该尽量减少，因为它会大大增加处理时间。'
- en: '**Linear Damping**: This represents the reduction of velocity of an object
    in motion. You can think of it as air friction as the object does not need to
    be in contact with any other object to slow down.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性阻尼**：这代表了物体运动速度的减小。你可以把它想象成空气摩擦，因为物体不需要与其他物体接触就会减速。'
- en: '**Angular Damping**: Much like **Linear Damping**, this is the reduction of
    rotational movement of an object.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角阻尼**：与**线性阻尼**类似，这是物体旋转运动的减小。'
- en: '**Friction**: Friction is the force that acts opposite to a moving object during
    collision. This works in a similar fashion to **Linear Damping** in that it slows
    down objects. The difference is that it requires a collision to occur.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩擦力**：摩擦力是在碰撞过程中与运动物体相反的力。这与**线性阻尼**类似，因为它会减慢物体的速度。不同之处在于它需要发生碰撞。'
- en: Different materials in the real world will have different values for each of
    these properties. There are many charts available that will show values for many
    types of materials, such as steel that has a density of 7,820 kilograms per cubic
    meter, and has a friction coefficient of 0.78 when touching other steel. Trying
    to think of all these values as they correspond to objects in a game can quickly
    become overwhelming. Luckily, games don't need to use real-world values, but instead
    we can use general concepts for the materials, such as steel has a high density
    while ice has a low density. Below is a chart with some basic concepts for how
    we need to treat the values for **Density**, **Restitution**, and **Friction**.
    For **Linear Damping** and **Angular Damping** it is a bit trickier, as they relate
    more to the shape of an object. For example, a round steel pin would have less
    **Angular Damping** than a square steel pin. All of these materials, whatever
    we set the values to, should always be tweaked until they feel correct for the
    game they are in. It is completely valid for a metal bar to have a density of
    three in one game and 300 in another, so long as it acts as the developer intends.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的不同材料将具有这些属性的不同值。有许多图表可以显示许多类型材料的值，例如钢的密度为每立方米7,820千克，与其他钢接触时的摩擦系数为0.78。试图考虑这些值与游戏中的对象对应时，可能会很快变得令人不知所措。幸运的是，游戏不需要使用现实世界的值，而是可以使用材料的一般概念，例如钢的密度很高，而冰的密度很低。下面是一个图表，其中包含了我们需要处理**密度**、**恢复**和**摩擦**值的一些基本概念。对于**线性阻尼**和**角阻尼**来说，情况会有些棘手，因为它们更多地与物体的形状有关。例如，一个圆形的钢钉的**角阻尼**会比一个方形的钢钉小。无论我们将这些材料的值设置为多少，都应该始终调整，直到它们在游戏中感觉正确。在一个游戏中，金属棒的密度为3，在另一个游戏中为300，这是完全有效的，只要它符合开发者的意图。
- en: '| Material | Density | Restitution | Friction |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 材料 | 密度 | 恢复 | 摩擦 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Steel | High | Low | Medium |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 钢 | 高 | 低 | 中等 |'
- en: '| Glass | Low | Medium | Low |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 玻璃 | 低 | 中等 | 低 |'
- en: '| Wood | Medium | Medium | Medium |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 木材 | 中等 | 中等 | 中等 |'
- en: '| Rubber | Medium | High | Medium |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 橡胶 | 中等 | 高 | 中等 |'
- en: '| Stone | High | Low | High |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 石头 | 高 | 低 | 高 |'
- en: As this Ground is intended to never move or feel the effects of gravity, we
    need to set **Density** to `0`. When an object has no density it is considered
    to be a static object.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个地面永远不会移动或感受到重力的影响，我们需要将**密度**设置为`0`。当一个物体没有密度时，它被认为是一个静态物体。
- en: We don't want the Ground to be bouncy, so set **Restitution** to `0`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望地面有弹性，所以将**恢复**设置为`0`。
- en: We will leave **Collision Group** at the default `0`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将**碰撞组**保留为默认值`0`。
- en: As the object isn't moving, we might as well set **Linear Damping** and **Angular
    Damping** to `0`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于物体不会移动，我们可能会将**线性阻尼**和**角阻尼**设置为`0`。
- en: Finally, we do want objects to come quickly to a stop on the ground, so let's
    set **Friction** to `1`. We are done with `obj_Ground`, so click on **OK**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们确实希望物体在地面上迅速停止，所以让我们将**摩擦**设置为`1`。我们已经完成了`obj_Ground`，所以点击**确定**。
- en: Next, we will make the Steel Pillar. Create a new Sprite, `spr_Pillar_Steel`,
    and load `Chapter 6/Sprites/Pillar_Steel.png` with **Remove Background** checked.
    Center the origin and click on **OK**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将制作钢柱。创建一个新的精灵，`spr_Pillar_Steel`，并加载`Chapter 6/Sprites/Pillar_Steel.png`，勾选**去除背景**。居中原点，然后点击**确定**。
- en: Create a new Object, `obj_Pillar_Steel`, and set `spr_Pillar_Steel` as its **Sprite**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Pillar_Steel`，并将`spr_Pillar_Steel`设置为其**精灵**。
- en: Check the box for **Uses Physics**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**使用物理**的复选框。
- en: In **Collision Shape** under **Physics Properties**, select **Box**. As we placed
    the origin into the center of the Sprite, the shape should be correctly conformed
    to the Sprite so that we do not have to modify it. However, we should always open
    the **Physics Shape** editor to ensure that it is properly located to prevent
    any major issues.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**物理属性**下的**碰撞形状**中，选择**方块**。由于我们将原点放置在精灵的中心，因此形状应该正确地符合精灵，这样我们就不必修改它。然而，我们应该始终打开**物理形状**编辑器，以确保它正确地定位，以防止任何重大问题。
- en: We want this object to be fairly heavy, so set **Density** to `20`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个对象相当重，所以将**密度**设置为`20`。
- en: The Steel Pillar shouldn't be very slick either, so set **Friction** to `2`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 钢柱也不应该很滑，所以将**摩擦**设置为`2`。
- en: Set all the other properties to `0`, as we do not want to slow this object or
    have it bounce. We have now finished setting the properties of this object.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有其他属性设置为`0`，因为我们不希望减慢这个物体的速度或使其弹跳。我们现在已经完成了设置这个对象的属性。
- en: The only thing we have left to do is to add an `obj_Ground` event. As can be
    seen in the next screenshot, we don't need any code, we just need a comment. Drag
    a **Comment** from the **Controls** tab under **Actions:** and write `Collide
    with Ground`. With this little trick the Pillar will now have active collision
    with the Ground.![Defining properties with fixtures](img/4100OT_06_06.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们唯一剩下要做的就是添加一个`obj_Ground`事件。如下截图所示，我们不需要任何代码，只需要一个注释。从**控件**选项卡下的**动作**中拖动一个**注释**，并写上`与地面碰撞`。通过这个小技巧，钢柱现在将与地面发生主动碰撞。![使用夹具定义属性](img/4100OT_06_06.jpg)
- en: Reopen the `Sandbox` room and place an instance of `obj_Pillar_Steel` somewhere
    near the top in the center horizontally. Also, place instances of `obj_Ground`
    along the bottom with one additional instance located right above the floor and
    just slightly under where the Steel Pillar will fall, as seen in the following
    screenshot. To move an instance freely in the **Room Properties** editor, hold
    down the *Alt* key while holding down the left mouse button.![Defining properties
    with fixtures](img/4100OT_06_07.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`Sandbox`房间，并在水平中心附近放置一个`obj_Pillar_Steel`的实例。此外，在底部放置`obj_Ground`的实例，其中一个额外的实例位于地板上方，略低于钢柱将要掉落的位置，如下截图所示。在**房间属性**编辑器中自由移动实例，按住*Alt*键同时按住鼠标左键。![使用夹具定义属性](img/4100OT_06_07.jpg)
- en: Run the game. The Steel Pillar should fall down and collide with the little
    stump on the ground. It should then fall over onto its side and come to a rest.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。钢柱应该会倒下并与地面上的小树桩碰撞。然后它应该倒在一边并停下来。
- en: We have just completed our first physics simulation! Let's now take a look at
    Joints.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了我们的第一个物理模拟！现在让我们来看看关节。
- en: Connecting objects with Joints
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用关节连接对象
- en: 'There are times when we will want two or more objects to be constrained to
    each other, such as a chain, or a ragdoll body. In the physics engine it is achieved
    through the use of **Joints**. There are five different types of Joints that we
    can use:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望两个或更多的对象相互约束，比如链条或布娃娃身体。在物理引擎中，这是通过使用**关节**来实现的。我们可以使用五种不同类型的关节：
- en: '**Distance Joints**: These will keep two instances connected at a set distance
    apart from each other. For example, a wheelbarrow would have a Distance Joint
    to keep the front wheel a set distance away from the handles, no matter how it
    is pushed.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**距离关节**：这些将保持两个实例相互连接，并保持一定距离。例如，手推车会有一个距离关节，以保持前轮与把手一定距离，无论如何推动它。'
- en: '**Revolute Joints**: These will rotate one instance around another. For example,
    a door hinge is a Revolute Joint that rotates a door around the door frame.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转关节**：这些将使一个实例围绕另一个旋转。例如，门铰链是一个旋转关节，它会使门围绕门框旋转。'
- en: '**Prismatic Joints**: These will allow one instance to move in a single direction
    relative to another. For example, a pinball plunger would have a Prismatic Joint,
    as it can only pull back or push forward into the machine.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动关节**：这些将允许一个实例在相对于另一个的单个方向上移动。例如，弹球弹簧会有一个滑动关节，因为它只能向后拉或向前推入机器中。'
- en: '**Pulley Joints**: These will allow one instance to influence another in relation
    to its movement. For example, a set of scales uses a Pulley Joint to weigh things.
    If it is heavier on one side it will go down, while the other side would go up.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑轮关节**：这些将允许一个实例影响另一个与其运动相关的关系。例如，一套天平使用滑轮关节来称重。如果一边更重，它会下降，而另一边会上升。'
- en: '**Gear Joints**: These will affect the movement of one instance based on the
    rotation of another. For example, the spinning reel of a fishing rod is a Gear
    Joint; when it is rotated it will pull in the fish.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**齿轮关节**：这些将根据另一个实例的旋转影响一个实例的运动。例如，钓鱼竿的旋转卷轴是一个齿轮关节；当它旋转时，它会拉进鱼。'
- en: Let's take a look at how Joints work by creating a simple chain that is attached
    to an Anchor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个简单的链条来看看关节是如何工作的，它连接到一个锚点上。
- en: We will start by building the anchor, which will be a stationary static object
    in the world. Create a new Sprite, `spr_Anchor`, and load `Chapter 6/Sprites/Anchor.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从构建锚点开始，这将是世界中的一个静止静态对象。创建一个新的精灵，`spr_Anchor`，并加载`Chapter 6/Sprites/Anchor.png`，勾选**删除背景**。居中原点，然后点击**确定**。
- en: Create a new Object, `obj_Anchor`, and set `spr_Anchor` as the Sprite.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Anchor`，并将`spr_Anchor`设置为精灵。
- en: Check the box for **Uses Physics** and change the **Collision Shape** to **Box**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**使用物理**并将**碰撞形状**更改为**方块**。
- en: Set **Density** and **Restitution** to `0`. We can leave the other properties
    at the default values and it should look like the following screenshot:![Connecting
    objects with Joints](img/4100OT_06_31.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**密度**和**弹性**设置为`0`。我们可以将其他属性保留为默认值，应该看起来像下面的截图：![用关节连接对象](img/4100OT_06_31.jpg)
- en: Next, we need to create the Chain Links. Create a new Sprite, `spr_ChainLink`,
    and load `Chapter 6/Sprites/ChainLink.png` with **Remove Background** checked.
    Center the origin and click on **OK**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建链条链接。创建一个新的精灵，`spr_ChainLink`，并加载`Chapter 6/Sprites/ChainLink.png`，勾选**删除背景**。居中原点，然后点击**确定**。
- en: Create a new Object, `obj_ChainLink`, and set `spr_ChainLink` as the **Sprite**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_ChainLink`，并将`spr_ChainLink`设置为**精灵**。
- en: Check the box for **Uses Physics** and change the **Collision Shape** to **Box**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**使用物理**并将**碰撞形状**更改为**方块**。
- en: We want the Chain to be quite strong and heavy, so set **Density** to `50`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望链条非常坚固和沉重，所以将**密度**设置为`50`。
- en: The Chain should not stretch and swings freely, therefore we need to set the
    **Restitution**, **Linear Damping**, **Angular Damping**, and **Friction** to
    `0`. The final settings should look like the following screenshot:![Connecting
    objects with Joints](img/4100OT_06_32.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链条不应该伸展并且应该自由摆动，因此我们需要将**弹性**、**线性阻尼**、**角阻尼**和**摩擦**设置为`0`。最终设置应该看起来像下面的截图：![用关节连接对象](img/4100OT_06_32.jpg)
- en: 'The component parts are now complete; we will just need to build the entire
    Chain and attach it to the Anchor. Create a new Script, `scr_Anchor_Create`, write
    the following code, and add this to a **Create** event in `obj_Anchor`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件部分现在已经完成；我们只需要构建整个链条并将其连接到锚点。创建一个新脚本，`scr_Anchor_Create`，编写以下代码，并将其添加到`obj_Anchor`的**创建**事件中：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To build the Chain we run a loop starting to create nine links of the Chain.
    We start the loop at `1` so that the Chain is offset correctly. We use a basic
    one-dimensional array to store the ID of each Chain Link, as we will need this
    when we add the joints. The `x` offset we have in the creation will create each
    link an equal distance apart horizontally.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建链条，我们运行一个循环，开始创建九个链条链接。我们从`1`开始循环，以便正确偏移链条。我们使用一个基本的一维数组来存储每个链条链接的ID，因为当我们添加关节时会需要这个。我们在创建中的`x`偏移将使每个链接在水平方向上等距离分开。
- en: 'Next, we need to apply a Revolute Joint to the first link of the Chain. After
    the previous code, add:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在链条的第一个链接上应用旋转关节。在上一个代码之后，添加：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We start by creating a Revolute Joint from the anchor to the very first Chain
    Link. The rotation will occur around the Anchor''s X and Y axes. The next three
    parameters relate to the limitations of the rotation: the minimum and maximum
    angles of rotation, and whether these limits are active. In this case we don''t
    care, so we have turned off any angle limitation. The following three parameters
    are for whether the joint will rotate on its own or not, with values for the maximum
    speed, the set speed, and whether it is active. Again, we have turned it off so
    the Chain will just hang in the air. The last parameter is for whether the Anchor
    can collide with the Chain, and we do not want that to occur here.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要创建一个旋转关节，从锚点到第一个链条链接。旋转将围绕锚点的X和Y轴发生。接下来的三个参数与旋转的限制有关：旋转的最小和最大角度，以及这些限制是否生效。在这种情况下，我们不关心，所以我们关闭了任何角度限制。接下来的三个参数是关节是否会自行旋转，以及最大速度、设定速度和是否生效的值。同样，我们关闭了它，所以链条将悬挂在空中。最后一个参数是锚点是否可以与链条发生碰撞，我们不希望发生碰撞。
- en: 'Now that we have the first link attached, let''s join the rest of the Chain
    together. Still in the same script, at the end add:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经连接了第一个链接，让我们把剩下的链条连接起来。仍然在同一个脚本中，在最后添加：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we are using a loop again, so that we can go through each link and attach
    the one that follows. Notice that the loop stops at `9`, as we have already connected
    one piece of Chain. In the case of the Chain, we don't want each Link to have
    full freedom of rotation. We have activated the rotational limit and set it to
    20 degrees in either direction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们再次使用循环，这样我们可以遍历每个链接并连接下一个链接。注意循环停在`9`，因为我们已经连接了一段链条。对于链条来说，我们不希望每个链接都有完全的旋转自由度。我们激活了旋转限制，并将其设置为20度的两个方向。
- en: We now have a small Chain attached to an anchor. Let's add it to the world.
    Reopen the `Sandbox` and add a single instance of `obj_Anchor` near the top of
    the room.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个小链条连接到一个锚点。让我们把它添加到世界中。重新打开`Sandbox`，在房间的顶部附近添加一个`obj_Anchor`的实例。
- en: Run the game. The Anchor should remain at the top of the room with the Chain
    Links extending out to the right of it. The Chain will fall due to the gravity
    in the room, though each link will remain attached to the one above it, with the
    top link still attached to the Anchor. It should look something like the following
    screenshot:![Connecting objects with Joints](img/4100OT_06_08.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。锚点应该保持在房间的顶部，链条链接向右延伸。由于房间中的重力，链条会下落，但每个链接都会保持连接在上面的链接上，顶部链接仍然连接在锚点上。它应该看起来像下面的截图：![使用关节连接对象](img/4100OT_06_08.jpg)
- en: Applying forces to objects
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对物体施加力
- en: In order to move an object in the physics world, excluding movement due to gravity,
    it requires that a **Force** be applied to it. These forces can be applied from
    a point in the world or locally to the instance. How the object reacts to the
    force depends on the properties it has. Just like the real world, the heavier
    the object, the more force is required to move it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在物理世界中移动一个物体，除了由于重力而产生的运动，需要对其施加**力**。这些力可以从世界中的某一点施加，也可以局部施加到实例上。物体对力的反应取决于它的属性。就像现实世界一样，物体越重，移动它所需的力就越大。
- en: In order to take a look at Forces we are going to create TNT, which will explode,
    shooting out eight fragments. These fragments will be very dense and will require
    a lot of force to make them move.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看力，我们将创建TNT，它将爆炸，射出八个碎片。这些碎片将非常密集，需要大量的力才能使它们移动。
- en: Let's start with the fragments first. Create a new Sprite, `spr_TNT_Fragment`,
    and load `Chapter 6/Sprites/TNT_Fragment.png` with **Remove Background** unchecked.
    Center the origin and click on **OK**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先从碎片开始。创建一个新的精灵，`spr_TNT_Fragment`，并加载`Chapter 6/Sprites/TNT_Fragment.png`，取消**删除背景**的勾选。将原点居中，然后点击**确定**。
- en: Create a new Object, `obj_TNT_Fragment`, and assign `spr_TNT_Fragment` as the
    **Sprite**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_TNT_Fragment`，并将`spr_TNT_Fragment`分配为**精灵**。
- en: Check the box for **Uses Physics** and change **Collision Shape** to **Box**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**使用物理**，并将**碰撞形状**更改为**矩形**。
- en: Set the **Density** to `10`. We are making this value very high, so that when
    it collides with objects, such as the Steel Pillar, it will be able to move it.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**密度**设置为`10`。我们将这个值设置得很高，这样当它与物体碰撞时，比如钢柱，它就能够移动它。
- en: Set all remaining properties to `0`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有剩余的属性设置为`0`。
- en: 'As we need several fragments to shoot out from the TNT, we need to be able
    to control the direction in which it is going to move. Therefore, we need to establish
    some variables. Create a new Script, `scr_TNT_Fragment_Create`, with the following
    variables:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要从TNT中射出多个碎片，我们需要能够控制它移动的方向。因此，我们需要建立一些变量。创建一个新的脚本，`scr_TNT_Fragment_Create`，包含以下变量：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The strength and direction of a force is determined by a vector, which is why
    we need X and Y variables. We have set it to zero, so that it is not moving by
    default. Don't forget to apply this to a **Create** event in `obj_TNT_Fragment`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 力的强度和方向由矢量确定，这就是为什么我们需要X和Y变量。我们将其设置为零，这样它默认不会移动。不要忘记将其应用到`obj_TNT_Fragment`的**创建**事件中。
- en: As these fragments are meant to represent an explosion, we will want to constantly
    apply force to them, so that they aren't overly affected by gravity. Create a
    new Script, `scr_TNT_Fragment_Step`, and apply some force. Add this script to
    a **Step** event.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这些碎片是用来表示爆炸的，我们希望不断地对它们施加力，这样它们就不会受到过多的重力影响。创建一个新的脚本，`scr_TNT_Fragment_Step`，并施加一些力。将这个脚本添加到**Step**事件中。
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function `physics_apply_force` is a world based force, with the first two
    parameters representing where in the world the force is coming from, and the second
    two parameters being the vector of force to be applied.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`physics_apply_force`是一个基于世界的力，前两个参数表示力来自世界的哪个位置，后两个参数是要施加的力的矢量。
- en: 'Currently, these fragments will never stop moving, which is a problem. We are
    going to want to limit how far they can move outwards. Add the following code
    at the end of the script:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，这些碎片永远不会停止移动，这是一个问题。我们需要限制它们可以移动的距离。在脚本的末尾添加以下代码：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we are doing here is checking to see if the Fragment has moved more than
    128 pixels from where it was created. If it has, we remove it from the world.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是检查碎片是否从创建时移动了超过128像素。如果是，我们就将其从世界中移除。
- en: We want these fragments to collide with some of the other elements in the game.
    At the same time, we don't want them to go through anything, so we will destroy
    them. Create a new Script, `scr_TNT_Fragment_Collision` and remove the instances.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这些碎片与游戏中的其他元素发生碰撞。与此同时，我们不希望它们穿过任何东西，所以我们会销毁它们。创建一个新的脚本，`scr_TNT_Fragment_Collision`并删除实例。
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Add an `obj_Ground` event and add this script. This will remove the Fragment
    if it hits the Ground.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`obj_Ground`事件并添加这个脚本。这将在碰到地面时移除碎片。
- en: We want it to affect the Steel Pillar, but since we are planning on creating
    many more types of Pillars, let's build a parent object for the Pillars for collision
    detection. Create a new Object, `obj_Pillar_Parent`. This is all that it needs
    for now, so click on **OK**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望它影响钢柱，但由于我们计划创建更多类型的柱子，让我们为柱子构建一个父对象进行碰撞检测。创建一个新对象，`obj_Pillar_Parent`。现在它只需要这些，所以点击**确定**。
- en: Reopen `obj_Steel_Pillar` and set **Parent** to `obj_Pillar_Parent`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`obj_Steel_Pillar`并将**父级**设置为`obj_Pillar_Parent`。
- en: While we are in `obj_Steel_Pillar`, we might as well have it react to other
    Pillars as well. Add an `obj_Pillar_Parent` and drag a **Comment** from **Controls**
    into the **Actions:** area, and enter `Collides with Pillars` as the comment.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在`obj_Steel_Pillar`中时，我们也可以让它对其他柱子做出反应。从**控件**中添加一个**注释**到**操作**区域，并输入`与柱子碰撞`作为注释。
- en: Go back into obj_TNT_Fragment and add an `obj_Pillar_Parent` and apply `scr_TNT_Fragment_Collision`.
    We will now have collision with all Pillars!
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到obj_TNT_Fragment并添加一个`obj_Pillar_Parent`并应用`scr_TNT_Fragment_Collision`。现在我们将与所有柱子发生碰撞！
- en: All we need to do now is to create the TNT and have it explode. Create a new
    Sprite, `spr_TNT`, and load `Chapter 6/Sprites/TNT.png` with **Remove Background**
    checked. Center the origin and click on **OK**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们所需要做的就是创建TNT并让它爆炸。创建一个新的精灵，`spr_TNT`，并加载`Chapter 6/Sprites/TNT.png`，勾选**去除背景**。居中原点，然后点击**确定**。
- en: Create a new Object, `obj_TNT`, and apply `spr_TNT` as the Sprite. We will be
    manually placing the TNT in the game, and we don't need it to react to the world
    physics, so we do *not* need to turn on **Use Physics**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_TNT`，并应用`spr_TNT`作为精灵。我们将手动放置TNT在游戏中，我们不需要它对世界物理做出反应，所以我们*不*需要打开**使用物理**。
- en: Let's create a new Script, `scr_TNT_Activate`, and for testing purposes, add
    it to a **Space** event under **Key Press**. We are going to create only a single
    Fragment and have it launch outwards to the right, so we can see how forces work
    in the world.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的脚本，`scr_TNT_Activate`，并为测试目的，在**按键按下**下的**空格**事件中添加它。我们将只创建一个碎片，并让它向右发射，这样我们就可以看到世界中的力量是如何工作的。
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We first create a Fragment and capture its ID in a variable. We are then setting
    the horizontal force to be 100 units. This value seems like it should be enough
    force to push this object to the right.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个碎片并将其ID存储在一个变量中。然后我们将水平力设置为100单位。这个值似乎足够推动这个物体向右移动。
- en: Let's test it out. Reopen `Sandbox` and place a single instance slightly to
    the left of where the Steel Pillar will fall and three grid spaces above the Ground.
    Also, let's remove the extra instance of Ground and the Chain. The Room should
    look like the following screenshot:![Applying forces to objects](img/4100OT_06_09.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来测试一下。重新打开`Sandbox`并将一个单独的实例放在钢柱将要倒下的位置的左侧，离地面三个网格空间。另外，让我们移除多余的地面实例和链条。房间应该看起来像下面的截图：![对物体施加力量](img/4100OT_06_09.jpg)
- en: Run the game and press the space key to spawn a Fragment. You should see the
    Fragment come out moving to the right, but it is falling downwards as well. When
    the Fragment collides with the Steel Pillar, the Fragment disappears and nothing
    happens to the Steel Pillar. All of this is a result of the Fragment not having
    enough force.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏，按空格键生成一个碎片。你应该看到碎片向右移动，但也向下掉落。当碎片与钢柱碰撞时，碎片消失，钢柱没有任何变化。所有这些都是由于碎片没有足够的力量。
- en: 'Let''s increase the force. Reopen `scr_TNT_Activate` and change the second
    line to:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加力量。重新打开`scr_TNT_Activate`并将第二行更改为：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the game and press space to see how this changes things. The Fragment now
    appears to move only to the right, and on contact with the Steel Pillar, it makes
    it rock a little bit. However, no matter how many times we hit the Steel Pillar,
    it will never fall over. This is due to the fact that the Steel Pillar has double
    the density of the Fragment, and it needs significantly more force to knock it
    down.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并按空格键查看这些变化。碎片现在似乎只向右移动，并在与钢柱接触时使其摇晃了一下。然而，无论我们多少次击中钢柱，它都不会倒下。这是因为钢柱的密度是碎片的两倍，它需要更大的力量才能将其击倒。
- en: 'Once again, let''s adjust the number by adding a zero to the end. Change the
    force to:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调整数字，将力量改为：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the game again and try to knock the Steel Pillar over. It should take three
    quick taps and it will fall over. As we can see, a small object like the Fragment
    is going to require a very large amount of force in order to move a large object
    such as the Steel Pillar.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行游戏，尝试把钢柱撞倒。应该需要三次快速点击，它就会倒下。正如我们所看到的，像碎片这样的小物体需要非常大的力量才能移动像钢柱这样的大物体。
- en: Now that we have one Fragment working, let's get the rest in. We need seven
    more fragments moving in 45 degree increments. We will also want to remove the
    TNT so it can only be triggered once.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个碎片在工作，让我们把其他的也加进来。我们需要再加入七个碎片，每个以45度的增量移动。我们还希望移除TNT，这样它只能被触发一次。
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see, for each Fragment we apply an appropriate value for the forces
    in the X and Y directions. There is no need for us to pull out a calculator and
    some fancy equations to figure out exactly how much force is needed, especially
    on the angled pieces. Remember, this is a video game and we should only worry
    about the overall effect and experience the player has to see if the results are
    correct. When you run the game it should look something like the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，对于每个碎片，我们在X和Y方向上应用适当的力值。我们无需拿出计算器和一些花哨的方程来准确计算需要多少力量，尤其是在倾斜的部分。记住，这是一个视频游戏，我们只需要担心玩家所看到的整体效果和体验，以确定结果是否正确。当你运行游戏时，它应该看起来像以下的截图：
- en: '![Applying forces to objects](img/4100OT_06_11.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![对对象施加力](img/4100OT_06_11.jpg)'
- en: At this point we have a good foundational knowledge of how the Box2D physics
    engine works. We have built a room with physics activated and created several
    objects with fixtures and physics properties. We have used joints to connect a
    series of instances together and we have applied forces to an object to make it
    move. We are now ready to start building the tower toppling game!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们对Box2D物理引擎的工作原理有了良好的基础知识。我们已经建立了一个启用了物理的房间，并创建了几个具有夹具和物理属性的对象。我们使用关节将一系列实例连接在一起，并对一个对象施加力以使其移动。现在我们准备开始建立推倒塔游戏！
- en: Building a tower toppling game
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立推倒塔游戏
- en: 'In order to build a tower toppling game, the first elements we need to create
    are the support structures. We already have a Steel Pillar, which will be the
    strongest piece, but we will need several more. There will be three material types
    that will each have unique physics properties: Steel, Wood, and Glass. There will
    also need to be two different sizes, large and small, for variation. Finally,
    we want the large structures to be able to break apart into small chunks of Debris.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立一个推倒塔游戏，我们需要创建的第一个元素是支撑结构。我们已经有了一个钢柱，它将是最坚固的部分，但我们还需要几个。将有三种材料类型，每种材料都具有独特的物理属性：钢、木和玻璃。还需要两种不同的尺寸，大和小，以便变化。最后，我们希望大型结构能够分解成小块的碎片。
- en: Constructing the Pillars and Debris
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建柱子和碎片
- en: We will start by building all the additional Steel Pillars and Debris.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先建立所有额外的钢柱和碎片。
- en: Create a new Sprite, `spr_Pillar_Steel_Small`, and load `Chapter 6/Sprites/Pillar_Steel_Small.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，`spr_Pillar_Steel_Small`，并加载`Chapter 6/Sprites/Pillar_Steel_Small.png`，勾选**Remove
    Background**。将原点居中，然后点击**OK**。
- en: Rather than making a new object, right click on `obj_Pillar_Steel` and **Duplicate**
    the object. This will keep the properties the same so we don't have to repeat
    most of that work. Rename this to `obj_Pillar_Steel_Small`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是创建一个新对象，右键单击`obj_Pillar_Steel`，然后**Duplicate**该对象。这样可以保持属性不变，因此我们不必重复大部分工作。将其重命名为`obj_Pillar_Steel_Small`。
- en: Change the Sprite to `spr_Pillar_Steel_Small`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵更改为`spr_Pillar_Steel_Small`。
- en: As this is a duplicate of a larger object, we need to adjust the fixture. Click
    on **Modify Collision Shape** to open the **Physics Shape** editor, and move the
    points to properly fit the smaller sprite. We are done with this Pillar and the
    **Object Properties** should look like the following screenshot:![Constructing
    the Pillars and Debris](img/4100OT_06_12.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个较大对象的副本，我们需要调整夹具。点击**Modify Collision Shape**以打开**Physics Shape**编辑器，并移动点以适当地适应较小的精灵。我们已经完成了这个柱子，**Object
    Properties**应该看起来像以下的截图：![构建柱子和碎片](img/4100OT_06_12.jpg)
- en: Create a new Sprite, `spr_Debris_Steel_01`, and load `Chapter 6/Sprites/Debris_Steel_01.png`
    with **Remove Background** checked.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，`spr_Debris_Steel_01`，并加载`Chapter 6/Sprites/Debris_Steel_01.png`，勾选**Remove
    Background**。
- en: 'When a Pillar becomes Debris, we will want to make sure each piece is placed
    and rotated correctly. In order to do this, we will need to place the origin as
    it would correspond to the Pillar''s origin. This debris comes from the upper-left
    corner, so set the origin to **X**: `16`, **Y**: `64` and click on **OK**.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当柱子变成碎片时，我们希望确保每个部分都被正确放置和旋转。为了做到这一点，我们需要将原点放置在与柱子原点对应的位置。这些碎片来自左上角，因此将原点设置为**X**：`16`，**Y**：`64`，然后点击**OK**。
- en: Let's duplicate the `obj_Pillar_Steel` again, name it `obj_Debris_Steel_01`
    and change the sprite to `spr_Debris_Steel_01`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次复制`obj_Pillar_Steel`，将其命名为`obj_Debris_Steel_01`，并将精灵更改为`spr_Debris_Steel_01`。
- en: All Debris comes in odd shapes and we will want the collision to reflect that.
    In the **Physics Properties** editor, change **Collision Shape** to **Shape**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有碎片都呈奇怪的形状，我们希望碰撞反映出这一点。在**Physics Properties**编辑器中，将**Collision Shape**更改为**Shape**。
- en: Click on **Modify Collision Shape** to open the **Physics Shape** editor and
    move the points to properly fit the Debris. You will notice that it likely has
    given you a triangle to start. To add additional points, just click away from
    the existing points. One other important note is that a Shape fixture must always
    be built in a clockwise manner in order for the physics to work properly. The
    collision shape should look like the following screenshot:![Constructing the Pillars
    and Debris](img/4100OT_06_13.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Modify Collision Shape**以打开**Physics Shape**编辑器，并移动点以适当地适应碎片。您会注意到它可能已经给了您一个三角形的起点。要添加额外的点，只需点击远离现有点的位置。另一个重要的注意事项是，为了使物理正常工作，形状夹具必须始终按顺时针的方式构建。碰撞形状应该看起来像以下的截图：![构建柱子和碎片](img/4100OT_06_13.jpg)
- en: Create a new Sprite, `spr_Debris_Steel_``02`, and load `Chapter 6/Sprites/Debris_Steel_02.png`
    with **Remove Background** checked.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，`spr_Debris_Steel_02`，并加载`Chapter 6/Sprites/Debris_Steel_02.png`，勾选**Remove
    Background**。
- en: 'Set the origin to **X**: `0`, **Y**: `64` and click on **OK**.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点设置为**X**：`0`，**Y**：`64`，然后点击**OK**。
- en: Duplicate `obj_Debris_Steel_01`, rename it `obj_Debris_Steel_02`, and set the
    **Sprite** to `spr_Debris_Steel_02`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`obj_Debris_Steel_01`，将其重命名为`obj_Debris_Steel_02`，并将**Sprite**设置为`spr_Debris_Steel_02`。
- en: Once again, click on **Modify Collision Shape** and adjust the points appropriately
    as seen in the following screenshot:![Constructing the Pillars and Debris](img/4100OT_06_14.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击“修改碰撞形状”，并根据以下屏幕截图调整点的位置：![构建支柱和碎片](img/4100OT_06_14.jpg)
- en: We have one more piece of Debris to make, create a new Sprite, `spr_Debris_Steel_03`,
    and load `Chapter 6/Sprites/Debris_Steel_03.png` with **Remove Background** checked.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要制作最后一个碎片，创建一个新精灵，“spr_Debris_Steel_03”，并加载“第6章/精灵/Debris_Steel_03.png”，勾选“去除背景”。
- en: 'Set the origin to **X**: `16`, **Y**: `0` and click on **OK**.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点设置为“X”：`16`，“Y”：`0`，然后点击“确定”。
- en: Duplicate `obj_Debris_Steel_01`, rename it `obj_Debris_Steel_03`, and change
    the **Sprite** to `spr_Debris_Steel_03`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制“obj_Debris_Steel_01”，将其重命名为“obj_Debris_Steel_03”，并将“精灵”更改为“spr_Debris_Steel_03”。
- en: We will need five total points on this object, so click on Modify **Collision
    Shape** and adjust the points appropriately as seen in the following screenshot.
    We are done with the Steel Debris:![Constructing the Pillars and Debris](img/4100OT_06_15.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个对象需要五个点，因此点击“修改碰撞形状”，并根据以下屏幕截图调整点的位置。我们已完成钢碎片：![构建支柱和碎片](img/4100OT_06_15.jpg)
- en: Next, we will build the Wood Pillar and associated parts. We won't go through
    every step, as it is just going to be repeating the process we just went through
    with the Steel Pillar. We will, however, build the first Pillar of the other material
    types. Create a new Sprite, `spr_Pillar_Wood` and load `Chapter 6/Sprites/Pillar_Wood.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将构建木支柱及其相关部分。我们不会逐步介绍每个步骤，因为这只是重复我们刚刚用钢支柱进行的过程。但是，我们将构建其他材料类型的第一个支柱。创建一个新精灵，“spr_Pillar_Wood”，并加载“第6章/精灵/Pillar_Wood.png”，勾选“去除背景”。将原点居中，然后点击“确定”。
- en: Create a new Object, `obj_Pillar_Wood`, and assign `spr_Pillar_Wood` as the
    **Sprite**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，“obj_Pillar_Wood”，并将“spr_Pillar_Wood”分配为“精灵”。
- en: Set the **Parent** to `obj_Pillar_Parent`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“父对象”设置为“obj_Pillar_Parent”。
- en: Check **Uses Physics**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“使用物理”。
- en: Change the **Collision Shape** to **Box**. The collision shape should automatically
    fit the Sprite as it is a new object, so we don't need to modify the shape.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“碰撞形状”更改为“矩形”。由于这是一个新对象，碰撞形状应自动适应精灵，因此我们不需要修改形状。
- en: Wood is much lighter than Steel, so we want to make it move with just a little
    force. Set the **Density** to `8`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 木材比钢轻得多，因此我们希望它只需很小的力就能移动。将“密度”设置为`8`。
- en: Wood also bounces a lot more as it can easily flex, therefore we should set
    **Restitution** to `0.2`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 木材弹性更大，因此应将“恢复”设置为`0.2`。
- en: We will say that this Wood is less coarse than the Steel and set **Friction**
    to `0.5`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将说这种木材比钢更不粗糙，并将“摩擦”设置为`0.5`。
- en: Set the values for **Collision Group**, **Linear Damping**, and **AngularDamping**
    to `0`, as we will not want the Pillar affected by them.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“碰撞组”、“线性阻尼”和“角阻尼”的值设置为`0`，因为我们不希望支柱受到它们的影响。
- en: We need to add events for `obj_Ground` and `obj_Pillar_Parent` with comments
    attached for the collision detection to work. If you are wondering why we don't
    just put it in the `obj_Pillar_Parent`, it's because we will be adding scripts
    for Debris to these events later.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为“obj_Ground”和“obj_Pillar_Parent”添加事件，并附上注释以使碰撞检测起作用。如果你想知道为什么我们不直接将其放在“obj_Pillar_Parent”中，那是因为我们稍后将为这些事件添加碎片脚本。
- en: We are done with the Wood Pillar, which means we can now create the Small Wood
    Pillar and the Wood Debris. Go ahead and build all these parts with the files
    provided in `Chapter 6/Sprites/`. Make sure the object properties are all the
    same as can be seen in the following screenshot:![Constructing the Pillars and
    Debris](img/4100OT_06_16.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 木支柱已完成，这意味着我们现在可以创建小木支柱和木碎片。继续使用“第6章/精灵/”中提供的文件构建所有这些部分。确保对象属性与以下屏幕截图中所示的相同：![构建支柱和碎片](img/4100OT_06_16.jpg)
- en: Our last Pillar, and the weakest one, is the one made out of Glass. Create a
    new Sprite, `spr_Pillar_Glass`, and load `Chapter 6/Sprites/Pillar_Glass.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一个支柱，也是最脆弱的支柱，是由玻璃制成的。创建一个新精灵，“spr_Pillar_Glass”，并加载“第6章/精灵/Pillar_Glass.png”，勾选“去除背景”。将原点居中，然后点击“确定”。
- en: Create a new Object, `obj_Pillar_Glass`, with its **Sprite** set to `spr_Pillar_Glass`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，“obj_Pillar_Glass”，其“精灵”设置为“spr_Pillar_Glass”。
- en: Set the Parent to `obj_Pillar_Parent`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将父对象设置为“obj_Pillar_Parent”。
- en: Check **Uses Physics** and change the **Collision Shape** to **Box**.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“使用物理”并将“碰撞形状”更改为“矩形”。
- en: Glass is the lightest material and we want it to move with very little force.
    Set the **Density** to `2`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玻璃是最轻的材料，我们希望它只需很小的力就能移动。将“密度”设置为`2`。
- en: We want the Glass to rattle a lot so we will set **Restitution** to `0.3`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望玻璃会发出很多声音，因此将“恢复”设置为`0.3`。
- en: The Glass should be very slick with a **Friction** value of `0.07`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玻璃应该非常光滑，具有摩擦值`0.07`。
- en: As with the other Pillars, set the values for **Collision Group**, **Linear
    Damping**, and **Angular Damping** to `0`, as we will not want the Pillar affected
    by them.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他支柱一样，将“碰撞组”、“线性阻尼”和“角阻尼”的值设置为`0`，因为我们不希望支柱受到它们的影响。
- en: Finally, we need to add events for `obj_Ground` and `obj_Pillar_Parent` with
    comments attached for the collision detection to work. The final set up should
    look like the following screenshot:![Constructing the Pillars and Debris](img/4100OT_06_17.jpg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为`obj_Ground`和`obj_Pillar_Parent`添加事件，并附上注释以使碰撞检测起作用。最终设置应如以下屏幕截图所示：![构建支柱和碎片](img/4100OT_06_17.jpg)
- en: As we did with the other Pillars, create the remaining Glass pieces with the
    assets provided in `Chapter 6/Sprites/`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他支柱一样，使用“第6章/精灵/”中提供的资源创建剩余的玻璃碎片。
- en: Now that all the Pillars have been created, reopen Sandbox and place a few Pillars
    and some TNT. Run the Game and notice how the various materials react. The Glass
    will move easily while the Steel is fairly rigid. The Wood appears to react somewhere
    in between those two.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有的柱子都已经创建好了，重新打开沙盒并放置一些柱子和一些TNT。运行游戏，注意各种材料的反应。玻璃会轻易移动，而钢是相当坚固的。木头似乎在这两者之间有所反应。
- en: Breaking the Pillars into Debris
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将柱子打碎成碎片
- en: We have already created all the necessary objects for spawning Debris from the
    Pillars; we just need to write the functionality for the switch between the two.
    To do this, we will build a simple system that can be used by all Pillars. In
    this game we will only break apart the larger Pillars. The small Pillar and the
    Debris will be destroyed if enough force is applied.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了从柱子生成碎片所需的所有对象；我们只需要编写两者之间切换的功能。为此，我们将构建一个简单的系统，可以用于所有柱子。在这个游戏中，我们只会打碎较大的柱子。如果施加了足够的力，小柱子和碎片将被销毁。
- en: We will start with the weakest object, the Glass Pillar, by initializing some
    variables. Create a new Script, `scr_Pillar_Glass_Create`, and apply this to a
    **Create** event in `obj_Pillar_Glass`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从最脆弱的物体，玻璃柱开始，初始化一些变量。创建一个新的脚本，`scr_Pillar_Glass_Create`，并将其应用于`obj_Pillar_Glass`的**创建**事件。
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first variable we have will be used for the amount of damage a Pillar can
    take. In this case, the Glass Pillar requires at least five points of damage to
    break apart. Next we are setting variables for each piece of Debris that we will
    need to spawn.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要使用的变量将用于柱子可以承受的伤害量。在这种情况下，玻璃柱需要至少五点伤害才能分解。接下来，我们为需要生成的每个碎片设置变量。
- en: 'Create a new Script, `scr_Pillar_BreakApart` with the following code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Pillar_BreakApart`，其中包含以下代码：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start by determining the velocity of the collision, so that it only applies
    to moving objects, not static ones. We are using a function called abs, which
    will ensure that the velocity we are given is always a positive number. This will
    make the comparison much easier, as we don't need to consider the direction of
    movement. If the colliding object is moving faster than the damage amount of the
    Pillar, we then check a second conditional statement comparing the mass of the
    two instances involved in the collision. We only want the Pillar to break apart
    if it is hit by something stronger than itself. It would not make any sense to
    have a Glass Pillar destroy a Steel Pillar. If a Pillar is hit by a heavier object,
    we then spawn the Debris. For each piece of Debris, we need to place it in the
    appropriate position based on the physics speed and rotation of the Pillar it
    is spawning from. Once we have created the Debris, we destroy the Pillar.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确定碰撞的速度，这样它只适用于移动的物体，而不是静止的物体。我们使用一个叫做abs的函数，它将确保我们得到的速度始终是一个正数。这将使比较变得更容易，因为我们不需要考虑运动的方向。如果碰撞物体的速度比柱子的伤害量快，那么我们就检查第二个条件语句，比较碰撞中涉及的两个实例的质量。我们只希望柱子在被比自身更强的东西击中时分解。让玻璃柱摧毁钢柱是毫无意义的。如果柱子被更重的物体击中，我们就生成碎片。对于每个碎片，我们需要根据柱子的物理速度和旋转将其放在适当的位置。创建了碎片后，我们销毁了柱子。
- en: Add this script to the `obj_Pillar_Parent` event in `obj_Pillar_Glass`. We can
    remove the comment as it is no longer needed for the collision to work.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此脚本添加到`obj_Pillar_Glass`中的`obj_Pillar_Parent`事件。我们可以删除注释，因为它不再需要用于碰撞。
- en: Reopen `Sandbox` and place a single instance of TNT, with a Glass Pillar and
    Steel Pillar on either side. It should look like the following screenshot:![Breaking
    the Pillars into Debris](img/4100OT_06_18.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`Sandbox`，在两侧分别放置一个玻璃柱和钢柱的单个TNT实例。它应该看起来像下面的截图：![将柱子打碎成碎片](img/4100OT_06_18.jpg)
- en: Run the game and explode the TNT. We should see the Glass Pillars push out to
    the side, collide with the Steel Pillars, and then break apart into a pile of
    Debris, like the following screenshot:![Breaking the Pillars into Debris](img/4100OT_06_19.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并引爆TNT。我们应该看到玻璃柱向外推，与钢柱碰撞，然后分解成一堆碎片，就像下面的截图：![将柱子打碎成碎片](img/4100OT_06_19.jpg)
- en: Let's move onto the Wood Pillar. Create a new Script, `scr_Pillar_Wood_Create`,
    and initialize the necessary variables. Add them to a **Create** event in `obj_Pillar_Wood`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续进行木柱。创建一个新的脚本，`scr_Pillar_Wood_Create`，并初始化必要的变量。将它们添加到`obj_Pillar_Wood`的**创建**事件中。
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have increased the required velocity of the damage to be applied in order
    for it to break apart. Glass is easy to shatter, while wood is not. We have also
    assigned the appropriate Debris to the Wood.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经增加了需要施加的伤害速度，以便它能够分解的要求。玻璃容易破碎，而木头不容易。我们还为木头分配了适当的碎片。
- en: Remove the comment from the `obj_Pillar_Parent` and add `scr_Pillar_BreakApart`
    instead.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`obj_Pillar_Parent`中删除注释，并添加`scr_Pillar_BreakApart`。
- en: Reopen `Sandbox` and replace the Glass Pillars with Wood Pillars.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`Sandbox`，用木柱替换玻璃柱。
- en: Run the game and explode the TNT. The Wood will move outwards, but will not
    shatter. This result is intended as we said we need more force to break it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并引爆TNT。木头会向外移动，但不会破碎。这个结果是有意的，因为我们说需要更大的力量才能打破它。
- en: Add another instance of TNT below the one existing in `Sandbox`. This will apply
    more force when it is detonated.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Sandbox`中添加另一个TNT实例，放在现有的TNT下方。这样在引爆时会施加更大的力。
- en: Run the game. As can be seen in the next screenshot, this time the Wood Pillars
    move outwards and shatter on contact. The Steel Pillars will also be knocked over
    with this amount of force!![Breaking the Pillars into Debris](img/4100OT_06_20.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。如下一张截图所示，这次木柱向外移动并在接触时破碎。钢柱也会因为这种力量而倒下！![将柱子打碎成碎片](img/4100OT_06_20.jpg)
- en: We only have the Steel Pillar remaining. We will set it up to function properly,
    though at this point we will not be able to test it, as there are no objects with
    more density than it. Create a new Script, `scr_Pillar_Steel_Create`, and add
    it to a **Create** event in `obj_Pillar_Steel`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只剩下钢柱了。我们将设置它以正常运行，尽管在这一点上我们将无法测试它，因为没有比它更密度大的物体。创建一个新的脚本，`scr_Pillar_Steel_Create`，并将其添加到`obj_Pillar_Steel`的**Create**事件中。
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The same as before, we have increased the required velocity for damage and set
    the correct Debris to spawn.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们增加了造成伤害所需的速度，并设置了正确的碎片生成。
- en: We also need to remove the comment from the `obj_Pillar_Parent` and replace
    it with `scr_Pillar_BreakApart`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从`obj_Pillar_Parent`中删除注释，并替换为`scr_Pillar_BreakApart`。
- en: 'We now have the Pillars breaking apart into smaller pieces when they are hit
    with enough force. Next, we need to destroy the small Pillars and the Debris when
    enough force collides with them. Create a new Script, `scr_Pillar_Destroy`, with
    the following code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经让柱子在受到足够的力量时分解成小块。接下来，我们需要在足够的力量碰撞到它们时摧毁小柱子和碎片。创建一个新的脚本，`scr_Pillar_Destroy`，并添加以下代码：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similar to `scr_Pillar_BreakApart`, we check the velocity of the colliding object
    and then compare mass to see if it should be destroyed. Here is where the difference
    between density and mass becomes apparent. All of the Debris have the same density
    as the Pillar that spawned it, which means that the solidity is the same. However,
    the bigger the object is, the more mass it will have. This means that smaller
    Debris chunks can be destroyed by larger Debris chunks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与`scr_Pillar_BreakApart`类似，我们检查碰撞物体的速度，然后比较质量，看看是否应该被摧毁。这里是密度和质量之间的差异变得明显的地方。所有的碎片都有与生成它的柱子相同的密度，这意味着它们的坚固度是相同的。然而，物体越大，质量就越大。这意味着较小的碎片可以被较大的碎片摧毁。
- en: Apply this script to all small Pillars and Debris in their respective `obj_Pillar_Parent`
    events.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此脚本应用于它们各自的`obj_Pillar_Parent`事件中的所有小柱子和碎片。
- en: This script uses the same variables as the type of Pillar it is, which means
    that we need to initialize them. We can reuse the existing script to save us some
    time. For each small Pillar and Debris, add a **Create** event and apply the appropriate
    Pillar Create script, as in all Glass should have `scr_Pillar_Glass_Create` assigned.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本使用与其类型相同的变量，这意味着我们需要初始化它们。我们可以重用现有的脚本来节省时间。对于每个小柱子和碎片，添加一个**Create**事件，并应用适当的柱子创建脚本，就像所有玻璃都应该分配`scr_Pillar_Glass_Create`一样。
- en: Time to test this out. Reopen `Sandbox` and place two instances of Glass Pillars
    on top of the Wood Pillars, so that it looks like the following screenshot:![Breaking
    the Pillars into Debris](img/4100OT_06_21.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候测试一下了。重新打开`Sandbox`，并在木柱顶部放置两个玻璃柱，使其看起来像下面的截图：![Breaking the Pillars into
    Debris](img/4100OT_06_21.jpg)
- en: Run the game and explode the TNT. The Glass Pillars should shatter easily and
    most of the Debris will disappear very quickly. The Wood Pillars will also splinter
    a bit and most of its Debris disappears. The Steel Pillars will rock slightly,
    but remain undamaged.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并引爆TNT。玻璃柱应该很容易破碎，大部分碎片会很快消失。木柱也会有些裂痕，大部分碎片会消失。钢柱会稍微摇晃，但不会受损。
- en: Adding in the collision sounds
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加碰撞声音
- en: Everything is functioning, though a bit boring, due to the lack of sound. The
    Debris being destroyed so quickly is also not very satisfying. Let's fix both
    of these issues.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都运行正常，尽管有点无聊，因为缺少声音。碎片被很快摧毁也不太令人满意。让我们解决这两个问题。
- en: First we need to bring in some sounds. Create a new Sound, `snd_Shatter_Glass`,
    and load `Chapter 6/Sounds/Shatter_Glass.wav`. The default values will work, just
    make sure that **Kind** is set to **Normal Sound**. This effect will be for when
    the Glass breaks apart.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们需要引入一些声音。创建一个新的声音，`snd_Shatter_Glass`，并加载`Chapter 6/Sounds/Shatter_Glass.wav`。默认值将起作用，只需确保**Kind**设置为**Normal
    Sound**。这个效果是当玻璃破碎时使用的。
- en: We also want a sound for when the Glass Pillars do not break. Create another
    new Sound, `snd_Impact_Glass` and load `Chapter 6/Sounds/Impact_Glass.wav`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望在玻璃柱不破裂时有声音。创建另一个新声音，`snd_Impact_Glass`，并加载`Chapter 6/Sounds/Impact_Glass.wav`。
- en: Repeat this process for the Wood and Steel sound effects.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为木头和钢铁的声音效果重复这个过程。
- en: 'We need to initialize some variables, so reopen `scr_Pillar_Glass_Create` and
    add the following at the end of the script:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要初始化一些变量，所以重新打开`scr_Pillar_Glass_Create`，并在脚本的末尾添加以下内容：
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by assigning variables to the `Impact` and `Shatter` sounds. We will
    only want to allow the impact sound to play a single time, so we have created
    the `isTapped` variable. The `isActive` variable and the alarm are going to be
    used, so that no sound is made when the game starts. When the physics system begins,
    all active instances in the world will have gravity applied, which will cause
    collisions. This in turn means that the impact sound will occur when nothing appears
    to be moving.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为`Impact`和`Shatter`声音分配变量。我们只希望允许撞击声音播放一次，所以我们创建了`isTapped`变量。`isActive`变量和警报将被使用，以便在游戏开始时不会发出声音。当物理系统开始时，世界中的所有活动实例都将受到重力的影响，这将导致碰撞。这反过来意味着当似乎没有东西在移动时，撞击声音会发生。
- en: Reopen `scr_Pillar_Wood_Create` and `scr_Pillar_Steel_Create`, and add the same
    code with the appropriate sounds.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Pillar_Wood_Create`和`scr_Pillar_Steel_Create`，并添加相同的代码和适当的声音。
- en: 'Now we can start implementing the sounds. Open `scr_Pillar_BreakApart` and
    insert the following line of code before the instance is destroyed:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现声音了。打开`scr_Pillar_BreakApart`，并在实例被销毁之前插入以下代码行：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the Debris spawns, we will play the Shatter sound a single time. Notice
    that we have given this sound a priority of 10, which means that if too many sounds
    need to be played, this sound will be chosen over lower priority sounds.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当碎片生成时，我们将播放一次Shatter声音。请注意，我们已经给这个声音设置了优先级为10，这意味着如果需要播放太多声音，这个声音将优先于优先级较低的声音。
- en: Still in the script, we need to play the impact sound if a collision occurs,
    but does not break the Pillar. We will add an `else` statement immediately after
    the instance is destroyed.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中，如果发生碰撞但没有破坏支柱，我们需要播放碰撞声音。在实例被销毁后立即添加一个`else`语句。
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If only a minor collision has occurred, we check to see if we have run the sound
    before. If we haven't, then we play the impact sound, with a low priority, and
    stop this code from executing again.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只发生了轻微的碰撞，我们会检查是否之前已经播放了声音。如果没有，那么我们会播放撞击声音，优先级较低，并阻止该代码再次执行。
- en: 'We only have one thing left to do in this script and that is to place all of
    the code into a conditional statement, so that it executes only if the instance
    is active. Add the check at the top of the script and place braces around all
    the existing code. When it is done, the whole script will look like the following:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们只剩下一件事要做，那就是将所有的代码放入条件语句中，这样它只有在实例处于活动状态时才会执行。在脚本顶部添加检查，并在所有现有代码周围加上大括号。完成后，整个脚本将如下所示：
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to repeat this process for `scr_Pillar_Destroy`, so that the shatter
    sound is played on destruction, the impact sound on a light collision, and all
    of this when the instance is active. Here is the code in its entirety:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要重复这个过程，对`scr_Pillar_Destroy`进行修改，以便在销毁时播放粉碎声音，在轻微碰撞时播放碰撞声音，并且在实例处于活动状态时执行所有这些操作。以下是完整的代码：
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In order for the sounds to work, we need to make them active. Create a new Script,
    `scr_Pillar_Alarm0` and set `isActive` to `true`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使声音正常工作，我们需要使它们处于活动状态。创建一个新的脚本，`scr_Pillar_Alarm0`，并将`isActive`设置为`true`。
- en: Rather than adding an alarm for every pillar and debris, we can just add an
    **Alarm 0** event to `obj_Pillar_Parent`. This will not cause any conflicts because
    the alarm will only be run once per instance and only changes a variable.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要为每个支柱和碎片都添加一个警报，只需在`obj_Pillar_Parent`中添加一个**警报0**事件。这不会引起任何冲突，因为警报每个实例只运行一次，并且只改变一个变量。
- en: Run the game, explode the TNT and listen. We can hear the different sounds as
    the Pillars break apart and collide with each other. Also notice that there is
    more Debris now remaining. This is because there is now a one second delay before
    they can destroy themselves, which allows time for the Debris to escape any collision
    that happens upon creation.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏，引爆TNT并听着。我们可以听到不同的声音，因为支柱破碎并相互碰撞。还要注意现在剩下更多的碎片。这是因为现在它们在销毁自己之前有一秒的延迟，这样就有时间让碎片逃离在创建时发生的任何碰撞。
- en: Building the demolition equipment
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造拆迁设备
- en: 'We have everything we need to build towers, but this game is all about demolition.
    The player would become bored if all they had was TNT to destroy the towers. We
    are going to utilize some more physics functions and create some new equipment:
    a Wrecking Ball and a Magnetic Crane.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了建造塔所需的一切，但这个游戏的重点是拆除。如果玩家只能使用TNT来摧毁塔，他们会感到无聊。我们将利用一些更多的物理函数，并创建一些新的设备：破坏球和磁吊机。
- en: Creating a Wrecking Ball
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个破坏球
- en: Let's start with the Wrecking Ball as we have already built a large portion
    of it. We will utilize the Chain and Anchor and add a Ball to it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从破坏球开始，因为我们已经建造了它的大部分。我们将利用链条和锚点，并在其上添加一个球。
- en: Create a new Sprite, `spr_WreckingBall`, and load `Chapter 6/Sprites/WreckingBall.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，`spr_WreckingBall`，并加载`Chapter 6/Sprites/WreckingBall.png`，勾选**去除背景**。居中原点，然后点击**确定**。
- en: Create a new Object, `obj_WreckingBall`, and apply the `spr_WreckingBall` as
    its **Sprite**.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_WreckingBall`，并将`spr_WreckingBall`应用为其**Sprite**。
- en: We will want the Wrecking Ball to always be drawn in front of the chain that
    holds it. Set **Depth** to `-100`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望破坏球始终显示在支撑它的链条前面。将**深度**设置为`-100`。
- en: Check the box for **Uses Physics**. We do not need to change Collision Shape,
    as the Wrecking Ball is a circle.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**使用物理**。我们不需要更改碰撞形状，因为破坏球是一个圆形。
- en: We want this Wrecking Ball to be very powerful, so set **Density** to `50`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个破坏球非常强大，所以将**密度**设置为`50`。
- en: As it is such a heavy object and hanging from a chain, it should not be able
    to spin very much. To slow the rotation, set the **AngularDamping** to `5`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它是一个如此沉重的物体，悬挂在链条上，它不应该能够旋转太多。为了减慢旋转速度，将**AngularDamping**设置为`5`。
- en: All other physics values for this object should be set to `0`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该对象的所有其他物理值都应设置为`0`。
- en: 'We are done building the Wrecking Ball, so now we need to add it to the Anchor
    and Chain. Reopen `scr_Anchor_Create` and add the following code at the end of
    the script:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经建造了破坏球，现在需要将其添加到锚点和链条上。重新打开`scr_Anchor_Create`，并在脚本末尾添加以下代码：
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we are creating a Wrecking Ball at the end of the Chain, with a 24 pixel
    offset so it is positioned correctly. We then add a Revolute Joint between the
    last link in the Chain and the Wrecking Ball with a rotational limit of 30 degrees
    in either direction.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在链条末端创建一个破坏球，偏移24像素以便正确定位。然后在链条的最后一个链接和破坏球之间添加一个旋转关节，旋转限制为每个方向30度。
- en: Next, we need to add the collision. We are not going to place the collision
    on the Wrecking Ball, as the existing scripts are going to look for variables
    that the Wrecking Ball will not have. Instead, we will start by reopening `obj_Pillar_Parent`
    and adding an `obj_WreckingBall` event, and attaching `scr_Pillar_Destroy`. As
    all Pillars and Debris are parented to the object, they will all respond to this
    event.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加碰撞。我们不会在破坏球上放置碰撞，因为现有的脚本将查找破坏球不会有的变量。相反，我们将从重新打开`obj_Pillar_Parent`开始，添加一个`obj_WreckingBall`事件，并附加`scr_Pillar_Destroy`。因为所有支柱和碎片都是该对象的子对象，它们都会响应这个事件。
- en: While this last step will work fine, it also means the large Pillars will be
    destroyed on contact as well. We want the large Pillars to always break apart
    first. We can still do this by reopening the three Pillars, `obj_Pillar_Glass`,
    `obj_Pillar_Wood`, and `obj_Pillar_Steel`, and add an `obj_WreckingBall` event
    with `scr_Pillar_BreakApart` attached. If a parent object and one of its children
    both have the same type of event, be it collision, step, or whatever, the child's
    event will be executed and the parent's event will be ignored.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然最后一步将正常工作，但这也意味着大柱子也会在接触时被摧毁。我们希望大柱子始终首先破裂。我们仍然可以通过重新打开三个柱子`obj_Pillar_Glass`，`obj_Pillar_Wood`和`obj_Pillar_Steel`，并添加一个带有`scr_Pillar_BreakApart`的`obj_WreckingBall`事件来实现这一点。如果父对象和其子对象都具有相同类型的事件，无论是碰撞、步进还是其他事件，子对象的事件将被执行，父对象的事件将被忽略。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to execute both the parent event and the child event together
    by using the function `event_inherited()` in the child's event code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在子事件代码中使用函数`event_inherited()`同时执行父事件和子事件。
- en: Let's test this out. Reopen `Sandbox` and place an instance of `obj_Anchor`
    in the room, just off to the right of the existing Pillars. We can also remove
    the TNT as we do not need it for this test. The setup should look like the following
    screenshot:![Creating a Wrecking Ball](img/4100OT_06_22.jpg)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试一下。重新打开`Sandbox`，并在房间中放置一个`obj_Anchor`的实例，就在现有柱子的右侧。我们还可以移除TNT，因为我们不需要它进行测试。设置应该看起来像以下屏幕截图：![创建破坏球](img/4100OT_06_22.jpg)
- en: Run the game. We should see the Wrecking Ball swing down attached to the Chain
    and Anchor. When the Wrecking Ball collides with the Steel Pillar, the Pillar
    breaks apart, as do many of the other Pillars. Everything works correctly, but
    there is a bit of an issue. The Wrecking Ball falls immediately, when it should
    wait to be triggered. Let's fix all that.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。我们应该看到破坏球挂在链和锚上摆动。当破坏球与钢柱碰撞时，柱子会破裂，其他许多柱子也会破裂。一切都运行正常，但存在一些问题。破坏球立即下落，而它应该等待被触发。让我们修复所有这些。
- en: 'In order for us to stop the Wrecking Ball from moving immediately, we need
    to deactivate from the World Physics. This is simply done by setting the `phy_active`
    variable to false for each instance we want to stop. Reopen `scr_Anchor_Create`
    and apply this change for the Wrecking Ball and every Chain. The entire script
    can be seen in the following code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们能够立即停止破坏球的移动，我们需要从世界物理中停用。这只需将`phy_active`变量设置为false，以停止我们想要停止的每个实例。重新打开`scr_Anchor_Create`，并对破坏球和每个链应用此更改。整个脚本可以在以下代码中看到：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Wrecking Ball and Chain will no longer move at the start, but we still need
    to be able to trigger it at some point. Create a new Script, `scr_Anchor_Activate`,
    and for testing purposes, attach it to a **Space** event under **Key Press**.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 破坏球和链将不再在开始时移动，但我们仍然需要在某个时候触发它。创建一个新脚本，`scr_Anchor_Activate`，并将其附加到**按键按下**下的**空格**事件以进行测试。
- en: '[PRE23]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When this script is run, a simple `for` loop activates every Chain, and then
    the Wrecking Ball.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此脚本时，一个简单的`for`循环会激活每个链，然后激活破坏球。
- en: Run the game. The Wrecking Ball should be extended out to the right and static.
    When we hit the space key, the Wrecking Ball and Chain should become active and
    swing down, colliding into the tower. The collision itself is much higher on the
    tower, as the Chain is now fairly rigid with only a little elasticity. It looks
    like we are done!
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。破坏球应该向右延伸并保持静止。当我们按下空格键时，破坏球和链应该变得活跃并摆动下来，撞击到塔上。碰撞本身在塔上更高，因为链现在相当刚硬，只有一点弹性。看起来我们已经完成了！
- en: Making a Magnetic Crane
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作磁吊车
- en: Our third piece of demolition equipment will be a Magnetic Crane. This Crane
    will drop down and pick up any small Pillar and Debris made from Steel. It will
    then raise itself back up with whatever it has collected.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个拆迁设备将是一个磁吊车。这个吊车将下降并拾起任何由钢制成的小柱子和碎片。然后它将带着它收集到的任何东西抬起来。
- en: We will start by building the Magnet itself. Create a new Sprite, `spr_Magnet`,
    and load `Chapter 6/Sprites/Magnet.png` with **Remove Background** checked. Center
    the origin, and click on **OK**.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先建立磁铁本身。创建一个新的精灵，`spr_Magnet`，并加载`Chapter 6/Sprites/Magnet.png`，并勾选**删除背景**。居中原点，然后点击**确定**。
- en: Create a new Object, `obj_Magnet`, and assign `spr_Magnet` as the **Sprite**.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Magnet`，并将`spr_Magnet`分配为**精灵**。
- en: Check the box for **Uses Physics** and set **Collision Shape** to **Box**.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**使用物理**并将**碰撞形状**设置为**矩形**。
- en: We will want to make the collision area smaller, so that when it picks up objects,
    the effect appears more believable. Click on **Modify Collision Shape** and pull
    the sides in so that it looks like the following screenshot:![Making a Magnetic
    Crane](img/4100OT_06_23.jpg)
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将碰撞区域变小，这样当它吸起物体时，效果看起来更真实。点击**修改碰撞形状**，将侧面拉进，使其看起来像以下屏幕截图：![制作磁吊车](img/4100OT_06_23.jpg)
- en: The Magnet needs to be quite heavy so that the other objects can't push it around.
    Set **Density** to `50`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 磁铁需要相当重，这样其他物体就无法推动它。将**密度**设置为`50`。
- en: Set all the other properties to `0`, as we don't want them affecting the magnet's
    movement.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有其他属性设置为`0`，因为我们不希望它们影响磁铁的运动。
- en: As our intention is for the magnet to only pick up the small objects made of
    Steel, we should change how the Steel Debris is parented. Currently, it is parented
    to `obj_Pillar_Parent` for collision purposes. We still need to be able to have
    that ability, but we want magnetic attraction to be unique to a few objects. To
    do this, we can parent the Debris to any object that has `obj_Pillar_Parent` as
    its parent. Let's set the Parent for all Steel Debris to `obj_Pillar_Steel_Small`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的意图是让磁铁只吸起由钢制成的小物体，我们应该改变钢屑的父级关系。目前，它是为了碰撞目的而与`obj_Pillar_Parent`相关联的。我们仍然需要具有这种能力，但我们希望磁性吸引对一些物体是独特的。为了做到这一点，我们可以将碎片与任何具有`obj_Pillar_Parent`作为其父级的对象相关联。让我们将所有钢屑的父级设置为`obj_Pillar_Steel_Small`。
- en: 'We also need to add a variable to everything made of steel so that we know
    if it has been collected or not. Reopen `scr_Pillar_Steel_Create` and add the
    following line of code at the end of the script:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为所有钢制品添加一个变量，以便我们知道它是否已被收集。重新打开`scr_Pillar_Steel_Create`，并在脚本的末尾添加以下代码行：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we can make the script for the magnetic attraction. Create a new Script,
    `scr_Magnet_Step`, and attach it to a **Step** event in `obj_Magnet`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为磁性吸引力编写脚本。创建一个新的脚本，`scr_Magnet_Step`，并将其附加到`obj_Magnet`的**Step**事件上。
- en: '[PRE25]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We start by seeing whether the magnet is active and can begin collecting scrap
    metal. Next, we check if there are any small Steel Pillars, or anything parented
    to it, in the world. If there are instances in existence, we apply code directly
    to them through a `with` statement. If the instance has not been collected, we
    find the nearest Magnet, see how far away it is, and in what direction. When checking
    for the X and Y coordinates of an object in a physics game, we need to use the
    `phy_position_x` and `phy_position_y` values to accurately know where they are
    in the world space. Next, we see if the instance is within the magnetic range,
    and whether it is underneath the Magnet. If it is, we apply a strong impulse upwards,
    which will make it move towards the Magnet.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要看磁铁是否活动并开始收集废金属。接下来，我们检查世界中是否有任何小型钢柱，或者任何与之相关的实例。如果存在实例，我们通过`with`语句直接对它们应用代码。如果实例尚未被收集，我们找到最近的磁铁，看看它离磁铁有多远，以及在什么方向。在物理游戏中检查对象的X和Y坐标时，我们需要使用`phy_position_x`和`phy_position_y`值来准确地知道它们在世界空间中的位置。接下来，我们看实例是否在磁力范围内，以及它是否在磁铁下方。如果是的话，我们会向上施加一个强大的冲量，使其向磁铁移动。
- en: Once a small Steel Pillar or Debris comes in contact with the Magnet, we want
    to consider it collected and to always move with it. To do this, we will dynamically
    create a joint to any instance that collides with the Magnet. Create a new Script,
    `scr_Magnet_Collsion`, and attach it to an `obj_Pillar_Steel_Small` event in `obj_Magnet`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦一个小型钢柱或碎片接触到磁铁，我们希望将其视为已收集，并始终与其一起移动。为此，我们将动态地创建一个关节，使其与磁铁碰撞的任何实例连接。创建一个新的脚本，`scr_Magnet_Collsion`，并将其附加到`obj_Magnet`中的`obj_Pillar_Steel_Small`事件。
- en: '[PRE26]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we are making a Prismatic Joint with the magnet and the instance that collides
    with it. The first two parameters are the two instances that are to be joined,
    followed by where in the world they are connected. The fifth and sixth parameters
    are the direction it can move in, and in this case it is vertical only. The next
    three are the limits of the movement. We don't want it to move, so we set the
    min/max values to zero. The limits do need to be enabled, otherwise they won't
    lift with the Magnet. The following three are for whether there is a motor to
    move this joint. The final parameter is for collision with the objects which we
    want to avoid. Once the joint has been created, we then set the collected variable
    to `false`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用磁铁和与之碰撞的实例创建了一个棱柱关节。前两个参数是要连接的两个实例，然后是它们在世界中连接的位置。第五和第六个参数是它可以移动的方向，在这种情况下只能垂直移动。接下来的三个是移动的限制。我们不希望它移动，所以将最小/最大值设置为零。限制需要启用，否则它们将不会随着磁铁一起升起。接下来的三个是用于移动这个关节的电机。最后一个参数是与我们想要避免碰撞的对象的碰撞。关节创建后，我们将收集变量设置为`false`。
- en: Next, we need to make a base for the Crane, which will function similar to the
    Anchor. Create a new Sprite, `spr_CraneBase`, and load `Chapter 6/Sprites/CraneBase.png`
    with **Remove Background** checked. Center the origin and click on **OK**.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为起重机创建一个基座，它将类似于锚。创建一个新的Sprite，`spr_CraneBase`，并加载`Chapter 6/Sprites/CraneBase.png`，勾选**Remove
    Background**。将原点居中，然后点击**OK**。
- en: Create a new Object, `obj_CraneBase`, and apply `spr_CraneBase` as the **Sprite**.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_CraneBase`，并将`spr_CraneBase`应用为**Sprite**。
- en: Check the box for **Uses Physics** and set **Collision Shape** to **Box**.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**Uses Physics**框，并将**Collision Shape**设置为**Box**。
- en: This object is meant to be static in the physics world, so we need to set the
    **Density** to `0`. All other properties can be left at their default values.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个对象在物理世界中是静态的，所以我们需要将**Density**设置为`0`。所有其他属性都可以保留其默认值。
- en: We will want the crane base to spawn the magnet and set the joint up. Create
    a new Script, `scr_CraneBase_Create`, and attach it to a **Create** event.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望起重机基座生成磁铁并设置关节。创建一个新的脚本，`scr_CraneBase_Create`，并将其附加到**Create**事件上。
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are creating the Magnet well below the crane base and have deactivated it
    from the physics world. We then apply a Prismatic Joint between the two instances.
    This time we are allowing for 128 pixels of movement in a vertical direction.
    We are also running a motor, so that the Magnet can move up and down on its own.
    The maximum force the motor can apply is `100000` and we have the motor dropping
    the Magnet at a motor speed of `20000`. As you can see, the values we are using
    are extremely high and the reason for this is to make sure that the heavy magnet
    can lift plenty of Steel Debris.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将磁铁创建在起重机基座下方，并将其从物理世界中取消激活。然后我们在两个实例之间应用了一个棱柱关节。这次我们允许在垂直方向上移动128像素。我们还运行一个电机，这样磁铁就可以自己上下移动。电机可以施加的最大力是`100000`，我们让电机以`20000`的速度下降磁铁。正如你所看到的，我们使用的值非常高，这是为了确保重磁铁可以吊起大量的钢渣。
- en: As with the Wrecking Ball, we need to activate the crane base. Create a new
    Script, `scr_CraneBase_Activate`, and for testing purposes, attach it to the **Space**
    event under **Key Press**.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与拆迁球一样，我们需要激活起重机基座。创建一个新的脚本，`scr_CraneBase_Activate`，并将其附加到**Key Press**下的**Space**事件以进行测试。
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We want the magnet to drop down first, so we make it active in the physics world.
    We are using an alarm set for five seconds, which will raise the Magnet back up.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望磁铁首先下降，因此我们在物理世界中使其活动。我们使用了一个设置为五秒的闹钟，这将使磁铁重新上升。
- en: Create a new Script, `scr_CraneBase_Alarm0` and attach it to an **Alarm 0**
    event.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_CraneBase_Alarm0`，并将其附加到**Alarm 0**事件上。
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are setting the value for the motor speed to go up at a value of `-20000`.
    Again, we are using a very large number to ensure it goes back up with the additional
    weight of the Pillar Debris.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将电机速度的值设置为`-20000`。同样，我们使用一个非常大的数字来确保在柱子碎片的额外重量下再次上升。
- en: The last thing we need to do for the Crane is to add a cable between the crane
    base and the magnet. For this we will simply draw a line between the two. Create
    a new Script, `scr_CraneBase_Draw`, and apply it to a **Draw** event.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起重机的最后一件事是在起重机底座和磁铁之间添加一根电缆。为此，我们将简单地在两者之间画一条线。创建一个新的脚本，`scr_CraneBase_Draw`，并将其应用于**Draw**事件。
- en: '[PRE30]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Whenever a **Draw** event is used, it overrides the drawing of the default Sprite
    for the object. Therefore, we use `draw_self` to correct that override. Next we
    set a color to use, here we are using a default dark gray color, and then we draw
    an 8 pixel wide line between the crane base and the top of the magnet.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用**Draw**事件时，它会覆盖对象的默认精灵绘制。因此，我们使用`draw_self`来纠正该覆盖。接下来，我们设置要使用的颜色，这里我们使用默认的深灰色，然后在起重机底座和磁铁顶部之间绘制一条8像素宽的线。
- en: All we need to do now is to add an instance of crane base to `Sandbox`. Place
    the instance off to the left-hand side of the existing Pillars. Also add a few
    instances of Debris and the small Steel Pillar as can be seen in the following
    screenshot:![Making a Magnetic Crane](img/4100OT_06_24.jpg)
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要在`Sandbox`中添加一个起重机底座的实例。将实例放在现有柱子的左侧。还要添加一些碎片和小钢柱的实例，如下图所示：![制作磁吸起重机](img/4100OT_06_24.jpg)
- en: Run the game. The Magnet should be sitting in the air and we should notice the
    Debris shaking a bit as if there is some magnetic attraction occurring. When we
    hit space, the Magnet should drop down and collect a few pieces of Debris. After
    a few seconds, the Magnet will raise back up, taking the collected Debris with
    it. Also notice that none of the other Debris or Pillars are affected by the Magnet.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。磁铁应该悬浮在空中，我们应该注意到碎片有些摇晃，好像发生了一些磁吸。当我们按下空格键时，磁铁应该下降并收集一些碎片。几秒钟后，磁铁将再次上升，带着收集到的碎片。还要注意，其他碎片或柱子都不受磁铁的影响。
- en: Completing the game
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成游戏
- en: So far we have built a fun little toy, but it is not yet a game. We have no
    win or lose condition, no challenge, and no reward. We need to give the player
    something to do and challenge themselves with. We will start by implementing the
    win condition; remove all Pillars from a preset Zone. We will create some levels
    with a variety of Towers and Zones to clear. We will also create an Equipment
    Menu, so that the player can select what items they want to use and place them
    in the world.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经建立了一个有趣的小玩具，但它还不是一个游戏。我们没有赢或输的条件，没有挑战，也没有奖励。我们需要给玩家一些事情去做，并挑战自己。我们将从实现赢的条件开始；清除预设区域内的所有柱子。我们将创建一些具有各种塔和区域的关卡来清理。我们还将创建一个装备菜单，让玩家可以选择他们想要使用的物品，并将它们放置在世界中。
- en: Setting the win condition
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置赢的条件
- en: The win condition for this game is to clear all Pillars and Debris from a specific
    Zone. The player will only be able to activate the equipment once and will have
    a small amount of time to clear the Zone. If they clear it, they win and move
    on. If it isn't cleared, they lose and they try again.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的赢的条件是清除特定区域内的所有柱子和碎片。玩家只能激活设备一次，并且有一小段时间来清理区域。如果他们清理了，他们就赢了并继续前进。如果没有清理，他们就输了，然后再试一次。
- en: We will start by making a parent Zone that will have all the code, but is never
    actually placed into the world. Create a new Object, `obj_Zone_Parent`. There
    is no sprite to attach.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个父区域，其中包含所有代码，但实际上从未放置到世界中。创建一个新对象，`obj_Zone_Parent`。没有精灵可以附加。
- en: Create a new Script, `scr_Zone_Create`, and add it to a **Create** event.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Zone_Create`，并将其添加到**Create**事件。
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We start by stopping the animation of the assigned sprite. All the Zones will
    consist of sprites with two frames of animation. The first frame will indicate
    collision and the second frame is the all clear signal. We also have a variable
    that we will use to identify if a Pillar or Debris is in contact with the Zone.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先停止分配精灵的动画。所有区域都将包括两帧动画的精灵。第一帧表示碰撞，第二帧是全清信号。我们还有一个变量，用于识别柱子或碎片是否与区域接触。
- en: 'The Zone will need to constantly update whether it is clear of collision or
    not. Create a new Script, `scr_Zone_Step`, and attach it to a **Step** event with
    the following code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区域将需要不断更新是否清除碰撞。创建一个新的脚本，`scr_Zone_Step`，并将其附加到**Step**事件，并使用以下代码：
- en: '[PRE32]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here we are using a function, `collision_rectangle`, to determine whether the
    Pillar parent is currently in contact with the Zone. We cannot use a collision
    event to check for contact, as we need to watch for the lack of collision to happen.
    We are using the bounding box parameters of the Sprite to determine the size of
    the collision area. This will allow us to have multiple Zone sprites with a variety
    of sizes without any additional code. If there is collision, we switch to the
    first frame of the animation and indicate that collision is currently happening.
    Otherwise, we switch to the second frame of animation and indicate that the Zone
    is currently free of collision.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个函数`collision_rectangle`来确定柱子父对象当前是否与区域接触。我们不能使用碰撞事件来检查接触，因为我们需要观察缺乏碰撞的发生。我们使用精灵的边界框参数来确定碰撞区域的大小。这将允许我们拥有多个区域精灵，而无需任何额外的代码。如果发生碰撞，我们切换到动画的第一帧，并指示当前正在发生碰撞。否则，我们切换到动画的第二帧，并指示区域当前没有碰撞。
- en: 'Now that we have the parent Zone built, we can build the child Zones, which
    will be placed into the world. Create a new Sprite, `spr_Zone_01`, and load `Chapter
    6/Sprites/Zone_01.gif` with **Remove Background** checked. Leave the origin at
    **X**: `0` **Y**: `0`, so that collision will work correctly. Click on **OK**.'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经建立了父区域，我们可以建立子区域，这些区域将放置在世界中。创建一个新的精灵，`spr_Zone_01`，并加载`Chapter 6/Sprites/Zone_01.gif`，勾选**删除背景**。将原点保留在**X**：`0`
    **Y**：`0`，以便碰撞可以正常工作。点击**确定**。
- en: Create a new Object, `obj_Zone_01`, and apply `spr_Zone_01` as its **Sprite**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Zone_01`，并将`spr_Zone_01`应用为其**精灵**。
- en: We want the Zone to always be drawn behind the towers, so set **Depth** to `100`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望区域始终绘制在塔的后面，所以将**深度**设置为`100`。
- en: Set Parent to `obj_Zone_Parent` and click on **OK**.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将父对象设置为`obj_Zone_Parent`，然后点击**确定**。
- en: We have supplied a few more sprites in `Chapter 6` for variety. Repeat steps
    4 to 6 with the appropriate naming conventions for the additional zones.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Chapter 6`中提供了一些额外的精灵以增加变化。使用适当的命名约定重复步骤4到6来创建额外区域。
- en: Open `Sandbox` and place an instance of `obj_Zone_01`, so that it covers some
    of the Glass Pillars only, as seen in the following screenshot:![Setting the win
    condition](img/4100OT_06_25.jpg)
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Sandbox`并放置一个`obj_Zone_01`的实例，以便它只覆盖一些玻璃柱，如下截图所示：![设置胜利条件](img/4100OT_06_25.jpg)
- en: Run the game and activate the equipment. You should see the Zone remain red
    for as long as there are Pillars or Debris within it. Once it is clear, it will
    turn light blue, indicating that it is clear of collision.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并激活设备。只要柱子或碎片在区域内，你应该看到区域保持红色。一旦清除，它将变成浅蓝色，表示它没有碰撞。
- en: Next, we need to create an Overlord to check for the win condition. Create a
    new Object and name it `obj_Overlord`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个最高指挥官来检查胜利条件。创建一个新对象，命名为`obj_Overlord`。
- en: Create a new Script, `scr_Overlord_Create`, and attach it to a **Create** event,
    so that we can initialize some variables.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，`scr_Overlord_Create`，并将其附加到**创建**事件中，以便我们可以初始化一些变量。
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have two variables that we will be using. We will use `isTriggered` to check
    if the equipment has been activated or not. The `isVictory` variable will determine
    whether the win condition has occurred.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个变量。我们将使用`isTriggered`来检查设备是否已被激活。`isVictory`变量将确定胜利条件是否发生。
- en: We are going to take the activation away from the individual pieces of equipment
    and place it into the Overlord. Reopen `obj_TNT`, `obj_Anchor`, and `obj_CraneBase`,
    and remove the **Space** event under **Key Press**.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将取消对各个设备单独激活的操作，并将其放入最高指挥官中。重新打开`obj_TNT`，`obj_Anchor`和`obj_CraneBase`，并删除**按键按下**事件下的**空格**事件。
- en: Create a new Script, `scr_Overlord_Step`, and add it to a **Step** event in
    `obj_Overlord`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，`scr_Overlord_Step`，并将其添加到`obj_Overlord`的**Step**事件中。
- en: '[PRE34]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code will only execute if the variable `isTriggered` is `true`. If it is,
    we check to see if there are any instances of the TNT in existence. If there are
    instances, we use a `with` statement to run the activation script for each instance.
    We do the same for the Anchor and Crane Base. We also add an alarm set for eight
    seconds, which is when we will check for the win condition. Finally, we set `isTriggered`
    back to `false` so that this runs for the second time.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只有在变量`isTriggered`为`true`时才会执行。如果是，我们检查是否存在TNT的实例。如果有实例，我们使用`with`语句来运行每个实例的激活脚本。对于Anchor和Crane
    Base，我们也做同样的操作。我们还设置了一个8秒的警报，这时我们将检查胜利条件。最后，我们将`isTriggered`设置回`false`，这样它就会第二次运行。
- en: Let's activate the equipment. Create a new Script, `scr_Overlord_KeyPress`,
    and add it to a **Space** event under **Key Press**.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们激活设备。创建一个新脚本，`scr_Overlord_KeyPress`，并将其添加到**按键按下**事件的**空格**事件下。
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At some point we may want to have more than one Zone in a level that needs
    to be cleared. This poses a bit of a problem, in that we need to ensure that all
    Zones are clear while not knowing in what order we are going to check each Zone.
    What we need to do is have any Zone that has collision. Stop the checking process
    and set the win condition to `false`. Create a new Script, `scr_WinCondition`,
    with the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些时候，我们可能希望在需要清除的关卡中有多个区域。这会带来一个小问题，我们需要确保所有区域都清除，但又不知道我们将以什么顺序检查每个区域。我们需要做的是让任何有碰撞的区域停止检查过程，并将胜利条件设置为`false`。创建一个新脚本，`scr_WinCondition`，并添加以下代码：
- en: '[PRE36]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By using a `with` statement to check `obj_Zone_Parent`, we are able to look
    for all instances of that object and all of its children. We are going to use
    `return` statements here to help us exit the script. When a return is executed,
    the script will immediately stop and any code after it will not be run. If any
    instance has collision we return `false`; otherwise, if no instances have collision,
    we return `true`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`with`语句来检查`obj_Zone_Parent`，我们能够查找该对象及其所有子对象的所有实例。我们将在这里使用`return`语句来帮助我们退出脚本。当执行返回时，脚本将立即停止，之后的任何代码都不会运行。如果任何实例有碰撞，我们返回`false`；否则，如果没有实例有碰撞，我们返回`true`。
- en: We can now use `scr_WinCondition` in our alarm event. Create a new Script, `scr_Overlord_Alarm0`,
    and add it to an **Alarm 0** event.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在警报事件中使用`scr_WinCondition`。创建一个新脚本，`scr_Overlord_Alarm0`，并将其添加到**警报0**事件中。
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by capturing the returned `boolean` from `scr_WinCondition` in the
    `isVictory` variable. If it is `true`, we check to see if there is a room after
    the current room we are in. The order of rooms is determined by where they are
    placed in the Resource tree, with the next room being the one below it in the
    Resource tree. If there is a room, we go to it. If the win condition is `false`,
    we restart the room.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先捕获从`scr_WinCondition`返回的`boolean`，并将其存储在`isVictory`变量中。如果它是`true`，我们检查当前房间之后是否有另一个房间。房间的顺序由它们在资源树中的位置决定，下一个房间是资源树中它下面的房间。如果有另一个房间，我们就进入它。如果胜利条件是`false`，我们重新开始这个房间。
- en: Reopen `Sandbox` and place a single instance of `obj_Overlord` anywhere in the
    room.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`Sandbox`并在房间中的任何位置放置一个`obj_Overlord`的单个实例。
- en: We can't test the win condition with only one room, so let's duplicate the `Sandbox`
    and name it `Sandbox_02`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能只用一个房间来测试获胜条件，所以让我们复制“沙盒”并将其命名为“Sandbox_02”。
- en: Rearrange the Pillars and equipment in the room so that you can tell that it
    is not the same room as Sandbox. Also move the Zone closer to the ground so that
    it guarantees the win condition will not happen, as shown in the following screenshot:![Setting
    the win condition](img/4100OT_06_26.jpg)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新排列房间中的柱子和设备，以便您可以确定它不是与沙盒相同的房间。还将区域移到离地面更近的位置，以确保获胜条件不会发生，如下面的截图所示：![设置获胜条件](img/4100OT_06_26.jpg)
- en: Run the game and press space. In the first room we should see some destruction
    clear the Zone and after a few moments, the room will switch over to `Sandbox_02`.
    When the equipment is activated this time, there will be some destruction, but
    there will still be Pillars and Debris in the Zone. After a few moments, this
    room will restart. The win condition works!
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并按空格键。在第一个房间中，我们应该看到一些破坏清除区域，几秒钟后，房间将切换到“Sandbox_02”。这次激活设备时，会有一些破坏，但区域中仍然会有柱子和碎片。几秒钟后，这个房间将重新开始。获胜条件达成！
- en: Creating the Equipment Menu
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建装备菜单
- en: While we now have a win condition, there still isn't anything for the player
    to do. We are going to fix that by adding an **Equipment Menu**. This menu will
    be placed along the bottom of the gameplay screen and have selectable icons for
    the TNT, Wrecking Ball, and Magnetic Crane. When an icon is clicked it will create
    a placeable ghost version of the appropriate piece of equipment. To place the
    equipment, the player just needs to click somewhere in the world and the ghost
    will become the real item.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在有了获胜条件，但玩家还没有任何事情可做。我们将通过添加一个**装备菜单**来解决这个问题。该菜单将放置在游戏屏幕的底部，并具有TNT、挖掘机和磁吊机的可选择图标。当点击图标时，它将创建相应设备的可放置幽灵版本。要放置设备，玩家只需在世界的某个地方点击，幽灵就会变成真正的物品。
- en: 'To build the Equipment Menu we are going to need several sprites. Create new
    sprites and load the appropriate files from `Chapter 6/Sprites/` for the following
    sprites with **Remove Background** unchecked. Leave the origin at **X**: 0 and
    **Y**: `0`.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建装备菜单，我们需要几个精灵。创建新精灵，并从“第6章/精灵/”中加载适当的文件，对以下精灵进行**取消背景**的检查。将原点保留在**X：**0和**Y：**`0`。
- en: '`spr_Menu_BG`'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Menu_BG`'
- en: '`spr_Menu_TNT`'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Menu_TNT`'
- en: '`spr_Menu_WreckingBall`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Menu_WreckingBall`'
- en: '`spr_Menu_MagneticCrane`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spr_Menu_MagneticCrane`'
- en: Create a new Object and name it `obj_Menu`. We will not apply a Sprite to this
    object.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象并将其命名为“obj_Menu”。我们不会为这个对象应用精灵。
- en: We only need to initialize one variable to indicate when the menu is active.
    Create a new Script, `scr_Menu_Create`, and apply it to a **Create** event.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要初始化一个变量来指示菜单何时处于活动状态。创建一个新脚本“scr_Menu_Create”，并将其应用到一个**创建**事件。
- en: '[PRE38]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this game we are going to require rooms of varying sizes, so that we can
    have tall or wide towers. This means that the menu will need to adapt to fit properly.
    This could be very frustrating except for the fact that we are going to set screen
    size to 640 x 480 at all times. If we use GameMaker's **Draw GUI** event, it ignores
    the world positioning and uses the coordinates based on the window size. Create
    a new script, `scr_Menu_DrawGUI`, and apply it to a **Draw GUI** event.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们需要不同大小的房间，这样我们就可以有高或宽的塔。这意味着菜单需要适应合适的大小。除非我们始终将屏幕大小设置为640 x 480，否则这可能会非常令人沮丧。如果我们使用GameMaker的**绘制GUI**事件，它会忽略世界定位，并使用基于窗口大小的坐标。创建一个新脚本“scr_Menu_DrawGUI”，并将其应用到一个**绘制GUI**事件。
- en: '[PRE39]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we know that every room is going to be displayed at a resolution of 640 x
    480, we start by drawing the background sprite at the bottom of the screen. We
    are going to use a variable, `menuItem_Zone`, to help with the mouse coordinates
    over the sprites. We will need to know exactly where the icon is placed when we
    code in the future, so we make variables for each menu item's coordinates and
    then draw the Sprite on the screen.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道每个房间都将以640 x 480的分辨率显示，所以我们首先在屏幕底部绘制背景精灵。我们将使用一个变量“menuItem_Zone”来帮助确定鼠标在精灵上的坐标。在未来的编码中，我们需要确切地知道图标放置的位置，因此我们为每个菜单项的坐标创建变量，然后在屏幕上绘制精灵。
- en: Reopen `Sandbox` and change the **Settings** of the room to **Width:** `800`,
    **Height:** `600`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开“沙盒”并将房间的**设置**更改为**宽度：**`800`，**高度：**`600`。
- en: Under the **Views** tab, check the boxes for **Enable the use of Views** and
    **Visible When Room Starts**.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**视图**选项卡下，勾选**启用视图使用**和**房间启动时可见**的复选框。
- en: Change the **View In Room** to **W:** `800` **H:** `600`. Do not change the
    values for **Port on Screen**. By doing this, we will be able to see the entire
    room and it will be displayed at the standard 640 x 480 resolution.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**在房间中查看**更改为**W：**`800` **H：**`600`。不要更改**屏幕上的端口**的值。通过这样做，我们将能够看到整个房间，并且它将以标准的640
    x 480分辨率显示。
- en: Now place a single instance of `obj_Menu` anywhere in the room.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在房间中的任何位置放置一个“obj_Menu”的单个实例。
- en: Run the game. You should see the menu with the three icons at the bottom of
    the screen as shown in the following screenshot:![Creating the Equipment Menu](img/4100OT_06_27.jpg)
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。您应该看到屏幕底部有三个图标的菜单，如下面的截图所示：![创建装备菜单](img/4100OT_06_27.jpg)
- en: To make the menu functional we need to first create all the ghost objects. We
    do not need to bring in any new sprites, as we will use the existing sprites for
    each piece of equipment. Let's start by creating a new Object, `obj_Ghost_TNT`,
    and applying `spr_TNT` as the **Sprite**.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使菜单功能正常，我们首先需要创建所有的幽灵对象。我们不需要引入任何新的精灵，因为我们将使用每个设备部件的现有精灵。让我们首先创建一个新对象“obj_Ghost_TNT”，并将“spr_TNT”应用为**精灵**。
- en: 'Create a new Script, `scr_Ghost_TNT_Create`, and apply it to a **Create** event
    with the following code:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本“scr_Ghost_TNT_Create”，并将其应用到一个**Create**事件，其中包含以下代码：
- en: '[PRE40]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In order to differentiate the Ghost TNT from the real TNT, we start by setting
    the transparency to 50 percent. We are going to use some common scripts for all
    ghosts, so we will need a variable to indicate what this Ghost represents.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分幽灵TNT和真实TNT，我们首先将透明度设置为50％。我们将使用一些通用脚本来处理所有幽灵，因此我们需要一个变量来指示这个幽灵代表什么。
- en: Next, we need to be able to move this object with the mouse around the room
    for placement. To do this we are going to write a Script that can be used by all
    ghosts. Create a new Script, `scr_Ghost_Step` and apply it to a **Step** event.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要能够使用鼠标将此对象在房间中移动以进行放置。为此，我们将编写一个可以供所有幽灵使用的脚本。创建一个新脚本，`scr_Ghost_Step`，并将其应用于**Step**事件。
- en: '[PRE41]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create another new Script, `scr_Ghost_Released`, and add it to a **Left Released**
    event under **Mouse**.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个新脚本，`scr_Ghost_Released`，并将其添加到**鼠标**下的**左释放**事件。
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We don't want to be able to place the item down on top of the menu, or on top
    of other instances we are trying to destroy. To make this happen we first need
    to grab the height of the display area and the position of the mouse within the
    display. It is important to note that we cannot use the standard `mouseY` variable
    as it relates to the position within the world because we need to know its position
    on screen. We check to see if there is a lack of collision at the current location
    in the room with any Pillar, and that the mouse on screen is 64 pixels above the
    bottom, which ensures that it is above the menu. If this is all true, we create
    an instance of whatever item is to be placed, tell the Menu that it is no longer
    active and remove the Ghost from the world. We are now done with the Ghost TNT.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望能够将物品放在菜单顶部或其他我们试图摧毁的实例顶部。为了实现这一点，我们首先需要获取显示区域的高度和鼠标在显示区域内的位置。重要的是要注意，我们不能使用标准的`mouseY`变量，因为它与世界内的位置有关，而我们需要知道它在屏幕上的位置。我们检查当前位置在房间内是否与任何柱子发生碰撞，并且屏幕上的鼠标距离底部64像素，这确保它在菜单上方。如果这一切都是真的，我们创建一个要放置的物品实例，告诉菜单它不再活动，并从世界中移除幽灵。我们现在完成了幽灵TNT。
- en: Up next is the Ghost Wrecking Ball. Create a new Object, `obj_Ghost_WreckingBall`
    and assign `spr_Anchor` as its **Sprite**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是幽灵挖掘球。创建一个新对象，`obj_Ghost_WreckingBall`，并将`spr_Anchor`指定为其**精灵**。
- en: We have some common scripts, so let's apply them quickly. Add a **Step** event,
    apply `scr_Ghost_Step`, and add a **Left Released** event under **Mouse** with
    `scr_Ghost_Released` attached.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一些通用脚本，所以让我们快速应用它们。添加一个**Step**事件，应用`scr_Ghost_Step`，并在**鼠标**下添加一个**左释放**事件，附加`scr_Ghost_Released`。
- en: Create a new Script, `scr_Ghost_WreckingBall_Create`, and add it to a **Create**
    event. All we need here is to initialize what item it will create when placed.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，`scr_Ghost_WreckingBall_Create`，并将其添加到**Create**事件。我们在这里只需要初始化放置时将创建的物品。
- en: '[PRE43]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can''t build this exactly the same as the TNT, as the Wrecking Ball is comprised
    of several parts. For this Ghost we will need a **Draw** event and a new Script,
    `scr_Ghost_WreckingBall_Draw` with the following code:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们无法像TNT那样完全构建这个，因为挖掘球由几个部分组成。对于这个幽灵，我们将需要一个**Draw**事件和一个新脚本，`scr_Ghost_WreckingBall_Draw`，其中包含以下代码：
- en: '[PRE44]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We start by setting the instance to half transparent so that it looks like a
    Ghost. We then draw the Anchor, run a `for` loop to draw the Chain, and then the
    Wrecking Ball is drawn at the end of the Chain. Finally, we need to reset the
    transparency back to full at the end of this code. It is critical that we do this,
    as Draw events affect everything that is drawn on screen. If we did not reset
    it, every object in the world would have half transparency.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将实例设置为半透明，使其看起来像幽灵。然后绘制锚，运行一个`for`循环来绘制链条，然后挖掘球在链条末端绘制。最后，我们需要在代码末尾将透明度重置为完整。这一点非常重要，因为绘制事件会影响屏幕上绘制的所有内容。如果我们不重置它，世界中的每个对象都会有半透明度。
- en: Now for the Ghost Magnetic Crane. Create a new Object, `obj_Ghost_MagneticCrane`,
    and apply `spr_CraneBase` as the **Sprite**.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是幽灵磁吊机的时候了。创建一个新对象，`obj_Ghost_MagneticCrane`，并将`spr_CraneBase`应用为**精灵**。
- en: The same as for the other Ghosts, add a **Step** event and a **Left Released**
    event under **Mouse** and apply the appropriate scripts.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他幽灵一样，添加一个**Step**事件和一个**左释放**事件在**鼠标**下，并应用适当的脚本。
- en: Create a new Script, `scr_Ghost_MagneticCrane_Create`, and initialize the necessary
    variable.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，`scr_Ghost_MagneticCrane_Create`，并初始化必要的变量。
- en: '[PRE45]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now draw the pieces. Create another Script, `scr_Ghost_MagneticCrane_Draw`,
    and add it as a **Draw** event.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在绘制部件。创建另一个脚本，`scr_Ghost_MagneticCrane_Draw`，并将其添加为**Draw**事件。
- en: '[PRE46]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In a similar manner as the Ghost Wrecking Ball, we start by setting the transparency
    to 50 percent. We then draw the crane base, draw a thick gray line and the magnet
    at the same position they would be when placed. We then set the transparency back
    to full.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 与幽灵挖掘球类似，我们首先将透明度设置为50％。然后绘制起重机底座，绘制一条粗灰色线和磁铁，位置与放置时相同。然后将透明度恢复到完整。
- en: 'The Ghosts are now all complete; we just need to spawn them. Reopen `scr_Menu_DrawGUI`
    and add the following code at the end:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幽灵现在全部完成了；我们只需要生成它们。重新打开`scr_Menu_DrawGUI`，并在末尾添加以下代码：
- en: '[PRE47]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We start by checking if the menu is active or not. If a menu item is selected
    and hasn't been placed, the menu will be considered active. If we are able to
    select a menu item, we grab the mouse location on screen. We check the mouse location
    on screen, first with the Y coordinate and the Zone offsets to see if the mouse
    is on top of the Menu, then with the X coordinate and the Zone of each item. If
    the mouse is over the top of one of the icons, we redraw the sprite on the second
    frame of animation to indicate the hover state. We then check to see if the left
    mouse button has been pressed, and if it has, we spawn the appropriate Ghost item
    and the menu is now active. Now we can spawn TNT, Wrecking Balls, and Magnetic
    Cranes.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查菜单是否处于活动状态。如果选择了菜单项并且尚未放置，菜单将被视为活动状态。如果我们能够选择菜单项，我们就会在屏幕上抓取鼠标位置。我们首先检查屏幕上的鼠标位置，首先是Y坐标和区域偏移量，看看鼠标是否在菜单上方，然后是X坐标和每个项目的区域。如果鼠标在图标的顶部，我们会在第二帧动画上重绘精灵以指示悬停状态。然后我们检查左鼠标按钮是否被按下，如果是，我们就会生成相应的幽灵物品，菜单现在是活动的。现在我们可以生成TNT、毁坏球和磁吊机。
- en: Run the game. We already have the menu on screen, but now when you hover over
    the icons, they should be highlighted. When you click on an icon, it creates the
    appropriate Ghost item, which will move with the mouse. When you click in the
    playable area, an instance of the item will be created and can be used.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。我们已经在屏幕上有了菜单，但现在当你悬停在图标上时，它们应该会被突出显示。当你点击一个图标时，它会创建相应的幽灵物品，它会随鼠标移动。当你在可玩区域点击时，会创建一个物品的实例，并且可以使用。
- en: Constructing the towers
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建塔楼
- en: We now have a working game and all that is left is to create some levels to
    play. We will build a few levels with a variety of different towers and room sizes
    to make sure all our code is working properly.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可用的游戏，剩下的就是创建一些可以玩的关卡。我们将建立一些具有不同塔和房间大小的关卡，以确保我们的所有代码都能正常工作。
- en: Create a new Room and in the **settings** tab, name it `Level_01.Make` sure
    this is moved to the top of the Rooms section of the Resource tree.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的房间，在**设置**选项卡中，命名为`Level_01`。确保这个房间移动到资源树中房间部分的顶部。
- en: Open the **physics** tab, check the box for **Room is Physics World** and set
    the **Gravity** to **X:** `0` **Y:** `20`.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**物理**选项卡，勾选**房间是物理世界**的框，并将**重力**设置为**X：**`0` **Y：**`20`。
- en: In the **objects** tab, select `obj_Ground` and place instances 64 pixels from
    the bottom and across the width of the room. The menu will take up the bottom
    64 pixels, so we don't need to put any Ground down there.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象**选项卡中，选择`obj_Ground`并将实例放置在距离底部64像素的位置，横跨整个房间的宽度。菜单将占据底部64像素，所以我们不需要在那里放任何地面。
- en: Add single instances of `obj_Overlord` and `obj_Menu` in the area below the
    Ground instances. While technically they can go anywhere in the room, this will
    just keep things a bit more organized.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地面下方的区域中添加`obj_Overlord`和`obj_Menu`的单个实例。尽管从技术上讲它们可以放在房间的任何地方，但这样做会使事情更有条理。
- en: As this is the first level, let's make it easy for the player and only use Glass
    Pillars. Up to this point in the book, we have only been placing objects as they
    were created. When placing the Pillars, we can easily rotate them and place them
    in the world. To rotate an instance in the **Room Properties** editor, first place
    the instance in the room normally, and while it is still selected, change the
    **Rotation** value in the **objects** tab. There are options for scaling an instance,
    but we cannot use these in a physics simulation, as it does not affect the Fixture
    size.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是第一关，让我们为玩家设置简单一点，只使用玻璃柱。在本书的这一部分，我们一直在按照创建的顺序放置对象。在放置柱子时，我们可以轻松地旋转它们并将它们放置在世界中。要在**房间属性**编辑器中旋转一个实例，首先将实例正常放置在房间中，然后在仍然选中的情况下，在**对象**选项卡中更改**旋转**值。有缩放实例的选项，但我们不能在物理模拟中使用这些选项，因为它不会影响夹具大小。
- en: Using only `obj_Pillar_Glass` and `obj_Pillar_Glass_Small`, construct a simple
    two story tower as seen in the following screenshot:![Constructing the towers](img/4100OT_06_28.jpg)
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只使用`obj_Pillar_Glass`和`obj_Pillar_Glass_Small`，构建一个简单的两层塔，如下截图所示：![构建塔楼](img/4100OT_06_28.jpg)
- en: Finally, place a single instance of `obj_Zone_01` behind the tower and roughly
    in the center vertically. This room is now complete.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在塔后面大致垂直中心放置一个`obj_Zone_01`的实例。这个房间现在完成了。
- en: Let's build the final room meant for much later in the game, but this time much
    larger and with multiple zones. Create a new Room and in the **settings** name
    it `Level_12`, and change the **Width** to `1280` and **Height** to `960`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们建造游戏中更晚的最终房间，但这次要大得多，并且有多个区域。创建一个新的房间，在**设置**中命名为`Level_12`，将**宽度**更改为`1280`，**高度**更改为`960`。
- en: In the Resource tree, move this room so that it is immediately after `Level_01`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源树中，将这个房间移动到`Level_01`之后。
- en: This room is now twice as big as `Level_01`, but we want to display it on screen
    at the same size. In the **views** tab, check the boxes for **Enable the use of
    Views** and **Visible When Room Starts**.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个房间现在是`Level_01`的两倍大，但我们希望以相同的大小在屏幕上显示它。在**视图**选项卡中，勾选**启用视图**和**房间开始时可见**的框。
- en: Change the **View In Room** to **W:** `1280` **H:** `960`. Do not change the
    values for **Port on Screen**. Again, by doing this we will be able to see the
    entire room at the standard 640 x 480 resolution.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**在房间中查看**更改为**W：**`1280` **H：**`960`。不要更改**屏幕上的端口**的值。通过这样做，我们将能够以标准的640 x
    480分辨率看到整个房间。
- en: In the **physics** tab, check the box for **Room is Physics World** and set
    the **Gravity** to **X:** `0` **Y:** `20`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**物理**选项卡中，勾选**房间是物理世界**的框，并将**重力**设置为**X：**`0` **Y：**`20`。
- en: We will start by laying the ground down with `obj_Ground`. As the room is twice
    as large, our numbers need to double as well. The menu will display with a height
    of 64 pixels of screen resolution in this room, which means the Ground should
    be 128 pixels from the bottom.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从使用`obj_Ground`铺设地面开始。由于房间的大小加倍，我们的数字也需要加倍。在这个房间中，菜单将以64像素的屏幕分辨率高度显示，这意味着地面应该距离底部128像素。
- en: Place single instances of `obj_Overlord` and `obj_Menu` in the area below the
    Ground instances.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地面实例下方放置单个`obj_Overlord`和`obj_Menu`。
- en: As this level is meant to be a later level in the game, we can use all small
    and regular size pillars of all types. Build a couple of towers with varying heights
    and building materials.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个关卡意味着是游戏中的后期关卡，我们可以使用所有类型的小型和常规尺寸的柱子。建造几座高度和建筑材料不同的塔。
- en: Add an instance of `obj_Zone_01` behind each of the towers. An example of what
    the level could look like can be seen in the following screenshot:![Constructing
    the towers](img/4100OT_06_29.jpg)
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个塔后面添加一个`obj_Zone_01`的实例。关卡可能看起来像下面的截图所示：![建造塔](img/4100OT_06_29.jpg)
- en: Run the game. The first level should only need a few, well placed pieces of
    TNT to successfully destroy it. The next level should be much more difficult to
    complete, and requires all three types of equipment. The challenge now is to see
    how few pieces of equipment are needed to destroy everything. Have fun smashing
    things up as shown in the following screenshot:![Constructing the towers](img/4100OT_06_30.jpg)
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。第一关只需要几个放置得当的TNT就能成功摧毁它。下一关应该更难完成，并需要所有三种类型的装备。现在的挑战是看看需要多少装备才能摧毁一切。尽情地摧毁东西，就像下面的截图所示：![建造塔](img/4100OT_06_30.jpg)
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of material in this chapter. We started with the basics of
    using the Box2D physics system. We learned how to assign Fixtures to objects and
    what the different properties were that we could change. We created a Chain and
    Wrecking Ball that utilized Revolute Joints so each piece would rotate with the
    one preceding it. We built TNT and a Magnetic Crane that used Forces to move objects
    around the world. We also made Debris spawn from the large Pillars when they collided
    with heavier, stronger objects. Additionally, we learned about the Draw GUI event
    and the difference between a Sprite's location as represented in a room versus
    the location on screen. This allowed us to create a Menu that will display properly
    on screen no matter the size of the room.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章涵盖了很多内容。我们从使用Box2D物理系统的基础知识开始。我们学会了如何为对象分配Fixture以及可以更改的不同属性。我们创建了一个利用旋转关节的链条和破坏球，使每个部分都会随着前面的部分旋转。我们建造了使用力来移动世界中的物体的TNT和磁吊机。当它们与更重、更坚固的物体碰撞时，我们还制造了从大柱子上产生碎片的效果。此外，我们了解了Draw
    GUI事件以及精灵在房间中的位置与屏幕上的位置之间的区别。这使我们能够创建一个菜单，无论房间的大小如何，都能在屏幕上正确显示。
- en: We are going to continue to work on this game in the next chapter. We will create
    a store and inventory system so that the player has a limited amount of equipment
    and can purchase additional items. We will also dive into displaying dialog, so
    that we can add some basic story elements to the game to motivate the player to
    destroy more stuff!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章继续开发这个游戏。我们将创建一个商店和库存系统，以便玩家拥有有限数量的装备，并可以购买额外的物品。我们还将深入探讨显示对话，以便我们可以向游戏添加一些基本的故事元素，激励玩家摧毁更多的东西！
