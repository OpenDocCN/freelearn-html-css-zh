- en: Chapter 7. Dynamic Front Ends
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。动态前端
- en: In the last chapter we built a tower toppling physics game where the player
    could use TNT, Wrecking Balls, and Magnetic Cranes to destroy towers made of Glass,
    Wood, and Steel Pillars. In this chapter we are going to build this game by implementing
    a Shop, a Score Screen, and Level Intro Dialog. We are also going to rework the
    HUD so that only the equipment that is available can be used to implement a countdown
    timer, and add buttons for restarting the level and going to the Shop. In order
    to accomplish all of this, we will spend some time looking at arrays and data
    structures for storing information and using global variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个塔倒塌的物理游戏，玩家可以使用TNT、挖掘球和磁吊机来摧毁由玻璃、木材和钢柱构建的塔。在本章中，我们将通过实现商店、得分屏幕和级别介绍对这个游戏进行构建。我们还将重新设计HUD，以便只有可用的设备可以用于实现倒计时器，并添加重新开始级别和前往商店的按钮。为了完成所有这些，我们将花一些时间研究用于存储信息和使用全局变量的数组和数据结构。
- en: Setting up the rooms
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置房间
- en: 'In the last chapter we built two rooms, `Level_01` and `Level_12`, for testing
    the HUD and game difficulty. We now need to make rooms for all the levels in between
    those two, plus a few additional rooms for the Front End, Shop and Level Select:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为测试HUD和游戏难度构建了两个房间，`Level_01`和`Level_12`。现在我们需要为这两个之间的所有级别制作房间，以及为前端、商店和级别选择制作一些额外的房间：
- en: 'Create a new Room for each level from `Level_02` to `Level_11`. Set the size
    of the rooms as follows:'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为从`Level_02`到`Level_11`的每个级别创建一个新房间。将房间的大小设置如下：
- en: '`Level_02` – `Level_04` is set to **Width**: `640` and **Height**: `480`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Level_02` – `Level_04`的设置为**宽度**：`640`和**高度**：`480`'
- en: '`Level_05` – `Level_08` is set to **Width**: `960` and **Height**: `720`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Level_05` – `Level_08`的设置为**宽度**：`960`和**高度**：`720`'
- en: '`Level_09` – `Level_11` is set to **Width**: `1280` and **Height**: `960`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Level_09` – `Level_11`的设置为**宽度**：`1280`和**高度**：`960`'
- en: Each room needs to have **Room is Physics World** checked in the **Physics**
    tab.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个房间都需要在**物理**选项卡中勾选**房间是物理世界**。
- en: 'Make sure that **Views** | **Port on Screen** is set to **X**: `0`, **Y**:
    `0`, **W**: `640`, and **H**: `480` so that each room will display properly on
    screen.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**视图** | **屏幕上的端口**设置为**X**：`0`，**Y**：`0`，**W**：`640`，和**H**：`480`，以便每个房间在屏幕上正确显示。
- en: We have supplied backgrounds for each level which can be found in `Chapter 7/Backgrounds/`.
    Make sure that **Remove Background** is not checked.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为每个级别提供了背景，可以在`第7章/背景/`中找到。确保没有勾选**删除背景**。
- en: 'Each level should have a unique tower built from a variety of Pillars and ideally
    be made more difficult than the previous level. Start by placing the ground down
    in the room which requires a different Y coordinate depending on the size of the
    Room. The Y placement is indicated as follows:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个级别应该有一个独特的塔，由各种柱子构建，理想情况下比上一个级别更难。首先在需要不同Y坐标的房间中放置地面，具体取决于房间的大小。Y的放置如下所示：
- en: '`Level_02` – `Level_04`: **384**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Level_02` – `Level_04`: **384**'
- en: '`Level_05` – `Level_08`: **576**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Level_05` – `Level_08`: **576**'
- en: '`Level_09` – `Level_11`: **784**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Level_09` – `Level_11`: **784**'
- en: Populate the levels with one instance of `obj_Overlord` and `obj_Menu` each.
    Each room should look something like the following screenshot:![Setting up the
    rooms](img/4100_07_11.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个房间中放置一个`obj_Overlord`和一个`obj_Menu`的实例。每个房间应该看起来像下面的截图：![设置房间](img/4100_07_11.jpg)
- en: Once the levels have been built, we can move on to the Front End. Create a new
    Room and in the **Settings**, name it `MainMenu`, with a **Width** of `640` and
    **Height** of `480`. Move this to the top of the `Rooms` folder in the Resource
    Tree.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立了级别之后，我们可以继续进行前端的工作。创建一个新房间，在**设置**中，命名为`MainMenu`，宽度为`640`，高度为`480`。将其移动到资源树中`Rooms`文件夹的顶部。
- en: Create a new Background, `bg_MainMenu`, and load `Chapter 7/Backgrounds/BG_MainMenu.png`.
    Make sure that **Remove Background** is not checked.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的背景，`bg_MainMenu`，并加载`第7章/背景/BG_MainMenu.png`。确保没有勾选**删除背景**。
- en: In the **Room Properties** | **Background** tab, set **Background 0** to `bg_MainMenu`.
    The box for **Visible when room starts** should be checked. We are done with this
    room for now so click on **OK**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**房间属性** | **背景**选项卡中，将**背景0**设置为`bg_MainMenu`。应该勾选**房间开始时可见**的框。现在我们暂时完成了这个房间，点击**确定**。
- en: 'We need two additional rooms for the Front End: `LevelSelect` and `Shop` with
    the appropriate backgrounds applied. The position in the Resource Tree does not
    matter. We now have all the rooms we will need for the game.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为前端再添加两个房间：`LevelSelect`和`Shop`，并应用适当的背景。资源树中的位置并不重要。现在我们已经拥有了游戏所需的所有房间。
- en: Initializing the main menu
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化主菜单
- en: 'The main menu is the very first screen the player will see and it consists
    of two objects: a button to start the game and a game initializing object with
    all the global variables:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单是玩家将看到的第一个屏幕，它由两个对象组成：一个开始游戏的按钮和一个包含所有全局变量的游戏初始化对象：
- en: Let's start with an object for initializing the game. Create a new Object and
    name it `obj_Global`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个用于初始化游戏的对象开始。创建一个新对象，命名为`obj_Global`。
- en: 'Create a new Script called `scr_Global_GameStart`. We will be adding code to
    this as we go along, but for now we just need to initialize the score:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`scr_Global_GameStart`的新脚本。随着我们的进行，我们将向其中添加代码，但现在我们只需要初始化分数：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add an **Other** | **Game Start** event and apply `scr_Global_GameStart`. Click
    on **OK**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**其他** | **游戏开始**事件，并应用`scr_Global_GameStart`。点击**确定**。
- en: Reopen `MainMenu` and place a single instance of `obj_Global` somewhere in the
    room.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`MainMenu`，在房间中放置一个`obj_Global`的实例。
- en: We are going to be creating a few buttons, so let's build a parent object to
    run the common functionality of hover states. Create a new Object called `obj_Button_Parent`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一些按钮，因此让我们建立一个父对象来运行悬停状态的公共功能。创建一个名为`obj_Button_Parent`的新对象。
- en: 'All buttons will have multiple frames of animation to be used for the hover
    states, so we need to stop them from playing. Create a new Script, `scr_Button_Parent_Create`,
    and attach this to a **Create** event with the following code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有按钮都将有多个动画帧用于悬停状态，因此我们需要停止它们的播放。创建一个新的脚本，`scr_Button_Parent_Create`，并将其附加到**创建**事件，并使用以下代码：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new Script, `scr_Button_Parent_MouseEnter`, and attach it to a **Mouse**
    | **Mouse Enter** event with the code to change it to the second frame of animation:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Button_Parent_MouseEnter`，并将其附加到**鼠标** | **鼠标进入**事件，代码用于将其更改为动画的第二帧：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also need to reset this by creating another new Script, `scr_Button_Parent_MouseLeave`
    and attach it to a **Mouse** | **Mouse Leave** event:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要通过创建另一个新的脚本`scr_Button_Parent_MouseLeave`并将其附加到**鼠标** | **鼠标离开**事件来重置它。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The parent object is now complete and the setting should look like the following
    screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 父对象现在已经完成，设置应该如下截图所示：
- en: '![Initializing the main menu](img/4100_07_10.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![初始化主菜单](img/4100_07_10.jpg)'
- en: Next we can build the first real button. Create a new Sprite, `spr_Button_Start`,
    with **Remove Background** turned off, and load `Chapter 7/Sprites/Button_Start.gif`.
    **Center** the **Origin** and click on **OK**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以构建第一个真正的按钮。创建一个新的精灵，`spr_Button_Start`，关闭**删除背景**，加载`Chapter 7/Sprites/Button_Start.gif`。**居中**
    **原点**，然后点击**确定**。
- en: Create a new Object, `obj_Button_Start`, and apply `spr_Button_Start` as the
    **Sprite**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，`obj_Button_Start`，并将`spr_Button_Start`应用为**精灵**。
- en: Set the **Parent** to be `obj_Button_Parent` so that the hover states will function
    properly.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**父对象**设置为`obj_Button_Parent`，以便悬停状态能够正常工作。
- en: 'Since each button will do something different we need to give each button its
    own click event. Create a new Script, `scr_Button_Start_MousePressed`, and attach
    it to a **Mouse** | **Left Pressed** event with the following code to go to the
    room `LevelSelect`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于每个按钮都会执行不同的操作，我们需要为每个按钮分配自己的点击事件。创建一个新的脚本，`scr_Button_Start_MousePressed`，并将其附加到**鼠标**
    | **左键按下**事件，使用以下代码前往房间`LevelSelect`：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This button is now complete. Place a single instance of `obj_Button_Start`
    into `MainMenu` near the bottom of the screen at **X**: `320` and **Y**: `416`.
    The Room should look like the following screenshot:![Initializing the main menu](img/4100_07_01.jpg)'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个按钮现在已经完成。将`obj_Button_Start`的单个实例放入`MainMenu`靠近屏幕底部的位置，**X**：`320`和**Y**：`416`。房间应该看起来像下面的截图：![初始化主菜单](img/4100_07_01.jpg)
- en: Run the game to make sure that it starts with `MainMenu` and that the **Start**
    Button functions as designed.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏，确保它从`MainMenu`开始，并且**Start**按钮按预期工作。
- en: Selecting levels with 2D arrays
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用2D数组选择级别
- en: The next room we are going to build is `LevelSelect`. In this room there will
    be a button for going to the Shop and buttons for each level in the game, with
    only the first level unlocked at the start. As the player progresses, the buttons
    will unlock and the player will have access to all previous levels. To achieve
    this we will dynamically create buttons for each level in the game and use a 2D
    array to store all this information.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的下一个房间是`LevelSelect`。在这个房间中，将有一个用于前往商店的按钮，以及游戏中每个级别的按钮，但一开始只有第一个级别是解锁的。随着玩家的进展，按钮将会解锁，玩家将可以访问所有以前的级别。为了实现这一点，我们将动态创建游戏中每个级别的按钮，并使用2D数组来存储所有这些信息。
- en: 'A 2D array is just like the arrays we have already used in the book. It is
    a single static list of data but it allows for multiple values per row, like a
    spreadsheet. This is a very powerful tool at our disposal as it makes it much
    simpler to group several different elements together:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 2D数组就像我们在书中已经使用过的数组一样。它是一个静态的数据列表，但它允许每行有多个值，就像电子表格一样。这是我们可以使用的一个非常强大的工具，因为它使得将几个不同的元素组合在一起变得更加简单：
- en: 'Create a new Script, `scr_Global_Levels`, and start by initializing some global
    variables:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，`scr_Global_Levels`，并开始初始化一些全局变量：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we are always trying to simplify our code we can use an alternate method
    of declaring global variables with `globalvar`. This declaration method functions
    exactly the same way as `global`, but it will allow us to write `level` instead
    of `global.level`. While this will save us plenty of keystrokes, it is up to us
    to remember that it is a global variable as it is not as obvious.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直在试图简化我们的代码，我们可以使用`globalvar`来声明全局变量的替代方法。这种声明方法与`global`完全相同，但它允许我们编写`level`而不是`global.level`。虽然这将为我们节省大量按键，但我们必须记住它是一个全局变量，因为它并不那么明显。
- en: 'Next we need to create a 2D array with one column holding the level and another
    with whether it is locked or not. Let''s just add the first level:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个2D数组，其中一列保存级别，另一列保存它是否被锁定。让我们先添加第一个级别：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To create a 2D array, you just need to place two numbers inside the brackets.
    The first number is for the row and the second for the column. Here we have only
    a single row that has two columns. The first column will hold the room name and
    the second column will be for whether that room is locked or not; in this case
    `Level_01` is unlocked.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个2D数组，只需要在括号内放入两个数字。第一个数字是行数，第二个是列数。这里我们只有一行，有两列。第一列将保存房间名称，第二列将保存该房间是否被锁定；在这种情况下，`Level_01`是解锁的。
- en: 'There is one drawback in using simple arrays in GameMaker: Studio that there
    is no function to find out the size of the array. We need to know the size of
    this array so that we can dynamically create all the buttons. We already created
    a global variable to hold the total amount of levels; we just need to manually
    set its value. Let''s add all the levels into the array, lock them, and set the
    `totalLevels` variable. Here is the complete script for all 12 levels:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在GameMaker: Studio中使用简单数组的一个缺点是没有函数可以找出数组的大小。我们需要知道这个数组的大小，以便我们可以动态创建所有的按钮。我们已经创建了一个全局变量来保存级别的总数；我们只需要手动设置它的值。让我们将所有级别添加到数组中，锁定它们，并设置`totalLevels`变量。以下是所有12个级别的完整脚本：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need to initialize this array at the start of the game. Reopen `scr_Global_GameStart`
    and execute this script after the score variable.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在游戏开始时初始化这个数组。重新打开`scr_Global_GameStart`，并在分数变量之后执行此脚本。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's move onto building the button for going to the Shop. Create a new Sprite,
    `spr_Button_Shop`, and with **Remove Background** turned off, load `Chapter 7/Sprites/Button_Shop.gif`.
    **Center** the **Origin** and click on **OK**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续构建前往商店的按钮。创建一个新的精灵`spr_Button_Shop`，并关闭**Remove Background**，加载`Chapter
    7/Sprites/Button_Shop.gif`。**Center** **Origin**并单击**OK**。
- en: Create a new Object, `obj_Button_Shop`, and apply `spr_Button_Shop` as the **Sprite**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象`obj_Button_Shop`，并将`spr_Button_Shop`应用为**Sprite**。
- en: This is a standard button so set the **Parent** to `obj_Button_Parent`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个标准按钮，所以将**Parent**设置为`obj_Button_Parent`。
- en: 'The last thing we need to do to this object is to add a **Mouse** | **Left
    Pressed** event and apply a new Script, `scr_Button_Shop_MousePressed` with the
    code to switch rooms:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个对象，我们需要做的最后一件事是添加一个**Mouse** | **Left Pressed**事件，并应用一个新的脚本`scr_Button_Shop_MousePressed`，其中包含切换房间的代码。
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will draw some text onto these buttons which means that we need to bring
    in some fonts. We have supplied a font called Boston Traffic in this game, which
    is needed to be installed on your computer. To install this font on a Windows
    computer, right-click on `Chapter 7/Fonts/boston.ttf` and select **Install**.
    Then follow the directions when prompted.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这些按钮上绘制一些文本，这意味着我们需要引入一些字体。我们在这个游戏中提供了一个名为Boston Traffic的字体，需要安装在您的计算机上。要在Windows计算机上安装此字体，请右键单击`Chapter
    7/Fonts/boston.ttf`，然后选择**安装**。然后按照提示进行操作。
- en: 'Back in GameMaker: Studio we need to create three new fonts: `fnt_Large`, `fnt_Medium`,
    and `fnt_Small`. All three will have a **Font** of `Boston Traffic`. Set the **Size**
    of `fnt_Large` to `20`, `fnt_Medium` to `16`, and `fnt_Small` to `10`.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在GameMaker: Studio中，我们需要创建三种新字体：`fnt_Large`，`fnt_Medium`和`fnt_Small`。所有三种字体都将使用`Boston
    Traffic`字体。将`fnt_Large`的大小设置为`20`，`fnt_Medium`设置为`16`，`fnt_Small`设置为`10`。'
- en: Next we can move onto the buttons for selecting the levels. We will be dynamically
    creating these buttons and drawing a number on each one of them so that we only
    need a single art asset. Create a new Sprite, `spr_Button_LevelSelect`, and with
    **Remove Background** turned off, load `Chapter 7/Sprites/Button_LevelSelect.gif`.
    **Center** the **Origin** and click on **OK**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以继续创建用于选择关卡的按钮。我们将动态创建这些按钮，并在每个按钮上绘制一个数字，这样我们只需要一个单一的艺术资源。创建一个新的精灵`spr_Button_LevelSelect`，并关闭**Remove
    Background**，加载`Chapter 7/Sprites/Button_LevelSelect.gif`。**Center** **Origin**并单击**OK**。
- en: Create a new Object, `obj_Button_LevelSelect`, and apply `spr_Button_LevelSelect`
    as the **Sprite**. These buttons cannot be parented to `obj_Button_Parent` as
    they require the ability to have a locked state, which will affect the hover states.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象`obj_Button_LevelSelect`，并将`spr_Button_LevelSelect`应用为**Sprite**。这些按钮不能作为`obj_Button_Parent`的子对象，因为它们需要具有锁定状态的能力，这将影响悬停状态。
- en: Since this button type is unique, we need to initialize some variables. Create
    a new Script, `scr_Button_LevelSelect_Create`, and attach it to a **Create** event.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这种按钮类型是独特的，我们需要初始化一些变量。创建一个新脚本`scr_Button_LevelSelect_Create`，并将其附加到**Create**事件中。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start by making all buttons locked by default. We set a default room for
    the room it should go to when clicked, and a number that we will draw on top.
    Finally we stop the sprite from animating and set an alarm for one step.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将所有按钮默认设置为锁定状态。我们为点击时应该转到的默认房间设置一个默认房间，并在顶部绘制一个数字。最后，我们停止精灵动画，并设置一个步骤的警报。
- en: 'We are using an alarm so that we can ensure that the levels will properly display
    whether they are locked or not. Create a new Script, `scr_Button_LevelSelect_Alarm0`,
    and attach it to an **Alarm** | **Alarm 0** event:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用一个警报，以确保关卡是否被锁定都能正确显示。创建一个新脚本`scr_Button_LevelSelect_Alarm0`，并将其附加到**Alarm**
    | **Alarm 0**事件中。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the button is to be locked, we set the sprite to display the locked frame.
    Otherwise it is unlocked and we show the first frame.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮被锁定，我们将设置精灵显示锁定帧。否则，它是解锁的，我们显示第一帧。
- en: 'Create a new Script, `scr_Button_LevelSelect_MouseEnter`, and apply it to a
    **Mouse** | **Mouse Enter** event:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本`scr_Button_LevelSelect_MouseEnter`，并将其应用到**Mouse** | **Mouse Enter**事件中。
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For the hover state of the button we first check to see if it is locked. If
    it is, we just exit the script immediately. If it is unlocked, we switch to the
    hover frame.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按钮的悬停状态，我们首先检查它是否被锁定。如果是，我们立即退出脚本。如果未锁定，我们切换到悬停帧。
- en: 'This same logic needs to be applied to when the mouse leaves the button. Create
    another new Script, `scr_Button_LevelSelect_MouseLeave`, and apply it to a **Mouse**
    | **Mouse Leave** event:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样的逻辑需要应用到鼠标离开按钮时。创建另一个新脚本`scr_Button_LevelSelect_MouseLeave`，并将其应用到**Mouse**
    | **Mouse Leave**事件中。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next we will add a **Mouse** | **Left Pressed** event with a new Script, `scr_Button_LevelSelect_MousePressed`,
    attached with code to change rooms if it is unlocked only:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个**Mouse** | **Left Pressed**事件，并附加一个新的脚本`scr_Button_LevelSelect_MousePressed`，其中包含仅在解锁时更改房间的代码。
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we just need a new Script, `scr_Button_LevelSelect_Draw` that we can
    use to draw the button with the appropriate number on top. Add this to a **Draw**
    | **Draw** event:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要一个新的脚本`scr_Button_LevelSelect_Draw`，我们可以用它来在按钮上绘制适当的数字。将其添加到**Draw**
    | **Draw**事件中。
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First we need to draw the sprite that has been applied to the object itself.
    Next we set the drawing color to black, set the font, and center align the text.
    We then draw the text held in the `myNum` variable, dropping it down a bit on
    the Y axis so that it centers vertically. Since we will be drawing a lot of text
    in this game, we should force the font to the default font by setting it to `-1`
    value. This will help prevent this font from affecting any other drawn font in
    the game:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要绘制应用于对象本身的精灵。接下来，我们将绘图颜色设置为黑色，设置字体，并居中对齐文本。然后，我们绘制`myNum`变量中保存的文本，将其在Y轴上下降一点，使其在垂直方向上居中。由于我们将在这个游戏中绘制大量文本，我们应该通过将字体设置为`-1`值来强制使用默认字体。这将有助于防止此字体影响游戏中的任何其他绘制字体：
- en: We are now finished with the level selection button and the properties should
    look like the following screenshot:![Selecting levels with 2D arrays](img/4100_07_02.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了级别选择按钮，属性应该看起来像以下截图：![使用2D数组选择级别](img/4100_07_02.jpg)
- en: We now have all the components we need for a level selection screen, we just
    need to spawn everything. For this we will create a new Object, `obj_LevelSelect_Overlord`,
    to build the menu upon entering the room.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在拥有了级别选择屏幕所需的所有组件，我们只需要生成所有内容。为此，我们将创建一个新对象，`obj_LevelSelect_Overlord`，以在进入房间时构建菜单。
- en: 'Add an **Other** | **Room Start** event and attach a new Script, `scr_LevelSelect_Overlord_RoomStart`,
    with the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**其他** | **房间开始**事件，并附加一个新的脚本，`scr_LevelSelect_Overlord_RoomStart`，其中包含以下代码：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by establishing variables for the row and columns that we will need
    for the layout of the buttons. We then run a loop starting at zero and run it
    for the total amount of levels we declared in the global variable `totalLevels`.
    Inside this loop, we first create an instance of `obj_Button_LevelSelect` and
    offset it in both horizontal and vertical directions with an additional 128 pixels
    of padding for a margin between the edge of the screen and the buttons. We then
    change the button's `myLevel` and `isLocked` variables by setting it according
    to the values in the `level` global array. Next we change the `myNum` variable
    to indicate what number will be drawn on the button. The last few lines of code
    are how we will limit the amount of columns and add additional rows of buttons.
    Every loop we increase the column count and once it passes five we reset it to
    zero. This will give us a row of six buttons. If we have more than six buttons,
    a new row will be created that can have another six buttons. This means we can
    add levels to the array later and they will be added into this menu automatically
    creating new rows for every six levels. Last but not least, we spawn an instance
    of the **SHOP** button at the bottom of the screen.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为按钮布局所需的行和列建立变量。然后我们从零开始运行一个循环，运行总级数我们在全局变量`totalLevels`中声明的次数。在这个循环中，我们首先创建一个`obj_Button_LevelSelect`的实例，并在水平和垂直方向上偏移它，额外增加128像素的填充，以便在屏幕边缘和按钮之间留出边距。然后我们通过设置`level`全局数组中的值来改变按钮的`myLevel`和`isLocked`变量。接下来，我们改变`myNum`变量以指示按钮上将绘制的数字。代码的最后几行是我们如何限制列数并添加额外的按钮行。每次循环我们增加列数，一旦超过五，就将其重置为零。这将给我们一行六个按钮。如果我们有超过六个按钮，将创建一个新行，可以有另外六个按钮。这意味着我们可以稍后向数组中添加级别，并且它们将自动添加到此菜单中，为每六个级别创建新行。最后但并非最不重要的是，在屏幕底部生成一个**SHOP**按钮的实例。
- en: Open `LevelSelect` and place a single instance of `obj_LevelSelect_Overlord`
    somewhere in the room. This is all we need, and to do so click on the checkmark.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LevelSelect`，并在房间中放置一个`obj_LevelSelect_Overlord`的实例。这就是我们需要的全部，要这样做，请点击复选标记。
- en: Run the game. After clicking start game, you should end up in `LevelSelect`
    and it should look like the following screenshot. Only Level 1 is accessible at
    this point and the button is yellow. All the other buttons are gray, indicating
    that they are locked. Clicking on the button for **Level 1** will take you to
    that level and the **SHOP** button should take you to the Shop.![Selecting levels
    with 2D arrays](img/4100_07_03.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。点击开始游戏后，您应该进入`LevelSelect`，并且它应该看起来像以下截图。目前只有1级可访问，按钮是黄色的。所有其他按钮都是灰色的，表示它们被锁定。点击**Level
    1**按钮将带您到该级别，**SHOP**按钮应该带您到商店。![使用2D数组选择级别](img/4100_07_03.jpg)
- en: Preparing the Shop using data structures
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据结构准备商店
- en: 'The only room we have left to build is the Shop where the player will be able
    to purchase equipment to be used in each level. The room will consist of icons
    for each piece of equipment, a listing of the price, and a button to purchase
    the equipment. We will also have a display showing how much cash the player currently
    has and this will update as they spend money:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一剩下要构建的房间是商店，玩家将能够购买用于每个级别的装备。房间将包括每种装备的图标、价格列表和购买装备的按钮。我们还将有一个显示当前玩家拥有多少现金的显示，并且当他们花钱时，这将更新：
- en: 'The first thing we need to do before we build anything is to establish some
    constants to make our code easier to read. Open the **Resources** | **Define Constants**
    editor and set values for the equipment: `TNT`: `0`, `WRECKINGBALL`: `1`, `MAGNET`:
    `2`.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建任何东西之前，我们需要做的第一件事是建立一些常量，以使我们的代码更易于阅读。打开**资源** | **定义常量**编辑器，并为装备设置值：`TNT`：`0`，`WRECKINGBALL`：`1`，`MAGNET`：`2`。
- en: 'We will also need some constants that describe all the elements that comprise
    a piece of equipment. Add `SPRITE`: `0`, `OBJECT`: `1`, `AMOUNT`: `2`, and `COST`:
    `3`. When this is complete the settings in the editor should look like the following
    screenshot:![Preparing the Shop using data structures](img/4100_07_04.jpg)'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些常量来描述组成装备的所有元素。添加`SPRITE`：`0`，`OBJECT`：`1`，`AMOUNT`：`2`和`COST`：`3`。完成后，编辑器中的设置应该如下截图所示：![使用数据结构准备商店](img/4100_07_04.jpg)
- en: 'In order to stick with the color scheme of the game we will need to create
    a unique yellow color that we can access globally. Create a new Script, `scr_Global_Colors`,
    with this code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持游戏的颜色方案，我们需要创建一个全局访问的独特黄色。创建一个新脚本，`scr_Global_Colors`，其中包含以下代码：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We create a global variable for our color and then use a function that has parameters
    for the amount of red, green, and blue to make our special yellow color.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的颜色创建一个全局变量，然后使用一个带有红色、绿色和蓝色数量参数的函数来制作我们特殊的黄色。
- en: Open `scr_Global_GameStart` and execute `scr_Global_Colors()`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`scr_Global_GameStart`并执行`scr_Global_Colors()`。
- en: 'To build a proper Shop and inventory system we need more control over the data
    than a static array allows. We need something more malleable and searchable. This
    is where **data structures** come in. Data structures are special dynamic structures
    similar to arrays, but with the ability to manipulate the data with specific functions
    for things such as shuffling or reordering the data. GameMaker: Studio comes with
    six different types of data structures, each with its own set of functions and
    benefits:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '为了构建一个合适的商店和库存系统，我们需要比静态数组更多的数据控制。我们需要更加灵活和可搜索的东西。这就是**数据结构**的用武之地。数据结构是特殊的动态结构，类似于数组，但具有使用特定函数操纵数据的能力，例如洗牌或重新排序数据。GameMaker:
    Studio带有六种不同类型的数据结构，每种都有自己的一套函数和好处：'
- en: '**Stacks**: This structure is last-in-first-out, meaning that each new piece
    of data is placed on top of the previous one and when it is read, the newest data
    is read first. Think of it like a stack of plates, where you are going to use
    the one last placed on the shelf.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈**：这种结构是后进先出的，意味着每个新的数据都被放置在前一个数据的顶部，当读取时，最新的数据首先被读取。可以把它想象成一叠盘子，你将使用最后放在架子上的那个。'
- en: '**Queues:** This structure is first-in-first-out, meaning that each new piece
    of data is placed behind the one previous to it and when read, the oldest data
    is read first. Think of a line at a store, where the first person in line is going
    to be served first.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**：这种结构是先进先出的，意味着每个新的数据都被放置在前一个数据的后面，当读取时，最旧的数据首先被读取。可以把它想象成商店里的排队，排在最前面的人将首先被服务。'
- en: '**Lists**: This structure is much more flexible. In this structure the data
    can be placed anywhere within the list and can be sorted, altered, and searched
    throughout. Think of this like a deck of cards, where they can be in any order
    which can be changed any time.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：这种结构更加灵活。在这种结构中，数据可以放置在列表中的任何位置，并且可以进行排序、修改和搜索。可以把它想象成一副扑克牌，可以以任何顺序放置，并且随时可以改变。'
- en: '**Maps**: This structure allows for information to be stored in linked pairs
    using keys and values, though it cannot be sorted and all keys must be unique.
    Think of a set of keys, where each key opens only the associated door.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：这种结构允许使用键和值的链接对存储信息，尽管它不能被排序，所有键必须是唯一的。可以把它想象成一组钥匙，每个钥匙只能打开相应的门。'
- en: '**Priority Queues**: This structure is similar to a queue, but each value is
    assigned a priority level. Think of this like a line at a nightclub, where VIPs
    have a higher priority and are let in first.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先队列**：这种结构类似于队列，但每个值都被分配了一个优先级。可以把它想象成夜店里的排队，VIP有更高的优先级，先被放行。'
- en: '**Grids**: This structure is the most robust and is similar to a 2D array.
    It has rows and columns, but it has many functions for sorting, searching, and
    manipulating the data. Think of a searchable airport departure schedule, where
    you can see all the planes, the companies, flight times, and so on, and sort it
    according to your preference.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格**：这种结构是最健壮的，类似于2D数组。它有行和列，但有许多用于排序、搜索和操纵数据的函数。可以把它想象成一个可搜索的机场出发时间表，你可以看到所有的飞机、公司、飞行时间等，并根据自己的喜好进行排序。'
- en: 'We are going to start with a Grid data structure as we need several rows and
    columns of information for each item. Create a new Script, `scr_Global_Equipment`
    and write the following code to build the Grid:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网格数据结构开始，因为我们需要每个物品的几行和列的信息。创建一个新的脚本，`scr_Global_Equipment`，并编写以下代码来构建网格：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We start by declaring a global variable which we then use to hold the ID of
    a Grid. When creating a Grid we need to declare how many rows and columns it needs.
    For this game we have three rows for the pieces of equipment and each piece has
    four columns of data. We set the value for each Grid cell individually, so slot
    0 is the sprite to use, slot 1 the object to spawn, slot 2 is for how many the
    player starts with, and finally, slot 3 is how much it will cost to purchase.
    We have done this for each piece of equipment and we (the player) will start the
    game with single TNT only.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个全局变量，然后使用它来保存网格的ID。创建网格时，我们需要声明它需要多少行和列。对于这个游戏，我们有三行装备，每个装备有四列数据。我们分别为每个网格单元设置了值，所以槽0是要使用的精灵，槽1是要生成的对象，槽2是玩家起始的数量，最后，槽3是购买的成本。我们已经为每个装备做了这个设置，我们（玩家）将在游戏开始时只拥有单个TNT。
- en: Reopen `scr_Global_GameStart` and call this script. We now have all the equipment
    categorized and ready for the Shop.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Global_GameStart`并调用这个脚本。现在我们已经对所有的装备进行了分类，并为商店做好了准备。
- en: 'Next we need to create an inventory for the player to track what equipment
    they have purchased. Since the player needs to add equipment to the inventory
    and will also use that equipment, we need a data structure that is easily mutable.
    We will use a List for this purpose. Create a new Script, `scr_Global_Inventory`,
    and start a List:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为玩家创建一个库存，以跟踪他们购买了什么装备。由于玩家需要将装备添加到库存中，并且还将使用这些装备，我们需要一个易于改变的数据结构。我们将使用列表来实现这个目的。创建一个新的脚本，`scr_Global_Inventory`，并开始一个列表：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We declare a global variable and then use it to hold the ID of the List we create.
    At the start of the game we have already established that the player will have
    some TNT, so that is all we need in the inventory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个全局变量，然后使用它来保存我们创建的列表的ID。在游戏开始时，我们已经确定玩家将拥有一些TNT，所以这就是我们在库存中需要的全部。
- en: 'Once again, call this script in `scr_Global_GameStart`. Here is the complete
    code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在`scr_Global_GameStart`中调用这个脚本。以下是完整的代码：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have all the data stored, we can move on to building the item menu.
    The first element we need to create is a purchase button. Create a new Sprite,
    `spr_Button_Buy`, and with **Remove Background** turned off, load `Chapter 7/Sprites/Button_Buy.gif`.
    **Center** the **Origin** and click on **OK**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经存储了所有的数据，我们可以继续构建物品菜单。我们需要创建的第一个元素是一个购买按钮。创建一个新的精灵，`spr_Button_Buy`，并关闭**删除背景**，加载`Chapter
    7/Sprites/Button_Buy.gif`。**居中** **原点**，然后点击**确定**。
- en: Create a new Object, `obj_Button_Buy`, and assign `spr_Button_Buy` as the **Sprite**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_Button_Buy`，并将`spr_Button_Buy`分配为**Sprite**。
- en: This is a standard button so set the **Parent** to `obj_Button_Parent`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个标准按钮，所以将**Parent**设置为`obj_Button_Parent`。
- en: 'Add a **Mouse** | **Left Pressed** event and apply a new Script, `scr_Button_Buy_MousePressed`,
    with the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Mouse** | **Left Pressed**事件，并应用一个新脚本，`scr_Button_Buy_MousePressed`，其中包含以下代码：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In order to purchase an item, we first need to check to see if the player has
    enough money. For this, we compare the `score` against the data held in the Grid
    we created. You will notice that we have a variable, `myItem`, that has not been
    initialized in the button itself. We will create that variable dynamically later,
    when we spawn the button. If the player can purchase the item, we increase the
    amount the player owns, and reduce the amount of money by the price of the item.
    Finally, we check to see if the player already has some of the item in their current
    inventory. If this is the first item of its type, we add it to the inventory List.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了购买物品，我们首先需要检查玩家是否有足够的钱。为此，我们将`score`与我们创建的网格中保存的数据进行比较。您会注意到我们有一个变量`myItem`，它在按钮本身中尚未初始化。稍后，当我们生成按钮时，我们将动态创建该变量。如果玩家可以购买该物品，我们增加玩家拥有的物品数量，并将金钱减去物品的价格。最后，我们检查玩家当前库存中是否已经有该物品。如果这是其类型的第一个物品，我们将其添加到库存列表中。
- en: We are now ready to spawn everything in the room with a new Object called `obj_Shop_Overlord`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好用一个名为`obj_Shop_Overlord`的新对象在房间中生成所有东西。
- en: 'Add an **Other** | **Room Start** event and attach a new Script, `scr_Shop_Overlord_RoomStart`,
    with the code for spawning the buttons needed in the Shop:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Other** | **Room Start**事件，并附加一个新脚本，`scr_Shop_Overlord_RoomStart`，其中包含在商店中生成所需按钮的代码：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start by running a loop through each row of the equipment Grid so that we
    know how many buttons need to be created. We then spawn a purchase button which
    will be stacked vertically on screen. Next we pass the `myItem` variable that
    is used in the mouse pressed event. The last thing we do is create a start button
    in the lower right corner of the screen so that the player can go back to `LevelSelect`
    option.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过每一行的装备网格运行一个循环，以便我们知道需要创建多少按钮。然后我们生成一个购买按钮，它将垂直堆叠在屏幕上。接下来，我们传递在鼠标按下事件中使用的`myItem`变量。我们做的最后一件事是在屏幕的右下角创建一个开始按钮，以便玩家可以返回到`LevelSelect`选项。
- en: 'We now have all the buttons placed, but we still need to draw all the other
    necessary information. Create a new Script, `scr_Shop_Overlord_Draw`, and add
    it to a **Draw** | **Draw** event:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经放置了所有的按钮，但我们仍然需要绘制所有其他必要的信息。创建一个新脚本，`scr_Shop_Overlord_Draw`，并将其添加到**Draw**
    | **Draw**事件中：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First we need to set the font color to black and center-align the text. We then
    run a loop through the equipment Grid to draw each component. We first draw the
    proper sprite in the correct location to line up with the buttons. Here we use
    a small font to draw the amount of the item the player owns in the small space
    in the lower right corner of the sprite. We then change to a large font and display
    the price of the item.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将字体颜色设置为黑色，并将文本居中对齐。然后我们通过装备网格运行一个循环来绘制每个组件。我们首先在正确的位置绘制正确的精灵，以与按钮对齐。在这里，我们使用小字体在精灵右下角的小空间中绘制玩家拥有的物品数量。然后我们改为大字体，并显示物品的价格。
- en: 'The menu is now built but it is still missing an important piece of information;
    how much cash the player has. Add the following at the end of the script:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单现在已经建好了，但仍然缺少一个重要的信息；玩家有多少现金。在脚本的末尾添加以下内容：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We set the color to our special yellow color for the rest of this text. We set
    a medium font to display the word `Cash` and then change to a large font for the
    actual amount they have. Finally, we reset the font to default.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将颜色设置为我们特殊的黄色，用于本文的其余部分。我们设置一个中等字体来显示单词`现金`，然后改为大字体显示实际金额。最后，我们将字体重置为默认值。
- en: Open up `Shop` and place a single instance of `obj_Shop_Overlord` object somewhere
    in the room. We are done with this room so click on **OK**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`商店`，并在房间的某个地方放置一个`obj_Shop_Overlord`对象的单个实例。我们已经完成了这个房间，所以点击**确定**。
- en: Run the game and go to the Shop. You won't be able to purchase anything at this
    point but you should see the icons, buttons, and information properly displayed.
    It should look like the following screenshot:![Preparing the Shop using data structures](img/4100_07_05.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并前往商店。此时您将无法购买任何物品，但您应该能够看到图标、按钮和信息正确显示。它应该看起来像下面的截图：![使用数据结构准备商店](img/4100_07_05.jpg)
- en: Rebuilding the HUD
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重建HUD
- en: 'Game development is an iterative process where elements are added in when they
    are needed and often reworked several times as features are implemented and feedback
    from users changes the direction of the project. Building a game in this fashion
    saves time because it allows us to get things done quickly, see the results, and
    adapt as we go. In the last chapter we were focused on functionality of the basic
    gameplay. We built a simple HUD that allowed us to spawn each piece of equipment
    with a click. However, we did not limit what equipment the player had access to,
    nor did it have the ability to restart the level or show a countdown timer displaying
    how much time was remaining to clear the Zone. We will need to fix all of this,
    plus we should allow the player to go to the Shop in case their supplies are running
    low. All of this can be done as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发是一个迭代的过程，元素在需要时被添加进去，通常会被重新制作多次，因为功能被实现并且用户的反馈改变了项目的方向。以这种方式构建游戏可以节省时间，因为它允许我们快速完成任务，看到结果，并在进行中进行调整。在上一章中，我们专注于基本游戏玩法的功能。我们建立了一个简单的HUD，允许我们通过点击生成每个装备。然而，我们没有限制玩家可以访问的装备，也没有能力重新开始级别或显示倒计时计时器，显示剩余多少时间来清除区域。我们需要修复所有这些，另外我们应该允许玩家前往商店，以防他们的供应不足。所有这些可以按以下方式完成：
- en: 'We will start by adding some global variables. Create a new Script, `scr_Global_Gameplay`,
    and declare the necessary global variables:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先添加一些全局变量。创建一个新的脚本`scr_Global_Gameplay`，并声明必要的全局变量：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we initialize two variables that we will need to improve the functionality
    of the game. The variable `isGameActive` will be set to `true` at the start of
    each level to commence gameplay. It will also afford us the ability to display
    information at the end of the level while preventing the player from using the
    Menu. The `isTimerStarted` variable will be used for the countdown to clear the
    Zones.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了两个变量，这些变量将改进游戏的功能。变量`isGameActive`将在每个级别开始时设置为`true`，以开始游戏。它还将使我们能够在关卡结束时显示信息，同时防止玩家使用菜单。`isTimerStarted`变量将用于倒计时清除区域。
- en: Open `scr_Global_GameStart` and call this the script.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`scr_Global_GameStart`并调用此脚本。
- en: 'The Menu is also going to need some new variables. Open `scr_Menu_Create` and
    add the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单还需要一些新的变量。打开`scr_Menu_Create`并添加以下代码：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first variable is the amount of time the player will have for a countdown.
    Here we are going to give ten seconds for the Zone to be cleared. We then set
    the vertical location of the menu to be near the bottom of the screen. The next
    two variables are for the horizontal location of the Restart and Shop buttons.
    We need some temporary variables for holding the value of the equipment used and
    how much the player earns in the level as we don't want to change the global score
    unless the player wins the level. Finally, we create another Grid and copy the
    data from the `equip` Grid so that if the level is restarted we still have the
    original settings.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量是玩家进行倒计时的时间。在这里，我们将给予区域被清除的十秒钟。然后我们将菜单的垂直位置设置在屏幕底部附近。接下来的两个变量是重启和商店按钮的水平位置。我们需要一些临时变量来保存使用的装备的值以及玩家在关卡中赚取的金额，因为我们不希望在玩家赢得关卡之前改变全局得分。最后，我们创建另一个网格并复制`equip`网格中的数据，以便如果关卡重新开始，我们仍然拥有原始设置。
- en: 'We will also want to make sure that the player is unable to play a level if
    they have no equipment in their inventory. If that happens we will want to automatically
    go to the Shop. At the very top of the script, add the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望确保玩家如果库存中没有装备，则无法玩关卡。如果发生这种情况，我们将自动去商店。在脚本的顶部，添加以下代码：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We check the size of the inventory and if it contains nothing we go to the Shop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查库存的大小，如果里面什么都没有，我们就去商店。
- en: 'The previous draw script we used for the Menu functioned adequately for what
    we needed at the time. However, now that we have data structures, we can simplify
    the system and add new functionality. We will start by creating a new Script,
    `scr_Menu_Equipment`, for which we will need to accept some parameters:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前用于菜单的绘制脚本在当时的需求下运行得很好。然而，现在我们有了数据结构，我们可以简化系统并添加新功能。我们将首先创建一个新的脚本`scr_Menu_Equipment`，我们需要接受一些参数：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We start by declaring two variables for the two arguments that must be supplied
    when calling this script. **Arguments** are just variables that pass information
    from a script or function when it is called. Here we will have a slot placement
    on the Menu and a declaration of what item is to be displayed in the slot. Since
    we have a predetermined amount of slots on our Menu to be three, we can check
    which slot is being passed and apply the appropriate horizontal offset.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明两个变量，这两个参数在调用此脚本时必须提供。**参数**只是在调用脚本或函数时从脚本或函数传递信息的变量。在这里，我们将在菜单上有一个插槽位置和一个要在插槽中显示的物品的声明。由于我们在菜单上有一个预定数量的插槽，为了是三个，我们可以检查传递的是哪个插槽并应用适当的水平偏移。
- en: 'Next we will add the functionality for how the Menu equipment buttons work.
    Add the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加菜单装备按钮的功能。添加以下代码：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Previously we had code similar to this for each piece of equipment. Now that
    we have the data structure, we can use the information to create all of the equipment
    dynamically. We start by drawing the sprite that is pulled from the local `startEquip`
    Grid. We then check to see if the Menu is active due to the player trying to place
    an item. We check for the mouse location on screen and see if it is hovering above
    the button and change to the appropriate frame of animation. If the button is
    clicked, we create the selected item, subtract one unit of the item from the Grid,
    add the value of the item to how much the player has spent, and make the Menu
    active.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们为每个装备都有类似的代码。现在我们有了数据结构，我们可以使用信息动态创建所有的装备。我们首先绘制从本地`startEquip`网格中提取的精灵。然后我们检查菜单是否处于活动状态，因为玩家试图放置物品。我们检查鼠标在屏幕上的位置，看它是否悬停在按钮上，并更改为适当的动画帧。如果点击按钮，我们创建所选的物品，从网格中减去一个物品单位，将物品的价值添加到玩家的支出中，并使菜单处于活动状态。
- en: 'We have drawn all the Equipment buttons, but we haven''t displayed how many
    items the player has in their inventory. To fix this, add the following code to
    the end of the script:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经绘制了所有的装备按钮，但我们没有显示玩家在他们的库存中有多少物品。为了解决这个问题，在脚本的末尾添加以下代码：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All we are doing here is setting the color, horizontal alignment of the text,
    and the font. We then draw the amount of units for each item in the lower right-hand
    corner as we did in the Shop.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是设置文本的颜色、水平对齐和字体。然后我们像在商店里一样在右下角绘制每个物品的单位数量。
- en: 'Now that we have the improved and simplified Equipment button code, we can
    go back to `scr_Menu_DrawGUI` and remove all the old clunky code. Delete all the
    code except for the very first line that draws the menu background. Once it has
    been removed, add the following code to draw the Menu:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了改进和简化的装备按钮代码，我们可以回到`scr_Menu_DrawGUI`并删除所有旧的笨重代码。删除除绘制菜单背景的第一行代码之外的所有代码。一旦删除了，添加以下代码来绘制菜单：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We start by checking whether the global variable `isGameActive` is true or not.
    If it is true, we get the screen location of the mouse, so we have the proper
    information to place the menu correctly. We then run a loop for as many objects
    as the player has in the inventory, which will then execute the menu equipment
    script to draw all the buttons. At the very end of the script we once again set
    the font back to its default.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查全局变量`isGameActive`是否为true。如果为true，我们获取鼠标的屏幕位置，以便正确放置菜单的位置。然后，我们为玩家在库存中拥有的物品运行一个循环，然后执行菜单装备脚本以绘制所有按钮。在脚本的最后，我们再次将字体设置回默认值。
- en: The HUD needs more than just buttons for the equipment. For a game like this
    we definitely need a button that allows the player to restart the level. Let's
    quickly create a new Sprite, `spr_Button_Restart`, and with **Remove Background**
    turned off, load `Chapter 7/Sprites/Button_Restart.gif`. **Center** the **Origin**
    and click on **OK**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HUD不仅需要装备按钮，还需要其他内容。对于这样的游戏，我们肯定需要一个允许玩家重新开始关卡的按钮。让我们快速创建一个新的精灵，`spr_Button_Restart`，并关闭**Remove
    Background**，加载`Chapter 7/Sprites/Button_Restart.gif`。**Center** **Origin**，然后单击**OK**。
- en: 'We do not need to create an object for this button as it is going to be drawn
    on the Menu. Create a new Script, `scr_Menu_Button_Restart`, and write the following
    code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要为此按钮创建对象，因为它将绘制在菜单上。创建一个新的脚本，`scr_Menu_Button_Restart`，并编写以下代码：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Just as we did with the Equipment buttons, we start by drawing the button in
    its non-hovered state. We then check if the mouse is hovering over the button,
    and if it is, we change the animation to the hover state. If the button is clicked,
    we restart the room.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与装备按钮一样，我们首先以非悬停状态绘制按钮。然后检查鼠标是否悬停在按钮上，如果是，则将动画更改为悬停状态。如果点击按钮，我们重新启动房间。
- en: Reopen `scr_Menu_DrawGUI` and call this script after the loop that creates the
    buttons for the equipment.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Menu_DrawGUI`，并在创建装备按钮的循环之后调用此脚本。
- en: 'We also need a button to allow the player to access the Shop. We can''t use
    the button we previously created as we need it to be drawn on the menu, not spawned
    in the world. Luckily, we can use its sprite so all we need to do is create a
    new Script, `scr_Menu_Button_Shop`, with code similar to all the other menu buttons:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个按钮，允许玩家访问商店。我们不能使用先前创建的按钮，因为我们需要它绘制在菜单上，而不是在世界中生成。幸运的是，我们可以使用它的精灵，所以我们只需要创建一个新的脚本，`scr_Menu_Button_Shop`，代码类似于所有其他菜单按钮：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Same as before, we draw the sprite and then check whether the mouse is hovering
    or not, making sure that we change the width to the larger size of this sprite.
    If the button is clicked, we go to the Shop.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们绘制精灵，然后检查鼠标是否悬停，确保我们将宽度更改为此精灵的较大尺寸。如果点击按钮，我们就会进入商店。
- en: Once again, open `scr_Menu_DrawGUI` and call this script immediately after the
    Restart button.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开`scr_Menu_DrawGUI`，并在重新启动按钮之后立即调用此脚本。
- en: 'We are almost finished with the HUD, we only have one very important piece
    of information we still need to show the player: How much time is left. This will
    be done completely with text, so all we need to do is create a new Script, `scr_Menu_Clock`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎已经完成了HUD，我们只需要向玩家显示一个非常重要的信息：剩余多少时间。这将完全通过文本完成，所以我们只需要创建一个新的脚本，`scr_Menu_Clock`：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The background is black, so we will use the yellow color we created for all
    the text. If the global variable `isTimerStarted` is true, we draw the word `"COUNTDOWN"`
    in small letters and the amount of time remaining in a large font underneath it.
    If `isTimerStarted` is false, we then draw the text in a similar manner to indicate
    to the player what they are supposed to do.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 背景是黑色的，所以我们将使用我们为所有文本创建的黄色。如果全局变量`isTimerStarted`为true，我们以小写字母绘制单词“COUNTDOWN”，并在其下方以大字体显示剩余时间。如果`isTimerStarted`为false，我们将以类似的方式绘制文本，以指示玩家他们应该做什么。
- en: 'Reopen `scr_Menu_DrawGUI` and call this script after the Shop button call.
    The completed script should look like the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`scr_Menu_DrawGUI`，并在商店按钮调用之后调用此脚本。完成的脚本应如下所示：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To get the countdown started we need to activate it, which we can do in `scr_Overlord_KeyPress`.
    Add the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动倒计时，我们需要激活它，在`scr_Overlord_KeyPress`中可以这样做。添加以下代码：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We check the `isTimerStarted` variable to see if it has been activated already
    or not as we only want it to happen once. If the timer has not started, it will
    turn on an alarm in the Menu in one second.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查`isTimerStarted`变量，看它是否已经被激活，因为我们只希望它发生一次。如果计时器尚未启动，它将在一秒钟内在菜单中打开一个警报。
- en: The last thing we need to do to get everything to work is to open `obj_Menu`
    and add an **Alarm** | **Alarm 0** event with a new Script, `scr_Menu_Alarm0`,
    attached.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是打开`obj_Menu`，并添加一个**Alarm** | **Alarm 0**事件，附加一个新的脚本`scr_Menu_Alarm0`。
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Menu has a timer initialized for ten seconds and in this alarm we check
    to see if there is still time remaining. If there is, we reduce the time by one
    and reset the alarm for another second. This will repeat until time expires, in
    which case we tell the Overlord to run the victory condition alarm immediately.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单已经初始化了一个为十秒的计时器，在这个警报中，我们检查是否还有剩余时间。如果有，我们将时间减少一秒，并重置另一个秒的警报。这将重复直到时间到期，此时我们告诉Overlord立即运行胜利条件警报。
- en: The HUD is now controlling the time so we need to remove that functionality
    from the Overlord. Reopen `scr_Overlord_Step` and remove the line of code that
    sets the alarm.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HUD现在正在控制时间，所以我们需要从Overlord中删除该功能。重新打开`scr_Overlord_Step`，并删除设置警报的代码行。
- en: Run the game and play the first level. The Menu has a single Equipment button
    of TNT, a Restart button, and a Shop button. Once you hit spacebar, the countdown
    timer will start ticking down until zero. When time expires the room will either
    restart or go to the next room based on whether the Zone is clear or not. The
    game should look like the following screenshot:![Rebuilding the HUD](img/4100_07_06.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并玩第一关。菜单有一个TNT的单个装备按钮，一个重新开始按钮和一个商店按钮。一旦按下空格键，倒计时器就会开始倒计时，直到为零。当时间到期时，房间将根据区域是否清除而重新启动或进入下一个房间。游戏应该看起来像下面的截图：![重建HUD](img/4100_07_06.jpg)
- en: Adding risk and reward to destruction
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加破坏的风险和回报
- en: 'So far there has been very little risk or reward in the game at all. We have
    added a Shop to the game where we can purchase items, but we are not yet able
    to earn any cash. We can use as much equipment as we want, as long as it is in
    our inventory, which means that there is no need for strategy. We need to add
    a Game Over Screen, if the player ever runs out of money or completes all the
    levels. We also need a Score Screen as currently the player has no idea how well
    they did so we will want to show that as well. It''s time to add these features
    starting with rewarding the player points:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，游戏中几乎没有任何风险或回报。我们已经在游戏中添加了商店，可以购买物品，但我们还不能赚取任何现金。只要物品在我们的库存中，我们可以使用尽可能多的装备，这意味着没有必要进行策略。如果玩家用完所有的钱或完成所有的关卡，我们需要添加一个游戏结束屏幕。由于目前玩家不知道自己的表现如何，我们还需要一个得分屏幕来显示。现在是时候添加这些功能了，首先是奖励玩家分数：
- en: We will start with the Game Over screen. Create a new Room called `GameOver`
    and apply `bg_MainMenu` as its background.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从游戏结束屏幕开始。创建一个名为`GameOver`的新房间，并将`bg_MainMenu`应用为其背景。
- en: Create a new Object, `obj_GameOver`, with no **Sprite** attached.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，`obj_GameOver`，不附加**Sprite**。
- en: 'Upon creation we will create a variable that will contain the game over message
    and we will set an alarm for five seconds, which we will use to restart the game.
    Create a new Script, `scr_GameOver_Create`, with the following code and attach
    it to a **Create** event:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，其中包含游戏结束消息，并设置一个五秒的闹钟，用于重新开始游戏。创建一个新脚本`scr_GameOver_Create`，并将其附加到**Create**事件：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add an **Alarm** | **Alarm 0** event and then attach a new Script, `scr_GameOver_Alarm0`,
    and restart the game:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Alarm** | **Alarm 0**事件，然后附加一个新脚本`scr_GameOver_Alarm0`，并重新启动游戏：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All that we have left to do is to draw the win/lose statement. Create a new
    Script, `scr_GameOver_Draw`, and attach it to a **Draw** | **Draw** event:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所要做的最后一件事就是绘制胜利/失败声明。创建一个新脚本`scr_GameOver_Draw`，并将其附加到**Draw** | **Draw**事件：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If it isn't still open, reopen `GameOver` and place a single instance of `obj_GameOver`
    somewhere in the room. We are now done with this and can close the room.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它还没有打开，重新打开`GameOver`，并在房间中的某个地方放置一个`obj_GameOver`的单个实例。我们现在已经完成了这个，可以关闭房间了。
- en: The next thing we will create is a new Object, `obj_ScoreFloat`, to display
    the points rewarded as each Pillar or Debris is destroyed.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们要创建一个新对象`obj_ScoreFloat`，来显示每个柱子或碎片被摧毁时奖励的分数。
- en: 'Add a **Create** event with a new Script, `scr_ScoreFloat_Create`, and initialize
    two variables:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Create**事件，使用一个新脚本`scr_ScoreFloat_Create`，并初始化两个变量：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will have the score fade out over time, so we have a variable for triggering
    the fade out and one for the value of transparency which is currently set to full
    opacity.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让分数随着时间淡出，所以我们有一个变量来触发淡出，还有一个用于透明度值的变量，目前设置为完全不透明。
- en: 'Next we need to add a **Draw** | **Draw** event with a new Script, `scr_ScoreFloat_Draw`,
    to show the value on screen:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个**Draw** | **Draw**事件，使用一个新脚本`scr_ScoreFloat_Draw`来在屏幕上显示值：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This object is not a part of the physics world, so we can manually move it vertically
    every frame. We increase the `fadeOut` variable and once it hits 60, we start
    to decrease the `alpha` variable by a small amount. Once `alpha` has hit zero,
    we destroy the instance so that it doesn't take up any memory. After that we set
    the color, font, and transparency values and draw the text. The `myValue` variable
    will be passed upon creation from the object that spawns it. Finally, we set the
    transparency back to full opacity; otherwise everything else in the entire room
    will fade out as well.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象不是物理世界的一部分，所以我们可以手动在每一帧垂直移动它。我们增加`fadeOut`变量，一旦它达到60，我们开始逐渐减少`alpha`变量的值。一旦`alpha`达到零，我们销毁实例，以便它不占用任何内存。之后我们设置颜色、字体和透明度值，并绘制文本。`myValue`变量将在创建时从生成它的对象传递。最后，我们将透明度设置回完全不透明；否则整个房间中的其他所有东西也会淡出。
- en: 'Now that we can display the score we need to spawn it and pass a value to it.
    Since we already know that each Pillar and Debris has a different mass, we can
    use that number to award points upon its destruction. Reopen `scr_Pillar_BreakApart`
    and insert the following code after the shatter sound is played but before the
    instance is destroyed:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以显示分数，我们需要生成它并传递一个值给它。由于我们已经知道每个柱子和碎片的质量不同，我们可以使用这个数字来在其被摧毁时奖励分数。重新打开`scr_Pillar_BreakApart`，在播放破碎声音后但实例被销毁之前插入以下代码：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the Pillar breaks apart it will spawn an instance of `obj_ScoreFloat`.
    We then set the displayed value to the rounded down amount of the object's total
    mass. Finally, we increase the Menu's `tempScore` by the same amount.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当柱子破碎时，它将生成一个`obj_ScoreFloat`的实例。然后我们将显示的值设置为对象总质量的向下取整。最后，我们将菜单的`tempScore`增加相同的数量。
- en: We need the Small Pillars and Debris to do the same, so open `scr_Pillar_Destroy`
    and insert the same code in the same place.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要让小柱子和碎片做同样的事情，所以打开`scr_Pillar_Destroy`，并在同样的位置插入相同的代码。
- en: Run the game and destroy the Pillars in the first level. As each piece breaks,
    a number will float up signifying the value that it is worth. The floating numbers
    should fade out after a few seconds and should look something like the following
    screenshot:![Adding risk and reward to destruction](img/4100_07_07.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并摧毁第一关的柱子。每块破碎的部分都会浮出一个数字，表示它的价值。浮动的数字应该在几秒钟后淡出，并且应该看起来像以下截图：![为破坏添加风险和回报](img/4100_07_07.jpg)
- en: All we need to do now is to make a Score Screen that sums up the damage and
    shows the total profit for the level. We will start by bringing in a few more
    sprites, `spr_Screen_BG` and `spr_Button_NextLevel`, both supplied in `Chapter
    7/Sprites/`. Make sure not to **Remove Background** and to **Center** the **Origin**
    for both.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要制作一个总结损坏并显示关卡总利润的得分屏幕。我们将首先引入一些额外的精灵，`spr_Screen_BG`和`spr_Button_NextLevel`，都在`第7章/精灵/`中提供。确保不要**删除背景**，并为两者都**居中**设置**原点**。
- en: 'Let''s create a new Script, `scr_Menu_Button_NextLevel`, with the functionality
    of this button:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新脚本`scr_Menu_Button_NextLevel`，实现此按钮的功能：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We only want the Next Level button to appear if the player successfully clears
    the Zones, so we check for that first. If the player has won the level, we draw
    the sprite and then check to see if the mouse is hovering over it. If the mouse
    is over the button and it is pressed, we run a quick loop through the level array
    to see what room we are currently in and unlock the next level. Finally we go
    to the room we just unlocked.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只希望下一关按钮在玩家成功清除区域时出现，因此我们首先检查这一点。如果玩家赢得了关卡，我们绘制精灵，然后检查鼠标是否悬停在其上。如果鼠标悬停在按钮上并按下，我们快速遍历关卡数组，查看我们当前所在的房间，并解锁下一关。最后，我们进入刚刚解锁的房间。
- en: Now we are ready to create a new Object, `obj_ScoreScreen`, to display the Score
    Screen. Set the **Depth** to `-100` so that it always draws on top of all other
    GUI elements.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备创建一个新对象`obj_ScoreScreen`，用于显示得分屏幕。将**深度**设置为`-100`，以便它始终显示在所有其他GUI元素的顶部。
- en: 'Add a **Create** event with a new Script, `scr_ScoreScreen_Create` attached
    and initialize the following variables:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新脚本`scr_ScoreScreen_Create`添加一个**Create**事件，并初始化以下变量：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We don't want the player to play during this time, so we turn off the `isGameActive`
    variable and make the Menu active so that the Equipment buttons no longer function.
    Next we need to check if the player has been successful in order to know what
    to draw. The final seven variables are all for the placement of the various text
    and buttons we will be displaying.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望玩家在这段时间内进行游戏，因此我们关闭`isGameActive`变量，并激活菜单，使得装备按钮不再起作用。接下来，我们需要检查玩家是否成功，以便知道要绘制什么。最后的七个变量都是用于放置我们将显示的各种文本和按钮。
- en: 'Now to add a **Draw** | **Draw GUI** event with a new Script, `scr_ScoreScreen_DrawGUI`
    and we will start by drawing all the text we need:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个**Draw** | **Draw GUI**事件，使用新脚本`scr_ScoreScreen_DrawGUI`，我们将首先绘制所需的所有文本：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First we draw the background sprite. We then set the color, alignment, and font.
    We are using the largest font to draw the name of the room and the values for
    the amount of damage, the amount of equipment used, and the total profit. We then
    switch to the medium font to write the description of each value, placed above
    the number it corresponds to. We are done drawing text, so we set the font back
    to its default value.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先绘制背景精灵。然后设置颜色、对齐和字体。我们使用最大的字体来绘制房间的名称和损坏量、使用的装备量和总利润的值。然后切换到中等字体，写出每个值的描述，放在相应数字的上方。我们完成了绘制文本，所以将字体设置回默认值。
- en: 'Now we just need to add the buttons into the script:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要将按钮添加到脚本中：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Just as we did with the Menu, we get the coordinates of the mouse on screen
    and then execute the scripts for the three buttons.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在菜单中所做的那样，我们获取屏幕上鼠标的坐标，然后执行三个按钮的脚本。
- en: 'In order to activate the Score Screen, we need to reopen `scr_Overlord_Alarm0`
    and have it spawn an instance of `obj_ScoreScreen` instead of the code it currently
    runs. Remove all the code and replace it with the following code:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了激活得分屏幕，我们需要重新打开`scr_Overlord_Alarm0`，并让它生成`obj_ScoreScreen`的一个实例，而不是当前运行的代码。删除所有代码，并用以下代码替换它：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run the game and finish the first level. After the timer has run out, the Score
    Screen appears displaying the damage, the cost, and the profit. The in-game menu
    has disappeared and has been replaced by three buttons for replaying the level,
    going to the Shop, or the next level. It should look like the following screenshot:![Adding
    risk and reward to destruction](img/4100_07_08.jpg)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并完成第一关。计时器结束后，得分屏幕将显示损坏、成本和利润。游戏菜单已消失，并被三个按钮替换，用于重新玩关卡、前往商店或下一关。它应该看起来像以下截图：![为破坏添加风险和回报](img/4100_07_08.jpg)
- en: 'There is one issue that we need to solve. While the screen says we have earned
    money, if we go to the Shop, there will be no cash available. This is because
    we haven''t transferred the temporary values to the global values, which we will
    do in a new Script called `scr_ScoreCleanUp`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要解决一个问题。虽然屏幕显示我们已经赚了钱，但如果我们去商店，将没有现金可用。这是因为我们还没有将临时值转移到全局值，我们将在一个名为`scr_ScoreCleanUp`的新脚本中完成这个操作：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When this script is executed, it will go into the Menu and copy the remaining
    equipment over to the global equipment values and then delete the temporary grid
    from memory. Next we increase the global score based on what occurred during gameplay.
    We then run a loop through the inventory looking for whether the player has run
    out of any items. If they have, we remove it from the inventory altogether.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将进入菜单，并将剩余的装备复制到全局装备值中，然后从内存中删除临时网格。接下来，根据游戏过程中发生的情况增加全局得分。然后，我们通过库存运行循环，查找玩家是否已用完任何物品。如果是，我们将其从库存中删除。
- en: 'If the player goes to the next level, we should pay them immediately. We should
    also check the score to make sure that the player has money. If they run out of
    money, then it is game over, otherwise they can go to the next level. Reopen `scr_Menu_Button_NextLevel`
    and replace the line of code where we switch rooms with the following:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家进入下一关，我们应该立即支付他们。我们还应该检查分数，以确保玩家有钱。如果他们钱花光了，那就是游戏结束，否则他们可以进入下一关。重新打开`scr_Menu_Button_NextLevel`并用以下代码替换切换房间的那行代码：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the player decides to go to the Shop, it becomes a bit trickier. The script
    we are calling is also used on the Menu, so we don''t want it to change the data
    during gameplay. Reopen `scr_Menu_Button_Shop` and replace the line of code where
    we switch rooms with the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家决定去商店，情况会变得有点棘手。我们正在调用的脚本也在菜单上使用，所以我们不希望它在游戏进行时改变数据。重新打开`scr_Menu_Button_Shop`并用以下代码替换切换房间的那行代码：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now the score will be transferred only if gameplay has stopped. We also check
    the score here for the game over state to decide what room to go to when clicked.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有在游戏停止时才会传输分数。我们还在这里检查游戏结束状态的分数，以决定点击时要去哪个房间。
- en: Everything should work properly now, so run the game and check to make sure
    that the score doesn't change when you go to the shop during gameplay.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一切应该正常工作了，所以运行游戏并检查一下，确保在游戏进行时去商店时分数不会改变。
- en: Adding introductory text to each level
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为每个级别添加介绍性文本
- en: 'We have a good end to the levels, but the player may not be sure what to do.
    What we need is a bit of a story to sell the idea of destroying towers and explaining
    what it is the player needs to do in each level. To do this we will add a screen,
    much like the Score Screen at the start of each level:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了关卡的良好结局，但玩家可能不确定该怎么做。我们需要一点故事来推销摧毁塔的想法，并解释玩家在每个关卡需要做什么。为此，我们将在每个关卡开始时添加一个屏幕，就像在每个关卡开始时的得分屏幕一样：
- en: 'We will need a button to start the level, which again will need to be drawn
    on screen. Create a new Script, `scr_Menu_Button_Start`, with some very familiar
    code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个按钮来开始关卡，同样需要在屏幕上绘制。创建一个新脚本`scr_Menu_Button_Start`，其中包含一些非常熟悉的代码：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: All the standard button code is here, but when the button is clicked, we activate
    the gameplay and then destroy the Story screen object. The `start_ZoneWidth` and
    `start_ZoneHeight` variables used here haven't been initialized yet, but we will
    be doing that shortly.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准按钮代码都在这里，但当按钮被点击时，我们激活游戏并销毁Story screen对象。这里使用的`start_ZoneWidth`和`start_ZoneHeight`变量尚未初始化，但我们很快就会做到。
- en: 'Next we need all the text that we want to display for each level. For this
    we will want to use a Map data structure so that we can link the text to the level.
    Create a new Script, `scr_Global_Dialogue`, and write the dialog that we need:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要所有我们想要为每个关卡显示的文本。为此，我们将使用一个地图数据结构，以便我们可以将文本链接到关卡。创建一个新脚本`scr_Global_Dialogue`，并编写我们需要的对话：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We make a new global variable and attach it to the Map data structure we create.
    For each entry we need to have a **Key** and a **Value** for that key. Here we
    use the name of each room as a key and write the dialog as the value. We need
    text for every room in the game so it doesn't error out, so we have temporary
    dialog for rooms 2-12 that you can replace with your own text. In the dialog for
    Level 01 we are using `#` which is a special character used to start a new paragraph.
    This will make large amounts of text a bit more readable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的全局变量，并将其附加到我们创建的地图数据结构上。对于每个条目，我们需要一个**Key**和一个**Value**。在这里，我们使用每个房间的名称作为键，并将对话写为值。我们需要为游戏中的每个房间都有文本，以免出错，所以我们为房间2-12提供了临时对话，您可以用自己的文本替换。在Level
    01的对话中，我们使用`#`，这是一个特殊字符，用于开始新的段落。这将使大量文本更易读。
- en: Open `scr_Global_GameStart` and call this script.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`scr_Global_GameStart`并调用这个脚本。
- en: We have all the art assets we need, but we do need a new Object, `obj_StoryScreen`,
    with a **Depth** of `-100`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经拥有了所有需要的艺术资源，但我们需要一个新的对象`obj_StoryScreen`，深度为`-100`。
- en: 'Add a **Create** event and apply a new Script, `scr_StoryScreen_Create`, to
    initialize the variables:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Create**事件并应用一个新脚本`scr_StoryScreen_Create`来初始化变量：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We stop gameplay and then set six variables for the location of the text we
    will be drawing. We then load up the text from the Map based on the room the player
    is currently in. The last variable we have, `textLength` , is going to be used
    for an inventory effect, where the text appears to be typed in over time.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们停止游戏并设置六个变量来确定我们将要绘制的文本的位置。然后根据玩家当前所在的房间从地图中加载文本。我们最后一个变量`textLength`将用于一个库存效果，文本看起来会随着时间而被打出来。
- en: 'Next we need to add a **Draw** | **Draw GUI** event with a new Script, `scr_StoryScreen_DrawGUI`,
    that draws everything:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个**Draw** | **Draw GUI**事件，并使用一个新脚本`scr_StoryScreen_DrawGUI`来绘制一切：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As we did with the Score Screen, we draw the background and set the color, alignment,
    and font for the title of the level. Next is the typewrite effect for the dialog
    to be shown on screen. We change the alignment and font for the dialog and start
    increasing the `textLength` variable by one step each. This value is what determines
    how many characters from the dialog need to be copied over to the `writeText`
    variable, which means that the text will grow over time. We are using the `draw_text_ext`
    function, which allows us to limit how wide the paragraph can be before it drops
    down a line, in this case 320 pixels. Once again at the end we get the mouse location
    for the start button to work.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与得分屏幕一样，我们绘制背景并设置标题的颜色、对齐方式和字体。接下来是对话框在屏幕上显示的打字效果。我们改变对话框的对齐方式和字体，然后开始逐步增加`textLength`变量。这个值决定了需要复制到`writeText`变量的对话中有多少个字符，这意味着文本会随着时间增长。我们使用`draw_text_ext`函数，它允许我们限制段落在下移一行之前可以有多宽，本例中为320像素。最后，我们再次获取鼠标位置以使开始按钮工作。
- en: 'All that is left for us to do is to spawn an instance of the Story screen in
    `scr_Overlord_Create`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事就是在`scr_Overlord_Create`中生成一个Story screen的实例：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Run the game and go to the first level. The story screen appears and the dialog
    starts appearing one letter at a time and should look like the image below. When
    the **START** button is clicked, the gameplay starts as usual.![Adding introductory
    text to each level](img/4100_07_09.jpg)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并进入第一关。故事画面出现，对话开始一次出现一个字母，应该看起来像下面的图片。当点击**开始**按钮时，游戏玩法如常开始。![为每个级别添加介绍性文本](img/4100_07_09.jpg)
- en: Saving the player's progress
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存玩家的进度
- en: Polish in games is not always about the visual embellishments. Sometimes it's
    also about adding smaller features that aren't immediately noticeable but can
    drastically improve the overall experience. Currently the game looks good and
    plays well, but if we close down the browser and return to play at a later time,
    we will need to start all over again. Players these days expect that they can
    come back to a game and continue from where they left off. In order to do this,
    we need to save the player's progress.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的润色并不总是关于视觉装饰。有时也涉及添加一些不会立即被注意到但可以极大改善整体体验的小功能。目前游戏看起来不错，玩起来也很顺畅，但如果我们关闭浏览器然后在以后的时间返回来玩，我们将需要重新开始。如今的玩家期望他们可以回到游戏并从他们离开的地方继续。为了做到这一点，我们需要保存玩家的进度。
- en: Understanding local storage
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解本地存储
- en: Whenever a game needs to save data the only viable option is to write the data
    to a file outside of the game itself. This poses a potential problem for web-based
    games as any file that needs to be downloaded will require the user to explicitly
    allow it. This would mean the player would know the name of the file and where
    it is located, which in turn would mean they could easily hack their own saved
    file. To get around this hurdle, HTML5 offers a solution known as **local storage**.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每当游戏需要保存数据时，唯一可行的选择是将数据写入游戏本身之外的文件。对于基于网络的游戏来说，这可能会带来问题，因为任何需要下载的文件都需要用户明确允许。这意味着玩家会知道文件的名称和位置，这反过来意味着他们可以轻松地黑客自己的保存文件。为了避开这个障碍，HTML5提供了一个名为**本地存储**的解决方案。
- en: Local storage allows web pages, or in our case a game embedded into a web page,
    to save data within the browser itself. This is similar to internet cookies but
    with the benefit of being faster, more secure, and potentially able to store a
    lot more information. Since this data is saved in the browser, the user is not
    notified of the file being created or accessed; they cannot see the data easily
    and it is only accessible from the domain that creates it. This makes it perfect
    for saving our game data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储允许网页，或者在我们的情况下是嵌入到网页中的游戏，将数据保存在浏览器内部。这类似于互联网cookie，但具有更快、更安全的优势，并且可能能够存储更多的信息。由于这些数据保存在浏览器中，用户不会收到文件被创建或访问的通知；他们无法轻松地看到数据，而且只能从创建它的域中访问。这使得它非常适合保存我们的游戏数据。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are only two ways to clear the saved data. Overwrite the data or clear
    your browser's cache. It is recommended that you always test games in a private
    browser mode to guarantee the save system is working properly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 清除保存的数据只有两种方法。覆盖数据或清除浏览器的缓存。建议您始终在私人浏览器模式下测试游戏，以确保保存系统正常工作。
- en: Writing to local storage
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入本地存储
- en: 'For this game, we are going to save all the relevant data related to the levels
    unlocked, the amount of cash accrued, and the equipment purchased. To save the
    game data we are going to need to write to a file. GameMaker: Studio has two file
    formats that it can handle for HTML5 games: **Text files** and **Ini files** .
    Text files are useful for reading or writing large amounts of data and can be
    structured in any way you choose. Ini files are intended for smaller amounts of
    data and use a **section/key/value** structure. This structure breaks the data
    into separate sections and in each section there will be key/value pairs that
    look something like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这个游戏，我们将保存所有与解锁的级别、累积现金金额和购买的装备相关的数据。为了保存游戏数据，我们需要写入文件。GameMaker: Studio有两种文件格式可以处理HTML5游戏：**文本文件**和**Ini文件**。文本文件适用于读取或写入大量数据，并且可以按任何您选择的方式进行结构化。Ini文件用于较小量的数据，并使用**部分/键/值**结构。这种结构将数据分成单独的部分，在每个部分中将有键/值对，看起来像这样：'
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Local storage requires all data to be in key/value pairs so that we will be
    using the Ini file system. It is possible to use the text file system, but for
    the little amount of data we need to save and the amount of extra coding it would
    take, it''s not very beneficial:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储要求所有数据都是键/值对，因此我们将使用Ini文件系统。虽然可以使用文本文件系统，但对于我们需要保存的少量数据以及额外编码所需的工作量来说，这并不是很有益。
- en: 'The first thing any save system needs to do is to create a save file with the
    appropriate structure and settings desired. Create a new Script, `scr_GameSave`,
    and write the following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何保存系统需要做的第一件事是创建一个具有所需结构和设置的保存文件。创建一个新的脚本，`scr_GameSave`，并编写以下代码：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When we execute this script we will require the name of the file to be passed
    as an argument. We can then open the requested file, or if one is not found it
    will be created to open. Once the file is open we can write all of the necessary
    data. We start by writing to a `Score` section, with a key called `Cash` to set
    the value of score. We run a loop using the level array and in a `Levels` section
    we store each level and whether it has been unlocked or not. Next we run another
    loop, this time going through the equipment grid and writing how many of each
    item the player currently has in the game. Finally, after all the data has been
    written we close the file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个脚本时，我们需要传递文件的名称作为参数。然后我们可以打开请求的文件，或者如果找不到文件，将创建一个打开。一旦文件打开，我们就可以写入所有必要的数据。我们首先写入一个`Score`部分，使用一个名为`Cash`的键来设置分数的值。我们使用级别数组运行一个循环，在`Levels`部分中存储每个级别以及它是否已解锁。接下来我们运行另一个循环，这次是遍历装备网格，并写入玩家当前在游戏中拥有的每种物品的数量。最后，在所有数据都被写入后，我们关闭文件。
- en: Saving a game is only useful if we actually load the data into it. Create a
    new Script, `scr_GameLoad`, so we can read from the file.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存游戏只有在实际加载数据时才有用。创建一个新脚本，`scr_GameLoad`，以便我们可以从文件中读取。
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We start by checking whether the file, as passed through the argument, exists.
    If the file is not found in local storage, such as the first time the game is
    run, we run the save script to initialize the values. If the file is found we
    open the save file and read the data into the game just as we saved it. We set
    the score, unlock the appropriate levels, and load the equipment. We also run
    through the inventory to ensure that all the equipment is available to the player.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查通过参数传递的文件是否存在。如果在本地存储中找不到文件，比如游戏首次运行时，我们会运行保存脚本来初始化数值。如果找到文件，我们会打开保存文件并将数据读入游戏，就像我们保存的那样。我们设置分数，解锁适当的关卡，并加载装备。我们还会遍历库存，以确保所有装备对玩家可用。
- en: 'We will want to load any game data at the start of the game. Open `scr_Global_GameStart`
    and add the following code at the end of the script:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在游戏开始时加载任何游戏数据。打开`scr_Global_GameStart`，并在脚本末尾添加以下代码：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We create a global variable for the filename so we can save our data easily
    later. We then pass the string to the load script. This code must be at the end
    of the script because we need the default values for our grids and arrays to have
    been initialized first.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为文件名创建一个全局变量，以便稍后轻松保存我们的数据。然后将字符串传递给加载脚本。此代码必须放在脚本的末尾，因为我们需要首先初始化网格和数组的默认值。
- en: 'The most logical place to start saving the game is after the player has completed
    each level. Open `scr_ScoreCleanUp` and just before the final brace, insert a
    call to `scr_GameSave`. The entire script is seen below:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存游戏的最合逻辑的地方是在玩家完成每个关卡后。打开`scr_ScoreCleanUp`，并在最后的大括号之前插入对`scr_GameSave`的调用。整个脚本如下所示：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We also need to save the game when the player purchases Equipment in the Shop.
    Open `scr_Button_Buy_MousePressed` and insert the call to `scr_GameSave` just
    before the final brace.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家在商店购买装备时，我们还需要保存游戏。打开`scr_Button_Buy_MousePressed`，并在最后的大括号之前插入对`scr_GameSave`的调用。
- en: Save the game and play the first few levels. After you have completed a few
    levels, refresh the browser. You should see that all your cash, equipment, and
    unlocked levels remain the same.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存游戏并玩几个关卡。完成几个关卡后，刷新浏览器。您应该看到您的现金、装备和已解锁的关卡仍然保持不变。
- en: Saving multiple game profiles
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存多个游戏配置文件
- en: 'We now have a game that can save a player''s progress, but no way of clearing
    the data if they want to replay the game. As we mentioned already, the only option
    for removing the data is to have the user clear their browser''s cache or overwrite
    the data, both options having drawbacks. Most users won''t want to clear their
    cache as it will remove all the data in local storage, not just the game data.
    Overwriting the data is problematic if multiple people want to play the game in
    the same browser. Having only a single save file becomes meaningless. We do have
    a third option available which is that we don''t clear the data at all, but rather
    we create additional save files that can be loaded at any time. Our current save/load
    system is already prepared for us to have multiple user profiles, we just need
    to add an input system to capture the name of the user. We will keep the system
    fairly simple, placing it on the front end and limit the user names to a maximum
    of eight characters. When the player clicks the start button, it will load the
    proper profile before it switches rooms:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以保存玩家进度的游戏，但没有清除数据的方法，如果他们想重新玩游戏。正如我们已经提到的，删除数据的唯一选择是让用户清除其浏览器缓存或覆盖数据，这两种选择都有缺点。大多数用户不会想清除其缓存，因为这将删除本地存储中的所有数据，而不仅仅是游戏数据。如果多个人想在同一浏览器中玩游戏，覆盖数据会有问题。只有一个保存文件变得毫无意义。我们还有第三个可用的选项，即我们根本不清除数据，而是创建可以随时加载的额外保存文件。我们当前的保存/加载系统已经准备好让我们拥有多个用户配置文件，我们只需要添加一个输入系统来捕获用户的名称。我们将保持系统相当简单，将其放在前端，并将用户名称限制为最多八个字符。当玩家点击开始按钮时，它将在切换房间之前加载适当的配置文件：
- en: We will start by adding one more global variable for the player's name. Open
    `scr_Global_GameStart`, initialize the `playerName` variable, and set it to an
    empty string at the end of the script.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先添加一个用于玩家名称的全局变量。打开`scr_Global_GameStart`，初始化`playerName`变量，并在脚本末尾将其设置为空字符串。
- en: '[PRE62]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We will need to create a new Object, `obj_NameInput`, which we can use for tracking
    the player's input. It does not need a sprite since we will be drawing the text
    onto the screen.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的对象，`obj_NameInput`，用于跟踪玩家的输入。由于我们将在屏幕上绘制文本，因此它不需要精灵。
- en: Add a **Create** event with a new Script, `scr_NameInput_Create`, to initialize
    variables for the length of the string and how many characters have been typed.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Create**事件，附加一个名为`scr_NameInput_Create`的新脚本，用于初始化字符串的长度和已输入字符的数量的变量。
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next we will add a **Draw** | **Draw** event with a new Script, `scr_NameInput_Draw`,
    attached to draw the player''s name as it is typed and a simple instruction telling
    the player to type in their name:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个**Draw** | **Draw**事件，附加一个名为`scr_NameInput_Draw`的新脚本，用于绘制玩家输入的名称以及一个简单的指示，告诉玩家输入他们的名字：
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now that we have everything displayed on screen we need to gather the keyboard
    input. Add a **Key Press** | **Any Key** event and attach a new Script called
    `scr_NameInput_KeyPressed`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在屏幕上显示了所有内容，我们需要收集键盘输入。添加一个**Key Press** | **Any Key**事件，并附加一个名为`scr_NameInput_KeyPressed`的新脚本。
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We only want the name to be a maximum of eight letters, so we first check to
    see if there is still space available in the current name. If we can input another
    letter, we then check if the key that is being pressed is a letter. If a letter
    has been pressed, we add that letter to the end of the string and then indicate
    that another space has been used.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只希望名称最多为八个字母，因此我们首先检查当前名称是否仍有空间。如果我们可以输入另一个字母，然后我们检查正在按下的键是否是字母。如果按下了字母，我们将该字母添加到字符串的末尾，然后指示另一个空间已被使用。
- en: 'If we ran the game now we would be able to enter letters, but we have no ability
    to undo any letters. We can fix that with the following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在运行游戏，我们将能够输入字母，但我们无法撤消任何字母。我们可以使用以下代码来解决这个问题：
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the user presses *backspace*, we grab the length of the string to find out
    where the last space of the string is. Once we know that, we can then remove the
    letter at the end of the string. Finally we check to see if there are still letters
    remaining and if so, reduce the space count by one. This is needed so that we
    can't go into negative spaces.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下*退格*键，我们获取字符串的长度，以找出字符串的最后一个空格在哪里。一旦我们知道了这一点，我们就可以删除字符串末尾的字母。最后，我们检查是否仍然有剩余的字母，如果有，就减少空格计数。这是必要的，这样我们就不会进入负空间。
- en: Open `MainMenu` and place a single instance of `obj_NameInput` somewhere in
    the room, location does not matter.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainMenu`，在房间的某个地方放置一个`obj_NameInput`的单个实例，位置无关紧要。
- en: Save and play the game. In the front end you should be able to enter a name
    of up to eight letters and by clicking backspace, delete all those letters. It
    should look like the following screenshot:![Saving multiple game profiles](img/4100_07_12.jpg)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并玩游戏。在前端，你应该能够输入最多八个字母的名字，并通过点击退格键删除所有这些字母。它应该看起来像下面的截图：![保存多个游戏配置文件](img/4100_07_12.jpg)
- en: 'The save system is now complete; all that is left to do is to load the data
    when the player clicks the **START** button. Since we use the **START** button
    in the Shop as well as the Main Menu, we will need to run a check to ensure we
    only load the game data at the beginning of the game. Open `scr_Button_Start_MousePressed`
    and before the room is changed, add the following code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存系统现在已经完成；剩下要做的就是在玩家点击**开始**按钮时加载数据。由于我们在商店和主菜单中都使用**开始**按钮，我们需要运行一个检查，以确保我们只在游戏开始时加载游戏数据。打开`scr_Button_Start_MousePressed`，在房间改变之前，添加以下代码：
- en: '[PRE67]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Save and play the game. Use your name and play the game, completing a few levels.
    Then refresh the page and enter a different name. When you get to the level selection,
    only the first room should be available.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并玩游戏。使用你的名字玩游戏，完成几个级别。然后刷新页面并输入一个不同的名字。当你到达级别选择时，只有第一个房间应该是可用的。
- en: Refresh the browser a second time and use your name once again. This time when
    you get to the level selection you should see all your unlocked levels. The save
    system works!
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新浏览器第二次，再次使用你的名字。这次当你到达级别选择时，你应该能看到所有解锁的级别。保存系统有效！
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Excellent work! In this chapter we really rounded out the game experience by
    adding an entire front end, including a Shop and unlockable levels. We learned
    to use Grids, Maps, and List data structures to hold a variety of information.
    We rebuilt the HUD so that we could display more buttons, display only the available
    equipment, and built a basic countdown timer. We created a Score Screen to show
    the player how they fared in the level. We also created an introductory screen
    at the front of each level that utilized a simple typewriter effect that showed
    us how to manipulate strings. Finally, we added a save system that taught us about
    using local storage and allows us to have multiple player saves!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在本章中，我们通过添加整个前端，包括商店和可解锁的级别，真正完善了游戏体验。我们学会了使用网格、地图和列表数据结构来保存各种信息。我们重建了HUD，以便能够显示更多按钮，只显示可用的装备，并建立了一个基本的倒计时器。我们创建了一个得分屏幕，向玩家展示他们在级别中的表现。我们还在每个级别的前面创建了一个介绍屏幕，利用了一个简单的打字机效果，向我们展示了如何操作字符串。最后，我们添加了一个保存系统，教会了我们如何使用本地存储，并允许我们拥有多个玩家存档！
- en: Overall we took the game from being a playable prototype to a fully fleshed
    out game with a beginning and end and plenty of risk and reward. In the next chapter
    we are going to continue to polish this game by taking a look at particle effects
    and adding them to the Pillar and Debris destruction. Let's get on with it!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们将游戏从一个可玩的原型变成了一个完全成熟的游戏，有一个开始和结束，还有很多风险和回报。在下一章中，我们将继续通过查看粒子效果并将其添加到柱子和碎片的销毁中来完善这个游戏。让我们继续吧！
