- en: Chapter 3. Let's Build a Role Playing Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。让我们建立一个角色扮演游戏
- en: In the previous chapter we took a look at several key concepts and zoomed in
    on them one by one, largely disregarding their underlying dependencies. Now we
    will build up a game step by step. In this chapter we will take a look at the
    RPG, while in [Chapter 4](ch04.html "Chapter 4. Let's Build a Side Scroller Game"),
    *Let's build a Side Scroller Game*, we will dive into the side scroller game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了几个关键概念，并逐一放大它们，基本上忽略了它们的基本依赖关系。现在我们将逐步构建一个游戏。在本章中，我们将看看RPG，而在[第4章](ch04.html“第4章。让我们建立一个侧面滚动游戏”)中，我们将深入研究侧面滚动游戏。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The RPG game format and its possible sub formats
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPG游戏格式及其可能的子格式
- en: Building an actual level for your player to explore and connecting it to other
    levels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家建立一个实际的探索级别，并将其与其他级别连接起来
- en: Adding a playable entity, slayable but dangerous foes, and neutral talkative
    characters to the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向游戏中添加可玩实体、可杀但危险的敌人和中立的健谈角色
- en: Turning your player into a force to be reckoned with by adding weapons and helpful
    items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的玩家变成一个不可忽视的力量，通过添加武器和有用的物品
- en: Adding some depth to the player's enemies by bestowing them with basic artificial
    intelligence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过赋予敌人基本的人工智能，为玩家的敌人增加一些深度
- en: Keeping track of some changes in the game such as the collections of coins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪游戏中的一些变化，比如收集硬币
- en: Ending the game by pitting the player against a more formidable foe
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过让玩家与更强大的敌人对抗来结束游戏
- en: The RPG game setting
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPG游戏设置
- en: 'Before diving into the RPG game setting it would be good to have a look at
    some successful RPGs and see what we can learn from them. There are some great
    examples out there: **Zelda** , **Final Fantasy** , **Pokémon** , **World Of Warcraft**
    , **Tibia** , **Baldur''s Gate** , **Neverwinter Nights** , and so on. The list
    is virtually endless. What made all these games so successful? Well, there is
    always the marketing component, but no game can reap eternal fame on marketing
    alone. So what was their *unique gaming proposition* for the audience they targeted?
    Game reviewers often divide their marks over several categories such as gameplay,
    graphics, sound, and so on. These are valid points, but why not have a look at
    addictiveness for example? Even the simplest game can be addictive. If you have
    ever been to Vegas and witnessed the tons of people playing for hours on slot
    machines that require no skill at all, you will understand that there is something
    special about game psychology.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究RPG游戏设置之前，最好看一看一些成功的RPG，并看看我们可以从中学到什么。有一些很好的例子：《塞尔达传说》，《最终幻想》，《宝可梦》，《魔兽世界》，《泰比亚》，《博德之门》，《无冬之夜》等等。这个列表几乎是无穷无尽的。是什么让所有这些游戏如此成功呢？嗯，总是有营销因素，但没有游戏可以仅凭营销而获得永恒的名声。那么，他们对目标受众的*独特游戏主张*是什么？游戏评论员经常将他们的分数分配到几个类别，如游戏性、图形、声音等。这些都是有效的观点，但为什么不看看上瘾性呢？即使是最简单的游戏也可能会上瘾。如果你曾经去过拉斯维加斯，目睹了成堆的人在不需要任何技能的老虎机上玩了几个小时，你就会明白游戏心理学有些特别。
- en: Addictiveness is of course great, if you offer a free game and want to make
    money from in-game advertising or recurring subscription fees. Another approach
    is making the game engaging but final. Those are the games you can actually "finish".
    They usually have an interesting story between the games' protagonist and antagonist.
    When the antagonist is defeated, the game ends and as a player you are unlikely
    to pick it up again. An example would be every game within the Final Fantasy series.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上瘾当然是很棒的，如果你提供一个免费游戏，并希望通过游戏内广告或重复订阅费用赚钱。另一种方法是使游戏引人入胜，但是有终点。这些是你实际上可以“完成”的游戏。它们通常在游戏的主角和反派之间有一个有趣的故事。当反派被打败时，游戏就结束了，作为玩家，你不太可能再去玩它。一个例子就是《最终幻想》系列中的每个游戏。
- en: Most RPGs apart from **MMORPG**s (**Mass Multiplayer Online Role Playing Game**)
    are in this second category. They often have a fascinating story and mesmerizing
    music. The characters are really interesting and deep. The battle system is very
    intuitive and yet complicated enough for someone to be either good or bad at it.
    The really good ones tend to leave a lasting impression on anyone who played them,
    and they cost a lot of work to put together.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**大型多人在线角色扮演游戏**之外，大多数RPG都属于第二类。它们通常有一个迷人的故事和迷人的音乐。角色非常有趣和深刻。战斗系统非常直观，但足够复杂，以至于有人可以擅长或不擅长。真正优秀的游戏往往会给玩过的人留下深刻的印象，而且需要付出大量的工作才能完成。
- en: This is the standard way of looking at an RPG. However, this should in no way
    hold you back from refreshing the genre and throwing some elements from other
    genres or totally new ideas into the mix. For example, **Borderlands** is a crossbreed
    of an RPG and a shooter. It has level progression and weapon enhancement like
    most RPGs. It has a story and at the same time it still plays like a shooter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是看待RPG的标准方式。然而，这绝不应该阻止你刷新这个类型，并将其他类型的元素或全新的想法融入其中。例如，《无主之地》是RPG和射击游戏的混合体。它具有像大多数RPG那样的等级进展和武器增强。它有一个故事，同时仍然像射击游戏一样玩。
- en: A game does not need to mix up two computer genres. **Minecraft** is essentially
    the pleasure of playing with Lego brought to a computer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏不需要混合两种电脑类型。**我的世界**本质上是在电脑上玩乐高的乐趣。
- en: What it boils down to is finding out for yourself what things you enjoy the
    most or enjoyed greatly as a kid. Find the underlying mechanic at work and try
    to replicate that feeling in a game. This is all easier said than done for sure.
    However, it is necessary to go through this process since it is your time that
    it will take up to build the game, and if it isn't even a game you yourself would
    like to play, why would others want it?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，就是要找出自己最喜欢的或小时候非常喜欢的东西。找出其中的机制，并尝试在游戏中复制那种感觉。这当然比说起来容易得多。然而，有必要经历这个过程，因为建立游戏需要花费你的时间，如果它甚至不是你自己想玩的游戏，为什么别人会想要呢？
- en: For RPGs, it often gets more complicated than simply finding an original gameplay
    component. RPG video games can be a mix between a great book and a movie with
    the merits of interactivity thrown in. If you are a great story teller, or know
    one, why not do it this way? A game does not need to be difficult or graphically
    perfect for people to play. A good example is Final Fantasy VII, which was a big
    hit in the 1990s. In 2012 it was rereleased with "polished graphics". There is
    not much difference; an untrained eye wouldn't immediately notice the polishing.
    But it's still a great game, regardless of the fact that it can't compete with
    the complexity and graphical splendor of games such as Skyrim or Fable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RPG游戏来说，通常会比简单找到原创的游戏组件更加复杂。RPG视频游戏可以是一本好书和一部电影的结合，同时具有互动性的优点。如果你是一个很好的故事讲述者，或者认识一个，为什么不这样做呢？游戏并不需要难以或者图形完美才能吸引人们玩。一个很好的例子是《最终幻想VII》，它在1990年代大获成功。2012年，它以“优化图形”的形式重新发行。实际上并没有太大的区别；一个不经训练的眼睛不会立即注意到这种优化。但它仍然是一款很棒的游戏，尽管它无法与《上古卷轴》或《寓言》等游戏的复杂性和图形辉煌相竞争。
- en: 'This is what you should be aiming at: take the *core pleasure* you want your
    game to have, package it with as little complexity as you possibly can, and add
    happy, pastel-colored graphics. Happy graphics are great. No, seriously, if you
    want your game to radiate darkness and fear, that''s fine too, but otherwise,
    certainly consider smiling clouds and crazy looking animals.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你应该追求的目标：以尽可能少的复杂性打包你想要的*核心乐趣*，并添加快乐、柔和的图形。快乐的图形很棒。不，说真的，如果你想让你的游戏散发出黑暗和恐惧，那也可以，但除此之外，一定要考虑一些微笑的云和疯狂的动物。
- en: Building an RPG level
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个RPG关卡
- en: 'Now it is time to put our own little RPG together. We will start our journey
    with a clean slate. Following are the steps to build an RPG level:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始组建我们自己的小型RPG了。我们将从零开始我们的旅程。以下是构建RPG关卡的步骤：
- en: Let's take a copy of the freshly installed `ImpactJS` folder that we kept in
    the `chapter 1` folder and rename it to `RPG`. Copy the `media` folder from the
    `chapter 3` folder to your `RPG/media` folder. This way at least we have some
    graphics to work with.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制我们在`第1章`文件夹中保留的新安装的`ImpactJS`文件夹，并将其重命名为`RPG`。将`第3章`文件夹中的`media`文件夹复制到你的`RPG/media`文件夹中。这样至少我们有一些图形可以使用。
- en: Go back to the **it works!** screen you get when you enter `localhost/RPG` in
    your browser.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到当你在浏览器中输入`localhost/RPG`时得到的**它起作用了！**屏幕。
- en: Let's start by opening the Weltmeister (`localhost/Weltmeister.html`) and drawing
    a small level.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开Weltmeister（`localhost/Weltmeister.html`）并绘制一个小关卡开始。
- en: You will notice that there is nothing prepared for you this time around. The
    only available layer is the `entities` layer and it doesn't even contain a single
    entity. However, we can draw ourselves a small playing field to get started once
    we have something to populate the world.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次你会注意到没有为你准备好任何东西。唯一可用的层是`entities`层，甚至连一个实体都没有。然而，一旦我们有了一些东西来填充世界，我们就可以画一个小的游戏场地来开始。
- en: So let's add another layer (*+-*sign) and call it `grass`. Let's set the tile
    size to `16` and have a 30 x 20 zone at a distance of 1 pixel. Select the tileset
    `grass.png` and click on the **Apply Changes** button before you can start laying
    down the grass.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以让我们添加另一个层（*+-*符号）并将其命名为`grass`。让我们将瓷砖大小设置为`16`，并在距离1像素处有一个30 x 20的区域。选择瓷砖集`grass.png`，然后点击**应用更改**按钮，然后你就可以开始铺设草坪了。
- en: If you don't have your drawbox centered just right for you, hold the *Ctrl*
    key and move your mouse until it is centered. If for some reason it is too big
    to fit on your screen, zoom out with your mouse scroll wheel.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的绘图框没有完全居中，按住*Ctrl*键并移动鼠标直到它居中。如果由于某种原因它太大而无法适应你的屏幕，可以用鼠标滚轮缩小。
- en: Once we have painted this entire layer in green, we can easily add another one
    to sit on top of the grass. But before you do so, save your file as `level1`.
    Saving often is a virtue.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们把整个层都涂成绿色，我们就可以轻松地添加另一个层放在草坪上。但在这样做之前，将你的文件保存为`level1`。经常保存是一种美德。
- en: When adding layers you can name and use them by what they are supposed to represent.
    For instance, you have a layer for furniture, plants, and miscellaneous objects.
    This is a decent way of working, but you have to keep in mind that some layers
    will visually come in front of your player and monster entities, while others
    will appear behind them. Even something as simple as a single wall is best drawn
    with two layers.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加层时，你可以根据它们应该代表的内容进行命名和使用。例如，你可以有一个家具、植物和杂项物品的层。这是一个不错的工作方式，但你必须记住，一些层在视觉上会出现在你的玩家和怪物实体的前面，而其他层则会出现在它们的后面。即使是一个简单的墙最好也用两层来绘制。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Weltmeister does not support an endless number of layers. In order to keep
    the number of layers respectable, you can have tilesets for specific levels. For
    instance, you have two level settings: a city and a dungeon. Both can contain
    a chair, so don''t be afraid to have the same chair on a tileset for your city
    and on a different tileset to construct your dungeon. Duplicating information
    will increase your overall game size but can decrease the number of layers necessary
    for a single level.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Weltmeister不支持无限数量的层。为了保持层的数量可观，你可以为特定的关卡设置瓷砖集。例如，你有两个关卡设置：城市和地牢。两者都可以包含一把椅子，所以不要害怕在城市的瓷砖集上放置相同的椅子，也在不同的瓷砖集上构建你的地牢。重复信息会增加你的整体游戏大小，但可以减少单个关卡所需的层数。
- en: Our grass is just called `grass` because we won't have grass that will float
    in front of our player; consequently we don't require a second grass layer. Let's
    make two new layers called `vegetation_back` and `vegetation_front`. `vegetation_back`
    must be positioned underneath the `entities` layer in the layer selection menu.
    `vegetation_front` must be put above the `entities` layer. Together these two
    new layers will make up all the vegetation on the map.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的草地只叫`grass`，因为我们不会有草地漂浮在玩家面前；因此我们不需要第二层草地。让我们创建两个新图层，分别叫做`vegetation_back`和`vegetation_front`。`vegetation_back`必须在图层选择菜单中的`entities`图层下面。`vegetation_front`必须放在`entities`图层上面。这两个新图层一起将构成地图上的所有植被。
- en: Select the tileset `tree.png` and use the same settings for the `grass` layer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 选择图块集`tree.png`，并为`grass`图层使用相同的设置。
- en: 'Draw the upper part of a tree with the `vegetation_front` layer and the lower
    part with `vegetation_back`. The following screenshot shows the different layers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vegetation_front`图层绘制树的上部，使用`vegetation_back`绘制下部。以下屏幕截图显示了不同的图层：
- en: '![Building an RPG level](img/4568_3_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Building an RPG level](img/4568_3_1.jpg)'
- en: 'The following are the layers you should currently have in your Weltmeister
    **Layers** menu:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Weltmeister **Layers**菜单中应该有以下图层：
- en: '![Building an RPG level](img/4568_3_2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Building an RPG level](img/4568_3_2.jpg)'
- en: If you have no idea what the upper part or lower part of anything should be,
    think about how big your player and/or enemies will be. When walking past the
    tree, their heads or feet should not disappear. In order to avoid the player walking
    through the tree altogether, we will need another layer, the collision layer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道任何东西的上部或下部应该是什么，想想你的玩家和/或敌人有多大。当走过树时，他们的头或脚不应该消失。为了避免玩家完全穿过树，我们需要另一个图层，碰撞图层。
- en: Add a layer with the name `collision` to the Weltmeister.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Weltmeister中添加一个名为`collision`的图层。
- en: Don't forget, you can make a layer visible in Weltmeister by either dragging
    it to the top of the layer stack or switching off the layers that are blocking
    the view. In this case, the `grass` layer will probably block all the view if
    the collision layer is at the bottom of the stack. It's pretty efficient to drag
    the `collision` layer to the top and just turn it on and off when necessary. Settings
    for setting up the layer are the same as always.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，你可以通过将图层拖到图层堆栈的顶部或关闭挡住视野的图层来在Weltmeister中使图层可见。在这种情况下，如果碰撞图层在堆栈的底部，`grass`图层可能会挡住所有的视野。将`collision`图层拖到顶部并在必要时打开和关闭它是非常有效的。设置图层的设置与以往一样。
- en: 'With the `collision` layer, draw a border around the level so no one can escape.
    Also put some collision squares in the tree trunk just underneath or above the
    dividing line between the front and back layers, as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`collision`图层，在关卡周围绘制边界，这样就没有人可以逃跑了。还在树干下面或上面的分界线附近放一些碰撞方块，如下图所示：
- en: '![Building an RPG level](img/4568_3_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Building an RPG level](img/4568_3_3.jpg)'
- en: 'So we created a viable environment. It''s not much but it''s a start. However,
    for the level to load, we need to make changes to our `main.js` script as shown
    in the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们创建了一个可行的环境。虽然不多，但这是一个开始。然而，为了加载关卡，我们需要对我们的`main.js`脚本进行更改，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to make sure our game finds the level, we need to include it in the
    `.requires` part of our module. We need to point to it in the same way as we would
    to any file, starting from our game root folder. The only difference is that slashes
    (`/`) are replaced by dots (`.`) and the included file itself is always considered
    to have the `.js` extension. For example, `/game/levels/level1.js` becomes `game.levels.level1`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的游戏能找到关卡，我们需要在模块的`.requires`部分包含它。我们需要以与任何文件相同的方式指向它，从我们的游戏根文件夹开始。唯一的区别是斜杠(`/`)被点(`.`)替换，而包含的文件本身总是被认为有`.js`扩展名。例如，`/game/levels/level1.js`变成了`game.levels.level1`。
- en: 'We also need to load the level at game startup, so let''s add a `loadlevel()`
    method to the `init()` function. Don''t forget that the parameter to call this
    function always has the following form:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在游戏启动时加载关卡，所以让我们在`init()`函数中添加一个`loadlevel()`方法。不要忘记，调用这个函数的参数总是以下形式：
- en: '`Level + Levelname` in capital letters. Anything else will crash the game.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大写字母的`Level + Levelname`。其他任何形式都会导致游戏崩溃。
- en: 'We now have a loaded level but there is nothing interactive about it; we have
    no player yet. And although having **it works!** on the screen at all times is
    quite motivating, it''s also mildly blocking our vision. So let''s delete the
    following code from `main.js` and move on to our `player` entity using the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个加载的关卡，但它没有任何交互性；我们还没有玩家。尽管在屏幕上始终显示**it works!**相当激励，但也会轻微地阻碍我们的视野。所以让我们从`main.js`中删除以下代码，然后继续使用以下代码来创建我们的`player`实体：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: We need to start building our game from scratch in this chapter. Therefore we
    need the originally downloaded ImpactJS files. Put them in a separate folder in
    your server working directory. Also test whether you get the **it works!** message.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从头开始构建我们的游戏。因此，我们需要最初下载的ImpactJS文件。将它们放在服务器工作目录的一个单独文件夹中。还要测试一下是否收到了**it
    works!**消息。
- en: Add the `chapter 3` folder's `media` files to the folder you just set up.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chapter 3`文件夹的`media`文件添加到你刚刚设置的文件夹中。
- en: Open the Weltmeister level editor and make a layered level. You need a collision
    layer, an entities layer, and three graphical layers. The bottom graphical layer
    will represent the grass. The other two layers represent all other objects that
    will show up in front of or behind the player.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Weltmeister关卡编辑器并创建一个分层关卡。你需要一个碰撞图层，一个实体图层和三个图形图层。底部的图形图层将代表草地。其他两个图层代表所有其他在玩家前面或后面出现的对象。
- en: Draw the graphical layers.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制图形图层。
- en: Include the level file in your `main` script.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`脚本中包含关卡文件。
- en: Delete the `it works!` message from the `main` script.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`main`脚本中删除`it works!`消息。
- en: Adding a playable character
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加可玩角色
- en: In order to build our player from scratch we need a new (and empty) `.js` file.
    Create a new file in your code editor and even though it's empty, save it as `player.js`
    in the `entities` folder.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从头开始构建我们的玩家，我们需要一个新的（并且是空的）`.js`文件。在你的代码编辑器中创建一个新文件，即使它是空的，也将其保存为`entities`文件夹中的`player.js`。
- en: 'Every module starts out in the same way. It consists of the `ig.module()` ,
    `ig.requires()`, and `ig.defines()` methods. For some modules you will not need
    the `requires()` method but all entities will, because here you need to include
    the `impact` script for entities, as shown in the following code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都是以相同的方式开始的。它由`ig.module()`，`ig.requires()`和`ig.defines()`方法组成。对于一些模块，你不需要`requires()`方法，但所有实体都需要，因为在这里你需要包含实体的`impact`脚本，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are going to build the player based on the `prototype` entity. This prototype
    has several attributes (such as `health` and `velocity`) and several methods (such
    as `kill()` and `receiveDamage()`) predefined. This way we only need to extend
    the original version with the `extend()` method in order to create our player.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据`prototype`实体构建玩家。这个原型有几个属性（比如`health`和`velocity`）和几个方法（比如`kill()`和`receiveDamage()`）预定义。这样我们只需要用`extend()`方法扩展原始版本，就可以创建我们的玩家了。
- en: There are some rules here. If your JavaScript file is called `player.js`, your
    entity will be called `Player`. You assign it to an extension of the `entity`
    prototype by adding `Entity` in front of its name, as shown in the previous code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些规则。如果你的JavaScript文件叫做`player.js`，你的实体将被称为`Player`。你可以通过在其名称前面添加`Entity`，将其分配给`entity`原型的扩展，如前面的代码所示。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Any deviation from the naming conventions will remove the entity from the Weltmeister
    **Entities** menu. Adding an entity to the Weltmeister editor when it is correctly
    named, and loading the game with faulty naming will result in a crash.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何与命名约定的偏离都将从Weltmeister **Entities**菜单中移除实体。将实体添加到Weltmeister编辑器时，如果命名正确，加载游戏时命名错误将导致崩溃。
- en: 'Also don''t forget to include the `player` entity in the `requires()` method
    within `main.js`. A module can only be used when the `main` module knows about
    its existence. The following code shows that the extension `.player` is assigned
    to the `entities` folder:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要忘记在`main.js`中的`requires()`方法中包含`player`实体。只有当`main`模块知道其存在时，模块才能被使用。以下代码显示了扩展`.player`被分配给`entities`文件夹：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you add the `player` entity to the game with the Weltmeister right now,
    you would notice that there is nothing to see. The player has no visual representation
    yet, we address this issue in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在用Weltmeister添加`player`实体到游戏中，你会注意到什么也看不到。玩家还没有视觉表示，我们将在下面的代码中解决这个问题：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to get a glimpse of our playable character, we need to add an animation
    sheet, which is located in our `media` folder. The animation sheet needs to be
    assigned with the right dimensions if you don't want to see just pieces of your
    characters walk about. We also gave the entity a size. The animation can actually
    be bigger than the size of an entity. If you do not set a size, you will see that
    you can select the `player` entity in Weltmeister, but its boundaries do not encompass
    the entire image. This is because the default size is 16 x 16\. Size is a relevant
    property for collision detection. We also gave the player some health to get started.
    The default health is 10.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到我们可玩角色的一瞥，我们需要添加一个动画表，它位于我们的`media`文件夹中。如果你不想看到你的角色只是走来走去的话，动画表需要被分配正确的尺寸。我们还给实体分配了一个大小。动画实际上可以比实体的大小大。如果你不设置大小，你会发现你可以在Weltmeister中选择`player`实体，但它的边界并不包含整个图像。这是因为默认大小是16
    x 16。大小是碰撞检测的相关属性。我们还给玩家一些生命值来开始。默认生命值是10。
- en: We are also confronted with the `entity` prototype's `init()` method. The `entity`
    prototype already has its own `init()` function, so it's best to include this
    by calling the `parent()` method within the `init()` function. Having an animation
    sheet defined does not make the entity animated. You need to assign an action
    to the animation sheet. Here, *idling* corresponds to the first image on the sheet.
    You can now safely add your player to the map.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还面临着`entity`原型的`init()`方法。`entity`原型已经有了自己的`init()`函数，所以最好通过在`init()`函数中调用`parent()`方法来包含它。定义动画表并不会使实体动画化。你需要为动画表分配一个动作。在这里，*空闲*对应于表上的第一张图片。现在你可以安全地将你的玩家添加到地图上了。
- en: Great, we have a player in our game! Too bad it doesn't move. Let's work on
    that right now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们的游戏中有了一个玩家！太糟糕了，它还不能移动。让我们现在来解决这个问题。
- en: 'In the `main.js` script you are to add the following to your `init()` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`脚本中，你需要在你的`init()`方法中添加以下内容：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will make sure your arrow keys are bound to an *input state*. From now
    on the game will check automatically whether any of these keys are pressed. Since
    we are building a top-down game here, we need to be able to walk in any direction.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保你的箭头键绑定到一个*输入状态*。从现在开始，游戏将自动检查这些键中是否有任何一个被按下。由于我们在这里正在构建一个俯视游戏，我们需要能够朝任何方向行走。
- en: 'In the `player.js` script, four new animation sequences will need to be added
    to the `init()` function as shown in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`player.js`脚本中，需要在`init()`函数中添加四个新的动画序列，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While the animation sequence of `idle` was composed of one image, we now need
    to assign a true sequence for every direction in which our player can walk. Again,
    the `0.1` value is the time in between images.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`idle`的动画序列由一张图片组成，但现在我们需要为玩家可以行走的每个方向分配一个真正的序列。同样，`0.1`值是图像之间的时间。
- en: In addition, you will need to call and extend the `entity` prototype's `update()`
    function. Don't forget to have a comma to separate the `init()` and `update()`
    functions or you will get an error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要调用和扩展`entity`原型的`update()`函数。不要忘记在`init()`和`update()`函数之间加上逗号，否则会出错。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `update()` function, like `init()`, is a standard method of the prototype
    `entity`. Therefore we need to call the parent function if we don't want to lose
    its ImpactJS entity core functionalities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`函数和`init()`一样，是原型`entity`的标准方法。因此，如果我们不想失去其ImpactJS实体核心功能，我们需要调用父函数。'
- en: For every input state we need separate behavior, so we have this set of *if-then
    operators*. Remember that since we put this code in the `update()` function, it
    is run every time the game goes through an update loop, which is once per frame.
    The `init()` function is only called once, that is, at the moment of player creation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个输入状态，我们需要单独的行为，因此我们有这组*if-then操作符*。请记住，由于我们将这段代码放在`update()`函数中，它会在游戏每次更新循环时运行，即每帧一次。`init()`函数只会被调用一次，也就是在玩家创建的时候。
- en: 'Within the condition checks, we do two things: allocate a speed on the relevant
    axis and add an animation. If the player does nothing, the velocity in both directions
    is also set to `0`, so continuous input is required for the player to move.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件检查中，我们做了两件事：在相关轴上分配速度并添加动画。如果玩家什么也不做，那么两个方向上的速度也被设置为`0`，因此玩家需要持续输入才能移动。
- en: Instead of `ig.input.state` we could use `ig.input.pressed` . But that would
    result in our player having to button mash his way through the level. For, every
    time he or she presses one of the move buttons, the player would only move a small
    bit and stop immediately. In case of 60 fps and a velocity of 100, the player
    would move 100/60 = 1.67 pixels for one touch. Although `ig.input.pressed` certainly
    has its merits, moving in this way might annoy even the most patient of gamers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ig.input.pressed`而不是`ig.input.state`。但这将导致我们的玩家不得不通过按钮来穿过关卡。因为每次他或她按下移动按钮时，玩家只会移动一小段距离然后立即停下。在60
    fps和速度为100的情况下，玩家每次触摸只会移动100/60 = 1.67像素。尽管`ig.input.pressed`当然有其优点，但以这种方式移动可能会让即使是最有耐心的玩家也感到恼火。
- en: 'We finally have a playable character that moves around gracefully! It can even
    hide behind the tree we created earlier. We still have another problem on our
    hands though, we can''t see our player at all times. Can you imagine the frustration
    of a player getting killed by something because he couldn''t see where he was
    going? I''m sure you can and it has probably even happened to you if you have
    played some games in the past. However, we are in luck because a camera that follows
    the player around is easy to implement, as shown in the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于有了一个优雅移动的可玩角色！它甚至可以躲在我们之前创建的树后面。不过我们手头还有另一个问题，我们不能始终看到我们的玩家。你能想象一个玩家因为看不到自己的位置而被杀死的沮丧吗？我相信你可以，而且如果你过去玩过一些游戏，这种情况可能甚至发生过。不过，我们很幸运，因为一个跟随玩家四处走动的摄像头很容易实现，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding code, two important elements and the player
    are assigned to a local variable. Then the viewport coordinates are set to the
    player's position. If you wanted your camera to put the player in the top-left
    corner of the screen, you wouldn't need your game canvas. But of course, we want
    the player centered, so we adjust its position by half the size of the canvas
    in both dimensions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，两个重要的元素和玩家被分配给了一个本地变量。然后，视口坐标被设置为玩家的位置。如果您希望相机将玩家放在屏幕的左上角，您就不需要游戏画布。但当然，我们希望玩家居中，所以我们通过画布尺寸的一半来调整其位置。
- en: On reloading the browser, you will notice that you can finally walk to the bottom
    of your screen and underneath the tree. Great! Just too bad that there is nothing
    to do here, so next we will introduce something hostile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载浏览器后，您会注意到您终于可以走到屏幕底部和树下面。太好了！只是可惜这里没有什么可做的，所以下一步我们将引入一些敌对的东西。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `player.js`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`player.js`。
- en: Set up the `player.js` script with the standard ImpactJS module code.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的ImpactJS模块代码设置`player.js`脚本。
- en: Include `player.js` in your `main` script.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`脚本中包含`player.js`。
- en: Add an animation sheet and sequence to your playable character so that it can
    be found in the Weltmeister. Also provide him with health and a size.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为可玩角色添加动画表和序列，以便在Weltmeister中找到它。还为其提供健康和大小。
- en: Add player controls by binding keyboard keys to input states in the `main` script.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将键盘键绑定到`main`脚本中的输入状态来添加玩家控制。
- en: Bind these input states to move the character's action by manipulating its velocity.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些输入状态绑定到移动角色动作，通过操纵其速度。
- en: Make the movement appear as a smooth animation by introducing extra animation
    sequences and calling them when certain input states are active.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过引入额外的动画序列并在某些输入状态激活时调用它们，使移动看起来像是平滑的动画。
- en: Put in a camera that automatically follows the player around wherever he ventures.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置一个自动跟随玩家四处走动的摄像头。
- en: Introducing a defeatable opponent
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入一个可击败的对手
- en: Again, we will have to start from scratch, so open up a blank JavaScript file
    and save it as `enemy.js`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将不得不从头开始，因此打开一个空的JavaScript文件，并将其保存为`enemy.js`。
- en: The start of entity creation is always the same. Set up your `Entity` file and
    add an `enemy` entity to your `main` script.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实体创建的开始总是相同的。设置您的`Entity`文件并将`enemy`实体添加到您的`main`脚本中。
- en: 'In `main.js.requires` add the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js.requires`中添加以下代码：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `enemy.js` add the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`enemy.js`中添加以下代码：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Adding the previous code snippets creates our entity, which we can add to the
    level by use of the Weltmeister. However, it''s still pretty useless so let''s
    first add some graphics using the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 添加前面的代码片段创建了我们的实体，我们可以通过Weltmeister将其添加到关卡中。不过它还是相当无用的，所以让我们首先使用以下代码添加一些图形：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we can add our first enemy to the level. It won't do much though, and you
    will even be able to walk right through him as if he isn't there. This is because
    no collision between entities has been specified yet.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的第一个敌人添加到关卡中。不过它不会做太多事情，甚至你甚至可以穿过他走。这是因为实体之间还没有指定碰撞。
- en: Add the following code to the `player` and `enemy` entity as a property. You
    can add them in the `init()` function with the old JavaScript notation or above
    `init()` in literal notation, as shown in the following code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`player`和`enemy`实体作为属性。您可以使用旧的JavaScript表示法在`init()`函数中添加它们，或者在文字表示法中在`init()`上方添加，如下面的代码所示。
- en: 'The following code is for the player:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于玩家的：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code is for the enemy `entity`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于敌人`entity`的：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now push our enemy around the level like a real bully. You might have
    noticed that there is still some space in between the player and the enemy. This
    is because the boundaries of the entities are rectangles, which more than encompass
    the actual drawings. It''s pretty annoying for a player to get hit by an enemy
    when visually it''s not the case. To rectify the situation we need to introduce
    `offset` as a player property. The `size` property determines the size of the
    collision box around the entity. The `offset` property makes your collision box
    shift a few pixels to the right or down. Of course, you can enter a negative number
    at a point at which it will shift left and/or upward. We will need to combine
    these two properties to make a new collision box for the player, which makes him
    harder to hit. However, before proceeding it''s useful to turn on the ImpactJS
    debugger by adding the following line of code to the `main.js` script in the `requires()`
    method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像真正的恶霸一样推动我们的敌人在关卡中四处走动。您可能已经注意到玩家和敌人之间仍然有一些空间。这是因为实体的边界是矩形，远远超出了实际的绘图范围。当视觉上并非如此时，玩家被敌人击中是非常恼人的。为了纠正这种情况，我们需要将`offset`引入为玩家属性。`size`属性确定了实体周围的碰撞框的大小。`offset`属性使您的碰撞框向右或向下移动几个像素。当然，您可以在一个点输入一个负数，它将向左和/或向上移动。我们需要结合这两个属性来为玩家制作一个新的碰撞框，使他更难被击中。但是，在继续之前，通过在`main.js`脚本的`requires()`方法中添加以下代码行来打开ImpactJS调试器是有用的：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s a good habit to have this debugger switched on during development. You
    can delete this code again when preparing it for release. Let''s change the size
    and offset for both player and enemy using the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中保持调试器打开是一个好习惯。当准备发布时，您可以再次删除此代码。让我们使用以下代码更改玩家和敌人的大小和偏移：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The actual image size is 32 x 48\. We changed the size of both entities to
    `18` x `40` with an offset of `7` x `4`. If you open the debugger on the **Entities**
    tab and turn on **Show Collision Boxes**, you will notice the difference in size.
    You might also notice static collision, such as the squares of the collision layer
    that we added to the middle of the tree are not visible because it only shows
    collision for entities, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际图像大小为32 x 48。我们将两个实体的大小都改为`18` x `40`，偏移为`7` x `4`。如果您在**Entities**选项卡上打开调试器并打开**显示碰撞框**，您会注意到大小的差异。您还可能注意到静态碰撞，例如我们添加到树中间的碰撞层的正方形不可见，因为它只显示实体的碰撞，如下面的截图所示：
- en: '![Introducing a defeatable opponent](img/4568_3_4.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![引入一个可战胜的对手](img/4568_3_4.jpg)'
- en: There is no perfect rule for setting collision boxes. It all depends on how
    well centered and symmetrical your image is, how lenient you are when it comes
    to collision, and the difference in image size between the frontal and profile
    look. Here we chose to reduce our width by 14 pixels (32 - 18). In order to keep
    the box centered, the offset was set to half the difference ((32 - 18) / 2 = 7).
    The same reasoning applies to the y axis.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 没有设置碰撞框的完美规则。这完全取决于您的图像有多好地居中和对称，当涉及到碰撞时您有多宽容，以及前视和侧视之间的图像大小差异。在这里，我们选择将我们的宽度减小14像素（32-18）。为了保持框居中，偏移设置为差值的一半（（32-18）/2
    = 7）。相同的推理适用于y轴。
- en: Now we have an enemy. Let's kill it!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个敌人。让我们杀了它！
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `enemy.js`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件并将其保存为`enemy.js`。
- en: Set up the `enemy.js` script with the standard ImpactJS module code.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的ImpactJS模块代码设置`enemy.js`脚本。
- en: Include `enemy.js` in your `main` script.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`main`脚本中包含`enemy.js`。
- en: Add an animation sheet and several animation sequences, taking into account
    every direction in which your enemy might walk.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个动画表和几个动画序列，考虑到敌人可能行走的每个方向。
- en: Change both the player's and the enemy's `collisions` entities. They need to
    be able to detect each other's presence so the enemy can later on damage the player.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改玩家和敌人的`碰撞`实体。它们需要能够检测到彼此的存在，以便敌人以后可以伤害玩家。
- en: If you haven't already done this, turn on the ImpactJS debugger by including
    it in your `main` script. The aim is to see the entity's collision boxes.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请通过在您的`main`脚本中包含它来打开ImpactJS调试器。目的是看到实体的碰撞框。
- en: Giving the player some weapons
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给玩家一些武器
- en: 'We do like our player to be armed and ready for some action. Let''s first add
    a new key that will be used to attack. In `main.js` add the following key bind:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢我们的玩家武装起来，准备行动。让我们首先添加一个新的按键用于攻击。在`main.js`中添加以下键绑定：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In any combat situation it is the collision of two bodies that causes damage.
    If an arrow hits the mark, it''s the arrow that damages, not the bow. The same
    is true for a nuclear missile. It''s not the launch facility but the blast wave
    of the nuke that collides with whatever happens to be in the way which does the
    damage. In this respect you could say there are three entities at work here: a
    launch facility, a nuke, and its blast wave. You could even add another one if
    you want to make a difference between air pressure and actual conflagration. All
    of this is just to show how you should think when adding weapons to a game. Which
    impact is relevant? In case of a chicken and a chicken launcher, the chicken will
    become an entity while the launcher is a mere drawing.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何战斗情况下，造成伤害的是两个物体的碰撞。如果箭射中目标，造成伤害的是箭，而不是弓。同样的道理适用于核导弹。造成伤害的不是发射设施，而是核弹的爆炸冲击波与任何阻挡在其路径上的物体的碰撞。在这方面，我们可以说这里有三个实体在起作用：发射设施、核弹和其爆炸冲击波。如果你想区分空气压力和实际的大火，甚至可以再添加一个实体。所有这些只是为了展示在向游戏中添加武器时应该如何思考。哪种影响是相关的？在鸡和鸡发射器的情况下，鸡将成为一个实体，而发射器只是一个简单的绘图。
- en: Spawning a projectile
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成一个projectile
- en: For our ranged attack we need a new entity, which we will call `projectile`.
    Make a new script, set up the basics, save it as `projectile.js`, and include
    it in `main.js`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的远程攻击，我们需要一个新的实体，我们将其称为`projectile`。创建一个新的脚本，设置基础，将其保存为`projectile.js`，并在`main.js`中包含它。
- en: 'Include the following code in `main.js`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`中包含以下代码：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Include the following code in `projectile.js`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`projectile.js`中包含以下代码：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ok, the basics don''t seem to be that basic after all. This time around, we
    have two different animation sheets. An arrow tends to be quite a bit longer than
    it is wide. Therefore if the arrow is shot from left to right (or right to left),
    its dimensions differ from an arrow shot up or downwards. When defining an animation
    sheet, we have to define the dimensions that every image will take only once.
    However, in this case we need two different dimensions: `8` x `4` and `4` x `8`.
    Actually in this particular case there is another, probably easier, solution involving
    the angle of the animation. In programming languages there often are different
    ways to get the same or a similar result. However, now we will use multiple animation
    sheets.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，基础看起来似乎并不那么基础。这一次，我们有两个不同的动画表。箭往往比宽度长得多。因此，如果箭从左到右（或从右到左）射出，其尺寸与从上到下射出的箭不同。在定义动画表时，我们只需要一次定义每个图像的尺寸。然而，在这种情况下，我们需要两种不同的尺寸：`8`
    x `4`和`4` x `8`。实际上，在这种特殊情况下，还有另一种可能更简单的解决方案，涉及动画的角度。在编程语言中，通常有不同的方法来获得相同或类似的结果。然而，现在我们将使用多个动画表。
- en: We define two different animation sheets. Instead of initiating them on the
    standard `animSheet` property, we named them `animSheetX` and `animSheetY` to
    indicate the different axes. The `init()` function does not call the `addAnim()`
    method as in the `Player` and `Enemy` entities because it is programmed to take
    the `animSheet` property by default. Instead we directly address `ig.animation`
    to which we can pass our own animation sheets. It's nice to have an image in case
    you would like to add an arrow in Weltmeister, so the `currentAnim` property is
    given the x axis animation sequence as a default.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两种不同的动画表。我们将它们命名为`animSheetX`和`animSheetY`，而不是在标准的`animSheet`属性上初始化它们，以表示不同的轴。`init()`函数不像`Player`和`Enemy`实体那样调用`addAnim()`方法，因为它是按默认设置为`animSheet`属性。相反，我们直接调用`ig.animation`，可以传递我们自己的动画表。如果您想在Weltmeister中添加一个箭头，那么`currentAnim`属性将默认给出x轴动画序列。
- en: 'Now we just need to make the player spawn the arrow. Therefore we need to add
    the following to the player''s `update()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要让玩家生成箭。因此，我们需要在玩家的`update()`函数中添加以下内容：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The arrow will be spawned at the player's location.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 箭将在玩家的位置生成。
- en: 'In case you run the game at this point, the arrow can only fly in one direction:
    to the right. This is because our default velocity was set at `100` pixels per
    second to the right. Also our animation default is an arrow pointed rightwards.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上运行游戏时，箭只能朝一个方向飞行：向右。这是因为我们的默认速度设置为每秒`100`像素向右。而且我们的默认动画是箭头向右。
- en: 'That''s not entirely what we want. Our enemies would at all times have to be
    on our right side in order for us to kill them. So let''s modify the projectile
    code by adding the following code to the `init()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全是我们想要的。我们的敌人必须始终在我们的右侧，我们才能杀死他们。因此，让我们通过在`init()`函数中添加以下代码来修改projectile代码：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add `velocity` as a property as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码显示`velocity`作为一个属性：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What happens now is if the direction of the arrow is right, left, up, or down,
    it will adjust its speed and animation accordingly. There are only two images
    at play here, an arrow pointed upward and one pointed to the right, each in its
    separate animation sheet. We could add one extra image to each sheet, one downward
    pointing arrow, and one aiming to the left. This would be a viable solution but
    here we choose to use the flip property instead. Flip basically makes a mirror
    image of the animation, making the arrow point to the exact opposite direction.
    When using flip, you must make sure it actually makes sense to flip an image instead
    of using a separate one. For instance, if you have a character running from left
    to right and you want to make it run from right to left, flip is pretty ok to
    use. For characters running towards or away from you, this doesn't really work
    since you expect to either see their front or their back.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发生的是，如果箭头的方向是右、左、上或下，它将相应地调整其速度和动画。这里只有两个图像在起作用，一个箭头指向上方，一个指向右边，每个都在其单独的动画表中。我们可以向每个表中添加一个额外的图像，一个指向下的箭头，一个指向左边。这将是一个可行的解决方案，但在这里我们选择使用翻转属性。翻转基本上是制作动画的镜像图像，使箭头指向完全相反的方向。在使用翻转时，您必须确保翻转图像而不是使用单独的图像是有意义的。例如，如果您有一个从左到右奔跑的角色，并且希望使其从右到左奔跑，使用翻转是可以接受的。对于朝向您或远离您奔跑的角色，这并不起作用，因为您期望看到他们的正面或背面。
- en: This is all very nice but where does it get its *direction* from? Let's initiate
    the direction with a default value and then modify the player so it can pass on
    its own direction to the projectile.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但它的*方向*从哪里得到呢？让我们用默认值初始化方向，然后修改玩家，使其可以将自己的方向传递给抛射物。
- en: 'Add the following code to `projectile.js`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`projectile.js`：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Perform the following for `player.js`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对`player.js`执行以下操作：
- en: 'For every direction, add a variable called `lastpressed` with the same value
    as the input state, as shown in the following code snippet, for going to the right:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个方向，添加一个名为`lastpressed`的变量，其值与输入状态相同，如下面的代码片段所示，用于向右移动：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Make the `spawnEntity` method pass the direction parameter using the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码使`spawnEntity`方法传递方向参数：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Great! We now have our hero shooting arrows in every direction like a boss.
    At the moment, our arrows are still pretty indestructible and are quite harmless
    to our lucky foe. They just hit the edge of our level and stay there forever or
    until the game gets reloaded.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在的英雄可以像老板一样朝各个方向射箭。目前，我们的箭头仍然相当坚固，对我们幸运的敌人来说相当无害。它们只是击中我们关卡的边缘，永远停留在那里，或者直到游戏重新加载。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `projectile.js`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`projectile.js`。
- en: Set up the `projectile.js` script. Give it two animation sheets.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`projectile.js`脚本。给它两个动画表。
- en: Add the `projectile` script to the `main` script.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`projectile`脚本添加到`main`脚本中。
- en: Change the player's `update` function so the player can spawn a projectile when
    the `attack` input state is activated.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改玩家的`update`函数，以便玩家在激活`attack`输入状态时可以生成一个抛射物。
- en: Adapt the projectile's direction and animation depending on which direction
    the player is facing when firing.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据玩家射击时面对的方向，调整抛射物的方向和动画。
- en: 'Make sure the direction of the player is transferred to the `projectile` script
    when spawning it. This is done by filling out the optional parameter of the standard
    ImpactJS entity: the `spawn` function.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在生成时将玩家的方向传递给`projectile`脚本。这是通过填写标准ImpactJS实体的可选参数：`spawn`函数来完成的。
- en: Causing harm with a projectile
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用抛射物造成伤害
- en: 'We can make the arrow disappear when hitting an enemy or when in the air for
    some time using the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码使箭头在击中敌人或在空中一段时间后消失：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Initiating a new property called `lifetime` at `0` and adding a counter with
    the `kill()` function to the `update()` function will make the arrow disappear
    after flying for `100` frames. Again, don't forget to separate the `init()` and
    `update()` functions with a comma (`,`), or the literal notation will not forgive
    you.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0`处初始化一个名为`lifetime`的新属性，并在`update()`函数中使用`kill()`函数添加一个计数器，将使箭头在飞行了`100`帧后消失。再次，不要忘记用逗号（`,`）分隔`init()`和`update()`函数，否则文字表达式不会原谅您。
- en: 'In order to damage the enemy, we will need our arrow to check whether it encountered
    one. We make the arrow a `TYPE A` entity like the `player` entity, and let it
    check for the `TYPE B` entities like the `enemies` entity in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对敌人造成伤害，我们需要让箭头检查它是否遇到了敌人。我们将箭头设置为`TYPE A`实体，就像`player`实体一样，并让它检查`TYPE B`实体，就像以下代码中的`enemies`实体一样：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By adding the `check()` function we can make the arrow check for every entity
    it needs to check for (as set by the `checkAgainst` property). If it encounters
    an entity of type `B`, that entity receives a damage of `100` as shown in the
    following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`check()`函数，我们可以使箭头检查它需要检查的每个实体（由`checkAgainst`属性设置）。如果遇到类型为`B`的实体，该实体将受到`100`的伤害，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we still didn't solve the problem of the arrow camping against the edge
    of the level or any other place where map collision is present. So let's make
    some bouncing arrows! No worries, we made sure they couldn't hurt the player since
    they will only check for entities of type `B` and will fly right through our player.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们仍然没有解决箭头在关卡边缘或任何其他地图碰撞存在的地方露营的问题。所以让我们制作一些反弹的箭头！别担心，我们确保它们不会伤害玩家，因为它们只会检查类型为`B`的实体，并且会直接穿过我们的玩家。
- en: 'First set the `bounciness` to `1`, which means all speed is kept when bouncing
    back, using the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`bounciness`设置为`1`，这意味着在反弹时保持所有速度，使用以下代码：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we only need to check if the speed has inverted (if the arrow has bounced),
    and invert the animation if required. Of course, this needs to be done in the
    `update()` function as shown in the following code snippet since it can happen
    at all times:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要检查速度是否已经反转（如果箭已经反弹），并在必要时反转动画。当然，这需要在`update()`函数中完成，如下面的代码片段所示，因为它可能随时发生：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is a very naive check since it relies on the assumption that the speed
    of the arrow remains the same at all times, even after a bounce. However, for
    the sake of keeping the example simple, it will do.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常天真的检查，因为它依赖于箭的速度在反弹后仍然保持不变的假设。然而，为了保持示例简单，它将起作用。
- en: We didn't even set the `health` value of our enemy and we can already damage
    and kill it. This is because by default the `health` value of an entity is set
    to `10`. Let's change this property so that our enemy can at least survive the
    first hit.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至没有设置敌人的`health`值，我们就已经能够伤害和杀死它了。这是因为默认情况下，实体的`health`值被设置为`10`。让我们更改这个属性，这样我们的敌人至少能够在第一次受到攻击时存活。
- en: 'Make the change as per the following code in `enemy.js`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`enemy.js`中的以下代码进行更改：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our enemy has become harder to kill but it's not as if he's a challenge for
    us yet. It's time to get into some basic **AI** or **Artificial Intelligence**
    of a non-playable character.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的敌人变得更难击败了，但并不是说他对我们构成挑战。是时候开始学习一些基本的**AI**或**人工智能**了。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Add a maximum lifespan to your projectile so it can't remain in the game forever.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目的最大寿命添加到你的抛射物中，这样它就不会永远留在游戏中。
- en: Add entity collision detection so it can collide with an enemy.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加实体碰撞检测，使其能够与敌人碰撞。
- en: Set up the projectile's `check` function so that when the projectile collides
    with an enemy, the projectile is killed and the enemy is damaged.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置抛射物的“检查”功能，使得当抛射物与敌人碰撞时，抛射物被摧毁，敌人受到伤害。
- en: Add `bounciness` so it can bounce off walls.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加“弹性”以便它可以从墙上弹开。
- en: Set the `health` property of your enemy so it does not get hit by the very first
    projectile.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置敌人的`health`属性，使其不会被第一个抛射物击中。
- en: Bringing your NPCs to life with artificial intelligence
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用人工智能让你的NPC活起来
- en: 'Artificial intelligence can be one of the most complicated, if not *the* most
    complicated element of a game. As the name states, AI is artificial or simulated
    intelligence. The entities in your game will need to act and react to the things
    you as a player are doing to them or their environment. When writing AI, you are
    in effect trying to put the human brain or something more powerful, into the computer.
    For strategy games, AI can make or break the gameplay since it is what keeps the
    player engaged when playing skirmish matches offline. For other genres such as
    2D shooters, you might be contented with enemies who do more than just shooting
    at you. The problem with complicated AI is that it needs to take so many parameters
    into account that it can become almost impossible for a single programmer to fathom.
    Let''s make a division in three types:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能可能是游戏中最复杂的元素之一，如果不是*最*复杂的。顾名思义，AI是人工或模拟的智能。游戏中的实体需要对玩家对它们或它们的环境所做的事情做出反应。在编写AI时，实际上是在尝试将人脑或更强大的东西放入计算机中。对于策略游戏，AI可以决定游戏玩法的成败，因为它是在玩离线的小规模比赛时保持玩家参与的因素。对于其他类型的游戏，比如2D射击游戏，你可能会满足于敌人不仅仅只是向你开火。复杂的AI问题在于它需要考虑太多的参数，以至于一个程序员几乎无法理解。让我们将其分为三种类型：
- en: '**Single-strategy AI**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一策略AI**'
- en: '**Multiple-strategy AI**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多策略AI**'
- en: '**Data-driven AI**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据驱动AI**'
- en: '**Strategies** are patterns of behavior that an entity will follow in a specific
    situation. An enemy can charge at you with full ferocity when at full health,
    but retreat and look for a safe place to heal itself when badly injured. This
    is an example of using two different strategies while a *single strategy* enemy
    might just keep on attacking you until it is dead, regardless of its own life.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略**是实体在特定情况下遵循的行为模式。当敌人健康时，它可以全力冲向你，但当受伤严重时，它会撤退并寻找一个安全的地方来治疗自己。这是使用两种不同策略的一个例子，而*单一策略*的敌人可能会一直攻击你，直到它死掉，不管自己的生命如何。'
- en: '*Data driven AI* is something else altogether. It is not hardcoded behavior
    but requires tons of player data, which gets uploaded to a single location. There
    the data is processed and statistical procedures such as regressions, decision
    tree modeling, and neural networks are applied to make the AI more competent in
    the future. What you get is a learning entity, which becomes increasingly harder
    to defeat and automatically invents new strategies depending on the models'' predictions.
    To some people, the thought of a computer being able to learn and adapt behavior
    might be rather scary. However, it is today''s reality, and the future is bound
    to bring increasingly smarter AI. Whether computers will eventually take over
    the world, like in the movies Terminator and The Matrix, remains to be seen.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据驱动AI*是完全不同的东西。它不是硬编码的行为，而是需要大量玩家数据，这些数据被上传到一个单一的位置。在那里，数据被处理，并且统计程序，如回归，决策树建模和神经网络被应用，以使AI在未来更加有竞争力。你得到的是一个学习实体，它变得越来越难击败，并根据模型的预测自动发明新的策略。对一些人来说，计算机能够学习和适应行为的想法可能相当可怕。然而，这是当今的现实，未来肯定会带来越来越聪明的AI。计算机是否最终会像《终结者》和《黑客帝国》中的电影那样接管世界，还有待观察。'
- en: For now we will forget about all those data-driven statistical solutions and
    just have a look at a single strategy AI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将忘记所有那些数据驱动的统计解决方案，只看一个单一策略的AI。
- en: When writing AI, we want to keep a clear division between the decision and the
    actual behavior. You can see it as the division between the human brain and the
    body. The brain takes the decision and sends impulses to the body to perform the
    action. For this reason we will write our "brain" in a separate module, while
    the actions an enemy is able to perform will stay in the `enemy` entity itself
    as methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写AI时，我们希望在决策和实际行为之间保持清晰的分工。你可以把它看作是人类大脑和身体之间的分工。大脑做出决定并向身体发送脉冲来执行动作。因此，我们将在一个单独的模块中编写我们的“大脑”，而敌人能够执行的动作将留在`enemy`实体本身作为方法。
- en: The NPC's behavior
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NPC的行为
- en: 'Create a new script, name it `ai.js`, and save it under the `plugins` folder
    as shown in the following code snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`ai.js`，并将其保存在`plugins`文件夹下，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We kick off by defining our brand new module, our first plugin. Let''s not
    forget to require the script in our `main.js` as shown in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们全新的模块，我们的第一个插件。不要忘记在我们的`main.js`中要求脚本，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The AI will need to give orders to the entity. For this to happen they need
    to speak a common tongue. Just like your legs will need to interpret your nerve
    signals, our enemy will need to interpret the actions it needs to perform at any
    given time. We define these commands in our `init()` function, as shown in the
    following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: AI需要给实体下达命令。为了实现这一点，它们需要使用共同的语言。就像你的腿需要解释你的神经信号一样，我们的敌人需要在任何给定时间解释它需要执行的动作。我们在`init()`函数中定义这些命令，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `action` array holds all the possible actions the `AI` module can send.
    The `init()` function takes in the entity it needs to command as its input. It
    is not necessary to assign an entity to `this.entity` as shown in the previous
    code snippet (`this.entity=entity;`), but it merely confirms that `this` is not
    the entity itself but its AI. The fact that the input parameter `entity` is not
    assigned to `this` but to `this.entity` would make it possible to have a collective
    `ai`, capable of also making decisions for a group of enemies as a whole. This
    collective AI or hive mind will be addressed in [Chapter 5](ch05.html "Chapter 5. Adding
    Some Advanced Features to Your Game"), *Adding Some Advanced Features to your
    Game*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`数组包含`AI`模块可以发送的所有可能动作。`init()`函数以它需要命令的实体作为输入。并不需要像前面的代码片段中所示那样为`this.entity`分配一个实体（`this.entity=entity;`），但这仅仅是确认`this`不是实体本身，而是它的AI。输入参数`entity`不是分配给`this`而是分配给`this.entity`，这将使得可能拥有一个集体的`ai`，也能够为整个敌人群体做出决策。这种集体AI或蜂群思维将在[第5章](ch05.html
    "第5章。为你的游戏添加一些高级功能")中讨论，*为你的游戏添加一些高级功能*。'
- en: If you would now take a look at your Firebug DOM in Firefox, you can see the
    `AI` class as part of the `ig` object and it currently only holds the `init()`
    function we just wrote. It's always a good idea to keep a track of how your DOM
    evolves while writing code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在Firefox的Firebug DOM中查看，你可以看到`AI`类作为`ig`对象的一部分，它目前只包含我们刚刚编写的`init()`函数。在编写代码时，跟踪DOM的演变是一个好主意。
- en: '![The NPC''s behavior](img/4568_3_5.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![NPC的行为](img/4568_3_5.jpg)'
- en: 'Now that we have defined the signals we will send, let''s have a look at where
    they end up. Open the `enemy.js` script and add the following `update()` function
    to it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们将发送的信号，让我们看看它们最终会到达哪里。打开`enemy.js`脚本，并向其中添加以下`update()`函数：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We could write all the behavior in separate methods, which would then take the
    `AI` commands to see if they need to do something. These methods can then be put
    in the `update()` function of the entity in order to keep its orders up to date.
    We are not going to make this division in methods in this case. Because things
    aren't too complex in this case, all behavioral code will fit into the `update()`
    function without creating intermediate methods.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有的行为写在单独的方法中，然后使用`AI`命令来查看它们是否需要做些什么。然后，这些方法可以放在实体的`update()`函数中，以保持其命令的最新状态。在这种情况下，我们不打算将这些行为分成方法。因为在这种情况下，事情并不太复杂，所有的行为代码都将适应`update()`函数，而不会创建中间方法。
- en: 'The `update()` function now consists of two main parts: a *call to the AI module*
    to receive the action it needs to perform and *actually performing the action*.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`函数现在由两个主要部分组成：*调用AI模块*来接收它需要执行的动作和*实际执行动作*。'
- en: 'The action is stored in a local variable called `action` by calling the `ai.getAction()`
    method. However, in order to do this we need to add the AI to our enemy''s `requires`
    function next to the `impact` entity code, as shown in the following code snippet:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`ai.getAction()`方法，将动作存储在名为`action`的局部变量中。然而，为了做到这一点，我们需要在敌人的`requires`函数旁边添加AI到`impact`实体代码中，如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also give your enemy a speed parameter, as shown in the following code, since
    the case statements use it for setting their movement:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 还要给你的敌人一个速度参数，如下面的代码所示，因为case语句使用它来设置它们的移动：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All actions that we defined in the `AI` module are represented in the `update()`
    function. In order to make the series of case checks more efficient, a break is
    inserted at the end of each action. This way, once an action matches with the
    case it will stop checking if other cases match. We know that we want to give
    only *one order at every given time* so this makes sense. All code within `update()`
    functions should be written as efficiently as possible since it will be called
    60 times per second if the game runs at a frame rate of 60\. Four of our actions
    are geared towards moving in the correct direction, and then we have `attack`
    and `rest`. To make sure every situation is handled, a `default` value is set.
    This way, if the enemy is given a command that he doesn't understand, he will
    just stay put. You could rewrite the `default` part of the code and overwrite
    it with the `attack` case if you like; this way the enemy will always attack if
    he doesn't understand what he needs to do; barbaric but effective.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`AI`模块中定义的所有操作都在`update()`函数中表示。为了使一系列案例检查更有效，每个操作的末尾都插入了一个break。这样，一旦一个操作与案例匹配，它就会停止检查其他案例是否匹配。我们知道我们只想在每个给定时间给出*一个命令*，所以这是有道理的。由于`update()`函数中的所有代码将在每秒调用60次，如果游戏以60帧的帧速率运行，应尽可能高效地编写。我们的四个操作都是朝着正确的方向移动，然后我们有`attack`和`rest`。为了确保处理每种情况，设置了一个`default`值。这样，如果敌人收到他不理解的命令，他就会原地不动。如果你愿意，你可以重写代码的`default`部分，并用`attack`案例覆盖它；这样，如果敌人不明白他需要做什么，他就会一直攻击；野蛮但有效。
- en: In case the enemy attacks, he calls the player's `receive damage` function.
    This is interesting since the `receive damage` method of the player can be overwritten
    in `player.js` to incorporate damage reduction from armor and the like.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果敌人攻击，他会调用玩家的`receive damage`函数。这很有趣，因为玩家的`receive damage`方法可以在`player.js`中被重写，以包含来自盔甲等的伤害减少。
- en: However, for now let's take a look at the actual brain or decision making itself.
    Therefore we need to return to our `AI` module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们看一下实际的大脑或决策本身。因此，我们需要回到我们的`AI`模块。
- en: 'Summing up the preceding content, the conclusions are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，结论如下：
- en: The AI of an entity is its ability to make decisions based on external input,
    often using several strategies
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体的AI是其基于外部输入做出决策的能力，通常使用多种策略
- en: In code, the decision making should be separated from the actual behavior where
    possible
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中，决策应尽可能与实际行为分开
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `ai.js`. As an analogy to the human
    body, this file will contain everything about the brain.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`ai.js`。类比于人体，这个文件将包含关于大脑的一切。
- en: Set up the `ai.js` script so it becomes an ImpactJS class extension.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ai.js`脚本设置为ImpactJS类扩展。
- en: Include `ai.js` in your `main` script.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`脚本中包括`ai.js`。
- en: Define the language that will bind behavioral decisions to actual behavior.
    As an analogy to the human body, these would be the electrical impulses your nervous
    system transmits.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将行为决策与实际行为绑定的语言。类比于人体，这些将是你的神经系统传输的电脉冲。
- en: Build the actual behavioral patterns an enemy will follow for every command
    he can receive. As an analogy to the human body, this would be the body's reaction
    to certain nerve impulses.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为敌人将遵循的每个命令构建实际的行为模式。类比于人体，这将是身体对某些神经冲动的反应。
- en: Include the function that calls for an AI command. As an analogy to the human
    body, this function call would be the nerves themselves.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括调用AI命令的函数。类比于人体，这个函数调用将是神经本身。
- en: The NPC's decision making process
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NPC的决策过程
- en: 'We just saw that the AI `getAction()` method was called but not yet fully explained.
    Its main purpose is to return an action when called. The possible actions here
    are moving in a certain direction, attacking, blocking incoming attacks, or not
    moving at all. What action to take is decided by the distance between the player
    and the `enemy` entity that needs to take the decision, as shown in the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到AI `getAction()`方法被调用，但尚未完全解释。它的主要目的是在调用时返回一个动作。这里可能的动作是朝着某个方向移动、攻击、阻挡进攻或根本不移动。采取什么行动是由需要做出决定的`enemy`实体与玩家之间的距离决定，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add this function to the `AI` module. Just like the `init()` function, it takes
    the entity as an input parameter. A series of local variables is calculated to
    decide what path needs to be taken in order to get to the player. The enemy needs
    to know its distance from the player and the angle towards the player. Collision
    is calculated by use of the `collision.trace()` method. The inputs for this method
    are the entities `position`, `size`, and `distance` to its target, in this case,
    the player. Here you shouldn't see collision as a real physical collision but
    rather as a line of sight. `res.x.collision` should be interpreted as "is the
    player in line of sight if I look in a horizontal line across the screen?"
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数添加到`AI`模块中。就像`init()`函数一样，它以实体作为输入参数。一系列局部变量被计算出来，以决定需要采取什么路径才能到达玩家。敌人需要知道与玩家的距离和朝向玩家的角度。使用`collision.trace()`方法计算碰撞。这个方法的输入是实体的`position`、`size`和到目标的`distance`，在这种情况下是玩家。在这里，你不应该把碰撞看作真正的物理碰撞，而应该把它看作视线。`res.x.collision`应该被解释为“如果我在屏幕上水平看，玩家是否在视线中？”
- en: 'The following screenshot shows the line of sight for the enemy:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了敌人的视线：
- en: '![The NPC''s decision making process](img/4568_3_6.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![NPC的决策过程](img/4568_3_6.jpg)'
- en: If this is the case, there is no more need to move up or down. The same reasoning
    works for the y-axis and moving left or right. This is only to show you how this
    function works leaving out the first two `if` statements, and calculation of the
    `res` variable will still give the same result because of the logic in the next
    two `if` statements.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，就不再需要上下移动。对于y轴和左右移动也是同样的道理。这只是为了向你展示这个函数是如何工作的，省略了前两个`if`语句，并且`res`变量的计算仍然会得到相同的结果，因为接下来的两个`if`语句的逻辑。
- en: 'A check on the distance between the enemy and the player happens after this.
    If the enemy is close enough to attack (this is hardcoded at `30` pixels), the
    enemy attacks. This cut off could be changed by reading the actual range of the
    enemy and using this instead of just using `30`. Also, the enemy has the opportunity
    to attack once per frame; this makes for 60 attacks per second. Have you ever
    been hit with a sword 60 times in one second? It hurts. We could lower that by
    increasing the chance of the enemy doing nothing at all. Changing these two things,
    the code could look like the following code snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后检查敌人和玩家之间的距离。如果敌人足够接近可以攻击（这在`30`像素处硬编码），敌人就会攻击。这个截止点可以通过读取敌人的实际范围并使用它来代替`30`来改变。此外，敌人每帧有一次攻击的机会；这样一秒钟就会有60次攻击。你有没有被一秒钟内被剑击中60次？那很疼。我们可以通过增加敌人什么都不做的机会来降低这个频率。通过改变这两件事，代码可能看起来像以下的代码片段：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Of course you would need to change the actual damage done since 2 damages might
    not be that impressive or challenging for a player with 200 hit points. The following
    code snippet shows the change in damage:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要改变实际造成的伤害，因为2点伤害对于一个有200点生命值的玩家来说可能并不那么令人印象深刻或具有挑战性。以下代码片段显示了伤害的变化：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When the distance between the enemy and the player is 300, the enemy will move
    towards the player. As explained earlier it uses the angle to decide what direction
    to go first. In all other cases, the AI advises the entity to rest. So if the
    player is far away, the enemy will not attack. This way you avoid being attacked
    by all enemies at once. If your speed is greater you can even run away.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人和玩家之间的距离为300时，敌人会朝着玩家移动。如前所述，它使用角度来决定首先朝哪个方向前进。在所有其他情况下，AI建议实体休息。所以如果玩家很远，敌人就不会攻击。这样你就可以避免被所有敌人同时攻击。如果你的速度更快，你甚至可以逃跑。
- en: 'There is one small thing left. As you might have noticed, an action is not
    immediately returned but sent through the `doAction()` method. The following code
    snippet shows how this is done:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件小事。你可能已经注意到，一个动作不会立即返回，而是通过`doAction()`方法发送。以下代码片段显示了如何做到这一点：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method, which is also added to the `AI` module, is only used to store the
    last action that the entity has performed. You could do without this function,
    but it is often handy to keep track of the last move that was performed. Applications
    for this are not shown in this short AI tutorial.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法也被添加到`AI`模块中，只用于存储实体执行的最后一个动作。你可以不用这个函数，但是跟踪上一次执行的动作通常很方便。这个功能的应用在这个简短的AI教程中没有展示出来。
- en: If you were to reload the game at this point, you should have an enemy that
    actually tries to kill you instead of just being passive as a stone(r).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这一点重新加载游戏，你应该有一个真正试图杀死你的敌人，而不仅仅是像一块石头一样被动。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Calling the brain to act is done with our `getAction()` function. This function
    takes the entity for which a decision needs to be made as an input argument, and
    will return a command or an action. The logic inside this function can be as simple
    or complex as you like. In this example, distance to the player is the most important
    determinant for the action that needs to be taken.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用大脑行动是通过我们的`getAction()`函数完成的。这个函数以需要做出决定的实体作为输入参数，并返回一个命令或一个动作。这个函数内部的逻辑可以像你喜欢的那样简单或复杂。在这个例子中，与玩家的距离是决定需要采取的行动的最重要因素。
- en: Use a `line of sight` ImpactJS function to determine if the enemy will be able
    to see the player.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`line of sight` ImpactJS函数来确定敌人是否能看到玩家。
- en: What an AI should do is a totally subjective thing; try adding your own commands
    and behavioral patterns.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AI应该做的是完全主观的事情；尝试添加你自己的命令和行为模式。
- en: Pickup items to help out your player
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拾取物品来帮助你的玩家
- en: Now that our enemy fights back, we might be in need for some extra assistance
    in the form of the `pickup` items and extra weapons.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的敌人反击了，我们可能需要一些额外的帮助，比如`pickup`物品和额外的武器。
- en: One useful `pickup` item would be an instant `healthpotion` entity so that we
    can heal from the damage we got.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的`pickup`物品将是一个即时的`healthpotion`实体，这样我们就可以从受到的伤害中恢复。
- en: Healing your player with a potion
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用药水治疗你的玩家
- en: 'Let''s build ourselves an entity called `healthpotion` and include it in the
    `main` script `main.js`, as shown in the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们建立一个名为`healthpotion`的实体，并将其包含在`main`脚本`main.js`中，如下所示：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Include the following code in the `healthpotion.js` script:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`healthpotion.js`脚本中包含以下代码：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `healthpotion` entity is a very straightforward entity. It has no real behavior
    except for detecting whether a player touches it and then healing the player if
    he or she does.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`healthpotion`实体是一个非常直接的实体。除了检测玩家是否触碰它，然后治疗玩家之外，它没有真正的行为。'
- en: Interesting to note here is how the `receiveDamage()` method is used with negative
    damage in order to heal the target. This health potion is used on pickup; it does
    not always have to be like this and some things can be counted by use of a `gameinfo`
    array.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是`receiveDamage()`方法如何使用负伤害来治疗目标。这种生命药水在拾取时使用；它不总是这样，有些事情可以通过`gameinfo`数组来计算。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `healthpotion.js`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`healthpotion.js`。
- en: Set up the `healthpotion.js` script with the standard ImpactJS module code.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的ImpactJS模块代码设置`healthpotion.js`脚本。
- en: Include the `healthpotion.js` script in your `main` script.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`脚本中包含`healthpotion.js`脚本。
- en: Add an animation sheet and a sequence.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个动画表和一个序列。
- en: Set up the `collision` entity so it can detect when the player touches it.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`collision`实体，以便它在玩家触碰它时能够检测到。
- en: Use the `receivedamage()` function with a negative damage; this will heal the
    player instead of dealing with the damage. Make the `healthpotion` entity destroy
    itself.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`receivedamage()`函数并带有负伤害；这将治愈玩家而不是处理伤害。让`healthpotion`实体销毁自身。
- en: Becoming rich with coins
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用硬币变得富有
- en: 'The `coin` entity is an example of an item that we might want to keep a count
    of. It is almost the same as the `healthpotion` entity except for its name, animation
    sheet, and the `check` function, which is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`coin`实体是我们可能想要计数的物品的一个例子。它与`healthpotion`实体几乎相同，除了名称、动画表和`check`函数不同，如下所示：'
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Instead of healing the player, a method called `addCoin()` is applied. This
    function does not work yet so you can put this line of code in a comment until
    we change this in the section, *Keeping score for player feedback*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 不再治疗玩家，而是应用了一个名为`addCoin()`的方法。这个函数还没有起作用，所以你可以把这行代码放在注释中，直到我们在“为玩家反馈保持得分”部分改变它。
- en: 'First let''s address another issue. If you added the `coin` and `healthpotion`
    entities to the game with the Weltmeister, you might have noticed that you can
    actually kill the `healthpotion` and `coin` entities by shooting them. If you
    don''t like this behavior, it can be fixed by giving every entity a unique name,
    as shown in the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们解决另一个问题。如果你用Weltmeister向游戏中添加了`coin`和`healthpotion`实体，你可能已经注意到你实际上可以通过射击它们来杀死`healthpotion`和`coin`实体。如果你不喜欢这种行为，可以通过给每个实体一个唯一的名称来修复，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can check for it in the check functions as shown in the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在检查函数中检查它，就像下面的代码所示的那样：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now let's get our score system to work.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们让我们的得分系统起作用。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `coin.js`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`coin.js`。
- en: Set up the `coin.js` file with the standard ImpactJS module code.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用标准的ImpactJS模块代码设置`coin.js`文件。
- en: Include `coin.js` in your `main` script.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`脚本中包含`coin.js`。
- en: Add an animation sheet and a sequence.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个动画表和一个序列。
- en: Set up the `collision` entity so it can detect when the player touches it.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`collision`实体，以便它在玩家触碰它时能够检测到。
- en: When touching the `player` entity, the `coin` entity must destroy itself and
    call the `addcoin()` function, which sends feedback to the game info system. The
    function will be defined later this chapter, so turn it on when implemented.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当触碰`player`实体时，`coin`实体必须销毁自身并调用`addcoin()`函数，该函数会向游戏信息系统发送反馈。该函数将在本章后面定义，所以在实现时打开它。
- en: Keeping score for player feedback
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为玩家反馈保持得分
- en: 'Keeping track of a number of things is all about leaving it outside the currently
    loaded game. This way it can be transferred across levels and even across games.
    Add the following to `main.js` above the `MyGame` definition:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪一些东西的数量就是将它留在当前加载的游戏之外。这样它可以在关卡之间甚至在游戏之间传递。将以下内容添加到`main.js`中`MyGame`定义的上面：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`GameInfo.coins` and `GameInfo.score` will now keep track of how many coins
    we have gathered and what is our current score.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameInfo.coins`和`GameInfo.score`现在将跟踪我们收集了多少硬币和我们当前的得分。'
- en: 'However, we do need two functions, which will actually increase these game
    properties. Therefore let''s add these functions to the `MyGame` definition in
    the `main.js` script:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实需要两个函数，它们实际上会增加这些游戏属性。因此，让我们在`main.js`脚本的`MyGame`定义中添加这些函数：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now you can safely get the `ig.game.addCoin()` method out of the comments without
    fear of game crashes. Also, we can add a call to the `increaseScore` function
    at the death of an enemy. To do this, we need to change the `kill` function of
    our enemies in the `enemy.js` script, as shown in the following code snippet:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以放心地将`ig.game.addCoin()`方法从注释中取出，而不用担心游戏崩溃。此外，我们可以在敌人死亡时调用`increaseScore`函数。为此，我们需要更改`enemy.js`脚本中敌人的`kill`函数，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, we keep the original function by adding the `this.parent()`
    line of code but add our code for increasing the score just before it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们通过添加`this.parent()`代码行来保留原始函数，但是在它之前添加了增加得分的代码。
- en: 'We don''t need to restrict ourselves to things that can only go up. We could
    put a limit on the number of projectiles our hero has and keep a count of them.
    Add the initial number of projectiles to the `GameInfo` array as shown in the
    following code snippet:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要局限于只能上升的东西。我们可以限制英雄拥有的抛射物数量，并对其进行计数。将初始抛射物数量添加到`GameInfo`数组中，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We are in need of two new functions, which we can add to `MyGame` like we did
    for `addCoin()` and `increaseScore()`. The code for adding the two functions is
    as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个新的函数，我们可以像为`addCoin()`和`increaseScore()`一样将它们添加到`MyGame`中。添加这两个函数的代码如下：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our new attack code for the `player` entity will look like the following code
    snippet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`player`实体的新攻击代码将如下代码片段所示：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First we check whether we have enough projectiles and after launching one, a
    `projectile` entity is subtracted from our original stack.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们检查是否有足够的抛射物，然后发射一个后，从我们的原始堆栈中减去一个`projectile`实体。
- en: 'Great! But how do we resupply? We could just create another `pickup` item for
    this purpose as shown in the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！但是我们如何补给？我们可以为此目的创建另一个`pickup`物品，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Add some of these to your game and you will be able to shoot your way through
    anything like a real Rambo!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中添加一些这样的东西，你就能像真正的兰博一样射穿一切！
- en: There are many other appliances for this `GameInfo` array out there, but it's
    up to you to make good use of it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`GameInfo`数组还有许多其他用途，但是如何好好利用它就取决于你了。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Some information needs to be kept outside of the actual game so it can be used
    and stored after a game is finished. This overhead information is kept in a `gameinfo`
    array, defined in the `main` script.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些信息需要保留在实际游戏之外，以便在游戏结束后使用和存储。这些额外信息保存在`main`脚本中定义的`gameinfo`数组中。
- en: Create the `gameinfo` array and reserve a place for storing both the number
    of coins that are collected and the overall score a player achieves.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`gameinfo`数组，并保留一个位置来存储收集的硬币数量和玩家实现的总分数。
- en: Build the `addcoin()` and `increasescore()` functions. `addcoin()` will increase
    the number of coins by one when called. `increasescore()` can take a numeric input
    parameter, which is the score that it needs to add to the total.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`addcoin()`和`increasescore()`函数。`addcoin()`在调用时将硬币数量增加一枚。`increasescore()`可以接受一个数字输入参数，这是需要添加到总分数的分数。
- en: Activate the `addcoin()` function in the `coin` entity.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活`coin`实体中的`addcoin()`函数。
- en: Overwrite the enemy's `kill` method to incorporate the `increasescore()` function.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖敌人的`kill`方法以整合`increasescore()`函数。
- en: Using the same logic, create both the `addProjectile()` and `substractprojectile()`
    functions.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的逻辑，创建`addProjectile()`和`substractprojectile()`函数。
- en: Change the `player` entity code. So it will check how many projectiles a player
    has before it becomes possible to fire. When a projectile is fired, a `projectile`
    entity is subtracted from the remaining ammo.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`player`实体代码。这样它将检查玩家在变得可能发射之前有多少投射物。当发射投射物时，从剩余弹药中减去一个`projectile`实体。
- en: Use everything you learned about `pickup` items to make a `pickup` projectile
    that will replenish the player's ammo supply.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用您学到的关于`pickup`物品的一切，制作一个可以补充玩家弹药供应的`pickup`投射物。
- en: Transitioning from one area to another
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个区域过渡到另一个区域
- en: Making a map transition for an RPG has been thoroughly explained in [Chapter
    2](ch02.html "Chapter 2. Introducing ImpactJS"), *Introducing ImpactJS*. We will
    just have a quick recap and some pointers in this section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。介绍ImpactJS")中，详细解释了如何进行RPG的地图过渡，*介绍ImpactJS*。在本节中，我们将简要回顾一些要点。
- en: 'As you might remember, we have used a combination of three entity files to
    build gateways between levels. Add the `trigger`, `levelchange`, and `void` entities
    to the `entities` folder and include them in the `main` script, as shown in the
    following code snippet:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的，我们使用了三个实体文件的组合来构建级别之间的网关。将`trigger`、`levelchange`和`void`实体添加到`entities`文件夹中，并在`main`脚本中包含它们，如下面的代码片段所示：
- en: '[PRE53]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To have a level to connect to, we need to build one first. The following screenshot
    shows the `endgame` level to which we should connect:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到一个级别，我们首先需要构建一个级别。以下屏幕截图显示了我们应该连接到的`endgame`级别：
- en: '![Transitioning from one area to another](img/4568_3_7.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![从一个区域过渡到另一个区域](img/4568_3_7.jpg)'
- en: 'This level is the `endgame` content; it will soon feature the dangerous boss
    of this little RPG. Don''t forget to include it in `main.js`, as shown in the
    following code snippet:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个级别是`endgame`内容；它很快将展示这个小RPG的危险老板。不要忘记将其包含在`main.js`中，如下面的代码片段所示：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that all necessary components are ready, connect the level in the same way
    as shown in [Chapter 2](ch02.html "Chapter 2. Introducing ImpactJS"), *Introducing
    ImpactJS*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有必要的组件都准备好了，以与[第2章](ch02.html "第2章。介绍ImpactJS")中所示的方式连接级别，*介绍ImpactJS*。
- en: Use the `trigger` entity to trigger the `levelchange` entity when the player
    walks over it. The `void` entity is used as the `spawn` location.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家走过时，使用`trigger`实体触发`levelchange`实体。`void`实体用作`spawn`位置。
- en: 'One thing needs to be pointed out here. When the player moves from one area
    (level) to another, his health is reset to the default value because the `levelchange`
    script spawns a new player. This can be avoided by either moving the `health`
    value before loading the new level to an independent array of variables, or by
    changing the `levelchange` script itself. The second option is shown in the following
    code snippet. Open `levelchange.js` to find the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要指出一件事。当玩家从一个区域（级别）移动到另一个区域时，他的健康值会被重置为默认值，因为`levelchange`脚本会生成一个新的玩家。可以通过将`health`值移动到加载新级别之前的独立变量数组中，或者通过更改`levelchange`脚本本身来避免这种情况。第二个选项在下面的代码片段中显示。打开`levelchange.js`找到以下代码：
- en: '[PRE55]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Before actually loading the `level` entity, the `health` value is stored to
    a local variable`health`, which is then reassigned to the newly spawned player.
    The same can be done to any attribute, or a temporal copy can be made of the `player`
    entity, which then overwrites the freshly spawned one.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际加载`level`实体之前，`health`值被存储到一个本地变量`health`中，然后重新分配给新生成的玩家。同样的操作也可以应用到任何属性，或者可以对`player`实体进行临时复制，然后覆盖新生成的实体。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Copy the `trigger`, `levelchange`, and `void` entities from the `chapter 2`
    folder and put them in the `entities` folder.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`第2章`文件夹中复制`trigger`、`levelchange`和`void`实体，并将它们放入`entities`文件夹中。
- en: Include all three entities in the `main` script.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`脚本中包含所有三个实体。
- en: Make a level transition using these three entities as shown in [Chapter 2](ch02.html
    "Chapter 2. Introducing ImpactJS"), *Introducing ImpactJS*.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这三个实体进行级别过渡，如[第2章](ch02.html "第2章。介绍ImpactJS")中所示，*介绍ImpactJS*。
- en: Change the `levelchange` entity so the player's health is temporarily stored
    in between level loads.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`levelchange`实体，以便玩家的健康状况在级别加载之间暂时存储。
- en: NPCs and conversation
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC和对话
- en: In many 2D RPGs the epic story is told by the sole use of text. The player interacts
    with various **NPC**s (**Non Playable Characters**) before he or she can beat
    the game. An enemy is also an NPC but in most contexts, the NPC is regarded as
    the non-hostile character who helps the hero reach his goal by giving hints, quests,
    and items. We will introduce such a peaceful creature and make him speak in the
    next section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多2D RPG中，史诗般的故事仅通过文本来讲述。玩家在击败游戏之前与各种NPC（非玩家角色）进行互动。敌人也是NPC，但在大多数情况下，NPC被视为通过给出提示、任务和物品来帮助英雄达到目标的非敌对角色。我们将在下一节介绍这样一个和平的生物，并让他说话。
- en: The speech balloon
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对话气球
- en: 'For this we will use a text balloon, which we treat as an entity of its own.
    Let''s prepare a new JavaScript file and call it `textballoon.js` using the following
    code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用一个文本气球，将其视为一个独立的实体。让我们准备一个新的JavaScript文件，并将其命名为`textballoon.js`，使用以下代码：
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We will once again need to let our `main` script know of its existence, so add
    `'game.entities.textballoon'` to the `main` script.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次需要让我们的`main`脚本知道它的存在，所以将`'game.entities.textballoon'`添加到`main`脚本中。
- en: 'In this file we will not only define our `textballoon` entity but also an inner
    class, which we will use in the `textballoon` entity: `WordWrap`. `WordWrap` is
    a class invented by a person who goes under the name of Kingsley on the ImpactJS
    forum, and all thanks should go to him. Once again this proves that looking up
    on forums is a good idea. Someone might have already done what you intend to do.
    `WordWrap` organizes the inputted text in such a way that you can fit it on objects
    such as speech balloons. We can define this class in any of our JavaScript files
    but since it''s used exclusively by our `textballoon` entity, it makes sense to
    place the script as shown in the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们不仅会定义我们的`textballoon`实体，还会定义一个内部类，我们将在`textballoon`实体中使用：`WordWrap`。`WordWrap`是由ImpactJS论坛上一个名为Kingsley的人发明的类，所有的感谢应该归给他。这再次证明，在论坛上查找是一个好主意。有人可能已经做了你打算做的事情。`WordWrap`以这样一种方式组织输入的文本，以便你可以将其放在诸如对话气球之类的对象上。我们可以在我们的任何JavaScript文件中定义这个类，但由于它仅被我们的`textballoon`实体使用，将脚本放置如下所示是有意义的：
- en: '[PRE57]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `WordWrap` class is an extension of the general Impact class just like
    our `AI` module. It is in fact a function, which takes three arguments: a piece
    of text, a maximum width for a line of text, and whether the function should cut
    off by character or word. When a new `WordWrap` class is created, these three
    things are assigned to local arguments as can be seen in the `init()` function.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`WordWrap`类是通用Impact类的扩展，就像我们的`AI`模块一样。实际上，它是一个函数，它接受三个参数：一段文本，一行文本的最大宽度，以及函数是否应该按字符或单词截断。当创建一个新的`WordWrap`类时，这三个参数被分配给本地参数，如`init()`函数中所示。'
- en: However, the most important thing is the `wrap` method of the `WordWrap` class.
    It only contains two lines of code but does all the work. In the first line, a
    regular expression is built, which is then interpreted and returned in the second
    line. A regular expression is a flexible way to recognize specified strings of
    text. How this text pattern recognition code works is not covered here since it
    is not within the scope of this book.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是`WordWrap`类的`wrap`方法。它只包含两行代码，但却完成了所有的工作。在第一行中，构建了一个正则表达式，然后在第二行中进行解释和返回。正则表达式是一种灵活的方式，用于识别指定的文本字符串。这里不涵盖文本模式识别代码的工作原理，因为它不在本书的范围内。
- en: 'Now that we have the most vital function for our `textballoon` entity, we can
    build the `textballoon` entity itself using the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`textballoon`实体的最重要功能，我们可以使用以下代码构建`textballoon`实体本身：
- en: '[PRE58]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `balloon` entity is not much more than an image with text, which is shown
    on top of everything else (`zIndex = 1000`) when spawned. In the `Init()` method
    of our `balloon` entity, the `WordWrap()` function is used to wrap the text to
    the correct dimensions. It is interesting to note here how the font is initialized
    (`font : new ig.Font(''media/font.png'')`).The font that will be used is already
    present in our `media` folder in the `.png` format and in order to assign it to
    our local variable font, a new impact method is used: `ig.Font()`. Unlike the
    font from Word, here it has a predefined color and size. A free font tool is available
    if you want to make your own font for your ImpactJS game on the following link:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`balloon`实体不过是一个带有文本的图像，在生成时显示在所有其他内容的顶部（`zIndex = 1000`）。在我们的`balloon`实体的`Init()`方法中，使用`WordWrap()`函数将文本包装到正确的尺寸。有趣的是，这里如何初始化字体（`font:
    new ig.Font(''media/font.png'')`）。将要使用的字体已经存在于我们的`media`文件夹中，格式为`.png`，为了将其分配给我们的本地变量字体，使用了一个新的impact方法：`ig.Font()`。与Word中的字体不同，这里有一个预定义的颜色和大小。如果您想为ImpactJS游戏制作自己的字体，可以在以下链接上找到免费的字体工具：'
- en: '[http://impactjs.com/font-tool/](http://impactjs.com/font-tool/)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://impactjs.com/font-tool/](http://impactjs.com/font-tool/)'
- en: 'There is also a variable called `lifeTime`, which will keep track of the remaining
    number of frames until the `balloon` entity is dismissed. This check is done in
    the `update()` function as shown in the following code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`lifeTime`的变量，它将跟踪`balloon`实体被解散之前剩余的帧数。这个检查是在`update()`函数中进行的，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In every new frame, the lifetime drops by one. When the `lifeTime` value reaches
    `0`, the `balloon` entity is killed. More intelligent balloon timers could be
    implemented by counting the amount of text that should be read and adjusting the
    time you have to read it, but this is a simple example.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中，生命周期减少一次。当`lifeTime`值达到`0`时，`balloon`实体被销毁。更智能的气球计时器可以通过计算应该阅读的文本量并调整阅读时间来实现，但这只是一个简单的例子。
- en: 'The last thing we will need is the entity''s `draw()` method. `Draw()` is called
    for every frame just like the `update()` function, but is dedicated to what needs
    to be displayed as shown in the following code snippet:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一件事是实体的`draw()`方法。`draw()`就像`update()`函数一样，每一帧都会被调用，但它专门用于需要显示的内容，如下面的代码片段所示：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'All entities have a `draw` method and it is called automatically. We will have
    a look at it now because our balloon needs to be adjusted a bit. In the `draw()`
    function, first its parent function is called followed by positioning and drawing
    the text that needs to be shown on top of our balloon. The order of things is
    very important here. If you would first draw the text and put `this.parent();`
    at the end, the text will be written first, followed by the balloon. You can try
    this once we have an entity to spawn our `balloon` entity; for now you should
    get an empty speech balloon. The following screenshot shows a fully functioning
    speech balloon:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实体都有一个`draw`方法，并且会自动调用。我们现在将看一下它，因为我们的气泡需要稍作调整。在`draw()`函数中，首先调用其父函数，然后定位并绘制需要显示在气泡顶部的文本。这里事情的顺序非常重要。如果你首先绘制文本并在最后放置`this.parent();`，那么文本将首先被写入，然后是气泡。一旦我们有一个实体来生成我们的`balloon`实体，你可以尝试这样做；现在你应该得到一个空的对话气泡。以下截图显示了一个完全功能的对话气泡：
- en: '![The speech balloon](img/4568_3_8.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![对话气泡](img/4568_3_8.jpg)'
- en: 'Now that we have a fully functioning speech balloon, it is time to introduce
    an entity that wants to talk to us: the `NPC` entity.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全功能的对话气泡，是时候介绍一个想和我们说话的实体了：`NPC`实体。
- en: 'Summing up the preceding content, the conclusions are as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，结论如下：
- en: Lots of games have friendly creatures walking about and providing the player
    with hints.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多游戏中都有友好的生物在周围走动，并为玩家提供提示。
- en: A talking character consists of a friendly `NPC` entity and its speech balloon,
    which can be regarded as a separate entity. Additionally, we make use of a `wordwrap()`
    function, which will keep the sentences within the borders of the speech balloon.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个说话的角色由友好的`NPC`实体和其对话气泡组成，可以被视为一个单独的实体。此外，我们使用了一个`wordwrap()`函数，它将保持句子在对话气泡的边界内。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `textballoon.js`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`textballoon.js`。
- en: Create the `wordwrap()` function as an extension to the `ImpactJS` class.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`wordwrap()`函数作为`ImpactJS`类的扩展。
- en: Set up the `textballoon.js` file with the standard ImpactJS module code.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的ImpactJS模块代码设置`textballoon.js`文件。
- en: Include `textballoon.js` in your `main` script.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`脚本中包含`textballoon.js`。
- en: Add an animation sheet, an animation sequence, a size, and a default position.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个动画表，一个动画序列，一个大小和一个默认位置。
- en: Set the z-index property to a high number so the speech balloon is always shown
    on top of every other entity.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将z-index属性设置为一个较高的数字，这样对话气泡总是显示在其他实体的顶部。
- en: Use the `wordwrap()` function to transform a text of your choice and add it
    as a property of the speech balloon.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`wordwrap()`函数来转换你选择的文本，并将其添加为对话气泡的属性。
- en: 'If you want to make your own font for your game, use the ImpactJS font tool
    to convert it into a file that Impact can use. The font tool is located at the
    following URL: [http://impactjs.com/font-tool/](http://impactjs.com/font-tool/).'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想为你的游戏制作自己的字体，请使用ImpactJS字体工具将其转换为Impact可以使用的文件。字体工具位于以下网址：[http://impactjs.com/font-tool/](http://impactjs.com/font-tool/)。
- en: Change the `update` function of the speech balloon so that it will keep track
    of how much time has passed since the speech balloon was spawned. The `update`
    function will also kill off the balloon when a preset number of frames have past.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改对话气泡的`update`函数，以便它能够跟踪自对话气泡生成以来经过了多少时间。`update`函数还将在预设的帧数过去时关闭对话气泡。
- en: Overwrite the default `draw` function so it will draw your text on top of the
    speech balloon itself.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖默认的`draw`函数，使其能够在对话气泡本身上绘制你的文本。
- en: Adding a talking non-playable character
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个说话的非玩家角色
- en: 'Create a new script and save it as `Talkie.js`. `Talkie` will be the name of
    our lovely NPC as shown in the following code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并将其保存为`Talkie.js`。`Talkie`将是我们可爱的NPC的名称，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Like for any regular entity, the `Talkie` script properties are defined before
    or in the `init()` function, depending on whether you wish to write them in the
    literal notation or not, as shown in the following code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何常规实体一样，`Talkie`脚本属性在`init()`函数之前或之中被定义，具体取决于你是否希望以文字表示法编写它们，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`Talkie` has two states, either he is doing nothing (`idle`) or he is talking
    (`Talk`) and his animation changes accordingly. He should only stay in the `Talk`
    state while the balloon is there, so a timer is set to synchronize the balloon
    with Talkie''s animation using the following code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`Talkie`有两种状态，要么他什么也不做（`idle`），要么他在说话（`Talk`），他的动画会相应地改变。他应该只在气泡存在时保持在`Talk`状态，因此使用以下代码设置一个定时器来使气泡与Talkie的动画同步：'
- en: '[PRE63]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The animation remains in place for `200` frames; when done Talkie returns to
    his idle state.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 动画保持在`200`帧的位置；完成后，Talkie返回到他的空闲状态。
- en: '`Talkie` needs to check if the player is in the vicinity so he can start talking.
    When the player is close, the `textballoon` entity is spawned and Talkie will
    not talk again. `ig.game.sortEntitiesDeferred()` resorts the entities in the game
    by its z-value; this way you are sure the balloon is shown on top. The following
    code is used for this purpose:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`Talkie`需要检查玩家是否在附近，这样他就可以开始说话。当玩家靠近时，`textballoon`实体被生成，Talkie将不会再说话。`ig.game.sortEntitiesDeferred()`通过其z值重新排序游戏中的实体；这样你就可以确保气球显示在顶部。以下代码用于此目的：'
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now that we have our Talkie code finished, try adding him to one of the levels
    and get near him. A balloon should pop up saying **Epicness awaits you!**
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Talkie代码已经完成，尝试将他添加到其中一个关卡，并靠近他。一个气球应该弹出，上面写着**史诗般的等待着你！**
- en: Talkie is right because we are almost at the end of our game.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Talkie是正确的，因为我们几乎到达了游戏的结尾。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: We now need a character capable of delivering the message to the player. We
    will call this character `Talkie`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个能够向玩家传递消息的角色。我们将称这个角色为`Talkie`。
- en: Open a new JavaScript file and save it as `Talkie.js`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`Talkie.js`。
- en: Set up the `Talkie.js` file with the standard ImpactJS module code.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的ImpactJS模块代码设置`Talkie.js`文件。
- en: Include `Talkie.js` in your `main` script.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`脚本中包含`Talkie.js`。
- en: Add an animation sheet, an animation sequence, a size, name, and several other
    properties for the Talkie.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Talkie添加动画表、动画序列、大小、名称和其他几个属性。
- en: Add a property `talked`, which keeps track of whether Talkie already talked
    or not. And a property `times`, which is the number of frames for which the Talkie
    needs to look as if he is actually talking. The time span for which the talk animation
    is shown is best to be equal to the life span of the speech balloon.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`talked`属性，用于跟踪Talkie是否已经说过话。还有一个`times`属性，表示Talkie需要看起来像在说话的帧数。对话动画显示的时间跨度最好等于对话气球的寿命。
- en: Adapt the `update` function to make the speech animation work.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`update`函数使对话动画起作用。
- en: Overwrite the `check` function and collision detection so that a `textballoon`
    entity is spawned when the player touches the Talkie if he has not yet talked
    before.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`check`函数和碰撞检测，以便在玩家触摸Talkie时生成一个`textballoon`实体，如果他之前还没有说过话。
- en: The final battle
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终战斗
- en: Usually a game ends with a grand finale; a boss of great strength, you need
    to slay in order to reap everlasting fame!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通常游戏以盛大的结局结束；一个强大的boss，你需要杀死他才能获得永恒的名声！
- en: 'Let''s have a look at the final `Boss` entity:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看最终的`Boss`实体：
- en: '[PRE65]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this case, the `Boss` entity is nothing more than a strong enemy. There is
    no need to do an exact copy and paste of the `enemy` entity and adjust code separately
    on the elements they share. It is more efficient to extend the `enemy` class and
    only fill out the differences. Our boss has another name, more health, more speed,
    looks different, and takes less damage from a hit. In order to be able to build
    upon the original `enemy` entity, you need to include it in its `require` function.
    As the enemy is already built upon the ImpactJS `entity` class, there is no more
    need to include `impact.entity`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Boss`实体只是一个强大的敌人。没有必要精确复制和粘贴`enemy`实体，并在它们共享的元素上分别调整代码。通过扩展`enemy`类并只填写差异，效率更高。我们的boss有另一个名字，更多的生命值，更快的速度，外观不同，并且受到的伤害更少。为了能够建立在原始的`enemy`实体之上，你需要在其`require`函数中包含它。由于敌人已经建立在ImpactJS
    `entity`类之上，所以不再需要包含`impact.entity`。
- en: 'In addition, we need to tell the `projectile` entity that it is also allowed
    to hit the `Boss` entity, as shown in the following code snippet:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要告诉`projectile`实体也可以击中`Boss`实体，如下面的代码片段所示：
- en: '[PRE66]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In `projectile.js`, the `if` statement is adjusted to cope with our `Boss` entity.
    You might have noticed that the death of our enemy triggers the end of the game.
    We will look into that and the opening splash screen in [Chapter 5](ch05.html
    "Chapter 5. Adding Some Advanced Features to Your Game"), *Adding Some Advanced
    Features to Your Game*. You can add a `Boss` entity to the `endgame` level and
    fight him for glory!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在`projectile.js`中，`if`语句被调整以适应我们的`Boss`实体。你可能已经注意到我们的敌人死亡会触发游戏结束。我们将在[第5章](ch05.html
    "第5章。为你的游戏添加一些高级功能")中研究这一点和开场画面，*为你的游戏添加一些高级功能*。你可以在`endgame`级别中添加一个`Boss`实体并为荣耀而战！
- en: 'Summing up the preceding content, the conclusions are as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，结论如下：
- en: A final boss is often the long anticipated antagonist that a player needs to
    defeat in order to finish a game or stage. He often has more health, does more
    damage, and thus is generally harder to defeat than a regular foe.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终boss通常是玩家需要击败才能完成游戏或阶段的期待已久的对手。他通常拥有更多的生命值，造成更多的伤害，因此通常比普通敌人更难击败。
- en: We can base our boss's character on a regular enemy by extending the `enemy`
    class when creating the `boss` entity.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过扩展`enemy`类来创建`boss`实体，以基于常规敌人的角色。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `Boss.js`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，将其保存为`Boss.js`。
- en: Set up the `Boss.js` file by extending the `enemy` class.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展`enemy`类设置`Boss.js`文件。
- en: Include `Boss.js` in your `main` script.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`脚本中包含`Boss.js`。
- en: Change all the properties that need to distinguish the boss from a lesser foe.
    This includes health, damage, speed, and even armor. Armor can be implemented
    as a damage reduction by overwriting the `receivedamage()` function.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改所有需要区分boss和普通敌人的属性。这包括生命值、伤害、速度，甚至护甲。护甲可以通过覆盖`receivedamage()`函数来实现伤害减少。
- en: Overwrite the `receivedamage()` function to make sure the end of the game is
    called when the boss dies. This GameEnd is explained in [Chapter 5](ch05.html
    "Chapter 5. Adding Some Advanced Features to Your Game"), *Adding Some Advanced
    Features to Your Game* so you can turn it off for now.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`receivedamage()`函数，确保在boss死亡时调用游戏结束。这个GameEnd在[第5章](ch05.html "第5章。为你的游戏添加一些高级功能")中有解释，*为你的游戏添加一些高级功能*，所以现在可以关闭它。
- en: Adapt the `projectile` entity so it also damages the `Boss` entity and not just
    the `enemy` entity.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`projectile`实体，使其也对`Boss`实体造成伤害，而不仅仅是对`enemy`实体。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we have been able to build our own top-down game from scratch.
    In order to do this, we have built levels with the ImpactJS Weltmeister and added
    a controllable character known as **player**. The game becomes more challenging
    by adding intelligent enemies and the weapons to defeat them. We were able to
    add some more depth to the game by introducing a friendly NPC. The final element
    was keeping score in order to provide the player with some feedback on how well
    he or she is doing.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够从头开始构建自己的俯视游戏。为了做到这一点，我们使用ImpactJS Weltmeister构建了关卡，并添加了一个可控制的角色，称为**player**。通过添加智能敌人和击败它们的武器，游戏变得更具挑战性。我们能够通过引入友好的NPC来为游戏增加一些深度。最后一个元素是保持得分，以便为玩家提供一些关于他或她表现如何的反馈。
