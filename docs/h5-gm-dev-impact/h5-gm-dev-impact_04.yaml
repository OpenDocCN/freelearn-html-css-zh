- en: Chapter 4. Let's Build a Side Scroller Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。让我们建立一个侧向滚动游戏
- en: In this chapter we will build a very basic side scroller game using both ImpactJS
    and Box2D. Box2D is an open source C++ physics engine. With it, the forces of
    gravity and friction are simulated like you would see in a game of Angry Birds.
    Although not perfectly integrated, but given enough effort, Box2D can be used
    within an ImpactJS game. Just like the previous chapter, a game will be built
    from the ground up. The main difference will be in the use of a physics engine
    and the side scroller game setting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用ImpactJS和Box2D构建一个非常基本的侧向滚动游戏。Box2D是一个开源的C++物理引擎。使用它，重力和摩擦力会被模拟，就像你在愤怒的小鸟游戏中看到的那样。虽然不是完全集成，但经过足够的努力，Box2D可以在ImpactJS游戏中使用。就像上一章一样，游戏将从头开始构建。主要区别在于使用物理引擎和侧向滚动游戏设置。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Side scroller game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧向滚动游戏
- en: Using Box2D with ImpactJS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Box2D与ImpactJS
- en: Building a side scroller level with the ImpactJS Weltmeister
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ImpactJS Weltmeister构建一个侧向滚动关卡
- en: Introducing a playable character
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个可玩的角色
- en: Adding some enemies to the side scroller
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在侧向滚动游戏中添加一些敌人
- en: Arming the player with bullets and bombs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家配备子弹和炸弹
- en: Making the enemy smarter with artificial intelligence
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用人工智能使敌人更聪明
- en: Creating items which can be picked up by the player
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建玩家可以拾取的物品
- en: Keeping score and adding points every time an enemy dies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持得分并在每次敌人死亡时添加分数
- en: Connecting two different side scroller levels
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接两个不同的侧向滚动关卡
- en: Ending the game with a strong foe
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以强大的敌人结束游戏
- en: The side scroller game setting
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧向滚动游戏设置
- en: A side scroller videogame is a game which is viewed from a side angle and the
    player generally moves from left to right while playing through a level. The screen
    basically scrolls to the side, whether it is from the left to the right or any
    other direction, hence the name, side scroller. Well known side scroller games
    are 2D Mario, Sonic, Donkey Kong, the old Mega Man, Super Nintendo and Gameboy
    Metroid games, and the ancient but successful Double Dragon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 侧向滚动视频游戏是一种从侧面角度观看的游戏，玩家通常在玩过程中从左到右移动。屏幕基本上是从一侧滚动到另一侧，无论是从左到右还是其他方向，因此得名侧向滚动。著名的侧向滚动游戏有2D马里奥、索尼克、大金刚、旧版洛克人、超级任天堂和Gameboy版的银河战士游戏，以及古老但成功的双战龙。
- en: Most games of this type feature a long level through which the hero needs to
    find his way by battling or avoiding monsters and death traps. On reaching the
    end of the level, there is usually no way back except for replaying that particular
    level from the start. Metroid was a slight oddity in this respect, since it was
    one of the first side scrollers to feature an enormous world you could explore
    just like you would in a standard Role-playing game (RPG). Metroid set the stage
    for a new way of thinking about side scrollers; you needed to find your way in
    any possible direction through virtual miles of caves and you would occasionally
    find yourself back at the starting point. Castlevania is another example of a
    side scrolling adventure game, this time using a medieval setting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的大多数游戏都有一个长的关卡，英雄需要通过战斗或避开怪物和死亡陷阱找到自己的路。到达关卡的结尾后，通常除了重新开始该关卡之外，没有其他回头的办法。《银河战士》在这方面有些奇怪，因为它是最早的侧向滚动游戏之一，拥有一个你可以像在标准角色扮演游戏（RPG）中一样探索的巨大世界。《银河战士》为侧向滚动游戏的新思维方式奠定了基础；你需要在虚拟的数英里长的洞穴中找到自己的路，偶尔会发现自己回到起点。《梦幻城堡》是另一个例子，这是一个使用中世纪背景的侧向滚动冒险游戏。
- en: '![The side scroller game setting](img/4568_4_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![侧向滚动游戏设置](img/4568_4_1.jpg)'
- en: Now that we have taken a look at what a side scroller is, let's get to building
    one with ImpactJS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了侧向滚动游戏是什么，让我们开始用ImpactJS构建一个。
- en: Preparing the game for Box2D
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Box2D准备游戏
- en: 'Before we can start in earnest, we need to make sure all files are correctly
    in position:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正式开始之前，我们需要确保所有文件都正确放置：
- en: Make a copy from the original ImpactJS downloadable folder we prepared in [Chapter
    1](ch01.html "Chapter 1. Firing Up Your First Impact Game"), *Firing Up Your First
    Impact Game*. Alternatively, you can again download a fresh one and also put it
    in your XAMPP server's `htdocs` directory. Give your folder a name; let's be totally
    original and call it `chapter4`. Any other name will be fine too.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们在[第1章](ch01.html "第1章。启动你的第一个Impact游戏")中准备的原始ImpactJS可下载文件夹中复制一份，*启动你的第一个Impact游戏*。或者，你也可以再次下载一个新的，并将其放在XAMPP服务器的`htdocs`目录中。给你的文件夹起一个名字；让我们完全原创，叫它`chapter4`。其他名字也可以。
- en: Download the physics demo from the ImpactJS website and go to its `plugins`
    folder. Here you should find the `Box2D` plugin. Create your own `plugins` folder
    and drop the `Box2D` extension there.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ImpactJS网站下载物理演示，并转到其`plugins`文件夹。在这里，你应该找到`Box2D`插件。创建你自己的`plugins`文件夹，并将`Box2D`扩展放在那里。
- en: Test if everything works so far by visiting `localhost/chapter4` in your browser.
    The **it works!** message should once again be waiting there for you.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在浏览器中访问`localhost/chapter4`来测试一切是否正常。**它正常工作！**消息应该再次等待着你。
- en: Additionally, we will need to change some Box2D core files. Box2D is not a product
    of ImpactJS but was invented for C++ based games before a JavaScript equivalent
    was developed. This JavaScript version was then integrated with ImpactJS by Dominic
    Szablewski (creator of ImpactJS). However, there are some flaws, one of them being
    faulty collision detection. Therefore, we will need to swap one of the original
    files with an adapted one that takes care of this problem. Take the `game.js`
    and `collision.js` scripts from the downloadable files for the `chapter4` folder
    and place them in your local `Box2D` folder. The `collision.js` script is with
    thanks to Abraham Walters who supplied the script.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要更改一些Box2D核心文件。Box2D不是ImpactJS的产品，而是在开发JavaScript等效版本之前为基于C++的游戏而发明的。然后，Dominic
    Szablewski（ImpactJS的创造者）将这个JavaScript版本与ImpactJS集成。然而，存在一些缺陷，其中一个是错误的碰撞检测。因此，我们需要用一个修正了这个问题的适应文件来替换其中一个原始文件。从可下载的`chapter4`文件夹中获取`game.js`和`collision.js`脚本，并将它们放在本地的`Box2D`文件夹中。`collision.js`脚本得益于提供该脚本的Abraham
    Walters。
- en: Copy the `chapter4` folder's media files to your local `media` folder.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chapter4`文件夹的媒体文件复制到本地的`media`文件夹中。
- en: We need to make an adaption to the main script. Our game will no longer be an
    extension of the standard Impact game class.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对主脚本进行调整。我们的游戏将不再是标准Impact游戏类的扩展。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead it will be an extension of the modified Box2D version. So make sure
    to change the following piece of code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，它将是修改后的Box2D版本的扩展。因此，请确保更改以下代码片段：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We require the Box2D `game` file in order to work with this extension, so include
    it at the beginning of the `main.js` script.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`main.js`脚本的开头包含Box2D的`game`文件才能使用这个扩展。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, in order to test whether everything is working fine, we will need to
    load in a level with a collision layer. This is because Box2D needs the collision
    layer to create its world environment and their boundaries. Without a level, you
    will come across an error, that looks like the following:![Preparing the game
    for Box2D](img/4568_4_2.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了测试一切是否正常，我们需要加载一个带有碰撞层的关卡。这是因为Box2D需要碰撞层来创建它的世界环境和边界。没有关卡，你将遇到一个错误，看起来像这样：![Preparing
    the game for Box2D](img/4568_4_2.jpg)
- en: To do this, copy the `testsetup.js` script from the `level` subfolder of the
    `chapter4` folder, and place it in your local `levels` folder. Add the level to
    your required files.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，从`chapter4`文件夹的`level`子文件夹中复制`testsetup.js`脚本，并将其放在本地的`levels`文件夹中。将关卡添加到所需的文件中。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Insert a `loadlevel()` function in the main script's `init()` method.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主脚本的`init()`方法中插入一个`loadlevel()`函数。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Reload the game in your browser and you should see the **it works!** message.
    Now you have seen it, you can delete it from your code. It is inside the main
    script's `draw()` method.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中重新加载游戏，你应该会看到**it works!**的消息。现在你已经看到了它，可以从代码中删除它。它在主脚本的`draw()`方法中。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great! We should now have everything ready to go. The first thing we will do
    is build a small level to have a playground of our own.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在应该已经准备就绪了。我们要做的第一件事是建立一个小关卡，以便有一个属于自己的游乐场。
- en: Building a side scroller level
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个横向滚动的关卡
- en: 'In order to build a level, we once again need to rely on the ImpactJS Weltmeister:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个关卡，我们再次需要依赖于ImpactJS Weltmeister：
- en: Open the Weltmeister in your browser `localhost/chapter4/Weltmeister.html`.
    We don't have any entities to play around with, so all that we will add for now
    is some graphics and a collision layer. This collision layer is especially important
    since the Box2D extension code will look for it and lack of it will crash the
    game. Suffice to say Box2D for ImpactJS is still in its infancy and minor bugs
    like this are to be expected.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开Weltmeister `localhost/chapter4/Weltmeister.html`。我们没有任何实体可以玩耍，所以现在我们要添加的只是一些图形和一个碰撞层。这个碰撞层特别重要，因为Box2D扩展代码将寻找它，缺少它将导致游戏崩溃。可以说，对于ImpactJS来说，Box2D仍处于起步阶段，这样的小bug是可以预料到的。
- en: Add a layer and name it `collision`; the Weltmeister will automatically recognize
    it as a collision layer.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个层并将其命名为`collision`；Weltmeister将自动识别它为碰撞层。
- en: Set its tilesize to `8` and the layer dimensions to `100 x 75`. We now have
    an 800 x 600 pixel canvas to play with.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其瓷砖大小设置为`8`，层尺寸设置为`100 x 75`。现在我们有一个800 x 600像素的画布可以使用。
- en: Now draw a box around the edges so we have a closed environment from which no
    entity can escape. This will be very important when gravity comes into play. Without
    a solid ground you will get some unintended results for sure.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在边缘画一个框，这样我们就有了一个封闭的环境，没有实体可以逃脱。当重力开始作用时，这将非常重要。没有坚实的地面，你肯定会得到一些意外的结果。
- en: Now add a new layer and call it `background`. We will use a single picture as
    background for this level.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个新的层，将其命名为`background`。我们将使用一张图片作为这个关卡的背景。
- en: Select the `church.png` file from the `media` folder as tileset. Our picture
    is 800 x 600 pixels so it should fit exactly in the area we created with our collision
    layer. Set the tilesize to `100` and the layer dimensions to `8 x 6`. Paint the
    picture of the church on the canvas.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`media`文件夹中选择`church.png`文件作为图块集。我们的图片是800 x 600像素，所以它应该恰好适合我们用碰撞层创建的区域。将瓷砖大小设置为`100`，层尺寸设置为`8
    x 6`。在画布上绘制教堂的图片。
- en: Save your level as `level1`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的关卡保存为`level1`。
- en: 'Great, we now have a basic level of our own. It is pretty empty though and
    some extra obstacles would be nice. Just follow the next steps to add some obstacles:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们现在有了一个基本的关卡。虽然它很空，但一些额外的障碍会很好。只需按照以下步骤添加一些障碍：
- en: Add another layer called `platforms`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个名为`platforms`的层。
- en: Use the `tiles.png` file as tileset. They are simple in design but will do just
    fine as the building blocks for any platform you like to construct. Set the tilesize
    to `8` and dimensions to `100 x 75`, exactly like the collision layer.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tiles.png`文件作为图块集。它们设计简单，但可以作为任何你想构建的平台的基本构件。将瓷砖大小设置为`8`，尺寸设置为`100 x 75`，与碰撞层完全相同。
- en: Turn on the option **link with collision layer** before you start painting the
    platforms. This way, you don't need to trace the platforms with your collision
    layer afterwards. If you don't want every part of a platform to be solid, you
    can, of course, temporarily turn off the link, paint the tiles, and turn it back
    on; the link is not made retrospectively.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始绘制平台之前，打开**与碰撞层链接**选项。这样，你就不需要事后用碰撞层追踪平台。如果你不希望平台的每个部分都是固体的，当然可以暂时关闭链接，绘制瓷砖，然后重新打开链接；链接不是事后建立的。
- en: Add a few floating platforms to the level; follow your heart's desire on what
    they should look like.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡中添加一些浮动平台；按照你的内心欲望来决定它们应该是什么样子。
- en: Save your level when you feel the stage is set.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你觉得舞台已经准备好时保存你的关卡。
- en: Add the level to the `require()` function of your `main.js` script.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将关卡添加到你的`main.js`脚本的`require()`函数中。
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Make sure that the level called `level1` is loaded at the beginning, instead
    of our `testsetup` level, by changing the `loadLevel()` function parameter.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在开始时加载名为`level1`的关卡，而不是我们的`testsetup`关卡，通过改变`loadLevel()`函数的参数。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Building a side scroller level](img/4568_4_3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个侧面滚动关卡](img/4568_4_3.jpg)'
- en: It is time to add a playable entity to the game so that we can discover the
    breathtaking level we have just created.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向游戏中添加一个可玩实体，这样我们就可以发现我们刚刚创建的令人惊叹的关卡了。
- en: The playable character
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可玩角色
- en: 'Since we are working with Box2D, we will not use the standard ImpactJS entity
    but the adapted version. Especially the way an entity moves in a Box2D world is
    what makes all the difference. In standard ImpactJS, this is the very straightforward
    process of moving your character image a few pixels in a certain direction. However,
    Box2D works with forces; so, in order to move, you need to overcome gravity and
    even air friction. But let''s start by setting up a basic entity:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用Box2D，我们将不使用标准的ImpactJS实体，而是使用适应版本。特别是实体在Box2D世界中移动的方式是使一切变得不同的地方。在标准的ImpactJS中，这是将你的角色图像沿着某个方向移动几个像素的非常简单的过程。然而，Box2D使用力；因此，为了移动，你需要克服重力甚至空气摩擦。但让我们先建立一个基本实体：
- en: Open a new JavaScript file and save it as `player.js` in the `entities` folder.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`entities`文件夹中的`player.js`。
- en: 'Add the basic Box2D entity code as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加基本的Box2D实体代码如下：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the term `entity` is an extension of the Box2D entity and, as
    such, requires the Box2D entity plugin file. Once again, make sure the naming
    conventions are respected or your player entity will not show up in Weltmeister.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，术语`entity`是Box2D实体的扩展，因此需要Box2D实体插件文件。再次确保遵守命名约定，否则你的玩家实体将不会出现在Weltmeister中。
- en: Add the `'game.entities.player'` parameter to the `main.js` script.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`'game.entities.player'`参数添加到`main.js`脚本中。
- en: If you were to visit your Weltmeister after making these modifications, you
    would find the player in your entity's layer. He doesn't represent much yet though;
    currently it is nothing more than an invisible square over which you don't have
    any control. Time to change his invisibility by adding an animation sheet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在进行这些修改后访问Weltmeister，你会发现玩家在你的实体层中。尽管目前它只是一个不可见的正方形，你无法控制它。是时候通过添加一个动画表来改变他的不可见性了。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the previous block of code, we gave the player a size and a name; but more
    importantly, we added graphics. The animation sheet contains just two images,
    one for the player standing idle and the second one for when the player flies.
    This is not much but it will suffice for a simple game. A side scroller game has
    a considerable advantage when it comes to its need for graphics. In theory, you
    only need two images to represent a character; that is, one for the character
    standing still and another one for the character in motion. For a top-down game
    you would need at least six images to accomplish the same thing. This is because,
    in addition to a side-view, you need an image of the back and the front of the
    character. Consequently, if you would add an animation for the player firing a
    bullet, this would result in an extra drawing for the side scroller but three
    for the top-down game. It's clear how a side scroller game is better, if you have
    only limited resources to get your graphics.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上面的代码块，我们给玩家指定了大小和名称；但更重要的是，我们添加了图形。动画表只包含两个图像，一个是玩家站立不动时的图像，另一个是玩家飞行时的图像。这并不多，但对于一个简单的游戏来说足够了。侧面滚动游戏在需要图形方面有相当大的优势。理论上，你只需要两张图像来代表一个角色；也就是说，一个是角色静止不动时的图像，另一个是角色在运动时的图像。而对于一个俯视游戏，你至少需要六张图像来完成同样的事情。这是因为，除了侧视图，你还需要一个角色背面和正面的图像。因此，如果你为玩家开火添加一个动画，这将导致侧面滚动游戏需要额外绘制一张图像，而俯视游戏需要三张图像。很明显，如果你只有有限的资源来获取你的图形，侧面滚动游戏更好。
- en: It's just great that we can now add our player to the game and he is actually
    visible, but we don't have any control over him yet.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将玩家添加到游戏中并且他实际上是可见的，但我们还没有对他有任何控制。
- en: Adding player control is done at two places, namely, the main and the player
    script. In the main script, add controls to the game's `init()` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制是在两个地方完成的，即主脚本和玩家脚本。在主脚本中，将控制添加到游戏的`init()`方法中。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the player script, we need to change our `update()` function so the player
    can react to our input commands.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家脚本中，我们需要改变我们的`update()`函数，这样玩家就可以对我们的输入命令做出反应。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In Box2D the entity has an extra property, a body. In order to move the body,
    we need to exert a force upon it. This is exactly what happens when we use the
    body's `ApplyForce()` method. We apply a force in a certain direction, so we actually
    use a vector. The use of vectors is what Box2D is all about. As long as we keep
    the right, left, or fly button pressed, the force is applied. However, when released,
    the entity doesn't stop immediately. No further force is applied but it takes
    a certain amount of time for the effects of the applied force to wear out; this
    is a big difference from the velocity we used in the previous chapters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Box2D中，实体有一个额外的属性，即身体。为了移动身体，我们需要对其施加力。这正是当我们使用身体的`ApplyForce()`方法时发生的事情。我们在某个方向上施加一个力，因此我们实际上使用一个向量。向量的使用正是Box2D的全部内容。只要我们保持右、左或飞行按钮按下，力就会被施加。然而，当释放时，实体并不会立即停止。不再施加进一步的力，但需要一定的时间来消耗施加力的效果；这与我们在前几章中使用的速度有很大的不同。
- en: 'If you add the player to the level, make sure he is somewhere on top of a platform
    in the top-left corner. The top-left corner is what will be visible by default
    and we don''t have an adaptable viewport to follow our player around just yet.
    To be precise, he doesn''t really need a platform to stand on just yet, since
    we have no gravity in our world. Let''s do something about that. Add the gravity
    property to your game in the `main.js` script as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把玩家添加到关卡中，确保他在左上角的某个平台上。左上角是默认可见的，我们还没有一个适应性视口来跟随我们的玩家。准确地说，他现在并不需要一个平台来站立，因为我们的世界没有重力。让我们解决这个问题。在`main.js`脚本中添加重力属性到你的游戏，如下所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's take our player for a test-flight shall we?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们带我们的玩家进行一次测试飞行，好吗？
- en: '![The playable character](img/4568_4_4.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![可玩角色](img/4568_4_4.jpg)'
- en: 'You might have noticed that even though he flies rather smoothly, any solid
    object our jetpack frog encounters will make him go into a spin. Probably you
    don''t actually want this to happen. This is especially annoying since he can
    end up with his head facing down, at which point his jetpack flame is facing upwards.
    Now with the jetpack flame facing upwards, it doesn''t make a lot of sense if
    activating the jetpack still results in an upwards thrust. Therefore, we need
    to do something about his stability. This can be done by fixing the body on the
    horizontal axis. Add the following code to the frog''s `update()` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，即使他飞行得相当顺利，我们的喷气背包青蛙遇到的任何固体物体都会使他旋转。也许你实际上不希望发生这种情况。特别是当他的头朝下时，他的喷气背包火焰朝上。现在，如果激活喷气背包仍然导致向上推力，那么喷气背包火焰朝上就没有太多意义。因此，我们需要解决他的稳定性问题。这可以通过在水平轴上固定身体来实现。将以下代码添加到青蛙的`update()`函数中：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the player's body is fixed at an angle of 0 degrees towards the x axis.
    Try changing it to 45; you now have a crazy frog, always flying with his body
    tilted to the right, even when facing to the left.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家的身体被固定在0度角朝向x轴。尝试将其更改为45；现在你有一个疯狂的青蛙，即使面向左，他的身体也始终向右倾斜飞行。
- en: 'We have a flying and steady frog now. Just too bad we can''t see him once we
    move a bit too far to the right or gravity takes us to the bottom of the level.
    It''s definitely time to introduce a following camera. To do this we need to make
    a modification to our game''s `update()` function as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个飞行和稳定的青蛙。只可惜当我们向右移动一点或重力把我们带到关卡的底部时，我们就看不到他了。现在绝对是引入一个跟随摄像头的时候了。为此，我们需要对游戏的`update()`函数进行修改，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The player is put in a local variable and its location is checked once per frame
    to update the screen's position. Because we subtract half of the viewport's size
    from the players position, our player is kept neatly in the center of the screen.
    Leaving out the subtraction will keep the player in the top-left corner of the
    screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家被放在一个局部变量中，并且每帧检查其位置以更新屏幕的位置。因为我们从玩家的位置中减去视口大小的一半，所以我们的玩家被整齐地保持在屏幕中央。如果不减去这部分，玩家将保持在屏幕的左上角。
- en: Save all the modifications and fly around the level you created; enjoy the peace
    and silence as much as you can because soon hostiles will stir up the place.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有修改并在你创建的关卡周围飞行；尽情享受宁静，因为很快敌对势力将搅乱这个地方。
- en: 'Let''s quickly recap what we have covered about the Box2D entity and how we
    can make a playable character with it. A Box2D entity is different from an ImpactJS
    entity, such that Box2D makes use of vectors to move around. A vector is a combination
    of direction and force:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们关于Box2D实体以及如何使用它制作可玩角色的内容。Box2D实体不同于ImpactJS实体，Box2D利用向量来移动。向量是方向和力的组合：
- en: Open a new JavaScript file and save it as `player.js`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`player.js`。
- en: Insert the standard Box2D entity extension code.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入标准的Box2D实体扩展代码。
- en: Include the player entity in the main script.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主脚本中包含玩家实体。
- en: Add animation to the player. Also make use of the `flip` property, which flips
    your image over a vertical axis and cuts the needed character graphics in half
    for a side scroller game.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家添加动画。还利用`flip`属性，它可以在垂直轴上翻转图像，并为侧向滚动游戏剪切所需的角色图形的一半。
- en: Add player controls which grant the ability to move left, right, and upwards.
    Notice how force is applied on the body in order for it to move. Once the input
    button is released and no more force is applied, the entity will proceed on course
    and completely stop, once the force is totally dissipated or he hits a solid wall.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加玩家控制，使其能够向左、向右和向上移动。注意力是如何施加在身体上以便移动的。一旦输入按钮被释放，不再施加力，实体将继续前进并完全停止，一旦力完全消散或者他撞到一个固体墙壁。
- en: Introduce gravity as a property of the game. As gravity is a constant downward
    force, it will drag everything down to the first solid object it encounters, unless
    a counter-force is provided. For our flying frog, his jetpack is his counter-force
    against gravity.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将重力引入游戏的属性。由于重力是一个不断向下的恒定力量，它会将一切拉向它遇到的第一个固体物体，除非提供一个相反的力。对于我们的飞行青蛙，他的喷气背包是对抗重力的反作用力。
- en: Our frog doesn't know how to fly a steady course just yet. Fix him to the horizontal
    axis so he doesn't go spinning every time he hits a solid object.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的青蛙目前还不知道如何稳定地飞行。将他固定在水平轴上，这样他每次撞到固体物体时就不会旋转。
- en: Finally, we need a camera to keep track of where we are going. Incorporate the
    automatically following camera in the game's `update()` function.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要一个摄像机来跟踪我们的位置。在游戏的`update()`函数中加入自动跟随摄像机。
- en: Adding a minor foe
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个小敌人
- en: 'We need some opposition, something we can shoot out of the sky once we have
    the weapons to do so. Therefore, let''s introduce some more frogs! Hostile ones
    this time:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些对手，一些我们可以在拥有武器后击落的东西。因此，让我们介绍一些更多的青蛙！这次是敌对的：
- en: Open a new file and save it as `enemy.js`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件，保存为`enemy.js`。
- en: Insert the following code into the file. It is the minimum code necessary to
    get a representation of our enemy in the Weltmeister. As such, it already includes
    the animation sheet.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码插入文件中。这是在Weltmeister中获得我们敌人表示所需的最小代码。因此，它已经包括了动画表。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Require the enemy entity in our `main.js` script.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`main.js`脚本中需要敌人实体。
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add an enemy to the level with the Weltmeister.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Weltmeister在关卡中添加敌人。
- en: Since our enemy is currently pretty defenseless, we could just knock him off
    a platform as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的敌人目前相当无助，我们也可以将他从平台上击落。
- en: '![Adding a minor foe](img/4568_4_5.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![添加一个小敌人](img/4568_4_5.jpg)'
- en: In normal ImpactJS code, we would have to set collision variables for this to
    happen, otherwise, the player and the enemy frog would just go straight through
    each other. In Box2D, this is not necessary as collision is automatically assumed
    and a force is applied on every movable object we hit with our flying frog.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的ImpactJS代码中，我们必须为此设置碰撞变量，否则玩家和敌人青蛙会直接穿过彼此。在Box2D中，这是不必要的，因为碰撞会自动假定，并且我们的飞行青蛙撞到每个可移动对象时都会施加力。
- en: Since we have gravity working, a great alternative for placing our enemies at
    a certain location is spawning them in at the top of the level. Add the `spawnEntity()`
    function in the game's `init()` function. An enemy will spawn there and gravity
    will drag it down to the bottom.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了重力，一个很好的替代方法是在关卡顶部生成敌人。在游戏的`init()`函数中添加`spawnEntity()`函数。敌人将在那里生成，并且重力会将其拉到底部。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make sure the `spawnEntity()` function is used after the level loads or an error
    occurs. Once the enemy has intelligence of its own, spawning enemies at the top
    of the level will make more sense. They will drop down, either to the very bottom
    or until they reach a platform, where they will wait for the player and attack
    it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`spawnEntity()`函数在关卡加载后使用，否则会出错。一旦敌人有了自己的智能，在关卡顶部生成敌人就会更有意义。它们会下落，要么落到最底部，要么直到它们到达一个平台，在那里它们会等待玩家并攻击它。
- en: We will turn our red frog into a really annoying creature once we provide him
    with some basic artificial intelligence. However, let's first prepare ourselves
    by adding some weapons to the game.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为红色青蛙提供了一些基本的人工智能，我们将把它变成一个真正讨厌的生物。然而，让我们首先通过向游戏添加一些武器来做好准备。
- en: 'Let''s briefly recap how we created our enemy:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下我们是如何创建我们的敌人的：
- en: Open a new JavaScript file and save it as `enemy.js`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，保存为`enemy.js`。
- en: Insert the standard Box2D entity extension, attach an animation sheet, and add
    animation sequences
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入标准的Box2D实体扩展，附加动画表，并添加动画序列
- en: Include the enemy entity in the main script
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主脚本中包含敌人实体
- en: Add an enemy to the level with the Weltmeister and the `spawnentity()` method
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Weltmeister和`spawnentity()`方法在关卡中添加敌人
- en: Introducing formidable weapons
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入强大的武器
- en: Weapons are great, especially if they are subjected to gravity or if they can
    apply some force to other entities. We will have a look at two types of weapons
    here, namely, the projectile and the bomb.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 武器很棒，特别是如果它们受到重力的影响，或者如果它们可以对其他实体施加一些力。我们将在这里看两种类型的武器，即抛射物和炸弹。
- en: Shooting a projectile
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发射抛射物
- en: 'The projectile will be our main weapon against the rival frogs, so let''s start
    by setting up the basics:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 抛射物将是我们对手青蛙的主要武器，所以让我们从设置基础开始：
- en: Open a new JavaScript file and save it as `projectile.js` in the `entities`
    folder.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，保存为`projectile.js`，放在`entities`文件夹中。
- en: 'Add the basic Box2D entity code with animation sheet and sequences as shown
    in the following code snippet:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段添加基本的Box2D实体代码，包括动画表和序列：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Apart from a name, size, and the necessary elements to perform the animation,
    we have already included a property called `lifetime`. Every projectile starts
    with a `lifetime` of `60`. We will make this drop and kill off the bullet when
    it reaches `0`. This way we don't get an overload of entities in a single game.
    Every entity needs its own calculations and having too many of them on screen
    at once might significantly drop the game's performance. Keeping track of this
    performance can be done using the ImpactJS debugger, which can be turned on by
    including the `'impact.debug.debug'` command, in the main script.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了名称、大小和执行动画所需的元素之外，我们已经包括了一个名为`lifetime`的属性。每个抛射物都以`60`的`lifetime`开始。当它达到`0`时，我们将使其消失并杀死子弹。这样我们就不会在一个游戏中得到过多的实体。每个实体都需要自己的计算，一次在屏幕上有太多实体可能会显著降低游戏的性能。可以使用ImpactJS调试器来跟踪这种性能，通过在主脚本中包含`'impact.debug.debug'`命令来打开它。
- en: Add the `game.entities.projectile` script to the `main.js` script.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`game.entities.projectile`脚本添加到`main.js`脚本中。
- en: We can now add projectiles to the game by using Weltmeister if we want. However,
    adding them manually is not of much use to us. Let's adapt the player's code instead
    so our frog can spawn the projectiles. First, bind the `'shoot'` state to a key
    in the main script.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过Weltmeister向游戏中添加抛射物。然而，手动添加对我们来说没有太大用处。让我们改变玩家的代码，这样我们的青蛙就可以生成抛射物。首先，在主脚本中将`'shoot'`状态绑定到一个键。
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then add the following code to the player's `update()` function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下代码添加到玩家的`update()`函数中。
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Spawning the projectile needs to be done at a certain location and it has to
    point in a specific direction, either left or right. We arbitrarily set the y
    coordinate of the spawnpoint as `6` pixels lower than our player's position; we
    can make this 10, 20, or 200 pixels as well. Though, in the case of the last option,
    it would look as if the bullet was spawned way below the player, which would be
    rather unusual. However, let's not forget that the player's position is always
    at the top-left corner of its image. Given that the height of our frog is 24 pixels,
    it will appear as if the bullet is spawned from the mouth, which is pretty cool
    for a frog. The x coordinate is another matter. If the frog is facing left, we
    don't adjust the spawn coordinate; if he's facing right, we adjust it by 6 pixels.
    The information about whether the player is flipped is not only used to adjust
    the spawn coordinate. It is also transferred to the projectile itself as an optional
    input parameter. Here it will be used to determine what side it should face and
    fly. While firing the bullet you might notice the frog being kicked back a little,
    not unlike the recoil of a gun. This is because the frog initially occupies a
    space the bullet comes to occupy, when spawned. If you want to avoid this cool
    effect, all you need to do is spawn the bullet a bit farther away from the frog.
    If you were to load the game at this point, you would notice your bullet spawns
    but doesn't fly away. That is because we didn't tell the bullet to do so whenever
    it comes into existence.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 生成弹丸需要在特定位置完成，并且必须指向特定方向，要么向左，要么向右。我们任意地将生成点的y坐标设置为比我们的玩家位置低6像素；我们也可以将其设置为10、20或200像素。不过，在最后一种情况下，子弹看起来会生成在玩家下方，这会显得相当不寻常。不过，我们不要忘记玩家的位置总是在其图像的左上角。鉴于我们的青蛙的高度为24像素，看起来就好像子弹是从嘴里射出来的，这对于一只青蛙来说相当酷。x坐标是另一回事。如果青蛙面向左，我们不调整生成坐标；如果他面向右，我们将其调整6像素。有关玩家是否翻转的信息不仅用于调整生成坐标。它还作为一个可选的输入参数传递给弹丸本身。这里将用它来确定它应该面向和飞向哪一边。在发射子弹时，你可能会注意到青蛙被击退了一点，有点像枪的后坐力。这是因为青蛙最初占据了子弹生成时的位置。如果你想避免这种酷炫的效果，你只需要让子弹离青蛙远一点。如果你此时加载游戏，你会注意到你的子弹生成了，但没有飞走。这是因为我们没有告诉子弹在生成时应该这样做。
- en: Adding the following two lines of code to the projectile's `init()` function
    will rectify this situation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两行代码添加到弹丸的`init()`函数中将纠正这种情况。
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Upon spawning the projectile we now apply an impulse instead of a force. There
    is a significant difference between the `ApplyImpulse()` and `ApplyForce()` functions.
    While the `ApplyForce()` function applies a constant force on the body, the `ApplyImpulse()`
    function only applies it once, but abruptly. You could compare it to pushing a
    rock versus running up to it and slamming into it with your full force and all
    the momentum you gathered. A bullet in real life works the same way as we try
    to simulate it here; it is flung away by a small explosion and never pushed again
    thereafter. The local variable, `var.velocity`, is there to adapt the bullet's
    direction in the same way the animation depends on the value of the `settings.flip`
    parameter. If the value of the `flip` property is false, the bullet will be facing
    right and flying to the right. If the value of the `flip` property is true, the
    animation is flipped, making it face left. Because the velocity then takes a negative
    number, the bullet also flies to the left.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成弹丸时，我们现在应用的是冲量而不是力。`ApplyImpulse()`和`ApplyForce()`函数之间存在显著的区别。`ApplyForce()`函数在物体上施加一个恒定的力，而`ApplyImpulse()`函数只施加一次，但是突然。你可以将其比作推动一块石头与跑向它并用你所有的力量和动量撞击它。现实生活中的子弹与我们在这里尝试模拟的方式相同；它被一个小爆炸甩开，之后再也没有被推动。局部变量`var.velocity`用于调整子弹的方向，就像动画取决于`settings.flip`参数的值一样。如果`flip`属性的值为false，子弹将面向右并向右飞行。如果`flip`属性的值为true，动画将翻转，使其面向左。因为速度取负数，子弹也会向左飞行。
- en: We could still adapt our impulse on the y axis which is currently set at `0`.
    Putting a negative number will make our frog shoot upwards like an anti-air gun.
    A positive number will make him shoot downwards like a bomber. Try playing around
    with this to see the effects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以调整y轴上的冲量，目前设置为`0`。输入一个负数将使我们的青蛙向上射击，就像一门防空炮。输入一个正数将使他向下射击，就像一架轰炸机。尝试调整这个值，看看效果。
- en: Our projectiles are still lingering around, cluttering the screen, because we
    haven't put our `lifetime` property to good use yet.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的弹丸仍然在屏幕上徘徊，因为我们还没有充分利用我们的`lifetime`属性。
- en: Let's modify the `update()` function in order to limit the lifespan of our bullets.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`update()`函数，以限制我们子弹的寿命。
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Every time the game goes through the update loop, which is once per frame, the
    remaining lifetime of the projectile is shortened by 1\. Given a total lifetime
    value of 60 in a 60 frames per second game, the bullet has 1 second to live after
    being spawned.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每当游戏通过更新循环，也就是每帧一次，弹丸的剩余寿命就会减少1。在每秒60帧的游戏中，给定一个总寿命值为60，子弹在生成后有1秒的寿命。
- en: We can shoot at our enemies with it and actually push them away with the force
    of the bullet, but we don't really damage them yet. For this to happen we need
    to check if we hit an enemy.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它向敌人射击，并且实际上用子弹的力量将他们推开，但我们还没有真正伤害到他们。要实现这一点，我们需要检查是否击中了敌人。
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Adding this modified `check()` function, which will make the projectile deal
    damage before killing itself, is not enough. Even though collision is automatically
    handled by Box2D, the parameters necessary for a `check()` function to work are
    not. We need to do a few more things:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个修改后的`check()`函数，这将使弹丸在自毁之前造成伤害，是不够的。尽管碰撞是由Box2D自动处理的，但`check()`函数工作所需的参数并没有。我们需要做一些其他的事情：
- en: 'Tell the enemy it is a type B entity by adding the `TYPE` property as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`TYPE`属性，告诉敌人它是B型实体。
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Make the projectile check for collision with type B entities using the `checkAgainst`
    property.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`checkAgainst`属性使抛射物检查与B类型实体的碰撞。
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now save and reload the game. You can now kill those nasty red frogs.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存并重新加载游戏。你现在可以杀死那些讨厌的红色青蛙了。
- en: Try making your player a type B entity. Your bullets will now kill you. This
    is because we made them spawn in a space already occupied by our frog. As we have
    seen before, this is also the reason why we have this recoil effect upon firing
    a bullet. However, this time it's more than recoil; it can actually kill the player.
    So we better not make our player a type B entity or we should spawn our bullet
    a bit farther away and lose the recoil effect. It's great to have something to
    defend ourselves with, even if the other frogs don't pose much of a threat just
    yet. Before bringing them to life, we are shortly going to have a look at something
    more explosive, a bomb.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将你的玩家设为B类型实体。现在你的子弹会杀死你。这是因为我们让它们生成在我们的青蛙已经占据的空间中。正如我们之前看到的，这也是为什么我们在发射子弹时有这种后坐力效应的原因。然而，这次不仅仅是后坐力；它实际上可以杀死玩家。所以我们最好不要让我们的玩家成为B类型实体，或者我们应该让我们的子弹生成得离得更远，失去后坐力效应。拥有一些可以自卫的东西是很好的，即使其他青蛙现在还不构成太大的威胁。在让它们活过来之前，我们很快要看一下更爆炸性的东西，一个炸弹。
- en: 'Before moving on to the bomb, let''s again have a quick look at how we introduced
    our main weapon, the bullet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向炸弹之前，让我们再快速看一下我们是如何引入我们的主要武器——子弹的：
- en: We need guns, lots of them.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要枪，很多枪。
- en: Open a new JavaScript file and save it as `projectile.js`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`projectile.js`。
- en: Insert the standard Box2D entity extension, attach an animation sheet, and add
    animation sequences. Also add a `lifetime` property, which will keep track of
    how much longer the bullet should stay in the game.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入标准的Box2D实体扩展，附加一个动画表，并添加动画序列。还添加一个`lifetime`属性，用来跟踪子弹在游戏中应该停留多久。
- en: Include the projectile entity in the main script.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主脚本中包含抛射实体。
- en: Add a key bind to the shoot input state in the main script.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主脚本中为射击输入状态添加一个键绑定。
- en: Make our flying frog spawn a projectile when the player clicks on the shoot
    button.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家点击射击按钮时，让我们的飞行青蛙产生一个抛射物。
- en: Add an impulse to the bullet so it can actually fly instead of just dropping
    to the ground.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给子弹添加一个冲量，这样它就可以真正飞起来，而不仅仅是掉到地上。
- en: Check how long the bullet is in the air and kill it off if it exceeds its preset
    lifespan.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查子弹在空中的时间，并在超过预设寿命时将其销毁。
- en: Let the bullet check for enemies. If it encounters an enemy, it should deal
    damage and kill itself.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让子弹检查敌人。如果遇到敌人，它应该造成伤害并自杀。
- en: Try making the bullet kill the player but don't keep it that way.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试让子弹杀死玩家，但不要保持这种状态。
- en: Building an actual bomb
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制造一个真正的炸弹
- en: 'The basics for making a bomb are the same as for the projectile, indeed, they
    are the same as for creating any entity:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 制造炸弹的基础与制造抛射物的基础相同，实际上，它们与创建任何实体的基础相同：
- en: Open a new JavaScript file and save it as `bomb.js` in the `entities` folder
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`bomb.js`在`entities`文件夹中
- en: 'Add the basic Box2D entity code with the animation sheet and sequences as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加基本的Box2D实体代码，动画表和序列如下：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This time we already gave our bomb a type and a type to check against for inflicting
    damage
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们已经给我们的炸弹一个类型和一个用于造成伤害的检查类型
- en: Put the `game.entities.bomb` parameter as a required entity into the `main.js`
    script
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`game.entities.bomb`参数作为所需实体放入`main.js`脚本
- en: We now have a bomb we can put anywhere in the level we want to. We can add some
    bombs close to the ceiling of our level so they would fall down at level load.
    That would be great, given there would be an actual explosion. We are going to
    introduce that explosion as a separate method that only our bomb can use.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个炸弹，我们可以把它放在任何我们想要的关卡中。我们可以在我们的关卡天花板附近添加一些炸弹，这样它们在关卡加载时会掉下来。那将是很棒的，因为会有一个真正的爆炸。我们将把这个爆炸作为一个单独的方法引入，只有我们的炸弹才能使用。
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Just like the `init()`, `update()`, and `check()` methods, we now insert the
    `explosion()` method into the bomb entity so it will be able to use it henceforth.
    The `explosion()` method takes in five parameters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`init()`、`update()`和`check()`方法一样，我们现在将`explosion()`方法插入到炸弹实体中，以便它今后能够使用。`explosion()`方法接受五个参数：
- en: '**Minimum blast-zone**: If an entity is closer than this distance, he will
    not be hit. This doesn''t make a lot of sense for bombs, except that it allows
    you to use several blasts in one bomb. This in turn makes it possible to have
    higher damage when the target is closer to the bomb and lower damage when he is
    farther away.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最小爆炸区域**：如果一个实体距离比这更近，他将不会受到影响。这对于炸弹来说并没有太多意义，除非它允许你在一个炸弹中使用几次爆炸。这反过来又使得在目标靠近炸弹时造成更大的伤害，而在目标远离炸弹时造成更小的伤害成为可能。'
- en: '**Maximum blast-zone**: Everything farther away than the maximum blast-zone
    will not be affected by the explosion.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大爆炸区域**：距离最大爆炸区域以外的一切都不会受到爆炸的影响。'
- en: '**Blast damage**: This is the damage an entity will receive if it is within
    the blast-zone.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**爆炸伤害**：这是实体在爆炸区域内会受到的伤害。'
- en: '**Blastforcex**: This is the impulse on the x axis that will be applied to
    the affected entity. It will decide how far the target will fly to the right or
    left.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Blastforcex**：这是应用于受影响实体的x轴冲量。它将决定目标会向右或向左飞多远。'
- en: '**Blastforcey**: This is the impulse on the y axis that will be applied to
    the affected entity. It would determine how high the target will fly. Obviously,
    if the target is below the bomb when it explodes, it will push the target downwards,
    not upwards.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Blastforcey**：这是应用于受影响实体的y轴冲量。它将决定目标会飞多高。显然，如果目标在炸弹下方爆炸，它会将目标向下推，而不是向上。'
- en: The `explosion()` method works in the following manner. All entities are copied
    to a local variable. The entities are then checked one after the other to see
    what their distance from the bomb is. The distance is calculated as Euclidean
    distance here. While calculating the Euclidean or ordinary distance, you apply
    the Pythagorean formula. This formula states that, the length of any side of a
    triangle with a 90 degree angle can be calculated if the length of the other two
    sides is known. The formula is *a² + b² = c²*, with *c* being the longest side
    of the triangle. Depending on whether the hapless target is situated to the right
    or left, above or below the bomb, the direction of the force is adjusted. Finally,
    the function checks if the distance is within the limits of the blast-zone. If
    this is the case, a damage and an impulse are applied on the target. At this point
    either the entity dies or goes flying through the air; either way it's not good
    news.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`explosion()` 方法的工作方式如下。所有实体都被复制到一个本地变量中。然后依次检查这些实体，看看它们距离炸弹有多远。这里计算的距离是欧几里得距离。在计算欧几里得距离或普通距离时，你应用毕达哥拉斯定理。这个定理规定，如果已知三角形的另外两边的长度，就可以计算出一个直角三角形的任意一边的长度。公式是
    *a² + b² = c²*，其中 *c* 是三角形的最长边。根据不幸的目标是位于炸弹的右侧还是左侧，上方还是下方，力的方向会进行调整。最后，函数检查距离是否在爆炸区域的范围内。如果是这样，就对目标施加伤害和冲量。在这一点上，实体要么死亡，要么飞向空中；无论哪种情况都不是好消息。'
- en: Simply adding this `explosion()` method will do no good until we actually use
    it. Therefore, we need to modify our `update()` method so we can blow up our bomb
    at the end of its lifespan.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅添加这个 `explosion()` 方法是没有用的，直到我们真正使用它。因此，我们需要修改我们的 `update()` 方法，以便在炸弹寿命结束时引爆我们的炸弹。
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The lifespan part works exactly like it did in the projectile. However, in this
    case we don't merely call the `kill()` function, we use our newly developed explosion
    twice. We could just call the function once and put the blast-range value between
    0 and 200\. As mentioned earlier, the advantage we have now is the division between
    high damage and pressure close to the bomb, and low damage and pressure farther
    away. Technically, we can use as many explosions as we like; each one of them
    requires calculation time. Though, it's up to you on how much division you want.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 寿命部分的工作方式与弹丸中的方式完全相同。然而，在这种情况下，我们不仅仅调用 `kill()` 函数，而是使用我们新开发的爆炸两次。我们可以只调用一次函数，并将爆炸范围值设置在
    0 到 200 之间。正如前面提到的，我们现在的优势在于高伤害和靠近炸弹的压力之间的区分，以及低伤害和远离炸弹的压力。从技术上讲，我们可以使用任意数量的爆炸；每一个都需要计算时间。不过，你可以决定你想要多少个爆炸。
- en: Before you actually get to testing this explosion in your game, make sure to
    attribute health to all your entities. Whether they will survive the damage of
    the blast or not will depend on whether you have given them enough health. Since
    the default value is set at 10, they will not fly away, but die instantly if the
    previous numbers are used. So let's give our player and enemies a health value
    of 100 by adding this property before their respective `init()` functions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际测试游戏中的爆炸之前，确保为所有实体分配健康值。它们是否能够承受爆炸的伤害将取决于你是否给予它们足够的健康值。由于默认值设置为 10，它们将不会飞走，而是立即死亡，如果使用前面的数字。因此，让我们通过在它们各自的
    `init()` 函数之前添加此属性来给我们的玩家和敌人一个健康值为 100。
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As a final touch we can make the bomb explode when it comes into contact with
    one of our hostile frogs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的修饰，我们可以让炸弹在接触到敌对青蛙之一时爆炸。
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We already made sure the bomb checks for contact with entities of type B by
    setting the `checkAgainst` property. The direct damage of getting this piece of
    metal on the face is set at `30`. This is followed by the explosion itself, which
    will deal damage worth 70 points because the enemy is so close. The second blast
    wave affects everything farther away before the bomb finally kills itself.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确保炸弹通过设置 `checkAgainst` 属性检查与 B 类型实体的接触。直接受到这块金属的伤害设置为 `30`。这之后是爆炸本身，它将造成
    70 分的伤害，因为敌人离得很近。第二波爆炸影响到更远的一切，然后炸弹最终自毁。
- en: 'Now we have a bomb that can be put anywhere in the level and will do just fine.
    However, it would be even better if our player could spawn one himself. In the
    following steps, we simply repeat what we did with the projectile to make the
    player spawn a bomb by himself:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以放置在关卡中任何位置并且效果很好的炸弹。然而，如果我们的玩家自己也能生成一个炸弹，那就更好了。在接下来的步骤中，我们简单地重复了我们在弹丸中所做的操作，使玩家自己生成一个炸弹：
- en: 'Assign a keyboard button to your bomb input state as shown in the following
    line of code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个键盘按钮分配给炸弹输入状态，如下行代码所示：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Change the player''s `update()` function so the player can now spawn bombs
    with the help of the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改玩家的 `update()` 函数，以便玩家现在可以使用以下代码生成炸弹：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The spawn coordinates defined here are different from what we did with the projectile.
    The `y` coordinate is very important; it is set at `25` because our flying frog
    has a height of `24` pixels. This way the bomb is always spawned just beneath
    the flying frog.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里定义的生成坐标与我们在弹丸中所做的不同。 `y` 坐标非常重要；它设置为 `25`，因为我们的飞行青蛙的高度为 `24` 像素。这样炸弹总是生成在飞行青蛙的正下方。
- en: Add the following line of code to the bomb's `init()` function so it takes the
    `flip` parameter to know which side to face when spawned.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到炸弹的 `init()` 函数中，以便它接受 `flip` 参数，以知道生成时应该面向哪一侧。
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save, reload, and bomb the hell out of those red frogs! Watch out though, bombs
    can kill you too.![Building an actual bomb](img/4568_4_6.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存、重新加载，并炸掉那些红色的青蛙！不过要小心，炸弹也可能杀死你。![Building an actual bomb](img/4568_4_6.jpg)
- en: 'The bomb is our greatest weapon; let''s have a quick recap on how we built
    it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 炸弹是我们最大的武器；让我们快速回顾一下我们是如何构建它的：
- en: Open a new JavaScript file and save it as `bomb.js`.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个新的 JavaScript 文件，并将其保存为 `bomb.js`。
- en: Insert the standard Box2D entity extension, attach an animation sheet, and add
    animation sequences. Add a lifespan property that will keep track of how much
    time is left until the bomb explodes, if not detonated prematurely by touching
    an enemy.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入标准的Box2D实体扩展，附加动画表，并添加动画序列。添加一个寿命属性，用于跟踪炸弹爆炸前剩余的时间，如果没有被触碰敌人而过早引爆。
- en: Include the bomb entity in the main script.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主脚本中包括炸弹实体。
- en: Add a bomb to the level.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关卡中添加一个炸弹。
- en: Introduce the `explosion()`method; it is a custom function which simulates the
    damage and force effects of an explosion.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`explosion()`方法；这是一个自定义函数，模拟爆炸的伤害和力量效果。
- en: Change the `update()` function so it will make the bomb explode when its time
    is up.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`update()`函数，使炸弹在时间到时爆炸。
- en: Use the `check()` function to detect collision with an enemy and detonate immediately.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`check()`函数检测与敌人的碰撞并立即引爆。
- en: Assign a keyboard shortcut to fire bombs.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为炸弹分配一个键盘快捷键。
- en: Adjust the player's `update()` function so a bomb is spawned when the player
    commands it to do so.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整玩家的`update()`函数，使玩家命令时会生成一个炸弹。
- en: Make the bomb flip to the direction the player is looking at.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使炸弹翻转到玩家所看的方向。
- en: Mess around and have fun blowing frogs to bits!
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩得开心，尽情地炸青蛙！
- en: Artificial intelligence
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能
- en: It is time to make our red frogs a bit smarter so they stand at least a tiny
    chance against our newly developed weapons arsenal. In [Chapter 3](ch03.html "Chapter 3. Let's
    Build a Role Playing Game"), *Let's Build a Role Playing Game*, we did this completely
    by the book, by separating decisions from behavior. We made a separate Artificial
    Intelligence (AI) file for decision making, and—as always—the actual behavior
    is in the entity's `update()` function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让我们的红色青蛙变得更聪明一点，这样他们至少有一点机会对抗我们新开发的武器库。在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")中，*让我们建立一个角色扮演游戏*，我们完全按照书本上的方法做到了这一点，通过将决策与行为分开。我们为决策制定了一个单独的人工智能（AI）文件，而实际行为始终在实体的`update()`函数中。
- en: This time around, we will keep it very simple and put all AI directly in the
    enemy's `update()` method. This will demonstrate that even a simple AI can seem
    to act pretty smart.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将保持非常简单，直接将所有人工智能放在敌人的`update()`方法中。这将证明，即使是简单的人工智能也可以看起来相当聪明。
- en: 'Let''s modify our enemy''s `update()` function with the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下代码修改我们的敌人的`update()`函数：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Inserting this function into your enemy entity will make him try to catch the
    player. But how does it work? First, the player entity is saved in the function's
    local variable called `player`. Both the horizontal distance and the vertical
    distance between the enemy and the player are calculated. The `sign` variable
    is used to determine whether the frog should fly to the left or the right. He
    will always fly upwards; if he needs to come down because the player is below
    him, he will just let gravity do its work. While flying, the fly animation is
    active, otherwise the idle animation is used, even while moving horizontally.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数插入到敌人实体中，将使他试图抓住玩家。但它是如何工作的呢？首先，玩家实体保存在函数的本地变量中，称为`player`。计算敌人和玩家之间的水平距离和垂直距离。`sign`变量用于确定青蛙应该向左飞还是向右飞。他总是向上飞；如果他需要下降，因为玩家在他下面，他将让重力发挥作用。在飞行时，飞行动画是活动的，否则使用空闲动画，即使在水平移动时也是如此。
- en: The frog's body is fixed to the x axis to prevent him from spinning, as is the
    case with the player. Finally the animation is flipped to the left or right, depending
    on where the player is relative to the enemy.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 青蛙的身体固定在x轴上，以防止他旋转，就像玩家一样。最后，根据玩家相对于敌人的位置，动画会翻转到左侧或右侧。
- en: 'We now have a frog that will follow us around if we are close enough to him.
    Now we need him to do some damage to the player:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一只青蛙，如果我们离他足够近，他会跟着我们走。现在我们需要他对玩家造成一些伤害：
- en: 'Make sure the type of the enemy and the type it needs to check for are filled
    out as B and A respectively. Also introduce a new enemy property called `cooldowncounter`,
    as shown in the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保敌人的类型和需要检查的类型分别填写为B和A。还引入一个名为`cooldowncounter`的新敌人属性，如下所示：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `cooldowncounter` property will keep track of how many frames have passed
    since the last time the frog was able to deal damage.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cooldowncounter`属性将跟踪自上次青蛙能够造成伤害以来经过了多少帧。'
- en: 'The `cooldowncounter` property must count, therefore add it to the `update()`
    function:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cooldowncounter`属性必须计数，因此将其添加到`update()`函数中：'
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Extend the `check()` function so it checks whether enough frames have passed
    since the last attack and allow the frog to attack if this is the case, as shown
    in the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`check()`函数，以检查自上次攻击以来是否已经过了足够的帧数，并允许青蛙进行攻击，如下所示：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The frog will now be able to use its nasty melee attacks upon the player. The
    attack, whatever done by the frogs at a close range, will lower the player's health
    by a value of 10 every time it hits the player. The player will certainly need
    to avoid these nasty creatures now if he doesn't want to lose health quickly.
    We will need to give the player something extra that allows him to survive this
    carnage.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 青蛙现在将能够在玩家身上使用其恶毒的近战攻击。无论青蛙在近距离对玩家造成的攻击是什么，每次击中玩家都会降低玩家的健康值10点。现在玩家肯定需要避开这些恶毒的生物，以免健康值迅速下降。我们需要给玩家一些额外的东西，让他能够在这场屠杀中生存下来。
- en: 'AI is what makes the enemy worth fighting against. Unlike what we mentioned
    in [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role Playing Game"), *Let''s
    build a Role Playing Game*, it does not always need to become a complicated matter
    though. Let''s have a quick look at how we implemented AI for the side scroller:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能是使敌人值得对抗的原因。与我们在[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")中提到的不同，*让我们建立一个角色扮演游戏*，它并不总是需要变得复杂。让我们快速看一下我们如何为横向滚动游戏实现了人工智能：
- en: Change the `update()` function so the enemy can now fly towards the player.
    This new `update()` function is the AI of the enemy frog. As opposed to [Chapter
    3](ch03.html "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role
    Playing Game*, both decision and behavior are wrapped in a single piece of code
    this time around.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`update()`函数，使敌人现在可以朝着玩家飞行。这个新的`update()`函数是敌人青蛙的人工智能。与[第3章](ch03.html "第3章。让我们建立一个角色扮演游戏")中的*让我们建立一个角色扮演游戏*不同，这次决策和行为都包含在同一段代码中。
- en: Introduce a cool down counter that keeps track of the number of frames since
    the last attack happened. Also make sure the enemy entity is of type B and checks
    whether it touches type A entities. The player should be a type A entity.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个冷却计数器，用于跟踪自上次攻击以来的帧数。还要确保敌人实体是B类型，并检查它是否接触到A类型的实体。玩家应该是A类型的实体。
- en: Make the `cooldown` property add a value of 1 for every frame that passes, by
    adding it to the modified `update()` function.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将其添加到修改后的`update()`函数中，使`cooldown`属性在每帧过去时增加1的值。
- en: Incorporate the attack in the `check()` function so the frog becomes a force
    to be reckoned with.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`check()`函数中加入攻击，使青蛙成为不可忽视的力量。
- en: Pickup items
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拾取物品
- en: Our tiny flying frog can now officially be killed by those nasty red frogs.
    This is not good news for him and it is up to us to provide a way to replenish
    the lost health. This is done by the use of pickup items, that is, entities which
    will disappear upon touching the player, but grant beneficial effects in the process.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小飞行青蛙现在正式可以被那些讨厌的红色青蛙杀死。这对他来说不是好消息，我们需要提供一种方式来补充失去的健康。这是通过使用拾取物品来实现的，也就是，当接触到玩家时会消失但在过程中提供有益效果的实体。
- en: Before we add an actual pickup item, which will come in the form of a health
    replenishing crate, let's first add a normal crate to the game.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加实际的拾取物品之前，它将以补充健康的板条箱的形式出现，让我们先在游戏中添加一个普通的板条箱。
- en: Adding a normal crate
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个普通板条箱
- en: 'Our crate will function as a prototype to all types of crates we could invent.
    To create the crate, perform the following steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的板条箱将作为我们可以发明的所有类型的板条箱的原型。执行以下步骤创建板条箱：
- en: Open a new file and save it as `crate.js`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件并将其保存为`crate.js`。
- en: Add the crate code to the file.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将板条箱代码添加到文件中。
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code is really straightforward since the crate is nothing but a lifeless
    object. A tough lifeless object though, since it has a health value of `2000`.
    By giving the crate so much health, it is able to survive multiple bomb explosions.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码非常简单，因为板条箱只是一个无生命的物体。尽管是一个坚固的无生命物体，因为它的健康值为`2000`。通过给予板条箱如此多的健康，它能够经受住多次炸弹爆炸。
- en: Save the file and add some to your game with the Weltmeister. Certainly try
    stacking a few of them before unleashing an explosion in their midst.![Adding
    a normal crate](img/4568_4_8.jpg)![Adding a normal crate](img/4568_4_9.jpg)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在Weltmeister中添加一些到你的游戏中。当然，在释放爆炸之前，试着堆叠几个板条箱。![添加一个普通板条箱](img/4568_4_8.jpg)![添加一个普通板条箱](img/4568_4_9.jpg)
- en: Now we have the standard crate; making a healing crate is only a few steps away,
    since we will build it upon our normal crate.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了标准的板条箱；制作一个治疗板条箱只需要几个步骤，因为我们将在普通板条箱的基础上构建它。
- en: 'Before taking a look at our healing crate, let''s quickly see how we made the
    normal crate:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在看看我们的治疗板条箱之前，让我们快速看看我们是如何制作普通板条箱的：
- en: Create a new file and save it as `crate.js`
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新文件并将其保存为`crate.js`
- en: Implement a standard Box2D entity code
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现标准的Box2D实体代码
- en: Save and add some crates to the game using the Weltmeister
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存并使用Weltmeister向游戏中添加一些板条箱
- en: Implementing a healing crate
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个治疗板条箱
- en: 'Now we have our basic prototype crate, we only need to build upon it in order
    to create the health crate. To build the health crate perform the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的原型板条箱，我们只需要在其基础上构建，以创建健康板条箱。执行以下步骤来构建健康板条箱：
- en: Open a new file and save it as `crate.js`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件并将其保存为`crate.js`。
- en: 'Add the `healthcrate` specific code to it. The health crate is an extension
    of the normal crate, not a Box2D entity; therefore, we only need to point out
    where the health crate differs from the normal one:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其添加`healthcrate`特定的代码。健康板条箱是普通板条箱的扩展，不是一个Box2D实体；因此，我们只需要指出健康板条箱与普通板条箱的区别所在：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It has another name and animation sheet. In addition it will heal the player
    and destroy itself after healing the player.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有另一个名称和动画表。此外，它将治疗玩家并在治疗玩家后销毁自己。
- en: Add the crate to the main script using the following code, so your game knows
    it's there.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将板条箱添加到主脚本中，这样你的游戏就知道它在那里。
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Save and add a crate to the game to check out its effects.![Implementing a healing
    crate](img/4568_4_10.jpg)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并添加一个板条箱到游戏中以查看其效果。![实现一个治疗板条箱](img/4568_4_10.jpg)
- en: This crate heals the player by providing him a **health** value of **100**,
    as shown in the following screenshot. Thus, the player will always end up with
    more health than he started the game with. This is just a choice; you could always
    change this by implementing a health cap so as to make sure healing can't make
    the player stronger than he initially was.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个板条箱通过提供**100**的**健康**值来治疗玩家，如下截图所示。因此，玩家的健康值总是比游戏开始时更高。这只是一个选择；你可以通过实现健康上限来改变这一点，以确保治疗不会使玩家比初始状态更强大。
- en: '![Implementing a healing crate](img/4568_4_12.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![实现一个治疗板条箱](img/4568_4_12.jpg)'
- en: Remember you can always open Firefox with the Firebug add-on and look for the
    player properties in **Document Object Model** (**DOM**). Before picking up the
    crate, our player had a health value of 100 and it rose to a value of 200 after
    he picked up the crate.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你可以随时用带有Firebug附加组件的Firefox打开并查找**文档对象模型**（**DOM**）中的玩家属性。在拾取板条箱之前，我们的玩家的健康值为100，拾取后上升到200。
- en: 'The healing crate is somewhat more sophisticated than the normal one. Let''s
    once again have a look at the steps we took to make a healing crate:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 治疗板条箱比普通板条箱要复杂一些。让我们再次看看我们制作治疗板条箱所采取的步骤：
- en: Create a new file and save it as `healthcrate.js`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新文件并将其保存为`healthcrate.js`。
- en: Extend the previously built crate instead of a Box2D entity. Only add the parameters
    on which the health crate will differ from the original one. This includes a `check()`
    function to see if it has been touched by the player.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展先前构建的生命箱，而不是一个Box2D实体。只添加健康箱与原始箱不同的参数。这包括一个`check()`函数，用于查看玩家是否触摸到它。
- en: Save and add a crate to the game using the Weltmeister.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存并添加一个生命箱到游戏中使用Weltmeister。
- en: Check in the DOM if your health crate has actually increased your player's health.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DOM中检查您的生命箱是否实际增加了玩家的生命值。
- en: Keeping score
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持得分
- en: 'Keeping track of a score within the game is a rather straightforward thing.
    In order to implement a system where a score is kept and increased every time
    an enemy is killed, we need three things:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中跟踪分数是一件相当简单的事情。为了实现一个系统，在其中每次杀死一个敌人时都会保持并增加分数，我们需要三样东西：
- en: We need a variable that keeps track and is within the boundaries of the game
    itself, but can be regarded as some sort of overhead variable.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个在游戏本身范围内并且可以被视为某种开销变量的变量。
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is really important because, as we will see in [Chapter 5](ch05.html "Chapter 5. Adding
    Some Advanced Features to Your Game"), *Adding Some Advanced Features to Your
    Game*, the start and end screens are in effect different games that are being
    loaded. When a new game is loaded into memory, the old one is discarded and so
    are all of its variables. That is why we need a variable that exists outside of
    the game.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这非常重要，因为正如我们将在[第5章](ch05.html "第5章。为您的游戏添加一些高级功能")中看到的那样，*为您的游戏添加一些高级功能*，开始和结束屏幕实际上是正在加载的不同游戏。当新游戏加载到内存中时，旧游戏被丢弃，它的所有变量也被丢弃。这就是为什么我们需要一个存在于游戏之外的变量。
- en: This function is used to increase the score by a certain number of points. This
    one is allowed to be a method of the game itself. Just insert this in the main
    script underneath the other main functions of the `MyGame` file.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数用于增加一定数量的分数。这个函数允许是游戏本身的一个方法。只需将其插入到`MyGame`文件的其他主要函数下面的主脚本中。
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We overwrite the enemy `kill()` function as shown, so the frog does not only
    die but also supplies us with some extra points.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们覆盖了敌人的`kill()`函数，如所示，因此青蛙不仅死亡，而且还为我们提供了额外的分数。
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From now on, every time a red frog dies, we get an extra 100 points and these
    are kept safely in a variable that is not erased as long as we do not refresh
    the page. We can then later on use this variable to show up at the end of a game
    to provide our gamer with some feedback of how well or poorly he did.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每当红蛙死亡时，我们都会得到额外的100分，并且这些分数会安全地保存在一个变量中，只要我们不刷新页面，它们就不会被删除。然后，我们可以稍后使用这个变量，在游戏结束时向我们的玩家提供一些反馈，告诉他表现得好还是差。
- en: 'Keeping the score is a very important component for almost any game. It is
    a way to challenge the player to replay your game and do better at it. It is not
    too difficult to implement either; let''s see what we did:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 保持得分对于几乎任何游戏来说都是非常重要的组成部分。这是一种挑战玩家重玩游戏并在其中表现更好的方式。而且实现起来也不是太困难；让我们看看我们做了什么：
- en: Create a variable outside of the current game and call the variable `score`
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前游戏之外创建一个变量，并将变量命名为`score`
- en: Add a function to the game that can directly manipulate our `score` variable
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个可以直接操作我们的`score`变量的游戏函数
- en: Call the function when an enemy dies, to add points to the overall player score
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人死亡时调用该函数，将分数添加到整体玩家得分中。
- en: Transitioning from one level to another
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个级别过渡到另一个级别
- en: In order to have a map transitioning, you will first need a second level. You
    can make one yourself or copy the one from the downloadable files for this chapter.
    You will also need the trigger end `levelchange` entity. Copy both entities to
    the `entities` folder, and the level called `level 2` to the `levels` folder on
    your local computer. Alternatively, you can devise a second level yourself and
    use the trigger entity, which comes with your Impact license. The trigger entity
    is not part of the actual engine; it can be found in downloadable examples on
    the ImpactJS website.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现地图过渡，您首先需要第二个级别。您可以自己制作一个，或者从本章的可下载文件中复制一个。您还需要触发器结束`levelchange`实体。将这两个实体复制到`entities`文件夹中，并将名为`level
    2`的级别复制到本地计算机上的`levels`文件夹中。或者，您可以自己设计第二个级别，并使用随Impact许可证提供的触发器实体。触发器实体不是实际引擎的一部分；它可以在ImpactJS网站的可下载示例中找到。
- en: 'In the `levelchange` entity, we will make the following code change:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在`levelchange`实体中，我们将进行以下代码更改：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you might notice, it is different from the one we used in the RPG, in two
    main aspects as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能注意到的那样，它与我们在RPG中使用的不同，主要有两个方面：
- en: It does not take into account the use of spawnpoints. Using actual spawnpoints
    is not really necessary for most side scrollers. This is because once a level
    is completed, you can only go back to it by playing it all over again. Therefore,
    we do not need multiple spawnpoints per level, only one spawnpoint is required.
    If we only need one spawnpoint, however, it is way easier not to use the Void
    entity as we did in the previous chapters. Instead, we simply put the player entity
    on a certain location within the level and the level will thus always start there.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不考虑使用生成点。对于大多数横向卷轴游戏，实际上并不需要使用生成点。这是因为一旦完成了一个级别，您只能通过重新玩它来返回到它。因此，我们不需要每个级别多个生成点，只需要一个生成点。然而，如果我们只需要一个生成点，不使用我们在之前章节中使用的Void实体会更容易。相反，我们只需将玩家实体放在级别内的某个位置，级别将始终从那里开始。
- en: The second change to the `levelchange` entity is the backup we make of the player
    entity. Before loading the level, we copy the player entity to a local variable
    called `oldplayer`. Once the game is loaded, a new playable character is created;
    this is the one we manually added to the level, `level 2` in the Weltmeister.
    We then assign this new player to another local variable called `newplayer`. By
    overwriting `newplayer` with `oldplayer`, we can keep playing with the old frog.
    This can be important if the player is allowed to keep the previously acquired
    supplementary weapons or health.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`levelchange`实体的第二个更改是我们对玩家实体的备份。在加载关卡之前，我们将玩家实体复制到一个名为`oldplayer`的本地变量中。一旦游戏加载，就会创建一个新的可玩角色；这是我们手动添加到Weltmeister中的`level
    2`。然后我们将这个新玩家分配给另一个名为`newplayer`的本地变量。通过用`oldplayer`覆盖`newplayer`，我们可以继续使用旧的青蛙进行游戏。如果玩家被允许保留先前获得的补充武器或生命值，这可能很重要。
- en: 'All we need to do now is correctly set up a `trigger` and a `levelchange` entity
    in `level 1` and we have a decent level transitioning. This should be done as
    follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所需要做的就是在`level 1`中正确设置`trigger`和`levelchange`实体，这样我们就有了一个体面的关卡过渡。应该按照以下步骤进行：
- en: Once the `trigger` and `levelchange` entities are present in the `entities`
    folder, add both to the main script. Also add `level 2` to the script once you
    have created or copied it.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`trigger`和`levelchange`实体出现在`entities`文件夹中，就将它们都添加到主脚本中。一旦你创建或复制了`level 2`，也将`level
    2`添加到脚本中。
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Put both the `trigger` and the `levelchange` entities in `level 1` using the
    Weltmeister.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Weltmeister将`trigger`和`levelchange`实体放入`level 1`。
- en: Add a `name` property with the value `tolevel2` and a `level` property with
    the value `level2` to the `levelchange` entity using the Weltmeister.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Weltmeister为`levelchange`实体添加一个值为`tolevel2`的`name`属性和一个值为`level2`的`level`属性。
- en: Add a property called `target.1` with a value of `tolevel2` to the `trigger`
    entity using the Weltmeister.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Weltmeister为`trigger`实体添加一个名为`target.1`的属性，值为`tolevel2`。
- en: Double check you have a player entity present in your second level and this
    level bears the name `level2`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细检查你的第二个关卡中是否有一个玩家实体，并且这个关卡的名称是`level2`。
- en: Save all changes you made and reload the game for a test run. Certainly try
    collecting a health crate before using the level transition. Once you arrive at
    `level2`, your health increase should persist.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你所做的所有更改，并重新加载游戏进行测试。一定要尝试在使用关卡过渡之前收集一个生命值箱。一旦你到达`level2`，你的生命值增加应该会持续。
- en: If you copied `level2` from the downloadable files, notice how the stars move
    slower than the spaceships, which in turn move slower than some other spaceships.
    This is because of the distances of these three layers. If you open the Weltmeister,
    you can see that the star layer has a distance value of **5**, the closest star
    ships have a value of **2**, and the other ships have a value of **3**. Working
    with distances can give really nice effects for parallax games; use them wisely.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从可下载文件中复制了`level2`，请注意星星的移动速度比飞船慢，而飞船的移动速度又比其他一些飞船慢。这是因为这三个图层的距离。如果你打开Weltmeister，你会发现星星图层的距离值为**5**，最接近的星船的值为**2**，其他飞船的值为**3**。使用距离可以为视差游戏带来非常好的效果；明智地使用它们。
- en: '![Transitioning from one level to another](img/4568_4_13.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![从一个级别过渡到另一个级别](img/4568_4_13.jpg)'
- en: 'Adding a level transitioning can be done in a relatively easier manner, if
    it goes one way only. Let''s recap how we did this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是单向进行关卡过渡，那么添加关卡过渡可以相对容易地完成。让我们回顾一下我们是如何做到这一点的：
- en: Copy the `trigger` and `levelchange` entities.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制`trigger`和`levelchange`实体。
- en: Build or copy a second level called `level2`. Make sure to add a player entity
    to the level.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建或复制一个名为`level2`的第二个关卡。确保在关卡中添加一个玩家实体。
- en: Include the new level and both the `trigger` and `levelchange` entities in the
    main script.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主脚本中包括新的关卡和`trigger`和`levelchange`实体。
- en: Add a `trigger` and `levelchange` entity to `level 1`, connect them and make
    sure the `levelchange` entity points to `level2`.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`level 1`中添加一个`trigger`和`levelchange`实体，连接它们，并确保`levelchange`实体指向`level2`。
- en: Try using the `distance` property of a layer while designing your levels. This
    can give you beautiful results in a side scroller game.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计关卡时，尝试使用图层的`distance`属性。这可以在横向滚动游戏中给你美丽的结果。
- en: The final battle
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的战斗
- en: Every good game ends with a challenging final battle where good defeats evil,
    or vice versa, your call.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 每个好游戏都以一个具有挑战性的最终战斗结束，善良战胜邪恶，或者反之，由你决定。
- en: In order to have a challenging fight, let's create a separate `boss` entity,
    which is more powerful than our other frogs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行一场具有挑战性的战斗，让我们创建一个单独的`boss`实体，比我们其他的青蛙更强大。
- en: Open a new file and save it as `boss.js`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新建一个文件并将其保存为`boss.js`。
- en: The boss will be an extension to our normal enemy, so let's first define the
    characteristics on which he will differ from the red frogs.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: boss将是我们正常敌人的扩展，所以让我们首先定义他与红色青蛙不同的特征。
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: His name is different; but more importantly, he will have more health and is
    much bigger than the other frogs.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他的名字不同；但更重要的是，他的生命值更多，比其他青蛙要大得多。
- en: 'Add the boss to your main script using the following line of code:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将boss添加到你的主脚本中：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Save all changes and put the boss in one of your levels.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有更改并将boss放入你的一个关卡中。
- en: 'We now have a bigger enemy indeed, with more health, who basically does the
    same thing as the smaller ones. This doesn''t really make for an interesting boss
    fight, so let''s give him the ability to fire bullets like the player. We need
    a separate bullet entity, since our basic projectile can only damage type B entities
    and our player is of type A; also we might want it to look a bit different:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在确实有一个更大的敌人，生命值更多，基本上做的事情和较小的一样。这并不会让boss战变得有趣，所以让我们赋予他像玩家一样发射子弹的能力。我们需要一个单独的子弹实体，因为我们的基本抛射物只能伤害B类型实体，而我们的玩家是A类型；另外我们可能希望它看起来有点不同：
- en: Open a new file and save it as `bossbullet.js`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新建一个文件并将其保存为`bossbullet.js`。
- en: 'This bullet will be a direct extension of the normal bullet except for the
    type check and the way it looks. Write the following code to create the new bullet
    entity:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这颗子弹将是普通子弹的直接扩展，除了类型检查和外观方式。编写以下代码来创建新的子弹实体：
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We need one last modification, shown in the following code, to make the boss
    fire his own bullets:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要进行最后一个修改，如下所示的代码，让boss发射自己的子弹：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The boss entity''s `update()` function differs from the others in three main
    ways:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: boss实体的`update()`函数与其他实体有三个主要区别：
- en: Since he is a bigger creature, he uses more force to move around.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于他是一个更大的生物，他需要更多的力量来移动。
- en: We prefer him to deal damage with his bullets so he doesn't try to come into
    melee range. When he is within a distance of 1000 pixels on the x axis, he will
    approach. Once at a distance of 100 pixels, he doesn't try to come any closer.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望他用子弹造成伤害，这样他就不会试图进入近战范围。当他在x轴上的距离为1000像素时，他会接近。一旦距离为100像素，他就不会再靠近了。
- en: Last but not least, in every frame there is a 1 out of 10 chance of him firing
    a bullet. This should on an average result in 6 bullets every second, which is
    quite a barrage. If you are very unlucky, he can fire up to 60 bullets your way,
    in a single second.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，在每一帧中，他有1/10的几率发射一颗子弹。这平均每秒应该会导致6颗子弹，这是相当密集的火力。如果你非常不幸，他可以在一秒内向你发射多达60颗子弹。
- en: A pretty nice effect from the Box2D collision is that as a player, your own
    bullets can deflect those of the boss. However, this will not always be the case.
    Collision detection in Box2D is not perfect yet and sometimes two entities can
    go straight through each other. This is also why you should make sure your outer
    boundary collision wall is pretty thick. Otherwise, you will have entities flying
    outside your level, possibly resulting in game crashes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D碰撞的一个相当好的效果是，作为玩家，你自己的子弹可以偏转boss的子弹。然而，这并不总是这样。Box2D中的碰撞检测还不完美，有时两个实体可以直接穿过彼此。这也是为什么你应该确保你的外边界碰撞墙非常厚。否则，你的实体可能会飞出你的关卡，可能导致游戏崩溃。
- en: '![The final battle](img/4568_4_14.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![最终战斗](img/4568_4_14.jpg)'
- en: Killing the boss character should end the game and give the player a nice Victory
    screen. Dying should end in a Game Over screen instead of a Game Crash screen.
    These and many other things will be addressed in [Chapter 5](ch05.html "Chapter 5. Adding
    Some Advanced Features to Your Game"), *Adding Some Advanced Features to Your
    Game*, where we take a deeper look at some more advanced features with which you
    can enhance your game.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 击败boss角色应该结束游戏，并给玩家一个漂亮的胜利画面。死亡应该以游戏结束画面而不是游戏崩溃画面结束。这些以及许多其他事情将在[第5章](ch05.html
    "第5章。为您的游戏添加一些高级功能")中得到解决，*为您的游戏添加一些高级功能*，在那里我们将更深入地研究一些更高级的功能，以增强您的游戏。
- en: 'When the game is almost at an end, the player expects a climax. This can be
    given to him in the form of an epic battle against a worthy foe. That is exactly
    what we did earlier in this chapter. The boss character is the player''s ultimate
    enemy and his ticket to victory:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏接近尾声时，玩家期望有一个高潮。这可以通过与一个值得的敌人进行一场史诗般的战斗来给他。这正是我们在本章早些时候所做的。boss角色是玩家的终极敌人，也是他取得胜利的关键：
- en: Open a new file and save it as `boss.js`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个新文件并将其保存为`boss.js`。
- en: Create the boss character's basics as an extension of the enemy entity.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将boss角色的基本功能作为敌人实体的扩展。
- en: Introduce the boss' bullet, that is, the projectile used by the boss to kill
    the player. This is an extension of the projectile used by the player himself.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入boss的子弹，也就是boss用来杀死玩家的抛射物。这是玩家自己使用的抛射物的扩展。
- en: Upgrade the boss so he can make use of his lethal new bullet.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级boss，使他能够利用他的致命新子弹。
- en: Add a boss to your game and check out if you are able to defeat him.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中添加一个boss并查看你是否能击败他。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we learned about the side scroller game and took a look at some
    famous examples. We built our own side scroller using Box2D, that is, a physics
    engine integrated with ImpactJS.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了横向卷轴游戏，并看了一些著名的例子。我们使用了集成了ImpactJS的物理引擎Box2D构建了自己的横向卷轴游戏。
- en: First, we built a level with the Weltmeister, so we could populate them with
    our newly created enemy and playable characters. Lifeless crates were added to
    fully display the physics of Box2D. In order to arm the player against the violent
    enemies we introduced pickup items and two interesting weapons, that is, the bullet
    and the bomb.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用Weltmeister建立了一个关卡，这样我们就可以用我们新创建的敌人和可玩角色来填充它们。我们添加了无生命的箱子，以完全展示Box2D的物理效果。为了武装玩家对抗暴力敌人，我们引入了拾取物品和两种有趣的武器，即子弹和炸弹。
- en: Our enemy was given life once we added minor AI. As a final challenge for the
    player, the formidable boss was brought to the scene. This enemy is stronger than
    regular enemies and capable of firing bullets like the player. For defeating every
    enemy, the player is awarded with extra points to his total score.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的敌人在我们添加了轻微的人工智能后获得了生命。作为玩家的最终挑战，强大的boss被带到了场景中。这个敌人比普通敌人更强大，能够像玩家一样发射子弹。为了击败每个敌人，玩家将获得额外的积分。
- en: In the next chapter we will explore some new concepts like working with data
    and go deeper into some of the features we have already touched on, such as debugging
    AI.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些新概念，比如处理数据，并深入一些我们已经接触过的功能，比如调试人工智能。
