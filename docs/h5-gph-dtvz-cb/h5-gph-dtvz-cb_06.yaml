- en: Chapter 6. Bringing Static Things to Life
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。将静态事物变得生动起来
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Stacking graphical layers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆叠图形层
- en: Moving to an OOP perspective
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向面向对象的视角
- en: Animating independent layers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画独立层
- en: Adding an interactive legend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个交互式图例
- en: Creating a context-aware legend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个上下文感知的图例
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Until now, the importance of keeping things organized and clean wasn't as great
    as that of getting our projects done as we had relatively small projects. This
    chapter will break us into a few new habits by first making everything dynamic
    followed by creating a more object-oriented program so it's easier for us to separate
    tasks and reduce our code footprint. After all this hard work, we will revisit
    our application and start adding extra logic geared at making our application
    animated layer by layer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，保持组织和清洁的重要性并不像完成我们的项目那样重要，因为我们的项目相对较小。本章将通过首先使一切都变得动态，然后创建一个更面向对象的程序，使我们更容易分离任务并减少我们的代码量，为我们带来一些新的习惯。经过所有这些辛苦的工作，我们将重新审视我们的应用程序，并开始添加额外的逻辑，以使我们的应用程序逐层动画化。
- en: This chapter is a great resourse for refactoring practice. In the first half
    of this chapter, we will be focused on improving our code structure to make it
    possible for us to have the level of control we will need in the second half of
    the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是重构实践的一个很好的资源。在本章的前半部分，我们将专注于改进我们的代码结构，以使我们能够在本章的后半部分拥有我们需要的控制水平。
- en: Stacking graphical layers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆叠图形层
- en: Before we can do any real animations on our canvas we really need to rethink
    the concept of building everything on one canvas layer. Once a canvas element
    is drawn, it's incredibly hard to create subtle small changes to it, such as fade-ins
    for specific elements. We will revisit one of our famous charts, the bar chart,
    which we played around with and enhanced many times throughout the earlier chapters.
    In this chapter, our goal will be to break the logic apart and make it more modular.
    In this recipe we will separate layers. Each layer will give us more control later
    when we are ready to animate.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在画布上进行任何真正的动画之前，我们真的需要重新思考在一个画布层上构建一切的概念。一旦画布元素被绘制，就非常难以对其进行微小的细微变化，比如特定元素的淡入效果。我们将重新访问我们的一个著名图表，柱状图，我们在早期章节中多次玩耍和增强。在本章中，我们的目标将是打破逻辑并使其更加模块化。在这个配方中，我们将分离层。每一层都将在我们准备好进行动画时给我们更多的控制。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by grabbing the latest files from the previous chapter: `05.02.line-revisit.html`
    and `05.02.line-revisit.js`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从上一章中获取最新的文件：`05.02.line-revisit.html`和`05.02.line-revisit.js`。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following changes are made to the HTML file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对HTML文件进行以下更改：
- en: 'Update the HTML file to incorporate more canvas elements (one per drawn line):'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新HTML文件以包含更多的画布元素（每个绘制线条一个）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a CSS script so the layers will be stacked:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个CSS脚本，使层叠起来：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's move into the JavaScript file to update it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入JavaScript文件进行更新。
- en: 'Add a `window.onload` callback function (changes highlighted in the code snippet):'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`window.onload`回调函数（在代码片段中突出显示的更改）：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remove the variable `context` from global scope (delete the highlighted code
    snippet):'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从全局范围中删除变量`context`（删除高亮显示的代码片段）：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Consolidate all bar line information into one object for easier control (delete
    all the highlighted code snippets):'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有柱线信息合并到一个对象中，以便更容易控制（删除所有高亮显示的代码片段）：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remove all canvas logic from the `init` function and add it to the `drawChart`
    function:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`init`函数中删除所有画布逻辑，并将其添加到`drawChart`函数中：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Update references to the new data object in the `init` function:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`函数中更新对新数据对象的引用：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `drawChart` function, extract the logic of line creation to an external
    function (delete the highlighted code snippets):'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`drawChart`函数中，将线条创建的逻辑提取到一个外部函数中（删除高亮显示的代码片段）：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change the logic in the `onChangedRadio` callback function. Instead of what
    it was doing so far let''s have it trigger a call to the `changeLineView` function
    (we will create that function next):'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`onChangedRadio`回调函数中的逻辑。让它触发对`changeLineView`函数的调用（我们将在下面创建该函数）：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the function `changeLineView`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数`changeLineView`：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you run your HTML file after all these changes, you should see exactly
    the same thing as you did before we started making all these changes. If that's
    true then you are in a great place. However, we can't visually see any change
    yet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些更改之后运行HTML文件，你应该看到与我们在开始所有这些更改之前看到的完全相同的东西。如果是这样，那么你就处于一个很好的位置。然而，我们目前还看不到任何变化。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The heart of this recipe is our HTML file that enables us to layer canvas elements
    on top of each other, and as our canvas is by default transparent, we can see
    through to the elements that are under it. After our canvas is layered with four
    layers, it''s time for us to separate our background from our lines and as such
    we want to put all of our chart background information right into the base canvas:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的核心是我们的HTML文件，它使我们能够将画布元素层叠在彼此之上，由于我们的画布默认是透明的，我们可以看到它下面的元素。在我们的画布上叠加了四个层之后，是时候将我们的背景与线条分开了，因此我们希望将所有的图表背景信息都放在基础画布中：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With each line layer, we are using a preconfigured canvas element that is already
    set:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个线条层，我们使用一个预先配置的画布元素，它已经设置好：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first parameter is both the ID of our canvas and the key we are using in
    our new object that stores our line information (to keep our code simple):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数既是我们画布的ID，也是我们在存储线条信息的新对象中使用的键（以保持我们的代码简洁）：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this data object we have exactly the same number of elements as we do in
    our canvas with the exact same names. This way we can very easily fetch information
    without using extra variables or conditions. This ties in to the logic of creating/updating
    lines:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据对象中，我们有与画布中完全相同数量的元素，名称也完全相同。这样我们就可以非常容易地获取信息，而不需要使用额外的变量或条件。这与创建/更新线条的逻辑相关：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We didn''t change the core logic of our line but redirected the logic into
    the context of the current line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有改变我们线条的核心逻辑，而是将逻辑重定向到当前线条的上下文中：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This way we can extract any direct mention of a year or element without referring
    to element names directly. This way we can add or remove elements and we would
    only need to add another canvas in our HTML file, add new properties, and finish
    off by adding the line in our creating function. That is still a lot, so how about
    we continue and optimize this code before we move on to more creative lands?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以提取任何直接提及年份或元素的提及，而不直接引用元素名称。这样我们可以添加或删除元素，我们只需要在HTML文件中添加另一个画布，添加新属性，并在创建函数中添加线条。这仍然很多，那么在继续前进到更有创意的领域之前，我们如何继续优化这段代码呢？
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Our final goal is this recipe is to help minimize the number of changes the
    user needs to do to create lines. Currently to add more lines the user would need
    to make changes in three places. The next few optimization tricks will help us
    reduce the number of steps it takes to add/remove lines.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个食谱的最终目标是帮助最小化用户需要进行的更改线条的步骤数量。目前，要添加更多线条，用户需要在三个地方进行更改。接下来的一些优化技巧将帮助我们减少添加/删除线条所需的步骤数量。
- en: Optimizing the drawChart function
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化`drawChart`函数
- en: 'Our `drawChart` function has been through a facelift, but right now, when we
    are creating our lines we are still referring directly to our current elements:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`drawChart`函数经历了一次改头换面，但是现在，当我们创建我们的线条时，我们仍然直接引用我们当前的元素：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Instead, let''s take advantage of the `barData` object and use the data keys
    of this object. This way we can completely avoid the need to refer directly to
    our explicit elements and instead depend on our data source as the source of information:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们利用`barData`对象并使用该对象的数据键。这样我们完全可以避免直接引用我们的显式元素的需要，而是依赖于我们的数据源作为信息来源：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Perfect! Now any change in our `barData` object will define the elements that
    will get rendered initially when the application starts. We just cut down the
    number of changes users will need to do to two.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们`barData`对象中的任何更改都将定义在应用程序启动时最初呈现的元素。我们刚刚减少了用户需要进行的更改次数到两次。
- en: Further streamlining our code
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步简化我们的代码
- en: We are in much better shape now than when we started. Originally there where
    three places in our code that referred directly to hardcoded values for our chart
    information. With the last update we reduced it to two (once within the HTML file
    and once in our data source).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在比刚开始时要好得多。最初，我们的代码中有三个地方直接引用了图表信息的硬编码值。在最后一次更新中，我们将其减少到了两个（一次在HTML文件中，一次在数据源中）。
- en: It's time for us to remove one more hardcoded instance. Let's remove our extra
    canvases and create them dynamically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候删除另一个硬编码的实例了。让我们删除我们额外的画布，并动态创建它们。
- en: 'So let''s start by removing our chart canvas elements from the HTML file and
    setting up an ID to our `<div>` tag (delete the highlighted code snippet):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们从HTML文件中删除我们的图表画布元素，并为我们的`<div>`标签设置一个ID（删除突出显示的代码片段）：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By the way, we added an ID for our `<div>` containing the layers so we can easily
    access it and change things within JavaScript.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们为包含图层的`<div>`添加了一个ID，这样我们就可以在JavaScript中轻松访问它并进行更改。
- en: 'Now that there isn''t any canvas for our layers, we want to dynamically create
    them only when we draw the chart for the first time (this happens in the `drawChart`
    function with the new `for` loop we just created in the *Optimizing the drawChart
    function* section in the previous recipe):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的图层没有任何画布，我们希望在第一次绘制图表时动态创建它们（这发生在`drawChart`函数中，我们刚刚在*优化`drawChart`函数*部分中创建的新`for`循环中）：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Refresh your HTML file and you will find our canvas elements looking exactly
    the way they did before. We have one last thing to sort out to truly make this
    application dynamic, and that is our controllers that right now are hardcoded
    in the HTML file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新您的HTML文件，您会发现我们的画布元素看起来和以前一样。我们还有最后一件事要解决，那就是我们的控制器，它们目前在HTML文件中是硬编码的。
- en: Creating the radio buttons dynamically
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态创建单选按钮
- en: 'Yet another section that could be dynamic is our creation of radio buttons.
    So let''s start with removing our radio buttons from the HTML file and adding
    an ID to our wrapper (delete the highlighted code snippet):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以是动态的部分是我们创建单选按钮。所以让我们从HTML文件中删除单选按钮，并为我们的包装器添加一个ID（删除突出显示的代码片段）：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Back into our HTML file let''s create a function that creates new radio buttons.
    We will call it the `appendRadioButton` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的HTML文件，让我们创建一个创建新单选按钮的函数。我们将其称为`appendRadioButton`函数：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Last but not the least let''s draw our new button right before we start interacting
    with it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是在我们开始与它交互之前绘制我们的新按钮：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we are not integrating the two `for` loops together. Even though
    it might look like the same thing, the separation is needed. It takes JavaScript
    some time, a few nanoseconds, to actually render the elements to the screen, and
    as such by separating our loops we are giving the browser a chance to catch up.
    The separation between creating the elements and manipulating the elements is
    present mainly to give JavaScript a chance to render the HTML file before interacting
    with the created elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有将两个`for`循环整合在一起。尽管看起来可能是一样的，但分离是必要的。JavaScript需要一些时间，几纳秒，才能将元素实际呈现到屏幕上，因此通过分离我们的循环，我们给浏览器一个机会来追赶。创建元素和操作元素之间的分离主要是为了让JavaScript有机会在与创建的元素交互之前呈现HTML文件。
- en: Great job! We just finished updating our content to make it totally dynamic.
    Now that everything is controlled through one location, that is the data source,
    we are ready to start exploring layered canvas logic in the following recipes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们刚刚完成了更新我们的内容，使其完全动态化。现在一切都通过一个位置控制，即数据源，我们准备开始在接下来的食谱中探索分层画布逻辑。
- en: Moving to an OOP perspective
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向面向对象的视角
- en: Our application has been developing with a growing momentum. It's time for us
    to stop that by changing our chart to be more OOP conducive. In this recipe we
    will clean up our code some more and convert some of it into objects. We will
    continue from where we left off in our previous recipe, *Stacking graphical layers*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序一直在不断发展。现在是时候通过将我们的图表更改为更符合面向对象编程的方式来停止了。在这个食谱中，我们将进一步清理我们的代码，并将其中一些转换为对象。我们将继续从上一个食谱*堆叠图形层*中离开的地方继续。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step is to get our latest source files: `06.01.layers.optimized.html`
    and `06.01.layers.optimized.js`. We will rename them and add our animation logic.
    Beyond changing the references on our HTML file we will not change anything else
    in our HTML file but focus our attention into the JavaScript file.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是获取我们的最新源文件：`06.01.layers.optimized.html`和`06.01.layers.optimized.js`。我们将重命名它们并添加我们的动画逻辑。除了在我们的HTML文件中更改引用之外，我们不会在HTML文件中做任何其他更改，而是将注意力集中在JavaScript文件中。
- en: One of the simplest ways of creating objects in JavaScript is by using functions.
    We can create a function and refer within the function name to `this` and by doing
    that we can treat the function as an object (more details in the *How it works...*
    section of this recipe).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建对象的最简单方法之一是使用函数。我们可以创建一个函数，并在函数名称中引用`this`，通过这样做，我们可以将函数视为对象（有关更多详细信息，请参阅本食谱的*工作原理...*部分）。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s jump right in and start converting our code to be more OOP friendly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即开始将我们的代码转换为更符合面向对象编程的方式：
- en: 'We start our code changes in the JavaScript file. Create the `LineChart` constructor
    method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从JavaScript文件开始进行代码更改。创建`LineChart`构造方法：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s update all of our functions to be prototypes of the `LineChart` function
    (our pseudo class):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新所有函数，使其成为`LineChart`函数（我们的伪类）的原型：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s take a look at the really difficult part. We need to refer to all
    functions and object variables with `this`. For a full list of changes please
    review the source files (as we don''t want to take up too many pages just for
    this). Here is a small sample:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来看看真正困难的部分。我们需要用`this`引用所有函数和对象变量。有关更改的完整列表，请查看源文件（因为我们不想为此占用太多页面）。这里是一个小样本：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our application so far, to deal with radio buttons we created only one callback
    function that is set to all the radio buttons. When the user clicks on our radio
    buttons, an event is triggered. One issue will arise as our scope inside the events
    will break because `this` will be a `this` reference of something else and not
    our main object. Radio buttons have their own scope (their own `this` reference).
    We want to force a scope change; to do that we will create a helper function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，为了处理单选按钮，我们只创建了一个回调函数，该函数设置为所有单选按钮。当用户点击我们的单选按钮时，将触发事件。一个问题将出现，因为事件内部的作用域将会中断，因为`this`将是其他内容的`this`引用，而不是我们的主对象。单选按钮有自己的作用域（自己的`this`引用）。我们想要强制进行作用域更改；为此，我们将创建一个辅助函数：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will now rewrite the lines that trigger our event in our `LineChart` constructor:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将重写在`LineChart`构造函数中触发事件的行：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will now rewrite our `init` function. We will create our data points in
    it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将重写我们的`init`函数。我们将在其中创建我们的数据点：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Delete all global variables.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有全局变量。
- en: Surprising but that's it; you have just moved all of your logic into an object.
    We don't have any global variables left in our application, making it much easier
    to have more than one chart at the same time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，你刚刚将所有逻辑移到了一个对象中。在我们的应用程序中没有任何全局变量，这样可以更容易地同时拥有多个图表。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We kept our changes at this stage to a minimum. JavaScript is an object-oriented
    programing language, and as such we can take advantage of that by wrapping all
    of our functions into a new class. We start by creating a constructor function.
    This function will be used as our object type/name:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的更改保持在最小阶段。JavaScript是一种面向对象的编程语言，因此我们可以通过将所有函数包装到一个新类中来利用它。我们首先创建一个构造函数。这个函数将被用作我们的对象类型/名称：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To create object variables we will refer to the constructor variables with
    `this`. The `this` operator is a dynamic name that always refers to the current
    scope. The current scope within an object is the object itself; in our case the
    `MyFirstObject` function will look as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建对象变量，我们将使用`this`引用构造函数变量。`this`运算符是一个动态名称，始终指的是当前作用域。在对象内部的当前作用域是对象本身；在我们的情况下，`MyFirstObject`函数将如下所示：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can still create variables using the regular variable definition inside
    of functions, but there, scope would not be an object scope but instead, the scope
    would be only within that function. As such whenever you want to create variables
    that are shared throughout an object you must create them and refer to them with
    a leading `this` reference.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以在函数内部使用常规变量定义来创建变量，但是，在那里，作用域不会是对象作用域，而是仅在该函数内部。因此，每当你想创建在整个对象中共享的变量时，你必须创建它们，并使用前导`this`引用来引用它们。
- en: 'The next step is to rename all of our functions to be prototypes of the new
    class (function) we created. This way our functions will belong to the new object
    we are creating. We want the transition of our global variables of the past to
    become object variables belonging to the current object. Each time we want to
    refer to an object variable (property), we need to explicitly let JavaScript know
    by directing JavaScript to our object using the `this` directive. For example,
    if we want to refer to the `sampleVar` variable we would approach it in the following
    way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将所有函数重命名为我们创建的新类（函数）的原型。这样，我们的函数将属于我们正在创建的新对象。我们希望过去的全局变量的转变成为当前对象的对象变量。每当我们想引用对象变量（属性）时，我们需要通过使用`this`指令明确地让JavaScript知道我们的对象。例如，如果我们想引用`sampleVar`变量，我们可以这样做：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We had only one problem and that was when we introduced other objects into our
    code. The directive `this` needs to know the scope of its location to know which
    object we are referring to. In the situation of using events, our expectations
    of `this` referring to our object will not be true. Actually when dealing with
    `this` within an event listener, the `this` directive would always refer to the
    element being listened to, also known as the one being manipulated. As such, adding
    events to a radio button will produce a result of breaking our scope. To solve
    this problem, we create a function that will bind our scope to the listener. The
    `bind` method binds our function to our current scope. Even though by default,
    a listener would have the scope of what it is listening to, we are forcing the
    scope to stay on our object making our code work better for us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只遇到了一个问题，那就是当我们在代码中引入其他对象时。指令`this`需要知道其位置的范围，以知道我们正在引用的是哪个对象。在使用事件的情况下，我们对`this`指向我们的对象的期望将不成立。实际上，在事件侦听器中处理`this`时，`this`指令总是指向被侦听的元素，也就是被操作的元素。因此，向单选按钮添加事件将导致我们的范围被破坏。为了解决这个问题，我们创建一个函数，将我们的范围绑定到侦听器上。`bind`方法将我们的函数绑定到当前范围。尽管默认情况下，侦听器的范围将是它正在侦听的对象，但我们强制范围保持在我们的对象上，使我们的代码更好地为我们工作。
- en: 'This leaves us with our last task. We need to create a new instance of our
    object. By creating a new instance we will activate all the work we did so far.
    The steps involved with creating a new object are the same as creating other base
    objects, only this time around we are using our constructor function name:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了我们的最后一个任务。我们需要创建我们对象的一个新实例。通过创建一个新实例，我们将激活我们迄今为止所做的所有工作。创建新对象的步骤与创建其他基本对象的步骤相同，只是这一次我们使用我们的构造函数名称：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The real test of our object will be if we can create more than one instance
    of our chart. Right now we can't, so we will need to do a few more changes to
    our logic to make it work.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对象的真正测试将是我们是否能创建多个图表实例。现在我们还不能，所以我们需要对我们的逻辑做一些更改才能使其工作。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although right now we have a working OOP object, it's not really optimized and
    it can use some refining. As we are in one scope, we can revisit and rewire what
    can be sent and what can depend on internal variables. We will explore this next
    task in this section of the chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在我们有一个可用的OOP对象，但它并没有真正优化，可以进行一些改进。由于我们在一个范围内，我们可以重新审视和重连可以发送的内容以及可以依赖内部变量的内容。我们将在本章的这一部分探讨下一个任务。
- en: Moving our base canvas element into our constructor
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将我们的基本画布元素移到我们的构造函数中
- en: 'Let''s start by moving from the `drawChart` function. The following logic will
    fetch the base canvas and create a global variable within our new constructor:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`drawChart`函数开始移动。以下逻辑将获取基本画布并在我们的新构造函数中创建一个全局变量：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will be followed by replacing the associated lines in the `drawChart`
    method with a reference to our newly created `baseCanvas` object:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将替换`drawChart`方法中的相关行，引用我们新创建的`baseCanvas`对象：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice that we removed the function parameters from our `fillChart` method
    as we can pass them internally now within the method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们从`fillChart`方法中删除了函数参数，因为现在我们可以在方法内部传递它们：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I strongly encourage you to continue and optimize the rest of the functions
    in this same manner, but for our sample let's continue on to the next topic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您继续以同样的方式优化其余的函数，但是对于我们的示例，让我们继续下一个主题。
- en: Creating all the HTML components dynamically
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态创建所有HTML组件
- en: Why would we want to create our controllers and base canvas dynamically as well?
    Because we created some of our classes in advance, we are forced to have only
    one object in every HTML page. If we had dynamically created the controllers or
    passed the class information, we could enable the creation of more than one controller
    in our application. As we have so many elements that we are creating dynamically,
    it seems logical to continue in this path. Let's first create the remaining two
    elements dynamically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要动态创建我们的控制器和基本画布？因为我们提前创建了一些类，所以我们在每个HTML页面中只能有一个对象。如果我们动态创建了控制器或传递了类信息，我们就可以在我们的应用程序中启用创建多个控制器。由于我们正在动态创建许多元素，继续这样做似乎是合乎逻辑的。让我们首先动态创建剩下的两个元素。
- en: 'Let''s start by removing the inner canvas details from our HTML page (delete
    the highlighted code snippet):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从HTML页面中删除内部画布细节（删除突出显示的代码片段）：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are going to start inserting the controller class within our global `<div>`
    tag that will be used for our canvas. We need to update our CSS information for
    the controllers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始将控制器类插入到我们的全局`<div>`标记中，该标记将用于我们的画布。我们需要更新控制器的CSS信息：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'OK. We are now ready to do some code updates to our constructor. The highlighted
    code snippets are the updates that should be implemented next:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们现在准备对我们的构造函数进行一些代码更新。应该实现的更新代码片段已经突出显示：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We want to start our `LineChart` object by sending into it the `<div>` tag
    ID:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过将`<div>`标签ID发送到`LineChart`对象来开始：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you refresh your screen, all this hard work should be invisible. If everything
    is still working the way it did before we started to make changes, then well done,
    you've just completed the conversion of your chart to be smart and dynamic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新屏幕，所有这些辛苦的工作应该是看不见的。如果一切仍然像我们开始做出改变之前一样工作，那么干得好，您刚刚完成了将图表转换为智能和动态的过程。
- en: Removing the lose ends
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除松散的部分
- en: 'Although we extracted all of our external canvas and controllers and everything
    is working, we still are referring to internal canvas elements and radio buttons
    in a way that can break them. If we try to create a mirror chart right next to
    them to solve this problem, we will need to look through all our new elements
    and append to their name a unique key (we can use the `div id` element as that
    key as there can only be one `<div>` tag with the same ID in any HTML application).
    To save us some pages, I''ll just show you the basic logic here but grab the latest
    code bundle to find all the updates:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们提取了所有外部画布和控制器，并且一切都在运行，但我们仍然是以一种可能会破坏它们的方式引用内部画布元素和单选按钮。如果我们尝试在它们旁边创建一个镜像图表来解决这个问题，我们需要查看所有我们的新元素，并在它们的名称中添加一个唯一的键（我们可以使用`div
    id`元素作为该键，因为在任何HTML应用程序中只能有一个具有相同ID的`<div>`标签）。为了节省一些页面，我只会在这里展示基本逻辑，但请获取最新的代码包以查找所有更新。
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'I''ve created two helper functions and their role is simple: to rename `<div>`
    tag/class/radio buttons by adding the main `<div>` tag ID into their name. This
    way we won''t have duplicate elements. All that is left is to locate all the areas
    where we are creating elements (we are creating canvas in the `drawChart` function
    and radio buttons in our constructor, but we interact with them in a few functions).
    Search for the changes where the `this.extractID` or `this.wrapID` methods are
    called and understand why they are being called.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了两个辅助函数，它们的作用很简单：通过将主`<div>`标签ID添加到它们的名称中来重命名`<div>`标签/类/单选按钮。这样我们就不会有重复的元素。剩下的就是定位我们创建元素的所有区域（我们在`drawChart`函数中创建画布，在构造函数中创建单选按钮，但我们在一些函数中与它们交互）。搜索调用`this.extractID`或`this.wrapID`方法的更改，并理解为什么它们被调用。
- en: Testing our work by creating two charts
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过创建两个图表来测试我们的工作
- en: 'To make life harder, we are going to create the same exact chart twice using
    the same data sources (as that is a good edge case, so if that works any chart
    would work). Update the HTML file and add two `<div>` tags and update the CSS:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让生活变得更加困难，我们将使用相同的数据源两次创建完全相同的图表（因为这是一个很好的边缘案例，所以如果这样可以工作，任何图表都可以工作）。更新HTML文件并添加两个`<div>`标签，并更新CSS：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In our `init` function let''s set up both charts:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`init`函数中让我们设置好两个图表：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Yes! We have two interactive charts working at the same time based on the same
    code base. Good job! And don't worry, the rest of this chapter is going to be
    much easier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们有两个基于相同代码基础的交互式图表同时工作。干得好！不用担心，本章的其余部分会更容易一些。
- en: Animating independent layers
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立层的动画
- en: After a few really hard recipes let's do something fun and easy; let's add some
    animation to our chart and add some fade-ins and delays.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些非常困难的配方之后，让我们做一些有趣且简单的事情；让我们为我们的图表添加一些动画，并添加一些淡入和延迟。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The core logic of our application was built in the previous two recipes *Stacking
    graphical layers* and *Moving to an OPP perspective*. We are in great shape so
    it will be extremely easy for us to expand and create content and add it into
    our application. We will make few very slight updates to our latest HTML file,
    mainly deleting things we don't need and then it's all JavaScript.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的核心逻辑是在前两个配方*堆叠图形层*和*转向面向对象编程*中构建的。我们的状态非常良好，因此我们可以非常容易地扩展并创建内容并将其添加到我们的应用程序中。我们将对我们最新的HTML文件进行一些非常轻微的更新，主要是删除我们不需要的东西，然后就是JavaScript了。
- en: Grab the latest files from our last sample (`06.02.objects.optimized.html` and
    `06.02.objects.optimized.js`) and let's continue.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们上一个示例（`06.02.objects.optimized.html`和`06.02.objects.optimized.js`）中获取最新的文件，然后让我们继续。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Our goal in the next few steps is to remove the code that is not required and
    then build our layered animations. Perform the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个步骤中，我们的目标是删除不需要的代码，然后构建我们的分层动画。执行以下步骤：
- en: 'Remove the HTML, CSS, and `<div>` tags that are not required (delete the highlighted
    code snippets):'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除不需要的HTML、CSS和`<div>`标签（删除高亮显示的代码片段）：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the new `Animator` constructor:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的`Animator`构造函数：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the `add` method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`add`方法：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create the internal `_animate` method:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建内部的`_animate`方法：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a new `Animate` object within the `LineChart` constructor method and
    animate key components:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LineChart`构造函数方法中创建一个新的`Animate`对象并对关键组件进行动画处理：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add animation to canvas elements in the `drawChart` method:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`drawChart`方法中为画布元素添加动画：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When you run the webpage again you will find a fade-in of the separate layers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次运行网页时，您会发现分离层的淡入效果。
- en: '![How to do it...](img/3707OT_06_01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/3707OT_06_01.jpg)'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking into our `Animator` constructor. We start with a few
    variables in our constructor:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看我们的`Animator`构造函数开始。我们在构造函数中首先有一些变量：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These variables are the key to everything else. The `animQue` array will store
    each new animation request we make. The `refreshRate` property will control how
    often our animation will update. The more often it updates the smoother our animation
    will be (the higher the value in the refresh rate the less stress on user's system).
    For example, if we want to have a few animations, one in a smoother setting and
    others with a lower refresh rate, we can set two separate `Animator` classes with
    different refresh rates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量是一切的关键。`animQue`数组将存储我们发出的每个新动画请求。`refreshRate`属性将控制我们的动画更新频率。更新得越频繁，我们的动画就会越流畅（刷新率的值越高，用户系统的压力就越小）。例如，如果我们想要有几个动画，一个在更平滑的设置中，另一个以较低的刷新率运行，我们可以设置两个不同的`Animator`类，具有不同的刷新率。
- en: 'Our `add` method takes in all the necessary information to animate a property:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`add`方法接收所有必要的信息来对属性进行动画处理：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Each element sent in to animate is then converted into a reference object that
    will be used when animations are running and pushed into our `animQue` array:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到动画的每个元素都会被转换为一个引用对象，该对象在动画运行时将被使用，并推送到我们的`animQue`数组中：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: storing within the queue all the information we will need to animate an element,
    from the object's current status to how much of a change should be made each interval.
    On top of that we added a delay option enabling us to start the animation later.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中存储我们将需要动画元素的所有信息，从对象的当前状态到每个间隔应该进行多少变化。除此之外，我们还添加了一个延迟选项，使我们能够稍后开始动画。
- en: 'We control the creation of intervals only in this function so until this function
    is called, there will be no interval running:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在这个函数中控制间隔的创建，所以在调用这个函数之前，将不会有间隔运行：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now it''s time for the internal logic of our object. The `_animate` method
    is called internally for as long as there is something to animate. In other words,
    as long as there is something in the `animQue` array. It loops through all the
    `animQue` array elements and goes through a few tests per element:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们对象的内部逻辑的时间了。`_animate`方法在有东西需要动画时被内部调用。换句话说，只要`animQue`数组中有东西。它循环遍历所有`animQue`数组元素，并对每个元素进行一些测试：
- en: If the element has a delay set, it will downgrade the delay value by the `refreshRate`
    property such that the delay will become smaller during each loop until it will
    be zero or less. When that happens the next step will trigger.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果元素设置了延迟，它将通过`refreshRate`属性降低延迟值，使得在每次循环中延迟变小，直到变为零或更小。当这种情况发生时，下一步将触发。
- en: Now that the delay is complete, the `_animate` method changes gear. It starts
    to animate the objects within the `animQue` array for as long as the value of
    `data.crt` is lesser than `data.to`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在延迟已经完成，`_animate`方法改变了状态。它开始为`animQue`数组中的对象进行动画，直到`data.crt`的值小于`data.to`为止。
- en: The interval will continue one more time before testing to remove our element
    from the array. The separate step here is to help us avoid adding an `if` statement
    within our core logic reducing the complexity of our `for` loop. As we only need
    to test this once, we can absorb the cost of one extra loop cycle. In this extra
    cycle, we force the exact final value to our object and remove it from the animation
    queue.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试从数组中移除元素之前，间隔将继续一次。这里的分步是帮助我们避免在核心逻辑中添加`if`语句，从而减少我们`for`循环的复杂性。因为我们只需要测试一次，所以我们可以吸收一个额外的循环周期的成本。在这个额外的周期中，我们将确切的最终值强制给我们的对象，并将其从动画队列中移除。
- en: 'This is the only strange logic, where we force the value of our loop variable
    down:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是唯一的奇怪逻辑，我们在这里强制将循环变量的值降低：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this code we are removing our element. As soon as we remove our element our
    current value of `i` will be one value larger than it should be, as our object
    has shrunk. To solve this problem, we need to force down the value to reset it
    back to the new current index.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们正在移除我们的元素。一旦我们移除了元素，我们的`i`的当前值将比应该的值大一个，因为我们的对象已经缩小了。为了解决这个问题，我们需要强制降低值，将其重置为新的当前索引。
- en: 'Last but not the least, at the end of each update we check to see if there
    is anything in our array. If the array is empty, it''s time for us to remove the
    interval. We want to avoid having an interval running when it''s not needed. Next
    time the `add` method is triggered, it will restart the interval:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每次更新结束时，我们检查一下我们的数组中是否有任何东西。如果数组为空，那么是时候移除间隔了。我们希望在不需要时避免间隔运行。下次触发`add`方法时，它将重新启动间隔：
- en: '[PRE53]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That's the core of our logic and now it's time to create a new `animator` object
    and start sending elements that we want to animate. Play around with it, animate
    other things, and find your favorite animation balance between speed, delay, and
    properties you want to animate. This `animator` class is the base of all animation
    libraries, although our sample is more minimal and has more chances of user overkill
    such as sending the same object multiple times.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们逻辑的核心，现在是时候创建一个新的`animator`对象，并开始发送我们想要动画的元素了。尝试一下，动画其他东西，并找到你喜欢的动画速度、延迟和属性之间的平衡。这个`animator`类是所有动画库的基础，尽管我们的示例更简化，有更多的用户过载的可能性，比如多次发送相同的对象。
- en: Adding an interactive legend
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个交互式图例
- en: Although we created a legend in the past, our legend was bound to be non-interactive
    as we had no way to move it around. In this sample, we will create a quick and
    easy legend that will update its position and fade in and fade out when a user
    rolls over our chart.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前创建了一个图例，但我们的图例注定是非交互式的，因为我们没有办法移动它。在这个示例中，我们将创建一个快速简单的图例，当用户在我们的图表上滚动时，它将更新其位置，并淡入淡出。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Grab the latest files from our previous recipe, `06.03.fade.html` and `06.03.fade.js`,
    and let's jump right in. We will hardcode our values in this example, but a more
    modular approach of extracting elements that would be dynamic is a great way to
    make this class reusable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的`06.03.fade.html`和`06.03.fade.js`中获取最新的文件，然后让我们开始吧。在这个例子中，我们将硬编码我们的值，但是提取动态元素的更模块化方法是使这个类可重用的好方法。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This time around we will create a method in the `LineChart` object that will
    create legends for us. Perform the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将在`LineChart`对象中创建一个方法，为我们创建图例。执行以下步骤：
- en: 'Create the `createLegend` method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`createLegend`方法：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create the `updateLegend` method:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`updateLegend`方法：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The next step for us is to create a few methods that will be used as event
    listeners. Let''s add a few listeners to control our animation:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要创建一些方法，这些方法将被用作事件监听器。让我们添加一些监听器来控制我们的动画：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The methods we created just now are ready to be linked to a callback method
    such as an `onmouseover` or `onmouseout` event of our `mainDiv`. We will bind
    our scope back into our main object and trigger the methods we created earlier
    when the user triggers these built-in events. Let''s register our listeners in
    the constructor:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚创建的方法现在准备好与回调方法链接，比如我们的`mainDiv`的`onmouseover`或`onmouseout`事件。我们将我们的范围绑定回我们的主对象，并在用户触发这些内置事件时触发我们之前创建的方法。让我们在构造函数中注册我们的监听器：
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add into the code a variable that will count how many bars are there in the
    chart in the `drawChart` update code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中添加一个变量，用于计算`drawChart`更新代码中图表中有多少个条形图：
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Well done! When you refresh your browser you will see a legend fading in/out
    and repositioning based on our mouse moves.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！当你刷新浏览器时，你会看到一个根据我们的鼠标移动而淡入/淡出和重新定位的传说。
- en: '![How to do it...](img/3707OT_06_02.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3707OT_06_02.jpg)'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The logic this time around is simple as our application already is nicely set
    and optimized. Our `createLegend` method creates for us a new canvas area that
    we can use for our legend. I've added some hardcoded values into it, but it would
    be a good idea to extract them into our `chartInfo` variable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次的逻辑很简单，因为我们的应用程序已经很好地设置和优化了。我们的`createLegend`方法为我们创建了一个新的画布区域，我们可以用它来制作我们的传说。我已经在其中添加了一些硬编码的值，但将它们提取到我们的`chartInfo`变量中会是一个好主意。
- en: The only thing that requires explanation is the logic involved with the layout
    of the legend. We need to know how many items our chart contains to avoid looping
    through the data source again or asking the user to add this information. We can
    calculate this information the first time we loop through the user-generated data
    and thus update it to have our total items within it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要解释的是传说布局涉及的逻辑。我们需要知道我们的图表包含多少项，以避免再次循环遍历数据源或要求用户添加此信息。我们可以在第一次循环遍历用户生成的数据时计算这些信息，然后更新它以包含我们的总项数。
- en: We set up our method in a way that would make it easy for us to actually put
    dynamic data directly into our chart. I've left that challenge open for you to
    explore and set up the ground work for it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了我们的方法，这样我们就可以将动态数据直接放入我们的图表中。我留下了这个挑战给你去探索和为它设置基础。
- en: There's more...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One more thing to note is, if you search hard and stress test our `Animator`
    class in this example, you will find that its not hundred percent optimized. If
    we send to the `Animator` class the same object with conflicting instructions,
    it will not automatically terminate the conflict. Instead, it will run through
    both until completion (for example, it will fade-out and fade-in at the same time;
    it will not break our application but it will create unwanted outcomes). To solve
    problems such as this one, we would need to modify our `Animator` class to override
    animations that are in conflict.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要注意的是，如果你在这个例子中努力搜索并对我们的`Animator`类进行压力测试，你会发现它并不是百分之百优化的。如果我们向`Animator`类发送具有冲突指令的相同对象，它不会自动终止冲突。相反，它将运行直到完成（例如，它将同时淡出和淡入；它不会破坏我们的应用程序，但会产生不需要的结果）。为了解决这样的问题，我们需要修改我们的`Animator`类来覆盖冲突的动画。
- en: 'Let''s fix the animation conflicts by checking that our animation queue does
    not have the same object with the same property animating already. We will create
    a `find` function to help us find in the `animQue` property the index of a duplicate:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查我们的动画队列是否已经有相同属性的相同对象在进行动画来解决动画冲突。我们将创建一个`find`函数来帮助我们在`animQue`属性中找到重复的索引：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The function will scan through our `animQue` array and locate duplications.
    If a match is found, the index value will be returned. If not, `-1` will be returned.
    Now it''s time to update our `add` method to use this new `find` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将扫描我们的`animQue`数组并找到重复项。如果找到匹配项，将返回索引值。如果没有找到，将返回`-1`。现在是时候更新我们的`add`方法来使用这个新的`find`方法了：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Great! Problem solved! Although we have not addressed the dynamic legend in
    this example, we are going to create a new direction for our legend that will
    be just as dynamic and maybe a bit more in our next recipe, *Creating a context-aware
    legend*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！问题解决了！虽然在这个例子中我们还没有解决动态传说，但我们将在下一个示例中创建一个新的传说方向，它将是同样动态的，也许更加动态，*创建一个上下文感知的传说*。
- en: Creating a context-aware legend
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个上下文感知的传说
- en: Our goal will be to create a legend that updates based on what is under the
    user's mouse cursor as they roll over our application. Based on the mouse position
    of the user, we will update our legend to reflect the information that is under
    the user's mouse.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个根据用户鼠标悬停在应用程序上的位置而更新的传说。根据用户的鼠标位置，我们将更新我们的传说以反映用户鼠标下的信息。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Grab the latest files from the previous recipe: `06.04.legend.html` and `06.04.legend.js`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个示例中获取最新的文件：`06.04.legend.html`和`06.04.legend.js`。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We aren''t going to change anything in the HTML files so let''s jump right
    into the JavaScript and build out our dynamic legend:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在HTML文件中做任何改变，所以让我们直接进入JavaScript并构建我们的动态传说：
- en: 'From the `ChartLine` constructor, remove rollover/rollout events as we want
    to keep our legend always visible:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ChartLine`构造函数中删除rollover/rollout事件，因为我们希望保持我们的传说始终可见：
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Update the `createLegend` method:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`createLegend`方法：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Update the method `updateLegend`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`updateLegend`方法：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Change the event listener `onMouseMoveArea`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改事件监听器`onMouseMoveArea`：
- en: '[PRE64]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We need to add the step size into our data. This variable should be calculated
    dynamically as there is no need for the user to know this information if we can
    calculate it. As such, we will add this calculation to our `chartInfo` object
    when we calculate the step size in the `fillChart` method:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将步长添加到我们的数据中。这个变量应该动态计算，因为如果我们可以计算出来，用户就不需要知道这个信息。因此，当我们在`fillChart`方法中计算步长时，我们将把这个计算添加到我们的`chartInfo`对象中：
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Last but not the least, let''s add our canvas information directly into our
    `barData` object so we can easily interact with it (added in the `drawChart` function):'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我们直接将画布信息添加到我们的`barData`对象中，这样我们就可以轻松地与它交互（添加到`drawChart`函数中）：
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We should be all set. When you run the page again, your mouse should be in control
    of the information provided by the legend based on the exact coordinate you are
    on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该已经准备好了。当你再次运行页面时，你的鼠标应该控制传说中基于你所在的确切坐标提供的信息。
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the last two steps of the previous section of this recipe, we add a few helper
    variables to help us create our mouse move logic. This is an interesting part
    because in addition in this sample we are asking our canvas for pixel information
    for the first time. We will focus our attention mainly on the logic within the
    `onMouseMoveArea` event listener.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节配方的最后两个步骤中，我们添加了一些辅助变量来帮助我们创建鼠标移动逻辑。这是一个有趣的部分，因为在这个示例中，我们首次向画布请求像素信息。我们将主要关注`onMouseMoveArea`事件侦听器内的逻辑。
- en: 'We start by establishing the boundaries of our canvas area:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要确定画布区域的边界：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This will be followed by a quick calculation of the current area in the chart
    we are in:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将是对我们所在图表的当前区域进行快速计算：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If we are out of the area, our `currentXIndex` variable will remain `-1`, while
    if we are in the area, we will get a value between `0` and the highest possible
    value based on the number of steps in the data source. We will send this value
    to our newly updated `updateLegend` method that will append the actual value of
    that index information from the data source into the rendering of the legend.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们离开区域，我们的`currentXIndex`变量将保持为`-1`，而如果我们在区域内，我们将得到一个值，介于`0`和数据源步数的最大可能值之间。我们将把这个值发送到我们新更新的`updateLegend`方法中，该方法将把该索引信息的实际值从数据源附加到图例的渲染中。
- en: 'The next step is a `for` loop where we loop through our data to test our canvas
    elements to see if they are opaque or not:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个`for`循环，我们通过循环遍历我们的数据来测试我们的画布元素，看它们是否是不透明的：
- en: '[PRE69]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Only if the data returned confirms that there is content under the mouse pointer,
    we will add that ID into the `renderList` object. The `renderList` object is going
    to be our hub; it will control the legend data fields to be sent to the `updateLegend`
    method. If our mouse is above an element that is drawn then we will showcase the
    legend information related to the user's rollover; if not, we won't.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 只有返回的数据确认鼠标指针下有内容，我们才会将该ID添加到`renderList`对象中。`renderList`对象将成为我们的中心；它将控制要发送到`updateLegend`方法的图例数据字段。如果我们的鼠标位于绘制的元素上方，我们将展示与用户悬停相关的图例信息；如果没有，我们将不展示。
- en: 'We will update the way we call the `updateLegend` method, but right before
    we send it to our new parameters, we want to confirm we are really sending something.
    If our helper (linker object) is empty, we will send instead the original object.
    That way, everything will render if no chart is under our mouse pointer:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新调用`updateLegend`方法的方式，但在将其发送到新参数之前，我们要确认我们确实发送了一些东西。如果我们的辅助（链接对象）为空，我们将发送原始对象。这样，如果鼠标指针下没有图表，一切都会渲染：
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Time to take a peek at the changes within the `updateLegend` method. The first
    new thing comes right in the first line:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候来看看`updateLegend`方法内的变化了。第一件新事情就在第一行出现：
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is a nice coding trick that enables us to update our `ren` parameter. The
    way it works is very simple; the `||` operator will always return the first true
    value it sees. In our case if the `ren` parameter is empty, or zero, or false
    it would return the value in `this.barData`. The logic is simple, if the `ren`
    parameter has content, it will remain the same while if it's empty the `this.barData`
    property will be set within the `ren` variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的编码技巧，它使我们能够更新我们的`ren`参数。它的工作方式非常简单；`||`运算符将始终返回它看到的第一个真值。在我们的情况下，如果`ren`参数为空，或为零，或为假，它将返回`this.barData`中的值。逻辑很简单，如果`ren`参数有内容，它将保持不变，而如果为空，则`this.barData`属性将在`ren`变量中设置。
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is really the magic of this whole recipe. Instead of looping through the
    `this.barData` property we are looping through the key object that contains all
    the items we want to render. All that is left to do is to add the data when adding
    the text if there is a valid index listed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是整个配方的魔力所在。我们不是通过`this.barData`属性进行循环，而是通过包含我们要渲染的所有项目的键对象进行循环。在添加文本时，只需在添加文本时添加数据，如果有列出有效索引。
- en: There you go! We just added a really cool dynamic legend that changes as the
    user explores our chart.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们刚刚添加了一个非常酷的动态图例，随着用户探索我们的图表而变化。
- en: '![How it works...](img/3707OT_06_03.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3707OT_06_03.jpg)'
