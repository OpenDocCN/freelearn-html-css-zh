- en: Chapter 7. Depending on the Open Source Sphere
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。依赖于开源领域
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Animating a gauge meter (jqPlot)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个仪表盘表（jqPlot）
- en: Creating an animated 3D chart (canvas3DGraph)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个动画3D图表（canvas3DGraph）
- en: Charting over time (flotJS)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移绘制图表（flotJS）
- en: Building a clock with RaphaelJS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RaphaelJS创建时钟
- en: Making a sunburst chart with InfoVis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用InfoVis制作一个日光图
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The open source data visualization community is extremely rich and detailed,
    with many options and some really amazing libraries. Each library has its strong
    points and its disadvantages. Some are standalone code while others depend on
    other platforms such as jQuery. Some are really big and some are really small;
    there isn't any one option that is perfect for all opportunities, but with such
    a rich amount of options, the most important thing is to figure out what library
    is the right one for you.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 开源数据可视化社区非常丰富和详细，有许多选项和一些真正令人惊叹的库。每个库都有其优点和缺点。有些是独立的代码，而其他依赖于其他平台，如jQuery。有些非常庞大，有些非常小；没有一个选项适用于所有机会，但是有这么多的选择，最重要的是找出哪个库适合您。
- en: There is always a trade-off when working with open source libraries, mainly
    when it comes to file sizes and having just too many features that drag down the
    speed of your application, load time, and so on. But with the richness and creativeness
    of the community, it's hard to avoid really fantastic charts that can be created
    in minutes instead of hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用开源库时总会有一个权衡，主要是在文件大小和拖慢应用程序速度、加载时间等方面有太多功能的情况下。但是由于社区的丰富和创造力，很难避免在几分钟内创建出真正奇妙的图表，而不是几个小时。
- en: In this chapter we will explore working with some of these options. Instead
    of using the libraries according to the documentation of the projects, our goal
    will be to find ways to override the built-in libraries to provide us with better
    control over our applications, in case we can't find a suitable solution in the
    documentation of an application. So the goal in this chapter is now double, namely
    to find ways to do things that aren't naturally set to work and to find ways to
    bypass problems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索使用一些这些选项。我们的目标不是根据项目的文档使用库，而是找到方法来覆盖内置库，以便更好地控制我们的应用程序，以防在应用程序的文档中找不到合适的解决方案。因此，本章的目标现在是双重的，即找到执行不是自然设置的事情的方法，并找到绕过问题的方法。
- en: One more important thing to note is that all of these open source libraries
    have copyrights. It is advised that you check the legal documentation of the project
    before you go ahead with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件重要的事情要注意，所有这些开源库都有版权。建议您在继续之前检查项目的法律文件。
- en: Animating a gauge meter (jqPlot)
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个仪表盘表（jqPlot）
- en: 'In this recipe, we will be creating a really fun gauge meter and injecting
    some random animation into it to make it look like a real source of live data
    is connected to it, such as the speed of a car:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个非常有趣的仪表盘表，并注入一些随机动画，使其看起来像是连接到实时数据源，比如汽车的速度：
- en: '![Animating a gauge meter (jqPlot)](img/3707OT_07_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个仪表盘表（jqPlot）](img/3707OT_07_01.jpg)'
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started you will need to use jQuery and jqPlot. This time around we will
    start from scratch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要使用jQuery和jqPlot。这一次我们将从头开始。
- en: To get the latest scripts, visit the creator site at [http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取最新的脚本，请访问[http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339)的创建者网站。
- en: Download both jQuery and jqPlot, or download our source files to start with.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下载jQuery和jqPlot，或者下载我们的源文件开始。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s list the steps required to complete the task:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出完成任务所需的步骤：
- en: 'Create an HTML page for our project:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的项目创建一个HTML页面：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create the `07.01.jqplot-meter.js` file.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`07.01.jqplot-meter.js`文件。
- en: 'Let''s add a few helper variables. We will use them when rendering our meter:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一些辅助变量。我们将在渲染仪表时使用它们：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now it's time to create our meter. We will use jQuery to know when our document
    is being read and then create our chart.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的仪表盘了。我们将使用jQuery来知道我们的文档何时被阅读，然后创建我们的图表。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now it''s time to animate our chart. Let''s add in the last line of our `ready`
    listener interval (it will run from now on until the end of the recipe):'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候为我们的图表添加动画了。让我们在`ready`监听器间隔的最后一行中添加（从现在开始直到配方结束）：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Last but not least, it''s time to create the `updateMeter` function:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，现在是创建`updateMeter`函数的时候了：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Well done. Refresh your browser and you will find an animated speedometer that
    looks like that of a car driving around (if you only imagine it).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好。刷新您的浏览器，您会发现一个动画速度计，看起来像是汽车在行驶（如果您只是想象）。
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This task was really easy as we didn't need to start everything from scratch.
    For the meter to run, we need to import the library `meterGaugeRenderer` . We
    do that by adding that into our JavaScript files that we are loading. But let's
    focus on our code. The first step in our JavaScript is to prepare a few global
    variables; we are using global variables as we want to re-use these variables
    in two different functions (when we are ready to reset our data).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务真的很容易，因为我们不需要从头开始。为了使仪表运行，我们需要导入`meterGaugeRenderer`库。我们通过将其添加到我们正在加载的JavaScript文件中来实现这一点。但让我们专注于我们的代码。我们JavaScript的第一步是准备一些全局变量；我们使用全局变量是因为我们希望在两个不同的函数中重复使用这些变量（当我们准备重置我们的数据时）。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `meter` variable will hold the meter that we will generate from our open
    source library. The `meterValue` will be our initial value when the application
    loads. Our `startingSpeed` variable is going to be a random value between `30`
    and `90`. The goal is to start from a different place each time to make it more
    interesting. As soon as our application starts, we will want our meter to quickly
    animate to its new base speed (the `startingSpeed` variable). Lastly, this connects
    to the `isStarting` variable as we will want to have one animation that will get
    us to our base speed. When we get there, we want to switch to a random driving
    speed that would cause the animation to change. Now that we have all the helper
    variables set, we are ready to create the `renderOptions` object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`meter`变量将保存我们从开源库生成的仪表。`meterValue`将是应用程序加载时的初始值。我们的`startingSpeed`变量将是`30`和`90`之间的随机值。目标是每次从不同的地方开始，使其更有趣。应用程序一启动，我们希望我们的仪表快速动画到其新的基本速度（`startingSpeed`变量）。最后，这与`isStarting`变量相关联，因为我们希望有一个动画将我们带到基本速度。当我们到达那里时，我们希望切换到一个会导致动画改变的随机驾驶速度。现在我们已经设置了所有辅助变量，我们准备创建`renderOptions`对象：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This object is really the heart of the visuals for our application. (There are
    other options that you are welcome to explore in the jqPlot project home page
    documentation.) Now let's review a few of the key parameters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象实际上是我们应用程序视觉效果的核心。（在jqPlot项目主页文档中还有其他选项可供您探索。）现在让我们回顾一些关键参数。
- en: '`intervalOuterRadius` has a bit of a tricky name, but it''s actually the internal
    radius. The actual size of our meter is controlled by the size of `div` that we
    set our application to be in. `intervalOuterRadius` controls the size of our internal
    shape in the speedometer''s core.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`intervalOuterRadius`有一个有点棘手的名称，但实际上它是内半径。我们的仪表的实际大小由我们设置应用程序所在的`div`的大小控制。`intervalOuterRadius`控制速度计核心中内部形状的大小。'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ticks` function controls where the copy outlines would be. The default
    would take our top range and divide it by 4 (that is 30, 60, 90, and 120). The
    `intervals` and `intervalColors` functions let the meter know the ranges and the
    inner, internal, pie colors (separated from the ticks).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ticks`函数控制复制轮廓的位置。默认情况下，它会将我们的顶部范围除以4（即30、60、90和120）。`intervals`和`intervalColors`函数让仪表知道范围和内部、内部、饼颜色（与刻度分开）。'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To create a new chart using the jqPlot library, we always call the `$.jqplot`
    function. The first parameter of the function is the `div` layer, which is where
    our work will live. The second parameter is a two-dimensional array containing
    the data of the chart (kind of looks odd for this example as it expects a 2D array
    and as our sample only includes one data entry at a time, we need to wrap it in
    two arrays). The third parameter defines the used renderer and `rendererOptions`
    (that we created earlier).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用jqPlot库创建新图表，我们总是调用`$.jqplot`函数。函数的第一个参数是`div`层，这是我们的工作所在的地方。第二个参数是包含图表数据的二维数组（对于这个示例来说看起来有点奇怪，因为它期望一个二维数组，而我们的示例一次只包含一个数据条目，所以我们需要将它包装在两个数组中）。第三个参数定义了使用的渲染器和`rendererOptions`（我们之前创建的）。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Let's explore a few more functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再探索一些功能。
- en: Creating the updateMeter function
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建`updateMeter`函数
- en: 'The `updateMeter` function gets called every 30 milliseconds. What we need
    to do is start by clearing our art every time that it is called:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateMeter`函数每30毫秒调用一次。我们需要做的是每次调用时都清除我们的艺术品：'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will clear everything related to our meter so we can recreate it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将清除与我们的仪表相关的所有内容，以便我们可以重新创建它。
- en: If we are still in the intro part of our application where we want our speed
    to go up to the goal speed, we need to update our `meterValue` by `1`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仍然处于应用程序的介绍部分，希望我们的速度达到目标速度，我们需要通过`1`更新我们的`meterValue`。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we are already passed this state and want our meter to go up and down randomly,
    making it look like variations in driving speed, we''ll use the following code
    snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经通过了这个状态，想让我们的仪表随机上下波动，看起来像是驾驶速度的变化，我们将使用以下代码片段：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are randomly adding a value between `-1` and `1` to our meter value. A correction
    to our result can be achieved by keeping our value not lower than `0` and not
    higher than `120`, followed by redrawing our meter with our new `meterValue` value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随机地向我们的仪表值添加一个介于`-1`和`1`之间的值。通过保持我们的值不低于`0`且不高于`120`，然后用我们的新的`meterValue`值重新绘制我们的仪表，可以实现对我们结果的修正。
- en: Creating an animated 3D chart (canvas3DGraph)
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个动画3D图表（canvas3DGraph）
- en: This recipe is real fun. It's based on the source files of Dragan Bajcic. It's
    not a full library of charts, but it's a great inspirational chart that can be
    modified and used to create your own 3D data visualizations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方真的很有趣。它基于Dragan Bajcic的源文件。它不是一个完整的图表库，但它是一个很棒的启发式图表，可以修改并用来创建您自己的3D数据可视化。
- en: Although our source files in our attached sample are modified from the original
    source (mainly `canvas3DGraph.js`), to get the original source for the open source
    projects used in this book, please visit our centralized list at [http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们附带示例中的源文件是从原始源文件（主要是`canvas3DGraph.js`）修改的，但要获取本书中使用的开源项目的原始源，请访问我们的集中列表[http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339)。
- en: '![Creating an animated 3D chart (canvas3DGraph)](img/3707OT_07_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个动画3D图表（canvas3DGraph）](img/3707OT_07_02.jpg)'
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: If you want to follow our updates, download the original source files from the
    provided link or review the changes that we make to Dragan's source files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想关注我们的更新，请从提供的链接下载原始源文件，或者查看我们对Dragan的源文件所做的更改。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Let''s jump right in as we have a lot of work to do:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们马上开始，因为我们有很多工作要做：
- en: 'Create the HTML file:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建HTML文件：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the CSS file `canvas3DGraph.css`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建CSS文件`canvas3DGraph.css`：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now it's time to move into the JavaScript file.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候转到JavaScript文件了。
- en: 'Let''s add a few helper variables:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一些辅助变量：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to create our chart when the document is ready:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文档准备就绪时，我们需要创建我们的图表：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the `plotBar` function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`plotBar`函数：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the formatter function `styleFormatter`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建格式化函数`styleFormatter`：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Assuming that you are using our modified, open source JavaScript file, you should
    now see your chart animated. (In the *There's more...* section in this recipe,
    we will look deeper into the changes and why we made them.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在使用我们修改过的开源JavaScript文件，现在您应该看到您的图表正在进行动画。(在这个食谱的*更多内容*部分，我们将深入研究这些更改以及我们为什么进行这些更改。)
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's first look at our code in the way that we interact with the JavaScript
    library. After that we will dig deeper into the inner workings of this library.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先以与JavaScript库交互的方式来查看我们的代码。之后我们将更深入地了解这个库的内部工作原理。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `gData` array will store all the possible points in the 3D space. A 3D bar
    will be created with these points (the points are the 3D points x, y, and z values
    that will be put into this array as objects). The `trailingArray` array will store
    the current bar elements in the view. The `trailCount` variable will define how
    many bars can be seen at the same time, and our current index (`curIndex`) will
    keep track of our latest addition into the chart.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`gData`数组将存储3D空间中所有可能的点。一个3D条形图将使用这些点创建(这些点是将作为对象放入这个数组中的3D点x、y和z值)。`trailingArray`数组将存储视图中当前的条形图元素。`trailCount`变量将定义同时可以看到多少条形图，我们的当前索引(`curIndex`)将跟踪我们最新添加到图表中的元素。'
- en: 'When the window loads we create our graph element:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口加载时，我们创建我们的图表元素：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After creating our graph, we update the `barStyle` property to reflect the colors
    that we want to use on our bar. In addition to this, we are sending a formatter
    function as we want to treat each bar separately (visually treat them differently).
    We then create our data feed—in our case it's a traveling `Math.cos` in our inner
    space. Feel free to play around with all the data points; it creates some really
    amazing content. In a real-life application, you would want to use live or real
    data. To ensure that our data will be stacked from back to front, we would need
    to sort our data so that the z value that is in the back would be rendered first.
    In our case sorting isn't needed as our loop is creating an order of z indexes
    that grow in order, so the array is already organized.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的图表之后，我们更新`barStyle`属性以反映我们想要在条形图上使用的颜色。除此之外，我们还发送了一个格式化函数，因为我们希望单独处理每个条形图(在视觉上对它们进行不同处理)。然后我们创建我们的数据源——在我们的情况下是在我们的内部空间中旅行的`Math.cos`。随意玩弄所有数据点；它会产生一些非常惊人的内容。在实际应用中，您可能希望使用实时或真实数据。为了确保我们的数据将从后到前堆叠，我们需要对数据进行排序，以便后面的z值首先呈现。在我们的情况下，不需要排序，因为我们的循环正在创建一个按顺序增长的z索引顺序，所以数组已经组织好了。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Next we call `plotBar` and repeat the action every 40 milliseconds.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们调用`plotBar`并且每40毫秒重复一次这个动作。
- en: The logic behind plotBar
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: plotBar的逻辑
- en: 'Let''s review the logic within the `plotBar` function. This is the really cool
    part of our application, where we update the data feed to create an animation.
    We start by adding the current index element into the `trailingArray` array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来审查一下`plotBar`函数中的逻辑。这是我们应用程序的真正酷的部分，我们通过更新数据源来创建动画。我们首先将当前索引元素添加到`trailingArray`数组中：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If our array length is `5` or more, we need to get rid of the first element
    in the array:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数组长度为`5`或更多，我们需要摆脱数组中的第一个元素：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We then draw our chart and push the value of `curIndex` up by one. If our `curIndex`
    is greater than our array elements, we reset it to `0`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们绘制我们的图表并将`curIndex`的值增加一。如果我们的`curIndex`大于数组元素，我们将其重置为`0`。
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The logic behind styleFormatter
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: styleFormatter的逻辑
- en: 'Our formatter function is called each time a bar is drawn to calculate the
    color to be used. It will get the index of the bar and the total length of the
    data feed in the chart being processed. In our example, we are only changing the
    `alpha` value of the bars based on their position. (The greater the number, the
    closer we are to the last entered data source.) In this way, we create our fade-out
    effect:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每次绘制条形图时，我们的格式化函数都会被调用来计算要使用的颜色。它将获取条形图的索引和正在处理的图表中数据源的总长度。在我们的示例中，我们只是根据它们的位置改变条形图的`alpha`值。(数字越大，我们就越接近最后输入的数据源。)通过这种方式，我们创建了我们的淡出效果。
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There is actually much more to this sample. Without going too deep into the
    code itself, I want to outline the changes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例实际上还有更多。在不深入代码本身的情况下，我想概述一下这些更改。
- en: 'To control the colors of our bars, line 66 of the third-party package has to
    be changed. As such, I introduced `this.barStyle` and replaced all the references
    of the hardcoded values during the creation of the bar elements (and set some
    default values):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制我们的条形图的颜色，第三方包的第66行必须更改。因此，我引入了`this.barStyle`并且替换了在创建条形图元素时硬编码值的所有引用(并设置了一些默认值)：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I''ve created a style generator for our bars. This was done to help us redirect
    the logic between an external formatter and an internal style:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我们的条形图创建了一个样式生成器。这是为了帮助我们在外部格式化程序和内部样式之间重定向逻辑：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have created a clear function to delete all the visuals from the graph so
    we can re-render the data each time we call it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个清除函数，以删除图表中的所有可视内容，这样我们每次调用它时就可以重新渲染数据：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We moved the logic of drawing the chart to the `drawGraph` function, so I can
    delete the chart at the same time, making it easier for it to refresh all the
    data each time:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制图表的逻辑移动到`drawGraph`函数中，这样我可以同时删除图表，使得每次刷新所有数据更容易：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The current index and length information now travel through `drawBar` until
    it gets to the formatter function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当前索引和长度信息现在通过`drawBar`传递，直到它到达格式化函数。
- en: Last but not least, I've deleted the drawing of the chart from the constructor,
    so our chart will be more conducive for our animation idea.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我已经从构造函数中删除了绘制图表的部分，这样我们的图表将更有利于我们的动画想法。
- en: Charting over time (flotJS)
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随时间变化的图表(flotJS)
- en: One of the more impressive features of this library is the ease with which one
    can update the chart information. It's very easy to see from the first moment
    when you review this library and its samples that the author loves math and loves
    charting. My favorite feature is the way the chart can update its x ranges dynamically
    based on the input added into it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的一个更令人印象深刻的特性是更新图表信息的简易性。当您第一次审查这个库及其样本时，就可以很容易地看出作者热爱数学和图表。我最喜欢的功能是图表可以根据输入动态更新其x范围。
- en: 'My second favorite feature is how easy it is to update the chart text info
    by using a `tickFormater` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我第二喜欢的功能是使用`tickFormater`方法更新图表文本信息的简易性。
- en: '![Charting over time (flotJS)](img/3707OT_07_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![随时间变化的图表（flotJS）](img/3707OT_07_03.jpg)'
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get the latest builds of the `flotJS` library, please visit our link hub
    at [http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339)
    for charting open source libraries or download our book's source files where we
    include the latest build as of publication at [http://02geek.com/books/html5-graphics-and-data-visualization-cookbook.htm](http://02geek.com/books/html5-graphics-and-data-visualization-cookbook.htm).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`flotJS`库的最新版本，请访问我们的链接中心[http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339)以获取图表开源库，或者下载我们书籍的源文件，在出版时包含最新版本[http://02geek.com/books/html5-graphics-and-data-visualization-cookbook.htm](http://02geek.com/books/html5-graphics-and-data-visualization-cookbook.htm)。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create our HTML and JavaScript files:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的HTML和JavaScript文件：
- en: 'Create an HTML file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML文件：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new JavaScript file (`07.03.flot.js`) and then create our data source:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的JavaScript文件（`07.03.flot.js`），然后创建我们的数据源：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a `ready` event and trigger `updateChart`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ready`事件并触发`updateChart`：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create `updateChart`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`updateChart`：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create `getData`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`getData`：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now if you run the chart in your browser, you will see 6 months at a time, and
    at every half of a second, the chart will be updated by pushing the chart one
    month forward until the end of data source is reached.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在浏览器中运行图表，您将一次看到6个月，每隔半秒，图表将通过将图表向前推一个月来更新，直到数据源的末尾。
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`flotJS` has a built-in logic to reset itself when its redrawn, and that''s
    part of our magic. Our data source has been borrowed from one of the `flotJS`
    samples. We are actually using the data to represent a fictional situation. Originally
    this data was representing the average weight of people based on their age, broken
    down into percentiles. But our point in this example is not to showcase the data
    but instead show ways of visualizing the data. So in our case, we had to treat
    the data by keeping the percentiles as they are intended to be, but use the inner
    data to showcase the average over years instead of over ages, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`flotJS`具有内置逻辑，在重新绘制时重置自身，这是我们的魔法的一部分。我们的数据源是从`flotJS`的样本中借来的。我们实际上使用数据来表示一个虚构的情况。最初，这些数据代表了人们根据年龄的平均体重，按百分位数分解。但我们在这个例子中的重点不是展示数据，而是展示数据的可视化方式。因此，在我们的情况下，我们必须通过保持百分位数的原意来处理数据，但使用内部数据来展示多年来的平均值，而不是年龄，如下所示：'
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `yearID` values range from `2` through `19`. We want to showcase this information
    as if we started our data picking from 2006\. Each `yearId` will represent a month
    (19 would be 1.5 years after 2006, instead of the age 19 as the data actually
    represents).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`yearID`的值范围从`2`到`19`。我们希望将这些信息展示为如果我们从2006年开始选择我们的数据。每个`yearId`将代表一个月（19将是2006年之后1.5年的时间，而不是实际代表的年龄19）。'
- en: 'So let''s start breaking it down. Now that we know how we are going to treat
    our dataset, we want to limit the number of months that we can see at any given
    time. As such we will add two helper parameters, one of which will keep track
    of our current index and the other will track the maximum number of visible elements
    at any given time:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始分解。现在我们知道我们将如何处理我们的数据集，我们想要限制我们在任何给定时间内可以看到的月数。因此，我们将添加两个辅助参数，一个用于跟踪我们当前的索引，另一个用于跟踪任何给定时间内可见元素的最大数量：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We will create a global variable for our Flot graph and create a formatter to
    help us format the data that will be sent in.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的Flot图创建一个全局变量，并创建一个格式化程序来帮助我们格式化将发送的数据。
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that `tickFormater` enables us to modify the way our tick will look in
    the chart. In the case of the x axis, the goal is to showcase the current date
    `2/2012...`, and in the y axis, we want to add `cm` to the numbers that will be
    printed out on the screen.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tickFormater`使我们能够修改图表中刻度的外观方式。在x轴的情况下，目标是展示当前日期`2/2012...`，在y轴上，我们希望在屏幕上打印出的数字后面添加`cm`。
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are still two more things to cover—the `getData` function and the `updateChart`
    function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两件事情要讲——`getData`函数和`updateChart`函数。
- en: The GetData function
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取数据函数
- en: In `flotJS` every data point has an ID. In our case, we want to showcase six
    related content types. Play around with the parameters to see how they change
    the way the view is rendered. Before we send the created array back, we update
    the index ID by one, so the next time that the function is called it will send
    the next range.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`flotJS`中，每个数据点都有一个ID。在我们的情况下，我们想展示六种相关的内容类型。调整参数以查看它们如何改变视图的方式。在我们发送创建的数组之前，我们将索引ID更新一次，这样下次调用函数时它将发送下一个范围。
- en: 'One more thing we need to note is the actual data range. As we are not sending
    the full data range (but a maximum of `5`), we need to validate that there are
    atleast five items after the index, and if not we will return the last element
    of the array, ensuring that we never slice more than the actual length:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意的另一件事是实际数据范围。由于我们没有发送完整的数据范围（而是最多`5`个），我们需要验证索引后至少有五个项目，如果没有，我们将返回数组的最后一个元素，确保我们不会切割超过实际长度的部分：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The UpdateChart function
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新图表函数
- en: This part is probably the simplest one. The same code is used for the first
    render and all the following renders. If the dataset is valid, we create a timeout
    and call this function again until the animation completes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分可能是最简单的。相同的代码用于第一次渲染和所有后续渲染。如果数据集有效，我们创建一个超时，并再次调用此函数，直到动画完成。
- en: Building a clock with RaphaelJS
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RaphaelJS构建时钟
- en: Hands down this is my favorite sample in this chapter. It's based on a mix of
    two samples on Raphael's website (I strongly encourage you to explore it). Although
    `Raphael` isn't a graphing library, it's a really powerful animation and drawing
    library that is really worth playing with.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这是本章中我最喜欢的示例。它基于Raphael网站上的两个示例的混合（我强烈建议你去探索）。尽管`Raphael`不是一个绘图库，但它是一个非常强大的动画和绘图库，非常值得玩耍。
- en: 'In this recipe, we will create a clock that is creative (I think). I planned
    to play with this library for a day or two, and ended up playing with it all weekend
    as I was just having so much fun. I ended up with a digit morphing clock (based
    on a sample that Raphael created on his site for letter morphing) and incorporated
    some arcing into it based on the polar clock example on his site. Let''s see it
    in action:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个创意的时钟（我认为）。我计划玩这个库一两天，结果玩了整个周末，因为我玩得太开心了。我最终得到了一个数字变形时钟（基于Raphael在其网站上为字母变形创建的示例），并根据其网站上的极坐标时钟示例加入了一些弧线。让我们看看它的表现：
- en: '![Building a clock with RaphaelJS](img/3707OT_07_04.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用RaphaelJS构建时钟](img/3707OT_07_04.jpg)'
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As always in this chapter, you need the original library of Raphael. I've added
    it into our project. So just download the files and let's get rolling.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章中的其他部分一样，您需要Raphael的原始库。我已经将其添加到我们的项目中。所以只需下载文件，让我们开始吧。
- en: To grab the original library, visit our external source files hub for this chapter
    at [http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取原始库，请访问本章的外部源文件中心[http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339)。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s build up our application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的应用程序：
- en: 'Create the HTML file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建HTML文件：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now it''s time to move into the JavaScript file `07.04.raphael.js`. Copy the
    path parameters to draw the digits `0` through `9` and the `:` sign into an object
    called `helveticaForClock`. It''s really just a long list of numbers, so please
    copy them from our downloadable source files:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候进入JavaScript文件`07.04.raphael.js`了。将路径参数复制到一个名为`helveticaForClock`的对象中，以绘制数字`0`到`9`和`:`符号。这实际上只是一个很长的数字列表，所以请从我们可下载的源文件中复制它们：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are going to create an `onload` listener and put all of our code into it,
    to match it up with the style of code on Raphael''s samples:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`onload`监听器，并将所有代码放入其中，以与Raphael示例中的代码风格相匹配：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a new `Raphael` object with a 600 x 600 size:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个600 x 600大小的新`Raphael`对象：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we need to use a helper function to figure out the path to an arc. For
    that we are going to create an `arc` function as an extra attribute for our newly
    created `Raphael` object:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要使用一个辅助函数来找出弧线的路径。为此，我们将创建一个`arc`函数作为我们新创建的`Raphael`对象的额外属性：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create our drawing of the hours of the clock (00:00):'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们时钟的小时绘制（00:00）：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now it''s time to create our art for our `seconds` animation:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候为我们的`seconds`动画创建艺术品了：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the `animateSeconds` recursive function:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`animateSeconds`递归函数：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create the `animateStrokeWidth` function:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`animateStrokeWidth`函数：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you run the application now, you will see the outcome of my day of play with
    Raphael's library.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，您将看到我与Raphael库玩耍一天的成果。
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are a lot of elements to this project. Let''s start focusing on the arc
    animation. Note that one of the elements that we are using in our code is when
    we are creating our new paths (we create two of them). We are adding some hardcoded
    parameters that will be used later when we draw the arcs in the `arc` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目有很多元素。让我们开始关注弧线动画。请注意，我们在代码中使用的一个元素是当我们创建新的路径时（我们创建了两个）。我们添加了一些硬编码的参数，这些参数将在`arc`方法中后来用于绘制弧线：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We are doing that to avoid sending these three properties into the arc each
    time, and to enable us to pick a radius and stick with it without it being integrated
    or hardcoded into the animations. We based our `arc` method on the `arc` method
    used for the polar clock in Raphael's examples, but changed it so the values can
    be positive or negative (making it easier to animate back and forth).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了避免每次将这三个属性发送到弧线中，并且使我们能够选择一个半径并坚持下去，而不是将其集成或硬编码到动画中。我们的`arc`方法是基于Raphael示例中用于极坐标时钟的`arc`方法，但我们对其进行了更改，使值可以是正数或负数（这样更容易来回动画）。
- en: 'The `arc` method is then used to draw our arc when we are animating it inside
    the `animateSeconds` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`animateSeconds`函数内部动画化时，使用`arc`方法来绘制我们的弧线：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `attr` method will reset our `arc` attribute so that we can reanimate it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr`方法将重置我们的`arc`属性，以便我们可以重新对其进行动画处理。'
- en: By the way, note that in `animateStrokeWidth` we are animating the width of
    our stroke for 60 seconds from its lowest value to its highest value.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在`animateStrokeWidth`中，我们正在将我们的描边宽度从最小值动画到最大值，持续60秒。
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Did you really think we are done? I know you didn't. Let's take a look at a
    few other critical steps.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的以为我们完成了吗？我知道你没有。让我们看看其他一些关键步骤。
- en: Animating paths
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画路径
- en: One of the cooler things in this library is the capability to animate paths.
    If you have ever worked with Adobe Flash Shape Tweens, this will look very familiar—hands
    down, this is just really cool.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库中更酷的事情之一是能够动画化路径。如果您曾经使用过Adobe Flash的形状Tween，这看起来会非常熟悉——毫无疑问，这真的很酷。
- en: 'The idea is very simple. We have an object with a lot of path points. They
    create a shape together if we draw the line information through them. We have
    borrowed a list that Raphael created so we don''t need to start from scratch,
    and literally all that we are changing in it is that we don''t want our elements
    to be drawn in their current path. All we need to do is transform their location
    using the internal `Raphael.transformPath` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法非常简单。我们有一个具有许多路径点的对象。如果我们通过它们绘制线信息，它们将一起创建一个形状。我们借用了Raphael创建的一个列表，所以我们不需要从头开始，而且我们在其中改变的只是我们不希望我们的元素按照它们当前的路径绘制。我们需要做的就是使用内部的`Raphael.transformPath`方法来转换它们的位置：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In other words, we are grabbing the path information for the digit 0 and then
    we are transforming, moving it 400 pixels to the right and 100 pixels down.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们正在抓取数字0的路径信息，然后将其转换，向右移动400像素，向下移动100像素。
- en: 'In our source code, it looks like we are executing the function in a loop (which
    is a bit more complicated but condensed):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的源代码中，看起来我们正在循环执行该函数（这有点更复杂，但是压缩了）：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are basically looping through the `aLast` array (the list of digits that
    we want to create) and creating a new digit for each element. We then figure out
    the position of the digit based on the transforming information that is located
    in the `aTrans` array and then we draw it out by adding a new path into the attributes.
    Last but not least, we are saving our digit into our `aDigits` array that is to
    be used when we re-render the element later.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在循环遍历`aLast`数组（我们要创建的数字列表），并为每个元素创建一个新的数字。然后，我们根据`aTrans`数组中的转换信息确定数字的位置，然后通过添加一个新的路径到属性中将其绘制出来。最后但并非最不重要的是，我们将我们的数字保存到`aDigits`数组中，以便在以后重新渲染元素时使用。
- en: 'Each time the `animateSeconds` function gets called (once every second), we
    figure out if a digit has changed, and if it has then we are ready to update its
    information:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`animateSeconds`函数（每秒一次），我们都会弄清楚数字是否发生了变化，如果发生了变化，我们就准备更新它的信息：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We start by gathering the current time `HH:MM` into an array (`[H,H,M,M]`) followed
    by looking to see if our digits have changed. If they have changed, we grab the
    new data needed from our `helveticaForClock` function and animate it in our new
    path information for our digit (path).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先收集当前时间`HH:MM`到一个数组中（`[H,H,M,M]`），然后查看我们的数字是否发生了变化。如果它们发生了变化，我们就从我们的`helveticaForClock`函数中获取所需的新数据，并在我们的新路径信息中为我们的数字（路径）进行动画处理。
- en: That covers the most important factors for following this recipe.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了遵循此方法的最重要因素。
- en: Making a sunburst chart with InfoVis
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用InfoVis制作一个日晕图
- en: Another really cool library is `InfoVis`. If I had to categorize the library,
    I would say it's about connections. When you review the rich samples provided
    by Nicolas Garcia Belmonte, you will find a lot of relational datatypes that are
    very unique.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常酷的库是`InfoVis`。如果我必须对这个库进行分类，我会说它是关于连接的。当您查看Nicolas Garcia Belmonte提供的丰富示例时，您会发现很多非常独特的关系数据类型。
- en: This library is distributed freely through Sencha legal owners. (The copyright
    is easy to follow, but please review the notes for this and any open source project
    that you encounter.)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库是通过Sencha的法定所有者免费分发的。（版权很容易遵循，但请查看您遇到的任何开源项目的说明。）
- en: We will start with one of his base samples—the sunburst example from the source
    files. I've made a few changes to give it a new personality. The basic idea of
    a sunburst chart is to showcase relationships between nodes. While a tree is an
    ordered parent-child relationship, the relationships in a sunbust chart are bidirectional.
    A node can have a relationship with any other node, and it can be a two-way or
    one-way relationship. A dataset that is perfect for this is the example of the
    total exports of a country—lines from one country to all the other countries that
    get exports from it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从他的基本示例之一开始——源文件中的日晕示例。我做了一些改变，赋予它新的个性。日晕图的基本思想是展示节点之间的关系。树是有序的父子关系，而日晕图中的关系是双向的。一个节点可以与任何其他节点有关系，可以是双向或单向关系。一个完美适合这种情况的数据集是一个国家的总出口额的例子——从一个国家到所有其他从中获得出口的国家的线。
- en: 'We will keep it relatively simple by having only four elements (Ben, Packt
    Publishing, 02geek, and Nicolas the creator of InfoVis). I have a one-way relationship
    with each of them: as the owner of `02geek.com`, as a writer for Packt Publishing,
    and a user of InfoVis. While that is true about me, not all the others have a
    real in-depth relationship with me. Some of them have a relationship back with
    me, such as 02geek and Packt Publishing, while Nicolas for this example is a stranger
    that I''ve never interacted with. This can be depicted in a sunburst chart in
    the following way:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持相对简单，只有四个元素（Ben，Packt Publishing，02geek和InfoVis的创建者Nicolas）。我与他们每个人都有单向关系：作为`02geek.com`的所有者，作为Packt
    Publishing的作者，以及作为InfoVis的用户。虽然这对我来说是真的，但并非所有其他人都与我有真正深入的关系。其中一些人与我有联系，比如02geek和Packt
    Publishing，而对于这个例子来说，Nicolas是一个我从未互动过的陌生人。这可以用日晕图来描述：
- en: '![Making a sunburst chart with InfoVis](img/3707OT_07_05.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![使用InfoVis制作日晕图](img/3707OT_07_05.jpg)'
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As always you will need the source files, you can either download our sample
    files or get the latest release by visiting our aggregated list at [http://blog.everythingfla.com/?p=339](http://blog.everythingfla.com/?p=339).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，您将需要源文件，您可以下载我们的示例文件，或者访问我们的聚合列表获取最新版本。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create some HTML and JavaScript magic:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创造一些HTML和JavaScript的魔法：
- en: 'Create an HTML file as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML文件如下：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The rest of the code will be in `07.05.jit.js`. Create a base data source as
    follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的代码将在`07.05.jit.js`中。创建一个基本数据源如下：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s create a function that will create the nodes needed for our chart system:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个将为我们的图表系统创建所需节点的函数：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To connect the dots, we will need to create a function that will create the
    relationships between the elements:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了连接这些点，我们需要创建一个函数，用于创建元素之间的关系：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We want to be able to highlight the relationships. To do that we will need
    to have a way to rearrange the data and highlight the elements that we want highlighted:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望能够突出显示关系。为此，我们需要一种方法来重新排列数据并突出显示我们想要突出显示的元素：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create an `init` function:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`init`函数：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s start building up data sources and relationships:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始建立数据源和关系：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create the actual sunburst and interact with the API (I''ve stripped it down
    to its bare bones; in the original samples it''s much more detailed):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实际的旭日图并与API交互（我已将其简化到最基本的形式；在原始示例中，它更加详细）：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Last but not least, we want to render our chart by providing its `dataSource`
    and refresh the render for the first time:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们希望通过提供其`dataSource`来渲染我们的图表，并首次刷新渲染：
- en: '[PRE59]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That's it. If you run the application, you will find a chart that is clickable
    and fun, and just scratches the capabilities of this really cool data networking
    library.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。如果运行应用程序，您将找到一个可点击和有趣的图表，并且只是展示了这个真正酷的数据网络库的功能。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: I'll avoid getting into the details of the actual API as that is fairly intuitive
    and has a really nice library of information and samples. So instead I will focus
    on the changes and enhancements that I've created in this application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我将避免详细介绍实际API，因为那相当直观，并且具有非常丰富的信息和示例库。因此，我将专注于我在此应用程序中创建的更改和增强功能。
- en: 'Before we do that we need to understand how the data structure of this chart
    works. Let''s take a deeper look into how the data source object will look when
    filled with information:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们需要了解此图表的数据结构是如何工作的。让我们深入了解填充信息后数据源对象的外观：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There are a few important factors to note. The first is that there is a base
    parent that is the parent of all the parentless nodes. In our case it's a flat
    chart. The relationships that are really thrilling are between nodes that are
    at an equal level. As such the main parent has a relationship with all the nodes
    that are to follow. The children elements, such as `node1` in this case, could
    have relationships. They are listed out in an array called `adjacencies` that
    holds objects. The only mandatory parameter is the `nodeTo` property. It lets
    the application know the one-way relationship list. There are optional layout
    parameters that we will add later only when we want to highlight a line. So let's
    see how we can create this type of data dynamically with the help of a few functions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要因素需要注意。首先是有一个基本父级，它是所有无父节点的父级的父级。在我们的情况下，它是一个平面图表。真正令人兴奋的关系是在相同级别的节点之间。因此，主父级与所有接下来的节点都有关系。子元素，例如在这种情况下的`node1`，可能具有关系。它们在一个名为`adjacencies`的数组中列出，其中包含对象。唯一强制性的参数是`nodeTo`属性。它让应用程序知道单向关系列表。还有一些可选的布局参数，我们将在需要突出显示一条线时才添加。因此，让我们看看如何使用一些函数动态创建这种类型的数据。
- en: 'The `createNode` function helps us keep our code clean by wrapping up the dirty
    steps together. Every new element that we add needs to be added into our array
    and is needed to update our main parent (that is always going to be in position
    `0` of our array of new elements):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`createNode`函数通过将脏步骤封装在一起，帮助我们保持代码清晰。我们添加的每个新元素都需要添加到数组中，并且需要更新我们的主父元素（始终位于新元素数组的位置`0`）：'
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We return the object as we want to continue and build up the relationship with
    this object. As soon as we create a new object (in our `init` function), we call
    the `relate` function and send to it all the relationships that our element will
    have to it. The logic of the `relate` function looks more complicated that it
    actually is. The function uses a hidden or often ignored feature in JavaScript
    that enables developers to send an open-ended number of parameters into a function
    with the use of the `arguments` array that is created automatically within every
    function. We can get these parameters as an array named `arguments`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回对象，因为我们希望继续并建立与该对象的关系。一旦我们创建一个新对象（在我们的`init`函数中），我们就调用`relate`函数，并将所有与其相关的关系发送给它。`relate`函数的逻辑看起来比实际上更复杂。该函数使用JavaScript中的一个隐藏或经常被忽略的特性，该特性使开发人员能够使用`arguments`数组将开放数量的参数发送到函数中，该数组在每个函数中都会自动创建。我们可以将这些参数作为名为`arguments`的数组获取：
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `arguments` array is built into every function and stores all the actual
    information that has been sent into the function. As the first parameter is our
    object, we need to skip the first parameter and then add the new relationships
    into the `adjacencies` array.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`数组内置在每个函数中，并存储已发送到函数中的所有实际信息。由于第一个参数是我们的对象，我们需要跳过第一个参数，然后将新关系添加到`adjacencies`数组中。'
- en: Our last data-related function is our `highlight` function. The `highlight`
    function expects one parameter `nodeID` (that we created in `createNode`). The
    goal of the `highlight` function is to travel through all the data elements and
    de-highlight all the relationships limited to the one selected element and its
    relationships.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个与数据相关的函数是我们的`highlight`函数。`highlight`函数期望一个参数`nodeID`（我们在`createNode`中创建）。`highlight`函数的目标是遍历所有数据元素，并取消突出显示限于所选元素及其关系的所有关系。
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If we don't have `highlight`, we want to confirm and remove all the instances
    of the data object within the adjacencies of the node, while if it is selected,
    we need to add that same object by setting it with its own color and a thicker
    line.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有`highlight`，我们希望确认并删除节点的邻接数据对象的所有实例，而如果它被选中，我们需要通过设置它的颜色和更粗的线来添加相同的对象。
- en: 'We are almost done with the data. But when running the application, you will
    find an issue if we stop here. The issue is within the way the chart system works.
    If a line was drawn it will not redraw it again. In practical terms, if we select
    "Ben" while `ben` isn''t the first element in the list, then not all the relationships
    that "Ben" has with the others will be visible. To fix this issue, we would want
    to push the selected node to be the first element right after position `0` (main
    parent), so it will render the selected relationships first:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 数据几乎都完成了。但是在运行应用程序时，如果我们就此结束，你会发现一个问题。问题出在图表系统的工作方式上。如果画了一条线，它将不会再次重绘。实际上，如果我们选择“Ben”，而`ben`不是列表中的第一个元素，那么“Ben”与其他人的所有关系都将不可见。为了解决这个问题，我们希望将所选节点推到位置`0`（主要父节点）之后的第一个元素，这样它将首先渲染所选的关系：
- en: '[PRE64]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One more thing left is that we need to be able to refresh our content when
    the user clicks on an element. To accomplish this task, we will need to add an
    event parameter into the initializing parameter object of `jit.Sunburst`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事是，当用户点击一个元素时，我们需要能够刷新我们的内容。为了完成这个任务，我们需要在`jit.Sunburst`的初始化参数对象中添加一个事件参数：
- en: '[PRE65]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: One more thing to note in this sample is the `levelDistance` property that controls
    how close/far you are to/from the rendered element (making it bigger or smaller).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中需要注意的另一件事是`levelDistance`属性，它控制着你与渲染元素的距离（使其变大或变小）。
- en: Where is the copy?
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副本在哪里？
- en: 'There is still one more issue. We don''t have any copy in our chart enabling
    us to know what is actually being clicked on. I''ve removed it from the original
    sample as I just didn''t like the positioning of the text and couldn''t figure
    out how to get it up right, so instead I came up with a workaround. You can directly
    draw into the canvas by directly interacting with it. The canvas element will
    always be called by the same ID as our project (in our case `infovis` followed
    by `-canvas`):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题。我们的图表中没有任何副本，让我们知道实际点击的是什么。我从原始示例中删除了它，因为我不喜欢文本的定位，也搞不清楚如何把它弄对，所以我想出了一个变通方法。你可以直接与画布交互，直接在画布上绘制。画布元素将始终以与我们项目相同的ID命名（在我们的情况下是`infovis`后跟着`-canvas`）：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: I'll leave the rest for you to explore. The rest of the logic is easy to follow
    as I've stripped it down. So if you enjoy this project as well, please visit the
    InfoVis Toolkit site and play more with their interface options.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就留给你去探索了。逻辑的其余部分很容易理解，因为我已经简化了它。所以如果你也喜欢这个项目，请访问InfoVis Toolkit网站，并尝试更多他们的界面选项。
