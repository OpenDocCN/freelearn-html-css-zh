- en: Chapter 3. HTML5 Audio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。HTML5音频
- en: In the previous chapter, we discussed the importance of media distribution and
    how HTML5 has changed the web in providing both audio and video content natively
    in the browser. We specifically went over the HTML5 Video implementation, but
    we also discussed the `MediaElement` specification, which covers common APIs that
    are used by both video and audio.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了媒体分发的重要性，以及HTML5如何改变了在浏览器中提供音频和视频内容的方式。我们特别讨论了HTML5视频实现，但我们也讨论了`MediaElement`规范，该规范涵盖了视频和音频都使用的常见API。
- en: In this chapter, we go further into the specification and abstract it, making
    it reusable for audio and video. But before we get to that, we will discuss the
    server configuration with a simple example, and then move on to more advanced
    implementation with a dynamic audio player and customized controls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步研究规范并将其抽象化，使其可重用于音频和视频。但在此之前，我们将通过一个简单的示例讨论服务器配置，然后继续进行更高级的实现，包括动态音频播放器和自定义控件。
- en: 'In this chapter, we will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Integrating a simple HTML5 Audio example
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成一个简单的HTML5音频示例
- en: Configuring our server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置我们的服务器
- en: '`MediaElement` abstraction'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaElement`抽象'
- en: Extending the `MediaElement` API for audio
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`MediaElement`API以支持音频
- en: Creating a dynamic audio player
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态音频播放器
- en: Customizing the audio controls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义音频控件
- en: Server configuration
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器配置
- en: Before we get started with the HTML5 audio element, we need to configure our
    server for allowing specific audio formats to play appropriately. First, let's
    take a moment to understand the appropriate audio formats.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用HTML5音频元素之前，我们需要配置我们的服务器，以允许特定的音频格式适当播放。首先，让我们花点时间了解适当的音频格式。
- en: Audio formats
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频格式
- en: 'Support for the HTML5 audio playback is similar to that of the video element,
    in that each browser supports different types of formats for one reason or another.
    Here are some tables showcasing what is supported:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对HTML5音频播放的支持与视频元素的支持类似，因为每个浏览器出于某种原因支持不同类型的格式。以下是一些展示支持情况的表格：
- en: 'Following are the details related to desktop browsers:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是与桌面浏览器相关的细节：
- en: '| Desktop browser | Version | Codec support |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 桌面浏览器 | 版本 | 编解码器支持 |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Internet Explorer | 9.0+ | MP3, AAC |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Internet Explorer | 9.0+ | MP3，AAC |'
- en: '| Google Chrome | 6.0+ | Ogg Vorbis, MP3, WAV |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Google Chrome | 6.0+ | Ogg Vorbis, MP3, WAV |'
- en: '| Mozilla Firefox | 3.6+ | Ogg Vorbis, WAV |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Mozilla Firefox | 3.6+ | Ogg Vorbis, WAV |'
- en: '| Safari | 5.0+ | MP3, AAC, WAV |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Safari | 5.0+ | MP3，AAC，WAV |'
- en: '| Opera | 10.0+ | Ogg Vorbis, WAV |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Opera | 10.0+ | Ogg Vorbis, WAV |'
- en: 'Following are the details related to mobile browsers:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是与移动浏览器相关的细节：
- en: '| Mobile browser | Version | Codec support |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 移动浏览器 | 版本 | 编解码器支持 |'
- en: '| --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Opera Mobile | 11.0+ | Device-dependent |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Opera Mobile | 11.0+ | 设备相关 |'
- en: '| Android | 2.3+ | Device-dependent |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| Android | 2.3+ | 设备相关 |'
- en: '| Mobile Safari (iPhone, iPad, iPod Touch) | iOS 3.0+ | MPEG, MPG, MP3, SWA,
    AAC, WAV, BWF, MP4, AIFF, AIF, AIFC, CDDA, 32G, 3GP2, 3GP, 3GPP |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Mobile Safari（iPhone，iPad，iPod Touch）| iOS 3.0+ | MPEG，MPG，MP3，SWA，AAC，WAV，BWF，MP4，AIFF，AIF，AIFC，CDDA，32G，3GP2，3GP，3GPP
    |'
- en: '| Blackberry | 6.0+ | MP3, AAC |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Blackberry | 6.0+ | MP3，AAC |'
- en: As we can see, there are multiple format types that are supported by various
    browsers, both mobile and desktop. Luckily for us, this book focuses on iPhone
    web applications, so for our purpose, we will only focus on delivering MP3 formats,
    which are supported by most browsers. Now, we need to make sure our server can
    play MP3s.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，各种浏览器，无论是移动还是桌面，都支持多种格式类型。幸运的是，这本书侧重于iPhone网络应用程序，所以对于我们的目的，我们只关注传递大多数浏览器支持的MP3格式。现在，我们需要确保我们的服务器可以播放MP3。
- en: Audio format directives
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频格式指令
- en: 'In order to serve the correct MIME types, we need to configure our Apache server.
    To do this, we want to add the following directives to an `.htaccess` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供正确的MIME类型，我们需要配置我们的Apache服务器。为此，我们希望将以下指令添加到一个`.htaccess`文件中：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, for our purpose, we only need MPEG/MP3, but it's a good idea to allow
    these in order to take into account extensibility when supporting other browsers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于我们的目的，我们只需要MPEG/MP3，但允许这些格式是个好主意，以便在支持其他浏览器时考虑可扩展性。
- en: Simple HTML5 audio integration
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的HTML5音频集成
- en: 'Including audio on a page is pretty simple. We can just include the following
    markup in the page and we have an audio player instantly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上包含音频非常简单。我们只需在页面中包含以下标记，就可以立即拥有一个音频播放器：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Simple HTML5 audio integration](img/1024OT_03_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![简单的HTML5音频集成](img/1024OT_03_01.jpg)'
- en: The audio element
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 音频元素
- en: The preceding example specifies an audio element with an attribute of controls
    telling the browser to have an audio player with native controls for playback.
    Inside this element, there is a source element and a paragraph element. The source
    element specifies the source of the audio and its type. The attribute `src` on
    the source element is the relative location of the audio, and the `type` attribute
    specifies the MIME type and codec of the source. Lastly, we have a paragraph element,
    just in case the audio element is not supported.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子指定了一个带有控件属性的音频元素，告诉浏览器具有用于播放的本机控件的音频播放器。在这个元素内部，有一个源元素和一个段落元素。源元素指定音频的来源和类型。源元素上的`src`属性是音频的相对位置，`type`属性指定了源的MIME类型和编解码器。最后，我们有一个段落元素，以防音频元素不受支持。
- en: This example is perfect to demonstrate how easy it is to have media on our pages,
    except it's not always as simple. Most of the time, we want complete control over
    our components, and sometimes it's necessary to tap into the APIs specified. We've
    gone over these concepts in the previous chapter, and we have developed an extensive
    Video class that we can use here. In the next section, we'll take a step back
    and abstract the code we've written thus far.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常适合演示在我们的页面上拥有媒体有多么容易，除非它并不总是那么简单。大多数时候，我们希望完全控制我们的组件，有时需要利用指定的API。我们在上一章中已经讨论过这些概念，并且开发了一个广泛的Video类，我们可以在这里使用。在下一节中，我们将退一步，抽象我们迄今为止编写的代码。
- en: MediaElement abstraction
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MediaElement抽象
- en: We've talked about how audio and video share the same API in the HTML5 specification.
    In this section, we'll discuss taking the video JavaScript we've written and abstracting
    it so that we can re-use it for audio playback.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过音频和视频在HTML5规范中共享相同的API。在本节中，我们将讨论将我们编写的视频JavaScript抽象化，以便我们可以重用它来进行音频播放。
- en: Creating App.MediaElement.js
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建App.MediaElement.js
- en: First, let's create a new JavaScript file in our `js` directory and name it
    `App.MediaElement.js`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们的“js”目录中创建一个新的JavaScript文件，命名为“App.MediaElement.js”。
- en: Next, copy over the contents of `App.Video.js` into the new `App.MediaElement.js`
    file.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将“App.Video.js”的内容复制到新的“App.MediaElement.js”文件中。
- en: In this step, we want to make sure that our file reflects the `MediaElement`
    namespace, so we'll rename the word `Video` as `MediaElement`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们希望确保我们的文件反映了“MediaElement”命名空间，因此我们将把“Video”一词重命名为“MediaElement”。
- en: Once we've renamed everything to `MediaElement`, we probably want to remove
    the default elements and their names, because they won't be necessary for an abstracted
    class like this one. Along with those defaults, we won't need the public `fullscreen`
    method nor the `onFullScreen` callback.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们把所有东西都重命名为“MediaElement”，我们可能想要删除默认元素及其名称，因为它们对于这样一个抽象类来说是不必要的。除了这些默认值，我们也不需要公共的“fullscreen”方法或“onFullScreen”回调。
- en: 'When we make the preceding changes, our file should look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行以上更改时，我们的文件应该如下所示：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although we've written this code previously, let's briefly review the structure
    of the `MediaElement` class. This class contains exposed methods that can be accessed,
    such as `onCanPlay`, `onSeeking`, and `onEnded`. These methods are called when
    the element we pass in has dispatched the appropriate event. The events we are
    listening to are in `attachEvents`, and they contain the shared API events, such
    as `canplay`, `seeking`, `ended`, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前已经编写了这段代码，让我们简要回顾一下“MediaElement”类的结构。这个类包含可以访问的公开方法，比如“onCanPlay”、“onSeeking”和“onEnded”。当我们传递的元素分派了适当的事件时，这些方法将被调用。我们正在监听的事件在“attachEvents”中，它们包含共享的API事件，比如“canplay”、“seeking”、“ended”等等。
- en: This class essentially contains only the APIs that are shared among audio and
    video media. If we wanted to extend it for a specific functionality, such as fullscreen,
    we would extend the instance of `MediaElement` or use JavaScript inheritance for
    the `App.Video` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类基本上只包含在音频和视频媒体之间共享的API。如果我们想要扩展它以实现特定功能，比如全屏，我们将扩展“MediaElement”的实例，或者使用JavaScript继承来为“App.Video”类。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this book, we do not cover true JavaScript inheritance. Given that we want
    to review HTML5 for iPhone web application development as a whole, we don't go
    into more advanced details of JavaScript architecture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不涵盖真正的JavaScript继承。鉴于我们希望全面审查iPhone网页应用程序开发的HTML5，我们不会深入讨论JavaScript架构的更高级细节。
- en: Initializing App.MediaElement.js
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化App.MediaElement.js
- en: 'In order to initialize `App.MediaElement.js`, we can do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化“App.MediaElement.js”，我们可以这样做：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we create a new instance of `MediaElement` and pass it
    an object, which gets merged with the defaults of the `MediaElement` constructor.
    Keep in mind that `element` will always refer either to the audio or video element.
    We can choose to override the default callbacks or not, as they are optional.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个“MediaElement”的新实例，并传递了一个对象，该对象与“MediaElement”构造函数的默认值合并。请记住，“element”将始终引用音频或视频元素。我们可以选择覆盖默认的回调，也可以不覆盖，因为它们是可选的。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that we are passing in all the callbacks. This is because, since
    the writing of this book, `Zepto.js` contains a bug that does not do deep copying
    of an object if passed in the Boolean true value as the first parameter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在传递所有的回调。这是因为自从编写本书以来，“Zepto.js”包含一个bug，如果将布尔值true作为第一个参数传递，它不会进行对象的深复制。
- en: Now we are prepared to use this class with the audio class we've developed for
    this page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在这个页面上使用这个类与我们为此页面开发的音频类一起。
- en: Extending the MediaElement API for audio
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展音频的MediaElement API
- en: Now that we have an abstract `MediaElement` class, we want to build on top of
    it to allow for audio playback. Starting with the base template we've established,
    we'll create an `App.Audio` class that contains all the functionality for this
    page; from creating an instance of `MediaElement`, to creating a drop-down menu
    for switching tracks and managing the volume of each track.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个抽象的“MediaElement”类，我们希望在其基础上构建，以实现音频播放。从我们已经建立的基本模板开始，我们将创建一个包含此页面所有功能的“App.Audio”类；从创建一个“MediaElement”的实例，到创建一个下拉菜单来切换曲目和管理每个曲目的音量。
- en: The base template
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本模板
- en: 'We can establish a base template by following the pattern we have previously
    established. Here is some code you can start out with as a template:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过遵循我们之前建立的模式来建立一个基本模板。以下是一些代码，您可以用作模板的起点：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Nothing is new here, we are using the same pattern that we've used previously;
    establishing an `App.Audio` class, an IIFE that contains the `Audio` constructor,
    the same `attachEvents` method to contain the events to handle, and some prototype
    methods that extend `Audio` (`getDefaults` and `toString`). We continue to use
    `Zepto` and pass in both `window` and `document` into the IIFE as a reference
    and then self contain our code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新东西，我们使用了之前使用过的相同模式；建立一个“App.Audio”类，一个包含“Audio”构造函数的IIFE，包含处理事件的相同“attachEvents”方法，以及一些扩展“Audio”的原型方法（“getDefaults”和“toString”）。我们继续使用“Zepto”并将“window”和“document”传递给IIFE作为引用，然后自包含我们的代码。
- en: Creating an instance of MediaElement
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个MediaElement的实例
- en: In our constructor, we need to do two things. One, we need to get the audio
    element on the page and cache it. And two, we need to create or initialize an
    instance of MediaElement based on the element on the page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们需要做两件事。一是，我们需要获取页面上的音频元素并对其进行缓存。二是，我们需要根据页面上的元素创建或初始化一个基于MediaElement的实例。
- en: Finding and caching an audio element
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找和缓存音频元素
- en: 'To find the audio element and cache it, we can do the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到音频元素并将其缓存，我们可以这样做：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Remember that the `this` keyword is in reference to the instance of `audio`
    that gets returned to `App.Audio`. We then create a property on `this` called
    `audioElement`, which gets set to the first audio element found on the page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`this`关键字是指返回给`App.Audio`的`audio`实例。然后我们在`this`上创建一个名为`audioElement`的属性，该属性设置为页面上找到的第一个音频元素。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `getElementsByTagName`, which exists on the document, accepts one
    parameter, a string. This method gets all the elements on the page that match
    that tag in an array. In this instance, we only have one audio element on the
    page, so we get an array with one element found. Thus, we use `[0]` to get the
    first instance in that array.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`getElementsByTagName`存在于文档中，接受一个参数，即一个字符串。这个方法获取页面上与该标签匹配的所有元素，并以数组的形式返回。在这种情况下，我们在页面上只有一个音频元素，所以我们得到一个包含一个找到的元素的数组。因此，我们使用`[0]`来获取该数组中的第一个实例。
- en: Once we have the audio element, we cache it as a `Zepto` object so that we use
    `Zepto` once, thus increasing the performance of our application. I usually do
    this in most of my projects because I find myself using many of Zepto's built-in
    methods, especially for creating event listeners. However, this can be skipped
    if you don't find it useful in your case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了音频元素，我们将其缓存为`Zepto`对象，以便我们只使用一次`Zepto`，从而提高我们应用程序的性能。我在大多数项目中都这样做，因为我发现自己经常使用Zepto的许多内置方法，特别是用于创建事件侦听器。但是，如果在您的情况下发现它没有用处，可以跳过这一步。
- en: Initializing MediaElement
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化MediaElement
- en: 'Now that we have our audio element, we can follow the code we wrote in the
    last section on how to initialize `MediaElement`. So you don''t have to flip back,
    here''s the code we can use:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了音频元素，我们可以按照上一节中编写的代码来初始化`MediaElement`。因此，您不必翻回去，这是我们可以使用的代码：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the same code we wrote previously, and the ellipsis in the callbacks
    should contain `console.log` we had written. The one thing you should notice is
    that we pass in `this.audioElement`, our cached audio element, into this instance
    of `MediaElement`. Also, we have now created a reference to the instance of `MediaElement`
    with `this.mediaElement`. Now we can publicly control the audio from the instance
    of `App.Audio` we will create later on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前编写的代码相同，回调中的省略号应包含我们编写的`console.log`。您应该注意到的一件事是，我们将`this.audioElement`，我们缓存的音频元素，传递给`MediaElement`的实例。此外，我们现在已经创建了对`MediaElement`实例的引用，即`this.mediaElement`。现在我们可以从稍后将创建的`App.Audio`实例中公开控制音频。
- en: At this point, we have a fully functional audio player built off our abstracted
    class of `MediaElement`. However, there's not much going on; we only have a setup
    that works and is extensible, but it is not in any way unique. This is where our
    dynamic audio player will come in to play.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经建立了一个完全功能的音频播放器，基于我们抽象类`MediaElement`。然而，目前没有太多事情发生；我们只是有一个可以工作和可扩展的设置，但它并不是独一无二的。这就是我们动态音频播放器将发挥作用的地方。
- en: Dynamic audio player
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态音频播放器
- en: So at this point, we have an audio class that extends our `MediaElement` object
    with events that are exposed and therefore available for us to create dynamic
    content. Now, let's have some fun and create a dynamic audio player that switches
    tracks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这一点上，我们有一个扩展了我们的`MediaElement`对象的音频类，具有公开的事件，因此可以用来创建动态内容。现在，让我们来玩一些，创建一个可以切换曲目的动态音频播放器。
- en: The select element
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择元素
- en: Originally, when we created this application in [Chapter 1](ch01.html "Chapter 1. Application
    Architecture"), *Application Architecture*, we created a navigation that is contained
    by anchor tags and list elements. Although this works perfectly on desktop and
    perhaps the iPad, it is not suitable for smaller screen devices like the iPhone.
    For this reason, the `select` element brings up a native component that allows
    you to easily navigate choices that you can select.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，当我们在[第1章](ch01.html "第1章。应用程序架构")中创建这个应用程序时，*应用程序架构*，我们创建了一个由锚点标签和列表元素包含的导航。虽然这在桌面上和可能iPad上都可以完美运行，但对于iPhone等较小的屏幕设备来说并不适用。因此，`select`元素会弹出一个原生组件，允许您轻松导航并选择选项。
- en: Apple's developer documentation suggests that we use the `select` element in
    our apps, because it has been optimized as a custom control within iOS ([http://goo.gl/T3xuY](http://goo.gl/T3xuY)).
    This is extremely useful, because it allows us to keep within the guidelines for
    web application design for iOS.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的开发者文档建议我们在应用程序中使用`select`元素，因为它已经被优化为iOS中的自定义控件。这非常有用，因为它允许我们遵循iOS的Web应用程序设计指南。
- en: 'Now let''s go ahead with the implementation. First we need to make sure to
    add the `select` element to our page. Right now, you should have the following
    markup:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续实施。首先，我们需要确保将`select`元素添加到我们的页面中。现在，您应该有以下标记：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What we need to do is add the select element after the `audio` tag, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是在`audio`标签之后添加`select`元素，如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![The select element](img/1024OT_03_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![The select element](img/1024OT_03_02.jpg)'
- en: A select element
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择元素
- en: In the preceding code, we have added a select element that contains multiple
    options. These options have a `value` attribute, and the first option also contains
    a `selected` attribute. The value attribute should contain the track you have
    in your assets, and the selected attribute tells the `select` to have that option
    automatically selected on page load.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了一个包含多个选项的选择元素。这些选项具有`value`属性，而第一个选项还包含一个`selected`属性。value属性应包含您在资产中拥有的曲目，而selected属性告诉`select`在页面加载时自动选择该选项。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we assume that all our audio is MP3\. In your case this may
    be different, and if so, we would need to build logic into the code we will write
    to handle this logic. Because of the complexity that would be introduced, we focus
    exclusively on handling audio tracks that have a MIME type of MP3.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设所有的音频都是MP3格式。在您的情况下可能会有所不同，如果是这样，我们需要在我们将要编写的代码中构建逻辑来处理这个逻辑。由于这将引入复杂性，我们专注于处理具有MP3
    MIME类型的音频轨道。
- en: Switching audio tracks
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换音轨
- en: Now that we have a `select` element on the page listing out the several audio
    tracks in an iOS suggested manner, we now want to make our player dynamic based
    on user input. To do this, we need to create an event listener to handle the change
    event.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在页面上有一个`select`元素，以iOS建议的方式列出了几个音轨，我们现在希望根据用户输入使我们的播放器动态。为此，我们需要创建一个事件监听器来处理`change`事件。
- en: The change event listener
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: change事件监听器
- en: 'The `select` element has a specific event we can listen to, namely the `change`
    event. This is fairly easy to accomplish with `Zepto` and our cached instance
    of the audio element. To add the listener, let''s go to our `attachEvents` method
    in `App.Audio` and add the following bit of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`元素有一个特定的事件可以监听，即`change`事件。这在`Zepto`和我们缓存的音频元素实例中相当容易实现。要添加监听器，让我们进入`App.Audio`中的`attachEvents`方法，并添加以下代码：'
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First we are creating a variable called `that`, which refers to the instance
    of audio. Then we get the cached element we created in the constructor and delegate
    the `change` event coming from any `select` element on the page. When the `change`
    event fires, we call the anonymous function, namely the third parameter in the
    `on` method. Inside this anonymous function we call a method, which we have not
    created, called `onSelectedChange`, and pass it in the event or the `e` reference.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`that`的变量，它指的是音频的实例。然后，我们获取在构造函数中创建的缓存元素，并委托来自页面上任何`select`元素的`change`事件。当`change`事件触发时，我们调用匿名函数，即`on`方法中的第三个参数。在这个匿名函数内部，我们调用一个方法，我们还没有创建，叫做`onSelectedChange`，并将事件或`e`引用传递给它。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using Zepto's `on` method. This method can accept various parameters
    similar to jQuery's `on` method, but in this case, we send in the event we want
    to listen to, the element it should be coming from, and then finally a function
    that should be called. On top of this, our anonymous function is doing a call
    on the method, which we have discussed previously, but essentially it changes
    the reference of this to be audio.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Zepto的`on`方法。这个方法可以接受类似于jQuery的`on`方法的各种参数，但在这种情况下，我们发送我们想要监听的事件，它应该来自哪个元素，最后是应该被调用的函数。除此之外，我们的匿名函数正在调用我们之前讨论过的方法，但本质上它改变了`this`的引用为音频。
- en: The change event handler
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: change事件处理程序
- en: 'Once we have created the listener for the `change` event, we need to define
    the handler. We haven''t created this yet, but it entails some fairly complex
    functionality. Initially, this should be fairly easy now that we have an API via
    the `MediaElement` instance. However, we only have one audio element on the page,
    so we need to be able to use that one element for playback. Thus, we need to do
    the following in our handler:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为`change`事件创建了监听器，我们需要定义处理程序。我们还没有创建这个，但它涉及一些相当复杂的功能。最初，现在我们通过`MediaElement`实例有了一个API，这应该相当容易。然而，页面上只有一个音频元素，所以我们需要能够使用该元素进行播放。因此，在我们的处理程序中，我们需要做以下事情：
- en: Create a temporary reference to our cached audio element
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对缓存音频元素的临时引用
- en: Stop the playback of the audio, even if it is not playing
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止音频的播放，即使它没有在播放
- en: Clone the cached audio element to the temporary reference
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将缓存的音频元素克隆到临时引用
- en: Remove the audio element from the DOM
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从DOM中删除音频元素
- en: Delete the cached media element, audio element, and Zepto audio element
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除缓存的媒体元素、音频元素和Zepto音频元素
- en: Change the source of the cloned audio element
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改克隆的音频元素的源
- en: Append the cloned audio element to the DOM
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将克隆的音频元素附加到DOM
- en: Recreate the cached media element, audio element, and Zepto audio element
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新创建缓存的媒体元素、音频元素和Zepto音频元素
- en: Yes, this sounds like a lot of work to do in order to keep a single audio element
    on the page, but the code to do this is very little and involves some copy and
    paste because we have already written it. So, let's write some magic!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这听起来是为了保持页面上的单个音频元素而要做很多工作，但要做到这一点的代码很少，涉及一些复制和粘贴，因为我们已经写过了。所以，让我们写一些魔法！
- en: 'Under the event handler section, we want to include the following method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序部分，我们想要包含以下方法：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we go ahead and run the code in the browser, we should be able to switch
    between audio tracks with no problem. If you do have an issue, please refer to
    the provided source code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续在浏览器中运行代码，我们应该能够在音轨之间切换而没有问题。如果您遇到问题，请参考提供的源代码。
- en: Either way, the preceding code does exactly what we wanted. If we analyze the
    code closely, we can see that we are essentially tapping into the `MediaElement`
    class when we stop the playback. This is an example of how easy it is to play
    around with media elements such as audio and video now that it has been abstracted.
    Also note that we are using quite a few of the Zepto methods, including `clone`,
    `remove`, `prepend`, and `attr`. These are all methods that are useful, which
    is precisely the reason we cache our audio element.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，前面的代码确实实现了我们想要的效果。如果我们仔细分析代码，我们可以看到当我们停止播放时，我们实质上是在利用`MediaElement`类。这是一个很好的例子，说明了现在通过抽象化处理媒体元素（如音频和视频）是多么容易。还要注意，我们使用了相当多的Zepto方法，包括`clone`、`remove`、`prepend`和`attr`。这些都是有用的方法，这正是我们缓存音频元素的原因。
- en: You may be asking yourself what the `delete` section does in our preceding code.
    Essentially, this helps with garbage collection; it tells the JavaScript engine
    that we no longer need this and so you can recollect it. Yes, we can set them
    to the new values after we prepend the new audio element, but this is a sure fire
    way of starting fresh and not leaving anything up to guessing from the JavaScript
    engine.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问自己在我们前面的代码中`delete`部分是做什么的。基本上，这有助于垃圾收集；它告诉JavaScript引擎我们不再需要它，所以你可以重新收集它。是的，我们可以在将新音频元素前置之后将它们设置为新值，但这是一种确保从JavaScript引擎中重新开始并不留下任何猜测的方法。
- en: There is a problem with the code we've written, and that is the redundancy of
    the recreation of the `audioElement`, `$audioElement`, and `mediaElement` objects.
    As we've defined this functionality previously in our constructor, we can refactor
    to make sure our functionality is all located in one place—this is what the next
    section looks at. If you already understand what is meant by the refactor of this
    code, you can skip this part.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码存在一个问题，那就是重复创建`audioElement`、`$audioElement`和`mediaElement`对象。由于我们之前在构造函数中定义了这个功能，我们可以重构以确保我们的功能都位于一个位置——这就是下一节要讨论的内容。如果你已经理解了这段代码的重构意义，你可以跳过这部分。
- en: Refactoring our code
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构我们的代码
- en: Since we have the same code in two places, we are starting to introduce some
    redundancy. To make our application a bit more manageable, we should centralize
    the same functionality into one location. Doing this is not complex, and it is
    simpler than you would probably imagine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在两个地方有相同的代码，我们开始引入了一些冗余。为了使我们的应用程序更易管理，我们应该将相同的功能集中到一个位置。这样做并不复杂，比你想象的要简单。
- en: For our refactor, we only need to write one method, a `setAudioElement` method.
    This method should be private and only available within the `Audio` class, and
    it should only contain the code necessary for creating the references to the `audioElement`,
    `$audioElement`, and `mediaElement` objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的重构，我们只需要编写一个方法，一个`setAudioElement`方法。这个方法应该是私有的，只能在`Audio`类内部使用，它应该只包含创建对`audioElement`、`$audioElement`和`mediaElement`对象的引用所需的代码。
- en: 'To do this, create the following method in our private methods section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在我们的私有方法部分创建以下方法：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now copy the following code from the constructor, and paste it into `setAudioElement`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从构造函数中复制以下代码，并粘贴到`setAudioElement`中：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we''ve done this, let''s call `setAudioElement` within our constructor:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个，让我们在构造函数中调用`setAudioElement`：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we run our application now, it should run like normal, as if we had not
    changed anything. Now we need to replace the repeated code in the `select` handler
    to call the same method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用程序，它应该像平常一样运行，就好像我们没有改变任何东西。现在我们需要替换`select`处理程序中的重复代码，以调用相同的方法：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we've done all the refactoring we need, let's run the application on
    our iPhone simulator. When the page runs and you switch between audio tracks,
    you should not encounter any issues. There's nothing surprising here, but the
    cool thing is that you now a have common code centralized in one location. This
    is the essence of refactoring, and it helps achieve a maintainable codebase.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了所有需要的重构，让我们在iPhone模拟器上运行应用程序。当页面运行并在音轨之间切换时，你不应该遇到任何问题。这里没有什么令人惊讶的，但很酷的是，现在你有一个通用的代码集中在一个位置。这就是重构的本质，它有助于实现可维护的代码库。
- en: Initializing our Audio class
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化我们的Audio类
- en: Up to this point, we've focused on the development of the `Audio` class. That's
    fine, but now we need to initialize all of this code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于`Audio`类的开发。这很好，但现在我们需要初始化所有这些代码。
- en: 'To do this, open up the `index.html` file for the **Audio** page. This should
    be located at `/audio/index.html`. Once we''ve opened up that file, scroll to
    the bottom of the source code and add the following script after all the other
    scripts:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，打开`index.html`文件，找到**Audio**页面。它应该位于`/audio/index.html`。一旦打开了该文件，滚动到源代码底部，并在所有其他脚本之后添加以下脚本：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a bit different from how we initialized `App.Video`, in that we now
    pass in the element while `App.Video` finds the video elements within it. The
    reason behind the difference was to show how we can initialize our classes differently.
    It's up to you on how you want to initialize a class. Each has its advantages
    and disadvantages, but it's good to be aware of the alternatives and choose the
    best one your code style and project needs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们初始化`App.Video`的方式有些不同，因为我们现在传入元素，而`App.Video`在其中查找视频元素。这种差异背后的原因是为了展示我们如何以不同的方式初始化我们的类。你可以自行决定如何初始化一个类。每种方式都有其优缺点，但了解替代方案并选择最适合你的代码风格和项目需求的方式是很好的。
- en: Now we have a dynamic audio player running off an abstract `MediaElement` class.
    On top of that, we have created a UI that is effective for this purpose and executes
    what is expected. But what if we want clearer control of the audio besides what
    is provided in the default interface? In the next section, we discover how to
    control our audio using the `MediaElement` class we've created previously.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个动态音频播放器运行在一个抽象的`MediaElement`类上。除此之外，我们还创建了一个对于这个目的有效的UI，并执行了预期的操作。但是，如果我们想要更清晰地控制音频，除了默认界面提供的内容之外呢？在下一节中，我们将发现如何使用之前创建的`MediaElement`类来控制我们的音频。
- en: Customizing HTML5 audio controls
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义HTML5音频控件
- en: In this section, we'll cover how to customize the controls of our audio player.
    As we've seen in our video player discussed in the previous chapter, it can be
    fairly useful to create a custom experience. For this book, we've kept it fairly
    simple, and we will continue following that pattern so that we can discuss the
    principles and get you started quickly. For audio, customizing the controls is
    even simpler, especially since we do not have control over the volume, which is
    discussed further in the following section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍如何自定义音频播放器的控件。正如我们在上一章讨论的视频播放器中所看到的，创建自定义体验可能非常有用。对于本书来说，我们保持了相当简单的方式，并将继续遵循这种模式，以便我们可以讨论原则并让你快速入门。对于音频，自定义控件甚至更简单，特别是因为我们无法控制音量，这将在下一节中进一步讨论。
- en: Creating custom media controls
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义媒体控件
- en: 'First, let''s remove the `controls` attribute from our `audio` element. When
    we do this, you should have the following markup:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从`audio`元素中删除`controls`属性。这样做后，你应该有以下标记：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we need to add custom controls to the markup. We can continue doing the
    same thing we did in the previous chapter, except this time we abstract it with
    a media-controls class and keep it simple by just having a play and pause button.
    This should also go after the `audio` element. When we are finished, the markup
    should look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向标记添加自定义控件。我们可以继续做与上一章相同的事情，只是这次我们用一个media-controls类来抽象它，并简单地只有一个播放和暂停按钮。这也应该放在`audio`元素之后。完成后，标记应该是这样的：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you check out the application on the iPhone simulator, it should look
    like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在iPhone模拟器上查看应用程序时，它应该是这样的：
- en: '![Creating custom media controls](img/1024OT_03_03.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义媒体控件](img/1024OT_03_03.jpg)'
- en: Custom controls
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义控件
- en: What you will notice is that we now have no audio element being displayed on
    the page. This is because we have taken out the `controls` attribute. Don't worry
    about it too much; this is the expected behavior on iOS. Normally, you would create
    all the controls for your audio player, but for now we'll just do play and pause.
    As a bonus, you would probably want a track as well, but that is for a much larger
    discussion and does not fit the scope of this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到的是，现在页面上没有显示音频元素。这是因为我们已经去掉了`controls`属性。不要太担心；这是iOS上预期的行为。通常，您会为音频播放器创建所有控件，但现在我们只做播放和暂停。作为奖励，您可能还想要一首曲目，但这是一个更大讨论的内容，不适合本书的范围。
- en: Adding interactivity to our customized controls
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的自定义控件添加交互性
- en: This is where all the magic happens. We will now connect the interactivity we've
    built into the `MediaElement` class in order to customize our experience.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有魔术发生的地方。我们现在将连接我们已经构建的交互性到`MediaElement`类，以定制我们的体验。
- en: 'First, let''s go to our `App.Audio` JavaScript file and find the `attachEvents`
    method. To keep it short and simple, let''s include the following bit of code
    after our `change` event listener:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们去我们的`App.Audio` JavaScript文件中找到`attachEvents`方法。为了简短和简单起见，让我们在我们的`change`事件监听器之后包含以下代码片段：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code uses the cached `$element` to find the media controls, and
    then attaches the clock event onto the play and pause buttons accordingly. Inside
    each event listener we use the instance of `mediaElement` that has been created
    within the `setAudioElement` method to call the `play` or `pause` methods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用缓存的`$element`来查找媒体控件，然后相应地将时钟事件附加到播放和暂停按钮上。在每个事件监听器内部，我们使用在`setAudioElement`方法中创建的`mediaElement`的实例来调用`play`或`pause`方法。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing to note is that our event listeners are using `that` in order to reference
    the instance of `mediaElement`. If you recall, we created the `that` variable
    at the top of the `attachEvents` method so that we have a reference of `this`
    inside of the event listener. As we've explained previously, JavaScript has function
    scope, so when we create our event listener, that function has created a new scope
    that sets the relation of `this` to the scope of the event. Behind the scenes,
    Zepto sets `this` to the target element, which would be either the `play` or `pause`
    element.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，我们的事件监听器使用`that`来引用`mediaElement`的实例。如果您还记得，我们在`attachEvents`方法的顶部创建了`that`变量，以便在事件监听器内部有一个`this`的引用。正如我们之前解释过的，JavaScript具有函数作用域，因此当我们创建我们的事件监听器时，该函数创建了一个新的作用域，将`this`的关系设置为事件作用域。在幕后，Zepto将`this`设置为目标元素，这可能是`play`或`pause`元素。
- en: This is all we need to make customized controls that play and pause our audio.
    If we now test the application, we should be able to switch between tracks, play
    our track, and pause the track.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的一切，以制作自定义控件来播放和暂停我们的音频。如果我们现在测试应用程序，我们应该能够在曲目之间切换，播放我们的曲目，并暂停曲目。
- en: Sequential playback
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序播放
- en: In this section, we take a look at how we can build a preliminary playlist.
    Although this section is more bonus material, it's useful when creating some sort
    of a music player application where there are playlists of music we want to play
    sequentially. At first, it may be difficult to understand how we can do this,
    especially given the fact that we need user input to enable playback, but it's
    not really an issue. Because the load and play methods are initiated on the first
    song, we can just switch the source, load it, and then play the track. So let's
    go through it step-by-step.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看如何构建一个初步的播放列表。虽然这一部分更多是额外材料，但在创建某种音乐播放器应用程序时，有音乐播放列表是很有用的。起初，可能很难理解我们如何做到这一点，特别是考虑到我们需要用户输入来启用播放，但这实际上并不是问题。因为加载和播放方法是在第一首歌曲上启动的，我们只需切换源，加载它，然后播放曲目。所以让我们一步一步地进行。
- en: The markup
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记
- en: 'We don''t really want to play music sequentially by default, this should be
    user initiated based on good user experience design. So, let''s include another
    button for the user to enable or disable this feature:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不希望默认按顺序播放音乐，这应该是基于良好的用户体验设计由用户发起的。因此，让我们为用户添加另一个按钮来启用或禁用此功能：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All we've done in the preceding code is added another button after the play
    and pause buttons. This button contains the appropriate three classes that we
    need and the text `Sequential Off`, because we only want users to enable this
    feature if they want to.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们所做的只是在播放和暂停按钮之后添加了另一个按钮。这个按钮包含了我们需要的适当的三个类和文本“Sequential Off”，因为我们只希望用户在需要时启用此功能。
- en: 'When your markup is all set, you should have the following interface:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的标记都设置好后，您应该有以下界面：
- en: '![The markup](img/1024OT_03_04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![标记](img/1024OT_03_04.jpg)'
- en: The sequential button
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序按钮
- en: The JavaScript
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'There''s a bit of work to do here, but nothing overly complicated. Here''s
    what we want to do as a checklist:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些工作要做，但并不是太复杂。以下是我们要做的清单：
- en: Create a default setting for sequential playback, and set it to false
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为顺序播放创建默认设置，并将其设置为false
- en: Create a `handleOnAudioEnded` method, with a parameter for the `Audio` class
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`handleOnAudioEnded`方法，带有`Audio`类的参数
- en: Call the `handleOnAudioEnded` method within the `onEnded` callback of the MediaElement
    initialization
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在媒体元素初始化的`onEnded`回调中调用`handleOnAudioEnded`方法
- en: Inside the `handleOnAudioEnded` method, we should check if sequential playback
    is enabled
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`handleOnAudioEnded`方法中，我们应该检查顺序播放是否已启用
- en: If sequential playback is enabled, we want to update the select menu and reload
    the audio element
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果启用了顺序播放，我们希望更新选择菜单并重新加载音频元素
- en: Finally, we want to listen for the click event on the new sequential button
    to enable or disable this feature, while also updating the button's status as
    well
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们希望监听新的顺序按钮的点击事件以启用或禁用此功能，同时也更新按钮的状态
- en: 'So, first things first, let''s create the sequential default setting:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先，让我们创建顺序的默认设置：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Nothing too crazy, we''ve just added a default setting called `sequential`
    and set it to `false`. Next, we want to create the `handleOnAudioEnded` method
    that contains the functionality we''ve listed previously:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 没有太疯狂的事情，我们只是添加了一个名为`sequential`的默认设置，并将其设置为`false`。接下来，我们想创建包含我们之前列出的功能的`handleOnAudioEnded`方法：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Don''t worry if you don''t understand the preceding code, just take the following
    points into account:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解前面的代码，不要担心，只需考虑以下几点：
- en: The only parameter we are passing is an instance of `Audio`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们传递的唯一参数是`Audio`的一个实例
- en: We then check if `sequential` is enabled
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们检查`sequential`是否已启用
- en: 'Once we''ve verified we want sequential playback, we create two variables:
    `$select`, which caches the select element, and `$next`, which will cache the
    next song in the playlist'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们确认我们想要顺序播放，我们创建两个变量：`$select`，它缓存了选择元素，和`$next`，它将缓存播放列表中的下一首歌曲。
- en: Then we set the `$next` element while removing the `selected` attribute from
    the current option
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们设置`$next`元素，同时从当前选项中删除`selected`属性
- en: We update the `select` menu by setting the `selectedIndex` to the next option
    in `select`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`select`的`selectedIndex`设置为`select`中的下一个选项来更新`select`菜单
- en: Finally, we update the audio elements source directly, load that source, and
    set the status to playing
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们直接更新音频元素的源，加载该源，并将状态设置为播放
- en: This method handles the playback of the next source we want to play. We could
    probably improve this by adding the functionality to change the source, load,
    and play inside the `MediaElement` class, but I'll leave that up to you to decide
    and extend as needed. We could also possibly cache `select` at the class level
    (`Audio`), instead of doing it each time we want to play sequentially.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法处理我们想要播放的下一个源的播放。我们可能可以通过在`MediaElement`类中添加更改源、加载和播放的功能来改进这一点，但我会把这个决定和需要扩展的功能留给你。我们也可能在类级别（`Audio`）缓存`select`，而不是每次想要顺序播放时都这样做。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have not added any error checking. Currently, this code doesn't
    do a check for when we get to the end of the list. Perhaps we want it to loop,
    or maybe we want to inform the user the playlist is done? There are many use cases
    that we can execute here, but you get the point, which is that we can have a playlist
    in our application if we wanted.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有添加任何错误检查。目前，这段代码没有检查我们是否到达列表的末尾。也许我们希望它循环，或者也许我们希望通知用户播放列表已经完成？我们可以在这里执行许多用例，但你明白我的意思，也就是说，如果我们愿意，我们可以在我们的应用程序中拥有一个播放列表。
- en: 'Next we want to call the preceding method we created when we pass in `callbacks`
    to the initialization of the media element. As you may recall, we put this in
    our `setAudioElement`, and therefore we want to update the initialization to the
    following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当我们将`callbacks`传递给媒体元素的初始化时，我们希望调用我们创建的前面的方法。你可能还记得，我们把这个放在我们的`setAudioElement`中，因此我们希望更新初始化如下：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All we did here was update the `onEnded` method by calling `handleOnAudioEnded`
    and passing in `that`, which is a reference to the instance of the `Audio` class.
    Now, all we need to do is add our event listener for when the user wants sequential
    playback, which can be added in our `attachEvents` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是通过调用`handleOnAudioEnded`来更新`onEnded`方法，并传入`that`，它是对`Audio`类实例的引用。现在，我们只需要为用户想要顺序播放时添加事件监听器，这可以在我们的`attachEvents`方法中添加：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code basically shows that we have added a `click` event listener
    to our sequential button, and all it does is call the `handleSequentialClick`
    method that accepts an event and the instance of audio with the `that` variable
    we created previously. Notice how we haven''t created the `handleSequentialClick`
    method? Well, here it is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码基本上显示了我们已经向我们的顺序按钮添加了一个`click`事件监听器，它所做的就是调用`handleSequentialClick`方法，该方法接受一个事件和我们之前创建的`that`变量的音频实例。注意我们还没有创建`handleSequentialClick`方法吗？好吧，这就是它：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Put simply, this method just updates the default `sequential` option to `true`
    or `false`, toggling the value depending on the previous status. The method also
    toggles the classes of the button and the inner text, updating the user based
    on their interaction.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个方法只是将默认的`sequential`选项更新为`true`或`false`，根据先前的状态切换值。该方法还切换按钮和内部文本的类，根据用户的交互更新用户。
- en: iOS considerations
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS注意事项
- en: Up to this point, we have customized much of the experience for both the video
    and audio elements. This will work perfectly for desktop devices, but there are
    a few points we need to take into account when working with touch devices, such
    as the iPhone and iPad. The good thing is that these are points that are consistent
    across all iOS devices, and as such should be something we take into account.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为视频和音频元素定制了许多体验。这对桌面设备来说非常完美，但在处理触摸设备（如iPhone和iPad）时，我们需要考虑一些要点。好消息是，这些是所有iOS设备上一致的要点，因此应该是我们需要考虑的事情。
- en: Volume
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音量
- en: We can set the volume for audio and video elements from `0` to `1`, and we can
    maintain the state of the volume in our `MediaElement` library. This is good practice
    for an overall architecture. However, on iOS, the volume is under the user's physical
    control—the volume button we interact with on almost any device.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为音频和视频元素设置音量从`0`到`1`，并且我们可以在我们的`MediaElement`库中保持音量的状态。这是整体架构的良好实践。然而，在iOS上，音量在用户的物理控制下——几乎任何设备上我们与之交互的音量按钮。
- en: 'As per Apple''s documentation ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW11](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 根据苹果的文档（[http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW11](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)）：
- en: On iOS devices, the audio level is always under the user's physical control.
    The volume property is not settable in JavaScript. Reading the volume property
    always returns 1.
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在iOS设备上，音量始终在用户的物理控制下。音量属性在JavaScript中不可设置。读取音量属性始终返回1。
- en: Basically, we can't set the volume property; it will always return `1`. This
    is so that we don't manipulate the user's volume, and as such is only set via
    the user's volume control button.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们无法设置音量属性；它将始终返回`1`。这是为了我们不操纵用户的音量，因此只能通过用户的音量控制按钮设置。
- en: Autoplay
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动播放
- en: In our application, we've also seen an example of autoplay, where we play the
    audio after we select a different track in our `select`. This works perfectly
    on a desktop, but not so much on iOS. There's a reason for this, and it's basically
    to protect the user's cellular data usage. This is a design decision on Apple's
    part, and is something we could see on other devices as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们还看到了自动播放的一个例子，在我们的`select`中选择不同的音轨后播放音频。这在桌面上运行得很完美，但在iOS上不太好。这是有原因的，基本上是为了保护用户的蜂窝数据使用。这是苹果的设计决定，也是我们在其他设备上可能看到的东西。
- en: 'As per Apple''s documentation ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW8](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据苹果的文档（[http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW8](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)）：
- en: Autoplay is disabled to prevent unsolicited cellular download.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动播放被禁用以防止未经请求的蜂窝下载。
- en: 'It also states that ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW4](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它还指出（[http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW4](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)）：
- en: In Safari on iOS (for all devices, including iPad), where the user may be on
    a cellular network and be charged per data unit, preload and autoplay are disabled.
    No data is loaded until the user initiates it. This means the JavaScript play()
    and load() methods are also inactive until the user initiates playback, unless
    the play() or load() method is triggered by user action. In other words, a user-initiated
    Play button works, but an onLoad="play()" event does not.
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在iOS的Safari浏览器上（包括iPad在内的所有设备），用户可能在蜂窝网络上并且按数据单位收费，预加载和自动播放都被禁用。直到用户启动它，才会加载数据。这意味着JavaScript的play()和load()方法也在用户启动播放之前无效，除非play()或load()方法是由用户操作触发的。换句话说，用户启动的播放按钮有效，但onLoad="play()"事件无效。
- en: Simultaneous playback
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时播放
- en: You might be asking why we didn't go into more complicated experiences, including
    multiple video playback or audio tracks playing at the same time. Well, there's
    a good reason for that too, and it's basically because iOS limits the playback
    of audio or video streams to one at a time. This also comes back to the fact that
    we don't want to use more cellular data than necessary on the page.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么我们没有涉足更复杂的体验，包括同时播放多个视频或音轨。嗯，这也有一个很好的理由，基本上是因为iOS限制了一次只能播放一个音频或视频流。这也归结于我们不想在页面上使用比必要更多的蜂窝数据。
- en: 'As per Apple''s documentation ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW10](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据苹果的文档（[http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW10](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)）：
- en: Currently, all devices running iOS are limited to playback of a single audio
    or video stream at any time. Playing more than one video—side by side, partly
    overlapping, or completely overlaid—is not currently supported on iOS devices.
    Playing multiple simultaneous audio streams is also not supported.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 目前，所有运行iOS的设备都限制为一次只能播放一个音频或视频流。在iOS设备上，目前不支持同时播放多个视频——并排、部分重叠或完全叠加。同时播放多个音频流也不受支持。
- en: There are more considerations that should be taken into account when developing
    an iOS web application that supports audio and video media playback. We can continue
    covering this here, but I encourage you to visit Apple's documentation, *iOS-Specific
    Considerations* ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)),
    to review all the necessary considerations. The previously mentioned documentation
    snippets should cover some of the concerns you had while developing the video
    and audio sections of this book, but it's always good to be aware of all the issues
    that come up.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发支持音频和视频媒体播放的iOS Web应用程序时，应考虑更多因素。我们可以在这里继续讨论这些内容，但我鼓励您访问苹果的文档* iOS特定注意事项*（[http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)）来审查所有必要的注意事项。先前提到的文档片段应该涵盖了您在开发本书的视频和音频部分时遇到的一些问题，但了解所有可能出现的问题总是好的。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've reviewed the media element API from the perspective of
    audio playback on iOS. From abstracting the previous code into a `MediaElement`
    class making it reusable for both audio and video, to customizing the controls
    of the audio element, we have created a dynamic audio player that works and is
    constructed in a modular pattern. Along with creating an audio player, we have
    reviewed the considerations that must be made on an iOS device, such as the control
    of volume and the limitation of simultaneous playback. I hope that this chapter
    has helped you get started experimenting with audio, and has helped you understand
    that we can consolidate code and focus on delivering features that are critical
    within our applications by abstracting our code. In the next chapter, we shift
    to how we can use touch and gestures to create unique user experiences that go
    beyond just clickable buttons.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从iOS上音频播放的角度审查了媒体元素API。从将先前的代码抽象成`MediaElement`类，使其可重用于音频和视频，到自定义音频元素的控件，我们创建了一个动态音频播放器，它以模块化的方式工作和构建。除了创建音频播放器，我们还审查了在iOS设备上必须考虑的注意事项，比如音量控制和同时播放的限制。我希望本章能帮助您开始尝试音频，并帮助您了解，通过抽象化我们的代码，我们可以
    consoli代码并专注于提供在我们的应用程序中至关重要的功能。在下一章中，我们将转向如何使用触摸和手势来创建超越可点击按钮的独特用户体验。
