- en: Chapter 4. Touch and Gestures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 触摸和手势
- en: Creating iPhone web applications, by default, involves touch interaction. This
    is obvious, and luckily Apple has done a great job getting us up and going quickly
    by mapping clicks to touch events by default. However, what if we wanted a slideshow
    that reacted to a swipe from the user? Or, what if we wanted to zoom into a photo,
    without affecting the layout of a page, when the user pinched within a defined
    area of our application? Well, that's all up to us as developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建iPhone网页应用程序默认涉及触摸交互。这是显而易见的，幸运的是，苹果已经通过默认将点击映射到触摸事件，很好地帮助我们快速上手。然而，如果我们想要一个幻灯片向用户的滑动做出反应怎么办？或者，如果我们想要在用户在应用程序的定义区域内捏合时放大照片，而不影响页面的布局怎么办？嗯，这都取决于我们作为开发者。
- en: In this chapter we'll go over touch events and gestures, and use the technology
    to build a slideshow that is responsive to a user's touch and gestures. Most of
    the concepts here will be basic to help you understand these new events that were
    not common in traditional web development. However, we'll also dive into some
    more advanced features using the pinch gesture to zoom in and out of an image.
    But, first we need to do some adjusting to our app by reorganizing our navigation,
    so that it does not take up most of the screen real estate, from there we'll start
    our dive into touch and gestures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论触摸事件和手势，并利用这项技术构建一个对用户的触摸和手势响应的幻灯片。这里的大部分概念都是基础的，以帮助您理解这些在传统网页开发中不常见的新事件。然而，我们还将深入一些更高级的功能，使用捏合手势来放大和缩小图像。但首先，我们需要对我们的应用进行一些调整，重新组织我们的导航，以便它不会占用大部分屏幕空间，然后我们将开始深入研究触摸和手势。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Simplifying our navigation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化我们的导航
- en: Creating a responsive photo gallery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式相册
- en: Listening to and handling touch events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听和处理触摸事件
- en: Interpreting touch events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释触摸事件
- en: Responding to gestures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应手势
- en: Extending touch events as a plugin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将触摸事件扩展为插件
- en: Simplifying the navigation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化导航
- en: Our navigation is currently taking up some serious real estate, and although
    it worked for our previous examples, it just won't work well with the rest of
    the examples for this book. So, first we need to clean up this application in
    order to focus on the actual content of our application. We'll clean up our markup
    to use the `select` component. Then we'll add interactivity, so that our `select`
    element actually switches between pages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的导航目前占据了一些严重的屏幕空间，尽管它对我们之前的示例有效，但它在本书的其余示例中效果不佳。所以，首先我们需要清理这个应用程序，以便专注于我们应用程序的实际内容。我们将清理我们的标记以使用`select`组件。然后我们将添加交互性，使我们的`select`元素实际上在页面之间切换。
- en: 'Before we start coding, create an `App.Nav.js` file in our JavaScript directory.
    Once the file is created, let''s include it at the bottom of our page with the
    following script tag:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，在我们的JavaScript目录中创建一个`App.Nav.js`文件。创建文件后，让我们在页面底部包含它，使用以下脚本标签：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Navigation markup and styling
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航标记和样式
- en: In this section of the chapter we look at reworking the navigation for our applications.
    In most cases we want to make sure to use native controls on the device, so the
    goal here is to provide the user the ability to use the custom select control
    in iOS, but give us the same flexibility to customize the look and feel while
    having the same interaction. We'll modify the markup, look at customizing controls,
    and then simulating the same experience.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将重新设计我们应用程序的导航。在大多数情况下，我们希望确保在设备上使用原生控件，因此这里的目标是为用户提供在iOS中使用自定义选择控件的能力，但同时给我们提供相同的灵活性来自定义外观和感觉，同时具有相同的交互。我们将修改标记，查看自定义控件，然后模拟相同的体验。
- en: The basic template
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本模板
- en: 'First, let''s get rid of the anchor tags that we are using within the navigation.
    Once we''re done removing those links, let''s create a `select` element with options
    and have the values point to the appropriate pages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们摆脱我们在导航中使用的锚标签。一旦我们移除了这些链接，让我们创建一个`select`元素，其中包含选项，并使值指向适当的页面：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code we have replaced anchor tags with a `select` element with
    options. Each option has a value that points to the specific page and within the
    option is the chapter name. Since we've removed the anchor tags, we need to adjust
    the styling.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们用`select`元素的选项替换了锚标签。每个选项都有一个值，指向特定的页面，选项中包含章节名称。由于我们已经移除了锚标签，我们需要调整样式。
- en: Styling a select component
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式化选择组件
- en: There's not much we need to do here, but remove the styling we had in place.
    Although it's not necessary, for best practice, you always want to remove unused
    styling. This helps increase the performance of your application by lowering the
    page load.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们没有太多需要做的，只需移除我们之前设置的样式。虽然这并非必需，但最佳实践是，您总是希望移除未使用的样式。这有助于通过降低页面加载来提高应用程序的性能。
- en: 'So let''s remove the following styles:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们移除以下样式：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we need to add the interactivity that mimics the default actions of an
    anchor tag.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加模仿锚标签默认操作的交互性。
- en: Navigation interactivity
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航交互
- en: Mimicking the default behavior of an anchor tag is pretty simple. Let's start
    by creating a basic template, such as those we've done in previous chapters, then
    cache the navigation and add the behavior to switch between pages. So let's get
    started!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模仿锚标签的默认行为非常简单。让我们从创建一个基本模板开始，就像我们在之前的章节中所做的那样，然后缓存导航并添加切换页面的行为。所以让我们开始吧！
- en: The basic template
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本模板
- en: Following is our default template. As before, it's just a simple IIFE that establishes
    a class for our navigation. This closure accepts the `window`, `document`, and
    `Zepto` objects, aliasing the `Zepto` object to the dollar sign.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的默认模板。和以前一样，这只是一个简单的IIFE，为我们的导航建立了一个类。这个闭包接受`window`、`document`和`Zepto`对象，并将`Zepto`对象别名为美元符号。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Caching our navigation
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存我们的导航
- en: Now, we could just use Zepto to find the navigation in the DOM each time we
    need it. But following our best practices, we can cache the navigation and have
    a variable contained in the closure scope that can be used by private and public
    methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以每次需要时使用Zepto在DOM中查找导航。但是遵循我们的最佳实践，我们可以缓存导航，并在闭包范围内包含一个变量，该变量可以被私有和公共方法使用。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we have created a `$nav` variable that is contained within
    the closure scope, so we can now reference it within all methods contained in
    this closure. Then in the constructor we set the variable to the `nav` element.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`$nav`变量，它包含在闭包范围内，因此我们现在可以在闭包中包含的所有方法中引用它。然后在构造函数中，我们将变量设置为`nav`元素。
- en: Listening and handling the change event
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听和处理change事件
- en: Now the fun begins. We need to listen to when the `select` element's change
    event is fired. We have done this before for our audio player. However, we'll
    briefly go over how to do this here in case you haven't been following along in
    order.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始有趣的部分。我们需要监听`select`元素的change事件何时被触发。我们以前为我们的音频播放器做过这个。但是，我们将简要介绍如何在这里做这个，以防您之前没有跟进。
- en: 'First, let''s call an `attachEvents` method that we will define next:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们调用一个我们将在下面定义的`attachEvents`方法：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we are calling the `attachEvents` method, we need to create it. In
    this method, we want to listen to the change event and then handle it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在调用`attachEvents`方法，我们需要创建它。在这个方法中，我们想要监听change事件，然后处理它：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code we use Zepto's `on` method to tell the cached navigation
    to listen to the change event on a `select` element, which is contained within
    the navigation. From there we assign a method we have not created, `handleSelectChange`.
    This method is a handler that we will define next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用Zepto的`on`方法告诉缓存的导航监听`select`元素上的change事件，该元素包含在导航中。然后我们分配一个我们尚未创建的方法`handleSelectChange`。这个方法是一个处理程序，我们将在下面定义。
- en: Finally, we need to define our handler. All this handler needs to do is switch
    pages based on the changed value of the `select` element.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义我们的处理程序。这个处理程序所需要做的就是根据`select`元素的更改值切换页面。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding handler accepts the event parameter, but we actually don't use
    it. You can remove this parameter, but usually I like to keep the parameters a
    handler accepts. Either way, we are telling the window object to switch locations
    by setting `window.location` to the value that the `select` element has been changed
    to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的处理程序接受事件参数，但实际上我们并没有使用它。您可以删除此参数，但通常我喜欢保留处理程序接受的参数。无论如何，我们都在告诉窗口对象通过将`window.location`设置为`select`元素已更改为的值来切换位置。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are using `this.value` to set the location of the window object.
    In this case, `this` refers to the select element itself or the element the on
    event targets.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`this.value`来设置窗口对象的位置。在这种情况下，`this`指的是选择元素本身或事件目标元素。
- en: Initializing the navigation
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化导航
- en: 'Finally, all we need to do is initialize this class. Because this navigation
    will theoretically be on every page of our application, we can immediately create
    a new instance of `App.Nav` after we have created this call. So let''s add the
    following code at the end of `App.Nav.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要做的就是初始化这个类。因为这个导航理论上将出现在我们应用程序的每个页面上，所以我们可以在创建此调用后立即创建一个`App.Nav`的新实例。因此，让我们在`App.Nav.js`的末尾添加以下代码：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is all we need to mimic the behavior of our previous anchor tags. With
    this done, we now have plenty of screen real estate to proceed with touch events.
    Next, let's discuss touch events and gestures on the iPhone.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要模仿以前锚标签行为的全部内容。完成这些后，我们现在有足够的屏幕空间来进行触摸事件。接下来，让我们讨论iPhone上的触摸事件和手势。
- en: Touch and Gesture events
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸和手势事件
- en: Touch events are easy to handle on the iPhone; however, there are a couple of
    "gotchas" when you start diving into when events are fired and how they are interpreted
    in certain situations. Luckily for us, gestures are also easily implemented with
    the `GestureEvent` object. In this section we'll go over touch and gestures in
    general, getting a fundamental understanding of the technology behind these user
    experiences so that in the next section, we can successfully create a swipeable
    slideshow.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在iPhone上处理触摸事件很容易；但是，当您开始深入研究事件何时被触发以及在某些情况下如何解释它们时，会有一些“陷阱”。幸运的是，手势也可以很容易地通过`GestureEvent`对象实现。在本节中，我们将总体上讨论触摸和手势，获得对这些用户体验背后技术的基本理解，以便在下一节中，我们可以成功地创建一个可滑动的幻灯片放映。
- en: Touch events
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸事件
- en: 'Touch events include one or more inputs received by your mobile device. In
    this book we''ll focus on up to two-finger events that we can handle in several
    ways. iOS does a great job at interpreting these inputs; however, elements can
    be either clickable or scrollable as described by Apple''s Developer documentation
    ([http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#pageTitle](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸事件包括移动设备接收的一个或多个输入。在本书中，我们将重点放在我们可以以多种方式处理的最多两个手指事件上。iOS在解释这些输入方面做得很好；但是，元素可以是可点击的或可滚动的，如苹果的开发者文档所述（[http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#pageTitle](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)）：
- en: A clickable element is a link, form element, image map area, or any other element
    with mousemove, mousedown, mouseup, or onclick handlers. A scrollable element
    is any element with appropriate overflow style, text areas, and scrollable iframe
    elements. Because of these differences, you might need to change some of your
    elements to clickable elements, as described in "Making Elements Clickable," to
    get the desired behavior in iOS.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可点击元素是链接、表单元素、图像映射区域或任何其他具有mousemove、mousedown、mouseup或onclick处理程序的元素。可滚动元素是任何具有适当溢出样式、文本区域和可滚动的iframe元素的元素。由于这些差异，您可能需要将一些元素更改为可点击元素，如“使元素可点击”中所述，以在iOS中获得所需的行为。
- en: '>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: In addition, you can turn off the default Safari on iOS behavior as described
    in "Preventing Default Behavior" and handle your own multi-touch and gesture events
    directly. Handling multi-touch and gesture events directly gives developers the
    ability to implement unique touch-screen interfaces similar to native applications.
    Read "Handling Multi-Touch Events" and "Handling Gesture Events" to learn more
    about DOM touch events.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，您可以像在“阻止默认行为”中描述的那样关闭iOS上Safari的默认行为，并直接处理自己的多点触摸和手势事件。直接处理多点触摸和手势事件使开发人员能够实现类似原生应用程序的独特触摸屏界面。阅读“处理多点触摸事件”和“处理手势事件”以了解更多关于DOM触摸事件的信息。
- en: This is essential to keep in mind because, depending on the kind of functionality
    we require, certain elements behave differently by default. If we want to modify
    this functionality, we need to override the defaults by attaching certain events
    to those elements, as described earlier. By preventing the default functionality
    and overriding it with our own, we can create experiences that are greatly customized
    to our needs. An example of this would be creating a full page parallax experience
    that plays an animation as we scroll.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必须牢记的，因为根据我们需要的功能类型，某些元素的默认行为会有所不同。如果我们想要修改这种功能，我们需要通过将某些事件附加到这些元素来覆盖默认行为，就像之前描述的那样。通过阻止默认功能并用我们自己的功能覆盖它，我们可以创建非常符合我们需求的体验。一个例子是创建一个全屏视差体验，在滚动时播放动画。
- en: Once we know what kind of behavior we want, there are a couple of important
    things we need to keep in mind. For example, events are conditional, so depending
    on the user interaction some gestures might not generate any events. Let's take
    a look at some of these events.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道我们想要的行为类型，就有一些重要的事情需要记住。例如，事件是有条件的，因此根据用户交互，某些手势可能不会生成任何事件。让我们来看看其中一些事件。
- en: On scroll
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动时
- en: A good example of a conditional event is when the user scrolls a page. In this
    interaction the scroll event only fires when the page stops moving and redraws.
    For this reason, on most parallax-driven sites the default behavior is prevented
    on the page and a custom scroll solution is implemented.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有条件事件的很好例子是用户滚动页面。在这种交互中，滚动事件只有在页面停止移动并重绘时才会触发。因此，在大多数视差驱动的网站上，页面上的默认行为会被阻止，并实现自定义滚动解决方案。
- en: On touch and hold
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触摸并保持
- en: When a user touches a clickable element and holds down their finger, an information
    bubble is displayed. But if you were hoping to catch this gesture, you're out
    of luck. Based on the official Apple documentation, no events are dispatched during
    this type of interaction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户触摸可点击元素并按住手指时，会显示一个信息气泡。但是如果您希望捕捉此手势，那就没那么幸运了。根据官方苹果文档，在这种类型的交互期间不会分派任何事件。
- en: On double-tap zoom
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双击缩放
- en: In this interaction, the user double-taps the screen and the page zooms in.
    You would think that there would be an event for this type of interaction, but
    again we don't have any events we can tie into.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种交互中，用户双击屏幕，页面会放大。你可能会认为会有一个针对这种交互的事件，但是我们没有任何可以关联的事件。
- en: If we keep in mind the exceptions discussed earlier, we should be good with
    developing our application and handling our touch events correctly. Now we need
    to know what events we can tie into for touch, including how to listen and handle
    them appropriately.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记住了之前讨论的例外情况，我们应该能够正确地开发我们的应用程序并正确处理我们的触摸事件。现在我们需要知道我们可以关联哪些事件进行触摸，以及如何适当地监听和处理它们。
- en: Supported touch events and how they work
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持的触摸事件及其工作原理
- en: 'The Apple documentation officially lists out all events that are supported
    on iOS, including the following touch and gesture events and when they were supported:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果官方文档正式列出了在iOS上支持的所有事件，包括以下触摸和手势事件以及它们的支持情况：
- en: '| Event | Generated | Conditional | Available |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 生成 | 有条件 | 可用 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `gesturestart` | yes | N/A | iOS 2.0 and later |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `gesturestart` | 是 | 不适用 | iOS 2.0及更高版本 |'
- en: '| `gesturechange` | yes | N/A | iOS 2.0 and later |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `gesturechange` | 是 | 不适用 | iOS 2.0及更高版本 |'
- en: '| `gestureend` | yes | N/A | iOS 2.0 and later |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `gestureend` | 是 | 不适用 | iOS 2.0及更高版本 |'
- en: '| `touchcancel` | yes | N/A | iOS 2.0 and later |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `touchcancel` | 是 | 不适用 | iOS 2.0及更高版本 |'
- en: '| `touchend` | yes | N/A | iOS 2.0 and later |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `touchend` | 是 | 不适用 | iOS 2.0及更高版本 |'
- en: '| `touchmove` | yes | N/A | iOS 2.0 and later |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `touchmove` | 是 | 不适用 | iOS 2.0及更高版本 |'
- en: '| `touchstart` | yes | N/A | iOS 2.0 and later |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `touchstart` | 是 | 不适用 | iOS 2.0及更高版本 |'
- en: 'Based on the preceding list, we''ve got everything we need in order to make
    complex user experiences on the iPhone using mobile Safari. If you were worried
    how these events are handled, there''s no need to be, based on the development
    documentation by Apple ([http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html))
    these events are delivered in the same way as any other browser:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '根据前面的列表，我们已经拥有了在iPhone上使用移动Safari制作复杂用户体验所需的一切。如果您担心这些事件是如何处理的，根据苹果的开发文档（[http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)），无需担心，这些事件的传递方式与任何其他浏览器相同。 '
- en: 'Mouse events are delivered in the same order you''d expect in other web browsers
    (…). If the user taps a nonclickable element, no events are generated. If the
    user taps a clickable element, events arrive in this order: mouseover, mousemove,
    mousedown, mouseup, and click. The mouseout event occurs only if the user taps
    on another clickable item. Also, if the contents of the page changes on the mousemove
    event, no subsequent events in the sequence are sent. This behavior allows the
    user to tap in the new content.'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 鼠标事件按照您在其他网络浏览器中期望的顺序传递（...）。如果用户点击一个不可点击的元素，不会生成任何事件。如果用户点击一个可点击的元素，事件按照以下顺序到达：mouseover、mousemove、mousedown、mouseup和click。只有在用户点击另一个可点击的项目时，mouseout事件才会发生。此外，如果页面内容在mousemove事件上发生变化，那么序列中的后续事件都不会发送。这种行为允许用户在新内容中点击。
- en: Now that we have a good understanding of one-finger touch events, including
    the exceptions and the way they work, we should take some time to understand gestures.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对单指触摸事件有了很好的理解，包括异常和它们的工作方式，我们应该花一些时间来理解手势。
- en: Gestures
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手势
- en: Technically, gestures are touch events and so the preceding information also
    applies to single-touch events because panning, zooming, and scrolling are all
    considered gestures. But, gestures are also complex interactions that can be interpreted
    differently. Based on the Apple documentation ([http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html))
    we can combine multi-touch events to create custom gestures;
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，手势是触摸事件，因此前面的信息也适用于单点触摸事件，因为平移、缩放和滚动都被视为手势。但是，手势也是可以被不同解释的复杂交互。根据苹果的文档（[http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)），我们可以结合多点触摸事件来创建自定义手势；
- en: Typically, you implement multi-touch event handlers to track one or two touches.
    But you can also use multi-touch event handlers to identify custom gestures. That
    is, custom gestures that are not already identified (...)
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，您会实现多点触摸事件处理程序来跟踪一个或两个触摸。但您也可以使用多点触摸事件处理程序来识别自定义手势。也就是说，自定义手势不是已经识别的手势（...）
- en: 'We''ve seen from the chart in the previous sections that we can listen to gestures
    and thus create custom experiences; however, one thing that is confusing about
    gestures and normal touch events is when they happen. But this is not a mystery,
    because Apple''s documentation ([http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/GestureEventClassReference/GestureEvent/GestureEvent.html#//apple_ref/javascript/cl/GestureEvent](http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/GestureEventClassReference/GestureEvent/GestureEvent.html))
    provides the following information to us:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前面的部分的图表中看到，我们可以监听手势，从而创建自定义体验；然而，关于手势和普通触摸事件的一件令人困惑的事情是它们发生的时间。但这并不是一个谜，因为苹果的文档（[http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/GestureEventClassReference/GestureEvent/GestureEvent.html#//apple_ref/javascript/cl/GestureEvent](http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/GestureEventClassReference/GestureEvent/GestureEvent.html)）为我们提供了以下信息：
- en: '*(...) for a two finger multi-touch gesture, the events occur in the following
    sequence:*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （...）对于双指多点触摸手势，事件按照以下顺序发生：
- en: '*1\. touchstart for finger 1\. Sent when the first finger touches the surface.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. finger 1的touchstart。当第一根手指触摸表面时发送。
- en: '*2\. gesturestart. Sent when the second finger touches the surface.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. gesturestart。当第二根手指触摸表面时发送。
- en: '*3\. touchstart for finger 2\. Sent immediately after gesturestart when the
    second finger touches the surface.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. finger 2的touchstart。当第二根手指触摸表面时立即发送gesturestart后发送。
- en: '*4\. gesturechange for current gesture. Sent when both fingers move while still
    touching the surface.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 当前手势的gesturechange。当两根手指在仍然触摸表面的情况下移动时发送。
- en: '*5\. gestureend. Sent when the second finger lifts from the surface.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. gestureend。当第二根手指从表面抬起时发送。
- en: '*6\. touchend for finger 2\. Sent immediately after gestureend when the second
    finger lifts from the surface.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. finger 2的touchend。当第二根手指从表面抬起时立即发送gestureend后发送。
- en: '*7\. touchend for finger 1\. Sent when the first finger lifts from the surface.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. finger 1的touchend。当第一根手指从表面抬起时发送。
- en: From the preceding information, we can gather that both touch and gesture events
    go hand-in-hand. This allows us to do some interesting things on the frontend
    without any guesswork. But, how do we do this? Well, the next section tackles
    this by creating a photo gallery that responds to both touch and gestures.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的信息，我们可以得出触摸和手势事件是相辅相成的。这使我们能够在前端做一些有趣的事情，而不需要猜测。但是，我们该如何做到这一点呢？好吧，下一节通过创建一个对触摸和手势都有响应的照片库来解决这个问题。
- en: Creating a responsive photo gallery
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个响应式的照片库
- en: We'll get a better understanding of touch and gesture events if we focus on
    small pieces of functionality that we have already seen in traditional mobile
    applications, such as an interactive slideshow. We've seen this everywhere, a
    slideshow with next and previous buttons but also the ability to swipe from left
    to right or vice versa. The buttons are easy, and attaching touch events is also
    fairly simple; however, swiping does not come out of the box in mobile Safari,
    so we need to build that. So let's get started by first laying out our gallery
    and then styling it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们专注于我们在传统移动应用程序中已经看到的小功能片段，比如交互式幻灯片放映，我们将更好地理解触摸和手势事件。我们到处都看到这个，一个带有下一个和上一个按钮的幻灯片放映，但也可以从左到右或从右到左滑动。按钮很容易，附加触摸事件也相当简单；然而，在移动Safari中，滑动不是开箱即用的，所以我们需要构建它。所以让我们首先布置我们的画廊，然后进行样式设置。
- en: Gallery markup and styling
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画廊标记和样式
- en: As with any slideshow gallery, it's essential that we create a good structure.
    This structure should be easy to follow and doesn't really require too many elements
    if we want to modularize it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何幻灯片画廊一样，创建一个良好的结构是至关重要的。这种结构应该易于遵循，如果我们想要模块化，就不需要太多的元素。
- en: The basic gallery slide list
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本画廊幻灯片列表
- en: 'Let''s start with something extremely basic. First, let''s create a `div` with
    a class of `gallery`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从非常基本的东西开始。首先，让我们创建一个带有`gallery`类的`div`：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From here, we want a content area that will contain all our slides. You may
    very well be asking why we just don't dump our slides inside the parent gallery
    container, and the reason for this is so that we can extend our gallery with other
    functionality, such as a play and pause button, without compromising the structure
    of the slides themselves.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们希望有一个内容区域，其中包含所有幻灯片。你可能会问为什么我们不把幻灯片直接放在父画廊容器中，原因是这样我们可以通过其他功能扩展我们的画廊，比如播放和暂停按钮，而不会影响幻灯片本身的结构。
- en: 'So let''s create another `div` inside our gallery that contains a class of
    `gallery-content`, like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们在我们的画廊内创建另一个带有`gallery-content`类的`div`，就像这样：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have a content area for our gallery, we want to make an unordered
    list of slides that contain our images. When we finally do this, our `gallery`
    markup should look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个画廊的内容区域，我们想要创建一个包含我们图像的幻灯片的无序列表。当我们最终这样做时，我们的`gallery`标记应该是这样的：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you look at the preceding markup, you may be in shock that I left out content
    for the `alt` attribute on the `image` tag. Yes, this is a bad practice, but I
    do this here to move a bit quicker. However, you shouldn't do this in your applications,
    always give your images an `alt` attribute with relative content.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到前面的标记时，可能会震惊于我在`image`标记上留下了`alt`属性的内容。是的，这是一个不好的做法，但我在这里这样做是为了更快地移动。然而，在你的应用程序中不应该这样做，始终为你的图像提供一个带有相关内容的`alt`属性。
- en: Now that we have a basic markup structure we should start styling this slideshow,
    but keep in mind that the preceding markup is not end all, be all. I've seen some
    extraordinary work on other sites, and that's cool, but we want to keep things
    simple here and give you a foundation to build upon. I encourage you to experiment
    and try new things out, but don't let the preceding markup be the final solution
    for you. Before we get to styling this, let's take a step back and understand
    why we have a content area.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的标记结构，我们应该开始为这个幻灯片秀设置样式，但要记住，前面的标记并不是最终的解决方案。我在其他网站上看到了一些非凡的工作，那很酷，但我们想在这里保持简单，并为你提供一个基础。我鼓励你进行实验和尝试新的东西，但不要让前面的标记成为你的最终解决方案。在我们开始样式化之前，让我们退一步，了解为什么我们有一个内容区域。
- en: Adding simple gallery controls
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加简单的画廊控件
- en: We don't want to complicate the styling for the content area. If we do, this
    can lead to some messy styling that "fixes our markup". For this reason, we created
    a content area and are now going to add a `controls` group to our slideshow.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想为内容区域增加复杂的样式。如果我们这样做，这可能会导致一些混乱的样式，"修复我们的标记"。因此，出于这个原因，我们创建了一个内容区域，现在要向我们的幻灯片秀添加一个`controls`组。
- en: So let's follow the same principle; let's create a `div` with a class of `gallery-controls`
    that contains two anchor tags, one for the next button and another for the previous
    button.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们遵循同样的原则；让我们创建一个带有`gallery-controls`类的`div`，其中包含两个锚标记，一个用于下一个按钮，另一个用于上一个按钮。
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, both the content area and the control are two separate areas that can be
    controlled independently. You'll see how this makes things easy for us when we
    start styling our gallery. For now, trust me, this will make it simpler for you
    to control your gallery. But now, on to our styling!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，内容区域和控件是两个可以独立控制的区域。当我们开始为我们的画廊设置样式时，你会看到这样做对我们来说是多么容易。现在，请相信我，这将使你更容易控制你的画廊。但现在，让我们开始样式化！
- en: Making images responsive
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使图像具有响应性
- en: We've gone over responsive design in the very first chapter of this book, and
    hopefully you do understand the principles. But if you don't, this chapter should
    give you a good idea of what we can do to make sure our application not only works
    on iPhone, but also on other touch devices as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的第一章已经介绍了响应式设计，希望你能理解这些原则。但如果你不理解，这一章应该给你一个很好的想法，让我们确保我们的应用程序不仅在iPhone上工作，而且在其他触摸设备上也能工作。
- en: So let's say we want our gallery to exist on mobile and desktop versions of
    our site, which is a highly desirable feature because now you are building a component
    that is reusable and device agnostic. But this also makes things difficult, not
    taking into account asset management, we need to calculate how big our images
    must be. Well, for this example, we want our images to scale to 100 percent of
    the slideshow's width, we want the slideshow to take up 100 percent of our screen
    width, and have 12 pixel padding on the sides.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们希望我们的画廊存在于我们网站的移动和桌面版本上，这是一个非常理想的功能，因为现在你正在构建一个可重用的、设备无关的组件。但这也会让事情变得困难，不考虑资产管理，我们需要计算我们的图像必须有多大。好吧，对于这个例子，我们希望我们的图像能够缩放到幻灯片的宽度的100%，我们希望幻灯片占据我们屏幕宽度的100%，并且两侧有12像素的填充。
- en: 'In order to accomplish this, we can simply set the width of all images to 100
    percent and have our gallery apply padding of 12 pixels on the sides, like so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以简单地将所有图像的宽度设置为100%，并让我们的画廊在两侧应用12像素的填充，如下所示：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that our gallery will already take 100 percent of our screen width, minus
    the padding we give it on the sides. For this reason you don''t see a property
    of `width: 100%` in `.gallery`. Also, take into account that we added 12 pixels
    to the top of the gallery to give it some room from the main navigation. And last
    but not least, we are using shorthand properties here, so that we don''t use padding-left,
    margin-top, and so on. This makes our code, not only shorter, but easier to understand
    and maintain.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，我们的画廊已经占据了屏幕宽度的100%，减去我们在两侧给它的填充。因此你在“.gallery”中看不到“width: 100%”的属性。另外，要考虑到我们在画廊顶部添加了12像素的填充，以便给它一些与主导航的空间。最后但同样重要的是，我们在这里使用了简写属性，这样我们就不用使用padding-left，margin-top等。这不仅使我们的代码更短，而且更容易理解和维护。'
- en: This is all that's needed to make a responsive gallery using CSS, the rest of
    the styling will be applied via JavaScript. Some of you may balk at this, but
    it's a fairly used technique because we need to know the device's width in order
    to set our gallery correctly for responsive use. But before we get to that, let's
    start out by finishing up the styling for our gallery.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用CSS制作响应式画廊所需的全部内容，其余的样式将通过JavaScript应用。有些人可能会对此感到反感，但这是一个相当常用的技术，因为我们需要知道设备的宽度才能正确设置我们的画廊以实现响应式使用。但在开始之前，让我们先完成我们的画廊样式。
- en: Styling our gallery
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的画廊添加样式
- en: Now let's finish up the styling for our gallery in the CSS. Some of this will
    still apply for responsive applications, but the previous section helps define
    the principles. Don't worry though; I'll go over the styling for each part of
    this application so that you can understand it thoroughly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在CSS中完成我们画廊的样式。其中一些样式仍然适用于响应式应用，但前面的部分有助于定义原则。不过不用担心，我会逐一介绍这个应用的每个部分的样式，以便你能彻底理解。
- en: 'First, let''s make sure our gallery content scales to 100 percent in width,
    and because eventually our slides will float left, we want the parent container
    to have a height; so let''s add a property of `overflow: hidden`. When you''re
    done, your styles should look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，让我们确保我们的画廊内容在宽度上扩展到100%，并且因为最终我们的幻灯片将左浮动，我们希望父容器有一个高度；所以让我们添加一个“overflow:
    hidden”的属性。当你完成后，你的样式应该是这样的：'
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we want to make sure that the unordered list also has a height for when
    the slides are floated left, so that this height gets applied to the gallery content.
    Not only that, but because we want to animate the unordered list left or right,
    based on user interaction, we need to make sure the position and starting `left`
    value are defined. When you''re done applying this styling, it should look like
    this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要确保无序列表在幻灯片左浮动时也有一个高度，这样这个高度就会应用到画廊内容上。不仅如此，因为我们想要根据用户交互来动画显示无序列表左右移动，所以我们需要确保位置和起始的“left”值已经定义。当你完成应用这些样式后，它应该看起来像这样：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Here we've also applied a `0` value to `margin` and `padding`. This is mostly
    a reset so that we don't run into any layout issues later on. `Normalize.css`
    applies some `padding` and `margin` to unordered lists by default, and this is
    good but not necessary for our application so we wipe out those values.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还将“margin”和“padding”的值设为“0”。这主要是为了重置，以免以后出现任何布局问题。“Normalize.css”默认为无序列表应用了一些“padding”和“margin”，这是好的，但对于我们的应用来说并不是必要的，所以我们清除了这些值。
- en: 'Now, let''s focus on styling the controls of our slideshow. This next step
    is mostly a setup style, so that we don''t run into any issues when we float elements
    within a container; such as what we did for the `gallery` content and unordered
    list previously. So let''s make sure `overflow` is set to `hidden` for our controls:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于样式化我们幻灯片的控件。下一步主要是设置样式，以便我们在容器内浮动元素时不会遇到任何问题；就像我们之前为“gallery”内容和无序列表所做的那样。所以让我们确保我们的控件的“overflow”设置为“hidden”：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since our controls are now set to `hidden` when elements overflow, we can float
    our next and previous buttons accordingly so that they are on the appropriate
    side of the slideshow.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的控件现在设置为“hidden”当元素溢出时，我们可以相应地浮动我们的下一个和上一个按钮，使它们位于幻灯片的适当侧面。
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is all that's needed to get the basic styling done for your slideshow.
    Unfortunately it still doesn't look pretty, and that's because we need to use
    JavaScript in order to determine the screen size, apply widths to our slides,
    and an overall width to our unordered list. However, there's one more thing we
    can do here that brings some serious performance optimization to our application,
    and that's using CSS3 transitions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为你的幻灯片做基本样式所需的全部内容。不幸的是，它看起来仍然不够漂亮，这是因为我们需要使用JavaScript来确定屏幕尺寸，为幻灯片应用宽度，并为无序列表应用总体宽度。然而，这里还有一件事情可以带来严重的性能优化，那就是使用CSS3过渡。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we move on, it's important to note that our CSS selectors are cascading
    from the `gallery` `div`. This is a good practice because it allows you to compartmentalize
    your styles. What we are doing is basically creating default styles for our gallery,
    and if anyone wanted to customize it, they could add their own class before `.gallery`
    to override these styles, allowing the gallery to be much more customizable. This
    is a basic CSS fundamental, but I thought I'd point it out in order to show the
    importance of creating styles that are modular.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，重要的是要注意，我们的CSS选择器是从“gallery”“div”中级联的。这是一个很好的做法，因为它允许你将样式分隔开来。我们所做的基本上是为我们的画廊创建默认样式，如果有人想要自定义它，他们可以在“.gallery”之前添加自己的类来覆盖这些样式，从而使画廊更加可定制。这是一个基本的CSS基本原则，但我想指出它的重要性，以显示创建模块化样式的重要性。
- en: Using CSS3 transitions
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CSS3过渡
- en: CSS3 transitions are extremely important to our applications. Not only because
    it makes things easier for us, but also because it gives us performance optimization.
    By default, mobile Safari uses hardware acceleration for CSS3 transitions; what
    this means is that the hardware will handle the rendering of these transitions,
    and as such we won't need to do it manually. Traditionally, we needed to do this
    using JavaScript, and because of that we gained no performance optimization, but
    now we do with CSS3 transitions. So let's use them!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3过渡对我们的应用程序非常重要。不仅因为它让我们的工作变得更容易，而且因为它为我们提供了性能优化。默认情况下，移动Safari使用硬件加速进行CSS3过渡；这意味着硬件将处理这些过渡的渲染，因此我们不需要手动处理。传统上，我们需要使用JavaScript来做到这一点，因为这样我们就无法获得性能优化，但现在我们可以通过CSS3过渡来实现。所以让我们使用它们！
- en: This is a basic gallery, and we want to keep it simple. So let's just add our
    transition to the unordered list. After all, the unordered list is what we want
    to animate when the user swipes or initiates an action from the controls. To do
    this, we will use the `transition` property and use shorthand to define what property
    we want to animate, how long, and what transition-timing-function, otherwise known
    as easing method, to use.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的画廊，我们希望保持它简单。所以让我们只是将我们的过渡添加到无序列表中。毕竟，无序列表是我们希望在用户滑动或从控件发起操作时进行动画处理的内容。为此，我们将使用“transition”属性，并使用简写来定义我们要动画处理的属性、持续时间以及要使用的过渡时间函数，也就是所谓的缓动方法。
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only thing we have done here is added the `transition` property to our unordered
    list. This property tells the unordered list to animate the `left` property within
    500 milliseconds and to use the default easing method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的唯一一件事就是向我们的无序列表添加了“transition”属性。这个属性告诉无序列表在500毫秒内动画处理“left”属性，并使用默认的缓动方法。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Here we are defining five transition properties, each one being prefixed to
    the browser vendor while the last is the supported standard property. This is
    done so that our gallery is usable across devices. Yes, it's a bit complicated
    and messy, but it is a necessary evil given the fact that browser vendors have
    prefixed this property and only now have begun to use the non-prefixed version.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了五个过渡属性，每个属性都添加了浏览器厂商的前缀，而最后一个是支持的标准属性。这样做是为了使我们的画廊可以在各种设备上使用。是的，这有点复杂和混乱，但鉴于浏览器厂商已经给这个属性添加了前缀，并且现在才开始使用非前缀版本，这是一个必要的恶。
- en: Gallery interactivity
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画廊互动
- en: The heart of our slideshow lies in its interactivity; from next and previous
    buttons, swipeable content and animation rich displays—our slideshow is dependent
    on JavaScript. In this section we dive deep into what makes our slideshow work;
    using our basic framework, we'll build a `Gallery` class that is efficient and
    achieves the goals stated previously. In reality, our gallery should just have
    functionality that allows it to resize and play in a certain direction. But, as
    always, this takes some setup work and then we hook everything up. So let's get
    started!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们幻灯片秀的核心在于它的互动性；从下一个和上一个按钮、可滑动的内容和富有动画的显示——我们的幻灯片秀依赖于JavaScript。在这一部分，我们深入探讨了我们的幻灯片秀是如何工作的；使用我们的基本框架，我们将构建一个高效的“Gallery”类，实现之前所述的目标。实际上，我们的画廊应该只具有允许其在某个方向上调整大小和播放的功能。但是，像往常一样，这需要一些设置工作，然后我们将一切连接起来。所以让我们开始吧！
- en: The basic template
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本模板
- en: 'First, we''ll create our `Gallery` class. This class should be set up in the
    same way as any other class we''ve built. But in case you haven''t been following
    the book in order, all we need to do is check for the `App` namespace and then
    create a `Gallery` class underneath it. Wrapped in a closure, we''ll have some
    defaults and a `Gallery` function, and return it at the end of the closure declaration.
    As we have mentioned previously, we''ll have the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建我们的“Gallery”类。这个类应该设置与我们构建的任何其他类的方式相同。但是，如果你没有按顺序阅读本书，我们只需要检查“App”命名空间，然后在其下创建一个“Gallery”类。包裹在闭包中，我们将有一些默认值和一个“Gallery”函数，并在闭包声明的末尾返回它。正如我们之前提到的，我们将有以下内容：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The only thing that is different here is that we are only passing in the `Zepto`
    object. Previously, we were passing in `window` and `document`, but for this class
    we won't need those two objects, so we limit it to the Zepto library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一不同的是我们只传入了“Zepto”对象。以前，我们传入了“window”和“document”，但对于这个类，我们不需要这两个对象，所以我们将它限制在Zepto库中。
- en: That's all we need for now, but what's more critical is to cache the elements
    we will be re-using, plus they will need to be available in the closure so that
    they are available in private and public methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所需要的就是缓存我们将要重复使用的元素，而且它们需要在闭包中可用，以便它们在私有和公共方法中可用。
- en: Caching the gallery
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存画廊
- en: Caching objects is extremely helpful in our applications, especially since it
    increases the performance and makes our app extremely efficient. By cutting down
    on the number of lookups we need to do in the DOM, we allow for faster processing
    and create a less error-prone application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，缓存对象非常有帮助，特别是因为它提高了性能，使我们的应用程序非常高效。通过减少我们在DOM中需要做的查找次数，我们可以加快处理速度，并创建一个不太容易出错的应用程序。
- en: 'Not only do we want to cache certain elements, but we want them to also be
    available in the closure so that they are accessible by all methods. To do this,
    all we need to do is add the cached variables after the `_defaults` variable located
    above our construct, like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅我们想要缓存某些元素，而且我们希望它们也在闭包中可用，以便所有方法都可以访问它们。要做到这一点，我们只需要在上面的构造函数中添加缓存变量，就像这样：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we can see that the gallery, its slides, the container
    of the slides, the number of slides, gallery controls, and slide and gallery width
    will be cached. However, at this point in time we haven't cached anything. So
    let's start assigning them the values they should have.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们可以看到画廊、它的幻灯片、幻灯片容器、幻灯片数量、画廊控件、幻灯片和画廊宽度将被缓存。然而，此时我们还没有缓存任何东西。所以让我们开始给它们分配应该有的值。
- en: 'The best place to initialize your values would be in the constructor, or when
    you create an instance of a gallery. The constructor should go ahead and cache
    the values we need for the rest of the running application. On top of that, each
    variable semantically describes what it should be holding, making it easier for
    you to understand what''s going on. Let''s take a look at the following function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化值的最佳位置应该是在构造函数中，或者在创建一个画廊的实例时。构造函数应该先缓存我们在整个运行应用程序中需要的值。此外，每个变量在语义上描述了它应该持有的内容，这样可以更容易地理解发生了什么。让我们来看看下面的函数：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From this function we can gather that we cache the gallery, and from that all
    other values are determined. For example, we use `$gallery` to find all the slides,
    or list items. This is extremely useful, because what we are doing is telling
    our application to begin with the `gallery` element and then dive into it to find
    the appropriate values. Otherwise, we would typically begin at the top of the
    document and then go down, which is extremely costly when it comes to DOM lookups.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个函数中，我们可以得出结论，我们缓存了画廊，然后从中确定了所有其他值。例如，我们使用`$gallery`来查找所有幻灯片或列表项。这非常有用，因为我们所做的是告诉我们的应用程序从`gallery`元素开始，然后深入其中找到适当的值。否则，我们通常会从文档的顶部开始，然后向下进行，这在DOM查找方面非常昂贵。
- en: This is a critical step in the process, because everything else should be easy
    as pie. So let's start hooking up some interactivity!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是过程中的一个关键步骤，因为其他所有事情都应该很容易。所以让我们开始连接一些交互！
- en: Connecting our controls
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接我们的控件
- en: First, we want the user to be able to click on the next and previous buttons.
    However, we don't want anything to happen just yet, we just want to capture those
    events. As always let's start small and then work up, what we want to do is have
    a foundation to work with.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望用户能够点击下一个和上一个按钮。但是，我们现在不希望发生任何事情，我们只是想捕获这些事件。和往常一样，让我们从小处开始，然后逐步扩大，我们想要的是有一个可以使用的基础。
- en: Attaching the events
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 附加事件
- en: 'We''ve previously gone over how to attach events, and in this chapter it''s
    no different. So first create an `attachEvents` method that looks up the next
    and previous buttons from the gallery and then calls a `play` method. When you''re
    done writing the code, you should have something like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过如何附加事件，在本章中也是一样。首先创建一个`attachEvents`方法，从画廊中查找下一个和上一个按钮，然后调用`play`方法。当你写完代码时，你应该有类似这样的东西：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Nothing is different here. We use the cached `$galleryControls` variable and
    tell it to listen to the `click` event coming from our next and previous buttons.
    When that `click` event comes from the designated element, then call our `play`
    method. If we run our code now, nothing would happen, except that we would probably
    get an error because `play` does not exist. But let''s not do that; instead we''ll
    call our `attachEvents` method in our constructor after all of the setup code
    takes place:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么不同。我们使用缓存的`$galleryControls`变量，并告诉它监听来自下一个和上一个按钮的`click`事件。当`click`事件来自指定的元素时，然后调用我们的`play`方法。如果我们现在运行我们的代码，除了可能会因为`play`不存在而出现错误之外，什么也不会发生。但我们不要这样做；相反，在所有设置代码完成后，我们将在构造函数中调用我们的`attachEvents`方法：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Nothing crazy here, we're just calling `attachEvents`, a private method. Did
    you notice how we are using `$galleryControls` even though it's a private method?
    That's because that variable exists within the closure scope, so this makes it
    easier to manage variables without polluting the global scope of the program.
    If you don't yet understand what's going on here, don't worry. With time and practice
    this will make sense and things will just be that much easier.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么疯狂的，我们只是调用`attachEvents`，一个私有方法。你是否注意到，即使它是一个私有方法，我们仍在使用`$galleryControls`？这是因为该变量存在于闭包范围内，因此这样可以更容易地管理变量，而不会污染程序的全局范围。如果你还不明白这里发生了什么，不要担心。随着时间和实践，这将变得清晰，事情将变得更容易。
- en: Now, we still have a problem. There is no `play` method, so let's create it!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还有一个问题。没有`play`方法，所以让我们创建它！
- en: Handling our events
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理我们的事件
- en: Because our `play` method does not exist, our application fails; so we need
    to write it. But what should it do? Well, for this application, we want it to
    determine the direction in which the gallery should play. Then we want it to animate
    left or right based on the current position in which the gallery is located. You
    might be saying, that sounds easier than you think. But in reality it is. So let's
    go step-by-step.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的`play`方法不存在，所以我们的应用程序失败了；所以我们需要编写它。但它应该做什么？对于这个应用程序，我们希望它确定画廊应该播放的方向。然后我们希望它根据画廊当前位置的左右动画。你可能会说，这听起来比你想象的要容易。但实际上是这样的。所以让我们一步一步来。
- en: Caching variables, again
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 再次缓存变量
- en: 'Yes, we want to cache as much as possible. Again this is a mobile application
    we are creating for iPhone and because of the nature of mobile, we need to optimize
    where we can. But what should we be caching? Well, the first thing we''ll be checking
    is direction, and then manipulating a current left position of the unordered list.
    To prevent lookups of these values, let''s just state a `currentLeftPos` and direction
    at the top of the method, like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们希望尽可能缓存。再次强调，我们正在为iPhone创建一个移动应用程序，由于移动设备的性质，我们需要尽可能进行优化。但我们应该缓存什么？好吧，我们将首先检查方向，然后操作无序列表的当前左侧位置。为了防止查找这些值，让我们在方法的顶部声明一个`currentLeftPos`和方向，如下所示：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Simple! Now, let''s determine these values. An easy way to determine direction
    is to have it based on the value of the element clicked. In this case, we can
    check for #next or #previous, the values of the `href` attributes. To make it
    simpler, we may want to remove the hash tag as well, just in case we ever wanted
    to expose this method and allow ourselves to pass in `next` or `previous`. So
    let''s do this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！现在，让我们确定这些值。确定方向的简单方法是基于所点击元素的值。在这种情况下，我们可以检查#next或#previous，即`href`属性的值。为了使其更简单，我们可能还想删除井号，以防我们将来想公开此方法并允许自己传递`next`或`previous`。所以让我们这样做：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't worry too much about the details here, but essentially since `play` is
    an event handler, `this` has become the target event, which would be our anchor
    tag. This is how we can get the `href` value from those elements. Also, don't
    be too nervous about the string manipulation going on there. Basically we are
    using `substr`, a built-in `string` method, and passing it `1` so that it starts
    at position one and then gets the rest of the string. This is how we are able
    to get the word next or previous from the `href` attribute.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太担心这里的细节，但基本上，由于“play”是一个事件处理程序，“this”已经成为目标事件，这将是我们的锚标签。这是我们如何可以从这些元素中获取“href”值的方式。同时，不要对那里进行的字符串操作太紧张。基本上，我们使用了“substr”，这是一个内置的“string”方法，并传递了“1”，这样它就从位置1开始获取字符串的其余部分。这就是我们如何能够从“href”属性中获取单词“next”或“previous”的方式。
- en: 'Great, at this point we have determined the direction. Now we want to get the
    latest left position of the unordered list. To do this, we can add the following
    bit of code after we''ve set the direction:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，到这一点上我们已经确定了方向。现在我们想要获取无序列表的最新左位置。为了做到这一点，我们可以在设置方向之后添加以下代码：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are using `parseInt`, a built-in number method that accepts an
    integer as its first parameter and then the base as its second. We do this because
    when we request the value of the `left` property, we get something like `0px`,
    and we want the value that we are using to be an integer, not a string. So `parseInt`
    helps us out by taking `0px` and interpreting it as an integer of `0`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了“parseInt”，这是一个内置的数字方法，它接受一个整数作为其第一个参数，然后将基数作为其第二个参数。我们这样做是因为当我们请求“left”属性的值时，我们得到类似“0px”的东西，而我们希望我们使用的值是一个整数，而不是一个字符串。因此，“parseInt”通过将“0px”解释为“0”的整数来帮助我们。
- en: 'Now it''s time to create the magical part of our application. This part is
    a bit complex, but in the end will help us achieve the effect we are looking for.
    But let''s first focus on getting our application to move on the next call to
    action. To do this, we want to set the left position of the unordered list to
    the current left position minus the width of a single slide. To do this, we can
    simply write the following code after the setting of `currentLeftPos`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们应用程序的神奇部分了。这部分有点复杂，但最终将帮助我们实现我们想要的效果。但首先让我们专注于让我们的应用程序在下一个行动呼叫时移动。为了做到这一点，我们希望将无序列表的左位置设置为当前左位置减去单个幻灯片的宽度。为了做到这一点，我们可以在设置“currentLeftPos”之后简单地编写以下代码：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code will do exactly as we ask it; however, there are a couple
    of issues we run into. First, this will always run, even if the previous button
    is hit. Two, there''s no check for when you have reached the very end of your
    gallery. This can easily be added to our application like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将完全按照我们的要求执行；但是，我们遇到了一些问题。首先，这将始终运行，即使点击了“previous”按钮。其次，没有检查当你到达画廊的最末端时。这可以很容易地添加到我们的应用程序中，就像这样：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may have noticed that we are using `Math.abs` on the `currentLeftPos`. That
    is because we'll be getting a negative number as our value, and since we don't
    want to complicate the math or comparison, we simply turn it into a positive integer
    using `Math.abs`. Keep it simple!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们在“currentLeftPos”上使用了“Math.abs”。这是因为我们将得到一个负数作为我们的值，而且由于我们不想使数学或比较复杂化，我们只需使用“Math.abs”将其转换为正整数。保持简单！
- en: In this adjusted code we check the direction, looking for `next`, and then checking
    to make sure the current left position is less than the gallery width minus a
    single slide's width. This helps prevent any errors that might come up.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调整后的代码中，我们检查方向，寻找“next”，然后检查当前左位置是否小于画廊宽度减去单个幻灯片的宽度。这有助于防止可能出现的任何错误。
- en: 'Now on to implementing our `previous` functionality. For this step, we''ll
    follow the same procedure; we''ll make sure we want to go in the `previous` direction,
    then we''ll do a comparison to make sure we don''t go below the `0` mark, and
    finally we''ll execute the code if the conditions have been met. When we''re done
    implementing this functionality, we should have the following bit of code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始实现我们的“previous”功能。在这一步中，我们将按照相同的步骤进行；我们将确保我们要向“previous”方向前进，然后我们将进行比较，以确保我们不会低于“0”标记，最后我们将在条件满足时执行代码。当我们完成实现这个功能时，我们应该有以下代码：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only difference here is that we are comparing against the static number
    `0`. This is to prevent any positive values that will cause a visual error in
    our gallery. Then instead of negating our numbers, we use the correct values in
    order to add to a negative number, thus giving the appearance of a `Previous`
    action.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们正在与静态数字“0”进行比较。这是为了防止任何会在我们的画廊中引起视觉错误的正值。然后，我们不是对我们的数字取反，而是使用正确的值以便将其加到负数上，从而呈现“Previous”操作的外观。
- en: 'In the end, our `play` method should look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的“play”方法应该是这样的：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Are we done? Yes we are! Even though we are only switching the left position
    value of our unordered list. We are actually animating because, if you remember,
    we've told our element to transition the left property within our CSS. See how
    easy and effective using CSS3 properties is? With a simple declaration we have
    been able to minimize code and make a highly optimized version of our gallery.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了吗？是的！尽管我们只是在切换无序列表的左位置值，但我们实际上是在进行动画，因为如果你记得，我们已经告诉我们的元素在CSS中过渡左属性。看看使用CSS3属性是多么简单和有效？通过简单的声明，我们已经能够最小化代码，并制作出高度优化的版本。
- en: Now, that we have the core of our gallery completed, let's make it responsive!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的画廊的核心已经完成，让我们使其响应式！
- en: Gallery responsiveness
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画廊响应性
- en: We're going to side-step here a bit, but it's worth the necessary effort! In
    this step, we're going to look into making our gallery responsive to our user's
    device's width. So let's get started by setting our styles.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要稍微绕个弯，但这是值得的努力！在这一步中，我们将研究如何使我们的画廊对用户设备的宽度做出响应。所以让我们开始设置我们的样式。
- en: Setting the gallery styles
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置画廊样式
- en: 'Here we''re going to set all the styles necessary to make our gallery responsive.
    There are a couple of things we need to do. First, let''s create a public `setStyles`
    method using the `Gallery` function''s `prototype`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将设置所有必要的样式，使我们的画廊具有响应性。我们需要做一些事情。首先，让我们使用`Gallery`函数的`prototype`创建一个公共的`setStyles`方法：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding method, as you may have noticed, returns the instance of `Gallery`
    and thus allows you to chain your methods. Next, get an individual slide''s width.
    This width is 100 percent of the container it''s in, so it should be of the same
    width as the gallery itself. To get this width we can do the following within
    `setStyles`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经注意到的，前面的方法返回了`Gallery`的实例，因此允许你链接你的方法。接下来，获取单个幻灯片的宽度。这个宽度是其所在容器的100%，因此应该与画廊本身的宽度相同。为了获取这个宽度，我们可以在`setStyles`中进行以下操作：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can determine the full width of the gallery by multiplying the number
    of slides by the width each is set to, which we''ve already determined in the
    previous step. When we do this, we achieve the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将幻灯片的数量乘以每个幻灯片设置的宽度来确定画廊的完整宽度，这是我们在上一步中已经确定的。当我们这样做时，我们得到以下代码：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This following step may be confusing, however it is critical because we need
    to manually set the width of each slide in order to float them next to each other.
    So what we need to do now is apply the `slideWidth` value to each slide, like
    so:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤可能会令人困惑，但它非常重要，因为我们需要手动设置每个幻灯片的宽度，以便将它们浮动在一起。因此，我们现在需要做的是将`slideWidth`值应用到每个幻灯片上，如下所示：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can also set the width of the slides container using the calculate
    gallery width. Again, we need to do this in order to keep a gallery that has slides
    which are floated to the left. So we''ll set the slide container''s width and
    then float all our slides to the left. Your `setStyles` method will look like
    this, when we code these requirements:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还可以使用计算画廊宽度来设置幻灯片容器的宽度。同样，我们需要这样做，以便保持一个具有左浮动幻灯片的画廊。因此，我们将设置幻灯片容器的宽度，然后将所有幻灯片左浮动。当我们编写这些要求时，你的`setStyles`方法将如下所示：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is all it takes in order to set our gallery's styles in a responsive manner.
    However, there's one issue here; the styles cannot reset, which is needed in order
    to determine the widths of the slides and containers appropriately when the device's
    orientation or width changes in some way. Let's do some setup work in order to
    get this reset going.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是以响应式方式设置我们的画廊样式所需的全部步骤。然而，这里有一个问题；样式无法重置，这是为了在设备的方向或宽度发生变化时适当地确定幻灯片和容器的宽度而需要的。让我们进行一些设置工作，以便进行重置。
- en: 'To do this, we''ll simply wrap our functionality within a method that we then
    pass to a public `resetStyles` method. In this technique, we are essentially sending
    in a `callback` that will get executed when `resetStyles` functionality has finished
    taking place. For now, your code should result in the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将简单地将我们的功能包装在一个方法中，然后将其传递给一个公共的`resetStyles`方法。在这种技术中，我们实质上是在发送一个`回调`，当`resetStyles`功能完成时将被执行。目前，你的代码应该产生以下结果：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, all the functionality we originally created for `setStyles`
    has been wrapped in an anonymous function, also known as a `callback`, that will
    get called when `resetStyles` is done running. To get the full picture, let's
    continue on by creating our `resetStyles` function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们最初为`setStyles`创建的所有功能都被包装在一个匿名函数中，也被称为`回调`，当`resetStyles`运行完成时将被调用。为了全面了解情况，让我们继续创建我们的`resetStyles`函数。
- en: Resetting the gallery styles
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重置画廊样式
- en: Resetting an element's style is actually not that complicated, so we'll go head
    first into this method. Check out the following code that should be within your
    `reset` method.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 重置元素的样式实际上并不复杂，所以我们将直接进入这个方法。查看下面应该在你的`reset`方法中的代码。
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Not too crazy right? We are basically just removing the inline styles that Zepto
    applies when we set an element's style using JavaScript, or what we've done in
    our `setStyles` method. When we remove these styles, we then check for a `callback`
    method and execute that method. This is a good practice because, let's say we
    need to reset the styles of our gallery for any other reason; we don't want to
    create unnecessary functions for no reason.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 不会太疯狂吧？我们基本上只是删除 Zepto 在我们使用 JavaScript 设置元素样式时应用的内联样式，或者我们在`setStyles`方法中所做的事情。当我们删除这些样式时，然后检查是否有`回调`方法并执行该方法。这是一个很好的做法，因为假设我们需要出于任何其他原因重置我们画廊的样式；我们不想无缘无故地创建不必要的函数。
- en: Initializing the gallery styles
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化画廊样式
- en: The last thing we need to do is initialize our styles. To do this, let's call
    `setStyles` when our code initializes in the `Gallery` constructor.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是初始化我们的样式。为此，让我们在`Gallery`构造函数中初始化代码时调用`setStyles`。
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When we finally have our styles in place, our application should look like
    the following in the portrait mode:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最终设置好我们的样式时，我们的应用程序在纵向模式下应该如下所示：
- en: '![Initializing the gallery styles](img/1024OT_04_01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![初始化画廊样式](img/1024OT_04_01.jpg)'
- en: Responsive gallery
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式画廊
- en: 'In landscape mode, our application should like the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在横向模式下，我们的应用程序应该如下所示：
- en: '![Initializing the gallery styles](img/1024OT_04_02.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![初始化画廊样式](img/1024OT_04_02.jpg)'
- en: Responsive gallery
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式画廊
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unfortunately, your application won't look or behave like the one shown in these
    screenshots; this is because nothing is hooked up right now and we haven't even
    gone through initializing any of our code. But if you do want to get to that immediately
    and see how we do it, you can check out the last section in this chapter, right
    before our conclusion. If you follow those steps, you should have an application
    that will look similar to what we have just seen.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你的应用程序不会看起来或行为像这些截图中显示的应用程序；这是因为现在没有任何连接，我们甚至还没有初始化我们的任何代码。但是，如果你确实想立即进行操作并查看我们是如何做的，你可以在本章的最后一节之前查看我们的结论。如果你按照这些步骤，你应该会得到一个类似于我们刚刚看到的应用程序。
- en: Technically, our gallery is now completely built and we can now fully interact
    with it using our next and previous buttons. But now, it's on to the fun we've
    all been waiting for, touch events!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们的画廊现在已经完全构建好了，我们现在可以使用下一个和上一个按钮完全与之交互。但现在，让我们开始等待已久的有趣的触摸事件！
- en: Extending the gallery for touch
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展触摸功能的画廊
- en: We could, by default, include touch interactivity into the `Gallery` class,
    but this wouldn't be reusable and couldn't be applied to other parts of the application.
    So in this section we'll create a new class called `Swipe`, and it will contain
    everything that's needed to detect swiping gestures on a specific module.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们可以将触摸交互包含在`Gallery`类中，但这不具有可重用性，也无法应用于应用程序的其他部分。因此，在本节中，我们将创建一个名为`Swipe`的新类，它将包含检测特定模块上滑动手势所需的一切。
- en: The basic template
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本模板
- en: 'As always we want to start out with our basic framework, similar to the other
    classes we''ve written before. To get started we can write the following basic
    template:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往编写的其他类似，我们始终希望从基本框架开始。我们可以编写以下基本模板来开始：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Swipe` class is a bit different from our `Gallery` class in that it accepts
    the `window`, `document`, and `Zepto` objects. Another difference is that the
    `Swipe` constructor accepts one parameter called `options`, used to override default
    values that we will set soon.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swipe`类与我们的`Gallery`类有些不同，它接受`window`、`document`和`Zepto`对象。另一个不同之处在于`Swipe`构造函数接受一个名为`options`的参数，用于覆盖我们即将设置的默认值。'
- en: Default options and modularizing swipe events
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认选项和模块化滑动事件
- en: There are a couple things we want to do inside the `Swipe` class. First, we
    want to make sure it only applies to the particular container and not the entire
    document. Then, we want to be able to cache certain values like the initial x
    position of the touch and the end x position. These cached values should also
    be available in the closure scope, so that they are available across all methods.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swipe`类内部有几件事情要做。首先，我们希望确保它仅适用于特定容器，而不是整个文档。然后，我们希望能够缓存某些值，如触摸的初始x位置和结束x位置。这些缓存的值也应该在闭包作用域中可用，以便它们在所有方法中都可用。'
- en: 'Here are the defaults we would like to have and the cached values that will
    be available in the closure''s scope:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们想要的默认值和将在闭包作用域中可用的缓存值：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What we're basically saying in the preceding code is that the default element,
    the swipe functionality, should be attached to is the document's `body` element.
    From here we make sure that we can access these cached elements in the closure's
    scope. Finally we set up some variables that will store the information about
    the touch gesture we will be listening for.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们基本上是在说默认元素，滑动功能，应该附加到文档的`body`元素。从这里开始，我们确保可以在闭包作用域中访问这些缓存的元素。最后，我们设置一些变量，将存储关于我们将要监听的触摸手势的信息。
- en: 'Now in our constructor we want to override these defaults and make sure some
    of these initial values will exist in the global scope:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的构造函数中，我们要覆盖这些默认值，并确保一些这些初始值将存在于全局作用域中：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here we are using Zepto's `extend` method to create a new object that contains
    a merge of the options parameter into the defaults object. We then make sure that
    the closure's scope contains the cached element the swipe class will be attached
    to. Finally we check if a custom threshold was passed in and override the default
    30\. After all this, we call an initialize method at the end of the constructor
    so that the Swipe class starts automatically.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Zepto的`extend`方法创建一个新对象，其中包含将选项参数合并到默认对象中。然后，我们确保闭包作用域包含了滑动类将附加到的缓存元素。最后，我们检查是否传递了自定义阈值，并覆盖默认的30。在所有这些之后，我们在构造函数的末尾调用一个初始化方法，以便`Swipe`类自动启动。
- en: Listening to touch events
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听触摸事件
- en: Now we need to attach the appropriate events to the `Swipe` class. These events
    will be based on the touch events we covered earlier, but they will be used in
    such a way that mimics swipe gestures. To achieve this, we first need to listen
    to the `touchstart`, `touchend`, and `touchmove` events and assign event handlers
    to each of these. We can do all of this inside the `init` method that we are calling
    from the constructor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将适当的事件附加到`Swipe`类。这些事件将基于我们之前介绍的触摸事件，但它们将以模拟滑动手势的方式使用。为了实现这一点，我们首先需要监听`touchstart`、`touchend`和`touchmove`事件，并为每个事件分配事件处理程序。我们可以在我们从构造函数调用的`init`方法中完成所有这些。
- en: 'So first let''s create our `init` method on the Swipe''s `prototype`, and let''s
    make sure we are returning the instance at the end of the method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先让我们在`Swipe`的`prototype`上创建我们的`init`方法，并确保在方法的末尾返回实例：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inside this method we want to listen to the touch events mentioned previously
    and make sure they have event handlers. To do this, we''ll use Zepto''s `on` method
    and attach the events to the element we''ve cached:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们希望监听前面提到的触摸事件，并确保它们有事件处理程序。为此，我们将使用Zepto的`on`方法，并将事件附加到我们缓存的元素上：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code we pass in the event as a string to the `on` method's
    first parameter, and then assign an event handler, which we have not yet created.
    What you'll also notice is that these methods are chainable, allowing us to attach
    several events all at once. This is why we return `this` at the end of our public
    methods, so that we can allow ourselves to make calls synchronously.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将事件作为字符串传递给`on`方法的第一个参数，然后分配一个尚未创建的事件处理程序。您还会注意到这些方法是可链接的，允许我们一次附加多个事件。这就是为什么我们在公共方法的末尾返回`this`，以便我们可以允许自己同步调用的原因。
- en: Handling touch events
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理触摸事件
- en: Now we need to create the event handlers we've assigned to each listener. We'll
    go through one handler at a time so that we can explain how the swipe gesture
    is created from these touch events. The first we want to look at is the `touchstart`
    handler.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们分配给每个监听器的事件处理程序。我们将逐个处理处理程序，以便解释如何从这些触摸事件中创建滑动手势。我们首先要看的是`touchstart`处理程序。
- en: 'When we place our finger on the phone, the first thing we want to do is store
    the initial x position of the finger. To access this information, there is a `touches`
    array on the event triggered. Because we only want to use the first touch, we
    need to access the first touch in the `touches` array. Once we get the first touch,
    we can get the x position by using the `pageX` attribute on that object. This
    is what the functionality for `handleTouchStart` will look like:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们把手指放在手机上时，我们想要做的第一件事是存储手指的初始x位置。要访问这些信息，事件触发时会有一个`touches`数组。因为我们只想使用第一个触摸，所以我们需要访问`touches`数组中的第一个触摸。一旦我们得到第一个触摸，我们就可以使用该对象上的`pageX`属性来获取x位置。这就是`handleTouchStart`的功能将会是什么样子：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see the `handleTouchStart` method accepts one parameter, the event
    object. We then set `initXPos` to the `pageX` attribute on the first touch in
    the `touches` array on the event object. That might sound like a huge mess, but
    basically we are just accessing the objects we need to in order to hold the initial
    x value of your touch.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`handleTouchStart`方法接受一个参数，即事件对象。然后我们将`initXPos`设置为事件对象上`touches`数组中第一个触摸的`pageX`属性。这可能听起来很混乱，但基本上我们只是访问我们需要的对象，以便保存您触摸的初始x值。
- en: 'Next, we want to create the `handleTouchMove` event handler. This handler will
    contain the same concepts as `handleTouchStart`, but instead of the initial x
    position, we want to update the ending x position. This can be seen in the following
    code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建`handleTouchMove`事件处理程序。这个处理程序将包含与`handleTouchStart`相同的概念，但我们想要更新结束的x位置，而不是初始的x位置。可以在以下代码中看到：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are a couple of differences here that I'll explain. First, we prevent
    the default behavior of a touch move. This is to stop any weird behavior from
    happening and is usually suggested when we want to create a unique experience,
    such as a swipeable gallery.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我将解释的不同之处。首先，我们阻止了触摸移动的默认行为。这是为了阻止发生任何奇怪的行为，通常建议在我们想要创建独特体验时使用，比如可滑动的画廊。
- en: Another difference you'll notice is that we are looking into the `changedTouches`
    object on the event. This is because the `move` event does not contain a `touches`
    object. Although a bit contentious, this helps keep track of each touch and the
    changed attributes of that specific touch. So if I had multiple touches, then
    my `changedTouches` object would contain each changed touch appropriately.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到的另一个区别是我们正在查看事件的`changedTouches`对象。这是因为`move`事件不包含`touches`对象。尽管有点有争议，但这有助于跟踪每次触摸和该特定触摸的更改属性。因此，如果我有多次触摸，那么我的`changedTouches`对象将适当地包含每次更改的触摸。
- en: Up until now, all we have done is set the initial and ending x position. Now
    we need to use those values to create a `delta` value that is then used to trigger
    a swipe in the left or right direction. This is what our `handleTouchEnd` event
    handler will be doing for us.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的只是设置初始和结束的x位置。现在我们需要使用这些值来创建一个`delta`值，然后使用它来触发左右方向的滑动。这就是我们的`handleTouchEnd`事件处理程序将为我们做的事情。
- en: 'Here''s the code that `handleTouchEnd` should contain:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`handleTouchEnd`应该包含的代码：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now let's go over this code, one line at a time. First we do the exact same
    thing that `handleTouchMove` does, and that's setting the end x position. Next,
    we set our delta value, which is the difference calculated by subtracting the
    end x position from the initial x position. Now we do a comparison; if the delta
    is larger than the threshold, then trigger a custom event called `SwipeLeft`.
    Our next comparison is a bit more confusing but basically we check to see if the
    `delta` value is less than a negative threshold. This is so that we can detect
    a swipe in the right direction.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐行查看这段代码。首先我们做的和`handleTouchMove`一样，就是设置结束的x位置。接下来，我们设置我们的`delta`值，即通过从初始x位置中减去结束x位置得到的差值。现在我们进行比较；如果`delta`大于阈值，那么触发一个名为`SwipeLeft`的自定义事件。我们的下一个比较有点更加混乱，但基本上我们检查`delta`值是否小于负阈值。这是为了检测向右方向的滑动。
- en: Our `Swipe` class is now complete. We have created the necessary functionality
    that listens to our touch events and then mimics a gesture that we can tie into
    to. But we haven't actually connected it to our gallery, which is the last step
    in the process. Feel proud that you've reached this point, because now the easy
    stuff happens!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Swipe`类现在已经完成。我们已经创建了监听我们触摸事件的必要功能，然后模拟了一个手势，我们可以将其连接起来。但实际上我们还没有将它连接到我们的画廊，这是整个过程中的最后一步。因为现在你已经达到了这一点，所以应该感到自豪，因为现在将会发生容易的事情！
- en: Putting it all together
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: Okay, so at this point we have a gallery and the ability to detect swipe gestures
    using touch events. But right now, nothing is really connected, and in fact we
    haven't initialized our `Gallery` class so nothing should be working right now.
    But this is what this last section is about; we'll go through initializing our
    `Gallery` class, adding the `Swipe` functionality and then reacting to our swipe
    events.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止我们有一个画廊和使用触摸事件检测滑动手势的能力。但现在，没有什么真正连接在一起，实际上我们还没有初始化我们的`Gallery`类，所以现在什么都不应该工作。但这就是最后一部分的内容；我们将会初始化我们的`Gallery`类，添加`Swipe`功能，然后对我们的滑动事件做出反应。
- en: The JavaScript
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'The first thing we want to do is open our `App.Touch.js` file, as you recall
    this file pertains to the functionality of our touch page and thus is the file
    that will contain all our initialization. When we have this file open, go to the
    `init` method, or if it''s not created already, then create it and initialize
    an instance of `Gallery`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是打开我们的`App.Touch.js`文件，你还记得这个文件与我们的触摸页面的功能相关，因此这个文件将包含我们所有的初始化。当我们打开这个文件时，转到`init`方法，或者如果还没有创建，那么创建并初始化一个`Gallery`的实例：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now that we have initialized our `Gallery` class, the gallery should instantly
    initialize. But keep in mind we have not modified our markup to include this file.
    So even at this point, you won''t see the fruits of your labor. But let''s make
    sure we continue the setup work. In this next step, we want to initialize our
    `Swipe` class and make sure it sets itself to the `gallery` element:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了我们的`Gallery`类，画廊应该立即初始化。但请记住，我们还没有修改我们的标记以包含这个文件。所以即使在这一点上，你也看不到你劳动的成果。但让我们确保我们继续设置工作。在下一步中，我们想要初始化我们的`Swipe`类，并确保它将自己设置为`gallery`元素：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, even at this point our gallery does not respond to swipe events. That
    is because our swipe functionality only detects touches and dispatches those custom
    events we set up previously, so what we need to do is listen for those events
    on the gallery and then tell it to play the next or previous slide:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使在这一点上，我们的画廊也不会响应滑动事件。这是因为我们的滑动功能只检测触摸并分派我们之前设置的自定义事件，所以我们需要做的是在画廊上监听这些事件，然后告诉它播放下一个或上一个幻灯片：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, we listen for the `SwipeLeft` and `SwipeRight` events
    that get dispatched by our instance of swipe. When either event is dispatched,
    based on the event, we simulate a click on either the previous or next button.
    In this way we are able to give the appearance that the user is swiping throughout
    our gallery, while at the same time eliminating any kind of complications.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们监听由我们的滑动实例分派的`SwipeLeft`和`SwipeRight`事件。当任一事件被分派时，根据事件，我们模拟点击上一个或下一个按钮。通过这种方式，我们能够让用户看起来在整个画廊中滑动，同时消除任何复杂性。
- en: 'When you are done writing your `init` method, it should look like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成编写你的`init`方法时，它应该是这样的：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The markup
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记
- en: 'The final item that needs to be taken care of is the markup on the page—the
    scripts being included. To make things simpler and get you to finally run your
    application correctly, here''s what you need to include on your page:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 需要处理的最后一项是页面上的标记 - 包括的脚本。为了简化事情并最终使您的应用程序正确运行，以下是您需要在页面上包含的内容：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The difference here, compared to other pages, is that we are only including
    the items we need, including `App.Nav.js`, `App.Gallery.js`, `App.Swipe.js`, and
    `App.Touch.js`. In comparison to other pages, we were including the entire framework,
    but we don't really need to do that for this page or any pages moving forward.
    One thing to note is that we have also created a global touch object that gets
    set to an instance of our `App.Touch` class. This is so that we can reference
    it in the debugger easily, but this should be replaced with `App.touch`, so that
    it is not polluting the global namespace.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他页面相比，这里的不同之处在于我们只包括我们需要的项目，包括`App.Nav.js`、`App.Gallery.js`、`App.Swipe.js`和`App.Touch.js`。与其他页面相比，我们正在包括整个框架，但对于这个页面或任何以后的页面，我们实际上不需要这样做。需要注意的一点是，我们还创建了一个全局的触摸对象，它被设置为我们`App.Touch`类的一个实例。这样我们可以在调试器中轻松地引用它，但这应该被替换为`App.touch`，这样它就不会污染全局命名空间。
- en: We've reached the end! At this point you should have a fully functional gallery
    that has swipeable interactivity. Now pat yourself on the back; it's been a long
    journey, but I hope you can appreciate the fact that we have created reusable,
    modular code that is completely self-contained. On top of that, our gallery is
    completely responsive and adapts to users' devices, allowing them to enjoy the
    experience consistently.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到达了终点！在这一点上，你应该有一个完全功能的画廊，可以进行滑动交互。现在给自己一个鼓励吧；这是一个漫长的旅程，但我希望你能欣赏到我们已经创建了可重用的、模块化的代码，它是完全自包含的。除此之外，我们的画廊是完全响应式的，可以适应用户的设备，让他们能够一致地享受体验。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we have restyled our main navigation, gone over the fundamentals
    of both touch and gesture events, and then implemented both types of events using
    a responsive photo gallery that will adapt to the user's device. We have also
    gone through attaching these events and handling them appropriately for our requirements
    in the slideshow. From here on out you should have a good understanding about
    how to use touch events to create unique experiences on the iPhone, as well as
    on other mobile devices. Next, let's take a look at some special interactions
    that come with handling forms in HTML5 on the iPhone.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重新设计了我们的主导航，讨论了触摸和手势事件的基本原理，然后使用一个响应式的照片画廊实现了这两种类型的事件，这将适应用户的设备。我们还讨论了如何附加这些事件，并根据幻灯片放映的要求适当地处理它们。从现在开始，你应该对如何使用触摸事件在iPhone上创建独特体验有很好的理解，以及在其他移动设备上也是如此。接下来，让我们来看看在iPhone上处理HTML5表单时会有一些特殊的交互。
