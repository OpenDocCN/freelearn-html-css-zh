- en: Chapter 7. One-page Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 单页面应用程序
- en: Until this point we have developed individual pages with related static content.
    In this chapter we kick it up a notch by diving into one-page-application development.
    We've seen this in many of our web applications, including Pandora, Mint, and
    NPR. We'll cover the foundations of one-page-application development, from an
    introduction to MVC, Underscore, and Backbone to creating architecture with our
    sample application and utilizing the methods taught in the first section of this
    chapter. Once you complete this chapter you should have a solid understanding
    of concepts behind one-page-applications, which will allow you to continue to
    extend on this knowledge and help guide you on your way to building complex applications.
    So let's get started by first learning about MVC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开发了包含相关静态内容的单独页面。在本章中，我们将通过深入研究单页面应用程序开发来提高水平。我们在许多网络应用程序中都见过这种情况，包括Pandora、Mint和NPR。我们将介绍单页面应用程序开发的基础知识，从MVC、Underscore和Backbone的介绍到使用我们示例应用程序创建架构和利用本章第一部分教授的方法。完成本章后，您应该对单页面应用程序背后的概念有扎实的理解，这将使您能够继续扩展这些知识，并帮助您在构建复杂应用程序的道路上指引您。所以让我们首先学习MVC。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: MVC Architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC架构
- en: Introduction to `Underscore.js`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`Underscore.js`
- en: Introduction to `Backbone.js`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`Backbone.js`
- en: Creating a one-page application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单页面应用程序
- en: Model-View-Controller or MVC
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器或MVC
- en: '**Model-View-Controller** (**MVC**) is a heavily used design pattern in programming.
    A design pattern is essentially a reusable solution that solves common problems
    in programming. For example, the **Namespace** and **Immediately-Invoked Function
    Expressions** are patterns that are used throughout this book. MVC is another
    pattern to help solve the issue of separating the presentation and data layers.
    It helps us keep our markup and styling outside of the JavaScript; keeping our
    code organized, clean, and manageable—all essential requirements for creating
    one-page-applications. So let''s briefly discuss the several parts of MVC, starting
    with models.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）是编程中广泛使用的设计模式。设计模式本质上是解决编程中常见问题的可重用解决方案。例如，**命名空间**和**立即调用函数表达式**是本书中经常使用的模式。MVC是另一种模式，用于帮助解决分离表示和数据层的问题。它帮助我们将标记和样式保持在JavaScript之外；保持我们的代码有组织、清晰和可管理——这些都是创建单页面应用程序的基本要求。因此，让我们简要讨论MVC的几个部分，从模型开始。'
- en: Models
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: A model is a description of an object, containing the attributes and methods
    that relate to it. Think of what makes up a song, for example the track's title,
    artist, album, year, duration, and more. In its essence, a model is a blueprint
    of your data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是一个对象的描述，包含与之相关的属性和方法。想想构成一首歌的内容，例如曲目的标题、艺术家、专辑、年份、时长等。在本质上，模型是您的数据的蓝图。
- en: Views
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The view is a physical representation of the model. It essentially displays
    the appropriate attributes of the model to the user, the markup and styles used
    on the page. Accordingly, we use templates to populate our views with the data
    provided.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是模型的物理表示。它基本上显示模型的适当属性给用户，页面上使用的标记和样式。因此，我们使用模板来填充我们的视图所提供的数据。
- en: Controllers
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers are the mediators between the model and the view. The controller
    accepts actions and communicates information between the model and the view if
    necessary. For example, a user can edit properties on a model; when this is done
    the controller tells the View to update according to the user's updated information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是模型和视图之间的中介。控制器接受操作，并在必要时在模型和视图之间传递信息。例如，用户可以编辑模型上的属性；当这样做时，控制器告诉视图根据用户更新的信息进行更新。
- en: Relationships
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系
- en: 'The relationship established in an MVC application is critical to sticking
    with the design pattern. In MVC, theoretically, the model and view never speak
    with each other. Instead the controller does all the work; it describes an action,
    and when that action is called either the model, view, or both update accordingly.
    This type of relationship is established in the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC应用程序中建立的关系对于遵循设计模式至关重要。在MVC中，理论上，模型和视图永远不会直接交流。相反，控制器完成所有工作；它描述一个动作，当该动作被调用时，模型、视图或两者都相应地更新。这种类型的关系在下图中得以建立：
- en: '![Relationships](img/1024OT_07_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![关系](img/1024OT_07_01.jpg)'
- en: This diagram explains a traditional MVC structure, especially that the communication
    between the controller and model is two-way; the controller can send data to/from
    the model and vice versa for the view. However, the view and model never communicate,
    and there's a good reason for that. We want to make sure our logic is contained
    appropriately; therefore, if we wanted to delegate events properly for user actions,
    then that code would go into the view.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图解释了传统的MVC结构，特别是控制器和模型之间的通信是双向的；控制器可以向模型发送/接收数据，视图也可以如此。然而，视图和模型永远不会直接交流，这是有充分理由的。我们希望确保我们的逻辑得到适当的包含；因此，如果我们想要为用户操作正确地委派事件，那么这段代码将放入视图中。
- en: However, if we wanted to have utility methods, such as a `getName` method that
    combines a user's first name and last name appropriately, that code would be contained
    within a user model. Lastly, any sort of action that pertains to retrieving and
    displaying data would be contained in the controller.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要有实用方法，比如一个`getName`方法，可以适当地组合用户的名字和姓氏，那么这段代码将包含在用户模型中。最后，任何涉及检索和显示数据的操作都将包含在控制器中。
- en: Theoretically, this pattern helps us keep our code organized, clean, and efficient.
    In many cases this pattern can be directly applied, especially in many backend
    languages like Ruby, PHP, and Java. However, when we start applying this strictly
    to the frontend, we are confronted with many structural challenges. At the same
    time, we need this structure to create solid one-page-applications. The following
    sections will introduce you to the libraries we will use to solve these issues
    and more.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，这种模式有助于我们保持代码组织良好、清晰和高效。在许多情况下，这种模式可以直接应用，特别是在像Ruby、PHP和Java这样的许多后端语言中。然而，当我们开始严格将其应用于前端时，我们将面临许多结构性挑战。同时，我们需要这种结构来创建稳固的单页应用程序。接下来的章节将介绍我们将用来解决这些问题以及更多问题的库。
- en: Introduction to Underscore.js
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Underscore.js简介
- en: One of the libraries we will be utilizing in our sample application will be
    `Underscore.js`. Underscore has become extremely popular in the last couple of
    years due to the many utility methods it provides developers without extending
    built-in JavaScript objects, such as `String`, `Array`, or `Object`. While it
    provides many useful methods, the suite has also been optimized and tested across
    many of the most popular web browsers, including Internet Explorer. For these
    reasons, the community has widely adopted this library and continually supported
    it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例应用程序中将使用的库之一是`Underscore.js`。由于Underscore提供了许多实用方法，而不会扩展内置的JavaScript对象，如`String`，`Array`或`Object`，因此Underscore在过去几年变得非常流行。虽然它提供了许多有用的方法，但该套件还经过了优化并在许多最受欢迎的Web浏览器中进行了测试，包括Internet
    Explorer。出于这些原因，社区广泛采用了这个库并不断支持它。
- en: Implementation
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Underscore is extremely easy to implement in our applications. In order to
    get Underscore going, all we need to do is include it on our page like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中实现Underscore非常容易。为了让Underscore运行，我们只需要在页面上包含它，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we include Underscore on our page, we have access to the library at the
    global scope using the `_` object. We can then access any of the utility methods
    provided by the library by doing `_.methodName`. You can review all of the methods
    provided by Underscore online ([http://underscorejs.org/](http://underscorejs.org/)),
    where all methods are documented and contain samples of their implementation.
    For now, let's briefly review some of the methods we'll be using in our application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在页面上包含Underscore，我们就可以使用全局范围内的`_`对象访问库。然后，我们可以通过`_.methodName`访问库提供的任何实用方法。您可以在线查看Underscore提供的所有方法（[http://underscorejs.org/](http://underscorejs.org/)），其中所有方法都有文档并包含它们的实现示例。现在，让我们简要回顾一些我们将在应用程序中使用的方法。
- en: _.extend
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: _.extend
- en: The `extend` method in Underscore is very similar to the extend method we have
    been using from `Zepto` ([http://zeptojs.com/#$.extend](http://zeptojs.com/#$.extend)).
    If we look at the documentation provided on Underscore's website ([http://underscorejs.org/#extend](http://underscorejs.org/#extend)),
    we can see that it takes multiple objects with the first parameter being the destination
    object that gets returned once all objects are combined.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore中的`extend`方法与我们从`Zepto`中使用的`extend`方法非常相似（[http://zeptojs.com/#$.extend](http://zeptojs.com/#$.extend)）。如果我们查看Underscore网站上提供的文档（[http://underscorejs.org/#extend](http://underscorejs.org/#extend)），我们可以看到它接受多个对象，第一个参数是目标对象，一旦所有对象组合在一起就会返回。
- en: Copy all of the properties in the source objects over to the destination object,
    and return the destination object. It's in-order, so the last source will override
    properties of the same name in previous arguments.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将源对象的所有属性复制到目标对象中，并返回目标对象。它是按顺序的，因此最后一个源将覆盖先前参数中相同名称的属性。
- en: 'As an example, we can take a `Song` object and create an instance of it while
    also overriding its default attributes. This can be seen in the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以获取一个`Song`对象并创建一个实例，同时覆盖其默认属性。可以在以下示例中看到：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we log out the `Sample` object, we'll notice that it has inherited from the
    `Song` constructor and overridden the default attributes `track`, `duration`,
    and `album`. Although we can improve the performance of inheritance using traditional
    JavaScript, using an `extend` method helps us focus on delivery. We'll look at
    how we can utilize this method to create a base architecture within our sample
    application later on in the chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记录`Sample`对象，我们会注意到它是从`Song`构造函数继承而来，并覆盖了默认属性`track`，`duration`和`album`。虽然我们可以使用传统的JavaScript来提高继承的性能，但使用`extend`方法可以帮助我们专注于交付。我们将在本章后面看看如何利用这种方法在我们的示例应用程序中创建基本架构。
- en: _.each
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: _.each
- en: 'The `each` method is extremely helpful when we want to iterate over an `Array`
    or `Object`. In fact this is another method that we can find in `Zepto` and other
    popular libraries like `jQuery`. Although each library''s implementation and performance
    is a little different, we''ll be using Underscore''s `_.each` method, so that
    we can stick within our application''s architecture without introducing new dependencies.
    As per Underscore''s documentation ([http://underscorejs.org/#each](http://underscorejs.org/#each)),
    the use of `_.each` is similar to other implementations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要迭代`Array`或`Object`时，`each`方法非常有用。实际上，这是我们可以在`Zepto`和其他流行库如`jQuery`中找到的另一种方法。尽管每个库的实现和性能略有不同，但我们将使用Underscore的`_.each`方法，以便我们可以在不引入新依赖项的情况下保持应用程序的架构。根据Underscore的文档（[http://underscorejs.org/#each](http://underscorejs.org/#each)），使用`_.each`与其他实现类似：
- en: 'Iterates over a list of elements, yielding each in turn to an iterator function.
    The iterator is bound to the context object, if one is passed. Each invocation
    of iterator is called with three arguments: (element, index, list). If list is
    a JavaScript object, iterator''s arguments will be (value, key, list). Delegates
    to the native forEach function if it exists.'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对元素列表进行迭代，依次将每个元素传递给迭代器函数。如果传递了上下文对象，则迭代器绑定到上下文对象。迭代器的每次调用都使用三个参数：（element，index，list）。如果列表是JavaScript对象，则迭代器的参数将是（value，key，list）。如果存在本地forEach函数，则委托给本地forEach函数。
- en: 'Let''s take a look at an example of using `_.each` with the code we created
    in the previous section. We''ll loop through the instance of `Sample` and log
    out the object''s properties, including track, duration, and album. Because Underscore''s
    implementation allows us to loop through an `Object`, just as easily as an `Array`,
    we can use this method to iterate over our `Sample` object''s properties:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在前一节中创建的代码中使用`_.each`的示例。我们将循环遍历`Sample`的实例，并记录对象的属性，包括曲目、持续时间和专辑。由于Underscore的实现允许我们像数组一样轻松地循环遍历`Object`，因此我们可以使用这种方法来迭代我们的`Sample`对象的属性：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output from our log should look something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日志输出应该是这样的：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, it's extremely easy to use Underscore's `each` method with arrays
    and objects. In our sample application, we'll use this method to loop through
    an array of objects to populate our page, but for now let's review one last important
    method we'll be using from Underscore's library.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用Underscore的`each`方法与数组和对象非常容易。在我们的示例应用程序中，我们将使用这种方法来循环遍历对象数组以填充我们的页面，但现在让我们回顾一下我们将在Underscore库中使用的最后一个重要方法。
- en: _.template
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: _.template
- en: 'Underscore has made it extremely easy for us to integrate templating into our
    applications. Out of the box, Underscore comes with a simple templating engine
    that can be customized for our purposes. In fact, it can also precompile your
    templates for easy debugging. Because Underscore''s templating can interpolate
    variables, we can utilize it to dynamically change the page as we wish. The documentation
    provided by Underscore ([http://underscorejs.org/#template](http://underscorejs.org/#template))
    helps explain the different options we have when using templates:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore已经让我们非常容易地将模板集成到我们的应用程序中。默认情况下，Underscore带有一个简单的模板引擎，可以根据我们的目的进行定制。实际上，它还可以预编译您的模板以便进行简单的调试。由于Underscore的模板化可以插入变量，我们可以利用它来根据需要动态更改页面。Underscore提供的文档（[http://underscorejs.org/#template](http://underscorejs.org/#template)）有助于解释在使用模板时我们有哪些不同的选项：
- en: Compiles JavaScript templates into functions that can be evaluated for rendering.
    Useful for rendering complicated bits of HTML from JSON data sources. Template
    functions can both interpolate variables, using <%= … %>, as well as execute arbitrary
    JavaScript code, with <% … %>. If you wish to interpolate a value, and have it
    be HTML-escaped, use <%- … %>. When you evaluate a template function, pass in
    a data object that has properties corresponding to the template's free variables.
    If you're writing a one-off, you can pass the data object as the second parameter
    to template in order to render immediately instead of returning a template function.
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将JavaScript模板编译为可以用于渲染的函数。用于从JSON数据源呈现复杂的HTML片段。模板函数既可以插入变量，使用<%= ... %>，也可以执行任意的JavaScript代码，使用<%
    ... %>。如果您希望插入一个值，并且它是HTML转义的，请使用<%- ... %>。当您评估一个模板函数时，传递一个数据对象，该对象具有与模板的自由变量对应的属性。如果您正在编写一个一次性的模板，可以将数据对象作为模板的第二个参数传递，以便立即呈现，而不是返回一个模板函数。
- en: 'Templating on the frontend can be difficult to understand at first, after all
    we were used to querying a backend, using AJAX, and retrieving markup that would
    then be rendered on the page. Today, best practices dictate we use RESTful APIs
    that send and retrieve data. So, theoretically, you should be working with data
    that is properly formed and can be interpolated. But where do our templates live,
    if not on the backend? Easily, in our markup:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前端的模板化一开始可能很难理解，毕竟我们习惯于查询后端，使用AJAX，并检索标记，然后在页面上呈现。如今，最佳实践要求我们使用发送和检索数据的RESTful
    API。因此，理论上，您应该使用正确形成的数据并进行插值。但是，如果不是在后端，我们的模板在哪里？很容易，在我们的标记中：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because the preceding script has an identified type for the browser, the browser
    avoids reading the contents inside this script. And because we can still target
    this using the ID, we can pick up the contents and then interpolate it with data
    using Underscore''s `template` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前面的脚本在浏览器中有一个已识别的类型，所以浏览器避免读取此脚本中的内容。而且因为我们仍然可以使用ID来定位它，所以我们可以获取内容，然后使用Underscore的`template`方法插入数据：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result of running the page, would be the following markup:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行页面的结果将是以下标记：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the content from within the template would be prepended to the
    body and the data interpolated, displaying the properties we wish to display;
    in this case the title and album name of the song. If this is a bit difficult
    to understand, don't worry about it too much, I myself had a lot of trouble trying
    to pick up the concept when the industry started moving into one-page applications
    that ran off raw data (`JSON`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，模板中的内容将被预先放置在主体中，并且数据将被插入，显示我们希望显示的属性；在这种情况下，歌曲的标题和专辑名称。如果这有点难以理解，不要太担心，当行业开始转向运行原始数据（`JSON`）的单页面应用程序时，我自己也很难理解这个概念。
- en: For now, these are the methods we'll be using consistently within the sample
    application to be built in this chapter. It is encouraged that you experiment
    with the `Underscore.js` library to discover some of the more advanced features
    that make your life easier, such as `_.map`, `_.reduce`, `_.indexOf`, `_.debounce`,
    and `_.clone`. However, let's move on to `Backbone.js` and how this library will
    be used to create our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些是我们将在本章中一直使用的方法。鼓励您尝试使用`Underscore.js`库，以发现一些更高级的功能，使您的生活更轻松，例如`_.map`，`_.reduce`，`_.indexOf`，`_.debounce`和`_.clone`。但是，让我们继续学习`Backbone.js`以及如何使用这个库来创建我们的应用程序。
- en: Introduction to Backbone.js
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Backbone.js
- en: To add structure to our one-page application, we will be using `Backbone.js`,
    a light framework that helps us apply the MVC design pattern. `Backbone.js` is
    one of the many MVC-type frameworks that help frontend development stick to best
    practices of separating out the data from the views or in particular, the DOM.
    On top of that, our applications can become quite complex for one-page apps. `Backbone.js`
    helps alleviate these issues and gets us going quickly. So let's start with discussing
    how MVC applies to this framework.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的单页面应用程序添加结构，我们将使用`Backbone.js`，这是一个轻量级的框架，帮助我们应用MVC设计模式。`Backbone.js`是许多MVC类型框架之一，它帮助前端开发遵循将数据与视图或特别是DOM分离的最佳实践。除此之外，我们的应用程序可能会变得非常复杂。`Backbone.js`有助于缓解这些问题，并让我们快速上手。因此，让我们开始讨论MVC如何应用于这个框架。
- en: MVC and Backbone.js
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC和Backbone.js
- en: 'There are many types of JavaScript frameworks that apply MVC differently, it
    is no different for Backbone. Backbone implements `Models`, `Views`, `Collections`,
    and `Routers`; it also includes an `Event`, `History`, and `Sync` system. As you
    can see, Backbone does not have a traditional Controller that was discussed earlier,
    but we can interpret `Views` as controllers. As per Backbone''s documentation
    ([http://backbonejs.org/#FAQ-mvc](http://backbonejs.org/#FAQ-mvc)):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种类型的JavaScript框架以不同的方式应用MVC，Backbone也不例外。Backbone实现了`Models`、`Views`、`Collections`和`Routers`；它还包括一个`Event`、`History`和`Sync`系统。正如你所看到的，Backbone没有传统的Controller，但我们可以将`Views`解释为控制器。根据Backbone的文档（[http://backbonejs.org/#FAQ-mvc](http://backbonejs.org/#FAQ-mvc)）：
- en: (…) in Backbone, the View class can also be thought of as a kind of controller,
    dispatching events that originate from the UI, with the HTML template serving
    as the true view.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (…)在Backbone中，View类也可以被视为一种控制器，分派源自UI的事件，HTML模板作为真正的视图。
- en: This type of MVC implementation can be a bit confusing, however our sample application
    will help clear things up. For now let's dive into Backbone models, views, and
    collections. In the following sections we'll go over how each part of Backbone
    gets implemented and the parts we'll be using to build our application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种MVC实现可能有点令人困惑，但我们的示例应用程序将有助于澄清问题。现在让我们深入了解Backbone模型、视图和集合。在接下来的部分中，我们将介绍Backbone的每个部分是如何实现的，以及我们将用来构建应用程序的部分。
- en: Backbone models
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Backbone模型
- en: As in any MVC pattern, the Model is critical, containing the data and logic,
    including properties, access controls, conversions, validations, and more. Keep
    in mind that we write models on a daily basis, and in fact we have created a number
    of models throughout this book (`MediaElement`, `Video`, `Audio`, and so on).
    Backbone models are similar to a boilerplate in that they provide utility methods
    that we would otherwise have to build ourselves.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何MVC模式中，模型都是至关重要的，包含数据和逻辑，包括属性、访问控制、转换、验证等。请记住，我们每天都在编写模型，事实上，我们在本书中创建了许多模型（`MediaElement`、`Video`、`Audio`等）。Backbone模型类似于样板，它提供了我们否则必须自己构建的实用方法。
- en: 'Let''s take the following code as an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下代码为例：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we have created a `Song` model, the same as in the
    previous section, that has several properties (`track`, `duration`, and `album`)
    and methods (`get` and `set`). From there we create an instance of `Song` and
    use the methods created to get and set the `album` property. This is great; however,
    we needed to create those methods manually. That is not what we want to do; we
    already know we need those methods, so we just want to focus on the data and extending
    it. This is where Backbone models come into play.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个`Song`模型，与前一节中一样，它有几个属性（`track`、`duration`和`album`）和方法（`get`和`set`）。然后我们创建了`Song`的一个实例，并使用创建的方法来获取和设置`album`属性。这很棒；然而，我们需要手动创建这些方法。这不是我们想要做的；我们已经知道我们需要这些方法，所以我们只想专注于数据和扩展它。这就是Backbone模型发挥作用的地方。
- en: 'Let''s analyze the following Model:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下模型：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code shows how quickly we get off the ground writing our applications.
    Behind the scenes, Backbone is a namespace and has a model object attached to
    it. Then, using Underscore's `extend` method, we return a copy of `Backbone.Model`,
    that has merged default properties attached to it, to the variable `SongModel`.
    Then we do the same as earlier, using `get` and `set`, with the desired output
    in the comments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码展示了我们快速开始编写应用程序的方式。在幕后，Backbone是一个命名空间，并且有一个附加到它的模型对象。然后，使用Underscore的`extend`方法，我们返回一个`Backbone.Model`的副本，其中附加了默认属性，赋值给变量`SongModel`。然后我们做同样的事情，使用`get`和`set`，期望的输出在注释中。
- en: As you can see it's pretty simple to get started using Backbone, especially
    if you just wanted a way to organize your data without building custom functionality
    for each and every application. Now let's look at views inside Backbone and how
    it can actually help us separate the data from our UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用Backbone很容易入门，尤其是如果你只是想要一种方法来组织你的数据，而不是为每个应用程序构建自定义功能。现在让我们看看Backbone中的视图，以及它如何帮助我们将数据与UI分离。
- en: Backbone views
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Backbone视图
- en: 'Backbone views are a bit different than models in such a way that they are
    more for convenience. If we look at the Backbone documentation and compare the
    *Views* and *Models* sections, we''ll find that Views are a bit more bare bones,
    but again are useful in organizing our applications. To see why these are still
    useful, let''s look at the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone视图与模型有些不同，它们更多的是为了方便。如果我们查看Backbone的文档并比较*Views*和*Models*部分，我们会发现Views更加简洁，但在组织我们的应用程序时也很有用。为了看到它们为什么仍然有用，让我们看下面的代码：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Typically, this is how we would cache our elements on the page and delegate
    events for particular user interactions. However, what if this could be done with
    less setup work? In the following code, we transform the preceding code into a
    typical Backbone view setup.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是我们在页面上缓存元素并为特定用户交互委托事件的方式。但是，如果可以减少设置工作呢？在下面的代码中，我们将上面的代码转换为典型的Backbone视图设置。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, Backbone takes care of the setup work for you. It caches the
    element selected and delegates the events for you behind the scenes. Literally,
    all you need to do on your end is the setup and quickly move on to the next step;
    now you''ll notice that your development time decreases while your efficiency
    increases, and this is just the preliminary steps into Backbone. Now, the magic
    happens when we connect the Model and View together. To see this in action, take
    a look at the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Backbone为您处理了设置工作。它在幕后为您缓存了所选元素并代理了事件。实际上，您在您的端上需要做的只是设置，然后快速进行下一步；现在您会注意到您的开发时间减少了，而您的效率增加了，这只是进入Backbone的初步步骤。当我们将模型和视图连接在一起时，魔术就会发生。要看到这一点，请看以下代码：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this code snippet we have finally connected a single model to one view.
    The way we have done this is by passing in the instance of the model into the
    instance of the view:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们最终将单个模型连接到一个视图。我们这样做的方式是将模型的实例传递给视图的实例：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we do this, we associate the Model and the View. But we also need to do
    something with that Model, and usually we want to display the data associated
    with it. So in this example, we create an `initialize` method that gets called
    as a constructor. In this method, we use Backbone's built-in event system to track
    any changes associated with the Model's `track` property and call `updateSongTitle`
    accordingly. While we're at it, we change the context of the event handler by
    passing in `this` as the third parameter and then cache the element displaying
    the song's track.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们将模型和视图关联起来。但我们还需要对该模型进行一些操作，通常我们希望显示与其关联的数据。因此，在这个例子中，我们创建了一个`initialize`方法，它被调用作为构造函数。在这个方法中，我们使用Backbone内置的事件系统来跟踪与模型的`track`属性相关的任何更改，并相应地调用`updateSongTitle`。在此过程中，我们通过将`this`作为第三个参数传递来更改事件处理程序的上下文，然后缓存显示歌曲轨道的元素。
- en: In the end, when you change the instance of the song's `track` property, the
    DOM updates accordingly. We now have the basics we need to build our application.
    But let's take a look at Backbone collections to understand how keeping track
    of our data increases the efficiency of our application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您更改歌曲的`track`属性的实例时，DOM会相应地更新。现在我们已经有了构建应用程序所需的基础。但让我们来看看Backbone集合，了解如何跟踪数据如何增加应用程序的效率。
- en: Backbone collections
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Backbone集合
- en: Now, up until this point we have worked with a single Model, which is great
    but in most cases we work with sets of data. This is why Backbone collections
    exist, to manage an ordered set of models. Backbone collections also tie into
    Underscore's methods, allowing us to work with these sets easily and efficiently
    with no setup work.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了单个模型，这很好，但在大多数情况下，我们使用数据集。这就是Backbone集合存在的原因，用于管理有序的模型集。Backbone集合还与Underscore的方法相关联，使我们可以轻松高效地处理这些集合，而无需进行任何设置工作。
- en: 'Let''s look at the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This sample code is very similar to the code produced in the previous section.
    The difference here is that we have created a `SongCollection` that takes models
    of type `SongModel`. Then we create an instance of this collection, add 100 models
    to it via our `for` loop, and finally attach the collection to our View.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码与上一节中生成的代码非常相似。不同之处在于我们创建了一个`SongCollection`，它接受`SongModel`类型的模型。然后我们创建了这个集合的一个实例，通过我们的`for`循环向其中添加了100个模型，最后将集合附加到我们的视图上。
- en: 'Our View has also changed in such a way that we have attached the `change`
    event to our collection, and created a more general listener that gets called
    whenever a Model is updated within the collection. Therefore, when we execute
    the following code the View lets us know that something was updated:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图也发生了变化，我们将`change`事件附加到我们的集合上，并创建了一个更通用的监听器，每当集合中的模型更新时都会被调用。因此，当我们执行以下代码时，视图会告诉我们有东西被更新了：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Server-side interactions
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端交互
- en: It's not easy seeing how a Backbone application connects to the server, especially
    since we have so much going on in the frontend code. But, if YOU take a look at
    the documentation provided on the Backbone.js website ([http://backbonejs.org/#Sync](http://backbonejs.org/#Sync)),
    we know that Models contain all the functionality for manipulating the data. In
    fact, Models connect to the database and can sync with it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看到Backbone应用程序如何连接到服务器并不容易，特别是因为前端代码中有很多事情要做。但是，如果您查看Backbone.js网站提供的文档（[http://backbonejs.org/#Sync](http://backbonejs.org/#Sync)），我们知道模型包含了操纵数据的所有功能。事实上，模型连接到数据库并可以与之同步。
- en: Backbone.sync is the function that Backbone calls every time it attempts to
    read or save a model to the server. By default, it uses (jQuery/Zepto).ajax to
    make a RESTful JSON request and returns a jqXHR. You can override it in order
    to use a different persistence strategy, such as WebSockets, XML transport, or
    Local Storage.
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Backbone.sync是Backbone每次尝试从服务器读取或保存模型时调用的函数。默认情况下，它使用（jQuery/Zepto）。ajax来进行RESTful
    JSON请求并返回jqXHR。您可以覆盖它以使用不同的持久化策略，例如WebSockets、XML传输或本地存储。
- en: 'But, Models aren''t the only ones that can connect to the server. As the documentation
    continues to read, a model or collection can begin a sync request and interact
    with it accordingly. This is a bit different than a traditional MVC implementation,
    especially since collections and models can interact with the database. To better
    display Backbone''s implementation of MVC, the provided image helps display the
    relationship between the different types of objects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，模型并不是唯一可以连接到服务器的对象。随着文档的继续阅读，模型或集合可以开始同步请求并相应地与之交互。这与传统的MVC实现有些不同，特别是因为集合和模型可以与数据库交互。为了更好地显示Backbone对MVC的实现，提供的图像有助于显示不同类型对象之间的关系：
- en: '![Server-side interactions](img/1024OT_07_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端交互](img/1024OT_07_02.jpg)'
- en: This is pretty much what we have created previously; a view, model, and controller.
    The implementation is slightly different, but we can see that there is a clear
    separation between the presentation layer and data because the view never directly
    interacts with the database. If this is a bit confusing, it's because it is and
    is another level of complexity that, when understood, will help guide you to coding
    Zen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们之前创建的东西；一个视图、模型和控制器。实现略有不同，但我们可以看到演示层和数据之间有明显的分离，因为视图从不直接与数据库交互。如果这有点令人困惑，那是因为它确实如此，这是另一种复杂性的层次，一旦理解，将有助于引导您编写优雅的代码。
- en: You are now fully prepared to create a one-page application using `Underscore`,
    `Backbone`, and `Zepto`. But, there is a problem. These libraries help speed up
    our development and increase efficiency, but don't actually provide a solid structure
    for our applications. This is what we tackle in our sample application. Next,
    we will discuss architecture, implementation, and optimization needed for one-page
    applications.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经准备好使用`Underscore`、`Backbone`和`Zepto`创建一个单页应用程序。但是，有一个问题。这些库可以加快我们的开发速度并提高效率，但实际上并没有为我们的应用程序提供一个坚实的结构。这就是我们在示例应用程序中要解决的问题。接下来，我们将讨论单页应用程序所需的架构、实现和优化。
- en: Our sample application
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的示例应用程序
- en: We have now been introduced to `Underscore.js` and `Backbone.js`, and have a
    good understanding of what these libraries provide and how they help with application
    development. However, we still need a way of structuring our applications, so
    that they are easily extended and most importantly, managed. So in this part of
    the chapter, we'll start building out a sample application that ties everything
    together and gets you going on building out one-page applications quickly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了`Underscore.js`和`Backbone.js`，并且对这些库提供的内容以及它们如何帮助应用程序开发有了很好的理解。然而，我们仍然需要一种结构化应用程序的方式，以便它们可以轻松扩展，最重要的是，可以管理。因此，在本章的这一部分，我们将开始构建一个示例应用程序，将所有内容联系在一起，并帮助您快速构建单页应用程序。
- en: Application architecture
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序架构
- en: 'Our sample application will do two things. One, it will allow us to see user
    information, such as a profile and dashboard. Two, it will have a playlist of
    songs that can be listened to using the HTML5 Audio media element. We can think
    of these requirements as almost two applications: a user application for managing
    user data and another application that manages the playback of media. However
    they will be related, in such a way that the user will have a playlist of songs
    related to them.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序将做两件事。一是允许我们查看用户信息，例如个人资料和仪表板。二是具有可以使用HTML5音频媒体元素收听的歌曲播放列表。我们可以将这些要求视为几乎是两个应用程序：一个用于管理用户数据的用户应用程序，另一个用于管理媒体播放的应用程序。但它们将相关联，以便用户将有与他们相关的歌曲播放列表。
- en: Basic sample architecture
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本示例架构
- en: 'Let''s begin implementing the preceding architecture. First, we know that there
    will be two applications, similar to our `App` objects, so let''s start by defining
    these:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现前面的架构。首先，我们知道将有两个应用程序，类似于我们的`App`对象，因此让我们从定义这些开始：
- en: '`js/Music/`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js/Music/`'
- en: '`js/User/`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js/User/`'
- en: 'Within the JavaScript (`js`) folder, we should create the preceding two folders:
    `Music` and `User`. These two folders will contain the code for the User and Music
    applications accordingly. To help manage our backbone files, we''ll then create
    `models`, `views`, and `collections` folders for each.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript（`js`）文件夹中，我们应该创建前面提到的两个文件夹：`Music`和`User`。这两个文件夹将分别包含用户和音乐应用程序的代码。为了帮助管理我们的backbone文件，我们将为每个创建`models`、`views`和`collections`文件夹。
- en: '`js/Music/`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js/Music/`'
- en: '`views/`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/`'
- en: '`models/`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models/`'
- en: '`collections/`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections/`'
- en: '`js/User/`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js/User/`'
- en: '`views/`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/`'
- en: '`models/`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models/`'
- en: '`collections/`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections/`'
- en: Great! Now we can start by creating a main JavaScript file that will contain
    the namespace for each application; each namespace being `User` and `Music` accordingly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们可以开始创建一个主JavaScript文件，其中将包含每个应用程序的命名空间；每个命名空间分别为`User`和`Music`。
- en: '`js/Music/`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js/Music/`'
- en: '`views/`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/`'
- en: '`models/`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models/`'
- en: '`collections/`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections/`'
- en: '`Music.js`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Music.js`'
- en: '`js/User/`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js/User/`'
- en: '`views/`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/`'
- en: '`models/`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models/`'
- en: '`collections/`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections/`'
- en: '`User.js`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User.js`'
- en: 'Now, most of our views are going to be the same with functionality that is
    very familiar. For example, there will be a global navigation bar that contains
    three links that will initiate a hide/show for each section, hiding the current
    section and showing the next. We don''t necessarily want to code the same thing
    over and over again, so it would be nice to have a base view that our applications
    can inherit from. To do this, we''ll create a folder called `views` within our
    `App` folder:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的大多数视图都将具有非常熟悉的功能。例如，将有一个全局导航栏，其中包含三个链接，每个链接将启动每个部分的隐藏/显示，隐藏当前部分并显示下一个部分。我们不一定希望一遍又一遍地编写相同的代码，因此最好有一个基本视图，我们的应用程序可以从中继承。为此，我们将在我们的`App`文件夹中创建一个名为`views`的文件夹：
- en: '`js/App/`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js/App/`'
- en: '`views/`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/`'
- en: '`BaseView.js`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseView.js`'
- en: Okay, so this is basically our JavaScript framework for this sample application.
    Of course, there are other ways of setting this up, and perhaps they are even
    better—which is great. For our purpose, this fits the bill and helps demonstrate
    some structure within our applications. Now, let's start by looking at our markup.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这基本上是我们这个示例应用程序的JavaScript框架。当然，还有其他设置方式，也许它们甚至更好—这很好。对于我们的目的，这符合要求，并有助于展示我们应用程序中的一些结构。现在，让我们开始查看我们的标记。
- en: Application markup
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用标记
- en: Let's open up the `index.html` file pertaining to this chapter; it should be
    located at `/singlepage/index.html`. Now, if we haven't already done so, let's
    start by updating the global navigation of the site, which we have done previously
    for other chapters. If you need reference material, look at the previous chapter's
    finished source code, provided with this book, and update the markup as necessary.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开与本章相关的`index.html`文件；它应该位于`/singlepage/index.html`。现在，如果我们还没有这样做，让我们从更新站点的全局导航开始，这是我们之前为其他章节所做的。如果您需要参考资料，请查看本书提供的上一章的完成源代码，并根据需要更新标记。
- en: 'Our markup, when updated, should look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后，我们的标记应该看起来像这样：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s begin modifying this code to fit our application. First, let''s
    start by adding in a `div` after the header with a class of `content`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始修改这段代码以适应我们的应用程序。首先，让我们在标题后面添加一个`div`，类名为`content`：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we''re done doing that let''s modify the scripts, by including our entire
    application that we created previously. This means we are including the `Music`
    and `User` application scripts, and the `BaseView`. The scripts section of our
    markup should then look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成这些工作后，让我们修改脚本，包括我们之前创建的整个应用程序。这意味着我们包括了`Music`和`User`应用程序脚本，以及`BaseView`。我们的标记脚本部分应该看起来像这样：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have started the Backbone history API. Although we have not discussed
    this thoroughly, this is essential for keeping state in our applications. The
    details for the implementation of the History API in Backbone are beyond the scope
    of this book, but it is highly encouraged for those of you looking to harness
    the power of offline storage using Backbone. For now, keep in mind that this is
    essential for routing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经启动了Backbone历史API。虽然我们还没有全面讨论这一点，但这对于保持应用程序状态至关重要。Backbone中历史API的实现细节超出了本书的范围，但对于那些希望利用Backbone进行离线存储的人来说，这是非常鼓励的。现在，请记住这对于路由是至关重要的。
- en: Creating templates
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建模板
- en: 'Now our markup is close to completion, but we are still left with what the
    rest of the application will be made of; and that is where templating will come
    in. The next step is to include the templates that will be required for our application,
    including the audio player view, playlist, song, dashboard, profile, and shared
    navigation views. So how does one specify a template on a static HTML page? Like
    this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的标记接近完成，但我们还剩下应用程序的其余部分将由什么组成；这就是模板化将发挥作用的地方。下一步是包括我们应用程序所需的模板，包括音频播放器视图、播放列表、歌曲、仪表板、个人资料和共享导航视图。那么如何在静态HTML页面上指定模板呢？像这样：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You may be wondering why this does not cause any errors in validation or code
    execution within the browser. Well to help clear things up, the `type` attribute
    of our `script` tag is a non-supported MIME type and because of this, the browser
    ignores all content within this `script` block ([http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare](http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare)).
    Because the code within the block doesn't get executed, we can include our HTML
    templates to be used later on. Keep in mind that we have attached an ID that we
    can use to target this element using Zepto. And also note the source for the audio
    element, specifically `<%= file %>`. This will be used by Underscore's `template`
    method to interpolate the data passed into the template itself. We'll get to that
    soon, but for now know that this is how we can set up our templates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么这不会在浏览器中引起任何验证错误或代码执行错误。好吧，为了帮助澄清事情，我们的`script`标签的`type`属性是一个不受支持的MIME类型，因此浏览器会忽略`script`块中的所有内容（[http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare](http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare)）。因为块内的代码不会被执行，所以我们可以包含我们的HTML模板以供以后使用。请记住，我们已经附加了一个ID，我们可以使用Zepto来定位这个元素。还要注意音频元素的来源，特别是`<%=
    file %>`。这将由Underscore的`template`方法用于插入模板本身传递的数据。我们很快就会讨论到这一点，但现在知道这就是我们可以设置模板的方式。
- en: 'Okay, we now know how to create templates, so let''s implement the following
    templates right before the inclusion of our applications'' scripts. We can include
    the preceding template for the audio player, and after that we can include the
    following template:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道如何创建模板，让我们在包含我们应用程序脚本之前实现以下模板。我们可以包括音频播放器的前一个模板，然后我们可以包括以下模板：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the playlist view template we have some pretty interesting stuff going on.
    Take a look at the code after the `h1` tag. We see here the `template` method
    from Underscore's library; it is accepting one parameter that will be an HTML
    string of the template `#tmpl-user-nav`, which we have not defined yet, and the
    second parameter is an empty object. This example is showcasing the use of a template
    within a template, kind of Inception-like but hopefully not too scary. Remember
    that we mentioned there would be a global navigation included in our applications;
    the preceding method helps us code once—keeping our code clean, manageable, and
    efficient.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放列表视图模板中，我们有一些非常有趣的东西。看一下`h1`标签后面的代码。我们在这里看到Underscore库的`template`方法；它接受一个参数，这个参数将是模板`#tmpl-user-nav`的HTML字符串，我们还没有定义，第二个参数是一个空对象。这个例子展示了在模板中使用模板的用法，有点像潜行，但希望不会太可怕。请记住，我们提到我们的应用程序中将包含全局导航；前面的方法帮助我们编写一次代码，保持我们的代码清洁、可管理和高效。
- en: 'Now, our playlist still doesn''t contain a list of songs. That is because it
    will be dynamic and based on a dataset of songs; this is why we have an empty
    unordered list within the playlist view. But how will our songs look? Traditionally,
    we would just create a list (`li`) element in our JavaScript, but with templates
    we no longer need to do that—we can keep our markup outside our logic:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的播放列表仍然不包含歌曲列表。这是因为它将是动态的，基于歌曲数据集；这就是为什么在播放列表视图中有一个空的无序列表。但我们的歌曲会是什么样子呢？传统上，我们只需在JavaScript中创建一个列表（`li`）元素，但是使用模板，我们不再需要这样做——我们可以将标记保留在逻辑之外：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'See how easy it is now to keep your markup outside of your scripts? In this
    template, we are following the same basic principles: define a script block containing
    markup and create the markup that will then be interpolated to include the data
    we want. In this case, we want the track and artist to be output into their own
    elements. Now let''s create the user''s dashboard:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看将标记保留在脚本之外是多么容易？在这个模板中，我们遵循相同的基本原则：定义一个包含标记的脚本块，并创建将插值到其中的标记，以包含我们想要的数据。在这种情况下，我们希望将曲目和艺术家输出到它们自己的元素中。现在让我们创建用户的仪表板：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, it''s the same as before. In fact we are repeating ourselves by using
    the same method in the playlist view to display the global navigation. By now,
    you have noticed that each template receives a specific ID, and that, for convention,
    we have defined the type of each `script` block according to its application,
    for example `tmpl/User` for the User application and `tmpl/Music` for the Music
    application. Let''s now take a look at the profile view that combines both the
    preceding methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，和以前一样。实际上，我们正在重复使用在播放列表视图中显示全局导航的相同方法。到目前为止，你已经注意到每个模板都有一个特定的ID，并且根据约定，我们已经根据其应用程序定义了每个`script`块的类型，例如`tmpl/User`用于用户应用程序，`tmpl/Music`用于音乐应用程序。现在让我们来看一下结合了前面两种方法的个人资料视图。
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this view, we have the global navigation being printed out and data being
    interpolated. As you can see, there is no limit to what you can do in templates.
    But it can also be something as simple as the global navigation for our applications:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，全局导航被打印出来，并且数据被插值。正如你所看到的，模板中可以做任何事情。但它也可以是我们应用程序的全局导航这样简单的东西：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this last example, there is nothing complicated happening, it is essentially
    the global navigation we have been expecting and it turns out—it's just markup.
    Now, you may be wondering why not create all of this in the DOM, hide it, and
    then populate it with the information you need using the built-in selector engines
    in `Zepto` or `jQuery`. And honestly, that is a great question to ask. But there
    is one main reason, performance. It is expensive to use these engines, even the
    built-in methods `querySelector` and `querySelectorAll`. We do not want to touch
    the DOM, because it is a heavy operation, especially for large-scale applications
    handling large data sets. And ultimately, it's messy to do DOM operations just
    for data population or storage. Just don't do it, it is a nasty habit to use the
    DOM for data and not a best practice throughout the industry.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，没有发生复杂的事情，实际上就是我们一直期待的全局导航，结果是——它只是标记。现在，你可能会想为什么不在DOM中创建所有这些，隐藏它，然后使用`Zepto`或`jQuery`中的内置选择器引擎填充所需的信息。老实说，这是一个很好的问题。但是有一个主要原因，性能。使用这些引擎是昂贵的，甚至是内置方法`querySelector`和`querySelectorAll`。我们不想触及DOM，因为这是一个繁重的操作，特别是对于处理大数据集的大规模应用程序。最终，仅仅为了数据填充或存储而进行DOM操作是混乱的。不要这样做，将DOM用于数据而不是最佳实践。
- en: Our templates are complete, and that concludes the markup of our application.
    Now we move to the fun part, our scripts. The next part will be quite complex
    and pretty challenging, but I promise that when we're done, you'll be a pro at
    one-page applications and ready to create your own quickly. The first time around
    is always rough, but stick through it and you'll reap the rewards.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板已经完成，这就结束了我们应用程序的标记。现在我们转向有趣的部分，我们的脚本。接下来的部分将会相当复杂和相当具有挑战性，但我保证当我们完成时，你将成为一个单页应用程序的专家，并且准备快速创建你自己的应用程序。第一次总是艰难的，但坚持下去，你将会收获回报。
- en: Application scripts
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序脚本
- en: In this section we'll go through the scripts needed to make our application
    work. We'll start with reviewing the `BaseView`, the view containing shared functionality
    in inherited views (`PlayListView`, `ProfileView`, and `DashboardView`). From
    there we'll create our Music and User applications, each having their relative
    models, views, and collections.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍使我们的应用程序工作所需的脚本。我们将从审查`BaseView`开始，这个视图包含了继承视图（`PlayListView`、`ProfileView`和`DashboardView`）中的共享功能。然后我们将创建我们的音乐和用户应用程序，每个应用程序都有它们相对应的模型、视图和集合。
- en: The BaseView
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BaseView
- en: 'Let''s start looking at our scripts, beginning with the `BaseView` file we
    created under the `App` namespace (`js/App/views/BaseView.js`). In this file,
    we''ll create the `BaseView` class that will extend Backbone''s general `View`
    class. The `BaseView` will then look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始查看我们的脚本，从我们在`App`命名空间下创建的`BaseView`文件开始（`js/App/views/BaseView.js`）。在这个文件中，我们将创建`BaseView`类，它将扩展Backbone的通用`View`类。`BaseView`将如下所示：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This class follows the exact same pattern as the rest of the JavaScript we have
    written in previous chapters, the only differences here include the inclusion
    of `Backbone` and `Undescore` and the way we expose the `BaseView` class using
    `window.App.BaseView = BaseView`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类遵循了我们在之前章节中编写的其他JavaScript的完全相同的模式，这里唯一的区别是包括了`Backbone`和`Undescore`，以及我们如何使用`window.App.BaseView
    = BaseView`来公开`BaseView`类。
- en: 'Now, bear with me here. We will be creating several methods that will be included
    in any object extending the `BaseView` class. These methods will include `show`,
    `hide`, `onProfileClick`, `onPlaylistClick`, `onDashboardClick`, and `onEditClick`.
    As you may have guessed, some of these methods will be event handlers that will
    navigate to certain parts of our application. Check out the following code for
    the implementation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请跟着我。我们将创建几种方法，这些方法将包含在扩展`BaseView`类的任何对象中。这些方法将包括`show`、`hide`、`onProfileClick`、`onPlaylistClick`、`onDashboardClick`和`onEditClick`。正如你可能已经猜到的，其中一些方法将是事件处理程序，用于导航到我们应用程序的某些部分。查看以下代码以了解实现：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, you may notice that the objects written here have not been created, such
    as the `$template`, `User`, and `Music` objects. We'll return to this in a few
    steps, but keep in mind that `this.$template` will refer to the instance extending
    `BaseView`, and that the User and Music objects will be routers that will use
    the built-in backbone method called `navigate` to change our application's location
    in the URL and to store the history of the user's interaction. To better understand
    how this class, `BaseView`, gets used, let's start creating the code for the `Music`
    object in `Music.js` (`js/Music/Music.js`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能注意到这里写的对象尚未创建，比如`$template`、`User`和`Music`对象。我们将在几个步骤后返回到这一点，但请记住，`this.$template`将指的是扩展`BaseView`的实例，而`User`和`Music`对象将是使用内置的backbone方法`navigate`来改变我们应用程序在URL中的位置并存储用户交互历史的路由器。为了更好地理解这个类`BaseView`是如何被使用的，让我们开始创建`Music.js`中`Music`对象的代码（`js/Music/Music.js`）。
- en: Music application
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 音乐应用程序
- en: Now let's jump into creating the first part of our application, the music application.
    Both the music and user applications are separated to add a higher level of maintainability
    and reuse. Starting with the music application, we'll create the appropriate router,
    collection, model, and view.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始创建我们应用程序的第一部分，音乐应用程序。音乐和用户应用程序都是分开的，以增加更高级别的可维护性和重用性。从音乐应用程序开始，我们将创建适当的路由器、集合、模型和视图。
- en: The router
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路由器
- en: 'Our music application begins with the `Music` class defined in our `Music.js`
    file located at `js/Music/`. In this file, we will extend Backbone''s `Router`
    class, containing the routes for our music application, a sample data object for
    use with our models and collections, and finally an event handler for when the
    playlist is requested. First, let''s start out with defining the class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音乐应用程序始于`Music.js`文件中定义的`Music`类，该文件位于`js/Music/`目录下。在这个文件中，我们将扩展Backbone的`Router`类，包含我们音乐应用程序的路由、用于模型和集合的示例数据对象，以及当请求播放列表时的事件处理程序。首先，让我们从定义类开始：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Following the pattern we have established with our `BaseView` class, we extend
    the `Router` class in `Backbone` and define some default routes. The two routes
    include a general playlist route and an alternative route containing the playlist
    and the track number. Both routes, when called, will invoke the `setupPlaylist`
    method that we will define next:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们在`BaseView`类中建立的模式，我们在`Backbone`中扩展`Router`类，并定义一些默认路由。这两个路由包括一个常规播放列表路由和一个包含播放列表和曲目编号的替代路由。当调用这两个路由时，都将调用我们接下来将定义的`setupPlaylist`方法：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Don't worry if this code is a bit intimidating, it's actually pretty simple.
    First, we check if a `songCollection` object has been initialized with the instance
    of `Music`. If it hasn't then we create one, using a sample data object of songs—which
    we haven't created yet. Next, we do the same thing, checking if the `playListView`
    object has been created; if not we move on to creating it. Otherwise, we just
    show the playlist and the audio player associated with it. Lastly, we check if
    a track number has been passed in (related to the second route we created); if
    there is a track number, we update the `playListView` to reflect the track selected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码让你有点畏首畏尾，那没关系，它实际上非常简单。首先，我们检查是否已经使用`Music`的实例初始化了一个`songCollection`对象。如果没有，我们将使用一组歌曲的示例数据对象来创建一个。接下来，我们做同样的事情，检查`playListView`对象是否已经创建；如果没有，我们继续创建它。否则，我们只是显示播放列表和与之相关的音频播放器。最后，我们检查是否传递了曲目编号（与我们创建的第二个路由相关）；如果有曲目编号，我们将更新`playListView`以反映所选的曲目。
- en: 'Let''s focus on the initialization of the `playListView`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于`playListView`的初始化：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Although we haven''t officially created the `PlayListView` class, we can review
    how it gets initialized. In this case, we are attaching a property of `playListView`
    on the instance of `Music` with `this.playListView`. This property is going to
    be an instance of the `PlayListView` (`new PlayListView({})`). This new instance
    of `PlayListView` will accept a plain object that contains three properties: an
    element defined as `el`, a collection, and an instance of a `UserModel`, which
    has not been defined.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尚未正式创建`PlayListView`类，但我们可以回顾它是如何初始化的。在这种情况下，我们在`Music`的实例上附加了一个`playListView`属性，即`this.playListView`。这个属性将是`PlayListView`的一个实例（`new
    PlayListView({})`）。这个`PlayListView`的新实例将接受一个普通对象，其中包含三个属性：一个定义为`el`的元素，一个集合，以及一个`UserModel`的实例，这个实例尚未定义。
- en: 'The last thing we need to do here is include an `initialize` method that will
    create a sample data object (`this.songs`), and listen for when the playlist route
    is called. When we call the playlist route, or navigate to it, we want both the
    profile and dashboard to hide; we''ll do this manually within the `routes` listener:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们需要做的最后一件事是包括一个`initialize`方法，该方法将创建一个示例数据对象（`this.songs`），并监听播放列表路由的调用。当我们调用播放列表路由或导航到它时，我们希望同时隐藏个人资料和仪表板；我们将在`routes`监听器中手动执行这一操作：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Okay, so we have created the `initialize` method here, which gets called when
    an instance of `Music` is created. This is good, because in this method we take
    care of any setup work, such as creating the sample data object. The sample data
    object is an array of objects that will then be transformed into models by the
    `SongCollection` class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们在这里创建了`initialize`方法，当创建`Music`的实例时会调用这个方法。这很好，因为在这个方法中，我们可以处理任何设置工作，比如创建示例数据对象。示例数据对象是一个对象数组，然后将被`SongCollection`类转换为模型：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Looks familiar huh? Now we're tying up loose ends. We haven't created the `SongCollection`
    class yet, but as Backbone's documentation states, if an array is passed into
    a collection, it is automatically turned into the model specified in the collection
    (to be described in future steps).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很熟悉吧？现在我们正在收尾。我们还没有创建`SongCollection`类，但是Backbone的文档中指出，如果将数组传递给集合，它会自动转换为集合中指定的模型（将在未来的步骤中描述）。
- en: The last thing this `initialize` method does, is define a listener on the route
    for playlist (`this.on('route:setupPlaylist', function() {});`). The event handler
    then hides the profile and dashboard if they have been created. Also, note that
    we have specified the route using `route:setupPlaylist`, but we could have easily
    listened to any route by just using `route`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`initialize`方法做的最后一件事是，在播放列表的路由上定义一个监听器（`this.on('route:setupPlaylist', function()
    {});`）。事件处理程序然后隐藏了已经创建的个人资料和仪表板。另外，请注意，我们使用`route:setupPlaylist`指定了路由，但我们也可以使用`route`来监听任何路由。
- en: So I know this is a lot to digest, but we'll now connect the dots from this
    `Music` class, starting with collections then moving on to models and finally
    views. This class is the foundation for everything else that needs to get built
    in order to have a fully functional music application and provide the blueprint
    of our development.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这是很多东西要消化的，但我们现在将从这个`Music`类开始连接这些点，从集合开始，然后转向模型，最后是视图。这个类是其他所有需要构建的东西的基础，以便拥有一个完全功能的音乐应用程序，并提供我们开发的蓝图。
- en: The collection
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 集合
- en: The collection for our music application is simple. Following the basic template
    of what we've done previously, we will create a closure containing the `SongCollection`
    class. Then we will define the type of model the `SongCollection` should keep.
    And lastly, we'll expose the class to our `Music` object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们音乐应用程序的集合很简单。遵循我们之前所做的基本模板，我们将创建一个包含`SongCollection`类的闭包。然后我们将定义`SongCollection`应该保持的模型类型。最后，我们将把这个类暴露给我们的`Music`对象。
- en: 'When we are done implementing these requirements, our class looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成了实现这些要求后，我们的类看起来是这样的：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See how simple it was? Now we know that this collection only keeps track of
    models that are of type `SongModel` and that if passed an array, it will transform
    the contained objects into `SongModel` types. This is all this class will do for
    now. Of course, you are welcome to extend it and play around with the several
    methods, such as the comparator, this class can harness; but for now, this is
    all we need.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来多简单啊？现在我们知道这个集合只跟踪`SongModel`类型的模型，并且如果传递一个数组，它将把包含的对象转换为`SongModel`类型。这就是这个类现在要做的全部。当然，您可以扩展它并尝试使用几种方法，比如比较器，这个类可以利用；但现在，这就是我们需要的全部。
- en: The model
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模型
- en: Our `SongModel` will describe the type of data we're trying to keep track of.
    This model will also contain a single method that will take a property of duration,
    in seconds, and return it in minutes. Of course, we have the option to prepare
    our model, when it has been initialized, but for now we'll keep it simple.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SongModel`将描述我们试图跟踪的数据类型。这个模型还将包含一个单一的方法，该方法将以秒为单位的持续时间作为属性，并将其以分钟返回。当然，我们有选择在模型初始化时准备我们的模型，但现在我们将保持简单。
- en: 'The `SongModel`, when written, will look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`SongModel`，当写出来时，将是这样的：'
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: From the preceding code, we can infer that the `SongModel` will have the attributes
    `duration`, `artist`, `added`, `track`, and `album`. Each will have a default
    value of an empty `String` or `0`. We can also notice that each model will have
    a method named `getDurationInMinutes` that can be invoked and would return the
    duration of that model in minutes. Again, the `SongModel` class follows the same
    basic architecture and best practices, returning itself to the `Music` object.
    Finally, we are ready to look at the views for this music application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以推断出`SongModel`将具有属性`duration`、`artist`、`added`、`track`和`album`。每个属性的默认值都是空的`String`或`0`。我们还可以注意到，每个模型都将有一个名为`getDurationInMinutes`的方法，可以被调用，并返回该模型的持续时间（以分钟为单位）。同样，`SongModel`类遵循相同的基本架构和最佳实践，返回给`Music`对象。最后，我们准备好查看这个音乐应用程序的视图。
- en: The view(s)
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图（们）
- en: In this part, we're going to review three separate views, including the play
    list, song, and audio player views. Each view renders an individual part of the
    music application, except for playlist, which renders both the audio player and
    each individual song. So, let's start with the playlist view.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将审查三个单独的视图，包括播放列表、歌曲和音频播放器视图。每个视图呈现音乐应用程序的一个单独部分，除了播放列表，它还呈现音频播放器和每个单独的歌曲。所以，让我们从播放列表视图开始。
- en: The playlist view
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 播放列表视图
- en: We want the play list view to do a couple of things but we'll take it one step
    at a time. First, let's create the `PlayListView` class, which will extend our
    already created `BaseView` class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望播放列表视图做一些事情，但我们将一步一步来。首先，让我们创建`PlayListView`类，它将扩展我们已经创建的`BaseView`类。
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we want the `PlayListView` class to reference the proper template.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望`PlayListView`类引用正确的模板。
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By including a template as a property we can easily reference it using `this.template`.
    Keep in mind that we have not processed the template at this stage, we have simply
    used Underscore's `template` method to retrieve the markup. Next, we want to define
    an event listener for when the user clicks on a song.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将模板作为属性包含进来，我们可以很容易地使用`this.template`来引用它。请记住，在这个阶段我们还没有处理模板，我们只是简单地使用了Underscore的`template`方法来检索标记。接下来，我们想要为用户点击歌曲时定义一个事件监听器。
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this step we are telling the view to delegate all the events we've created
    to the view's element. In this event object, we are listening for a click event
    on an element with the class of `.view-song`. When this element is clicked, we
    want to invoke the `onSongClicked` event handler. Let's define this event handler
    next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们告诉视图将我们创建的所有事件委托给视图的元素。在这个事件对象中，我们监听一个带有类名`.view-song`的元素上的点击事件。当点击这个元素时，我们想要调用`onSongClicked`事件处理程序。让我们接下来定义这个事件处理程序。
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The event handler defined in the preceding code toggles the active class and
    then tells the `Music` router to navigate to the playlist route, telling it to
    trigger the route event and pass in the track''s index. By doing this, our route
    is called, passed a track, and the playlist updates. However, we still do not
    have the `updateTrack` method defined. Let''s include the following method in
    our class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义的事件处理程序切换活动类，然后告诉`Music`路由器导航到播放列表路由，告诉它触发路由事件并传递曲目的索引。通过这样做，我们的路由被调用，传递了一个曲目，播放列表更新了。然而，我们仍然没有定义`updateTrack`方法。让我们在我们的类中包含以下方法：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have the `updateTrack` method, and this is essentially telling the audio
    player''s view to render the track it has received. Unfortunately our code is
    still not ready to be run because we haven''t created this method. Also, the following
    method, `setActiveSong`, is not defined, so we need to do that now:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`updateTrack`方法，这本质上是告诉音频播放器的视图渲染它收到的曲目。不幸的是，我们的代码还没有准备好运行，因为我们还没有创建这个方法。另外，下面的方法`setActiveSong`也没有定义，所以我们现在需要这样做：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our `setActiveSong` method is now created and essentially toggles the active
    class depending on the URL''s track number. We could probably extrapolate and
    create a general toggle here for songs, but for now this meets the criteria. But
    we''re not done yet, we still need to initialize this class and render it appropriately.
    Let''s take a look at what the class now needs:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了`setActiveSong`方法，基本上是根据URL的曲目编号切换活动类。我们可能可以推断并在这里为歌曲创建一个通用的切换，但目前这满足了标准。但我们还没有完成，我们仍然需要初始化这个类并适当地渲染它。让我们看看这个类现在需要什么：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code completes the class, but before we move on let's take a look
    at what's going on here. First, we have defined an `initialize` method. This method
    will be invoked after the construction of an instance of this class, therefore
    the render method will also be called. Typically, in Backbone, the `render` method
    does exactly what the function is called—renders the view.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码完成了这个类，但在我们继续之前，让我们看看这里发生了什么。首先，我们定义了一个`initialize`方法。这个方法将在创建这个类的实例后被调用，因此`render`方法也将被调用。通常，在Backbone中，`render`方法确切地做了函数被调用的事情——渲染视图。
- en: 'The `render` method defined does a few things; first it compiles our template
    using the model that was passed in. Earlier we saw the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的`render`方法做了一些事情；首先，它使用传入的模型编译我们的模板。之前我们看到了以下代码：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As we can see, a new `UserModel` is created and passed into the `PlayListView`,
    and this instance is used to populate the playlist's template. Once the compilation
    is done, we attach the compiled template using Zepto's `append` method. What is
    it attaching it to, you ask? Well, the above initialization of this class is looking
    for an element with the class of `content`, which we defined after the header
    element on our page. Therefore, the `PlayListView` is going to attach itself to
    this `div` of class `content`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，创建了一个新的`UserModel`并将其传递给`PlayListView`，并且这个实例用于填充播放列表的模板。一旦编译完成，我们使用Zepto的`append`方法附加编译后的模板。你可能会问，它附加到什么上面？好吧，这个类的上面初始化正在寻找一个类为`content`的元素，我们在页面的标题元素之后定义了它。因此，`PlayListView`将附加到这个类为`content`的`div`上。
- en: 'When the template is done being attached, we check if the audio player view
    has been created. If not, then we create it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板附加完成后，我们检查音频播放器视图是否已经创建。如果没有，那么我们就创建它：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, once the check for the audio player view is made we get to the fun
    stuff. In this last part we loop through the collection that was sent over, which
    is an instance of `SongCollection` and the same data created in `Music.js`. As
    we loop through each model in the collection we create an instance of `SongView`
    each time, passing in the compiled template's unordered list element and passing
    it the current model.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦检查音频播放器视图，我们就可以开始有趣的事情了。在最后一部分中，我们循环遍历发送过来的集合，这是`SongCollection`的一个实例，与`Music.js`中创建的相同数据。当我们遍历集合中的每个模型时，我们每次都创建一个`SongView`的实例，将编译模板的无序列表元素传递给它，并传递当前模型。
- en: 'Now, if that didn''t blow your mind, I''m not sure what could. Either way,
    I hope you''re still up for the challenge because we have two more views we need
    to look at: the `AudioPlayerView` and the `SongView`. Don''t lose hope though,
    we have passed the greatest challenge and are ready to ride the wave.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果这没有让你大吃一惊，我不知道还有什么能让你大吃一惊。无论如何，我希望你仍然能接受这个挑战，因为我们还有两个视图需要看一看：`AudioPlayerView`和`SongView`。不过不要失去希望，我们已经度过了最大的挑战，准备好迎接新的挑战。
- en: The audio player view
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 音频播放器视图
- en: 'We''re going to build our `AudioPlayerView` next. This view needs to pick up
    on the template we created earlier, populating it with the track number and loading
    it if we directly access the URL, for example `/#playlist/2`. We also need to
    override a method on the extended `BaseView`, the method that needs to be overwritten
    is `onDashboardClick`. This is because it requires we hide the playlist and then
    navigate to the dashboard. So at the very basic level, this class will look like
    this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要构建我们的`AudioPlayerView`。这个视图需要使用我们之前创建的模板，用曲目编号填充它，并在直接访问URL时加载它，例如`/#playlist/2`。我们还需要覆盖扩展的`BaseView`上的一个方法，需要被覆盖的方法是`onDashboardClick`。这是因为它要求我们隐藏播放列表，然后导航到仪表板。所以在最基本的层面上，这个类将如下所示：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As we can see, all the requirements listed in the previous paragraph have been
    met with this base class for the `AudioPlayerView`. However, we need to render
    out this view, populating it with the data provided by the URL. To do this, we
    need to write our `render` method like so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，前面段落中列出的所有要求都已经在`AudioPlayerView`的基类中得到满足。然而，我们需要渲染出这个视图，并用URL提供的数据填充它。为了做到这一点，我们需要编写我们的`render`方法如下：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similar to the previous `render` method we wrote for the playlist view, the
    `render` method checks if a file, a number, has been passed in. If it has we populate
    the audio element from our template with what was passed in. Next, we compile
    our template, then set the volume to `0.5` and attach the player right after the
    header of `PlayListView`. If we review how we initialized this class, we''ll notice
    that the audio player view delegates to the playlist view element (inside `PlayListView`):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为播放列表视图编写的先前的`render`方法类似，`render`方法检查是否传入了文件或数字。如果有，我们将使用传入的内容填充我们的模板中的音频元素。接下来，我们编译我们的模板，然后将音量设置为`0.5`，并将播放器附加到`PlayListView`的标题后面。如果我们回顾一下我们如何初始化这个类，我们会注意到音频播放器视图委托给了播放列表视图元素（在`PlayListView`内部）：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The song view
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 歌曲视图
- en: The last part of our music application is the `SongView`. So let's quickly review
    the requirements for this and see its implementation. For this view, we again
    want to set our template. When we initialize this view we want to attach an event
    handler on the model passed in, so if the model is ever updated, the view renders
    automatically with the update. The `render` method of this view should essentially
    compile the template with the model's attributes and then attach itself to the
    element set for this view.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们音乐应用程序的最后一部分是`SongView`。让我们快速回顾一下这个视图的要求并看看它的实现。对于这个视图，我们再次想设置我们的模板。当我们初始化这个视图时，我们希望在传入的模型上附加一个事件处理程序，因此如果模型被更新，视图将自动渲染更新。这个视图的`render`方法应该基本上使用模型的属性编译模板，然后将自己附加到为这个视图设置的元素上。
- en: 'When we are done implementing the preceding requirements, the view should look
    somewhat like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成了前面的要求实现后，视图应该看起来有点像这样：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As we can see, we follow the standards set in previous view implementations.
    The only difference is the addition of the event listener on the model''s change
    event. Let''s remind ourselves of how this view gets initialized in `PlayListView`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们遵循了先前视图实现中设定的标准。唯一的区别是在模型的更改事件上添加了事件侦听器。让我们回顾一下`PlayListView`中这个视图是如何初始化的：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now we fully understand how the music application works. At this point, our
    page could function just with this implementation; however, I don't recommend
    it since errors will come up because we haven't created the user application.
    But we now know that our routes define the actions in our application, views are
    the presentation layer that implements models and collections. Models are the
    heart of our application, containing all the data we need in a manageable fashion.
    And finally, collections help us manage larger data sets of our models and because
    we can pass these into the view, the view itself can manage the render of this
    data, which is ideal for large-scale applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完全理解了音乐应用程序是如何工作的。在这一点上，我们的页面可以仅通过这种实现来运行；但是，我不建议这样做，因为我们还没有创建用户应用程序，错误将会出现。但是我们现在知道，我们的路由定义了应用程序中的操作，视图是实现模型和集合的表示层。模型是我们应用程序的核心，以可管理的方式包含我们需要的所有数据。最后，集合帮助我们管理模型的更大数据集，因为我们可以将这些传递到视图中，视图本身可以管理这些数据的呈现，这对于大型应用程序来说是理想的。
- en: The next step of this process is to develop the user application, but hopefully
    things will be a bit easier. As we did in the last part, we'll start out with
    the router and work our way to the collection, model, and views.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的下一步是开发用户应用程序，但希望事情会变得更容易一些。就像我们在上一部分中所做的那样，我们将从路由开始，然后逐步进行到集合、模型和视图。
- en: User application
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户应用程序
- en: The user application will follow the same flow as the music application we created.
    Again, we'll cover the implementation of a router, model, and view. When we are
    done with this section we'll have subapplications that each run separately and
    increases the maintainability and efficiency of our one-page application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应用程序将遵循我们创建的音乐应用程序相同的流程。同样，我们将涵盖路由、模型和视图的实现。当我们完成这一部分时，我们将拥有各自独立运行的子应用程序，从而增加了我们单页应用程序的可维护性和效率。
- en: The router
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路由
- en: Our router for the user application will be very similar to the music application.
    We'll define the routes for the dashboard and profile. We will also take the time
    to create the homepage route of our one-page application. The route will contain
    the appropriate methods for setting up the dashboard and profile. It will also
    contain the homepage method, which will call the dashboard route. In the `initialize`
    method of the router we will listen to these routes and hide other views.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户应用程序的路由将与音乐应用程序非常相似。我们将定义仪表板和个人资料的路由。我们还将抽出时间创建单页应用程序的主页路由。该路由将包含设置仪表板和个人资料的适当方法。它还将包含主页方法，该方法将调用仪表板路由。在路由的`initialize`方法中，我们将监听这些路由并隐藏其他视图。
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code, we follow our standards, and create the base template
    for our user application. Next, let''s take a look at what the `initialize` method
    will contain:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们遵循我们的标准，为用户应用程序创建基本模板。接下来，让我们看看`initialize`方法将包含什么：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `initialize` method of our route meets the requirements we've listed by
    creating the event listeners for the routes we created. Each listener hides the
    sections we don't want to see, but how do we see the actual part of the application
    we want? Well, that's where the `setup` methods come in.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们路由的`initialize`方法满足了我们列出的要求，通过为我们创建的路由创建事件侦听器。每个侦听器都隐藏了我们不想看到的部分，但是我们如何看到我们想要的应用程序的实际部分呢？这就是`setup`方法发挥作用的地方。
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These methods are pretty much the same. They do a check for whether the view
    has been created on the instance of the router (for example `this.dashboardView`
    and `this.profileView`), if it has we just show that view. However, if the view
    has not been created, we initialize the appropriate view and then call that `setup`
    method again (recursive), so that we can show it since the view now exists.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法基本上是相同的。它们检查视图是否已经在路由实例上创建（例如`this.dashboardView`和`this.profileView`），如果已经创建，我们只显示该视图。然而，如果视图尚未创建，我们初始化适当的视图，然后再次调用该`setup`方法（递归），以便我们可以显示它，因为现在视图已经存在。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may have noticed that we are creating a new `UserModel` that gets passed
    to many of our views. This is okay for now, since we want to test the meat of
    our application. But theoretically, one `UserModel` would be initialized and maintained
    throughout the application. Sounds like something you can tackle once you complete
    this chapter!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们正在创建一个新的`UserModel`，并将其传递给我们的许多视图。目前这样做是可以的，因为我们想要测试应用程序的核心部分。但从理论上讲，一个`UserModel`将在整个应用程序中被初始化和维护。完成本章后，你可以尝试解决这个问题！
- en: 'The last thing we need to do is include the homepage method for our application:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是为我们的应用程序包含主页方法：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Automatically, when you visit `/singlepage/index.html`, this route will be called.
    As defined in the `Backbone.js` library's documentation, an empty route refers
    to the home state of the application. Although we can define the `setupDashboard`
    method to be the callback, this is to illustrate that we can go from one route
    to another immediately when needed. Perhaps we could do some preprocessing here,
    or even create that single `UserModel` noted earlier?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问`/singlepage/index.html`时，将调用这个路由。根据`Backbone.js`库的文档，空路由指的是应用程序的主页状态。虽然我们可以将`setupDashboard`方法定义为回调，但这是为了说明我们可以在需要时立即从一个路由转到另一个路由。也许我们可以在这里做一些预处理，甚至创建之前提到的单个`UserModel`？
- en: The collection
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 集合
- en: Because we are only handling one user in this application, there won't be any
    need for creating a collection. Phew! You thought this would get a bit more difficult
    eh? Well, don't get your hopes up; we still have the model and view(s) to consider.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在这个应用程序中只处理一个用户，所以不需要创建集合。哦！你以为这会变得更加困难吗？好吧，别抱太大希望；我们仍然需要考虑模型和视图。
- en: The model
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模型
- en: As with any model in Backbone, we are just describing the data that will be
    handled throughout our application. This is no different for our `UserModel`,
    which will contain the default attributes of an instance and set the name of the
    person by combining the `first_name` and `last_name` attributes when it is initialized.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与Backbone中的任何模型一样，我们只是描述了将在整个应用程序中处理的数据。对于我们的`UserModel`来说也是如此，它将包含实例的默认属性，并在初始化时通过组合`first_name`和`last_name`属性来设置人的姓名。
- en: 'To meet these requirements, our `UserModel` will be defined like so:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这些要求，我们的`UserModel`将被定义如下：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That's really it for our model. We are just defining default values for our
    user and setting the name when an instance is created. Now we'll take a look at
    our `DashboardView` and `ProfileView`—the last two pieces for this application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们模型的全部内容。我们只是为用户定义了默认值，并在创建实例时设置了名称。现在我们将看一下我们的`DashboardView`和`ProfileView`——这个应用程序的最后两个部分。
- en: The view(s)
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图
- en: The user application will contain two views, including the `DashboardView` and
    `ProfileView`. As we have already established, each view extends the `BaseView`
    we created earlier. We'll need to make some changes in order to fit our experience,
    but overall this will be very similar to our music application view's implementation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应用程序将包含两个视图，包括`DashboardView`和`ProfileView`。正如我们已经建立的那样，每个视图都扩展了我们之前创建的`BaseView`。为了适应我们的体验，我们需要做一些改变，但总体上这与我们的音乐应用程序视图的实现非常相似。
- en: The dashboard view
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 仪表板视图
- en: As with our previously defined views, `DashboardView` will contain the template
    that will be used for the display of our dashboard, contain the events pertaining
    to this view and then render the template. What you'll notice here is that our
    events will use the event handlers defined in `BaseView`, because the `BaseView`
    event handlers meet the basic requirements of navigating to another view while
    the route listeners handle the hide functionality.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前定义的视图一样，`DashboardView`将包含用于显示我们仪表板的模板，包含与此视图相关的事件，然后渲染模板。你会注意到这里我们的事件将使用在`BaseView`中定义的事件处理程序，因为`BaseView`的事件处理程序满足了导航到另一个视图的基本要求，而路由监听器处理了隐藏功能。
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The code for this view is fairly simple; we've seen this pattern before and
    are repeating it here. Because we've defined the event handlers in `BaseView`,
    we don't need to redefine them here. As for the `render` method, it checks for
    the creation of the template, and if it exists, it populates the template with
    the user's data, which we passed in when creating the instance of `DashboardView`
    in `User.js`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的代码非常简单；我们以前见过这种模式，现在在这里重复。因为我们在`BaseView`中定义了事件处理程序，所以我们不需要在这里重新定义它们。至于`render`方法，它会检查模板的创建，如果存在，就会用用户的数据填充模板，这些数据是在创建`User.js`中的`DashboardView`实例时传递的。
- en: 'This is all we need to do for the dashboard view; like I promised, it''s fairly
    easy once the general setup is finished. Next let''s take a look at the final
    part of our application: the profile view.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为仪表板视图需要做的全部；就像我承诺的那样，一旦一般设置完成，它就相当容易。接下来让我们来看看我们应用程序的最后一部分：个人资料视图。
- en: The profile view
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 个人资料视图
- en: Our profile view will be exactly the same as the dashboard view in that we have
    a template, some events, and a `render` method. And just like before, we won't
    need to define the event handlers because the basic requirement of hiding a view
    is being taken care of by the `BaseView` we created at the beginning of this process.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的个人资料视图将与仪表板视图完全相同，因为我们有一个模板、一些事件和一个`render`方法。就像以前一样，我们不需要定义事件处理程序，因为`BaseView`在这个过程的开始时已经处理了隐藏视图的基本要求。
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And that wraps everything up. If we run the page now, we get a fully accessible
    application that has the dashboard view as its default view. You can then interact
    with the application by navigating to the profile and playlist views. As you do
    so, the application changes the URL and keeps history of your activity, letting
    you go back and forward easily. Pretty neat, huh? Here are a couple of screenshots
    to showcase what the final application should look like:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。如果我们现在运行页面，我们将得到一个完全可访问的应用程序，其默认视图为仪表板视图。然后，您可以通过导航到个人资料和播放列表视图与应用程序进行交互。当您这样做时，应用程序会更改URL并保留您的活动历史记录，让您可以轻松地前进和后退。相当不错，对吧？以下是一些屏幕截图，展示最终应用程序的外观：
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might be wondering about the styling for this application. Well lucky for
    you, the source code of this book has all of that written for you. We won't be
    going over the styling, since it doesn't really cover anything mobile specific
    and is more of a visual enhancement to display the applications we built here.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这个应用程序的样式。幸运的是，本书的源代码已经为您编写了所有这些内容。我们不会讨论样式，因为它实际上并没有涵盖任何移动特定的内容，而是更多地是对我们在这里构建的应用程序进行视觉增强的展示。
- en: '![The profile view](img/1024OT_07_03.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![个人资料视图](img/1024OT_07_03.jpg)'
- en: This screenshot of the application running in the iOS simulator showcases the
    dashboard view of the application we've written. In this view, we see our regular
    header and footer, including the title of the book, and a select control as the
    navigation. Inside the content area we see our dashboard templates rendering John
    Doe's dashboard and links to the playlist, profile, and back to the dashboard.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序在iOS模拟器中运行的屏幕截图展示了我们编写的应用程序的仪表板视图。在这个视图中，我们看到我们的常规页眉和页脚，包括书名和作为导航的选择控件。在内容区域内，我们看到我们的仪表板模板呈现了约翰·多的仪表板和链接到播放列表、个人资料和返回到仪表板。
- en: '![The profile view](img/1024OT_07_04.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![个人资料视图](img/1024OT_07_04.jpg)'
- en: Here we are in the playlist and song views showcasing an audio control and the
    ability to switch between tracks. We can see the rendering of templates inside
    of templates (audio tracks inside of the playlist). With this example, we can
    see how separation of controls (models, views, and controllers) helps us distinguish
    logic from user interface.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了播放列表和歌曲视图，展示了音频控件和在曲目之间切换的能力。我们可以看到模板在模板内的呈现（播放列表内的音轨）。通过这个例子，我们可以看到控件（模型、视图和控制器）的分离如何帮助我们区分逻辑和用户界面。
- en: '![The profile view](img/1024OT_07_05.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![个人资料视图](img/1024OT_07_05.jpg)'
- en: In this screenshot, we see an audio track selected and playing under the **Playlist**
    page. It might seem like there's not a lot going on, but behind the scenes we
    have created a reusable application that allows user interaction without a page
    refresh.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，我们看到在**播放列表**页面下选择并播放的音轨。看起来似乎没有太多事情发生，但在幕后，我们已经创建了一个可重复使用的应用程序，允许用户在不刷新页面的情况下进行交互。
- en: '![The profile view](img/1024OT_07_06.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![个人资料视图](img/1024OT_07_06.jpg)'
- en: In this last screenshot, we see the profile view, displaying John Doe's short
    biography, age, and birth date. During the transition of playlist and profile
    we didn't see a page refresh, instead a content update. Analyzing the URL, we
    can see that history has been kept and thus, allowing us to use the native back
    button to maneuver through the one-page application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一个屏幕截图中，我们看到了个人资料视图，显示了约翰·多的简短传记、年龄和出生日期。在播放列表和个人资料的过渡期间，我们没有看到页面刷新，而是内容更新。分析URL，我们可以看到历史记录已被保留，因此，允许我们使用原生返回按钮在单页应用程序中进行操作。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Give yourself a pat on the back; we have finally reached the end of this chapter!
    It's been a good ride, and hopefully not too bad. At this point you are now prepared
    to tackle the development of one-page applications. From understanding the MVC
    design pattern to implementation, utilizing libraries such as Backbone and Underscore,
    you can now go and extend on this foundation by developing complex applications
    that tie into APIs and create a dynamically beautiful experience for the user.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 给自己一个鼓励吧；我们终于到达了本章的结尾！这是一次愉快的旅程，希望不会太糟糕。在这一点上，您现在已经准备好着手开发单页应用程序了。从理解MVC设计模式到实施，利用Backbone和Underscore等库，您现在可以扩展这个基础，开发与API相结合并为用户创造动态美妙体验的复杂应用程序。
