- en: Chapter 9. Principles of Clean and Optimized Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。清洁和优化代码的原则
- en: Throughout the book, we have stressed the importance of optimizing from the
    very start of our application development. Although we have looked at topics from
    caching elements in JavaScript to modularizing our styles, in this chapter we
    want to summarize the techniques used in the book. After all, performance is highly
    important in our mobile applications for several reasons. In this chapter, we
    will cover optimizing our styles, scripts, and media. In addition to covering
    optimization techniques, we'll go over good coding standards that enhance the
    maintainability of your codebase while also enhancing performance at the same
    time. We'll start out by discussing stylesheets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们都强调了从应用程序开发的最开始就进行优化的重要性。尽管我们已经从JavaScript中缓存元素到模块化我们的样式等主题，但在本章中，我们想总结一下书中使用的技术。毕竟，性能对于我们的移动应用程序来说是非常重要的。在本章中，我们将涵盖优化我们的样式、脚本和媒体。除了涵盖优化技术之外，我们还将讨论增强代码可维护性的良好编码标准，同时也提高性能。我们将从讨论样式表开始。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Validating CSS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证CSS
- en: Profiling CSS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析CSS
- en: CSS best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS最佳实践
- en: Validating JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证JavaScript
- en: Profiling JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析JavaScript
- en: JavaScript best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript最佳实践
- en: Optimizing stylesheets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化样式表
- en: Traditionally, styles have been "plopped" onto web applications without any
    forethought. Usually, we would just style our pages without any thought to modularity,
    reusability, and maintainability. However, this is no longer acceptable due to
    the extensive nature of web applications today.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，样式被“随意”地添加到Web应用程序中而没有任何预见性。通常，我们只是为我们的页面添加样式，而没有考虑模块化、可重用性和可维护性。然而，由于今天Web应用程序的广泛性质，这种做法已不再可接受。
- en: In this book, we have strived to adhere to a couple of industry standards, such
    as modularity. However, we do have tools now that can help us validate and profile
    our styles. Starting with an analysis of a sample CSS file, we can then optimize
    those styles; this is what we aim to do in this section of the chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们努力遵守了一些行业标准，比如模块化。然而，现在我们有工具可以帮助我们验证和分析我们的样式。从分析样本CSS文件开始，我们可以优化这些样式；这就是我们在本章节中的目标。
- en: Validating our CSS
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证我们的CSS
- en: In order to optimize our stylesheets, we need to first verify that our CSS is
    valid and compliant with today's standards. We can use various tools out there
    to validate our styles, including the W3C CSS Validator and a tool called **CSS
    Lint**. Both these tools check your stylesheets and give you a summary of what
    is wrong, why it is wrong, and what you should do about it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化我们的样式表，我们需要首先验证我们的CSS是否有效，并符合当今的标准。我们可以使用各种工具来验证我们的样式，包括W3C CSS验证器和一个名为**CSS
    Lint**的工具。这些工具都会检查您的样式表，并为您总结出错的地方、为什么出错以及您应该怎么做。
- en: W3C CSS Validator
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: W3C CSS验证器
- en: 'To access the W3C CSS Validator, you can visit the following URL:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问W3C CSS验证器，您可以访问以下URL：
- en: '[http://jigsaw.w3.org/css-validator/](http://jigsaw.w3.org/css-validator/)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://jigsaw.w3.org/css-validator/](http://jigsaw.w3.org/css-validator/)'
- en: The following screenshot displays the W3C validator default view, which allows
    you to enter in the URI of the page containing styles. It will automatically pick
    up your stylesheets and validate them according to the W3C specification. However,
    we are not limited only to having our page crawlable on a live or production-ready
    site. We also have the option of uploading our stylesheets, or putting them directly
    into this application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了W3C验证器的默认视图，允许您输入包含样式的页面的URI。它将根据W3C规范自动获取您的样式表并对其进行验证。然而，我们不仅仅局限于在现场或生产就绪的网站上让我们的页面可爬行。我们还可以选择上传我们的样式表，或直接将它们放入这个应用程序中。
- en: '![W3C CSS Validator](img/1024OT_09_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![W3C CSS验证器](img/1024OT_09_01.jpg)'
- en: The W3C CSS Validator – URI view
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: W3C CSS验证器-URI视图
- en: In the following view, you can see that we can validate the styles through a
    file upload process. This will simply run those stylesheets through a processor
    at the backend to check if the styles are valid; once this process is done, we
    get our results.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下视图中，您可以看到我们可以通过文件上传过程验证样式。这将简单地通过后端处理器运行这些样式表，以检查样式是否有效；一旦这个过程完成，我们就会得到结果。
- en: '![W3C CSS Validator](img/1024OT_09_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![W3C CSS验证器](img/1024OT_09_02.jpg)'
- en: The W3C CSS Validator – file upload view
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: W3C CSS验证器-文件上传视图
- en: Lastly, we have the option to directly insert our styles into the tool, perhaps
    the fastest and easiest solution depending on the project and needs of the team
    or individual. We don't have to worry about styles being stripped or modified
    in any way; the text field will handle all your input correctly. Again, similar
    to the other views, the input will run through a processor and present to you
    the results once the **Check** button is clicked.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有直接将我们的样式插入到工具中的选项，这可能是根据项目和团队或个人的需求最快速、最简单的解决方案。我们不必担心样式被剥离或以任何方式修改；文本字段将正确处理您的所有输入。与其他视图类似，一旦单击**检查**按钮，输入将通过处理器运行并向您呈现结果。
- en: '![W3C CSS Validator](img/1024OT_09_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![W3C CSS验证器](img/1024OT_09_03.jpg)'
- en: The W3C CSS Validator – direct input view
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: W3C CSS验证器-直接输入视图
- en: Customizable options
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可定制选项
- en: 'As with any good-quality assurance tool, we need to have the ability to customize
    the options of this tool to fit our needs. In this case, we have various options
    that are available to us, including:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何优质保证工具一样，我们需要有能力定制此工具的选项以适应我们的需求。在这种情况下，我们有各种可用的选项，包括：
- en: '**Profile**: This option specifies the profile to be used when validating styles,
    for example, CSS Level 1, CSS Level 2, CSS Level 3, and so on.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：此选项指定验证样式时要使用的配置文件，例如CSS Level 1、CSS Level 2、CSS Level 3等。'
- en: '**Warnings**: This option specifies the warning to be presented in the report,
    for example, Normal, Most Important, No Warnings, and so on.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**：此选项指定报告中要呈现的警告，例如Normal、Most Important、No Warnings等。'
- en: '**Medium**: This option specifies the medium the stylesheets are supposed to
    represent, for example, Screen, Print, Handheld, and so on.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**介质**：此选项指定了样式表应该表示的介质，例如屏幕、打印、手持设备等。'
- en: '**Vendor Extensions**: This option specifies the way vendor extensions (`-webkit-`,
    `-moz-`, `-o-`) are to be handled in the report, for example, Warnings or Errors.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商扩展**：此选项指定了供应商扩展（`-webkit-`、`-moz-`、`-o-`）在报告中的处理方式，例如警告或错误。'
- en: Validating a successful example
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证一个成功的例子
- en: Let's take a look at a successful validation example. First, let's use some
    styles we created in a previous chapter to see if the CSS passes validation; in
    particular, let's use the `singlepage.css` file contents and paste it into the
    direct input view of the W3C validator and run it with the default options.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个成功的验证例子。首先，让我们使用我们在之前章节中创建的一些样式来查看CSS是否通过验证；特别是，让我们使用`singlepage.css`文件的内容，并将其粘贴到W3C验证器的直接输入视图中，并使用默认选项运行它。
- en: 'When we run the validator, our result should look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行验证器时，我们的结果应该是这样的：
- en: '![Validating a successful example](img/1024OT_09_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![验证一个成功的例子](img/1024OT_09_04.jpg)'
- en: The W3C CSS Validator – successful validation
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: W3C CSS验证器 - 成功验证
- en: As you can see, the output is successful and passes the CSS Level 3 specification.
    It's so amazing that we even get badges from the validator to put on our site!
    But don't do that; even though you should give yourself a pat on the back, this
    is something that most of us don't really like on our sites. Now let's look at
    an unsuccessful example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出是成功的，并通过了CSS Level 3规范。令人惊讶的是，我们甚至可以从验证器那里得到徽章放在我们的网站上！但不要这样做；尽管您应该对自己的工作感到满意，但这是我们大多数人不太喜欢在我们的网站上看到的东西。现在让我们看一个不成功的例子。
- en: Validating an unsuccessful example
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证一个不成功的例子
- en: 'Errors happen all the time in programming, and so it''s only natural for us
    to encounter validation errors in our styling, scripts, and markup. So, let''s
    take a look at what an example of validation errors in the W3C CSS Validator looks
    like. For this example, we''ll use a variation of the `video.css` file we created
    in [Chapter 2](ch02.html "Chapter 2. Integrating HTML5 Video"), *Integrating HTML5
    Video*. For the purpose of this example, I''ve introduced several mistakes with
    the following styles:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中经常出现错误，因此在我们的样式、脚本和标记中遇到验证错误是很自然的。因此，让我们看一下W3C CSS验证器中验证错误的示例是什么样子。在这个例子中，我们将使用我们在[第2章](ch02.html
    "第2章。集成HTML5视频")中创建的`video.css`文件的变体，*集成HTML5视频*。为了这个例子，我引入了一些错误，包括以下样式：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we pass the preceding styles through the W3C CSS Validator, we get the
    following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过W3C CSS验证器传递前面的样式时，我们得到以下结果：
- en: '![Validating an unsuccessful example](img/1024OT_09_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![验证一个不成功的例子](img/1024OT_09_05.jpg)'
- en: The W3C CSS Validator – unsuccessful validaton
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: W3C CSS验证器 - 不成功的验证
- en: In the preceding example we're getting a couple of value, property, and parse
    errors, all of which can be easily solved by the references given in this unsuccessful
    validation example. What's great about this is that instead of trying to figure
    out what might be breaking your layout, a simple fix on the errors shown in the
    screenshot might solve all your problems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们得到了一些值、属性和解析错误，所有这些都可以通过此不成功的验证示例中给出的参考轻松解决。这样做的好处是，不用试图弄清楚可能破坏布局的原因，屏幕截图中显示的错误可能解决所有问题。
- en: In a sense this is basically all you need to make sure that your CSS is valid
    and compliant across several browsers. However, what if you could prevent these
    errors from happening? Well, there's a tool for that, CSS Lint.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，这基本上是您需要确保您的CSS在多个浏览器中有效和符合规范的所有内容。但是，如果您能够防止这些错误发生呢？好吧，有一个工具可以做到，那就是CSS
    Lint。
- en: CSS Lint
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS Lint
- en: In most cases, we want to avoid having errors all together when we code, and
    it would be helpful to catch these early on with a tool of some sort. CSS Lint
    is that tool, and in fact can be used right inside the text editor or IDE of your
    choice. CSS Lint not only checks your styling against certain principles of CSS
    (such as the box model), but also does a lot of the syntax checking, helping you
    debug your styles effectively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们在编码时希望尽量避免出现错误，并且使用某种工具及早捕捉这些错误将会很有帮助。CSS Lint就是这样一个工具，实际上可以直接在您选择的文本编辑器或IDE中使用。CSS
    Lint不仅检查您的样式是否符合CSS的某些原则（如盒模型），还进行了大量的语法检查，帮助您有效地调试样式。
- en: CSS Lint points out problems with your CSS code. It does basic syntax checking
    as well as applying a set of rules to the code that look for problematic patterns
    or signs of inefficiency. The rules are all pluggable, so you can easily write
    your own or omit ones you don't want.
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CSS Lint指出了CSS代码的问题。它进行基本的语法检查，并应用一组规则来查找问题模式或低效迹象。这些规则都是可插拔的，因此您可以轻松编写自己的规则或省略您不想要的规则。
- en: The details regarding CSS Lint can be found at [https://github.com/stubbornella/csslint/wiki/About](https://github.com/stubbornella/csslint/wiki/About).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CSS Lint的详细信息可以在[https://github.com/stubbornella/csslint/wiki/About](https://github.com/stubbornella/csslint/wiki/About)找到。
- en: 'Similar to the W3C CSS Validator, CSS Lint has its own site where you can copy
    and paste your styles into a text area and have the processor checkout your styling.
    The page in which we interact with looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与W3C CSS验证器类似，CSS Lint有自己的网站，您可以将样式复制粘贴到文本区域中，让处理器检查您的样式。我们与之交互的页面如下所示：
- en: '![CSS Lint](img/1024OT_09_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![CSS Lint](img/1024OT_09_06.jpg)'
- en: CSS Lint
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Lint
- en: Customizable options
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可定制选项
- en: CSS Lint also comes with customizable options, which are extensive, that you
    can customize to fit you or your team's needs. There are six sections of customizable
    options, including **Errors**, **Maintainability & Duplication**, **Compatibility**,
    **Accessibility**, **Performance**, and **OOCSS** (**Object Oriented CSS**).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Lint还带有可定制的选项，这些选项非常广泛，您可以根据自己或团队的需要进行定制。可定制选项有六个部分，包括**错误**、**可维护性和重复性**、**兼容性**、**可访问性**、**性能**和**OOCSS**（**面向对象的CSS**）。
- en: 'The customizable options are located right below the **Lint!** button:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可定制的选项位于**Lint!**按钮的正下方：
- en: '![Customizable options](img/1024OT_09_07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![可定制的选项](img/1024OT_09_07.jpg)'
- en: CSS Lint options
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Lint选项
- en: Checking the appropriate options enables the engine to validate against those
    properties. Usually these options vary between projects; for example, you may
    be working on an application that requires padding and width to be set on certain
    elements and thus, unchecking the **Beware of broken box sizing** option may be
    more suitable for you, so that you are not presented with multiple errors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 检查适当的选项使引擎能够根据这些属性进行验证。通常这些选项在项目之间会有所不同；例如，您可能正在开发一个需要在某些元素上设置填充和宽度的应用程序，因此，取消选中**注意破碎的框尺寸**选项可能更适合您，这样您就不会看到多个错误。
- en: Validating a successful example using CSS Lint
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用CSS Lint验证成功的示例
- en: 'When we customize our options and pass the page through CSS Lint with proper
    stylesheets that meet standards while also catering to the team''s needs, we should
    receive a successful validation, such as the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们自定义选项并通过CSS Lint传递页面时，如果样式表符合标准，同时也满足团队的需求，我们应该收到一个成功的验证，如下面的截图所示：
- en: '![Validating a successful example using CSS Lint](img/1024OT_09_08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS Lint验证成功示例](img/1024OT_09_08.jpg)'
- en: CSS Lint – successful validation
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Lint – 成功的验证
- en: In the above case, our CSS styles pass and no additional information is needed.
    However, what happens when our CSS does not pass validation?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，我们的CSS样式通过了，不需要额外的信息。但是，当我们的CSS未通过验证时会发生什么呢？
- en: Validating an unsuccessful example using CSS Lint
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用CSS Lint验证不成功的示例
- en: 'If we take the alternative video styles we created in the previous section
    for the W3C CSS Validator and pass them through CSS Lint, we get the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将在上一节中为W3C CSS验证器创建的备用视频样式通过CSS Lint，我们会得到以下结果：
- en: '![Validating an unsuccessful example using CSS Lint](img/1024OT_09_09.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS Lint验证不成功的示例](img/1024OT_09_09.jpg)'
- en: CSS Lint – unsuccessful validation
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Lint – 未成功的验证
- en: 'However, just because we received four errors and two warnings does not mean
    we are helpless. In fact, when we scroll down the page, we will see a list of
    items that need to be taken care of; it also includes the type of problem, description,
    and line that the error occurs on:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅因为我们收到了四个错误和两个警告并不意味着我们无助。事实上，当我们向下滚动页面时，我们会看到需要处理的项目列表；它还包括问题类型，描述以及错误发生的行：
- en: '![Validating an unsuccessful example using CSS Lint](img/1024OT_09_10.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS Lint验证不成功的示例](img/1024OT_09_10.jpg)'
- en: CSS Lint – unsuccessful validation listing
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Lint – 未成功的验证列表
- en: Integrating CSS Lint
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集成CSS Lint
- en: Although we have a **graphical user interface** (**GUI**) that we can use to
    validate our styles, it would be easier if we could streamline the process with
    our personal development workflow. For example, it would be great if our CSS could
    be validated as we saved our stylesheet in our text editor or **integrated development
    environment** (**IDE**). CSS Lint is very extensible, allowing us to achieve these
    integrated workflows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有一个可以用来验证我们的样式的**图形用户界面**（**GUI**），但如果我们能够简化我们的个人开发工作流程，那将会更容易。例如，如果我们可以在文本编辑器或**集成开发环境**（**IDE**）中保存样式表时验证我们的CSS，那将会很好。CSS
    Lint非常灵活，允许我们实现这些集成的工作流程。
- en: 'Some IDEs and text editor vendors have already implemented CSS Lint, including
    Sublime Text, Cloud 9, Microsoft Visual Studio, and Eclipse Orion. Although the
    installation and setup of CSS Lint into your preferred tool is out of the scope
    of this book, you can look up all the information needed here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些集成开发环境和文本编辑器供应商已经实现了CSS Lint，包括Sublime Text，Cloud 9，Microsoft Visual Studio和Eclipse
    Orion。虽然将CSS Lint安装和设置到您喜欢的工具中超出了本书的范围，但您可以在这里查找所有所需的信息：
- en: '[https://github.com/stubbornella/csslint/wiki/IDE-integration](https://github.com/stubbornella/csslint/wiki/IDE-integration)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/stubbornella/csslint/wiki/IDE-integration](https://github.com/stubbornella/csslint/wiki/IDE-integration)'
- en: Profiling our CSS
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析我们的CSS
- en: Previously it was extremely difficult to profile any of your CSS, in fact probably
    impossible. But with the advancements that have taken place in browser debugging
    tools, we are now able to profile stylesheets to some degree. In this section,
    we review how to take profiles of our styles and read the information presented
    to us in the Safari browser on Mac.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以前很难对CSS进行分析，事实上可能是不可能的。但是随着浏览器调试工具的进步，我们现在能够在一定程度上对样式表进行分析。在本节中，我们将回顾如何对我们的样式进行分析，并阅读Safari浏览器在Mac上向我们呈现的信息。
- en: In the upcoming screens, we will briefly go over how profiling can be used for
    styles and how the Safari browser presents this information to us. We will only
    look at layout and rendering of our styles. Using the single-page application
    we built previously, we will look at the effectiveness of our styles and see the
    weaknesses and strengths of our styling in how it relates to the presentation
    layer of our application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的屏幕中，我们将简要介绍如何使用分析来分析样式以及Safari浏览器如何向我们呈现这些信息。我们只会查看我们的样式的布局和渲染。使用我们之前构建的单页面应用程序，我们将查看我们的样式的有效性，并查看我们的样式在与应用程序的呈现层相关的方面的弱点和优势。
- en: Let's begin by looking at the dashboard view of our single-page application
    with the Safari debugging tools opened and on the profile tab (clock symbol).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看我们的单页面应用程序的仪表板视图开始，Safari调试工具已打开，并处于配置文件选项卡（时钟符号）上。
- en: '![Profiling our CSS](img/1024OT_09_16.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![分析我们的CSS](img/1024OT_09_16.jpg)'
- en: Safari profiling tool
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Safari分析工具
- en: When we first load up our single-page application and view the profiling of
    the page load, we see three different timelines, including **Network requests**,
    **Layout & Rendering**, and **JavaScript & Events**. For our purposes, let's look
    at **Layout & Rendering**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次加载我们的单页面应用程序并查看页面加载的分析时，我们会看到三个不同的时间轴，包括**网络请求**，**布局和渲染**和**JavaScript和事件**。对于我们的目的，让我们看看**布局和渲染**。
- en: When we look at the **Layout & Rendering** timeline, we can see where repaints
    and restyle calculations were made on page load. The debugger also lets us know
    what type of process was run, when it was run, and the properties that were changed,
    including its start time and duration. This is all extremely helpful when looking
    for performance leaks on our page. But, what about runtime profiling? Well, the
    debugger has that to.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看**布局和渲染**时间轴时，我们可以看到重绘和重排计算是在页面加载时进行的。调试器还让我们知道运行了什么类型的进程，何时运行以及更改了哪些属性，包括其开始时间和持续时间。在寻找页面性能泄漏时，这些都非常有帮助。但是，运行时分析呢？嗯，调试器也有这个功能。
- en: 'In fact, in our left-hand side bar there is a circle on the same line as the
    **Profiles** tab that allows us to profile either our JavaScript or CSS. This
    is great because when we enable this, we''ll start profiling the application at
    run time. So, let''s say we enable the profiling of our CSS and then, within our
    application, click on the **Profile** tab to switch page views; we''ll definitely
    execute some changes in the view that would make our styles change. When we do
    this and stop our CSS profiling, we get the following results:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在我们的左侧边栏上有一个圆圈，与**Profiles**选项卡在同一行，它允许我们对JavaScript或CSS进行分析。这很棒，因为当我们启用它时，我们将开始对应用程序进行运行时分析。因此，假设我们启用了对CSS的分析，然后在应用程序中点击**Profile**选项卡以切换页面视图；我们肯定会执行一些更改，使我们的样式发生变化。当我们这样做并停止我们的CSS分析时，我们会得到以下结果：
- en: '![Profiling our CSS](img/1024OT_09_17.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![分析我们的CSS](img/1024OT_09_17.jpg)'
- en: Safari profiling tool – runtime profiling
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Safari分析工具-运行时分析
- en: When we analyze our profile we see the selectors that are being utilized, the
    total time for it to render, the number of matches on the page, and its source.
    This is a great breakdown of what sort of processing took place and gives us a
    good idea of the amount of time each selector takes to find and render, giving
    us a good idea of what can be improved. Given, our application for this book is
    small, but if you were working on an application that included complex animations
    or the rendering of thousands of rows of data, this would come in useful in debugging
    your mobile application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分析我们的分析时，我们可以看到正在使用的选择器，它们渲染的总时间，页面上的匹配数以及它们的来源。这是对发生了什么样的处理进行了很好的分解，并让我们对每个选择器查找和渲染所花费的时间有了一个很好的概念，从而让我们知道可以改进什么。鉴于我们为本书的应用程序很小，但如果你正在开发一个包括复杂动画或渲染数千行数据的应用程序，这将在调试您的移动应用程序时非常有用。
- en: Once we have a good idea of what is bottlenecking our application, we need to
    do something about it. Having this information gives us critical information on
    the performance of our application and what we should focus on. The optimization
    phase is based on the problem(s) and needs of the project each team or individual
    faces, so in the next section we discuss some optimization techniques that can
    be used for faster rendering and matching of our styles.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对我们的应用程序的瓶颈有了一个很好的想法，我们就需要采取一些行动。拥有这些信息为我们提供了关于应用程序性能的关键信息以及我们应该关注的内容。优化阶段是基于每个团队或个人面临的问题和项目需求的，因此在下一节中，我们将讨论一些用于更快渲染和匹配我们样式的优化技术。
- en: Optimizing our CSS
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化我们的CSS
- en: In this section, we briefly go over some industry standards that help us optimize
    our applications rendering time by providing modular styles that are efficient,
    maintainable, and well crafted. These standards have been widely discussed by
    individuals and organizations well known in the industry and have ultimately been
    adopted in various frameworks. Of course, the standards discussed here may change
    as time progresses and browsers implement better processing methods that make
    new techniques faster and more efficient, but this should be a good starting guide
    for anyone looking to create stylesheets that meet today's demands.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们简要介绍了一些行业标准，这些标准通过提供高效、可维护和精心制作的模块化样式来帮助我们优化应用程序的渲染时间。这些标准已经被业内知名的个人和组织广泛讨论，并最终被各种框架采纳。当然，这里讨论的标准可能随着时间的推移和浏览器实现更好的处理方法而发生变化，使新技术更快、更高效，但这应该是任何希望创建符合当今需求的样式表的人的良好起点指南。
- en: Avoid universal rules
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免通用规则
- en: Do not use the `*` selector in your rules. These select every element in the
    DOM and thus their traversal method is inefficient.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在规则中使用`*`选择器。这会选择DOM中的每个元素，因此它们的遍历方法是低效的。
- en: 'For example, the following is extremely inefficient:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是极其低效的：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code is inefficient for one reason, it is using a universal selector.
    Because CSS reads from right to left, the engine is saying "let''s pick up all
    elements and then see if they are immediately related to the header element."
    Because we need to traverse the entire DOM, the rendering of this selector is
    extremely slower than something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码之所以效率低，是因为它使用了通用选择器。因为CSS是从右到左读取的，引擎会说“让我们选择所有元素，然后看它们是否与标题元素直接相关”。因为我们需要遍历整个DOM，所以这个选择器的渲染比像这样的东西要慢得多：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don't qualify ID or Class rules
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要限定ID或类规则
- en: Qualifying an ID or Class involves directly attaching the tag name with the
    appropriate selector, but is extremely inefficient for the same reasons as the
    previous rule.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 限定ID或类涉及直接将标签名称与适当的选择器相结合，但出于与前一条规则相同的原因，这是极其低效的。
- en: 'For example, all of the following selectors are bad:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下所有选择器都是不好的：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although some of these may seem tempting, they are unnecessary and inefficient.
    However, there is an exception here; if we want to change the style by adding
    a class to an element, then qualifying a class might be necessary. Either way,
    we could do the following to correct the preceding qualifying ID or classes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其中一些可能看起来很诱人，但它们是不必要和低效的。但是，这里有一个例外；如果我们想通过向元素添加类来更改样式，那么限定类可能是必要的。无论如何，我们可以通过以下方式来纠正前面的限定ID或类。
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As it was mentioned in the preceding paragraph, the last selector might be more
    useful when changing the styles of an element based on a user action via JavaScript.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一段提到的，最后一个选择器在通过JavaScript基于用户操作更改元素样式时可能更有用。
- en: Never use !important
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 永远不要使用!important
- en: This rule is pretty self-explanatory. It is definitely tempting to use this
    to override styles, but don't; it will only cause headaches as your application(s)
    become more extensive. For this reason, check out the next rule.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则相当不言自明。使用它来覆盖样式肯定很诱人，但不要这样做；随着您的应用程序变得更加复杂，这只会带来麻烦。因此，请查看下一条规则。
- en: Modularize styles
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化样式
- en: 'It''s very easy to create styles that are generic to a web application or website;
    however, if we start thinking in terms of modularity, we start creating styles
    that are reserved for a part of that application. For example, take a form and
    its inputs, and let''s say we wanted all forms on a site to contain text fields
    with a brown border. We could do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建通用于Web应用程序或网站的样式非常容易；然而，如果我们开始以模块化的方式思考，我们就会开始创建专门用于该应用程序部分的样式。例如，考虑一个表单及其输入，假设我们希望网站上的所有表单都包含具有棕色边框的文本字段。我们可以这样做：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have reserved all fields with the class `.text-field` inside a `form`
    element to contain this style. So if any input fields with the class `.text-field`
    are outside this selector, we can then style them any way we want. Or on the other
    hand we could override the style like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有包含在`form`元素内的类为`.text-field`的字段保留为这种样式。因此，如果任何类为`.text-field`的输入字段在此选择器之外，我们可以按照自己的方式进行样式设置。或者，我们也可以这样覆盖样式：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if we include this style after the original one, it would take precedence
    because we are actually using cascading principles that make our styling more
    efficient and manageable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在原始样式之后包含这个样式，它将优先使用，因为我们实际上使用了使我们的样式更高效和更易管理的级联原则。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that descendant selectors are the most expensive kind of selector.
    However they are extremely versatile, and therefore we should not sacrifice maintainability
    or semantics for efficient CSS.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，后代选择器是最昂贵的选择器。然而，它们非常灵活，因此我们不应该为了高效的CSS而牺牲可维护性或语义。
- en: In most cases, these rules should be enough, but you will most likely find it
    useful to implement some of the other best practices that have been written about
    in the industry. Of course, you should work with the practices that have been
    adopted for the framework you use, or better yet, fit your team. I have found
    these to be extremely helpful and a great starting point, and I encourage you
    to research and experiment as you see fit. Now, let's take a look at how JavaScript
    could be optimized for our applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这些规则应该足够了，但您很可能会发现实施一些其他行业中已经写过的最佳实践是有用的。当然，您应该使用您所使用的框架采用的最佳实践，或者更好的是适合您的团队。我发现这些对我非常有帮助，是一个很好的起点，我鼓励您根据需要进行研究和实验。现在，让我们看看如何优化我们的应用的JavaScript。
- en: Optimizing JavaScript
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化JavaScript
- en: Now that we have covered the optimization of stylesheets, let's look at our
    scripts. JavaScript has also had a history of being dropped onto the page without
    any forethought or planning, and in general has led to bad reputation for the
    language. But again, because of the complex nature of web applications, the open
    source community has helped shape the language.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了样式表的优化，让我们看看我们的脚本。JavaScript也曾经被毫无考虑或计划地放在页面上，总的来说给这门语言带来了不好的声誉。但是，由于Web应用程序的复杂性，开源社区已经帮助塑造了这门语言。
- en: Throughout the book, we have adopted several industry standards, including namespaces,
    closures, caching variables, and so on. However, it is also essential we validate
    and profile our scripts so they can be optimized. In this section, we will go
    through this and hopefully cover the major points needed to make high-performance
    mobile applications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们采用了几个行业标准，包括命名空间、闭包、缓存变量等。然而，验证和分析我们的脚本也是必不可少的，以便进行优化。在本节中，我们将介绍这一点，并希望涵盖制作高性能移动应用所需的主要要点。
- en: Validating JavaScript using JSLint
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSLint验证JavaScript
- en: 'In recent years, various tools have come out to help us validate our JavaScript.
    Tools such as JSLint and JSHint have been created to help us as we code, similar
    to CSS Lint. But why should we use these tools, especially for JavaScript? JSLint''s
    site ([http://www.jslint.com/lint.html](http://www.jslint.com/lint.html)) mentions
    the reasoning behind the tool:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，出现了各种工具来帮助我们验证JavaScript。诸如JSLint和JSHint之类的工具已经被创建，以帮助我们编码，类似于CSS Lint。但为什么我们应该使用这些工具，特别是对于JavaScript呢？JSLint的网站（[http://www.jslint.com/lint.html](http://www.jslint.com/lint.html)）提到了工具背后的原因：
- en: 'JavaScript is a young-for-its-age language. It was originally intended to do
    small tasks in webpages, tasks for which Java was too heavy and clumsy. But JavaScript
    is a surprisingly capable language, and it is now being used in larger projects.
    Many of the features that were intended to make the language easy to use are troublesome
    when projects become complicated. A lint for JavaScript is needed: JSLint, a JavaScript
    syntax checker and validator.'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JavaScript是一种年轻但成熟的语言。最初，它是用来在网页中执行一些小任务的，这些任务对于Java来说太笨重、太笨拙了。但JavaScript是一种令人惊讶的功能强大的语言，现在它也被用于更大的项目中。许多旨在使语言易于使用的功能在项目变得复杂时会带来麻烦。JavaScript需要一个语法检查器和验证器：JSLint。
- en: 'JSLint''s website also mentions the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JSLint的网站还提到了以下内容：
- en: JavaScript is a sloppy language, but inside it there is an elegant, better language.
    JSLint helps you to program in that better language and to avoid most of the slop.
    JSLint will reject programs that browsers will accept because JSLint is concerned
    with the quality of your code and browsers are not. You should accept all of JSLint's
    advice.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JavaScript是一种松散的语言，但在其中有一种更优雅、更好的语言。JSLint可以帮助您使用更好的语言进行编程，并避免大部分松散。JSLint会拒绝浏览器会接受的程序，因为JSLint关心您的代码质量，而浏览器不关心。您应该接受JSLint的所有建议。
- en: 'To test out our JavaScript, we can easily visit JSLint''s website ([http://www.jslint.com/](http://www.jslint.com/)):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的JavaScript，我们可以轻松访问JSLint的网站（[http://www.jslint.com/](http://www.jslint.com/)）：
- en: '![Validating JavaScript using JSLint](img/1024OT_09_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用JSLint验证JavaScript](img/1024OT_09_11.jpg)'
- en: The JSLint website
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: JSLint网站
- en: As you can see, JSLint is very similar to CSS Lint, in such a way that all you
    really need to do is input your JavaScript onto the page and the results will
    be displayed to you. So let's check out what a successful and an unsuccessful
    output would look like.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，JSLint与CSS Lint非常相似，您只需要将JavaScript输入到页面上，结果就会显示出来。让我们看看成功和失败的输出会是什么样子。
- en: Validating a successful example using JSLint
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JSLint验证成功的例子
- en: 'In our example, we will utilize our `App.js` JavaScript to test out with the
    JSLint utility. When we run this file, a successful output will detail out the
    methods, variables, and properties used throughout the closure. Let''s look at
    the following screenshots:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将利用我们的`App.js` JavaScript来测试JSLint实用程序。当我们运行这个文件时，成功的输出将详细列出闭包中使用的方法、变量和属性。让我们看看以下截图：
- en: '![Validating a successful example using JSLint](img/1024OT_09_12.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用JSLint验证成功的例子](img/1024OT_09_12.jpg)'
- en: Successful validation using JSLint – methods and variables
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSLint进行成功验证 - 方法和变量
- en: The preceding example is the top view of a successful validation using JSLint.
    The validator will return to us a list beginning with a listing of all global
    objects. It will then continue on with a listing of the methods, variables, and
    some detail about each. For example, `initVideo` returns `this` or an instance
    of `App` and so on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是使用JSLint进行成功验证的顶视图。验证器将返回一个以所有全局对象列表开头的列表。然后它将继续列出方法、变量以及每个的一些细节。例如，`initVideo`返回`this`或`App`的一个实例等等。
- en: '![Validating a successful example using JSLint](img/1024OT_09_13.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![使用JSLint验证成功的例子](img/1024OT_09_13.jpg)'
- en: Successful validation using JSLint – properties
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSLint进行成功验证 - 属性
- en: Validating an unsuccessful example
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证失败的例子
- en: Taking the same example as the previous one without modifying the JSLint options
    would produce several errors. These errors are mostly whitespace, spacing, and
    global objects that the processor is not aware of.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不修改JSLint选项，使用与前一个相同的例子将产生多个错误。这些错误主要是空格、间距和处理器不知道的全局对象。
- en: '![Validating an unsuccessful example](img/1024OT_09_14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![验证失败的例子](img/1024OT_09_14.jpg)'
- en: JSLint – unsuccessful validation
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JSLint - 验证失败
- en: Based on the preceding output, the errors are listed in red with a description,
    sample code, and line number of where the error occurs, allowing you to easily
    debug your application. Now, let's say we didn't want whitespace or spacing to
    actually affect the outcome of our validation; then we could customize the options
    for JSLint.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的输出，错误以红色列出，包括描述、示例代码和错误发生的行号，让您轻松调试应用程序。现在，假设我们不希望空格或间距实际影响验证结果；那么我们可以定制JSLint的选项。
- en: Customizable options
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可定制选项
- en: As with most of the tools we are discussing in this chapter, JSLint also comes
    packaged with options that can be customized to fit our needs. Let's briefly review
    some of the options that are available to us via the website.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章讨论的大多数工具一样，JSLint也提供了可以根据我们的需求定制的选项。让我们简要回顾一下网站上提供给我们的一些选项。
- en: '![Customizable options](img/1024OT_09_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![可定制选项](img/1024OT_09_15.jpg)'
- en: JSLint – the Options screen
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: JSLint - 选项屏幕
- en: The options that are available to us are extensive, from whitespace formatting
    to the correctness of the toleration of `TODO` comments that we all put in our
    JavaScript. Of course, some of these options may not fit our needs at the time
    of testing, but in general, they are very helpful in keeping with a consistent
    coding standard that delivers cross-platform valid scripts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们可用的选项非常广泛，从空格格式到对我们所有放在JavaScript中的`TODO`注释的正确性的容忍。当然，其中一些选项可能在测试时不符合我们的需求，但总的来说，它们非常有助于保持一致的编码标准，提供跨平台有效的脚本。
- en: Integrating JSLint
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成JSLint
- en: Similar to CSS Lint, JSLint can be used in your IDE or text editor—whichever
    environment you prefer. Many vendors have already created plugins or extensions
    to these tools to allow you to easily lint your code as you type or save. For
    example, Sublime Text has a `SublimeLinter` package that comes with CSS Lint,
    JSLint, and also some other tools that can help you code more efficiently. How
    is this possible?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS Lint类似，JSLint可以在您喜欢的IDE或文本编辑器中使用。许多供应商已经创建了插件或扩展工具，使您可以在输入或保存代码时轻松进行代码检查。例如，Sublime
    Text有一个`SublimeLinter`包，其中包括CSS Lint、JSLint以及其他一些可以帮助您更高效编码的工具。这是如何可能的？
- en: '*JSLint can be run anywhere that JavaScript (or Java) can run. See for example*
    [https://github.com/douglascrockford/JSLint/wiki/JSLINT](https://github.com/douglascrockford/JSLint/wiki/JSLINT).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSLint可以在任何可以运行JavaScript（或Java）的地方运行。例如* [https://github.com/douglascrockford/JSLint/wiki/JSLINT](https://github.com/douglascrockford/JSLint/wiki/JSLINT)。'
- en: 'Refer to the following for more details:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参考以下内容：
- en: '[https://github.com/douglascrockford/JSLint](https://github.com/douglascrockford/JSLint)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/douglascrockford/JSLint](https://github.com/douglascrockford/JSLint)'
- en: In its essence, JSLint is a JavaScript method that can be passed in code and
    is then evaluated by JavaScript itself, making it extremely efficient to process
    your code and to integrate into other environments. So if it doesn't already exist
    for your text editor or IDE, you can easily create an extension that helps you
    code with quality using JSLint.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JSLint本质上是一个JavaScript方法，可以传入代码，然后由JavaScript本身进行评估，使其非常高效地处理您的代码并集成到其他环境中。因此，如果您的文本编辑器或IDE中还没有它，您可以轻松创建一个扩展，帮助您使用JSLint编写高质量的代码。
- en: Profiling our JavaScript
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对我们的JavaScript进行分析
- en: As with CSS profiling, testing the performance of your JavaScript was extremely
    hard in the old days of the Web. However, we don't really need to worry about
    it too much these days, since almost every browser debugger has implemented a
    way to profile your scripts. Using Safari's built-in debugging tool, we'll check
    out how to debug our application's script performance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS性能分析一样，在Web的旧时代，测试JavaScript的性能是非常困难的。然而，这些天我们不需要太担心这个问题，因为几乎每个浏览器调试器都实现了一种对脚本进行性能分析的方法。使用Safari内置的调试工具，我们将了解如何调试我们应用程序的脚本性能。
- en: In the following examples, we will just go over the profiling of the JavaScript
    on the single-page application we built previously, similar to what we did for
    the profiling of our styles in the previous section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将仅仅讨论我们之前构建的单页面应用程序中JavaScript的性能分析，类似于我们在上一节中对样式进行性能分析的做法。
- en: '![Profiling our JavaScript](img/1024OT_09_18.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![对我们的JavaScript进行性能分析](img/1024OT_09_18.jpg)'
- en: Safari profiling tool – JavaScript
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Safari性能分析工具- JavaScript
- en: The preceding screenshot is a review of the scripts on page load. When we review
    the **JavaScript & Events** timeline, we are given a breakdown of the type, details,
    location, start time, and duration of each script, contributing to the scripts
    timeline outcome. Although the start time is something which we definitely want
    to know in order to see what might be blocking scripts (other scripts), duration
    is probably even more important because each script can block the process of page
    rendering if it is not brought in asynchronously.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图是页面加载时脚本的回顾。当我们查看“JavaScript & Events”时间轴时，我们可以得到每个脚本的类型、细节、位置、开始时间和持续时间的详细信息，这些都对脚本时间轴的结果有所贡献。虽然开始时间是我们肯定想要知道的，以便查看可能阻塞脚本（其他脚本），但持续时间可能更重要，因为如果每个脚本不是异步加载的话，它们可能会阻塞页面渲染的过程。
- en: On top of viewing the performance of the page-load impact from scripts, we can
    also profile the functionality that our scripts perform. For example, let's say
    we wanted to detect how our methods are performing when we click on the **Profile**
    button within our application. Well this can be easily accomplished using the
    same technique as profiling your CSS, by clicking the circle in the **Profile**
    tab and enabling profiling for our JavaScript; we will be able to see all the
    methods called and their performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看脚本对页面加载的影响之外，我们还可以对脚本执行的功能进行性能分析。例如，假设我们想要检测当我们在应用程序中点击“Profile”按钮时我们的方法的执行情况。这可以很容易地通过与对CSS进行性能分析相同的技术来实现，点击“Profile”选项卡中的圆圈并启用JavaScript的性能分析；我们将能够看到所有调用的方法及其性能。
- en: '![Profiling our JavaScript](img/1024OT_09_19.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![对我们的JavaScript进行性能分析](img/1024OT_09_19.jpg)'
- en: Safari profiling tool – JavaScript runtime
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Safari性能分析工具- JavaScript运行时
- en: Based on our preceding use case, we can detail out the performance of our application
    pretty easily. From what we can gather in this example, our `onProfileClick` event
    takes about 8.40 ms to execute, and is called once. However, the larger picture
    is that we can see all the methods being called and the order of this execution—great
    information that can be used to help detect memory leaks and performance optimization
    that is necessary for our application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的用例，我们可以很容易地详细了解我们应用程序的性能。从这个例子中我们可以得知，我们的`onProfileClick`事件大约需要8.40毫秒来执行，并且只调用了一次。然而，更重要的是，我们可以看到所有被调用的方法以及执行顺序，这是非常有用的信息，可以帮助我们检测内存泄漏和性能优化，这对我们的应用程序是必要的。
- en: You can see from these very basic examples that debugging our application for
    performance is easier than ever before. We can profile our JavaScript, find out
    how our application is working, and the efficiency of our code. But now that we
    have this information, what can we do to improve our codebase? Well this is what
    we tackle in the next section, general optimization tips that we can all use to
    make our application perform better without sacrificing code quality.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些非常基本的示例中，我们可以看到调试我们的应用程序性能比以往任何时候都更容易。我们可以对JavaScript进行性能分析，了解我们的应用程序的运行情况和代码的效率。但是既然我们有了这些信息，我们可以做些什么来改进我们的代码库呢？这就是我们在下一节要解决的问题，一些通用的优化技巧，我们都可以使用这些技巧来提高我们的应用程序的性能，而不会牺牲代码质量。
- en: Optimizing our JavaScript
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化我们的JavaScript
- en: JavaScript is highly extensible, allowing us to do almost anything we want—which
    is great, but can also be extremely harmful. For example, you can easily forget
    about using the keyword `var` in front of your variables. However, we don't want
    to do this because it will make our variables available at the global scope, which
    may cause conflicts with other scripts that might use that exact same variable
    name. We can also easily wrap our JavaScript in a `try...catch` statement, not
    exactly the best practice because we're not figuring out what the problem is.
    Or if we wanted to, we could `eval` or evaluate a string of JavaScript pretty
    easily without any error checking.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是高度可扩展的，允许我们几乎做任何我们想做的事情-这很棒，但也可能非常有害。例如，你可以很容易地忘记在变量前使用关键字`var`。然而，我们不希望这样做，因为这会使我们的变量在全局范围内可用，这可能会与其他脚本发生冲突，这些脚本可能使用完全相同的变量名。我们也可以很容易地将我们的JavaScript包装在`try...catch`语句中，这并不是最佳实践，因为我们并没有找出问题所在。或者，如果我们想的话，我们可以很容易地使用`eval`来评估一串JavaScript，而不进行任何错误检查。
- en: For this reason, the industry has adopted multiple best practices that are true
    and tested, implemented by the most used open source libraries out there, including
    jQuery, Backbone, and Underscore. In this section, we briefly go over the practices
    I have based the book on and those I believe are critical to the success of any
    application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该行业已经采用了多种经过验证的最佳实践，这些最佳实践由最常用的开源库实施，包括jQuery、Backbone和Underscore。在本节中，我们简要介绍了我所基于的书籍的最佳实践，以及我认为对任何应用程序的成功至关重要的最佳实践。
- en: Avoid globals
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免全局变量
- en: It is extremely easy and tempting to create all your variables and functions
    in the global scope, or outside of the closures we created in our applications.
    But don't do that; it's a terrible idea and looked down upon in the community
    for several reasons. For example, if a variable is kept in the global scope, it
    must be maintained during the entire execution of your application, decreasing
    the performance of your application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局范围内或在我们应用程序中创建的闭包之外创建所有变量和函数非常容易且诱人。但不要这样做；这是一个糟糕的想法，并且因为几个原因而受到社区的鄙视。例如，如果一个变量保留在全局范围内，它必须在整个应用程序的执行过程中进行维护，从而降低应用程序的性能。
- en: 'So instead of doing this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，而不是这样做：
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should be doing this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该这样做：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding technique is very similar to what we have been doing all along.
    In fact, this is what we called closures or **immediately invoked function expression**
    (**IIFE**). When we wrap a method inside the parenthesis and then invoke it using
    `()`, we are calling that method immediately and creating a new containing scope,
    so anything inside those parenthesis is not available at the global scope, making
    our code a bit more manageable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的技术与我们一直在做的非常相似。实际上，这就是我们所谓的闭包或**立即调用的函数表达式**（**IIFE**）。当我们将一个方法包装在括号内，然后使用`()`调用它时，我们立即调用该方法并创建一个新的包含范围，因此括号内的任何内容在全局范围内不可用，使我们的代码更易管理。
- en: Leave the DOM alone
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要触及DOM
- en: Well, we probably won't be doing that, but we should definitely keep it to a
    minimum. Accessing the DOM is expensive and is an issue when it comes to application
    performance. So let's take a use case, such as updating a list of information.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们可能不会这样做，但我们肯定应该尽量减少。访问DOM是昂贵的，并且在应用程序性能方面存在问题。因此，让我们来看一个用例，比如更新信息列表。
- en: 'Avoid doing this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这样做：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead, you should do this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该这样做：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The difference between the two is that the former touches the DOM each time
    we create a list item, while the latter pushes each item to an array, and when
    it comes to appending, joins the array with an empty string, touching the DOM
    only once.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的区别在于前者每次创建列表项时都会触及DOM，而后者会将每个项目推到一个数组中，当涉及到追加时，将数组与空字符串连接，只触及DOM一次。
- en: Use literals
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用文字
- en: 'This can be seen throughout our entire codebase for this book. This is more
    efficient since we don''t use the `new` keyword. For example, instead of declaring
    a new variable via the new keyword, we just use the `Array` literal, like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在我们整本书的代码库中看到。这更有效，因为我们不使用`new`关键字。例如，我们可以使用`Array`文字，而不是通过新关键字声明一个新变量，就像这样：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Modularize functionality
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化功能
- en: To keep code modular, you want to make sure that each function or class has
    a specific set of functionality it is supposed to achieve. Most of the time, each
    function should probably be about 10 to 15 lines of code that achieves a certain
    goal.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码的模块化，您需要确保每个函数或类都有特定的功能集合。大多数情况下，每个函数可能应该是大约10到15行代码，实现特定的目标。
- en: 'For example, you may write the following bit of functionality:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以编写以下功能：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead of writing the preceding code, we can do this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写前面的代码，我们可以这样做：
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the code has been modularized to do specific sets of functionality,
    allowing us to create methods that run a specific set of instructions that each
    method, by name, describes. This is great for maintaining our codebase while delivering
    effective functionality.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，代码已经模块化，以执行特定的功能集，使我们能够创建运行特定指令集的方法，每个方法都以名称描述。这对于维护我们的代码库并提供有效的功能非常有用。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have considered performance optimization for various parts
    of our applications, including styles, scripts, and media. We went over validating,
    optimizing, and profiling our styles and scripts. In addition, we briefly covered
    how we can optimize our media, including images, audio, and video. Now that we
    have firm understanding of the techniques used throughout the book to optimize
    our applications, in the next chapter, we will take a look at frameworks that
    can help us deliver native applications using HTML5, CSS3, and JavaScript.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们考虑了优化应用程序各个部分的性能，包括样式、脚本和媒体。我们讨论了验证、优化和分析我们的样式和脚本。此外，我们简要介绍了如何优化我们的媒体，包括图像、音频和视频。现在我们对本书中用于优化应用程序的技术有了坚实的理解，下一章中，我们将看看可以帮助我们使用HTML5、CSS3和JavaScript交付原生应用程序的框架。
