- en: Chapter 1. The Task at Hand
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。手头的任务
- en: '"I long to accomplish a great and noble task, but it is my chief duty to accomplish
    small tasks as if they were great and noble."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我渴望完成一项伟大而崇高的任务，但我的首要任务是完成小任务，就像它们是伟大而崇高的一样。”
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: – Helen Keller
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- 海伦·凯勒'
- en: '*In this first chapter we will learn the basics of creating an HTML5 application.
    We will create an application template to be used as a starting point for building
    new applications quickly and with minimal effort. Then, we''ll use that template
    to create a simple tasklist application. Along the way we will discover how to
    interact with the user and manipulate the application''s user interface. We will
    also learn about our first new HTML5 feature, the Web Storage API.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将学习创建HTML5应用程序的基础知识。我们将创建一个应用程序模板，用作快速构建新应用程序的起点，并且付出最小的努力。然后，我们将使用该模板创建一个简单的任务列表应用程序。在此过程中，我们将发现如何与用户交互并操作应用程序的用户界面。我们还将了解我们的第一个新HTML5功能，Web存储API。*'
- en: 'In this chapter we will learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: The three basic components of an HTML5 application, HTML, CSS, and JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5应用程序的三个基本组件，HTML，CSS和JavaScript
- en: Some jQuery basics for those of you unfamiliar with the JavaScript library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于那些不熟悉JavaScript库的jQuery基础知识
- en: How to initialize an application and handle user interactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何初始化应用程序并处理用户交互
- en: How to manipulate the DOM to add, remove, change, and move elements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何操作DOM以添加、删除、更改和移动元素
- en: How to create reusable HTML templates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建可重用的HTML模板
- en: How to use the HTML5 Web Storage API to store and retrieve an application's
    state
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用HTML5 Web存储API存储和检索应用程序的状态
- en: The components of an HTML5 application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5应用程序的组件
- en: Before we get started building our first application, we need to learn some
    HTML5 application basics. HTML5 applications are like applications written in
    any other programming language. There is a certain amount of infrastructure and
    plumbing that needs to be put in place before we can start working on the fun
    part.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建我们的第一个应用程序之前，我们需要了解一些HTML5应用程序基础知识。HTML5应用程序类似于使用任何其他编程语言编写的应用程序。在我们开始进行有趣的部分之前，需要放置一定数量的基础设施和管道。
- en: Web applications are pretty good when it comes to scaffolding out a project.
    You could just start from scratch every time you begin a new application. But
    as you write more and more applications, you begin to notice that you are doing
    the same basic things over and over every time you get started, so it makes sense
    to create an application template to get started up quickly without reinventing
    the wheel every time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到搭建项目时，Web应用程序非常好。您可以每次开始新应用程序时都从头开始。但是随着您编写越来越多的应用程序，您会注意到每次开始时都在做相同的基本事情，因此创建应用程序模板以快速启动而不必每次重新发明轮子是有意义的。
- en: To understand how HTML5 applications are built, we will start from scratch and
    build our own application template which we can use when creating new applications.
    We will use this template as a base for all of the applications that we build
    throughout this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解HTML5应用程序是如何构建的，我们将从头开始构建自己的应用程序模板，我们可以在创建新应用程序时使用。我们将使用此模板作为本书中构建的所有应用程序的基础。
- en: 'Every web application starts with three components: HTML, CSS, and JavaScript.
    You can put them all in one file, and that might be acceptable for a very simple
    application, but we are learning how to build real applications here. So we will
    start by creating three files, one for each component, and placing them in a folder
    named `template`. They will be named `app.html`, `app.css`, and `app.js`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web应用程序都以三个组件开始：HTML，CSS和JavaScript。您可以将它们全部放在一个文件中，对于非常简单的应用程序可能是可以接受的，但是我们在这里学习如何构建真正的应用程序。因此，我们将首先创建三个文件，每个组件一个文件，并将它们放在名为`template`的文件夹中。它们将被命名为`app.html`，`app.css`和`app.js`。
- en: The following diagram is an interpretation of an HTML5 application and its components.
    Our application is built upon HTML, CSS, and JavaScript. Those in turn are built
    on top of CSS3 and the HTML5 framework, which consists of new markup elements
    and JavaScript APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是对HTML5应用程序及其组件的解释。我们的应用程序是建立在HTML，CSS和JavaScript之上的。这些又建立在CSS3和HTML5框架之上，其中包括新的标记元素和JavaScript
    API。
- en: '![The components of an HTML5 application](img/5947OT_01_05.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![HTML5应用程序的组件](img/5947OT_01_05.jpg)'
- en: 'Let''s look at the folder structure for our applications. We will put all of
    the files that we create at the root of our application''s folder. We will also
    add a folder named `lib` which contains any third-party JavaScript libraries our
    application may need. Since we will always use the jQuery library, we will put
    a copy of it in there. If there are any other assets, such as images or audio
    files, we will put them in the `images` and `audio` folders respectively:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们应用程序的文件夹结构。我们将把我们创建的所有文件放在应用程序文件夹的根目录下。我们还将添加一个名为`lib`的文件夹，其中包含应用程序可能需要的任何第三方JavaScript库。由于我们将始终使用jQuery库，因此我们将在其中放置一个副本。如果有任何其他资产，例如图像或音频文件，我们将分别将它们放在`images`和`audio`文件夹中：
- en: '![The components of an HTML5 application](img/5947OT_01_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![HTML5应用程序的组件](img/5947OT_01_02.jpg)'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could just reference the jQuery library from an online **content delivery
    network** (**CDN**), but that requires you to always have an Internet connection.
    Take it from me, you never know when you are going to end up some place without
    a connection and find out you can't get any work done.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从在线内容交付网络（CDN）引用jQuery库，但这要求您始终具有互联网连接。相信我，您永远不知道何时会在某个地方结束而无法连接并发现无法完成任何工作。
- en: Time for action – creating the HTML file
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建HTML文件
- en: The first component we will build is our base HTML file, `app.html`. We will
    keep our HTML as clean as possible. It should contain only markup. There should
    not be any styling or blocks of script mixed in it. Keeping markup, style, and
    behavior separated will make your applications easier to debug and maintain. For
    example, if there is a problem with the way something looks, we will know the
    problem is in the CSS file and not the JavaScript file. Another benefit is that
    you can completely restyle the user interface of your application by changing
    the CSS without ever touching its functionality.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的第一个组件是我们的基本HTML文件`app.html`。我们将尽可能保持我们的HTML干净。它应该只包含标记。不应该混入任何样式或脚本块。保持标记、样式和行为分开将使您的应用程序更容易调试和维护。例如，如果某些东西的外观有问题，我们将知道问题在CSS文件中而不是JavaScript文件中。另一个好处是，您可以通过更改CSS完全重新设计应用程序的用户界面，而不必触及其功能。
- en: Here is the markup for our base HTML file. All it does is include our CSS and
    JavaScript as well as the jQuery library, and defines a simple body structure
    that most of our applications will use. It is a good place to start for the applications
    we will be writing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们基本HTML文件的标记。它只包括我们的CSS和JavaScript以及jQuery库，并定义了大多数应用程序将使用的简单body结构。这是我们将要编写的应用程序的一个很好的起点。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: 'One of the major differences between HTML5 markup and previous versions of
    HTML is the document type declaration this has been greatly simplified. As you
    may recall, doctypes before HTML5 were very verbose and impossible for mere mortals
    to remember. They looked something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5标记和以前版本的HTML之间的一个主要区别是文档类型声明已经大大简化。正如你可能记得的那样，HTML5之前的文档类型声明非常冗长，普通人根本记不住。它们看起来像这样：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now meet the new and improved HTML5 document type declaration. It''s simple,
    it''s elegant, and best of all it''s easy to remember:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看新的改进的HTML5文档类型声明。它简单、优雅，最重要的是易于记忆：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another difference you may notice are the `<header>` and `<footer>` elements.
    These are new semantic elements in HTML5 that are essentially the same as `<div>`
    elements. HTML5 actually has a whole array of new semantic elements that are designed
    to give HTML markup more meaning than just wrapping everything in a `<div>` tag.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到的另一个区别是`<header>`和`<footer>`元素。这些是HTML5中的新语义元素，本质上与`<div>`元素相同。HTML5实际上有一整套新的语义元素，旨在为HTML标记提供比仅仅将所有内容包装在`<div>`标记中更多的含义。
- en: 'Since we are building applications here and not writing content pages, we won''t
    be focusing on these semantic elements too much. Most of the time we will use
    the plain old `<div>` elements. But just to familiarize you with them, here is
    an overview of some of the most useful new semantic elements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里构建的是应用程序，而不是编写内容页面，我们不会过多关注这些语义元素。大多数时候，我们将使用普通的`<div>`元素。但为了让您熟悉它们，这里是一些最有用的新语义元素的概述：
- en: '`<article>`: Defines an article in the document'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<article>`：定义文档中的一篇文章'
- en: '`<aside>`: Defines content aside from the other page content'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<aside>`：定义页面内容以外的内容'
- en: '`<footer>`: Defines the footer for a section in the document'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<footer>`：定义文档中某个部分的页脚'
- en: '`<header>`: Defines the header for a section in the document'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<header>`：定义文档中某个部分的标题'
- en: '`<nav>`: Contains page navigation links'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<nav>`：包含页面导航链接'
- en: '`<section>`: Defines a section in a document'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<section>`：定义文档中的一个部分'
- en: A few elements and attributes that existed in previous versions of HTML are
    now not present in HTML5\. These are mostly elements having to do with layout
    and fonts, including `<big>`, `<center>`, `<font>`, `<strike>`, and `<u>`. Obsolete
    elements such as `<frame>` and `<applet>` are also out.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5中，以前版本的HTML中存在的一些元素和属性现在已经不再存在。这些主要是与布局和字体有关的元素，包括`<big>`、`<center>`、`<font>`、`<strike>`和`<u>`。过时的元素，如`<frame>`和`<applet>`也已经淘汰。
- en: Now let's take a look at the contents of the `<body>` element in our markup.
    First there is a `<div id=`"`app`"`>` element. This will wrap the application's
    entire markup. Other markup, such as site navigation or anything else not related
    to the application, can go outside this element.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们标记中`<body>`元素的内容。首先是一个`<div id=`"`app`"`>`元素。这将包装应用程序的整个标记。其他标记，如站点导航或与应用程序无关的任何其他内容，可以放在此元素之外。
- en: Inside the `app` element we have three more elements. Here we use a couple of
    the new semantic elements. First we have a `<header>` element in our application
    that will contain the name of the application, such as a title bar (not to be
    confused with the `<title>` element in the document `<head>` section). The `<div
    id=`"`main`"`>` element is where the markup for the main part of the application
    will go. We add a `<footer>` element below it that will be used like a status
    bar to display the status of the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app`元素内部，我们还有三个元素。在这里，我们使用了一些新的语义元素。首先，我们在应用程序中有一个`<header>`元素，它将包含应用程序的名称，比如标题栏（不要与文档`<head>`部分中的`<title>`元素混淆）。`<div
    id=`"`main`"`>`元素是应用程序主要部分的标记所在的地方。我们在它下面添加一个`<footer>`元素，它将被用作状态栏来显示应用程序的状态。
- en: Time for action – creating the CSS file
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建CSS文件
- en: Next we'll create our base CSS file named `app.css`. This will have all of the
    basic styling that will be used by our applications, such as the default font
    and colors. The first part of the CSS file contains some document-wide element
    styles that set the basic look and feel.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将创建名为`app.css`的基本CSS文件。这将包含所有应用程序将使用的基本样式，如默认字体和颜色。CSS文件的第一部分包含一些文档范围的元素样式，设置了基本的外观和感觉。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First we set the style to be applied to the body, which will trickle down to
    the other elements. I like to set the font size to `1em` instead of a fixed pixel
    size so that it uses the browser's default font size. Then you can base other
    measurements off of that using ems or percent to give you a more reactive layout
    and make it easier to change the look of your application later on. Constant pixel
    sizes are good when you always need something to be the same size no matter what,
    or for small values for borders and margins, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置要应用于body的样式，这将传递到其他元素。我喜欢将字体大小设置为`1em`，而不是固定的像素大小，这样它就会使用浏览器的默认字体大小。然后，您可以使用em或百分比基于此进行其他测量，以便为您提供更具反应性的布局，并使以后更改应用程序外观更容易。当您始终需要某些东西保持相同大小时，常数像素大小很好，或者用于边框和边距等小值。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Typically, 1em is the same as 16px by default in most browsers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在大多数浏览器中，默认情况下1em等于16px。
- en: Next we make sure all padding and margins are removed from all the `div` elements,
    so we zero them out. It's also nice to have the cursor change to a pointer when
    the user hovers over a button, so we'll set that here too. Finally, there is a
    `.hidden` class selector that can be added to any element to hide it from being
    displayed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确保所有`div`元素的填充和边距都被移除，所以我们将它们归零。当用户悬停在按钮上时，将光标更改为指针也是很好的，所以我们也会在这里设置。最后，有一个`.hidden`类选择器，可以添加到任何元素中，以将其隐藏不显示。
- en: 'We''ll finish the CSS off with some styles for the `app` and `main` elements.
    All we''re setting at this point are margins, padding, and colors:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一些样式来完成CSS的`app`和`main`元素。在这一点上，我们所设置的只是边距、填充和颜色：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Time for action – creating the JavaScript file
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建JavaScript文件
- en: Let's move on to the JavaScript file, `app.js`. Here we'll stub out a basic
    outline for our application template. If you don't know what the dollar signs
    are for, they are aliases for the jQuery library. We'll go over some jQuery basics
    in a moment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行JavaScript文件`app.js`。在这里，我们将为我们的应用程序模板勾画出一个基本的轮廓。如果您不知道美元符号是用来做什么的，它们是jQuery库的别名。我们将在一会儿讨论一些jQuery基础知识。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Starting at the top we will include `"use strict"` in our JavaScript files.
    This informs the JavaScript runtime to use newer and stricter standards when running
    our code. For example, in older versions of JavaScript it was completely legal
    to use a variable name without declaring it first using the `var` keyword. This
    had the side effect of making it a global variable attached to the `window` object.
    When `"use strict"` is defined, you will get an error if you try to do that. It
    helps you find bad coding mistakes that could lead to bugs in your program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们将在我们的JavaScript文件中包含`"use strict"`。这通知JavaScript运行时在运行我们的代码时使用更新和更严格的标准。例如，在旧版本的JavaScript中，完全可以在不使用`var`关键字先声明变量名的情况下使用它。这会导致它成为附加到`window`对象的全局变量。当定义`"use
    strict"`时，如果尝试这样做，将会收到错误。它可以帮助您找到可能导致程序中出现错误的糟糕编码错误。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using some older JavaScript library that doesn't work in strict mode
    you can add `"use strict"` inside of function declarations instead, to make only
    that block of code use strict mode.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用一些不适用于严格模式的较旧的JavaScript库，可以在函数声明中添加`"use strict"`，以使仅该代码块使用严格模式。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next we define the main application object, `myApp`. There are many ways to
    define an object in JavaScript, including using object literals and constructor
    functions. Object literals are the simplest way to define an object, but those
    objects are created as soon as the JavaScript is loaded, usually before the DOM
    is ready. Here''s what our object would look like as an object literal:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义主应用程序对象`myApp`。在JavaScript中，有许多定义对象的方法，包括使用对象字面量和构造函数。对象字面量是定义对象的最简单方法，但这些对象通常在JavaScript加载后立即创建，通常在DOM准备就绪之前。以下是我们的对象作为对象字面量的样子：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since our applications are manipulating the Document Object Model (DOM), we
    don't want to create the object until the DOM is ready. That's why we will be
    using the function constructor form for creating an object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序正在操作文档对象模型（DOM），我们不希望在DOM准备就绪之前创建对象。这就是为什么我们将使用函数构造函数形式来创建对象。
- en: The **DOM**, or **Document Object Model**, is the internal representation of
    the HTML markup. It's a hierarchical tree of objects that represents the HTML
    elements.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOM**，或**文档对象模型**，是HTML标记的内部表示。它是一个对象的分层树，表示HTML元素。'
- en: Another problem with using object literals is that everything defined in it
    is a member of the object, and therefore must be accessed using the `this` keyword.
    Notice in the preceding object literal form how we must use `this` to access `version`
    and `setStatus()`. However, when creating an object using a constructor, we can
    define functions and variables inside of the constructor without making them members
    of the object. Since they aren't members, you don't have to use the `this` keyword
    to access them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象字面量的另一个问题是，其中定义的所有内容都是对象的成员，因此必须使用`this`关键字访问。请注意，在前面的对象字面量形式中，我们必须使用`this`来访问`version`和`setStatus()`。然而，当使用构造函数创建对象时，我们可以在构造函数中定义函数和变量，而不使它们成为对象的成员。由于它们不是成员，您不必使用`this`关键字来访问它们。
- en: So what's wrong with using `this`? After you've programmed in JavaScript for
    a while, you become aware that the `this` keyword can cause a lot of confusion
    because it can mean different things at different times. In other languages, such
    as C# and Java, `this` always points to the object that you are inside of. In
    JavaScript, `this` is a pointer to the object that called the function, which
    for event handlers is usually the `window` object. So the more we avoid using
    it, the better.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么使用`this`有什么问题呢？在您使用JavaScript编程一段时间后，您会意识到`this`关键字可能会引起很多混乱，因为它在不同的时间可能会有不同的含义。在其他语言中，比如C#和Java，`this`总是指向您所在的对象。在JavaScript中，`this`是指向调用函数的对象的指针，对于事件处理程序来说，通常是`window`对象。因此，我们尽量避免使用它，越少用越好。
- en: Another advantage of using a constructor is being able to define private and
    public methods. Notice that the `setStatus()` method is defined using a normal
    function declaration. This will make it a private method that can only be accessed
    from within the object that encloses it, and doesn't require using `this` to call
    it. The `start()` method, on the other hand, is assigned to the object using `this`.
    That will make `start()` a public method that can only be accessed from an instance
    of the object. We will use this paradigm throughout our JavaScript to implement
    the private and public members of our objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数的另一个优点是能够定义私有和公共方法。请注意，`setStatus()`方法是使用普通函数声明定义的。这将使它成为一个私有方法，只能从封闭它的对象内部访问，并且不需要使用`this`来调用它。另一方面，`start()`方法是使用`this`分配给对象的。这将使`start()`成为一个公共方法，只能从对象的实例中访问。我们将在整个JavaScript中使用这种范式来实现对象的私有和公共成员。
- en: 'The last thing we need is a document-ready event handler. The document-ready
    event gets fired once the page has loaded and the DOM hierarchy has been fully
    constructed. There are two ways to add this event handler using jQuery. The first
    and more verbose way is what you would expect:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一件事是一个文档准备好的事件处理程序。文档准备好的事件在页面加载完成并且DOM层次结构已完全构建后触发。使用jQuery添加此事件处理程序有两种方法。第一种更冗长的方式是您所期望的：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, since it is probably the most basic and important event you will need
    to implement, jQuery provides a shorthand form that is as simple as it gets:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于它可能是您需要实现的最基本和重要的事件，jQuery提供了一种简写形式，就是这么简单：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is our document-ready event handler:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的文档准备好的事件处理程序：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is an important piece of code. It defines the starting point for our application.
    It is equivalent to the `main()` function in other languages, such as C, C++,
    C#, and Java.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的代码片段。它定义了我们应用程序的起点。它相当于其他语言（如C、C++、C#和Java）中的`main()`函数。
- en: Here we create an instance of our main application object, and then assign it
    to a global variable named `app` by attaching it to the `window` object. We make
    it `global` so it can be accessed throughout our application. Last but not least
    we call the `start()` method of our application object to get the application
    going.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了我们的主应用程序对象的一个实例，然后将其分配给一个名为`app`的全局变量，通过将其附加到`window`对象。我们将它设置为`global`，这样它就可以在整个应用程序中访问。最后但同样重要的是，我们调用我们的应用程序对象的`start()`方法来启动应用程序。
- en: '*What just happened?*'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We just created a template that we can use to start writing new applications
    with minimal startup time. It consists of HTML, CSS, and JavaScript files. At
    this point our template is finished, and we have the basics we will need to start
    writing new HTML5 applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个模板，可以用来开始编写新的应用程序，启动时间最短。它由HTML、CSS和JavaScript文件组成。在这一点上，我们的模板已经完成，我们已经拥有了开始编写新的HTML5应用程序所需的基础知识。
- en: The dollar sign identifier
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 美元符号标识符
- en: You may have noticed dollar signs everywhere in our JavaScript code. The dollar
    sign is no more than an alias for the jQuery object. You could replace all dollar
    signs with jQuery and it would be the same, just more typing. If you already know
    about jQuery you might want to jump ahead. Otherwise I'll give a brief overview
    of jQuery.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们的JavaScript代码中到处都是美元符号。美元符号只不过是jQuery对象的别名。您可以用jQuery替换所有美元符号，效果是一样的，只是要多输入一些。如果您已经了解jQuery，您可能想要跳过。否则，我将简要概述一下jQuery。
- en: jQuery is a popular JavaScript library that at its most basic level provides
    functions to access and manipulate the DOM. It also provides a lot of other useful
    functionality, such as event handling, animations, and AJAX support. In addition,
    it hides many of the different quirks between browsers, so you can concentrate
    on programming and not on how to make your code work in every browser. It makes
    writing JavaScript applications tolerable, and dare I say fun. I wouldn't think
    of writing an HTML5 application without it. It's to JavaScript what the System
    library is to Java and C#.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个流行的JavaScript库，它在最基本的层面上提供了访问和操作DOM的功能。它还提供了许多其他有用的功能，如事件处理、动画和AJAX支持。此外，它隐藏了许多不同浏览器之间的差异，因此您可以专注于编程，而不是如何使您的代码在每个浏览器中都能正常工作。它使编写JavaScript应用程序变得可忍受，甚至可以说是有趣的。我不会想在没有它的情况下编写HTML5应用程序。它对JavaScript来说就像System库对Java和C#一样。
- en: 'For the most part, jQuery uses the same query syntax as CSS to select elements.
    The typical pattern is to select one or more elements and then perform some action
    on them, or retrieve data from them. So, for example, here is a jQuery select
    to get all `div` elements in the DOM:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，jQuery使用与CSS相同的查询语法来选择元素。典型的模式是选择一个或多个元素，然后对它们执行某些操作，或者从中检索数据。因此，例如，这是一个jQuery选择，用于获取DOM中的所有`div`元素：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following query would give you the element that has an ID of `main`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询将给出具有ID为`main`的元素：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just like CSS, the hash sign selects elements with a specific ID, and a dot
    selects elements that have a specific class. You can also use compound search
    criteria. This next query would return all of the elements that are descendants
    of the element with an ID of `main` and have a class of `selected`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS一样，井号选择具有特定ID的元素，点选择具有特定类的元素。您还可以使用复合搜索条件。下一个查询将返回所有具有ID为`main`的元素的后代，并具有`selected`类的元素：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After you have selected one or more elements you can perform some action on
    them. A jQuery select returns a jQuery object that is like an array, but also
    has lots of built-in functions to do all sorts of things, which we will learn
    about as we progress through this book. For example, the following line of code
    would hide all of the elements returned from the previous select (set their CSS
    `display` attribute to `none`):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了一个或多个元素之后，您可以对它们执行一些操作。jQuery选择返回一个类似数组的jQuery对象，但也有很多内置函数可以做各种事情，我们将在本书中逐步学习。例如，以下代码行将隐藏从前一个选择返回的所有元素（将它们的CSS
    `display`属性设置为`none`）：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Simple and powerful. So what is the deal with the dollar sign anyway? Some people
    assumed it was some sort of magic that jQuery could use the dollar sign as an
    alias. But apparently the dollar sign is a valid character to start a variable
    or function name within JavaScript.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 简单而强大。那么美元符号到底是怎么回事呢？有些人认为这是jQuery可以使用美元符号作为别名的一种魔法。但显然，美元符号是JavaScript中一个有效的字符，可以作为变量或函数名称的开头。
- en: Creating our first application
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个应用程序
- en: Throughout this and the next couple of chapters, we will be building a tasklist
    application that uses HTML5 and CSS3\. Before we get started we should spell out
    the specifications for our application so we know what we want to build.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和接下来的几章中，我们将构建一个使用HTML5和CSS3的任务列表应用程序。在开始之前，我们应该明确我们应用程序的规格，这样我们就知道我们想要构建什么。
- en: Our tasklist application should allow the user to quickly type in one or more
    task names and display them in a list.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的任务列表应用程序应该允许用户快速输入一个或多个任务名称，并在列表中显示它们。
- en: The user should be able to easily manipulate the tasks by editing them, deleting
    them, or moving them up or down in the order of the list.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够通过编辑、删除或上下移动任务来轻松操作任务。
- en: The application should remember the tasks that were entered, so when the user
    comes back to it they can continue where they left off.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该记住输入的任务，所以当用户回到应用程序时，他们可以继续之前的工作。
- en: The UI should be reactive so that it can be used on a number of different devices
    with different screen sizes.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI应该是响应式的，这样它可以在许多不同的设备上使用，具有不同的屏幕尺寸。
- en: We will start off simple and build upon what we've done as we go along. Throughout
    the process we will build some JavaScript libraries that can be used in subsequent
    projects, so we can hit the ground running.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从简单的开始，并随着进展逐步构建。在整个过程中，我们将构建一些JavaScript库，可以在后续项目中使用，这样我们就可以快速上手。
- en: Time for action – creating a tasklist
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建任务列表
- en: Now that we have the basics under our belt let's get started on the tasklist
    application. We'll call our application `Task at Hand`, or `Task@Hand` to be hip.
    First make a copy of our template folder and rename it to `taskAtHand`. Also rename
    the `.html`, `.css`, and `.js` files to `taskAtHand`. Now we're ready to start
    our first HTML5 application. You can find the code for this section in `Chapter
    1/example1.1`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了基础知识，让我们开始任务列表应用程序。我们将称我们的应用程序为`Task at Hand`，或者`Task@Hand`以时髦一点。首先复制我们的模板文件夹，并将其重命名为`taskAtHand`。还要将`.html`、`.css`和`.js`文件重命名为`taskAtHand`。现在我们准备开始我们的第一个HTML5应用程序。您可以在`第1章/示例1.1`中找到本节的代码。
- en: 'The first thing we need to do is go into the HTML file and change the title
    and names of the CSS and JS files in the `<head>` element to `taskAtHand`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是进入HTML文件，并在`<head>`元素中更改标题和CSS和JS文件的名称为`taskAtHand`：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next we move on to the body. First we change the name of the application in
    the `<header>` element. Then go into the `<div id=`"`app`"`>` element and add
    a text input field where the user can type in the name of a task. Finally, we
    add an empty list to hold our list of tasks. Since we are building a list we will
    use the unordered list `<ul>` element.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们转到body。首先我们在`<header>`元素中更改应用程序的名称。然后进入`<div id=`"`app`"`>`元素，并添加一个文本输入字段，用户可以在其中输入任务的名称。最后，我们添加一个空列表来保存我们的任务列表。因为我们正在构建一个列表，所以我们将使用无序列表`<ul>`元素。
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's all of the markup we need for now. There is one thing to point out in
    here, that's new to HTML5\. There is a new attribute for inputs called `placeholder`
    that displays some text in the field until the user starts typing something. This
    gives the user a hint as to what they should enter in the field. It is valid for
    input elements that allow the user to enter text.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们现在需要的所有标记。这里有一件事要指出，这是HTML5中的新内容。输入元素有一个新的属性叫做`placeholder`，它会在用户开始输入之前在字段中显示一些文本。这给用户一个提示，告诉他们应该在字段中输入什么。这对允许用户输入文本的输入元素是有效的。
- en: 'Let''s go into the JavaScript file and get coding. The first thing we''ll do
    is rename the application object to `TaskAtHandApp`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入JavaScript文件并开始编码。我们要做的第一件事是将应用程序对象重命名为`TaskAtHandApp`：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A standard in JavaScript is that only things that require a new statement (that
    is, object constructors) should start with a capital letter. This helps to distinguish
    what requires the `new` keyword to be created. Everything else, including variable
    and function names, should start with a lowercase letter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中的一个标准是，只有需要一个新语句（即对象构造函数）的东西才应该以大写字母开头。这有助于区分需要使用`new`关键字创建的内容。其他所有内容，包括变量和函数名称，都应该以小写字母开头。
- en: 'When the user is done typing in a task name and hits the *Enter* key, we want
    to create a new list item element and add it to the list. The first thing we need
    to do is add an event handler to the text field so we get notified when a key
    is pressed. We will add this in the `start()` method of our application object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入完任务名称并按下*Enter*键时，我们希望创建一个新的列表项元素并将其添加到列表中。我们首先需要在文本字段中添加一个事件处理程序，以便在按下键时得到通知。我们将在应用程序对象的`start()`方法中添加这个。
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First we get the text field by doing a jQuery select on its ID, `new-task-name`.
    Then we add a `keypress()` event handler to that element passing in a function
    to execute every time the event is triggered. jQuery passes one parameter to the
    event handler function, which is a `keypress` event object. The event object contains
    a field named `which` that contains the character code of the key that was pressed.
    The one we are interested in here is the *Enter* key, which has a code of `13`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过对其ID进行jQuery选择来获取文本字段，即`new-task-name`。然后，我们向该元素添加一个`keypress()`事件处理程序，传入一个函数，以便在每次触发事件时执行。jQuery向事件处理程序函数传递一个参数，即`keypress`事件对象。事件对象包含一个名为`which`的字段，其中包含按下的键的字符代码。我们感兴趣的是*Enter*键，它的代码是`13`。
- en: When the user presses the *Enter* key we call the `addTask()` method (defined
    next), and then it returns `false`. The reason we return `false` here is to tell
    the system that we handled the key press event, and don't want it to do the default
    action. Some browsers will perform other actions when the *Enter* key is pressed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Enter*键时，我们调用`addTask()`方法（下面定义），然后它返回`false`。我们在这里返回`false`的原因是告诉系统我们处理了按键事件，并且不希望它执行默认操作。一些浏览器在按下*Enter*键时会执行其他操作。
- en: Next, we add another function call onto the end of the `keypress()` handler
    to set the focus back to the text field. At this point you're probably asking
    yourself, how does that work, calling a function on a function? This is called
    function chaining and is perhaps one of the most useful features of jQuery. Most
    of jQuery's methods return a pointer to the object itself, so we can perform multiple
    actions in a single line of code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`keypress()`处理程序的末尾添加另一个函数调用，将焦点设置回文本字段。此时，您可能会问自己，这是如何工作的，调用一个函数的函数？这称为函数链接，可能是jQuery最有用的功能之一。jQuery的大多数方法都返回对象本身的指针，因此我们可以在一行代码中执行多个操作。
- en: 'Now we''ll write that `addTask()` method. This method will get the name of
    the task and add a new list item to the `<ul>` element in our HTML:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写`addTask()`方法。此方法将获取任务的名称，并将新的列表项添加到我们HTML中的`<ul>`元素中：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First we get the value of the `new-task-name` text field using jQuery's `val()`
    method, which is used to get the value of input fields. Just to make sure the
    user actually typed something in, we test that the `taskName` variable is "truthy",
    which in this case means it's not an empty string.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用jQuery的`val()`方法获取`new-task-name`文本字段的值，该方法用于获取输入字段的值。只是为了确保用户实际输入了内容，我们测试`taskName`变量是否为"真值"，在这种情况下意味着它不是空字符串。
- en: Next we call the `addTaskElement()` method. There we create a new `<li>` element.
    You can create a new element by passing in an element definition instead of select
    to jQuery. In this case we use `"<li></li>"` to create a new empty list item element,
    and then assign it to the `$task` variable. Then, we immediately fill that element
    with the task name using the `text()` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们调用`addTaskElement()`方法。在那里，我们创建一个新的`<li>`元素。您可以通过传入元素定义而不是选择到jQuery来创建一个新元素。在这种情况下，我们使用`"<li></li>"`来创建一个新的空列表项元素，然后将其分配给`$task`变量。然后，我们立即使用`text()`方法填充该元素的任务名称。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When assigning a jQuery object to a variable, it's a good practice to start
    the variable name with `$`, so you know that it references a jQuery object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将jQuery对象分配给变量时，最好的做法是以`$`开头的变量名，这样您就知道它引用了一个jQuery对象。
- en: Now that we have the new element we need to add it to the document in the correct
    place, which is inside the `<ul id=`"`task-list`"`>` element. That is done by
    selecting the `task-list` element and calling the `append()` method. This adds
    our new `<li>` element to the end of the tasklist.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新元素，我们需要将其添加到文档的正确位置，即`<ul id=`"`task-list`"`>`元素内。这是通过选择`task-list`元素并调用`append()`方法来完成的。这将我们的新`<li>`元素添加到任务列表的末尾。
- en: The last thing we do, back in the `addTask()` method, is clear out the value
    of the text input field and set the focus back on it so the user can immediately
    enter another task. We use function chaining here to do both in one statement.
    Notice that we used the jQuery `val()` method for both setting and getting the
    value of the text field. If you pass a value in, it sets the control's value;
    otherwise it returns the control's value. You'll find that a lot of the jQuery
    methods work this way. For example, the `text()` method will either set the text
    within an element, or return it if no value is passed in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`addTask()`方法中做的最后一件事是清除文本输入字段的值，并将焦点重新设置在它上面，以便用户可以立即输入另一个任务。我们在这里使用函数链接来在一条语句中完成两个操作。请注意，我们在设置和获取文本字段的值时都使用了jQuery的`val()`方法。如果传入一个值，它会设置控件的值；否则，它会返回控件的值。您会发现很多jQuery方法都是这样工作的。例如，`text()`方法将在元素内设置文本，或者如果没有传入值，则返回文本。
- en: '*What just happened?*'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We created a tasklist application where the user can type in task names and
    build a list of tasks. Let''s open the application in our browser and see what
    we''ve got so far:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个任务列表应用程序，用户可以在其中输入任务名称并构建任务列表。让我们在浏览器中打开应用程序，看看我们目前有什么：
- en: '![What just happened?](img/5947OT_01_04.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_01_04.jpg)'
- en: Time for action – removing a task from the list
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-从列表中删除任务
- en: Now that we can add tasks to the list, let's add the ability to remove tasks.
    To do this we'll need a delete button for each task in the list. We'll add the
    code to create the button in the `addTaskElement()` method. You can find the code
    for this section in `Chapter 1/example1.2`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向列表中添加任务了，让我们添加删除任务的功能。为此，我们需要为列表中的每个任务添加一个删除按钮。我们将在`addTaskElement()`方法中添加创建按钮的代码。您可以在`第1章/example1.2`中找到此部分的代码。
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing this method does is create a new `<button>` element with a class
    of `delete`. Then it creates the list item element as we did before, except that
    first it appends the delete button and then appends the task name. Note that we
    are now wrapping the task name in a `<span class=`'`task-name`'`>` element to
    help us keep track of it. Last we add a click event handler to the delete button.
    To delete the task from the list element we simply call the `remove()` method
    to remove it from the DOM. Voila, it's gone!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的第一件事是创建一个带有`delete`类的新`<button>`元素。然后，它创建了列表项元素，就像我们之前做的那样，只是首先附加了删除按钮，然后附加了任务名称。请注意，我们现在将任务名称包装在一个`<span
    class=`'`task-name`'`>`元素中，以帮助我们跟踪它。最后，我们为删除按钮添加了一个点击事件处理程序。要从列表元素中删除任务，我们只需调用`remove()`方法将其从DOM中删除。哇，它就消失了！
- en: Time for action – moving tasks within the list
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-在列表中移动任务
- en: While we're at it, let's add buttons to move tasks up and down in the list.
    For this we'll add some more code to the `addTaskElement()` method. First we need
    to create `move-up` and `move-down` buttons, and then add them to the list element
    along with the `delete` button.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，让我们为列表中的任务添加上移和下移按钮。为此，我们将向`addTaskElement()`方法添加一些代码。首先，我们需要创建`move-up`和`move-down`按钮，然后将它们与`delete`按钮一起添加到列表元素中。
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the **move up** or **move down** button is clicked, it finds the previous
    or next task element using the `prev()` and `next()` methods. Then it uses the
    jQuery `insertBefore()` and `insertAfter()` methods to move the task element up
    or down in the tasklist.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击**向上移动**或**向下移动**按钮时，它使用`prev()`和`next()`方法找到前一个或下一个任务元素。然后它使用jQuery的`insertBefore()`和`insertAfter()`方法将任务元素向上或向下移动到任务列表中。
- en: '*What just happened?*'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added buttons to each task element so that we can delete them or move them
    up and down in the order of the list. We learned how to use the jQuery `remove()`,
    `insertBefore()`, and `insertAfter()` methods to modify the DOM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个任务元素添加了按钮，以便可以删除它们或将它们上下移动到列表的顺序中。我们学会了如何使用jQuery的`remove()`、`insertBefore()`和`insertAfter()`方法来修改DOM。
- en: HTML templates
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML模板
- en: As you can see, things are getting a little messy in our `addTaskElement()`
    method. We are creating a bunch of elements programmatically in JavaScript and
    manually adding them to the DOM. Wouldn't it be a lot easier if we could just
    define what we want the task element's structure to look like in our HTML file
    and use it to create new tasks? Well we can, and we will. In this section we'll
    create an HTML template that we can reuse to easily create new tasks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的`addTaskElement()`方法有点混乱。我们在JavaScript中以编程方式创建了一堆元素，并手动将它们添加到DOM中。如果我们只需在HTML文件中定义任务元素的结构，并使用它来创建新任务，那不是更容易吗？好吧，我们可以，而且我们将这样做。在本节中，我们将创建一个HTML模板，以便轻松创建新任务。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are plenty of JavaScript libraries out there for implementing HTML templates
    and they have a lot of powerful features, but for our application all we need
    is something simple, so we'll implement our own.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多JavaScript库可以用来实现HTML模板，它们具有很多强大的功能，但对于我们的应用程序，我们只需要一些简单的东西，所以我们将自己实现。
- en: Time for action – implementing a template
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-实施模板
- en: 'To start out we need a place to put the template''s markup. So we''ll add a
    `<div id="templates">` to our HTML file outside of the `app` element and give
    it a class of `hidden`. As you may recall from our CSS, the hidden class sets
    `display` to `none` for an element. This will hide the template''s markup so it
    is never seen by the user. Now let''s define the template:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个放置模板标记的地方。因此，我们将在HTML文件中的`app`元素之外添加一个`<div id="templates">`，并给它一个`hidden`类。正如您可能还记得的，从我们的CSS中，`hidden`类为元素设置`display`为`none`。这将隐藏模板标记，使用户永远看不到它。现在让我们定义模板：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I don't know about you, but for me that's a lot easier than trying to build
    the task elements in the code. It's also a lot easier to read, add to, and maintain.
    You may have noticed a few other elements and attributes were added that would
    have been painful to add programmatically. A `<div class="tools">` was placed
    around the buttons to group them together, and a `title` attribute was added to
    each button that will show up as tool tips in the browser.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你怎么想，但对我来说，这比在代码中构建任务元素要容易得多。这样做也更容易阅读、添加和维护。你可能已经注意到，还添加了一些其他元素和属性，如果要以编程方式添加，那将是非常痛苦的。在按钮周围放置了一个`<div
    class="tools">`，将它们组合在一起，并为每个按钮添加了一个`title`属性，它将显示为浏览器中的工具提示。
- en: Note that we did not use any ID attributes anywhere in the task elements. Instead
    we are using class attributes to identify different elements. The reason for this
    is that an ID uniquely identifies an element, so it should only be used once.
    If we create a template that has a bunch of IDs and start copying it, we will
    have duplicate IDs. An ID is pretty worthless for uniquely identifying an element
    if you use it more than once.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在任务元素中没有使用任何ID属性。相反，我们使用类属性来标识不同的元素。这样做的原因是，ID唯一地标识一个元素，因此它应该只被使用一次。如果我们创建一个具有一堆ID的模板并开始复制它，我们将会有重复的ID。如果您多次使用ID，那么ID对于唯一标识元素就毫无价值了。
- en: 'Before we move on, we need to add some styling to our CSS for the buttons and
    their container. We want the buttons to remain on the same line as the task name
    but their container `<div>` is a block-level element. Let''s change it to `inline-block`
    so it doesn''t break:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要为按钮及其容器在CSS中添加一些样式。我们希望按钮保持与任务名称在同一行，但它们的容器`<div>`是一个块级元素。让我们将它更改为`inline-block`，这样它就不会断行：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also want to remove the borders from the buttons, make them all the same
    size, and remove padding and margins so it''s more compact:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望从按钮中移除边框，使它们都是相同的大小，并移除填充和边距，使其更加紧凑：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, now that we have a task template what do we do with it? jQuery comes in
    handy here again. All we have to do is get the template element and use the `clone()`
    method to make a copy of it. Then insert the copy wherever we want to in the DOM.
    Here''s what our new `addTaskElement()` method looks like:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们有了一个任务模板，我们该怎么办呢？这里再次用到了jQuery。我们所要做的就是获取模板元素，并使用`clone()`方法来复制它。然后将复制的内容插入到DOM中的任何位置。下面是我们新的`addTaskElement()`方法的样子：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've replaced all those lines of creating elements with one line of code that
    gets the task template element and makes a copy of it using the `clone()` method.
    The second line fills the task name into the `<span class="task-name">` element
    we have set up to hold it. If you look closely you will see that we are passing
    in a second parameter to jQuery in our select now. That tells jQuery to only search
    for elements that are descendants of the `task` element. Otherwise it would find
    every task name element in the document and change it. We do the same thing when
    selecting the buttons to hook up click event handlers to them, using their class
    name to identify them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一行代码替换了所有创建元素的代码行，它获取了任务模板元素，并使用`clone()`方法对其进行复制。第二行将任务名称填入了我们设置好的`<span
    class="task-name">`元素中。如果你仔细看，你会发现我们现在在选择时向jQuery传递了第二个参数。这告诉jQuery只搜索`task`元素的后代元素。否则它会在整个文档中找到每个任务名称元素并更改它们。在选择按钮时，我们也是用相同的方法来识别它们，使用它们的类名来连接点击事件处理程序。
- en: '*What just happened?*'
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We implemented an HTML template that allows us to remove all of the code to
    dynamically generate task elements and replace it with a call to jQuery's `clone()`
    method. This makes it easier for us to update and maintain element structures
    in HTML rather than JavaScript.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个HTML模板，允许我们删除所有动态生成任务元素的代码，并用jQuery的`clone()`方法来替换它。这使得我们更容易在HTML中更新和维护元素结构，而不是在JavaScript中。
- en: Time for action – editing a task in the list
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-编辑列表中的任务
- en: 'So far we have a tasklist that we can add tasks to, remove tasks from, and
    change the order of the tasks. Let''s add some functionality to allow the user
    to change the name of a task. When the user clicks on a task name we will change
    it to a text input field. To do that we need to add a text input field to our
    task element template right after the task name:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个任务列表，可以向其中添加任务，从中删除任务，并更改任务的顺序。让我们添加一些功能，允许用户更改任务的名称。当用户点击任务名称时，我们将把它更改为文本输入字段。为此，我们需要在任务元素模板中的任务名称后面添加一个文本输入字段：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We give it a class of `task-name` to identify it, and also add the hidden class
    so it''s not visible by default. We only want to show it when the user clicks
    on the task name. So let''s go into the JavaScript file and add an event handler
    on the `<span>` element to the end of our `addTaskElement()` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给它一个`task-name`的类来标识它，并且还添加了隐藏类，所以默认情况下它是不可见的。我们只想在用户点击任务名称时显示它。所以让我们进入JavaScript文件，并在`addTaskElement()`方法的末尾添加一个`<span>`元素的事件处理程序：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s break this down. First we get the span with the class of `task-name`
    that is a child of the task element. Then we add a click event handler that calls
    the `onEditTaskName()` method. The `onEditTaskName()` method takes a reference
    to the `<span>` element as a parameter. When you are in a jQuery event handler
    function, `this` refers to the element that was the source of the event. So `$`(`this`)
    creates a jQuery object that wraps the `<span>` element so we can call jQuery
    methods on it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下。首先，我们获取了任务元素的子元素，类名为`task-name`的span。然后，我们添加了一个点击事件处理程序，调用`onEditTaskName()`方法。`onEditTaskName()`方法以`<span>`元素的引用作为参数。当你在jQuery事件处理程序函数中时，`this`指的是事件的源元素。因此，`$`(`this`)创建了一个包装`<span>`元素的jQuery对象，这样我们就可以在其上调用jQuery方法：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Even though the `onEditTaskName()` method technically contains one line of code,
    there is a lot going on. It uses function chaining to do a lot of work in a compact
    statement. First it hides the `<span>` element. Then it gets the text input field
    by looking for a sibling of the `<span>` element, that is, an `<input>` element
    with a class of `task-name`. Then it sets the value of the text field with the
    task name which it gets from the `<span>` element using jQuery's `text()` method.
    Finally, it makes the text field visible and sets the focus on it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`onEditTaskName()`方法在技术上只包含一行代码，但其中发生了很多事情。它使用函数链接在一个紧凑的语句中完成了很多工作。首先，它隐藏了`<span>`元素。然后，它通过查找`<span>`元素的兄弟元素，即类名为`task-name`的`<input>`元素，获取了文本输入字段。然后，它使用jQuery的`text()`方法从`<span>`元素中获取任务名称并设置文本字段的值。最后，它使文本字段可见，并将焦点设置在它上面。
- en: 'When the user clicks on the task name, it appears to change into an editable
    text field right before their eyes. Now all we need is a way to change it back
    when the user is done editing the name. To do that we''ll add a change event handler
    to the text field, which gets fired when the user changes the text field and hits
    *Enter* or leaves it. Add this to the end of the `addTaskElement()` method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击任务名称时，它似乎会在他们眼前变成一个可编辑的文本字段。现在我们只需要一种方法，在用户完成编辑名称后将其改回来。为此，我们将以下内容添加到`addTaskElement()`方法的末尾：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This works the same way as the task name click event handler. We are going
    to call a method named `onChangeTaskName()` and pass it a jQuery object that wraps
    the text field''s input element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这与任务名称点击事件处理程序的工作方式相同。我们将调用一个名为`onChangeTaskName()`的方法，并传递一个包装文本字段输入元素的jQuery对象：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First we hide the text input field, and then get the task name `<span>` element
    and store it in a variable. Before updating the name we check to make sure that
    the user actually typed something in. If so, we update the task name. Finally,
    we call `show()` to make the task name visible again. The user sees the text field
    turn back into static text.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们隐藏文本输入字段，然后获取任务名称`<span>`元素并将其存储在一个变量中。在更新名称之前，我们检查用户是否确实输入了内容。如果是，我们就更新任务名称。最后，我们调用`show()`来使任务名称再次可见。用户会看到文本字段再次变成静态文本。
- en: 'There is one last thing left to do. If the user clicks off the field without
    changing anything, we will not get a change event and the text field will not
    get hidden. We can get a `blur` event when this happens though. So let''s add
    a `blur` event handler to the text field that hides it and shows the static task
    name `<span>` element:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有一件事要做。如果用户在不更改任何内容的情况下点击字段，我们将不会收到更改事件，并且文本字段将不会被隐藏。但是，当发生这种情况时，我们可以获得`blur`事件。因此，让我们向文本字段添加一个`blur`事件处理程序，以隐藏它并显示静态任务名称`<span>`元素：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*What just happened?*'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We added a text field to our task template that gets shown when the user clicks
    on the task name, so they can edit the task name. When the task name text field
    changes, it updates the task name label.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在任务模板中添加了一个文本字段，当用户点击任务名称时，它会显示出来，以便他们可以编辑任务名称。当任务名称文本字段更改时，它会更新任务名称标签。
- en: '![What just happened?](img/5947OT_01_03.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: 发生了什么？
- en: Saving the state of the application
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存应用程序的状态
- en: We have a pretty functional tasklist application now. We can add, remove, and
    move tasks around. We can even edit the name of an existing task. There's only
    one problem. Since we added all of these task elements to the DOM dynamically,
    they won't be there the next time the user comes back to the application. We need
    a way to save the tasklist, so the next time the user comes back to the application
    the tasks will still be there. Otherwise, what's the point?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常实用的任务列表应用程序。我们可以添加、删除和移动任务。甚至可以编辑现有任务的名称。只有一个问题。由于我们动态向DOM添加了所有这些任务元素，所以下次用户返回应用程序时，它们将不会存在。我们需要一种方法来保存任务列表，这样用户下次返回应用程序时，任务仍将存在。否则，这有什么意义呢？
- en: HTML5 has just the thing for that-Web Storage. Web Storage is a new API in HTML5
    that allows you to store information on the client. In the past, the only kind
    of storage available on the client was cookies. But cookies aren't a great way
    to store data on the client. They are limited to only a few kilobytes of data
    and are also included in HTTP requests, inflating their size.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5刚好有这样的东西-Web Storage。Web Storage是HTML5中的一个新API，允许您在客户端上存储信息。过去，客户端上唯一可用的存储方式是cookie。但是cookie并不是在客户端存储数据的好方法。它们仅限于几千字节的数据，并且还包含在HTTP请求中，增加了它们的大小。
- en: Web Storage, on the other hand, allows us to save much more data (up to 5 MB
    in most browsers) and adds nothing to the HTTP requests. It consists of two global
    objects that have the same interface, `localStorage` and `sessionStorage` . The
    only difference between the two is that data stored in `sessionStorage` goes away
    when the browser is closed, while data stored in `localStorage` doesn't. Since
    we want to save application data between sessions we will only use `localStorage`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Web Storage允许我们保存更多的数据（在大多数浏览器中最多可达5MB），并且不会增加HTTP请求的内容。它由两个具有相同接口的全局对象组成，`localStorage`和`sessionStorage`。两者之间唯一的区别是存储在`sessionStorage`中的数据在关闭浏览器时会消失，而存储在`localStorage`中的数据不会。由于我们希望在会话之间保存应用程序数据，因此我们只会使用`localStorage`。
- en: 'Data is stored as key/value pairs. You can set values using the `setItem()`
    method and retrieve values using `getItem()` as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以键/值对的形式存储。您可以使用`setItem()`方法设置值，并使用`getItem()`检索值，如下所示：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you try to get a value using a key that doesn't exist in `localStorage`,
    it will return `null`. If you try to add a value to `localStorage` and there is
    not enough memory left, you will get a `QUOTA_EXCEEDED_ERR` exception.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试使用在`localStorage`中不存在的键获取值，它将返回`null`。如果尝试向`localStorage`添加值并且内存不足，将会收到`QUOTA_EXCEEDED_ERR`异常。
- en: 'There are a few limitations to `localStorage`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`有一些限制：'
- en: The user doesn't necessarily have access to anything stored there (although
    it can be accessed through the browser's developer tools).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不一定可以访问存储在其中的任何内容（尽管可以通过浏览器的开发人员工具访问）。
- en: It is shared by all applications in a domain, so the storage limit is shared
    among all of your applications. This also means that all of your keys among all
    of your applications must be unique. If two applications use the same key they
    will end up overwriting each other's data.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它由域中的所有应用程序共享，因此存储限制在所有应用程序之间共享。这也意味着在所有应用程序中，所有键都必须是唯一的。如果两个应用程序使用相同的键，它们最终会覆盖彼此的数据。
- en: Both keys and values must be strings. If you want to store something that is
    not a string, you must convert it to a string first. When you pull that value
    out of storage you must convert it back from a string to the type you're expecting.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键和值都必须是字符串。如果要存储的内容不是字符串，必须先将其转换为字符串。当您从存储中取出该值时，必须将其从字符串转换回您期望的类型。
- en: Fortunately for us, JavaScript has a utility object called JSON that provides
    functions to convert values to and from strings. **JSON** stands for **JavaScript
    Object Notation** and is the standard for representing values as strings in a
    readable format. It is a subset of object literal notation in JavaScript, so if
    you know how to define object literals you know JSON. The JSON object has two
    methods; `JSON.stringify()` to convert a value to a string, and `JSON.parse()`
    to convert a string back into a value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript有一个叫做JSON的实用对象，它提供了将值转换为字符串和从字符串转换回值的函数。**JSON**代表**JavaScript对象表示法**，是以可读格式表示值的标准。它是JavaScript中对象文字表示法的子集，因此如果您知道如何定义对象文字，您就知道JSON。JSON对象有两种方法;
    `JSON.stringify()`将值转换为字符串，`JSON.parse()`将字符串转换回值。
- en: Time for action – creating a localStorage wrapper
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建一个localStorage包装器
- en: To help get around some of the limitations of `localStorage` we are going to
    create an object called `AppStorage` that provides a wrapper over the `localStorage`
    object. The `AppStorage` object will help us avoid key collisions and provide
    an easy way to store non-string values. Let's define this object in a new file
    called `appStorage.js`, so we can reuse it in all of our applications. You can
    find the code for this section in `Chapter 1/example1.3`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决`localStorage`的一些限制，我们将创建一个名为`AppStorage`的对象，它提供了对`localStorage`对象的包装。`AppStorage`对象将帮助我们避免键冲突，并提供一种简单的方法来存储非字符串值。让我们在一个名为`appStorage.js`的新文件中定义这个对象，这样我们可以在所有应用程序中重用它。您可以在`第1章/示例1.3`中找到这一部分的代码。
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The constructor takes in the application name as a parameter. The next line
    sets a private variable named `prefix` that will be used to prefix all of our
    keys with the application name to avoid collisions. If an `appName` parameter
    is not provided, it will not use a prefix, which could be useful for data shared
    among all your applications. If we pass in `"myApp"` to the constructor, all of
    the keys for our app will start with `"myApp"` (for example, `myApp.settings`
    or `myApp.data`).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数以应用程序名称作为参数。下一行设置了一个名为`prefix`的私有变量，它将用于为所有键添加应用程序名称前缀，以避免冲突。如果未提供`appName`参数，则不会使用前缀，这对于在所有应用程序之间共享数据可能很有用。如果我们将`"myApp"`传递给构造函数，我们应用程序的所有键将以`"myApp"`开头（例如，`myApp.settings`或`myApp.data`）。
- en: 'This next line creates a public variable that is used to determine if `localStorage`
    is supported by the browser. It simply checks to see if the global `localStorage`
    object exists:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行创建了一个公共变量，用于确定浏览器是否支持`localStorage`。它只是检查全局`localStorage`对象是否存在：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s implement the `setValue()` method used to set values in local storage
    first:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现`setValue()`方法，用于在本地存储中设置值：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `setValue()` method takes a key and a value to put into local storage. It
    prepends the application prefix to the key to help avoid naming collisions. Since
    you can only put strings into local storage we use the `JSON.stringify()` method
    to convert the value to a string, and then call `localStorage.setItem()` to store
    it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`setValue()`方法接受一个键和一个要放入本地存储的值。它在键前面添加应用程序前缀，以避免命名冲突。由于您只能将字符串放入本地存储，我们使用`JSON.stringify()`方法将值转换为字符串，然后调用`localStorage.setItem()`进行存储。'
- en: 'Now let''s implement the `getValue()` method to get values from `localStorage`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`getValue()`方法来从`localStorage`中获取值：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `getValue()` method takes a key, prepends the prefix to it, and returns
    the string value associated with it in `localStorage`. It uses `JSON.parse()`
    to parse the string retrieved from `localStorage` into a value. If the key doesn't
    exist or local storage is not supported, these methods return `null`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValue()`方法接受一个键，将前缀添加到它，并返回与之在`localStorage`中关联的字符串值。它使用`JSON.parse()`将从`localStorage`中检索到的字符串解析为值。如果键不存在或不支持本地存储，这些方法将返回`null`。'
- en: 'The next thing we need is a way to remove items. Let''s implement the `removeValue()`
    method to do that. It simply calls `localStorage.removeItem()` passing in the
    prefixed key:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一步是删除项目的方法。让我们实现`removeValue()`方法来做到这一点。它只是调用`localStorage.removeItem()`，传入带前缀的键：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'While we''re at it, let''s add a method to remove all keys for an application.
    `localStorage` does have a `clear()` method, but that completely empties out `localStorage`
    for your domain, not just the values for our application. So we need to get all
    of the keys for our application and then delete them one-by-one:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，让我们添加一个方法来删除应用程序的所有键。`localStorage`确实有一个`clear()`方法，但这会完全清空您域中的`localStorage`，而不仅仅是我们应用程序的值。因此，我们需要获取我们应用程序的所有键，然后逐个删除它们：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `removeAll()` method references a `getKeys()` method. This method will
    return an array of all key names for the application. We will make the `getKeys()`
    method, so the user can also pass in a filter function to further filter the results
    by their own criteria if they wish:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeAll()`方法引用了一个`getKeys()`方法。这个方法将返回应用程序的所有键名数组。我们将制作`getKeys()`方法，这样用户也可以传入一个过滤函数，以便根据自己的标准进一步过滤结果：'
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method works by looping over all of the keys in `localStorage`, which you
    can get in the same way that you get all of the keys in an object or array, by
    implementing a loop using the `in` keyword. It calls the private method `isAppKey()`
    to determine if the key belongs to our application. If so, it removes the application
    prefix from the key. Lastly, if no filter is defined or the filter function returns
    `true`, add the key to the array of keys to pass back.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法通过循环遍历`localStorage`中的所有键来工作，你可以通过实现使用`in`关键字的循环来获取对象或数组中的所有键，它调用私有方法`isAppKey()`来确定键是否属于我们的应用程序。如果是，它会从键中移除应用程序前缀。最后，如果没有定义过滤器或过滤器函数返回`true`，则将键添加到要返回的键数组中。
- en: The private `isAppKey()` method takes a key name as the parameter and returns
    `true` if the key belongs to our application. If an application name prefix is
    not defined there's nothing to check. Otherwise we check to see if the key starts
    with the application prefix.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的`isAppKey()`方法以键名作为参数，并在键属于我们的应用程序时返回`true`。如果未定义应用程序名称前缀，则没有要检查的内容。否则，我们检查键是否以应用程序前缀开头。
- en: 'There''s one last public method we need to write. The `contains()` method will
    determine if there is a value associated with a key. It simply tries to get the
    value associated with the key and checks to see if it exists:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写最后一个公共方法。`contains()`方法将确定与键关联的值是否存在。它只是尝试获取与键关联的值并检查是否存在：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*What just happened?*'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚发生了什么？*'
- en: We created a wrapper object called `AppStorage` over the HTML5 `localStorage`
    object. It encapsulates all of the behavior for interacting with `localStorage`
    and saving JavaScript objects to it. Now we can save any type of data to `localStorage`
    and then retrieve it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`AppStorage`的包装对象，它包装了HTML5`localStorage`对象。它封装了与`localStorage`交互和保存JavaScript对象的所有行为。现在我们可以将任何类型的数据保存到`localStorage`中，然后检索它。
- en: Time for action – storing the tasklist
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-存储任务列表
- en: 'Let''s get back to the tasklist application. First we''ll add a reference to
    `appStorage.js` in our HTML file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到任务列表应用程序。首先在我们的HTML文件中添加对`appStorage.js`的引用：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next we''ll add a private `appStorage` variable to the `TaskAtHandApp` object,
    passing in the name of the application to the constructor:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`TaskAtHandApp`对象中添加一个私有的`appStorage`变量，并将应用程序的名称传递给构造函数：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now let''s add a private method that can be called to save the tasks whenever
    a change is made:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个私有方法，可以在每次更改时调用以保存任务：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `saveTaskList()` method finds all of the task name `<span>` elements for
    each task in the list. Then it calls the jQuery `each()` method, which is used
    to iterate over the elements that were found by the select. The `each()` method
    takes a function as a parameter and calls that function for each element. Our
    function simply pushes the task name onto the end of the tasks array. Then we
    call `appStorage.setValue()` telling it to store the tasks array using the key
    `"taskList"`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveTaskList()`方法查找列表中每个任务的任务名称`<span>`元素。然后调用jQuery的`each()`方法，用于迭代由选择找到的元素。`each()`方法接受一个函数作为参数，并为每个元素调用该函数。我们的函数只是将任务名称推送到任务数组的末尾。然后我们调用`appStorage.setValue()`，告诉它使用键`"taskList"`存储任务数组。'
- en: 'Now we need to add a call to `saveTaskList()` every time the list changes.
    That would be in the `addTask()` and `onChangeTaskName()` methods. Also, in `addTaskElement()`
    we need to call it from the button click event handlers for `delete`, `move-up`,
    and `move-down`. To make things easier to read, let''s do a little refactoring
    for the button event handlers by moving the inline handler code out to private
    methods:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在列表更改时每次调用`saveTaskList()`。这将在`addTask()`和`onChangeTaskName()`方法中进行。此外，在`addTaskElement()`中，我们需要在`delete`、`move-up`和`move-down`的按钮点击事件处理程序中调用它。为了使事情更容易阅读，让我们通过将内联处理程序代码移出到私有方法中进行一些重构：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s take a look at this in Chrome now. Go ahead and add a few tasks then
    press *F12* to open developer tools. If you click on the **Resources** icon at
    the top of the window you will see a list of resources in the left pane. Expand
    the **Local Storage** item and click on the item under it. You should see all
    of the data that is stored in local storage for your domain in the right pane:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在Chrome中看一下这个。继续添加一些任务，然后按*F12*打开开发者工具。如果您点击窗口顶部的**资源**图标，您将在左窗格中看到资源列表。展开**本地存储**项目，然后单击其下的项目。您应该在右窗格中看到存储在本地存储中的域中的所有数据：
- en: '![Time for action – storing the tasklist](img/5947OT_01_01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-存储任务列表](img/5947OT_01_01.jpg)'
- en: In the **Key** column you should find `taskAtHand.taskList` and see the JSON
    that represents our list of tasks in the **Value** column, which as you may recall
    is stored as an array.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Key**列中，您应该找到`taskAtHand.taskList`，并在**Value**列中看到代表我们任务列表的JSON，正如您可能记得的那样，它存储为数组。
- en: Now go ahead and play around with it. Try adding, removing, editing, and moving
    tasks around. You should see the value in local storage get updated after every
    change. We now have a persistent tasklist.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续玩一下。尝试添加、删除、编辑和移动任务。您应该在每次更改后看到本地存储中的值更新。我们现在有一个持久的任务列表。
- en: Some browsers don't allow access to `localStorage` when using the `file://`
    protocol (that is, you opened the file directly from the file system into your
    browser). If your `localStorage` isn't working, try it in another web browser
    or access your application through a web server, such as IIS or Apache.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`file://`协议时，一些浏览器不允许访问`localStorage`（也就是说，您直接从文件系统打开文件到浏览器）。如果您的`localStorage`不起作用，请尝试在另一个网络浏览器中使用，或者通过诸如IIS或Apache之类的网络服务器访问您的应用程序。
- en: Time for action – loading the tasklist
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-加载任务列表
- en: 'We have the tasklist saved. But that doesn''t do us much good if we can''t
    load it. So let''s add a new private method called `loadTaskList()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经保存了任务列表。但如果我们无法加载它，那对我们来说没有太大用处。所以让我们添加一个名为`loadTaskList()`的新私有方法：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This method calls `appStorage.getValue()` passing in the key for our tasklist.
    Then it checks to make sure we got something back. If so, it iterates over all
    of the tasks in the array calling the `addTaskElement()` method for each one.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用`appStorage.getValue()`，传入我们任务列表的键。然后检查确保我们得到了一些东西。如果是这样，它会遍历数组中的所有任务，为每个任务调用`addTaskElement()`方法。
- en: 'The only thing left to do is add a call to `loadTaskList()` from the `start()`
    method, so the list is loaded when the application starts:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情是在`start()`方法中添加一个调用`loadTaskList()`，这样在应用程序启动时加载列表：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*What just happened?*'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We used the `AppStorage` object in our tasklist application to store the tasklist
    to `localStorage` any time something changes, and then retrieve it and build the
    tasklist when the user returns.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务列表应用程序中，我们使用`AppStorage`对象将任务列表存储到`localStorage`中，每当有变化时，然后在用户返回时检索它并构建任务列表。
- en: Have a go hero
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: Write a local storage browser application that can be used to look at the data
    for each application in your domain. At the top level, list all of the applications.
    When you drill down into the application, it shows all of its local storage items.
    When you click an item, it shows the contents of that item.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个本地存储浏览器应用程序，用于查看域中每个应用程序的数据。在顶层，列出所有应用程序。当您深入到应用程序时，它会显示所有本地存储项。当您单击一个项目时，它会显示该项目的内容。
- en: Pop quiz
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验
- en: Q1\. What are the three basic components of an HTML5 application?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. HTML5应用程序的三个基本组件是什么？
- en: jQuery, templates, and local storage
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: jQuery、模板和本地存储
- en: Document, object, and model
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档、对象和模型
- en: Tags, elements, and attributes
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签、元素和属性
- en: HTML, CSS, and JavaScript
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML、CSS和JavaScript
- en: Q2\. What type of data can be stored in local storage?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 本地存储可以存储哪些类型的数据？
- en: Any type
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何类型
- en: Objects
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象
- en: Numbers
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字
- en: Strings
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'There you have it. We now have our first HTML5 application under our belts.
    A tasklist where we can add, remove, and edit tasks. The tasks are persisted,
    so that when the user returns to the application they can continue from where
    they left off. We covered the following concepts in this chapter:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们现在已经完成了我们的第一个HTML5应用程序。一个任务列表，我们可以添加、删除和编辑任务。任务是持久的，所以当用户返回应用程序时，他们可以从他们离开的地方继续。在本章中，我们涵盖了以下概念：
- en: We learned the basics of building an HTML5 application and its three components,
    HTML, CSS, and JS
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了构建HTML5应用程序及其三个组件，HTML、CSS和JS的基础知识。
- en: We created an application template to help us get new applications started quickly
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个应用程序模板，以帮助我们快速启动新应用程序。
- en: We learned how to use jQuery to access and manipulate the DOM
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了如何使用jQuery来访问和操作DOM。
- en: We learned how to initialize a web application and handle user interaction
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了如何初始化一个Web应用程序并处理用户交互。
- en: We learned how to create HTML templates so we can define reusable element structures
    in markup
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了如何创建HTML模板，以便我们可以在标记中定义可重用的元素结构。
- en: We learned how to use Web Storage to save and retrieve the state of an application,
    and created an `AppStorage` object to help us access `localStorage`
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了如何使用Web Storage来保存和检索应用程序的状态，并创建了一个`AppStorage`对象来帮助我们访问`localStorage`。
- en: Now that we've learned the basics of creating HTML5 applications and have our
    tasklist application working, we're ready to do some styling. In the next chapter,
    we will learn about some of the new CSS3 features that will make our application
    look as good, or better than, any desktop app.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了创建HTML5应用程序的基础知识，并且我们的任务列表应用程序正在运行，我们准备开始一些样式设计。在下一章中，我们将学习一些新的CSS3功能，这些功能将使我们的应用程序看起来和任何桌面应用程序一样好，甚至更好。
