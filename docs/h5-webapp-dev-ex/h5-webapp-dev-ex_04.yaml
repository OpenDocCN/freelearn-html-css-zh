- en: Chapter 4. A Blank Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。一块空白画布
- en: '"It''s so fine and yet so terrible to stand in front of a blank canvas."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “站在一块空白的画布前，既美好又可怕。”
- en: '*—Paul Cezanne*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*—保罗·塞尚*'
- en: '*In this chapter we are heading out in a whole new direction. We will learn
    how to use the new HTML5 canvas element and API by creating a simple drawing application.
    Our application will use the canvas basics such as strokes, paths, lines, and
    shapes. We will create a toolbar using custom data attributes, which we learned
    in the previous chapter, to bind menu items to actions in our code.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将朝着一个全新的方向前进。我们将学习如何使用新的 HTML5 画布元素和API，创建一个简单的绘图应用程序。我们的应用程序将使用画布基础知识，如笔画、路径、线条和形状。我们将使用在上一章中学到的自定义数据属性创建一个工具栏，将菜单项绑定到我们代码中的操作。*'
- en: 'We will learn the following in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中学习以下内容：
- en: The canvas element and its drawing API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画布元素及其绘图API
- en: How to get a canvas context and what are its global properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取画布上下文及其全局属性
- en: How to draw lines, rectangles, and other shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绘制线条、矩形和其他形状
- en: How to get the position of the mouse inside a canvas element
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取画布元素内鼠标的位置
- en: How to create a toolbar that contains drop-down menus
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建包含下拉菜单的工具栏
- en: How to use custom data attributes to bind toolbar actions to JavaScript code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用自定义数据属性将工具栏操作绑定到 JavaScript 代码
- en: HTML5 canvas
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5 画布
- en: Probably one of the most exciting new features of HTML5 is the canvas. You can
    use it to create drawings anywhere on a web page. The only way to do this previously
    was by using some other technology such as Flash, SVG, or some other browser plugin.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 最令人兴奋的新功能之一可能就是画布。您可以使用它在网页的任何位置创建绘图。以前唯一的方法是使用其他技术，如 Flash、SVG 或其他浏览器插件。
- en: The HTML5 canvas is both an element and an API. The `<canvas>` element defines
    a rectangular area of a web page where graphics can be drawn. The canvas API works
    with a `<canvas>` element to provide the JavaScript interface to draw on the canvas.
    It is a low-level set of functions for drawing lines, rectangle, circles, and
    other graphic primitives.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 画布既是一个元素，也是一个API。`<canvas>`元素定义了网页的一个矩形区域，可以在其中绘制图形。画布API与`<canvas>`元素一起工作，提供了在画布上绘制的
    JavaScript 接口。它是一组用于绘制线条、矩形、圆形和其他图形基元的低级函数。
- en: 'The `<canvas>` element itself is very simple. You must set the `width` and
    `height` attributes to specify its size. You can optionally put content inside
    the `<canvas>` element to be displayed for browsers that don''t support it. The
    good news is that the HTML5 `<canvas>` element is widely supported by nearly every
    modern browser. The following code creates a canvas element 600 pixels wide and
    400 pixels high:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`<canvas>`元素本身非常简单。您必须设置`width`和`height`属性来指定其大小。您还可以选择将内容放在`<canvas>`元素内，以便在不支持它的浏览器中显示。好消息是，几乎每个现代浏览器都广泛支持
    HTML5 的`<canvas>`元素。以下代码创建一个宽度为600像素，高度为400像素的画布元素：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you set the width and height of a `<canvas>` element in CSS to something
    other than the size specified on the element, it will stretch or shrink the drawing
    in the canvas to fit, which may compromise on the image quality.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 CSS 中将`<canvas>`元素的宽度和高度设置为元素上指定的大小之外的值，它将拉伸或缩小画布中的绘图以适应，这可能会影响图像质量。
- en: Getting a context
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取上下文
- en: 'The canvas API is accessed via a canvas context object. You get the context
    by calling the `getContext()` method of the `<canvas>` element, passing in a string
    parameter that defines the type of the context you want:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过画布上下文对象访问画布API。通过调用`<canvas>`元素的`getContext()`方法，传入一个字符串参数来定义您想要的上下文类型，来获取上下文：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only valid context type parameter you can pass into `getContext()` at this
    time is `"2d"`. This begs the question, "Is there a 3D context?" The answer is
    *no*, there is not. But we can always hope for one in the future.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您目前可以传递给`getContext()`的唯一有效上下文类型参数是`"2d"`。这引出了一个问题，“是否有3D上下文？”答案是否定的。但我们总是可以期待未来会有一个。
- en: Canvas basics
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布基础知识
- en: In this section we will learn some of the basics of using the canvas API. Now
    that we have a context, we can call its methods to draw lines and shapes. The
    API has a whole host of methods that let you draw everything from the most basic
    lines, to shapes, and even bitmap images.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用画布API的一些基础知识。现在我们有了上下文，我们可以调用其方法来绘制线条和形状。API具有一系列方法，让您可以绘制从最基本的线条到形状，甚至位图图像的一切。
- en: You can find the source code for this section in `chapter4/canvas-examples/canvas-examples.html`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter4/canvas-examples/canvas-examples.html`中找到此部分的源代码。
- en: Clearing the canvas
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除画布
- en: The background of the canvas is transparent. Whatever background color you specify
    for the canvas element in your CSS will show through. You can clear the canvas,
    or a portion of it, using the context's `clearRect()` method. It takes *x*, *y*,
    width, and height parameters and clears that part of the canvas.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 画布的背景是透明的。您在 CSS 中为画布元素指定的任何背景颜色都会显示出来。您可以使用上下文的`clearRect()`方法清除画布或其部分。它接受*x*、*y*、宽度和高度参数，并清除画布的那一部分。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Context properties
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文属性
- en: By default, when you draw on the canvas, lines are one pixel wide and the color
    is black. You can change these by setting global properties on the `context` object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当您在画布上绘制时，线条宽度为一像素，颜色为黑色。您可以通过在`context`对象上设置全局属性来更改这些属性。
- en: '`penWidth`: This property sets the width that lines will be drawn with. It
    can be any decimal number. For example, you can have a line that is 1.5 pixels
    wide.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`penWidth`：此属性设置绘制线条的宽度。它可以是任何小数。例如，您可以有一条宽度为1.5像素的线。'
- en: '`strokeStyle`: This property sets the color that will be used to draw lines.
    It can be any one of the CSS color specifiers. For example, to draw in red you
    could use `red` or `#FF0000`, `rgb(255, 0, 0)`, or `rgba(255, 0, 0, 1)`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strokeStyle`：此属性设置用于绘制线条的颜色。它可以是 CSS 颜色规范符之一。例如，要用红色绘制，您可以使用`red`或`#FF0000`、`rgb(255,
    0, 0)`或`rgba(255, 0, 0, 1)`。'
- en: '`fillStyle`: This property sets the color that will be used to fill shapes.
    Like `strokeStyle` it can be any CSS color specifier.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillStyle`：此属性设置用于填充形状的颜色。与`strokeStyle`一样，它可以是任何CSS颜色规范。'
- en: '`globalAlpha`: This property sets the alpha or transparency amount to draw
    with. It can be any number from 0 to 1, where 0 is completely transparent and
    1 is completely opaque.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`globalAlpha`：此属性设置要绘制的alpha或透明度量。它可以是从0到1的任何数字，其中0是完全透明的，1是完全不透明的。'
- en: '`lineCap`: This property determines how the ends of lines are drawn. It can
    be one of the following:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lineCap`：此属性确定线的端点如何绘制。它可以是以下之一：'
- en: '`butt` draws a flat end'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`butt`绘制一个平角'
- en: '`round` draws a rounded end'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`round`绘制一个圆形的末端'
- en: '`square` draws a square end'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`square`绘制一个方形的末端'
- en: '`square` looks similar to `butt` except that it has an extra rectangle drawn
    at the end, making it longer.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`square`看起来类似于`butt`，只是它在末端多画了一个矩形，使它更长。'
- en: '![Context properties](img/5947OT_04_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![上下文属性](img/5947OT_04_05.jpg)'
- en: '`lineJoin`: This property determines how corners are drawn where two lines
    meet. It can be one of the following:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lineJoin`：此属性确定两条线相交的地方如何绘制角。它可以是以下之一：'
- en: '`bevel` draws a beveled or flat corner'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevel`绘制一个斜角或平角'
- en: '`round` draws a rounded corner'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`round`绘制圆角'
- en: '`miter` draws a sharp corner'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`miter`绘制一个尖角'
- en: '![Context properties](img/5947OT_04_06.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![上下文属性](img/5947OT_04_06.jpg)'
- en: Canvas pad
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas pad
- en: Now that we know the basics of the canvas API, let's use our newfound knowledge
    to create a drawing application called **canvas pad**. We'll start off with an
    application that draws black lines, like drawing with a pen on paper. Then we
    will add a toolbar and menus so that the user can change options such as width,
    opacity, color, and select different drawing tools.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了画布API的基础知识，让我们利用我们新获得的知识来创建一个名为**canvas pad**的绘图应用程序。我们将从一个绘制黑色线条的应用程序开始，就像在纸上用笔画一样。然后我们将添加一个工具栏和菜单，以便用户可以更改选项，如宽度、不透明度、颜色，并选择不同的绘图工具。
- en: Time for action – creating a canvas pad
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建画布垫
- en: You can find the source code for this section at `chapter4/example4.1`. Let's
    start by copying our application template that we created in the first chapter
    and renaming the file names to `canvasPad.html`, `canvasPad.css`, and `canvasPad.js`.
    Then we'll go in and change the links in the HTML for those files. Finally we
    change the main application object in the JavaScript to `CanvasPadApp`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter4/example4.1`中找到本节的源代码。让我们从第一章创建的应用程序模板中复制，并将文件名更改为`canvasPad.html`、`canvasPad.css`和`canvasPad.js`。然后我们进入并更改HTML中这些文件的链接。最后，我们将JavaScript中的主应用程序对象更改为`CanvasPadApp`。
- en: 'Now let''s add a `<canvas>` element to the HTML right inside the `<div id="main">`
    element and size it to 600 by 400:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在HTML中的`<div id="main">`元素内部添加一个`<canvas>`元素，并将其大小设置为600乘以400：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next we''ll add some styles to the CSS to center the canvas on the page and
    give it a white background. We''ll also use a `box-shadow` element to make it
    stand out:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在CSS中添加一些样式，将画布居中显示在页面上，并给它一个白色背景。我们还将使用`box-shadow`元素使其突出显示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to encapsulate our interaction with the canvas we are going to create
    a new object called `Canvas2D` and put it in a file named `canvas2d.js`. In this
    object we will create some higher level drawing functions. This object''s constructor
    takes a `<canvas>` element wrapped in a jQuery object as a parameter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装我们与画布的交互，我们将创建一个名为`Canvas2D`的新对象，并将其放在一个名为`canvas2d.js`的文件中。在这个对象中，我们将创建一些更高级的绘图函数。这个对象的构造函数以一个包装在jQuery对象中的`<canvas>`元素作为参数：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing the constructor does is set some private variables. We get the
    context, width, and height from the `$canvas` jQuery object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的第一件事是设置一些私有变量。我们从`$canvas` jQuery对象中获取上下文、宽度和高度。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can get access to the underlying element that a jQuery object wraps by using
    square brackets such as an array. So in this case `$canvas[0]` gives us the first
    (and only) `<canvas>` element.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用方括号（如数组）访问jQuery对象包装的基础元素。因此，在这种情况下，`$canvas[0]`给我们第一个（也是唯一的）`<canvas>`元素。
- en: '*What just happened?*'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a new canvas pad application from our template and added a canvas
    to it. We centered the canvas on the page and gave it an all-over shadow to frame
    it and make it appear to float on top of the page. Finally, we created a `Canvas2D`
    object to encapsulate interaction with the canvas.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的模板中创建了一个新的画布垫应用程序，并向其添加了一个画布。我们将画布居中显示在页面上，并给它一个全面的阴影来框定它，并使其看起来浮在页面的顶部。最后，我们创建了一个`Canvas2D`对象来封装与画布的交互。
- en: Time for action – showing the coordinates
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 显示坐标
- en: The first thing we will implement in our `Canvas2D` object is a way to convert
    page coordinates to canvas coordinates. Then we will use that to show the mouse
    coordinates on the page as the user moves their mouse over the canvas.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Canvas2D`对象中要实现的第一件事是将页面坐标转换为画布坐标的方法。然后我们将使用它来在用户在画布上移动鼠标时在页面上显示鼠标坐标。
- en: The problem with mouse coordinates is that they are always offset from the top
    left of the web page. To get the canvas coordinates we need to find the offset
    of the `<canvas>` element on the page and subtract it from the page coordinates.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标坐标的问题在于它们总是相对于网页的左上角偏移。为了获得画布坐标，我们需要找到页面上`<canvas>`元素的偏移量，并从页面坐标中减去它。
- en: 'First we need a variable named `pageOffset` to hold the offset of the canvas
    element. We''ll set its value using jQuery''s `offset()` method, which gets the
    page offset of an element. It returns an object with `left` and `top` fields:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个名为`pageOffset`的变量来保存画布元素的偏移量。我们将使用jQuery的`offset()`方法来设置它的值，该方法获取元素的页面偏移量。它返回一个带有`left`和`top`字段的对象：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we add a `getCanvasPoint()` method. It takes the `pageX` and `pageY` parameters,
    subtracts the canvas element offsets, and returns a new object with `x` and `y`
    fields to hold the adjusted coordinates:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一个`getCanvasPoint()`方法。它接受`pageX`和`pageY`参数，减去画布元素的偏移量，并返回一个新对象，其中包含`x`和`y`字段来保存调整后的坐标：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since our canvas is centered on the page, whenever the size of the window changes
    the offset of the canvas will change as well. So we need to add a `resize` event
    handler to the window so that whenever it changes the `pageOffset` variable gets
    updated:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的画布位于页面中心，每当窗口大小发生变化时，画布的偏移量也会发生变化。因此，我们需要向窗口添加一个`resize`事件处理程序，以便在其发生变化时更新`pageOffset`变量：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s add the code to show the mouse coordinates in the status bar when
    the user moves the mouse over the canvas. First we need an instance of the `Canvas2D`
    object in our application''s main class, `CanvasPadApp`. We will assign it to
    a private variable named `canvas2d`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加代码，当用户在画布上移动鼠标时，在状态栏中显示鼠标坐标。首先，我们需要在我们应用程序的主类`CanvasPadApp`中创建`Canvas2D`对象的实例。我们将把它赋给一个名为`canvas2d`的私有变量：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will show the coordinates in the `<footer>` element below the canvas. Let''s
    add a `<span>` in the footer to hold the coordinates:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在画布下方的`<footer>`元素中显示坐标。让我们在页脚中添加一个`<span>`来保存坐标：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next we add a `mousemove` event handler to the `<canvas>` element in the `start()`
    method. It will call `onMouseMove` when the mouse is moved:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`start()`方法中为`<canvas>`元素添加一个`mousemove`事件处理程序。当鼠标移动时，它将调用`onMouseMove`：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `onMouseMove` event handler calls the `canvas2d.getCanvasPoint()` method
    passing in the page coordinates from the mouse event. It gets back the position
    of the mouse on the canvas and passes that into the `showCoordinates()` method
    to display them in the footer:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMouseMove`事件处理程序调用`canvas2d.getCanvasPoint()`方法，传入鼠标事件的页面坐标。它返回画布上鼠标的位置，并将其传递给`showCoordinates()`方法以在页脚中显示它们：'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `showCoordinates()` method uses jQuery's `text()` method to put the coordinates
    into the footer. Now if you move the mouse over the canvas on the page you will
    see the coordinates change. When you move the mouse to the top-left corner it
    should display **(0, 0)**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`showCoordinates()`方法使用jQuery的`text()`方法将坐标放入页脚。现在，如果您在页面上的画布上移动鼠标，您将看到坐标变化。当您将鼠标移动到左上角时，它应该显示**(0,
    0)**。'
- en: '*What just happened?*'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么?*'
- en: We computed the page offset of the mouse on the canvas by subtracting the position
    of the canvas from the mouse coordinates. Then we added a `mousemove` event handler
    to display the coordinates in the footer when the user moves the mouse over the
    canvas.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从鼠标坐标中减去画布的位置来计算鼠标在画布上的页面偏移。然后我们添加了一个`mousemove`事件处理程序，以在用户在画布上移动鼠标时在页脚显示坐标。
- en: Drawing lines
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制线条
- en: The first thing we want to implement is a way for the user to draw simple lines,
    or to scribble on the canvas. To do that we need to get the points when the user
    moves the mouse with the mouse button pressed down and draw lines between them.
    So let's learn how to draw on the canvas.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的第一件事是让用户绘制简单的线条，或者在画布上涂鸦。为此，我们需要在用户按下鼠标按钮并移动鼠标时获取点，并在它们之间绘制线条。所以让我们学习如何在画布上绘制。
- en: Paths and strokes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径和描边
- en: The most primitive way to draw on the canvas is by defining paths and then stroking,
    or drawing them. Think of it as planning what you are going to draw in your head,
    then putting your pen to the paper, and actually drawing it out.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制的最原始的方法是定义路径，然后描边或绘制它们。可以将其视为在脑海中规划要绘制的内容，然后将笔放在纸上，并实际绘制出来。
- en: To create a path you define it by specifying two or more points using `moveTo()`
    and `lineTo()` methods. Then you draw it to the canvas by calling the `stroke()`
    method. There are four basic methods that you use to define and draw paths.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建路径，您需要使用`moveTo()`和`lineTo()`方法指定两个或更多点来定义它。然后通过调用`stroke()`方法将其绘制到画布上。有四种基本方法可用于定义和绘制路径。
- en: '`beginPath()`: This method starts a new path.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beginPath()`:此方法开始一个新路径。'
- en: '`moveTo(x, y)`: This method moves the pen to a new position without drawing.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moveTo(x, y)`:此方法将笔移动到新位置而不绘制。'
- en: '`lineTo(x, y)`: This method draws a line from the previous position to a new
    position.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lineTo(x, y)`:此方法从上一个位置绘制一条线到新位置。'
- en: '`stroke()`:This method draws the path onto the canvas. It is important to note
    that nothing actually gets drawn to the canvas until you call `stroke().`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke()`:此方法将路径绘制到画布上。重要的是要注意，直到调用`stroke()`之前，实际上没有任何东西被绘制到画布上。'
- en: 'The following code draws a line from the point (10, 10) to (80, 100):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从点(10, 10)绘制一条线到(80, 100)：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can make any number of calls to the `moveTo()` and `lineTo()` methods between
    `beginPath()` and `stroke()`. This allows you to queue up a number of drawing
    commands and then commit them to the canvas all at once. If you want your path
    to form a closed shape you can call the `closePath()` method to draw a line from
    the last point to the first point. For example, the following code draws a triangle:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beginPath()`和`stroke()`之间，您可以调用任意次`moveTo()`和`lineTo()`方法。这允许您排队多个绘图命令，然后一次性将它们提交到画布上。如果您希望路径形成一个封闭的形状，可以调用`closePath()`方法以从最后一个点绘制一条线到第一个点。例如，以下代码绘制了一个三角形：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s also possible to fill your shapes by calling the context''s `fill()`
    method instead of `stroke()` . Actually you can call both `fill()` and `stroke()`
    if you want the shape to be outlined in one color and filled with another:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过调用上下文的`fill()`方法而不是`stroke()`来填充形状。实际上，如果您希望形状以一种颜色轮廓并以另一种颜色填充，可以同时调用`fill()`和`stroke()`：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Paths and strokes](img/5947OT_04_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![路径和描边](img/5947OT_04_03.jpg)'
- en: Time for action – using the mouse to draw
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-使用鼠标绘制
- en: 'The first thing we need to do is capture mouse events. Let''s go into our `CanvasPadApp`
    object and add the code to check for them in the `start()` method. As you may
    recall, we already added a `mousemove` event handler above. Now we will add handlers
    for `mousedown`, `mouseup`, and `mouseout` events:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是捕获鼠标事件。让我们进入`CanvasPadApp`对象，并在`start()`方法中添加代码来检查它们。您可能还记得，我们已经添加了`mousemove`事件处理程序。现在我们将为`mousedown`、`mouseup`和`mouseout`事件添加处理程序：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: No, there's not a mistake in `mouseout`. We want the `mouseout` event to be
    handled the same way as `mouseup`, so they both stop the drawing process. The
    `mouseout` event is fired when the mouse leaves the `<canvas>` element. When that
    happens we can't get `mousemove` events anymore and therefore lose track of the
    pen position.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不，`mouseout`中没有错误。我们希望`mouseout`事件与`mouseup`事件以相同的方式处理，因此它们都会停止绘图过程。当鼠标离开`<canvas>`元素时，将触发`mouseout`事件。当这种情况发生时，我们将无法再获取`mousemove`事件，因此无法再跟踪笔的位置。
- en: 'Before we implement the event handlers we need a couple of new variables to
    keep track of things. We need a Boolean value to keep track of when we are drawing,
    an array to keep track of the current set of points, and an array to keep track
    of all the sets of points (we will call them actions):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现事件处理程序之前，我们需要一些新变量来跟踪事物。我们需要一个布尔值来跟踪我们何时在绘制，一个数组来跟踪当前的点集，以及一个数组来跟踪所有的点集（我们将它们称为动作）：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you give your global object variables default values it will make
    it easier for code editors that have an autocomplete feature to figure out what
    the type of the variable is and give you the appropriate suggestions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您给全局对象变量设置默认值，它将使具有自动完成功能的代码编辑器更容易确定变量的类型，并为您提供适当的建议。
- en: 'First let''s implement `onMouseDown()` since this starts the drawing process.
    It takes one parameter, which is the mouse event object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们实现`onMouseDown()`，因为这会启动绘图过程。它接受一个参数，即鼠标事件对象：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing we do in the `onMouseDown()`method is call `preventDefault()`
    on the mouse event object. This will stop the system from doing the default mouse
    down behavior, part of which is to change the mouse cursor icon. We want it to
    remain a cross icon, which we previously set in the CSS. Then we call `penDown()`
    passing in the page coordinates of the mouse which we get from the mouse event.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMouseDown()`方法中的第一件事是在鼠标事件对象上调用`preventDefault()`。这将阻止系统执行默认的鼠标按下行为，其中的一部分是更改鼠标光标图标。我们希望它保持为十字光标，这是我们之前在CSS中设置的。然后我们调用`penDown()`，传入鼠标的页面坐标，这些坐标是从鼠标事件中获取的。'
- en: In the `penDown()` method we initialize the drawing process. First, we set the
    `drawing` flag to `true`. Then we create a new array to put the current drawing
    points into it. Then we add the first point to the array after converting it from
    page coordinates to canvas coordinates by calling `getCanvasPoint()` . The final
    thing we do is add the current `points` array to the `actions` array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`penDown()`方法中，我们初始化了绘图过程。首先，我们将`drawing`标志设置为`true`。然后我们创建一个新数组来存放当前的绘图点。然后我们将第一个点添加到数组中，通过调用`getCanvasPoint()`将其从页面坐标转换为画布坐标。我们做的最后一件事是将当前的`points`数组添加到`actions`数组中。
- en: 'The next step in the drawing process is to handle `mousemove` events, so let''s
    rewrite the `onMouseMove()` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图过程中的下一步是处理`mousemove`事件，所以让我们重写`onMouseMove()`方法：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now `onMouseMove()`calls `penMoved()` passing it the mouse coordinates. The
    `penMoved()` method first converts the coordinates then calls `showCoordinates()`
    as it did before. Then we check if the `drawing` flag is set. This was set in
    the `penDown()` method so we know that the mouse button is down. If the user is
    drawing then we add the current point to the array of points and call `redraw()`,
    which we will implement next:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`onMouseMove()`调用`penMoved()`，传递鼠标坐标。`penMoved()`方法首先转换坐标，然后像以前一样调用`showCoordinates()`。然后我们检查`drawing`标志是否已设置。这是在`penDown()`方法中设置的，所以我们知道鼠标按钮已按下。如果用户正在绘制，那么我们将当前点添加到点数组中并调用`redraw()`，接下来我们将实现它：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `redraw()` method first clears the canvas by calling `canvas2d.clear()`,
    which we will write next, then it iterates over all of the actions and calls `drawPoints()`
    passing in the set of points for each action.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`redraw()`方法首先通过调用`canvas2d.clear()`清除画布，接下来我们将编写它，然后遍历所有的动作并调用`drawPoints()`，传入每个动作的点集。'
- en: 'Now let''s go into our `Canvas2D` object and add the `clear()` and `drawPoints()`
    methods. First, our `clear()` method calls the `context.clearRect()` method passing
    in the canvas `width` and `height` variables we defined in the `Canvas2D` constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入我们的`Canvas2D`对象并添加`clear()`和`drawPoints()`方法。首先，我们的`clear()`方法调用`context.clearRect()`方法，传入我们在`Canvas2D`构造函数中定义的画布`width`和`height`变量：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, the `drawPoints()` method takes an array of points and draws lines between
    them:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`drawPoints()`方法接受一个点数组并在它们之间绘制线条：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After beginning a new path it calls `moveTo()` to move the pen to the first
    point in the array. Then it iterates over the remaining points in the array calling
    `lineTo()` for each one. When it's done it calls `stroke()` to draw it to the
    canvas.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新路径后，它调用`moveTo()`将笔移动到数组中的第一个点。然后它遍历数组中的其余点，为每个点调用`lineTo()`。完成后，它调用`stroke()`将其绘制到画布上。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For all of the methods in Canvas2D that wouldn't normally return a value we
    will return `this` so we can do function chaining.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Canvas2D中那些通常不返回值的方法，我们将返回`this`，以便我们可以进行函数链接。
- en: 'The last thing we need to implement is the `onMouseUp()` event handler. All
    we need to do here is set the `drawing` flag back to `false`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一件事是`onMouseUp()`事件处理程序。我们在这里需要做的就是将`drawing`标志设置回`false`：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*What just happened?*'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We used mouse events to capture and store drawing actions in a buffer. Then
    we used the canvas API to draw lines to the canvas from those points. Now let's
    open our application in the browser and check it out. We can scribble on the canvas
    using the mouse and create simple line drawings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用鼠标事件来捕获和存储绘图动作到缓冲区中。然后我们使用画布API从这些点绘制线条到画布上。现在让我们在浏览器中打开我们的应用程序并检查一下。我们可以使用鼠标在画布上涂鸦并创建简单的线条图。
- en: '![What just happened?](img/5947OT_04_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_04_08.jpg)'
- en: Changing context properties
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改上下文属性
- en: Let's take our application to the next level by allowing the user to change
    the pen properties such as color, opacity, and width.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过允许用户更改笔属性，如颜色、不透明度和宽度，将我们的应用程序提升到下一个级别。
- en: Time for action – adding context properties
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加上下文属性
- en: 'First let''s add some code to our `Canvas2D` object to allow us to change the
    global context drawing properties. Let''s set some default values in the constructor.
    We will set the pen to black with a width of `4` and make it completely opaque
    by setting `globalAlpha` to `1`. We will set the line joins and caps to round
    to make our lines look smoother:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们在我们的`Canvas2D`对象中添加一些代码，以允许我们更改全局上下文绘图属性。让我们在构造函数中设置一些默认值。我们将笔的颜色设置为黑色，宽度为`4`，并通过将`globalAlpha`设置为`1`使其完全不透明。我们将线连接和端点设置为圆形，使我们的线看起来更加平滑：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next we''ll add public property accessor methods to allow us to set and get
    the value of the color, opacity, and width properties. If a parameter is passed
    into a property method (that is, `arguments.length` is not `0`) it will set the
    value of the property then return `this` so we can do function chaining. Otherwise
    it will return the value of the property:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加公共属性访问器方法，以允许我们设置和获取颜色、不透明度和宽度属性的值。如果参数被传递到属性方法中（即`arguments.length`不是`0`），它将设置属性的值，然后返回`this`，这样我们就可以进行函数链接。否则，它将返回属性的值：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now all we need is a way for the user to change these settings from the application,
    so the next thing we will implement is a toolbar.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一种方式让用户从应用程序中更改这些设置，所以下一步我们将实现的是一个工具栏。
- en: Creating a toolbar
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建工具栏
- en: Our toolbar will need the following buttons. The first three will be used to
    change the properties of the context. The last two will allow us to undo and clear
    the canvas.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具栏将需要以下按钮。前三个将用于更改上下文的属性。最后两个将允许我们撤消和清除画布。
- en: '**Color**: This button displays a drop-down menu where the user can choose
    a pen color'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：这个按钮显示一个下拉菜单，用户可以选择笔的颜色。'
- en: '**Opacity**: This button displays a drop-down menu where the user can choose
    the pen opacity'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不透明度**：这个按钮显示一个下拉菜单，用户可以选择笔的不透明度。'
- en: '**Width**: This button displays a drop-down menu where the user can choose
    the pen width'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽度**：这个按钮显示一个下拉菜单，用户可以选择笔的宽度。'
- en: '**Undo**: This button removes the last drawing action'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤消**：这个按钮移除最后一次绘图操作'
- en: '**Clear**: This button clears the canvas and all drawing actions to start over'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**：这个按钮清除画布和所有绘图操作，重新开始'
- en: Custom data attributes, which we covered in the previous chapter, will be used
    throughout our toolbar to define actions for the toolbar buttons and options for
    our menus. We will use these later in our JavaScript to determine the action or
    option that was selected. Adding a little extra markup now will save us from writing
    a lot of repetitive code later on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义数据属性，我们在上一章中介绍过，将在整个工具栏中使用，用于定义工具栏按钮的操作和菜单选项。我们稍后将在JavaScript中使用这些属性来确定所选的操作或选项。现在添加一些额外的标记将使我们免于以后编写大量重复的代码。
- en: Time for action – creating a toolbar
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建工具栏
- en: You can find the code for this section in `chapter4/example4.2`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter4/example4.2`中找到本节的代码。
- en: 'We''ll define the toolbar in our HTML file just inside the main element and
    above the canvas:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在HTML文件中的主要元素内部定义工具栏，并放在画布的上方：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each toolbar button has a `data-action` custom attribute. This will be used
    in JavaScript to determine which action to take when the button is clicked. For
    the buttons with drop-down menus we set the `data-action` to `"menu"`. The **Undo**
    and **Clear** buttons each have their own unique action values.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工具栏按钮都有一个`data-action`自定义属性。这将在JavaScript中用于确定单击按钮时要执行的操作。对于带有下拉菜单的按钮，我们将`data-action`设置为`"menu"`。**撤消**和**清除**按钮各自有自己独特的操作值。
- en: Since the toolbar items for color, opacity, and width are drop-down menus we
    wrapped them in a `<div class="dropdown-menu">` element. This groups the toolbar
    button and the menu to display when the button is clicked. The menus are defined
    using as an unordered list. Each `<ul>` element is given a class of `menu` and
    a `data-option` custom attribute. The value of this attribute matches to the name
    of a property method in the `Canvas2D` object, for example `penColor()`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于颜色、不透明度和宽度的工具栏项目是下拉菜单，我们将它们包装在`<div class="dropdown-menu">`元素中。这将工具栏按钮和菜单分组在一起，当单击按钮时显示菜单。菜单使用无序列表定义。每个`<ul>`元素都被赋予一个`menu`类和一个`data-option`自定义属性。这个属性的值与`Canvas2D`对象中的属性方法的名称相匹配，例如`penColor()`。
- en: The menu items are defined with `<li>` elements. Each one has a `data-value`
    custom attribute. This is set to the value that will be passed into the property
    method defined by the `data-option` attribute on the menu.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项使用`<li>`元素定义。每个菜单项都有一个`data-value`自定义属性。这个属性设置为将传递到菜单上的`data-option`属性定义的属性方法中的值。
- en: 'Now let''s style the toolbar in CSS:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在CSS中为工具栏设置样式：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First we make the color of the toolbar black with a 50 percent opacity so the
    background color bleeds through. Then we style the buttons to remove the borders
    and background color, and set the text color to white. Now let''s style the drop-down
    menus:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将工具栏的颜色设置为黑色，不透明度为50%，这样背景颜色会透过来。然后我们将样式按钮，去掉边框和背景颜色，并将文本颜色设置为白色。现在让我们为下拉菜单设置样式：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We set the `<div class="dropdown-menu">`wrapper elements to display `inline-block`
    and set the `position` to `relative` so that we can absolutely position the menus
    under them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`<div class="dropdown-menu">`包装元素设置为`inline-block`显示，并将`position`设置为`relative`，这样我们可以绝对定位菜单在它们下方。
- en: For the `<ul>` menu elements first we set `display` to `none` so they are hidden
    by default. Then we set the `position` to `absolute` so they don't take up any
    space in the page. To make them appear below the button instead of over it we
    set `top` to `100%`. Then we give it a shadow to give the illusion of depth. Finally,
    we get rid of the list bullet points by setting `list-style-type` to `none`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`<ul>`菜单元素，首先我们将`display`设置为`none`，这样它们默认是隐藏的。然后我们将`position`设置为`absolute`，这样它们在页面中不占用任何空间。为了使它们出现在按钮下方而不是覆盖在按钮上方，我们将`top`设置为`100%`。然后我们给它添加阴影，以营造深度的错觉。最后，我们通过将`list-style-type`设置为`none`来去掉列表的项目符号。
- en: 'Finally let''s style the menu items:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后让我们为菜单项设置样式：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We give the menu items a minimum width so they don't get too small. We also
    specify a style for the selected menu item to display a circle next to it using
    `list-style-type` and color the background light blue.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给菜单项设置了最小宽度，以防它们变得太小。我们还指定了选定菜单项的样式，使用`list-style-type`显示一个圆圈，并将背景颜色设置为浅蓝色。
- en: '*What just happened?*'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a toolbar in our HTML file with menu items for color, width, and
    opacity. We used custom data attributes to define custom actions that will be
    implemented in our JavaScript. Lastly we styled the menus in our CSS file so they
    line up under their toolbar buttons.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在HTML文件中创建了一个工具栏，其中包含颜色、宽度和不透明度的菜单项。我们使用自定义数据属性来定义将在JavaScript中实现的自定义操作。最后，我们在CSS文件中对菜单进行了样式设置，使它们与工具栏按钮对齐。
- en: Time for action – implementing a reusable toolbar
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-实现可重用的工具栏
- en: 'Now let''s create a new reusable `Toolbar` object that encapsulates the code
    for a toolbar. That way we can also use it in our other applications later on.
    We will put it inside a new file called `toolbar.js`. The constructor will take
    the root element of the toolbar wrapped in a jQuery object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个新的可重用的`Toolbar`对象，封装工具栏的代码。这样我们以后也可以在其他应用程序中使用它。我们将把它放在一个名为`toolbar.js`的新文件中。构造函数将接受包装在jQuery对象中的工具栏的根元素：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Remember how I said in [Chapter 1](ch01.html "Chapter 1. The Task at Hand"),
    *The Task at Hand* that the `this` pointer can cause problems when using event
    handlers with public methods? To get around that we will create a global `_this`
    variable and set it to the object's `this` so it's always available.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我在[第1章](ch01.html "第1章。手头的任务")中说过的吗，*手头的任务*，`this`指针在使用公共方法的事件处理程序时可能会引起问题？为了解决这个问题，我们将创建一个全局的`_this`变量，并将其设置为对象的`this`，这样它就始终可用。
- en: 'First we will implement the public methods. We have two methods that are used
    to notify the application that either a toolbar button or menu item has been clicked.
    In this object they are just placeholders. The client application will override
    them to implement custom behavior:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将实现公共方法。我们有两个方法，用于通知应用程序工具栏按钮或菜单项已被单击。在这个对象中，它们只是占位符。客户端应用程序将覆盖它们以实现自定义行为：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `toolbarButtonClicked()` method takes the button's `data-action` attribute
    as a parameter. The `menuItemClicked()` method takes the menu's `data-option`
    and the menu item's `data-value` attribute as parameters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolbarButtonClicked()`方法将按钮的`data-action`属性作为参数。`menuItemClicked()`方法将菜单的`data-option`和菜单项的`data-value`属性作为参数。'
- en: 'We also need a public method called `hideMenus()` to hide all of the toolbar''s
    drop-down menus. It just finds all of the menu elements and hides them:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个名为`hideMenus()`的公共方法，以隐藏工具栏的所有下拉菜单。它只是找到所有菜单元素并隐藏它们：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next thing we will add is an event handler for all of the toolbar buttons:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将为所有工具栏按钮添加事件处理程序：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When the user clicks a button in the toolbar, it calls the private `onToolbarButtonClicked()`
    method passing it the button that was clicked wrapped in a jQuery object. Let''s
    implement that handler now:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击工具栏中的按钮时，它调用私有的`onToolbarButtonClicked()`方法，将被单击的按钮包装在jQuery对象中传递给它。现在让我们实现这个处理程序：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method gets the value of the `data-action` custom attribute from the button.
    Then it passes it into the public `toolbarButtonClicked()` method. Notice that
    it must use `_this` to call the public methods because `this` is currently pointing
    at the `window` object. If `toolbarButtonClicked()` returns `true` it means that
    the client handled the action and there's nothing else to do. Otherwise it checks
    if the action was `"menu"` and if so, calls `showMenu()` passing in the menu element,
    which is a sibling of the button. If it's not, the menu action it hides all the
    menus.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从按钮中获取`data-action`自定义属性的值。然后将其传递给公共的`toolbarButtonClicked()`方法。请注意，它必须使用`_this`来调用公共方法，因为`this`当前指向`window`对象。如果`toolbarButtonClicked()`返回`true`，这意味着客户端处理了操作，没有其他事情要做。否则，它检查操作是否为`"menu"`，如果是，则调用`showMenu()`，并传入菜单元素，该元素是按钮的兄弟元素。如果不是菜单操作，则隐藏所有菜单。
- en: 'Now let''s write the private `showMenu()` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写私有的`showMenu()`方法：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We use the jQuery `is()` method passing in the `:visible` filter to determine
    if the menu is already showing. If it is, it fades the menu out to hide it. Otherwise
    it hides all of the menus in the toolbar, in case another one is open, and then
    fades the menu in to show it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用jQuery的`is()`方法，传入`:visible`过滤器来确定菜单是否已经显示。如果是，它会淡出菜单以隐藏它。否则，它会隐藏工具栏中的所有菜单，以防其他菜单已经打开，然后淡入菜单以显示它。
- en: 'Next we add the click event handler for all of the menu items:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为所有菜单项添加点击事件处理程序：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the user clicks a menu item in the toolbar it calls `onMenuItemClicked()`
    passing it the menu item that was clicked wrapped in a jQuery object:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在工具栏中单击菜单项时，它调用`onMenuItemClicked()`，并将被单击的菜单项包装在jQuery对象中传递给它：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First we get the parent element which is the menu. Then we get the `data-option`
    attribute from it. Next we get the `data-value` attribute from the menu item itself.
    We pass those values as parameters to the public `menuItemClicked()` method. If
    that method returns `true` it means that the client handled the action and there's
    nothing else to do. Otherwise we add a `"selected"` class to the menu item to
    highlight it and remove the class from all of the other menu items. Then we fade
    the menu out to hide it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们获取菜单的父元素。然后我们从中获取`data-option`属性。接下来我们从菜单项本身获取`data-value`属性。我们将这些值作为参数传递给公共的`menuItemClicked()`方法。如果该方法返回`true`，这意味着客户端处理了操作，没有其他事情要做。否则，我们向菜单项添加一个`"selected"`类来突出显示它，并从所有其他菜单项中删除该类。然后我们淡出菜单以隐藏它。
- en: '*What just happened?*'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a reusable object that encapsulates toolbar behavior including buttons
    and dropdown menus. It uses custom data attributes to define the actions for toolbar
    buttons and menu items. We can use this object in our applications whenever we
    need a toolbar.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个可重用的对象，封装了工具栏行为，包括按钮和下拉菜单。它使用自定义数据属性来定义工具栏按钮和菜单项的操作。我们可以在需要工具栏的应用程序中使用这个对象。
- en: Adding a toolbar
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具栏
- en: Now that we have a `Toolbar` object and the HTML for our toolbar and menus defined
    we can hook up events in our drawing application to handle user interaction.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`Toolbar`对象和我们的工具栏和菜单的HTML定义，我们可以在我们的绘图应用程序中连接事件以处理用户交互。
- en: Time for action – adding the toolbar object
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加工具栏对象
- en: 'Let''s add the `Toolbar` object to our application. First we add a `toolbar`
    variable to `CanvasPadApp` and set it to a new instance of the `Toolbar` object.
    We pass in the toolbar''s root `<div>` element as a parameter to the constructor:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`Toolbar`对象添加到我们的应用程序中。首先，我们向`CanvasPadApp`添加一个`toolbar`变量，并将其设置为`Toolbar`对象的新实例。我们将工具栏的根`<div>`元素作为参数传递给构造函数：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `start()` we override the `toolbar` object''s `toolbarButtonClicked()` and
    `menuItemClicked()` methods to set them to our own implementations to handle those
    events:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start（）`中，我们重写`toolbar`对象的`toolbarButtonClicked（）`和`menuItemClicked（）`方法，将它们设置为我们自己的实现来处理这些事件：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'First let''s implement our `CanvasPadApp.toolbarButtonClicked()` method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们实现我们的`CanvasPadApp.toolbarButtonClicked（）`方法：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When the user clicks the **Clear** button we confirm that they want to clear
    the canvas. If so we set the `actions` array to a new array to clear everything
    out and then call `redraw()`, which clears the canvas.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击**清除**按钮时，我们确认他们是否要清除画布。如果是，我们将`actions`数组设置为一个新数组以清除所有内容，然后调用`redraw()`，这将清除画布。
- en: When the user clicks the **Undo** button it removes the last drawing action
    from the `actions` array, then calls `redraw()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击**撤消**按钮时，它会从`actions`数组中删除最后一个绘图操作，然后调用`redraw（）`。
- en: 'Now let''s implement the `menuItemClicked()` method. It takes two parameters;
    the menu option name and the value of the menu item that was selected:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`menuItemClicked（）`方法。它接受两个参数;菜单选项名称和所选菜单项的值：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you remember from earlier instances, the `data-option` attribute is the name
    of the method that is used to set the property in the `Canvas2D` object. We use
    the square brace method of accessing that method in the object, and then we execute
    it passing the `data-value` attribute from the menu item into it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得之前的实例，`data-option`属性是用于在`Canvas2D`对象中设置属性的方法的名称。我们使用方括号方法访问对象中的该方法，然后我们执行它，将菜单项的`data-value`属性传递给它。
- en: For example, if the user clicked the red menu item in the **Color** menu, the
    `data-option` would be `"penColor"` and the `data-value` would be `"red"`. So
    in this case the statement `canvas2d[option](value)` would be equivalent to calling
    `canvas2d.penColor("red")`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户在**颜色**菜单中单击红色菜单项，则`data-option`将是`“penColor”`，`data-value`将是`“red”`。因此，在这种情况下，语句`canvas2d[option](value)`将等同于调用`canvas2d.penColor（“red”）`。
- en: '*What just happened?*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added the reusable `Toolbar` object we created in the previous section to
    our application and added event handlers to handle toolbar button and menu events.
    Then we implemented the undo and clear actions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们在上一节中创建的可重用的`Toolbar`对象添加到我们的应用程序中，并添加事件处理程序来处理工具栏按钮和菜单事件。然后我们实现了撤消和清除操作。
- en: Time for action – initializing menu items
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-初始化菜单项
- en: 'Next we will initialize the **Color** menu to set the background color of each
    item to the color it represents. We could do that in CSS but it would be cumbersome.
    Instead we are going to write a JavaScript method to set them all with just a
    little bit of code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将初始化**颜色**菜单，将每个项目的背景颜色设置为它所代表的颜色。我们可以在CSS中做到这一点，但这将很麻烦。相反，我们将编写一个JavaScript方法，只需一点点代码就可以设置它们全部：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This gets all of the color menu items and iterates over them using the jQuery
    `each()` method. For each item it sets the background color using the jQuery `css()`
    method to the value of the `data-value` custom attribute, which is a CSS color
    name. Just like that we have a menu of colors.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这会获取所有颜色菜单项，并使用jQuery的`each（）`方法对它们进行迭代。对于每个项目，它使用jQuery的`css（）`方法将背景颜色设置为`data-value`自定义属性的值，这是一个CSS颜色名称。就像这样，我们有了一个颜色菜单。
- en: 'We want to do something similar for the width menu''s items, except we will
    set the bottom border to the width in the `data-value` custom attribute to give
    the user some idea of how big the line will be:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对宽度菜单的项目执行类似的操作，只是我们将底部边框设置为`data-value`自定义属性中的宽度，以便用户了解线条的大小：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will call these two methods from the `start()` method when we're initializing
    the application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化应用程序时，我们将从`start（）`方法中调用这两种方法。
- en: '*What just happened?*'
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We changed the styles for the color and width menu items to give them colors
    and widths respectively so that the user can better see what they are selecting
    from the menus.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了颜色和宽度菜单项的样式，分别为它们设置颜色和宽度，以便用户可以更好地看到他们从菜单中选择了什么。
- en: Now if you open the application in the browser you can change the pen's properties.
    Go ahead and draw a few lines. If you click on **Undo,** the last line is erased.
    When you click on **Clear**, the entire drawing is erased.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在浏览器中打开应用程序，您可以更改笔的属性。继续画几条线。如果单击**撤消**，最后一行将被擦除。当您单击**清除**时，整个图纸都将被擦除。
- en: Adding drawing actions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加绘图操作
- en: You may have noticed that when you changed an option, the next time you drew
    something the options applied to all of the previous lines that were drawn. That's
    not a very good user experience. The user expects that when they change the pen
    options it will only apply to the next thing they draw, not everything.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，当您更改选项时，下次绘制时，选项将应用于以前绘制的所有线条。这不是一个很好的用户体验。用户期望当他们更改笔选项时，它只会应用于他们绘制的下一件事，而不是所有事情。
- en: In order to get that to work properly we will need to add more data to each
    action than just a list of points. We also need to know the color, width, and
    opacity to draw the points with. For that we need an object to hold all of these
    values.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其正常工作，我们需要为每个操作添加更多数据，而不仅仅是一系列点。我们还需要知道颜色，宽度和不透明度以绘制点。为此，我们需要一个对象来保存所有这些值。
- en: Time for action – creating drawing actions
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建绘图操作
- en: 'We will use a factory method to create this object. Let''s add a `newAction()`method
    to `CanvasPadApp` that creates the action object for us with the current drawing
    options set:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个工厂方法来创建这个对象。让我们在`CanvasPadApp`中添加一个`newAction()`方法，用当前的绘图选项设置创建动作对象：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `newAction()` method takes one parameter which is the name of the drawing
    tool the action will use. Next it uses curly braces to define a new object literal.
    The object will hold the tool, the context property values, and the points for
    that action. It gets the current color, width, and opacity settings from our `Canvas2D`
    object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`newAction()`方法接受一个参数，即动作将使用的绘图工具的名称。接下来，它使用大括号定义一个新的对象字面量。该对象将保存工具、上下文属性值和该动作的点。它从我们的`Canvas2D`对象中获取当前颜色、宽度和不透明度设置。'
- en: 'The next thing we need to do is remove the global `points` variable from the
    `CanvasPadApp` object and replace it with a `curAction` variable to hold the current
    action object created by `newAction()`. Let''s also add a `curTool` variable to
    hold the current tool, and set it to `"pen"`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是从`CanvasPadApp`对象中删除全局的`points`变量，并将其替换为一个`curAction`变量，用于保存由`newAction()`创建的当前动作对象。让我们还添加一个`curTool`变量来保存当前工具，并将其设置为`"pen"`：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, wherever we used the `points` variable before we will need to change it
    to use `curAction.points` instead. The first spot is the `penDown()` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们以前在哪里使用`points`变量，我们都需要将其更改为使用`curAction.points`。第一个地方是`penDown()`方法：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First we set `curAction` to a new action object, and then add the first point
    to the `curAction` object's `points` array. Then we add `curAction` to the `actions`
    array.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将`curAction`设置为一个新的动作对象，然后将第一个点添加到`curAction`对象的`points`数组中。然后我们将`curAction`添加到`actions`数组中。
- en: 'The next stop is the `penMoved()` method. There we add the next point to the
    action''s `points` array:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是`penMoved()`方法。在那里，我们将下一个点添加到动作的`points`数组中：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We also need to update the `penUp()` method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`penUp()`方法：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: First we check the `drawing` variable to make sure we are indeed drawing. If
    so we turn off the `drawing` flag by setting it to `false`. Next we need to make
    sure there are at least two points in the action's `points` array. If the user
    pressed the mouse button but didn't move it, there would only be one point. We
    can't draw anything without two points so we'll just remove that action from the
    `actions` array using `pop()`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`drawing`变量，确保我们确实在绘制。如果是这样，我们通过将其设置为`false`来关闭`drawing`标志。接下来，我们需要确保动作的`points`数组中至少有两个点。如果用户按下鼠标按钮但没有移动它，那么只会有一个点。我们不能在没有两个点的情况下绘制任何东西，所以我们将使用`pop()`从`actions`数组中移除该动作。
- en: 'Lastly, we will update the `redraw()` method. Here''s where we need to make
    some substantial changes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新`redraw()`方法。这里我们需要做一些重大的改变：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: First of all notice the calls to `savePen()` and `restorePen()` in the `Canvas2D`
    object. They will save the current context properties before we start drawing
    all of the actions and then restore them when we are done. We will implement those
    in a moment. Next we iterate over all of the actions setting the pen color, width,
    and opacity for each one (using function chaining) before drawing the points.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意`Canvas2D`对象中对`savePen()`和`restorePen()`的调用。它们将在我们开始绘制所有动作之前保存当前上下文属性，然后在完成后恢复它们。我们将马上实现它们。接下来，我们遍历所有动作，为每个动作设置笔的颜色、宽度和不透明度（使用函数链接），然后绘制点。
- en: '*What just happened?*'
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added a drawing action object to keep track of the tool, pen properties,
    and points for each drawing action. Now when we change drawing properties they
    don't affect previous actions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个绘图动作对象来跟踪工具、笔属性和每个绘图动作的点。现在当我们更改绘图属性时，它们不会影响以前的动作。
- en: Time for action – saving and restoring
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-保存和恢复
- en: Now, about those `savePen()` and `restorePen()` methods. Let's go on over to
    `canvas2d.js` and add them to the `Canvas2D` object. We could keep track of the
    current properties ourselves, but the canvas API provides an easier way.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于`savePen()`和`restorePen()`方法。让我们去`canvas2d.js`，并将它们添加到`Canvas2D`对象中。我们可以自己跟踪当前属性，但画布API提供了一种更简单的方法。
- en: The canvas API contains both `save()` and `restore()` methods. Any time you
    need to save the state of the context you call `save()` and it pushes the state
    of the context on to a stack. When you want to restore the context state you call
    `restore()` and it pops the state off the stack back into the context. This allows
    you to save and restore the state multiple times recursively.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 画布API包含`save()`和`restore()`方法。每当需要保存上下文的状态时，调用`save()`，它会将上下文的状态推送到堆栈上。当您想要恢复上下文状态时，调用`restore()`，它会将状态从堆栈中弹出到上下文中。这允许您多次递归保存和恢复状态。
- en: 'This works great for situations where you may have a library of drawing functions
    that could be drawn in any order at runtime. Each method can call `save()` before
    it starts changing context properties and call `restore()` when it''s done. That
    way when a method is done the context is in the same state that it was before
    the method was called:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于可能在运行时以任何顺序绘制的绘图函数库非常有效。每个方法在开始更改上下文属性之前都可以调用`save()`，并在完成后调用`restore()`。这样，当方法完成时，上下文的状态与调用方法之前的状态相同：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*What just happened?*'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We learned how to save the context and restore it so that we don't lose the
    context's current properties.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何保存上下文并恢复它，以便不会丢失上下文的当前属性。
- en: Let's open the application in the browser and take a look. Now we can draw in
    all different colors, widths, and opacities. If you make a mistake you can click
    on **Undo** to erase it. And if you want to start all over you can click on **Clear**.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中打开应用程序并查看一下。现在我们可以用各种不同的颜色、宽度和不透明度绘制。如果出错，您可以单击**撤消**来擦除它。如果您想重新开始，可以单击**清除**。
- en: '![What just happened?](img/5947OT_04_09.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_04_09.jpg)'
- en: Adding drawing tools
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加绘图工具
- en: At this point we have an application where we can draw simple lines such as
    a pen, but it sure would be nice if we could draw some shapes such as straight
    lines, rectangles, and circles. In this section we will add a **Tool** menu to
    allow the user to select different shapes to draw.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的应用程序可以绘制简单的线条，比如笔，但如果我们能绘制一些形状，比如直线、矩形和圆形，那将会很好。在本节中，我们将添加一个**工具**菜单，允许用户选择不同的形状进行绘制。
- en: Time for action – adding a line tool
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加线条工具
- en: You can find the code for this section in `chapter4/example4.3`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter4/example4.3`中找到本节的代码。
- en: 'Currently we can draw freehand lines, but we don''t have a way to draw a straight
    line from one point to another. So let''s add a line drawing tool. To allow the
    user to select different tools we need a new drop-down menu toolbar option. Let''s
    add it to our HTML:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们可以绘制自由线条，但是我们没有办法从一个点到另一个点画一条直线。所以让我们添加一个线条绘制工具。为了允许用户选择不同的工具，我们需要一个新的下拉菜单工具栏选项。让我们把它添加到我们的HTML中：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For this menu we are setting the `data-option` attribute to `drawingTool`.
    We add menu items for the **Pen** tool, which we currently have, and a **Line**
    tool, which we are implementing now. Since `drawingTool` isn''t a property of
    the `Canvas2D` object we need to add code to check for it in `menuItemClicked()`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜单，我们将`data-option`属性设置为`drawingTool`。我们为**笔**工具添加了菜单项，我们目前已经有了，以及**线条**工具，我们现在正在实现。由于`drawingTool`不是`Canvas2D`对象的属性，我们需要添加代码来检查`menuItemClicked()`中的属性。
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: First we check to see which option was selected. If it's `"drawingTool"` we
    simply set the current tool to the value of the menu item that was selected. Otherwise
    we do the default behavior of setting the `Canvas2D` property with the selected
    value.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查选择了哪个选项。如果是`"drawingTool"`，我们只需将当前工具设置为所选菜单项的值。否则，我们将执行设置`Canvas2D`属性为所选值的默认行为。
- en: 'Next we will change the `penMoved()` method. We need to check which tool we
    are currently using. If it''s the pen we add another point to the `points` array.
    Otherwise we only want to change the second point in the `points` array because
    we are drawing a straight line, and a line only has two points:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将更改`penMoved()`方法。我们需要检查当前使用的工具。如果是笔，我们将向`points`数组添加另一个点。否则，我们只想更改`points`数组中的第二个点，因为我们正在画一条直线，而一条直线只有两个点：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Lastly we need to make some changes to the `redraw()` method. Inside the loop
    we will check the action''s tool. If it''s the pen we call `canvas2d.drawPoints()`
    the same as we did before. If it''s the line tool we call `canvas2d.drawLine()`
    passing in the two points:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对`redraw()`方法进行一些更改。在循环内，我们将检查操作的工具。如果是笔，我们调用`canvas2d.drawPoints()`，就像以前一样。如果是线条工具，我们调用`canvas2d.drawLine()`，传入这两个点：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Wait a minute! We don''t have a `drawLine()` method in the `Canvas2D` object
    yet. So let''s go add it:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！我们的`Canvas2D`对象中还没有`drawLine()`方法。所以让我们去添加它：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `drawLine()` method takes the line start and end points as parameters. After
    beginning a new path it moves to the first point, draws a line to the second point,
    and then strokes it. That's it. Now we can draw straight lines.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawLine()`方法将线的起点和终点作为参数。在开始新路径后，它移动到第一个点，画一条线到第二个点，然后描边。就是这样。现在我们可以画直线了。'
- en: '*What just happened?*'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added a **Tool** menu to our toolbar where the user can select different
    drawing tools. In addition to the pen tool we already had, we added a line drawing
    tool to draw straight lines in our application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在工具栏中添加了一个**工具**菜单，用户可以选择不同的绘图工具。除了我们已经有的笔工具，我们还添加了一条线条绘制工具，用于在应用程序中绘制直线。
- en: Drawing rectangles
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制矩形
- en: You could draw a rectangle using paths, but the canvas API has a couple built
    in methods to do this; `drawRect()` and `fillRect()`. They both take the same
    parameters; *x*, *y*, width, and height. `drawRect()` uses the `strokeStyle` to
    draw the lines and `fillRect()` uses the `fillStyle` to fill it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用路径来绘制矩形，但是画布API有一些内置方法来实现这一点；`drawRect()`和`fillRect()`。它们都接受相同的参数；*x*，*y*，宽度和高度。`drawRect()`使用`strokeStyle`来绘制线条，而`fillRect()`使用`fillStyle`来填充。
- en: 'The following draws a rectangle starting at the point (350, 10) with a width
    of `50` and a height of `90`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从点（350，10）开始的矩形，宽度为`50`，高度为`90`：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This example draws a filled rectangle starting at the point (425, 10) with
    a width of `50` and a height of `90`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子画了一个从点（425，10）开始的填充矩形，宽度为`50`，高度为`90`：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![Drawing rectangles](img/5947OT_04_02.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![绘制矩形](img/5947OT_04_02.jpg)'
- en: Time for action – adding a rectangle tool
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加矩形工具
- en: 'Let''s add a tool to draw rectangles. We''ll start by adding a menu item to
    the **Tool** drop-down menu with its `data-value` attribute set to `"rect"`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个绘制矩形的工具。我们将首先向**工具**下拉菜单添加一个菜单项，其`data-value`属性设置为`"rect"`：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s implement the `drawRect()` method in `Canvas2D`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Canvas2D`中实现`drawRect()`方法：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Our `drawRect()` method takes three parameters; the two points that define top-left
    and bottom-right coordinates, and a Boolean value to determine if the rectangle
    should be filled. Since `fillRect()` and `strokeRect()` both take width and height
    parameters we need to compute them by subtracting the `point1` variable's coordinates
    from `point2` variable's coordinates.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`drawRect()`方法接受三个参数；定义左上角和右下角坐标的两个点，以及一个布尔值来确定矩形是否应该填充。由于`fillRect()`和`strokeRect()`都需要宽度和高度参数，我们需要通过从`point2`变量的坐标中减去`point1`变量的坐标来计算它们。
- en: 'Before we code up the call to `drawRect()` there is one piece of business we
    need to take care of. Our `drawRect()` method can draw either outlined or filled
    rectangles, so we need a way to let the user pick which one they want. Let''s
    add another drop-down menu to the toolbar named **Fill** that allows the user
    to set this option:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`drawRect()`之前，我们需要处理一件事。我们的`drawRect()`方法可以绘制轮廓或填充矩形，因此我们需要一种方法让用户选择他们想要的选项。让我们在工具栏中添加另一个下拉菜单，命名为**填充**，允许用户设置此选项：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The drop-down menu has only two options: **Yes** and **No**. In our `CanvasPadApp`
    object we need a global `fillShapes` Boolean variable to keep track of the current
    setting. Let''s add this at the top of the object along with our other variables:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉菜单只有两个选项：**是**和**否**。在我们的`CanvasPadApp`对象中，我们需要一个全局的`fillShapes`布尔变量来跟踪当前的设置。让我们在对象的顶部添加这个变量，以及其他变量：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We also need to add it to the action object in the `newAction()` method. We
    will add a field named `fill` and set it to the current value of `fillShapes`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`newAction()`方法的action对象中添加它。我们将添加一个名为`fill`的字段，并将其设置为`fillShapes`的当前值：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next we need to add some extra code to the `menuItemClicked()` method to check
    if the option was the **Fill** menu option and if so set the `fillShapes` variable
    to its `data-value`. Since the value is either `"true"` or `"false"` we can convert
    it directly to a Boolean:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`menuItemClicked()`方法中添加一些额外的代码，以检查选项是否为**填充**菜单选项，如果是，则将`fillShapes`变量设置为其`data-value`。由于值要么是`"true"`要么是`"false"`，我们可以直接将其转换为布尔值：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Okay, that''s it for the **Fill** option. Now we can add the code to the `redraw()`
    method to check for the rectangle tool and draw it by calling `drawRect()`. We
    will pass in the two points of the rectangle and the value of `action.fill` to
    tell it whether to fill the rectangle or not:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，**填充**选项就是这样。现在我们可以在`redraw()`方法中添加代码，检查矩形工具并通过调用`drawRect()`来绘制它。我们将传入矩形的两个点和`action.fill`的值，告诉它是否填充矩形：
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '*What just happened?*'
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added a rectangle tool to our **Tool** menu. We also added a new toolbar
    menu to select whether to fill shapes or not. We used this to determine whether
    to draw filled or outlined rectangles.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在**工具**菜单中添加了一个矩形工具。我们还添加了一个新的工具栏菜单来选择是否填充形状。我们用它来确定是绘制填充还是轮廓矩形。
- en: Arcs and circles
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弧和圆
- en: 'In addition to straight lines you can draw arcs, or portions of a circle, using
    the context''s `arc()` method. It takes the following parameters:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直线，您还可以使用上下文的`arc()`方法绘制弧线或圆的部分。它需要以下参数：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`centerX`: This parameter tells the horizontal position of the center point.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centerX`: 此参数指定中心点的水平位置。'
- en: '`centerY`: This parameter tells the vertical position of the center point.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centerY`: 此参数指定中心点的垂直位置。'
- en: '`radius`: This parameter tells the radius of the arc.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radius`: 此参数指定弧的半径。'
- en: '`startAngle`: This parameter tells the starting angle of the arc specified
    in radians. It can be any value between `0` to `2π`. Numbers outside this range
    will automatically be normalized into it.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startAngle`: 此参数指定以弧度表示的弧的起始角度。它可以是`0`到`2π`之间的任何值。超出此范围的数字将自动归一化为其中。'
- en: '`endAngle`: This parameter tells the ending angle of the arc specified in radians.
    It can be any value between `0` to `2π`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endAngle`: 此参数指定以弧度表示的弧的结束角度。它可以是`0`到`2π`之间的任何值。'
- en: '`counterclockwise`: This is a `Boolean` parameter that specifies which direction
    to draw the arc from start to end angle. If false it draws clockwise, if true
    counterclockwise.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counterclockwise`: 这是一个`Boolean`参数，指定从起始角度到结束角度绘制弧的方向。如果为false，则顺时针绘制，如果为true，则逆时针绘制。'
- en: 'Arcs are really paths, so you must use `beginPath()` and `stroke()` to draw
    them. The following code draws the bottom-right corner of a circle. The center
    is at the point `(100, 200)`. It has a radius of `40`. The angle starts at `0`
    and ends at `π/2` radians, or 90 degrees. And it is drawn clockwise:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 弧实际上是路径，因此您必须使用`beginPath()`和`stroke()`来绘制它们。以下代码绘制了一个圆的右下角。中心点在`(100, 200)`处。它的半径为`40`。角度从`0`开始，到`π/2`弧度或90度结束。并且是顺时针绘制的：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can draw a full circle using the `arc()` method too. A circle is simply
    a complete arc drawn from `0` to `2π` radians, or 360 degrees:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`arc()`方法绘制一个完整的圆。一个圆只是从`0`到`2π`弧度或360度绘制的完整弧：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you are unfamiliar with radians, let me give you a brief overview. Radians
    are simply another way to specify an angle. It is based on the formula for the
    circumference of a circle; `C = 2 * π *` radius. By setting the radius to `1`,
    we can use that formula to measure the length of an arc from one point on the
    circle to another point along the circumference. If you were to measure all the
    way around a circle you would have `2π` radians. Therefore, `2π` radians are equal
    to 360 degrees. Half way around the circle is `π` radians, which is equal to 180
    degrees. One quarter of the way around is `π/2` radians or 90 degrees.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉弧度，让我简要介绍一下。弧度只是指定角度的另一种方式。它基于圆的周长公式；`C = 2 * π *`半径。通过将半径设置为`1`，我们可以使用该公式来测量从圆上的一个点到圆周上的另一个点的弧长。如果您测量整个圆，您将得到`2π`弧度。因此，`2π`弧度等于360度。圆的一半是`π`弧度，等于180度。圆的四分之一是`π/2`弧度或90度。
- en: '![Arcs and circles](img/5947OT_04_01.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![弧和圆](img/5947OT_04_01.jpg)'
- en: 'If you prefer to use degrees you can always use this conversion function to
    convert degrees to radians:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用度数，您可以始终使用此转换函数将度数转换为弧度：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here are some examples of arcs using different parameters. Arcs 1 and 2 use
    the same start and end angles, just drawing in different direction. The same is
    true for arcs 3 and 4\. Arc 5 draws a complete circle:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用不同参数的弧的一些示例。弧1和2使用相同的起始和结束角度，只是以不同的方向绘制。弧3和4也是如此。弧5绘制一个完整的圆：
- en: '`context.arc(100, 200, 40, 0, toRadians(90), true);`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.arc(100, 200, 40, 0, toRadians(90), true);`'
- en: '`context.arc(200, 200, 40, 0, toRadians(90), false);`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.arc(200, 200, 40, 0, toRadians(90), false);`'
- en: '`context.arc(300, 200, 40, 0, toRadians(180), true);`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.arc(300, 200, 40, 0, toRadians(180), true);`'
- en: '`context.arc(400, 200, 40, 0, toRadians(180), false);`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.arc(400, 200, 40, 0, toRadians(180), false);`'
- en: '`context.arc(500, 200, 40, 0, toRadians(360), false);`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.arc(500, 200, 40, 0, toRadians(360), false);`'
- en: '![Arcs and circles](img/5947OT_04_04.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![弧和圆](img/5947OT_04_04.jpg)'
- en: Time for action – adding a circle tool
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加圆形工具
- en: 'Let''s add a circle menu item to our **Tool** menu:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的**工具**菜单中添加一个圆形菜单项：
- en: '[PRE70]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now let''s go ahead and add a `drawCircle()` method to `Canvas2D`. Our method
    will take the center point, the radius, and a Boolean value to determine if the
    circle should be filled:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续添加一个`drawCircle()`方法到`Canvas2D`。我们的方法将接受中心点、半径和一个布尔值来确定是否应该填充圆：
- en: '[PRE71]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If the fill parameter is set to true we call `context.fill()` after calling
    `arc()`. Otherwise we just use `context.stroke()` to draw the outline.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果fill参数设置为true，我们在调用`arc()`后调用`context.fill()`。否则，我们只使用`context.stroke()`来绘制轮廓。
- en: 'Finally let''s add the code to `redraw()` to draw the circle. Here we need
    to do a little work to find the radius to pass into `drawCircle()`. First we find
    the difference in `x` between the first and second point, then the difference
    in `y`. Whichever one is smaller we will use that as our radius:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后让我们添加代码到`redraw()`来绘制圆。这里我们需要做一些工作来找到传递到`drawCircle()`的半径。首先我们找到第一个点和第二个点之间的`x`的差值，然后找到`y`的差值。无论哪个更小，我们将使用它作为我们的半径：
- en: '[PRE72]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*What just happened?*'
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added a new menu item to the **Tool** menu to draw circles using the context's
    `arc()` method.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在**工具**菜单中添加了一个新的菜单项，使用上下文的`arc()`方法来绘制圆。
- en: Open the application and give it a try. Now we have a pretty decent collection
    of drawing tools in our application. We can make some more sophisticated drawings
    with all different colors and opacities rather than just black scribbles.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序并试一试。现在我们的应用程序中有一个相当不错的绘图工具集合。我们可以用各种颜色和不透明度制作一些更复杂的绘画，而不仅仅是黑色涂鸦。
- en: '![What just happened?](img/5947OT_04_10.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_04_10.jpg)'
- en: Have a go hero
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试一试
- en: Try adding your own drawing tool, such as a triangle or some other shape. Implement
    the drawing of the shape in the `Canvas2D` object then add a menu item to the
    toolbar.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加自己的绘图工具，比如三角形或其他形状。在`Canvas2D`对象中实现形状的绘制，然后在工具栏中添加一个菜单项。
- en: Pop quiz
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验
- en: Q1\. What unit is used to define the angle when drawing arcs?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 绘制弧时使用什么单位来定义角度？
- en: Degrees
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 度
- en: Units
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单位
- en: Radians
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弧度
- en: Arcs
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弧
- en: Q2\. What context method is used to draw a path to the canvas?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 用于将路径绘制到画布的上下文方法是什么？
- en: '`drawPath()`'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`drawPath()`'
- en: '`stroke()`'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stroke()`'
- en: '`draw()`'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`draw()`'
- en: '`endPath()`'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`endPath()`'
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we created a drawing application called canvas pad which can
    be used to make simple drawings. Along the way we learned how to use the HTML5
    canvas element and API. We also learned how to implement a reusable toolbar with
    menu items that are bound to actions using custom data attributes. We now have
    a reusable toolbar we can use in other applications.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个名为canvas pad的绘图应用程序，可以用来制作简单的绘画。在这个过程中，我们学习了如何使用HTML5画布元素和API。我们还学习了如何实现一个可重用的工具栏，其中菜单项通过自定义数据属性绑定到操作。现在我们有一个可重用的工具栏，可以在其他应用程序中使用。
- en: 'We covered the following concepts in this chapter:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们涵盖了以下概念：
- en: How to use the `<canvas>` element and the canvas API
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`<canvas>`元素和canvas API
- en: How to get a canvas context and change global drawing properties such as width,
    color, and opacity
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取画布上下文并更改全局绘图属性，如宽度、颜色和不透明度
- en: How to use paths to draw free lines and shapes
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用路径绘制自由线条和形状
- en: How to draw lines, rectangles, and circles
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绘制线条、矩形和圆形
- en: How to get the position of the mouse inside a canvas element
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取画布元素内鼠标的位置
- en: How to create a reusable toolbar and implement drop-down menus
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建可重用的工具栏并实现下拉菜单
- en: How to use custom data attributes to bind actions to menu items
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用自定义数据属性将操作绑定到菜单项
- en: In the next chapter we will continue our exploration of the canvas. We will
    learn some more advanced canvas features such as transformations and rotations.
    We will also see how to load images and export them from the canvas, in the process
    touching upon the file API. Then we will get down to the individual pixels of
    the canvas to do some image manipulation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索画布。我们将学习一些更高级的画布功能，如变换和旋转。我们还将看到如何加载图像并从画布中导出它们，同时涉及文件API。然后我们将深入到画布的单个像素，进行一些图像处理。
