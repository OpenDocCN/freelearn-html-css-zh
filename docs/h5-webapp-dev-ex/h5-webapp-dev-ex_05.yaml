- en: Chapter 5. Not So Blank Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。并不是空白画布
- en: '"This world is but a canvas to our imagination."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个世界只是我们想象的画布。
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: – Henry David Thoreau
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- 亨利·大卫·梭罗'
- en: '*In the previous chapter we learned the basics of using the HTML5 canvas. We
    created a drawing application called Canvas Pad with tools to draw lines and shapes
    in all different colors and sizes. In this chapter we will continue our exploration
    of the Canvas API by extending Canvas Pad to add more tools. Then we will create
    a new application called Photo Pad where we will take a look at how to load images
    using the File API and perform image processing by accessing and modifying the
    individual pixels of the canvas.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*在上一章中，我们学习了使用HTML5画布的基础知识。我们创建了一个名为Canvas Pad的绘图应用程序，其中包含用于以各种颜色和大小绘制线条和形状的工具。在本章中，我们将通过扩展Canvas
    Pad来添加更多工具来继续探索Canvas API。然后，我们将创建一个名为Photo Pad的新应用程序，我们将学习如何使用File API加载图像，并通过访问和修改画布的单个像素来执行图像处理。*'
- en: 'In this chapter we will learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将学习：
- en: How to get text input and draw it to the canvas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取文本输入并将其绘制到画布上
- en: How to use the Canvas API transformation functions to change how items are drawn
    on the canvas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Canvas API变换函数来改变在画布上绘制项目的方式
- en: How to export the canvas image to save it
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何导出画布图像以保存它
- en: How to load images using the HTML5 File API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用HTML5文件API加载图像
- en: How to draw bitmap images to the canvas
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将位图图像绘制到画布上
- en: How to get the data for each pixel in a canvas, manipulate it, and put it back
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取画布中每个像素的数据，操纵它，并将其放回
- en: Drawing text
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制文本
- en: 'There are two methods available to draw text on the canvas: `strokeText()`
    and `fillText()`. `strokeText()` draws outlined text using the current `lineWidth`
    and `strokeStyle`, while `fillText()` draws with the current `fillStyle`. Both
    take the same parameters; the text to draw, and the x and y coordinates. The context
    object has a global font property to define which `font` to use. You set its value
    the same you would when defining a font in CSS. Continuing where we left off in
    the previous chapter with our Canvas Pad application, we will add a new text drawing
    tool. You can find the source code for this section in `Chapter 5/example5.1`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上有两种可用的绘制文本的方法：`strokeText()`和`fillText()`。`strokeText()`使用当前的`lineWidth`和`strokeStyle`绘制轮廓文本，而`fillText()`使用当前的`fillStyle`进行绘制。两者都接受相同的参数：要绘制的文本以及x和y坐标。上下文对象有一个全局的字体属性来定义要使用的`font`。您可以像在CSS中定义字体时一样设置它的值。在我们在上一章中使用Canvas
    Pad应用程序结束的地方继续，我们将添加一个新的文本绘制工具。您可以在`第5章/example5.1`中找到本节的源代码。
- en: Time for action – adding a text tool
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加文本工具
- en: 'Let''s start by adding a new item to the Tool drop-down menu for the text tool:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在工具下拉菜单中添加一个新项目，用于文本工具：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll add a `drawText()` method to the `Canvas2D` object. It will take
    the text to draw, a point from where to draw the text, and a Boolean value indicating
    whether to fill the text or just outline it. If `fill` is `true`, it uses `fillText()`
    to draw the text, otherwise it uses `strokeText()`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`Canvas2D`对象中添加一个`drawText()`方法。它将接受要绘制的文本、从哪里绘制文本的点以及一个布尔值，指示是填充文本还是仅仅轮廓它。如果`fill`为`true`，它使用`fillText()`来绘制文本，否则它使用`strokeText()`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we need a way to allow the user to enter the text that he/she wants to draw.
    We will need a text input field that we will keep hidden until the user wants
    to add some text. When the user selects the text tool and clicks on the canvas,
    we will position the text field where he/she clicked on and wait for him/her to
    enter the text. When the user presses the *Enter* key, we will hide the text field
    and draw the text to the canvas.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一种方法，允许用户输入他/她想要绘制的文本。我们需要一个文本输入字段，我们将保持隐藏，直到用户想要添加一些文本。当用户选择文本工具并点击画布时，我们将把文本字段定位在他/她点击的位置，并等待他/她输入文本。当用户按下*Enter*键时，我们将隐藏文本字段并将文本绘制到画布上。
- en: 'To make it seem like the user is typing on the canvas, we need to set a couple
    more properties in the canvas context for the font. We will set the `font` and
    `textBaseline` properties in the constructor. The baseline tells the context where
    to draw the text relative to the position. We will set it to `"top"` so it will
    draw the top of the text at the y position, which is the same place our text field
    will be. Other common baseline values are `"bottom"` and `"middle"`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户看起来像是在画布上输入，我们需要在画布上下文中设置更多属性以用于字体。我们将在构造函数中设置`font`和`textBaseline`属性。基线告诉上下文在哪里相对于位置绘制文本。我们将其设置为“top”，这样它将在y位置绘制文本的顶部，这与我们的文本字段所在的位置相同。其他常见的基线值是“bottom”和“middle”：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we need a text field for the user to enter text. Let''s add it to the bottom
    of our HTML file, after the footer element:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个文本字段，让用户输入文本。让我们将它添加到我们的HTML文件底部，在页脚元素之后：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next let''s go into our CSS and define the style for the `text-input` element.
    We will set `display` to `none`, so that it is hidden, and set `position` to `absolute`,
    so that we can position it wherever we want to on the page. We will also change
    the size of the font to 24 pixels because that''s what we set for our font size
    in the context:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们进入CSS并定义`text-input`元素的样式。我们将`display`设置为`none`，这样它就被隐藏了，并将`position`设置为`absolute`，这样我们就可以在页面上任意位置放置它。我们还将字体大小改为24像素，因为这是我们在上下文中设置的字体大小：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s add some JavaScript code to the `penDown()` method in `CanvasPadApp`
    so that when the user clicks the mouse it shows the text input field:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`CanvasPadApp`的`penDown()`方法中添加一些JavaScript代码，以便当用户点击鼠标时显示文本输入字段：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First it checks the current tool. If it is the text tool, it checks to see if
    the text field is already visible and if so, there's no need to continue. Otherwise
    it calls `showTextInput()` passing in the mouse coordinates. Notice that we don't
    set `drawing` to `true` in this case because we don't need to track the mouse.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查当前的工具。如果是文本工具，它会检查文本字段是否已经可见，如果是，则无需继续。否则，它调用`showTextInput()`并传入鼠标坐标。请注意，在这种情况下，我们不会将`drawing`设置为`true`，因为我们不需要跟踪鼠标。
- en: 'The `showTextInput()` method takes the mouse coordinates and moves the `text-input`
    element to the point where the user clicked the mouse on the canvas:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`showTextInput()`方法获取鼠标坐标并将`text-input`元素移动到用户在画布上单击鼠标的位置：'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First we set the `top` and `left` CSS properties to move the element over to
    where the user clicked on and then fade it in. Then it resets the value of the
    text field and sets the focus on it so the user can start typing. This will make
    it appear that the user is typing on the canvas.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们设置`top`和`left` CSS属性来移动元素到用户单击的位置，然后淡入。然后重置文本字段的值并将焦点设置在上面，这样用户就可以开始输入。这将使用户看起来好像在画布上输入。
- en: 'When the user is done typing, he/she can press the *Enter* key to finish the
    text. We need to add a `keydown` event handler to the text field to check for
    this. We will add that in the `start()` method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入完成后，他/她可以按*Enter*键完成文本。我们需要在文本字段中添加一个`keydown`事件处理程序来检查这一点。我们将在`start()`方法中添加这个。
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The handler calls `checkTextInput()`, passing in the key code of the key that
    was pressed. The key code is found in the `which` field of the event object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序调用`checkTextInput()`，传入按下的键的键码。键码在事件对象的`which`字段中找到：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `checkTextInput()` method looks at the key code to see what to do. If the
    user pressed the *Enter* key, which is key code 13, it will set the text into
    the current action object, hide the text input, and then call `redraw()`. If the
    key code is 27, which is the *Escape* key,it will cancel the text by removing
    the action and then hiding the text input.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkTextInput()`方法查看键码以确定要执行什么操作。如果用户按下*Enter*键，即键码为13，它将把文本设置到当前操作对象中，隐藏文本输入，然后调用`redraw()`。如果键码是27，即*Escape*键，它将通过移除操作然后隐藏文本输入来取消文本。'
- en: 'The final piece to implement is the change to `redraw()`. We need to add the
    text action to our `switch` statement. It passes in the text, the position to
    draw it, and whether to fill it or not:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的最后一部分是对`redraw()`的更改。我们需要将文本操作添加到我们的`switch`语句中。它传入文本、绘制位置以及是否填充：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*What just happened?*'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added a Text tool to our application that allows the user to type text on
    the canvas and draw it filled or outlined.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中添加了一个文本工具，允许用户在画布上输入文本并绘制填充或轮廓。
- en: Have a go hero
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看
- en: Try adding a toolbar menu for the user to select different font sizes. You will
    need to change the font size in the canvas context as well as the text input field's
    style.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为用户添加一个工具栏菜单，以选择不同的字体大小。你需要在画布上下文中改变字体大小，以及文本输入字段的样式。
- en: Transformations
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换
- en: The Canvas API contains four methods for transforming how things are drawn on
    the canvas. They change the coordinate system of the canvas so that when you draw
    something, it draws at a different place than it normally would. Think of it as
    taking a piece of paper and moving it or rotating it before drawing on it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas API包含四种方法来转换画布上的绘图方式。它们改变了画布的坐标系，使得当你绘制东西时，它会在一个不同的位置绘制。可以把它想象成在绘制之前移动或旋转一张纸。
- en: '`translate(x, y)`: This translates anything drawn on the canvas by the values
    specified. The values can be any decimal number. Negative numbers translate up
    and to the left. Often you will use `translate()` to translate to the center of
    a shape before applying other transformations to it.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translate(x, y)`: 这将画布上绘制的任何东西平移指定的值。这些值可以是任何小数。负数向上和向左平移。通常你会使用`translate()`将形状平移到中心，然后对其应用其他变换。'
- en: '`scale(x, y)`: This scales anything drawn to the canvas by the values specified.
    The parameters can be any positive decimal number. If you wanted everything to
    be drawn half size, you would use scale (0.5, 0.5). If you wanted to double the
    size, scale (2, 2).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale(x, y)`: 这将画布上绘制的任何东西按指定的值进行缩放。参数可以是任何正的小数。如果你想要一切都是一半大小，你会使用scale(0.5,
    0.5)。如果你想要加倍大小，使用scale(2, 2)。'
- en: '`rotate(angle)`: This rotates the canvas by an angle. The angle is specified
    in radians from 0 to 2π. Negative numbers will rotate counterclockwise.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate(angle)`: 这将以一个角度旋转画布。角度以弧度从0到2π指定。负数将逆时针旋转。'
- en: '`transform(a, b, c, d, e, f)`: If none of the other transformation methods
    work for you, you can use `transform()` to create your own. I wouldn''t recommend
    it unless you know how to use transformation matrices.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transform(a, b, c, d, e, f)`: 如果其他变换方法对你不起作用，你可以使用`transform()`来创建自己的变换。我不建议这样做，除非你知道如何使用变换矩阵。'
- en: Time for action – adding an Ellipse tool
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加椭圆工具
- en: 'Let''s use some transformations to draw an ellipse in Canvas Pad. An ellipse
    is basically a squashed circle. We can use the `scale()` method to change the
    scale of either the x or y axis before drawing a circle to squash it into an ellipse.
    Let''s add a `drawEllipse()` method to the `Canvas2D` object. It takes a center
    point, an end point, and a Boolean to determine if it should be filled:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一些变换来在Canvas Pad中绘制一个椭圆。椭圆基本上是一个扁平的圆。我们可以使用`scale()`方法在绘制圆之前改变x或y轴的比例，将其压扁成椭圆。让我们在`Canvas2D`对象中添加一个`drawEllipse()`方法。它需要一个中心点、一个终点和一个布尔值来确定是否应该填充：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There''s a lot going on in here, so let''s break it down:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情要做，所以让我们来分解一下：
- en: First we find the horizontal and vertical radii (rx and ry) by calculating the
    distance between the end point and the center point coordinates. Whichever one
    is the largest will be the radius of the ellipse.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们通过计算终点和中心点坐标之间的距离来找到水平和垂直半径(rx和ry)。其中较大的那个将是椭圆的半径。
- en: Next we find the horizontal and vertical scales by dividing the radii by the
    max radius. Since one of the radii is the max radius, that scale will be 1\. The
    other will be scaled less than 1.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们通过将半径除以最大半径来找到水平和垂直比例。由于其中一个半径是最大半径，所以该比例将为1。另一个将比1小。
- en: Next we call `save()` to save the state of the context before we start transforming
    it.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们调用`save()`来保存上下文的状态，然后开始变换它。
- en: Now we do our transformations. First we translate to the center of the ellipse,
    so it will transform around the center of the shape. Then we scale by the amounts
    we calculated previously.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们进行变换。首先，我们将平移至椭圆的中心，这样它将围绕形状的中心进行变换。然后，我们按照之前计算的量进行缩放。
- en: Then we draw the circle with `beginPath()`, `arc()`, and `closePath()`. Since
    the canvas is scaled on one axis, the circle will be squashed into an ellipse.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`beginPath()`，`arc()`和`closePath()`来绘制圆。由于画布在一个轴上被缩放，圆将被压扁成椭圆。
- en: Then we call either `fill()` or `stroke()` depending on the `fill` parameter
    to draw the circle to the canvas.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，根据`fill`参数调用`fill()`或`stroke()`来将圆绘制到画布上。
- en: Finally we call `restore()` to restore the context to the way it was before
    we applied the transformations, and we're done.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`restore()`来恢复上下文到应用变换之前的状态，然后就完成了。
- en: 'Now that we have a method to draw an ellipse, we can go add an Ellipse menu
    item to the Tool menu in our HTML:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个绘制椭圆的方法，我们可以在HTML中的工具菜单中添加一个椭圆菜单项：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The only thing left to do is add an option for the Ellipse tool in the `switch`
    statement in `redraw()` and we''re done:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情就是在`redraw()`的`switch`语句中为椭圆工具添加一个选项，然后我们就完成了：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*What just happened?*'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added an Ellipse tool to our application and implemented a method to draw
    an ellipse on the canvas using transformations to squash a circle on one axis.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向应用程序添加了一个椭圆工具，并实现了一个使用变换在画布上绘制椭圆的方法，以便在一个轴上压扁圆。
- en: Time for action – exporting an image
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-导出图像
- en: We can draw pictures with our Canvas Pad application, but what's the point if
    we can't save them? HTML5 doesn't have the capability to save files directly to
    the user's file system because of the security risks. So our options on the client
    side are pretty limited. We can save the data to `localStorage` or we can open
    the image in a new browser window, where the user can save the image using the
    browser's **Save** option. We will do the latter because it allows the user to
    get a real image file they can use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Canvas Pad应用程序绘制图片，但如果我们不能保存它们，那有什么意义呢？由于安全风险，HTML5无法直接将文件保存到用户的文件系统中。因此，我们在客户端的选择相当有限。我们可以将数据保存到`localStorage`中，或者我们可以在新的浏览器窗口中打开图像，用户可以使用浏览器的**保存**选项保存图像。我们将选择后者，因为它允许用户获得一个真正的图像文件。
- en: 'You can get the image data as a URL from a canvas by calling the `toDataURL()`
    method on the canvas element itself (not the context). Then you can open the image
    URL in another window using `window.open()`. Let''s add a **Save** button to our
    toolbar and set the `data-action` attribute to `"save"`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在画布元素本身（而不是上下文）上调用`toDataURL()`方法来将图像数据作为URL从画布中获取。然后，您可以使用`window.open()`在另一个窗口中打开图像URL。让我们在工具栏中添加一个**保存**按钮，并将`data-action`属性设置为`"save"`：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next let''s add a check for the action in the `switch` statement of the `toolbarButtonClicked()`
    method. When the **Save** button is clicked, it will get the data URL and then
    open it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`toolbarButtonClicked()`方法的`switch`语句中添加对操作的检查。当单击**保存**按钮时，它将获取数据URL，然后打开它：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*What just happened?*'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Now we can export images from the canvas using the context's `toDataUrl()` method
    and open them in another browser window so they can be saved by the user.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用上下文的`toDataUrl()`方法从画布中导出图像，并在另一个浏览器窗口中打开它们，以便用户可以保存图像。
- en: '![What just happened?](img/5947OT_05_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_05_05.jpg)'
- en: Handling touch events
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理触摸事件
- en: One of the great things about HTML5 is that you can write one application and
    it will work on many different devices. Canvas Pad works great as a desktop application
    where mouse events are available. But it would work just as well on a touch screen
    device. So let's add support for touch events to the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5的一个伟大之处在于您可以编写一个应用程序，它将在许多不同的设备上运行。Canvas Pad作为一个桌面应用程序非常出色，因为它支持鼠标事件。但是它在触摸屏设备上同样表现出色。因此，让我们为应用程序添加对触摸事件的支持。
- en: Touch events are similar to mouse events. One difference is that the user can
    touch the screen with more than one finger, so touch events may contain multiple
    points. So we will have to take that into consideration when handling them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸事件类似于鼠标事件。一个区别是用户可以用多个手指触摸屏幕，因此触摸事件可能包含多个点。因此，在处理它们时，我们必须考虑到这一点。
- en: There are three basic touch events that browsers support.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器支持三种基本的触摸事件。
- en: '`touchstart`: We get this event when the user touches the screen. This is equivalent
    to the `mousedown` event.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touchstart`：当用户触摸屏幕时，我们会收到此事件。这相当于`mousedown`事件。'
- en: '`touchmove`: We get these events after `touchstart` when the user moves his/her
    finger on the screen. This is equivalent to the `mousemove` event.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touchmove`：在`touchstart`之后，当用户在屏幕上移动手指时，我们会收到这些事件。这相当于`mousemove`事件。'
- en: '`touchend`: We get this event when the user lifts his/her finger off the screen.
    This is equivalent to the `mouseup` event.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touchend`：当用户从屏幕上抬起手指时，我们会收到此事件。这相当于`mouseup`事件。'
- en: The touch event object that is passed to the event handler contains an array
    called `touches`. This array contains all of the points that were touched. Each
    object in the `touches` array has a `pageX` and a `pageY` field, just like mouse
    events.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给事件处理程序的触摸事件对象包含一个名为`touches`的数组。该数组包含所有被触摸的点。`touches`数组中的每个对象都有一个`pageX`和一个`pageY`字段，就像鼠标事件一样。
- en: 'You can test whether touch events are supported by checking if the document
    element has an `ontouchstart` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查文档元素是否具有`ontouchstart`方法来测试是否支持触摸事件。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: jQuery doesn't include support for touch events, but it would be nice if we
    could use the same jQuery mechanism to add touch event handlers to elements. So
    let's write a jQuery extension to add it. We will create a new file called `touchEvents.js`
    to put our extension in, so that we can reuse it in other applications.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery不包括对触摸事件的支持，但如果我们可以使用相同的jQuery机制来为元素添加触摸事件处理程序，那将会很好。因此，让我们编写一个jQuery扩展来添加它。我们将创建一个名为`touchEvents.js`的新文件，以便将我们的扩展放入其中，以便在其他应用程序中重用它。
- en: Time for action – adding touch event handlers
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加触摸事件处理程序
- en: 'Extending the jQuery library is actually pretty easy. First we wrap our extensions
    in an immediately invoked function expression and pass the jQuery object into
    it. This is a best practice to make sure the dollar sign is really mapped to jQuery
    and not being used by something else. Then we define our extension methods by
    adding them to jQuery''s internal `$.fn` object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展jQuery库实际上非常容易。首先，我们将我们的扩展包装在一个立即调用的函数表达式中，并将jQuery对象传递给它。这是一个最佳实践，以确保美元符号确实映射到jQuery，而不是被其他东西使用。然后，我们通过将它们添加到jQuery的内部`$.fn`对象来定义我们的扩展方法：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in an extension method's context, the `this` pointer refers to the
    jQuery object that wraps the selected elements. So `this.each()` iterates over
    each of the elements that were selected.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在扩展方法的上下文中，`this`指针指的是包装所选元素的jQuery对象。因此，`this.each()`会迭代选择的每个元素。
- en: The `touchstart`, `touchmove`, and `touchend` methods all work the same way.
    They iterate over the elements and call `addEventListener()` for each one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`touchstart`，`touchmove`和`touchend`方法都以相同的方式工作。它们遍历元素，并为每个元素调用`addEventListener()`。'
- en: We also defined a global `isTouchSupported` variable directly on the jQuery
    object. It checks for touch support using the method described previously. We
    will use that to determine if we should use touch or mouse events in our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在jQuery对象上直接定义了一个全局的`isTouchSupported`变量。它使用之前描述的方法来检查触摸支持。我们将使用它来确定我们的应用程序是否应该使用触摸或鼠标事件。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about writing jQuery extensions on the jQuery website ([http://jquery.com](http://jquery.com)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在jQuery网站上了解更多关于编写jQuery扩展的信息（[http://jquery.com](http://jquery.com)）。
- en: 'Our extension is done, so let''s go back to `CanvasPadApp` and add the code
    to our application to handle touch events. First in the `start()` method we need
    to check if touch is supported and wire up the correct events:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的扩展已经完成，所以让我们回到`CanvasPadApp`，并在我们的应用程序中添加处理触摸事件的代码。首先在`start()`方法中，我们需要检查是否支持触摸，并连接正确的事件：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `onTouchStart()` event handler method must call both `stopPropagation()`
    and `preventDefault()` on the event object to keep it from performing the default
    behavior. Otherwise it might try to drag the screen rather than draw on the canvas:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTouchStart()`事件处理程序方法必须在事件对象上调用`stopPropagation()`和`preventDefault()`，以防止它执行默认行为。否则它可能会尝试拖动屏幕而不是在画布上绘制：'
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next we extract the point that the user touched. There could be multiple points,
    but we are only interested in the first point in the `touches` array. We extract
    the `pageX` and `pageY` fields from it and pass them into the `penDown()` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提取用户触摸的点。可能有多个点，但我们只对`touches`数组中的第一个点感兴趣。我们从中提取`pageX`和`pageY`字段，并将它们传递给`penDown()`方法。
- en: 'The `onTouchMove()` handler works the same way except it calls `penMoved()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTouchMove()`处理程序的工作方式相同，只是调用`penMoved()`：'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `onTouchEnd()` handler simply calls `penUp()`, the same as `onMouseUp():`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTouchEnd()`处理程序简单地调用`penUp()`，与`onMouseUp()`一样。'
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*What just happened?*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a reusable jQuery extension to add touch events to any element and
    added touch support to our application. We now have a drawing application that
    can be used to draw on both desktop and mobile devices.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个可重用的jQuery扩展，以向任何元素添加触摸事件，并向我们的应用程序添加了触摸支持。我们现在有一个可以用于在桌面和移动设备上绘制的绘图应用程序。
- en: With that our Canvas Pad application is complete, but we are not done with learning
    about the canvas. Now we'll move on to our next application, Photo Pad, where
    we will learn about some more advanced canvas features and the File API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的Canvas Pad应用程序就完成了，但我们还没有完成学习有关画布的知识。现在我们将转向我们的下一个应用程序Photo Pad，在那里我们将学习一些更高级的画布功能和文件API。
- en: Photo Pad
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Photo Pad
- en: The next application we are going to write is called Photo Pad. It will look
    a lot like Canvas Pad, and reuse the same code for the toolbar and menus. But
    instead of being a drawing application, it will be a photo manipulation application.
    The user will be able to load images and select from a few different effects,
    such as invert, black and white, or sepia, to apply to the image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要编写的应用程序叫做Photo Pad。它看起来很像Canvas Pad，并且重用了工具栏和菜单的相同代码。但它不是一个绘图应用程序，而是一个照片处理应用程序。用户将能够加载图像并从几种不同的效果中选择，例如反转、黑白或棕褐色，然后应用到图像上。
- en: Time for action – creating Photo Pad
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建Photo Pad
- en: 'Let''s start off, as usual, by copying the application template we created
    in [Chapter 1](ch01.html "Chapter 1. The Task at Hand"), *The Task at Hand*, and
    renaming the filenames to `photoPad.html`, `photoPad.css`, and `photoPad.js`.
    In the HTML file, we will add a toolbar with buttons for Load, Save, and Effects.
    You can find the code for this section in `Chapter 5/example5.2`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像往常一样，首先复制我们在[第1章](ch01.html "第1章。手头的任务")中创建的应用程序模板，然后将文件重命名为`photoPad.html`，`photoPad.css`和`photoPad.js`。在HTML文件中，我们将添加一个带有加载、保存和效果按钮的工具栏。您可以在`第5章/example5.2`中找到此部分的代码：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Load toolbar item has a drop-down menu, but instead of menu items it has
    a file input control in it where the user can select a file to load. The Effects
    item has a drop-down menu of effects. For now we just have one in there, Invert,
    but we will add more later.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 加载工具栏项有一个下拉菜单，但里面没有菜单项，而是有一个文件输入控件，用户可以在其中选择要加载的文件。效果项目有一个效果的下拉菜单。目前我们只有一个，即反转，但以后我们会添加更多。
- en: For our CSS we will copy everything we had in `canvasPad.css` to `photoPad.css`,
    so that we get all of the same styling for the toolbar and menus. We will also
    use the `Toolbar` object in `toolbar.js`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的CSS，我们将把`canvasPad.css`中的所有内容复制到`photoPad.css`中，这样我们就可以获得工具栏和菜单的所有相同样式。我们还将在`toolbar.js`中使用`Toolbar`对象。
- en: 'In our JavaScript file we will change the application object name to `PhotoPadApp`.
    We also need a couple of variables in `PhotoPadApp`. We will set the `canvas`
    variable to the `<canvas>` element, the `context` variable to the canvas''s context,
    and define an `$img` variable to hold the image we will be showing. Here we initialize
    it to a new `<img>` element using jQuery:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript文件中，我们将应用程序对象名称更改为`PhotoPadApp`。我们还需要在`PhotoPadApp`中定义一些变量。我们将`canvas`变量设置为`<canvas>`元素，将`context`变量设置为画布的上下文，并定义一个`$img`变量来保存我们将要显示的图像。在这里，我们使用jQuery将其初始化为一个新的`<img>`元素：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first toolbar action we will implement is the **Save** button, since we
    already have that code from Canvas Pad. We check the action in `toolbarButtonClicked()`
    to see if it''s `"save"`, and if so we get the data URL and open it in a new browser
    window:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一个工具栏操作是**保存**按钮，因为我们已经从Canvas Pad中拥有了该代码。我们在`toolbarButtonClicked()`中检查操作是否为`"save"`，如果是，我们获取数据URL并在新的浏览器窗口中打开它：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*What just happened?*'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created the scaffolding for the Photo Pad application with toolbar items
    for Load, Save, and Effects. We implemented the save function the same as we did
    for Canvas Pad.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用工具栏项目为Photo Pad应用程序创建了脚手架，包括加载、保存和效果。我们实现了与Canvas Pad相同的保存功能。
- en: The next thing we'll implement is the Load drop-down menu since we need an image
    to manipulate. When the **Load** toolbar button is clicked, it will show the drop-down
    menu with a file input control in it that we defined previously. All of that we
    get for free because it's just another drop-down menu in our toolbar.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要实现的是加载下拉菜单，因为我们需要一个图像来操作。当单击**加载**工具栏按钮时，它将显示带有我们之前定义的文件输入控件的下拉菜单。所有这些都是免费的，因为它只是工具栏中的另一个下拉菜单。
- en: But before we can do that we need to learn about the HTML5 File API.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但在此之前，我们需要了解HTML5文件API。
- en: The File API
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件API
- en: 'We may not be able to save files directly to the user''s filesystem, but we
    can access files using HTML5''s File API. The File API allows you to get information
    about, and load the contents of, files that the user selects. The user can select
    files using an input element with a type of `file`. The process for loading a
    file works in the following way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能无法直接将文件保存到用户的文件系统，但我们可以使用HTML5的文件API访问文件。文件API允许您获取有关用户选择的文件的信息并加载文件的内容。用户可以使用类型为`file`的输入元素选择文件。加载文件的过程如下：
- en: The user selects one or more files using a `<input type="file">` element.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户使用`<input type="file">`元素选择一个或多个文件。
- en: We get the list of files from the input element's `files` property. The list
    is a `FileList` object containing File objects.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从输入元素的`files`属性中获取文件列表。该列表是一个包含File对象的`FileList`对象。
- en: You can enumerate over the file list and access the files just like you would
    an array.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以枚举文件列表并像访问数组一样访问文件。
- en: The `File` object contains three fields.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`对象包含三个字段。'
- en: '`name`: This is the filename. It doesn''t include path information.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是文件名。它不包括路径信息。'
- en: '`size`: This is the size of the file in bytes.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`: 这是文件的大小（以字节为单位）。'
- en: '`type`: This is the MIME type, if it can be determined.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 这是MIME类型，如果可以确定的话。'
- en: Use a `FileReader` object to read the file's data. The file is loaded asynchronously.
    After the file has been read, it will call the `onload` event handler. `FileReader`
    has a number of methods for reading files that take a `File` object and return
    the file contents.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FileReader`对象读取文件的数据。文件是异步加载的。文件读取后，它将调用`onload`事件处理程序。`FileReader`有许多用于读取文件的方法，这些方法接受一个`File`对象并返回文件内容。
- en: '`readAsArrayBuffer()`: This method reads the file contents into an `ArrayBuffer`
    object.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAsArrayBuffer()`: 此方法将文件内容读入`ArrayBuffer`对象中。'
- en: '`readAsBinaryString()`: This method reads the file contents into a string as
    binary data.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAsBinaryString()`: 此方法将文件内容作为二进制数据读入字符串中。'
- en: '`readAsText()`: This method reads the file contents into a string as text.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAsText()`: 此方法将文件内容作为文本读入字符串中。'
- en: '`readAsDataURL()`: This method reads the file contents into a data URL string.
    You can use this as the URL for loading an image.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAsDataURL()`: 此方法将文件内容读入数据URL字符串。您可以将其用作加载图像的URL。'
- en: Time for action – loading an image file
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-加载图像文件
- en: 'Let''s add some code to the `start()` method of our application to check if
    the File API is available. You can determine if a browser supports the File API
    by checking if the `File` and `FileReader` objects exist:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序的`start()`方法中添加一些代码来检查文件API是否可用。您可以通过检查`File`和`FileReader`对象是否存在来确定浏览器是否支持文件API：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First we check if the `File` and `FileReader` objects are available in the `window`
    object. If so, we hook up a change event handler for the file input control to
    call the `onLoadFile()` method passing in the `<input>` element wrapped in a jQuery
    object. If the File API is not available we will just load a default image by
    calling `loadImage()`, which we will write later.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`window`对象中是否有`File`和`FileReader`对象。如果有，我们将为文件输入控件连接一个change事件处理程序，以调用`onLoadFile()`方法并传入用jQuery对象包装的`<input>`元素。如果文件API不可用，我们将通过调用`loadImage()`来加载默认图像，稍后我们将编写该方法。
- en: 'Let''s implement the `onLoadFile()` event handler method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`onLoadFile()`事件处理程序方法：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we get the file that was selected by looking at the file input's `files`
    array and taking the first one. Next we check the file type, which is a MIME type,
    to make sure it is an image. We are using the `String` object's regular expression
    `match()` method to check that it starts with `"image"`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过查看文件输入的`files`数组并取第一个来获取所选的文件。接下来，我们检查文件类型，即MIME类型，以确保它是图像。我们使用`String`对象的正则表达式`match()`方法来检查它是否以`"image"`开头。
- en: If it is an image, we create a new instance of the `FileReader` object. Then
    we set the `onload` event handler to call the `loadImage()` method, passing in
    the `FileReader` object's `result` field, which contains the file's contents.
    Lastly, we call the `FileReader` object's `readAsDataURL()` method, passing in
    the `File` object to start loading the file asynchronously.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是图像，我们将创建`FileReader`对象的一个新实例。然后，我们将设置`onload`事件处理程序以调用`loadImage()`方法，并传入`FileReader`对象的`result`字段，其中包含文件的内容。最后，我们调用`FileReader`对象的`readAsDataURL()`方法，传入`File`对象以异步开始加载文件。
- en: If it isn't an image file, we show an alert dialog box with an error message
    and show an error message in the footer by calling `setStatus()`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是图像文件，我们将显示一个带有错误消息的警报对话框，并通过调用`setStatus()`在页脚显示错误消息。
- en: 'Once the file has been read, the `loadImage()` method will be called. Here
    we will use the data URL we got from the `FileReader` object''s `result` field
    to draw the image into the canvas:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 文件读取完成后，将调用`loadImage()`方法。在这里，我们将使用从`FileReader`对象的`result`字段获得的数据URL将图像绘制到画布中：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First we set the `src` attribute for the image element to the data URL we got
    after the file was loaded. This will cause the image element to load that new
    image.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将图像元素的`src`属性设置为文件加载后获得的数据URL。这将导致图像元素加载新图像。
- en: Next we define the `onload` event handler for the image, so that we are notified
    when the image is loaded. Note that when we are inside the `onload` event handler,
    `this` points to the `<image>` element. First we change the canvas' width and
    height to the image's width and height. Then we draw the image on the canvas using
    the context's `drawImage()` method. It takes the image to draw and the x and y
    coordinates of where to draw it. In this case we draw it at the top-left corner
    of the canvas (0, 0).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为图像定义了`onload`事件处理程序，以便在图像加载时收到通知。请注意，当我们在`onload`事件处理程序内部时，`this`指向`<image>`元素。首先，我们将画布的宽度和高度更改为图像的宽度和高度。然后，我们使用上下文的`drawImage()`方法在画布上绘制图像。它接受要绘制的图像以及要绘制的x和y坐标。在这种情况下，我们在画布的左上角（0,0）绘制它。
- en: Lastly, we set an `onerror` event handler for the image. If an error occurs
    loading the image, we show an error message in the footer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为图像设置了一个`onerror`事件处理程序。如果加载图像时发生错误，我们将在页脚显示错误消息。
- en: '*What just happened?*'
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We learned how to use the File API to load an image file from the user's filesystem.
    After the image was loaded we resized the canvas to the size of the image and
    drew the image onto the canvas.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用文件API从用户的文件系统加载图像文件。在加载图像后，我们调整了画布的大小以适应图像的大小，并将图像绘制到画布上。
- en: Adding effects
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加效果
- en: Now let's add some effects to the effects menu. The first one we will implement
    is a color inverter. It will take the image in the canvas and invert the colors
    so the image looks like an old film negative (remember those?). We can do this
    by iterating over every pixel in the image and inverting their colors.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向效果菜单添加一些效果。我们将首先实现的是颜色反转。它将获取画布中的图像并反转颜色，使图像看起来像旧的底片（还记得那些吗？）。我们可以通过迭代图像中的每个像素并反转它们的颜色来实现这一点。
- en: 'You can get the pixels from the canvas using the context''s `getImageData()`
    method. It gets the pixels for a rectangular area of the canvas. You pass it the
    position and size of the area:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上下文的`getImageData()`方法从画布中获取像素。它获取画布的矩形区域的像素。您传递它区域的位置和大小：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `getImageData()` method returns an array of bytes, four for each pixel,
    that represent each pixel's color. The first byte is the red amount, second is
    the green amount, third is the blue amount, and fourth is the alpha amount. All
    values are from 0 to 255\. The total number of bytes in the array is *4 * width
    * height*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`getImageData()`方法返回一个字节数组，每个像素有四个字节，代表每个像素的颜色。第一个字节是红色量，第二个是绿色量，第三个是蓝色量，第四个是alpha量。所有值都在0到255之间。数组中的字节总数为*4
    *宽度*高度*。'
- en: After you get the image data, you can access and change any value in the array
    that you want. Note that this will only change the image in memory. After changing
    image data, you can write it back to the canvas using the `putImageData()` method.
    This method takes parameters for the image data to draw and the position to draw
    it at.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取图像数据之后，您可以访问和更改数组中的任何值。请注意，这只会更改内存中的图像。更改图像数据后，您可以使用`putImageData()`方法将其写回到画布。此方法接受要绘制的图像数据和要绘制的位置的参数。
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Time for action – the imageEffects object
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-图像效果对象
- en: We will now create a new object called `imageEffects` to encapsulate all of
    the code for our image effects and put it in a new file, `imageEffects.js`. The
    `imageEffects` object will be a global static object defined using the revealing
    module pattern.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`imageEffects`的新对象，将所有图像效果的代码封装在一个新文件`imageEffects.js`中。`imageEffects`对象将是使用揭示模块模式定义的全局静态对象。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With the revealing module pattern, you define a set of functions in a private
    scope and then return an anonymous object that reveals which of those methods
    you want to be public. This works well for defining static objects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用揭示模块模式，您在私有范围内定义一组函数，然后返回一个匿名对象，该对象公开了您想要公开的这些方法。这对于定义静态对象很有效。
- en: 'Let''s start by defining the `imageEffects` object and adding two helper functions
    which will remain private. They are used to get and set the image data for the
    entire canvas:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义`imageEffects`对象，并添加两个保持私有的辅助函数。它们用于获取和设置整个画布的图像数据：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `getImageData()` method takes a canvas and returns the image data for the
    entire canvas. The `putImageData()` method takes a canvas and image data as parameters
    and puts the image data back into the canvas.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`getImageData()`方法获取画布并返回整个画布的图像数据。`putImageData()`方法接受画布和图像数据作为参数，并将图像数据放回画布。'
- en: 'Let''s implement our first effect; inverting the colors of an image. The `invert()`
    method takes the canvas as a parameter. Inverting colors is very simple. We just
    take each color channel for each pixel and subtract its value from the maximum
    color value of 255:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们的第一个效果；反转图像的颜色。`invert()`方法以画布作为参数。反转颜色非常简单。我们只需取每个像素的每个颜色通道并从255的最大颜色值中减去它的值：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First we get the image data for the canvas and then loop over the bytes, incrementing
    by four every time because there are four bytes for each pixel. Each color channel
    value is inverted and set back into the byte. The alpha amount is unchanged. Then
    we put the image data back onto the canvas.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取画布的图像数据，然后循环遍历字节，每次递增四个，因为每个像素有四个字节。每个颜色通道值都被反转并设置回字节中。Alpha值保持不变。然后我们将图像数据放回画布。
- en: 'Now let''s finish the `imageEffects` object off. We need to return an anonymous
    object that defines all of the methods that we want to be public. The only one
    we have so far is the `invert()` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们完成`imageEffects`对象。我们需要返回一个匿名对象，定义我们想要公开的所有方法。到目前为止，我们只有`invert()`方法：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we have open and close parenthesis at the end of the function declaration.
    That immediately executes the function and assigns the anonymous object returned
    to the `imageEffects` variable. So now we have an `imageEffects` object with an
    `invert()` public method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在函数声明的末尾有开括号和闭括号。这立即执行函数，并将返回的匿名对象分配给`imageEffects`变量。所以现在我们有一个`imageEffects`对象，其中有一个`invert()`公共方法。
- en: 'Now we need to hook up our Effects menu items to the `imageEffects` object.
    We can do this in the `menuItemClicked()` method of `PhotoPadApp`. Previously
    we gave our menu element a `data-option` custom attribute of `"applyEffect"`.
    So we will check for that:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将Effects菜单项与`imageEffects`对象连接起来。我们可以在`PhotoPadApp`的`menuItemClicked()`方法中进行这样的操作。之前，我们给菜单元素设置了一个`data-option`自定义属性，值为`"applyEffect"`。所以我们将检查这个属性：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have given our Invert menu item element a `data-value` custom attribute set
    to `"invert"`. We will use this to dynamically access the `invert()` method in
    the `imageEffects` object, just like we did for data binding in [Chapter 3](ch03.html
    "Chapter 3. The Devil is in the Details"), *The Devil is in the Details*. We pass
    in the `canvas` object as a parameter. For `"invert"`, this is equivalent to calling
    `imageEffects.invert(canvas)`. We will implement all of our menu items in this
    way so that they automatically bind to a method in the `imageEffects` object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给Invert菜单项元素设置了一个`data-value`自定义属性，值为`"invert"`。我们将使用这个值来动态访问`imageEffects`对象中的`invert()`方法，就像我们在[第3章](ch03.html
    "第3章。细节决定成败")中进行数据绑定一样。我们将`canvas`对象作为参数传递。对于`"invert"`，这相当于调用`imageEffects.invert(canvas)`。我们将以这种方式实现所有菜单项，以便它们自动绑定到`imageEffects`对象中的方法。
- en: '*What just happened?*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created an `imageEffects` object to hold all of our image effects algorithms.
    We implemented an effect to invert the colors of an image. We hooked up the Effects
    menu using custom data attributes to bind the menu items to methods in the `imageEffects`
    object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`imageEffects`对象来保存所有的图像效果算法。我们实现了一个反转图像颜色的效果。我们使用自定义数据属性将Effects菜单与`imageEffects`对象中的方法绑定起来。
- en: 'Now let''s open up our application in the browser and give it a try. After
    loading an image, choose **Invert** from the **Effects** menu and you should see
    the inverted image:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在浏览器中打开我们的应用程序并尝试一下。加载图像后，从Effects菜单中选择**Invert**，您应该看到反转后的图像：
- en: '![What just happened?](img/5947OT_05_01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_05_01.jpg)'
- en: Time for action – black and white
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑白时间行动
- en: 'Ok, the `invert()` method was pretty simple. Let''s try something a little
    more challenging, but not much more. We will implement an effect that changes
    a color image to black and white. Let''s implement a `toBlackAnWhite()` method
    in the `imageEffects` object:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`invert()`方法非常简单。让我们尝试一些更具挑战性的东西，但不是太多。我们将实现一个将彩色图像转换为黑白的效果。让我们在`imageEffects`对象中实现一个`toBlackAnWhite()`方法：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For each pixel, we compute the gray scale value by taking a percentage of each
    color channel and adding them together; 30 percent red, 59 percent green, and
    11 percent blue. Then we set each color channel to that gray scale value.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个像素，我们通过取每个颜色通道的百分比并将它们相加来计算灰度值；30%红色，59%绿色和11%蓝色。然后我们将每个颜色通道设置为该灰度值。
- en: 'Now let''s add a menu item for black and white to the Effects menu. The `data-value`
    attribute is set to the method we created previously, `toBlackAndWhite`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在Effects菜单中添加一个黑白菜单项。`data-value`属性设置为我们之前创建的方法`toBlackAndWhite`：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*What just happened?*'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We created a filter to change each pixel to its gray scale value and set it
    back into the image data. Now we can convert a color image to black and white:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个过滤器，将每个像素更改为其灰度值，并将其设置回图像数据中。现在我们可以将彩色图像转换为黑白：
- en: '![What just happened?](img/5947OT_05_02.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_05_02.jpg)'
- en: Time for action – sepia
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 古铜时间行动
- en: 'Let''s implement another simple effect. This time we will convert the image
    to sepia, which gives it an old-timey picture look. Sepia is very similar to black
    and white except a little warmer. First let''s add the menu item for it and set
    the `data-value` attribute to `toSepia`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现另一个简单的效果。这次我们将图像转换为古铜色，给它一种老式照片的外观。古铜色与黑白色非常相似，只是略微温暖。首先让我们为它添加菜单项，并将`data-value`属性设置为`toSepia`：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now let''s add a `toSepia()` method to the `imageEffects` object.:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`imageEffects`对象中添加一个`toSepia()`方法。
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although `toSepia()` has three parameters, we will only pass in one parameter,
    the canvas, so we can use our default Effects menu handling code, and set the
    rest to default values. The first two lines of the method set default values for
    the `depth` and `intensity` parameters. `depth` is used to adjust the red and
    green channels and `intensity` is used to adjust the blue channel to give more
    fine-tuning over the final result.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`toSepia()`有三个参数，但我们只会传入一个参数，即画布，这样我们就可以使用我们的默认Effects菜单处理代码，并将其余设置为默认值。该方法的前两行设置了`depth`和`intensity`参数的默认值。`depth`用于调整红色和绿色通道，`intensity`用于调整蓝色通道，以便更精细调整最终结果。
- en: To convert a pixel to its sepia tone, we first get the gray scale value the
    same way as we did for black and white. Then instead of just setting the gray
    scale for all color channels, we adjust those values based on the channel. Red
    is boosted the most, which accounts for sepia's reddish tone. Green is also boosted,
    half as much as red. Blue is reduced by the intensity amount. We use the `Math.max()`
    and `min()` function to make sure we don't set the value out of range.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要将像素转换为它的棕褐色调，我们首先以与黑白相同的方式获取灰度值。然后，我们根据通道调整这些值，而不仅仅是为所有颜色通道设置灰度。红色增强最多，这解释了棕褐色的红色调。绿色也增强，增强的程度是红色的一半。蓝色按强度值减少。我们使用`Math.max()`和`min()`函数来确保我们不会设置超出范围的值。
- en: '*What just happened?*'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We created a filter to convert color images to sepia by finding the gray scale
    and then adjusting the color channels independently by a fixed amount that can
    be passed in as parameters or defaulted:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个滤镜，通过找到灰度并独立调整颜色通道的固定数量来将彩色图像转换为棕褐色，这个数量可以作为参数传入或默认值：
- en: '![What just happened?](img/5947OT_05_03.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947OT_05_03.jpg)'
- en: Have a go hero
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看
- en: Try using different percentages of red, green, and blue when computing the gray
    scale value to see what effect it has on the image. Try passing in different values
    for depth and intensity to see what effect it has on the sepia tone.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在计算灰度值时使用不同百分比的红色、绿色和蓝色，看看它对图像有什么影响。尝试传入不同的深度和强度值，看看它对棕褐色调有什么影响。
- en: Image distortion
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像失真
- en: Next we will add a more advanced effect. We will take the image and distort
    it with waves to make it look like a reflection in the water. We can do this using
    the `Math.sin()` method to offset the pixel positions from their original positions
    in a wavy pattern. So instead of changing color channels, this time we will be
    moving pixels around.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个更高级的效果。我们将采用图像并使用波浪进行扭曲，使其看起来像是水中的倒影。我们可以使用`Math.sin()`方法来偏移像素位置，使其呈波浪状。因此，这一次我们不是改变颜色通道，而是移动像素。
- en: Time for action – making waves
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-制造波浪
- en: 'Let''s add the menu item for our wave effect. We give it a `data-value` custom
    attribute set to `makeWaves`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的波浪效果添加菜单项。我们给它一个`data-value`自定义属性，设置为`makeWaves`：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we will code the `makeWaves()` method. It will take four parameters; `canvas`,
    `amplitude`, `frequency`, and `phase`. `amplitude` determines how big the waves
    will be, `frequency` determines how many waves there are, and `phase` determines
    where the waves begin. Like the `toSepia()` method we will only pass in the `canvas`
    parameter, but you can try different parameters to see what effect they have:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写`makeWaves()`方法。它将有四个参数；`canvas`、`amplitude`、`frequency`和`phase`。`amplitude`确定波浪的大小，`frequency`确定有多少波浪，`phase`确定波浪从哪里开始。与`toSepia()`方法一样，我们只会传入`canvas`参数，但您可以尝试不同的参数，看看它们有什么影响：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First thing we do is set the default values for the parameters. Then we set
    up some variables. This time we will need two sets of image data. One is our original
    image and the other, `newImageData`, is our working set that we will be changing
    and eventually write back to the canvas.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是设置参数的默认值。然后设置一些变量。这一次我们将需要两组图像数据。一个是我们的原始图像，另一个`newImageData`是我们将要更改并最终写回画布的工作集。
- en: Next we adjust the frequency value so it is relative to the height of the image.
    That way if we want a frequency of four, there will be four waves from top to
    bottom of the image.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调整频率值，使其相对于图像的高度。这样，如果我们想要频率为四，图像从顶部到底部将有四个波浪。
- en: Now it's time to iterate over the pixels. In the outer loop we iterate over
    the rows of the image. For each row we calculate the x offset by computing the
    sine value for that row and multiplying it by 4, the number of color channels
    per pixel. This gives us the offset, in bytes, into the image data array. We also
    compute the y offset, which is the byte offset into the array for the current
    row.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候迭代像素了。在外部循环中，我们迭代图像的行。对于每一行，我们通过计算该行的正弦值并将其乘以4（每个像素的颜色通道数）来计算x偏移量。这给我们提供了偏移量，以字节为单位，进入图像数据数组。我们还计算y偏移量，这是当前行数组的字节偏移量。
- en: 'Next we iterate over each pixel in the row. Inside this loop we copy the pixel
    data from the original image data to the working image data array offsetting the
    positions. Applying the sine wave to get the pixel offsets gives us a wavy pattern:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们迭代每一行中的每个像素。在这个循环内，我们将像素数据从原始图像数据复制到工作图像数据数组中，偏移位置。应用正弦波以获取像素偏移量会给我们一个波浪般的图案：
- en: '![Time for action – making waves](img/5947OT_05_04.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-制造波浪](img/5947OT_05_04.jpg)'
- en: '*What just happened?*'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a distortion effect that uses a sine wave to make an image look wavy.
    It does this by computing the offset from the original image and copying the pixels
    to the new image using the offset.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个失真效果，使用正弦波使图像看起来波浪起伏。它通过计算从原始图像的偏移量并将像素复制到新图像中来实现这一点。
- en: Have a go hero
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看
- en: Try coming up with your own effect and adding it to the Photo Pad application.
    For example, you could darken or lighten an image. For a more advanced effect
    try to blur the image by computing the average color of a pixel and its neighboring
    pixels (if you want to see how it's done, I've implemented it in the example code
    for this section).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试想出自己的效果并将其添加到Photo Pad应用程序中。例如，您可以使图像变暗或变亮。对于更高级的效果，请尝试通过计算像素及其相邻像素的平均颜色来模糊图像（如果您想看看如何实现，我已经在本节的示例代码中实现了它）。
- en: Pop quiz
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: Q1\. How are touch events different from mouse events?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 触摸事件与鼠标事件有何不同？
- en: Touch events can have any number of points
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触摸事件可以有任意数量的点
- en: Touch events don't have any points
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触摸事件没有任何点
- en: Touch events don't have a `preventDefault()` method
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触摸事件没有`preventDefault()`方法
- en: There is no difference
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有区别
- en: Q2\. How many bytes per pixel are there in the canvas image data?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 画布图像数据中每个像素有多少字节？
- en: One
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一
- en: Three
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三
- en: Four
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四
- en: Eight
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 八
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we continued working with the Canvas Pad application. We learned
    about drawing text on the canvas and transformations by drawing an ellipse. We
    made Canvas Pad touch enabled by adding support for touch events. Then we created
    a new application called Photo Pad where we learned about loading files from the
    user's filesystem using the HTML5 File API. We did some image processing to learn
    how to directly access and manipulate pixels on the canvas.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续使用Canvas Pad应用程序。我们学习了在画布上绘制文本和通过绘制椭圆来进行变换。我们通过添加对触摸事件的支持使Canvas Pad具备了触摸功能。然后我们创建了一个名为Photo
    Pad的新应用程序，在那里我们学习了如何使用HTML5文件API从用户文件系统加载文件。我们进行了一些图像处理，以学习如何直接访问和操纵画布上的像素。
- en: 'We covered the following concepts in this chapter:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下概念：
- en: How to draw text on the canvas
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在画布上绘制文本
- en: How to use the Canvas API transformations to translate, rotate, scale and so
    on, to change the way things are drawn to the canvas
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Canvas API的变换来进行平移、旋转、缩放等操作，以改变画布上的绘制方式
- en: How to create a jQuery plugin to check for touch devices and add touch events
    to elements
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个jQuery插件来检查触摸设备并为元素添加触摸事件
- en: How to use the File API to access files on the user's filesystem and read them
    into memory using the `FileReader` object
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用文件API访问用户文件系统中的文件，并使用`FileReader`对象将它们读入内存
- en: How to load an image file and draw it into the canvas
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加载图像文件并将其绘制到画布上
- en: How to access the pixels of the canvas and manipulate their colors to implement
    some image processing filters
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问画布的像素并操纵它们的颜色以实现一些图像处理滤镜
- en: In the next chapter we head off in a whole new direction again. We will learn
    about the HTML5 `<audio>` element and Audio API by building a virtual piano.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将再次开启全新的方向。我们将通过构建一个虚拟钢琴来学习HTML5 `<audio>`元素和音频API。
