- en: Chapter 6. Piano Man
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 钢琴人
- en: '"More than art, more than literature, music is universally accessible." – Billy
    Joel'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “音乐不仅是艺术，不仅是文学，它是普遍可及的。” – 比利·乔尔
- en: '*In this chapter, we will learn how to use audio by creating a virtual piano
    application. First, we will learn about the HTML5 Audio element and API. Then
    we will create an audio manager to load audio files asynchronously and cache them
    for playback later. We will create a keyboard using HTML elements and style it
    using CSS.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将通过创建一个虚拟钢琴应用程序来学习如何使用音频。首先，我们将学习 HTML5 音频元素和 API。然后，我们将创建一个音频管理器，以异步加载音频文件并缓存它们以供以后播放。我们将使用
    HTML 元素创建一个键盘，并使用 CSS 进行样式设置。*'
- en: 'We will learn the following in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The HTML5 `<audio>` element and its attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5 `<audio>` 元素及其属性
- en: How to use the Audio API to control audio in an application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用音频 API 来控制应用程序中的音频
- en: How to dynamically load audio files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何动态加载音频文件
- en: How to handle keyboard events to turn the computer keyboard into a piano keyboard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理键盘事件，将计算机键盘转换为钢琴键盘
- en: How to use a range input to control the volume of an audio element
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用范围输入来控制音频元素的音量
- en: How to check if the range input type is supported by your browser
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检查您的浏览器是否支持范围输入类型
- en: HTML5 audio overview
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5 音频概述
- en: Before we start writing our piano application, we need to learn the basics of
    how to use HTML5 audio. So let's start with an overview of the `<audio>` element
    and its API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写钢琴应用程序之前，我们需要学习如何使用 HTML5 音频的基础知识。因此，让我们从 `<audio>` 元素及其 API 的概述开始。
- en: The HTML5 <audio> element
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML5 <audio> 元素
- en: 'The HTML5 `<audio>` element is used to define an audio file to play in your
    web page or application. The `audio` element can have visible controls on the
    page or it can remain hidden and be controlled from JavaScript. Here are a few
    of the most useful attributes it supports:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 `<audio>` 元素用于定义在网页或应用程序中播放的音频文件。`audio` 元素可以在页面上具有可见控件，也可以保持隐藏并且可以通过
    JavaScript 进行控制。以下是它支持的一些最有用的属性：
- en: '`src`: URL of the audio file to load.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 要加载的音频文件的 URL。'
- en: '`autoplay`: Used to specify that the file should start playing as soon as it''s
    loaded.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoplay`: 用于指定文件在加载后立即开始播放。'
- en: '`controls`: Tells the browser to display audio controls on the page. Otherwise,
    nothing is displayed for the element.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controls`: 告诉浏览器在页面上显示音频控件。否则，元素不会显示任何内容。'
- en: '`loop`: Specifies that the audio will play in a loop.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`: 指定音频将循环播放。'
- en: '`muted`: Specifies that the audio will be muted.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`muted`: 指定音频将被静音。'
- en: '`preload`: Defines how the audio file is loaded.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preload`: 定义音频文件的加载方式。'
- en: '`auto`: Loads the audio file when the page loads. This is the default.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`: 页面加载时加载音频文件。这是默认设置。'
- en: '`none`: Does not preload the file, waits until it is played.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`: 不预加载文件，等待播放。'
- en: '`metadata`: Loads only metadata about the file when the page loads.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`: 页面加载时仅加载有关文件的元数据。'
- en: 'The following plays `audioFile.mp3` automatically after the page loads and
    shows the audio controls on the page:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下在页面加载后自动播放 `audioFile.mp3` 并在页面上显示音频控件：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s what it looks like when displayed on the page in Chrome:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 上显示在页面上时的样子如下：
- en: '![The HTML5 <audio> element](img/5947_06_05.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![HTML5 <audio> 元素](img/5947_06_05.jpg)'
- en: If the browser doesn't support the `<audio>` element, it will display whatever
    content is inside the element.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器不支持 `<audio>` 元素，它将显示元素内的任何内容。
- en: 'Although you can specify the file to load using the `src` attribute, it is
    not recommended. Different browsers support different file types, so if you only
    specify one it may not work on all browsers. Instead, you should specify `<source>`
    child elements inside the `<audio>` element to define a list of different audio
    files to use. The browser will use the first one that it supports:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用 `src` 属性指定要加载的文件，但不建议这样做。不同的浏览器支持不同的文件类型，因此如果您只指定一个文件，它可能在所有浏览器上都无法工作。相反，您应该在
    `<audio>` 元素内指定 `<source>` 子元素，以定义要使用的不同音频文件的列表。浏览器将使用它支持的第一个文件：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The three primary audio types supported are MP3, Ogg, and WAV. You should at
    least provide the MP3 and Ogg files, since all of the major browsers support one
    or the other. If you also want to include a WAV file, put it last in the list
    since WAV files are not compressed and therefore take a lot of bandwidth to download.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的三种主要音频类型是 MP3、Ogg 和 WAV。您至少应提供 MP3 和 Ogg 文件，因为所有主要浏览器都支持其中一种。如果您还想包括 WAV
    文件，请将其放在列表的最后，因为 WAV 文件未经压缩，因此需要大量带宽来下载。
- en: The HTML5 Audio API
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML5 音频 API
- en: If all you could do with HTML5 audio is put an element on a web page to let
    the user listen to music, it would be pretty boring, and this chapter would be
    over. But like the `<canvas>` element, the `<audio>` element has a whole API backing
    it up. We can use the Audio API to control how and when audio clips are played
    from JavaScript.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只能使用 HTML5 音频在网页上放置一个元素让用户听音乐，那将会很无聊，这一章将结束。但是像 `<canvas>` 元素一样，`<audio>`
    元素有一个完整的 API 支持它。我们可以使用音频 API 来控制何时以及如何从 JavaScript 播放音频剪辑。
- en: 'The Audio API contains a large number of methods and properties. Here are a
    few of the most useful ones:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 音频 API 包含大量的方法和属性。以下是其中一些最有用的方法：
- en: '`play()`: Starts playing the audio clip.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play()`: 开始播放音频剪辑。'
- en: '`pause()`: Pauses playback of the audio clip.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause()`: 暂停音频剪辑的播放。'
- en: '`canPlayType(type)`: Used to determine if a certain audio type is supported
    by the browser. Pass in an audio MIME type such as `"audio/ogg"` or `"audio/mpeg"`.
    It returns one of the following values:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canPlayType(type)`: 用于确定浏览器是否支持某种音频类型。传入音频 MIME 类型，如 `"audio/ogg"` 或 `"audio/mpeg"`。它返回以下值之一：'
- en: '`"probably"`: Most likely supports it'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"probably"`: 很可能支持'
- en: '`"maybe"`: The browser may be able to play it'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"maybe"`: 浏览器可能能够播放它'
- en: '`""` (empty string): Doesn''t support it'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`（空字符串）：不支持'
- en: '`currentTime`: Used to get or set the current playback time in seconds. This
    allows us to cue up the sound at a certain point before playing it. Usually we
    will set it to `0` to restart the sound.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentTime`：用于获取或设置当前播放时间（以秒为单位）。这使我们能够在播放之前将声音定位到某个特定点。通常我们会将其设置为`0`以重新开始播放声音。'
- en: '`volume`: Used to get or set the volume. Can be any value between `0` and `1`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：用于获取或设置音量。可以是`0`到`1`之间的任何值。'
- en: '`ended`: Used to determine if the sound has played all the way through.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ended`：用于确定声音是否已完全播放。'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `<audio>` and `<video>` elements both share the same API. So if
    you know how to use HTML audio, you know how to use video as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`<audio>`和`<video>`元素都共享相同的API。因此，如果你知道如何使用HTML音频，你也知道如何使用视频。
- en: We can use the Audio API to do some interesting things with sounds. In this
    chapter, we will create a virtual piano that the user can play on the web page
    by clicking the keys of a piano keyboard on the screen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用音频API来做一些有趣的事情。在本章中，我们将创建一个虚拟钢琴，用户可以通过在屏幕上点击钢琴键来在网页上演奏。
- en: Loading audio files
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载音频文件
- en: 'You could define all of the audio files for your application by adding `<audio>`
    elements for each one to your HTML file. However, we can also load audio files
    dynamically from JavaScript to control how and when they are loaded. We can load
    them just like we loaded image files dynamically in the previous chapter. First,
    we create a new `<audio>` element and set the `src` attribute to the name of the
    audio file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在HTML文件中为每个音频文件添加`<audio>`元素来定义应用程序的所有音频文件。但是，我们也可以从JavaScript动态加载音频文件，以控制它们的加载方式和时间。我们可以像在上一章中动态加载图像文件一样加载它们。首先，我们创建一个新的`<audio>`元素，并将`src`属性设置为音频文件的名称：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we add an event handler to get notified when the audio file has finished
    loading. There are two events that we can use. The `canplay` event is fired as
    soon as the browser has enough data to start playing the audio. The `canplaythrough`
    event is fired after the file has been completely loaded:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个事件处理程序，以便在音频文件加载完成时收到通知。我们可以使用两个事件。`canplay`事件在浏览器有足够的数据开始播放音频时触发。`canplaythrough`事件在文件完全加载后触发：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Time for action – creating an AudioManager object
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建AudioManager对象
- en: Let's encapsulate the loading of audio files into a re-usable object. We will
    create a new object called `AudioManager` and place it in a file named `audioManager.js`.
    This object will abstract all of the code needed to load, cache, and access audio
    files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将加载音频文件封装到一个可重用的对象中。我们将创建一个名为`AudioManager`的新对象，并将其放在名为`audioManager.js`的文件中。该对象将抽象出加载、缓存和访问音频文件所需的所有代码。
- en: 'The constructor for our object takes one parameter named `audioPath`, which
    is the path to where audio files are stored:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对象的构造函数接受一个名为`audioPath`的参数，这是存储音频文件的路径：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If `audioPath` isn''t defined, we default it to an empty string. Then we add
    a variable named `audios` which is an object that will be used to cache all of
    the `<audio>` elements that are loaded. Finally, we define a variable to hold
    the audio file extension supported by the browser, which we will determine by
    calling the `getSupportedFileTypeExt()` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未定义`audioPath`，我们将其默认为一个空字符串。然后我们添加一个名为`audios`的变量，它是一个对象，将用于缓存所有已加载的`<audio>`元素。最后，我们定义一个变量来保存浏览器支持的音频文件扩展名，我们将通过调用`getSupportedFileTypeExt()`方法来确定：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we create a new `<audio>` element in memory and use that to call the
    `canPlayType()` method to determine the file type the browser supports. Then we
    return the file extension for that type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在内存中创建一个新的`<audio>`元素，并使用它调用`canPlayType()`方法来确定浏览器支持的文件类型。然后我们返回该类型的文件扩展名。
- en: 'Next, we need a way to get the audio files from the `AudioManager` object.
    Let''s add a public `getAudio()` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种从`AudioManager`对象获取音频文件的方法。让我们添加一个公共的`getAudio()`方法：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `getAudio()` method takes three parameters. The first is the name of the
    audio file without the extension. We will add the audio path and default extension
    to it later when loading the file. The next two parameters are optional. The second
    parameter is a function that will get called when the file has finished loading.
    The third is a function that will get called if there was an error loading the
    file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAudio()`方法接受三个参数。第一个是没有扩展名的音频文件的名称。在加载文件时，我们稍后将为其添加音频路径和默认扩展名。接下来的两个参数是可选的。第二个参数是在文件加载完成时将被调用的函数。第三个是在加载文件时将被调用的函数。'
- en: The first thing `getAudio()` does is check the `audios` object to see if we
    already loaded and cached that file. The `audios` object is used like an associative
    array in this case, where the key is the filename and the value is the audio element.
    This makes it easy to look up `<audio>` elements by name.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAudio()`的第一件事是检查`audios`对象，看看我们是否已经加载并缓存了该文件。在这种情况下，`audios`对象被用作关联数组，其中键是文件名，值是音频元素。这样可以很容易地通过名称查找`<audio>`元素。'
- en: If the file hasn't been added to the cache yet, then we create a new `audio`
    element and load it by calling the `createAudio()` method, which we will implement
    next. Then it adds the new element to the `audios` object to cache it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件尚未添加到缓存中，那么我们将创建一个新的`audio`元素，并通过调用`createAudio()`方法来加载它，接下来我们将实现。然后将新元素添加到`audios`对象中以进行缓存。
- en: If the filename was already in the cache, then we immediately call the `onLoaded()`
    handler function that was passed in as a parameter since the file has been loaded.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件名已经在缓存中，那么我们立即调用传递的`onLoaded()`处理程序函数，因为文件已加载。
- en: 'Now let''s write the private `createAudio()` method. It takes the same parameters
    as the previous method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写私有的`createAudio()`方法。它接受与上一个方法相同的参数：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we create a new `<audio>` element using jQuery. Then we add an event
    listener for `canplaythrough`. When the event is fired, we check if an `onLoaded`
    function was passed into the method. If so, we call it passing it the new `<audio>`
    element. We also need to remove the event listener because some browsers will
    call it every time the audio is played.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用jQuery创建一个新的`<audio>`元素。然后我们为`canplaythrough`添加一个事件监听器。当事件触发时，我们检查方法中是否传入了`onLoaded`函数。如果是，我们调用它并传递新的`<audio>`元素。我们还需要删除事件监听器，因为有些浏览器会在每次播放音频时调用它。
- en: We also add an `onerror` handler to the `<audio>` element to check for errors
    while loading the file. If we get an error, it calls the `onError` function, if
    it was defined.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为`<audio>`元素添加了一个`onerror`处理程序，以检查加载文件时是否出现错误。如果出现错误，它将调用`onError`函数（如果已定义）。
- en: Next, we set the `src` attribute of the `<audio>` element to the URL of the
    audio file. We build the URL by combining `audioPath`, the name parameter, and
    `audioExt`. This will cause the audio file to start loading. Finally, we return
    the new `<audio>` element.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`<audio>`元素的`src`属性设置为音频文件的URL。我们通过组合`audioPath`、名称参数和`audioExt`来构建URL。这将导致音频文件开始加载。最后，我们返回新的`<audio>`元素。
- en: '*What just happened?*'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We created an object called `AudioManager` to load and cache audio files. The
    first time we request an audio file, it gets loaded and cached. The next time
    it uses the cached audio. For example, if our browser supports Ogg files, the
    following code will load the `audio/2C.ogg` audio file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`AudioManager`的对象来加载和缓存音频文件。当我们第一次请求音频文件时，它会被加载和缓存。下一次它将使用缓存的音频。例如，如果我们的浏览器支持Ogg文件，以下代码将加载`audio/2C.ogg`音频文件：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: HTML5 piano application
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5钢琴应用程序
- en: Now let's create our HTML5 piano application. We will have two octaves worth
    of piano keys, both black and white, and we will use some styling to make it look
    like a real keyboard. When the user clicks on a key with the mouse, it will play
    the corresponding note, which is defined in an audio file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的HTML5钢琴应用程序。我们将拥有两个八度的钢琴键，包括黑色和白色，并且我们将使用一些样式使其看起来像一个真正的键盘。当用户用鼠标点击键时，它将播放相应的音符，该音符在音频文件中定义。
- en: You can find the code for this section in `chapter6/example6.1`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter6/example6.1`中找到此部分的代码。
- en: Time for action – creating a virtual piano
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建虚拟钢琴
- en: We'll start as usual by copying our application template that we created in
    [Chapter 1](ch01.html "Chapter 1. The Task at Hand"), *The Task at Hand*, and
    renaming the files to `piano.html`, `piano.css`, and `piano.js`. We also need
    `touchEvents.js` that we created in the previous chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像往常一样，复制我们在[第1章](ch01.html "第1章。手头的任务")中创建的应用程序模板，*手头的任务*，并将文件重命名为`piano.html`、`piano.css`和`piano.js`。我们还需要`touchEvents.js`，这是我们在上一章中创建的。
- en: 'Inside `piano.js`, we''ll change the application object to `PianoApp`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`piano.js`中，我们将应用程序对象更改为`PianoApp`：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We create an instance of `AudioManager` and pass in the path to our audio files,
    which will be the `audio` folder. Now let''s open our HTML file and add all of
    the piano keys:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`AudioManager`的实例，并传入了我们音频文件的路径，这将是`audio`文件夹。现在让我们打开我们的HTML文件并添加所有的钢琴键：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Inside of the "main" element, we add a `<div>` tag with `id` set to `keyboard`.
    Inside there we have a `<div>` tag that will be the backboard and a `<div>` tag
    that will contain all of the keys. Each key is defined by an element that contains
    a class of `piano-key` and a class of either `white` or `black` depending on the
    key color. Each key element also has a `data-note` custom data attribute. This
    will be set to the name of the piano key's note and will also be the name of the
    matching audio file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在“main”元素内，我们添加一个`<div>`标签，`id`设置为`keyboard`。在里面，我们有一个`<div>`标签，它将成为背板，以及一个包含所有键的`<div>`标签。每个键由一个包含`piano-key`类和`white`或`black`类的元素定义，具体取决于键的颜色。每个键元素还有一个`data-note`自定义数据属性。这将设置为钢琴键音符的名称，也将是匹配音频文件的名称。
- en: 'Our piano has two full octaves of piano keys. Each key has its own audio file.
    Since each octave has 12 notes, and we have one more C note at the end of the
    keyboard, we will have 25 audio files named `2C` through `4C`. We want to supply
    audio files in both Ogg and MP3 formats to support all browsers, so in all we
    have 50 audio files:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的钢琴有两个完整的八度钢琴键。每个键都有自己的音频文件。由于每个八度有12个音符，并且我们在键盘末尾有一个额外的C音符，我们将有25个音频文件，命名为`2C`到`4C`。我们希望提供Ogg和MP3格式的音频文件以支持所有浏览器，因此总共有50个音频文件：
- en: '![Time for action – creating a virtual piano](img/5947_06_01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-创建虚拟钢琴](img/5947_06_01.jpg)'
- en: 'Let''s open `piano.css` and style the application. First of all we''ll make
    the application take up the whole browser window by setting `position` to `absolute`
    and setting all of the `position` values to `0`. We''ll give it a linear gradient
    from white to blue:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`piano.css`并为应用程序设置样式。首先，我们将通过将`position`设置为`absolute`并将所有`position`值设置为`0`来使应用程序占据整个浏览器窗口。我们将给它一个从白色到蓝色的线性渐变：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also set the `footer` selector''s `position` attribute to `absolute` and
    `bottom` to `0`, so it hugs the bottom of the window:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`footer`选择器的`position`属性设置为`absolute`，`bottom`设置为`0`，这样它就贴在窗口底部了：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the main section, we set `text-align` to `center`, so the keyboard is centered
    on the page:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要部分，我们将`text-align`设置为`center`，这样键盘就居中在页面上了：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s style the keyboard to make it look like a real piano keyboard. First,
    we give the entire keyboard a gradient from dark brown to light brown and a shadow
    to give it some depth:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为键盘设置样式，使其看起来像一个真正的钢琴键盘。首先，我们给整个键盘一个从深棕色到浅棕色的渐变和一个阴影，使其具有一定的深度：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we style the backboard, which hides the tops of the keys. We give it
    a dark brown color, make it `32` pixels high, and give it a shadow to add depth.
    In order to get the shadow to draw over the piano keys, we need to set `position`
    as `relative`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们样式化背板，隐藏键的顶部。我们给它一个深棕色，使其高度为`32`像素，并给它一个阴影以增加深度。为了使阴影绘制在钢琴键上方，我们需要将`position`设置为`relative`：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All of the piano keys share some base styling that is defined with the `piano-key`
    class. First, we set `display` as `inline-block` so they stay on the same line
    and also have width and height. Then we give the bottom a border radius to make
    them look rounded. We''ll also set the `cursor` property to `pointer` so the user
    gets an indication that they can be clicked:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有钢琴键共享一些基本样式，这些样式是使用`piano-key`类定义的。首先，我们将`display`设置为`inline-block`，这样它们就可以保持在同一行，并且具有宽度和高度。然后我们给底部设置了边框半径，使它们看起来圆润。我们还将`cursor`属性设置为`pointer`，这样用户就可以知道它们可以被点击：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we get to the black and white keys'' styles. The white keys are a
    little wider and taller than the black keys. We also give them an ivory color
    and a shadow. Lastly, we need to set `z-index` to `1`, because they need to be
    displayed behind the black keys:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到黑白键的样式。白键比黑键稍微宽一些，高一些。我们还给它们一个象牙色和阴影。最后，我们需要将`z-index`设置为`1`，因为它们需要显示在黑键的后面：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The black keys are a little smaller than the white. In order to make the black
    keys show over top of the white keys, we give set `z-index` to `2`. To make them
    seem to be in between the white keys, we set their `position` properties to `relative`
    and use a negative `left` offset to move them over top of the white keys. We also
    need a negative `right-margin` value, so the next white key gets pulled over and
    under it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 黑键比白键小一点。为了使黑键显示在白键的上方，我们将`z-index`设置为`2`。为了使它们看起来在白键之间，我们将它们的`position`属性设置为`relative`，并使用负`left`偏移将它们移动到白键的上方。我们还需要一个负的`right-margin`值，这样下一个白键就会被拉到它的上方和下方：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is how our piano would look:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的钢琴会是什么样子的：
- en: '![Time for action – creating a virtual piano](img/5947_06_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-创建虚拟钢琴](img/5947_06_03.jpg)'
- en: The first image shows the keys with no margins set. Doesn't look much like a
    real keyboard, does it? The next image shows what it looks like with the `left`
    margin set. It's getting better but the white key hasn't moved over. Setting the
    right margin takes care of that.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张图片显示了没有设置边距的键。看起来不太像一个真正的键盘，是吧？下一张图片显示了设置了`left`边距的样子。它变得更好了，但是白键还没有移动过来。设置右边距就解决了这个问题。
- en: '*What just happened?*'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a new HTML5 piano application starting with our application template.
    We defined all of the keys in HTML and then we styled them using negative offsets
    and margins to make the keys line up like a real keyboard.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的应用程序模板开始创建了一个新的HTML5钢琴应用程序。我们在HTML中定义了所有的键，然后使用负偏移和边距对它们进行了样式化，使键能够像真正的键盘一样排列。
- en: 'There you have it! We now have a two octave keyboard that looks pretty darn
    realistic:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在有一个看起来非常逼真的两个八度键盘：
- en: '![What just happened?](img/5947_06_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947_06_02.jpg)'
- en: Time for action – loading the notes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-加载音符
- en: We have a keyboard but there's no sound yet. Let's head back over to our JavaScript
    and load all of the audio files. We will create a new method called `loadAudio()`
    and call it from the application's `start()` method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个键盘，但还没有声音。让我们回到JavaScript，加载所有的音频文件。我们将创建一个名为`loadAudio()`的新方法，并从应用程序的`start()`方法中调用它。
- en: 'There are two ways by which we could load all the files. We could load them
    one at a time by calling `audioManager.getAudio()` for each file, which would
    be very verbose and require a lot of typing. Or we can iterate over all of the
    `piano-key` elements and get the filename from their `data-note` attributes. By
    using this method we could add more piano keys to the HTML and wouldn''t even
    have to touch the JavaScript:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式加载所有文件。我们可以通过为每个文件调用`audioManager.getAudio()`来一次加载它们，这将非常冗长并且需要大量输入。或者我们可以迭代所有的`piano-key`元素，并从它们的`data-note`属性中获取文件名。通过使用这种方法，我们可以在HTML中添加更多的钢琴键，甚至不需要触及JavaScript：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first thing we do is define some variables to keep track of the number of
    audio files that are being loaded and the number that have been loaded. We will
    use those to calculate the percent complete. We also need a variable to set if
    we get an error loading a file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是定义一些变量来跟踪正在加载的音频文件的数量和已加载的数量。我们将使用它们来计算完成百分比。我们还需要一个变量来设置如果加载文件时出现错误。
- en: 'The next thing we do is select all of the `piano-key` elements using jQuery
    and call `each()` to iterate over them. For each one we do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要使用jQuery选择所有的`piano-key`元素，并调用`each()`来对它们进行迭代。对于每一个，我们要做以下事情：
- en: Add 1 to the `count` variable to keep track of the total number of files.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`count`变量加1，以跟踪文件的总数。
- en: Get the note name, which is also the filename, from the `data-note` attribute.
    Notice that we must use the `escape()` function because some notes contain the
    sharp sign `#`, which is illegal in a URL.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`data-note`属性中获取音符名称，这也是文件名。请注意，我们必须使用`escape()`函数，因为一些音符包含sharp符号`#`，这在URL中是非法的。
- en: Call `audioManager.getAudio()` passing in the note name. This will cause the
    audio file to get loaded and cached. The next time we call `getAudio()` for this
    note, it will be loaded and ready to play.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`audioManager.getAudio()`，传入音符名称。这将导致音频文件被加载和缓存。下次我们为这个音符调用`getAudio()`时，它将被加载并准备好播放。
- en: The second parameter to `getAudio()` is a function that gets called when each
    file has finished loading successfully. In this function we increment the loaded
    variable. Then we check if all of the files have been loaded and if so, show a
    ready message. Otherwise, we compute the percent complete of loaded files and
    show it in the footer by calling `setStatus()`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getAudio()`的第二个参数是一个在每个文件成功加载完成时调用的函数。在这个函数中，我们增加了加载变量。然后我们检查是否所有文件都已加载，如果是，则显示准备好的消息。否则，我们通过调用`setStatus()`计算加载文件的完成百分比并显示在页脚中。'
- en: The last parameter to `getAudio()` is a function that gets called if there is
    an error loading a file. When that happens, we set the `error` variable to `true`
    and display a message showing the file that couldn't be loaded.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getAudio()`的最后一个参数是一个在加载文件时出错时调用的函数。当发生这种情况时，我们将`error`变量设置为`true`，并显示一个显示无法加载的文件的消息。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you are running this application through a web server such as IIS,
    you may need to add the `.ogg` file type to the list of MIME types for your site
    (`.ogg`, `audio/ogg`). Otherwise, you will get an error saying that the file is
    not found.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您通过IIS等Web服务器运行此应用程序，您可能需要将`.ogg`文件类型添加到站点的MIME类型列表中（`.ogg`，`audio/ogg`）。否则，您将收到文件未找到的错误。
- en: '*What just happened?*'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We used the `AudioManager` object to load all of the sounds for each keyboard
    key dynamically using their `data-note` attributes as the filename. Now we have
    all of our audio files loaded, cached, and ready to play.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AudioManager`对象动态加载每个键盘键的所有声音，使用它们的`data-note`属性作为文件名。现在我们已经加载、缓存并准备好播放所有的音频文件。
- en: Time for action – playing the notes
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-播放音符
- en: The next thing we need to do is add event handlers to play an `<audio>` element
    when a piano key is clicked or touched. We will hook up and event handlers to
    all of our piano keys and play the associated note when they are fired.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是为钢琴键添加事件处理程序，当点击或触摸钢琴键时播放`<audio>`元素。我们将为所有的钢琴键连接事件处理程序，并在它们被触发时播放相关的音符。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of this writing, the state of audio on mobile devices isn't very
    good. Although a touch device would be perfect for a piano app, the sounds don't
    always play correctly because of the way mobile browsers cache audio (or not).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，移动设备上的音频状态并不是很好。尽管触摸设备非常适合钢琴应用，但由于移动浏览器缓存音频的方式（或者没有缓存），声音并不总是正确播放。
- en: 'Let''s create a method called `initKeyboard()` that will be called from the
    application''s `start()` method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`initKeyboard()`的方法，它将从应用程序的`start()`方法中调用：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we use jQuery to select all of the `piano-key` elements on the keyboard.
    Then,we use the touch event's jQuery extension to check if the browser supports
    touch events. If so, we hook up touch event handlers to the piano keys. Otherwise,
    we hook up the mouse event handlers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用jQuery选择键盘上所有的`piano-key`元素。然后，我们使用触摸事件的jQuery扩展来检查浏览器是否支持触摸事件。如果是，我们将触摸事件处理程序连接到钢琴键。否则，我们将连接鼠标事件处理程序。
- en: When a key is touched or the mouse clicked down, it calls the `keyDown()` method
    passing in the key element wrapped in a jQuery object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下键或点击鼠标时，它调用`keyDown()`方法，传入用jQuery对象包装的键元素。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in this context, `this` is the element that was clicked. When the
    key is untouched or the mouse released, or the mouse leaves the element, we call
    the `keyUp()` method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，`this`是被点击的元素。当键被释放或鼠标释放，或鼠标离开元素时，我们调用`keyUp()`方法。
- en: 'Let''s write the `keyDown()` method first:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先编写`keyDown()`方法：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `keyDown()` method we first check if the key is already pressed down
    by checking if it has a class of `down`. If not, we add a class of `down` to the
    key element. We will use this to style the key to make it look like it's pressed.
    Then, we get the key's note name from the `data-note` custom attribute. We pass
    that to the `audioManager.getAudio()` method to get the `<audio>` element. To
    start playing the audio clip, we first set the `currentTime` property to `0` to
    cue up the sound at the start. Then we call the Audio API's `play()` method to
    start playing it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`keyDown()`方法中，我们首先检查键是否已经被按下，通过检查它是否具有`down`类。如果没有，我们将`down`类添加到键元素。我们将使用这个来为键添加样式，使其看起来像是被按下。然后，我们从`data-note`自定义属性中获取键的音符名称。我们将其传递给`audioManager.getAudio()`方法以获取`<audio>`元素。为了开始播放音频剪辑，我们首先将`currentTime`属性设置为`0`，以在开始时排队声音。然后，我们调用Audio
    API的`play()`方法来开始播放它。
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `keyUp()` method simply removes the `down` class from the element, so the
    key won't be styled in the down position any more.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyUp()`方法只是从元素中移除`down`类，这样键就不会再以按下状态进行样式设置。'
- en: 'The last thing we need to do is add the styling for the key down state. We
    will use a gradient to make it look like the end of the key is pressed down. We
    also make the shadow a little smaller since the key is not as high when pressed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是为按下状态添加样式。我们将使用渐变来使其看起来像是按下了键的末端。我们还会使阴影变小一点，因为按下时键不会那么高：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*What just happened?*'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We hooked up event handlers to the piano keys to play the associated notes when
    they are clicked with the mouse or touched on a touch device. We added some styling
    to give a visual indication that the key is pressed down. Now we have a functioning
    piano using HTML5 Audio. Go ahead and open it in your browser and bang out some
    tunes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们连接了事件处理程序到钢琴键，当它们被鼠标点击或在触摸设备上被触摸时，播放相关的音符。我们添加了一些样式来给出视觉指示，表明键被按下。现在我们有一个使用HTML5音频的功能钢琴。请在浏览器中打开它，并弹奏一些曲调。
- en: '![What just happened?](img/5947_06_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947_06_04.jpg)'
- en: Keyboard events
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘事件
- en: Using the mouse to play notes on our piano works okay, but it would be better
    if we could play more than one note at a time. To do that, we can use the computer's
    keyboard to play notes. To do this we will add keyboard event handlers to the
    DOM `document` in JavaScript and map keyboard keys to piano keys.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的钢琴上使用鼠标弹奏音符效果还可以，但如果我们可以同时播放多个音符会更好。为此，我们可以使用计算机键盘来弹奏音符。为此，我们将在JavaScript中向DOM`document`添加键盘事件处理程序，并将键盘键映射到钢琴键。
- en: 'The top two rows of the keyboard will be used for the first octave and the
    bottom two for the second octave. For example, pressing the *Q* key will play
    the lowest C note. Pressing the *2* key will play C#, *W* will play D, and so
    on. For the second octave, pressing *Z* will play middle C, *S* will play C#,
    and so on:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘的前两行将用于第一个八度，后两行将用于第二个八度。例如，按下*Q*键将播放最低的C音符。按下*2*键将播放C#，*W*将播放D，依此类推。对于第二个八度，按下*Z*将播放中央C，*S*将播放C#，依此类推：
- en: '![Keyboard events](img/5947_06_06.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![键盘事件](img/5947_06_06.jpg)'
- en: You can find the code for this section in `chapter6/example6.2`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter6/example6.2`中找到本节的代码。
- en: Time for action – adding keyboard events
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加键盘事件
- en: The first thing we need to do is add `keycodes.js` to our application. This
    file contains a global static object named `keyCodes` that maps keys on the keyboard
    to their associated key code. For example, `keyCodes.ENTER` is equal to `13`.
    Using this will make our code more readable than using key code numbers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将`keycodes.js`添加到我们的应用程序中。该文件包含一个名为`keyCodes`的全局静态对象，将键盘上的键映射到它们关联的键码。例如，`keyCodes.ENTER`等于`13`。使用这个将使我们的代码比使用键码数字更易读。
- en: 'The next thing we need to do is open the HTML and add a new custom data attribute
    to the `piano-key` elements. We will call it `data-keycode` and it will be set
    to the value in the `keyCode` object we want to associate with the piano key:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是打开HTML并向`piano-key`元素添加一个新的自定义数据属性。我们将其称为`data-keycode`，并将其设置为我们想要与钢琴键关联的`keyCode`对象中的值：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we need to map key codes to the notes. We will add an object to our application
    called `keyCodesToNotes` to hold our mappings. We will initialize it in the `initKeyboard()`
    method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将按键代码映射到音符。我们将在我们的应用程序中添加一个名为`keyCodesToNotes`的对象来保存我们的映射。我们将在`initKeyboard()`方法中对其进行初始化：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we iterate over all `piano-key` elements, getting the `data-keycode` custom
    attribute for each one and using that to get the key code from the `keyCodes`
    object. Then we add the mapping to `keyCodesToNotes` by setting it to the element's
    `data-note` custom attribute. For example, the key code for the *Q* key is 81
    and the associated piano key note is 2C. So `keyCodesToNotes[81]` will be set
    to `2C`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历所有`piano-key`元素，获取每个元素的`data-keycode`自定义属性，并使用它来从`keyCodes`对象中获取键码。然后，我们通过将其设置为元素的`data-note`自定义属性来将映射添加到`keyCodesToNotes`中。例如，*Q*键的键码为81，关联的钢琴键音符为2C。因此，`keyCodesToNotes[81]`将设置为`2C`。
- en: 'Now let''s add the keyboard event handlers. When checking for key down, up,
    or pressed events, you need to attach your event handlers to the HTML document.
    Let''s add `keydown` and `keyup` event handlers in the `start()` method of our
    application:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加键盘事件处理程序。在检查按下、释放或按下事件时，您需要将事件处理程序附加到HTML文档上。让我们在应用程序的`start()`方法中添加`keydown`和`keyup`事件处理程序：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `keydown` event handler calls the `onKeyDown()` method. The `keyup` handler
    calls `onKeyUp()`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`keydown`事件处理程序调用`onKeyDown()`方法。`keyup`处理程序调用`onKeyUp()`：'
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `onKeyDown()` method we look up the note for the key that was pressed
    using the `keyCodesToNotes` object. jQuery defines a `which` field on the key
    event object that contains the key code. If the key code matched to a note on
    our keyboard, then we call the `pressPianoKey()` method passing it the `note`
    parameter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onKeyDown()`方法中，我们使用`keyCodesToNotes`对象查找按下的键对应的音符。jQuery在键事件对象上定义了一个`which`字段，其中包含键码。如果键码与我们键盘上的音符匹配，那么我们调用`pressPianoKey()`方法，将`note`参数传递给它：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `onKeyUp()` method works the same way except that we call the `releasePianoKey()`
    method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`onKeyUp()`方法的工作方式相同，只是调用了`releasePianoKey()`方法。'
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `pressPianoKey()` method, we get the name of the note to play as a parameter.
    Then we call `getPianoKeyElement()` to get the piano key element associated with
    that note. Finally, we pass that element into the `keyDown()` method that we already
    implemented when we added mouse and touch events. In this way, we simulate the
    user clicking a piano key element on the screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pressPianoKey()`方法中，我们将要播放的音符名称作为参数。然后，我们调用`getPianoKeyElement()`来获取与该音符相关联的钢琴键元素。最后，我们将该元素传递给我们在添加鼠标和触摸事件时已经实现的`keyDown()`方法。通过这种方式，我们模拟了用户在屏幕上点击钢琴键元素。
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `releasePianoKey()` method works exactly the same way except it calls the
    existing `keyUp()` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`releasePianoKey()`方法的工作方式完全相同，只是调用了现有的`keyUp()`方法。'
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the `getPianoKeyElement()` method, we find the `piano-key` element associated
    with a note by using a jQuery select matching on the `data-note` custom attribute.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getPianoKeyElement()`方法中，我们通过使用jQuery选择器匹配`data-note`自定义属性来找到与音符相关联的`piano-key`元素。
- en: '*What just happened?*'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added keyboard key event handlers to the HTML document of our application.
    We mapped the key codes when a key is pressed to a piano key, so that the user
    can press keys on the keyboard to play the piano. By passing the `piano-key` element
    into `keyDown()` and `keyUp()`, we simulate the user clicking on those keys. They
    get the `down` class added to them so it looks like they are really being pressed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序的HTML文档中添加了键盘按键事件处理程序。当按下键盘上的键时，我们将键码映射到钢琴键，以便用户可以按下键盘上的键来弹奏钢琴。通过将`piano-key`元素传递给`keyDown()`和`keyUp()`，我们模拟了用户点击这些键。它们被添加了`down`类，看起来就像它们真的被按下了。
- en: Check it out for yourself. Try pressing two or three keys at a time and play
    some chords.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 自己试一试。尝试同时按下两个或三个键，弹奏一些和弦。
- en: Volume and sustain controls
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音量和延音控制
- en: Let's add some controls to our piano to allow the user to change the volume
    and sustain. As you may recall, the volume of an `audio` element may be set to
    any value from `0` to `1.0`. We will use a range input control that allows the
    user to control that via a slider.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在钢琴上添加一些控件，允许用户更改音量和延音。你可能还记得，`audio`元素的音量可以设置为`0`到`1.0`之间的任何值。我们将使用一个范围输入控件，允许用户通过滑块来控制音量。
- en: The sustain control allows a note to remain playing after the piano key is released.
    When sustain is turned off, the note will stop playing as soon as the key is released.
    We will add a checkbox to turn this off and on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 延音控制允许音符在释放钢琴键后继续播放。当关闭延音时，音符将在释放键时立即停止播放。我们将添加一个复选框来打开和关闭这个功能。
- en: You can find the source code for this section in `chapter6/example6.3`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter6/example6.3`中找到本节的源代码。
- en: Time for action – adding a sustain control
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加延音控制
- en: 'Let''s go ahead and add a sustain control to the application. We will use a
    checkbox input control to turn sustain on and off. In our HTML file, we will add
    a new `<div>` element with a class of `controls` under the keyboard to hold our
    controls:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在应用程序中添加一个延音控件。我们将使用复选框输入控件来打开和关闭延音。在我们的HTML文件中，我们将在键盘下方添加一个带有`controls`类的新`<div>`元素来容纳我们的控件：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We define a label and a checkbox with an `id` attribute of `sustain.` We also
    set it checked by default.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`id`属性定义一个标签和一个复选框，名称为`sustain`。我们还将其默认设置为选中状态。
- en: 'Now let''s implement the code for the checkbox in our `PianoApp` application
    object. First, we need to add a variable named `sustain` and set it to `true`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`PianoApp`应用程序对象中实现复选框的代码。首先，我们需要添加一个名为`sustain`的变量，并将其设置为`true`：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we hook up a `change` event handler to get notified when the checkbox
    changes. We will do this in the application''s `start()` method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个`change`事件处理程序，以便在复选框更改时收到通知。我们将在应用程序的`start()`方法中执行此操作：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the checkbox changes, we figure out if it is checked using the jQuery `is()`
    filter method passing it the `:checked` filter. If it is checked, the `sustain`
    variable gets set to `true`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框更改时，我们使用jQuery的`is()`过滤器方法来确定它是否被选中，传递给它`:checked`过滤器。如果选中，`sustain`变量将设置为`true`。
- en: 'Now we need to make some changes to the `keyUp()` method. All the method does
    now is to remove the `down` class from the `piano-key` element. We need to add
    code to check the `sustain` variable and stop the sound from playing if this variable
    is set to `true`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要对`keyUp()`方法进行一些更改。该方法现在的作用只是从`piano-key`元素中移除`down`类。我们需要添加代码来检查`sustain`变量，并且如果该变量设置为`true`，则停止播放声音：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After removing the `down` class, we check the `sustain` variable. If sustain
    is not set, we get the note name from the `piano-key` element's `data-note` custom
    attribute and use that to get the `<audio>` element from the `audioManager` object.
    Then we call the `pause()` method to stop playing the sound.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`down`类后，我们检查`sustain`变量。如果未设置延音，我们从`piano-key`元素的`data-note`自定义属性中获取音符名称，并使用它来从`audioManager`对象中获取`<audio>`元素。然后我们调用`pause()`方法来停止播放声音。
- en: '*What just happened?*'
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added a checkbox to allow the user to turn the sustain control on and off.
    When sustain is off and the user releases a piano key, we call the Audio API's
    `pause()` method to stop playback of the note.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个复选框，允许用户打开和关闭延音控制。当延音关闭并且用户释放钢琴键时，我们调用音频API的`pause()`方法来停止播放音符。
- en: Time for action – adding a volume control
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加音量控制
- en: 'Going back into the HTML, let''s add a range input control to allow the user
    to change the volume. We will put it right under the sustain label and control
    we just added:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 回到HTML中，让我们添加一个范围输入控件，允许用户更改音量。我们将它放在刚刚添加的延音标签和控件下面：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We define a label and a range input with an `id` attribute of `volume`. We set
    the range of the control from `1` to `100` with a `step` value of `1`. We also
    default the value to `100`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`volume`属性定义一个标签和一个范围输入。我们将控件的范围设置为`1`到`100`，步长值为`1`。我们还将默认值设置为`100`。
- en: 'Back in our `PianoApp` object we add another global variable named `volume`
    and set it to `1.0`, the maximum volume, by default:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`PianoApp`对象中，我们添加了另一个名为`volume`的全局变量，并将其默认设置为`1.0`，即最大音量：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Like the `sustain` checkbox, we need to add a `change` event handler to the
    `start()` method of our application for the range control:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与`sustain`复选框一样，我们需要为应用程序的`start()`方法添加一个`change`事件处理程序，用于范围控制：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You may have noticed that our range input control has a range of `1` to `100`,
    while the volume of an `audio` element is defined from `0` to `1.0`. Therefore,
    in our event handler, we set the `volume` variable to the value of the range control
    divided by `100`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们的范围输入控件的范围为`1`到`100`，而`audio`元素的音量定义为`0`到`1.0`。因此，在我们的事件处理程序中，我们将`volume`变量设置为范围控件的值除以`100`。
- en: 'Now all we need to do is add one line of code to the `keyDown()` method to
    set the `volume` property of the `audio` element before playing it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在`keyDown()`方法中添加一行代码，以在播放之前设置`audio`元素的`volume`属性：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s do a little styling in our CSS now for the `controls` section of the
    page:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在CSS中为页面的`controls`部分进行一些样式设置：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We set the top margin to give the controls a little breathing room, set vertical
    align for the controls so labels line up in the middle, and set the width of the
    volume range control.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置顶部边距，为控件留出一些空间，为控件设置垂直对齐，使标签居中对齐，并设置音量范围控件的宽度。
- en: 'There''s one more thing we should do to make our application more dynamic.
    The range input control isn''t widely supported by all browsers, so let''s add
    some code to check if it''s supported. We''ll add an `isInputTypeSupported()`
    method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该做一件事，使我们的应用程序更加动态。范围输入控件并不被所有浏览器广泛支持，因此让我们添加一些代码来检查它是否被支持。我们将添加一个`isInputTypeSupported()`方法：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we create a new `<input>` element in memory. Then we set the `type` attribute
    to the type we are testing. In our case, that will be `range`. Then we check the
    `type` attribute to see if it is stuck. If the element retains that type, then
    the browser supports it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在内存中创建一个新的`<input>`元素。然后我们将`type`属性设置为我们正在测试的类型。在我们的情况下，那将是`range`。然后我们检查`type`属性，看它是否被固定。如果元素保留了该类型，则表示浏览器支持它。
- en: 'In the `start()` method we''ll add a check for the range type. If you recall
    from [Chapter 3](ch03.html "Chapter 3. The Devil is in the Details"), *The Devil
    is in the Details*, that if an input type isn''t supported, it will just be displayed
    as a text input field. So if the range type isn''t supported, we''ll change the
    width of the field to make it smaller. We don''t want a text input field that''s
    `10em` wide to input a number from `0` to `100` :'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start()`方法中，我们将添加一个检查范围类型的检查。如果您还记得[第3章](ch03.html "第3章。细节中的魔鬼")中的内容，*细节中的魔鬼*，如果一个输入类型不受支持，它将显示为文本输入字段。因此，如果范围类型不受支持，我们将更改字段的宽度，使其变小。我们不希望一个宽度为`10em`的文本输入字段输入从`0`到`100`的数字：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*What just happened?*'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We added a range input control to allow the user to change the volume of the
    sounds with a slider. Before playing the sound, we set the volume to the value
    selected by the user. We also wrote a method to check if certain HTML5 input types
    are supported by the browser. The following is what we have created:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个范围输入控件，允许用户使用滑块更改声音的音量。在播放声音之前，我们将音量设置为用户选择的值。我们还编写了一个方法，用于检查浏览器是否支持某些HTML5输入类型。以下是我们创建的内容：
- en: '![What just happened?](img/5947_06_07.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/5947_06_07.jpg)'
- en: Have a go hero
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: Create a wrapper object for `<audio>` elements that takes the element as a constructor
    and contains public methods to access the Audio API methods. Add some convenience
    methods, for example, `rewind()`, which sets `audio.currentTime = 0`, or `stop()`,
    which calls `pause()` and `rewind()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为`<audio>`元素创建一个包装器对象，该对象将元素作为构造函数，并包含公共方法来访问音频API方法。添加一些便利方法，例如`rewind()`，它设置`audio.currentTime
    = 0`，或`stop()`，它调用`pause()`和`rewind()`。
- en: Pop quiz
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验
- en: Q1\. What audio type does the `<audio>` element support?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. `<audio>`元素支持哪种音频类型？
- en: Ogg
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ogg
- en: MP3
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MP3
- en: Wav
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Wav
- en: All of the above
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有内容
- en: Q2\. Which object do you attach keyboard events to?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 你将键盘事件附加到哪个对象？
- en: '`window`'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`窗口`'
- en: '`document`'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`文档`'
- en: '`div`'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`div`'
- en: '`audio`'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`音频`'
- en: Audio tools
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频工具
- en: Before we leave this chapter, I would like to tell you about a couple of free
    audio tools that you can use to get and manipulate audio files for your applications.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开本章之前，我想告诉你一些免费音频工具，你可以用它们来获取和处理应用程序的音频文件。
- en: FreeSound.org
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FreeSound.org
- en: '[FreeSound.org](http://FreeSound.org) is a website from where you can get audio
    files that are released under Creative Commons licenses. That means you can use
    them free of charge with various usage restrictions. There are public domain sounds,
    which you can use without doing anything. There are sounds that you can do anything
    with as long as you give the author credit. And there are sounds that you can
    use for anything except commercial purposes. The FreeSound database is vast and
    has great searching and browsing capabilities. You can find almost any sound you
    need on this website.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[FreeSound.org](http://FreeSound.org)是一个网站，你可以在那里获取以知识共享许可发布的音频文件。这意味着你可以在各种使用限制下免费使用它们。有一些公共领域的声音，你可以无需做任何事情就可以使用。还有一些声音，只要你给作者以信用，你就可以做任何事情。还有一些声音，你可以用于任何目的，除了商业用途。FreeSound数据库庞大，具有出色的搜索和浏览功能。你几乎可以在这个网站上找到任何你需要的声音。'
- en: Audacity
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Audacity
- en: Audacity is a free open source audio editor for recording, slicing, and mixing
    audio that runs on many different operating systems. Audacity works great for
    converting between multiple file types, which is great for us since we need to
    support different audio types for different browsers. It supports all of the main
    audio types used by the major web browsers, including Ogg, MP3 and WAV.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Audacity是一个免费的开源音频编辑器，用于录制、切割和混合音频，可在许多不同的操作系统上运行。Audacity非常适合在不同文件类型之间转换，这对我们来说非常重要，因为我们需要支持不同浏览器的不同音频类型。它支持主要网络浏览器使用的所有主要音频类型，包括Ogg、MP3和WAV。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use the HTML5 `audio` element and API to
    add sounds to web applications. We saw how to load and cache audio files by creating
    a re-usable audio manager object. Then we used HTML5 audio to create a virtual
    piano application for playing the piano in a web page. We used keyboard events
    to allow the user to play the piano keys via the keyboard. We added controls to
    change the volume and sustain notes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用HTML5的`audio`元素和API来为Web应用程序添加声音。我们看到了如何通过创建可重用的音频管理器对象来加载和缓存音频文件。然后我们使用HTML5音频在网页中创建了一个虚拟钢琴应用程序。我们使用键盘事件允许用户通过键盘弹奏钢琴键。我们添加了控件来改变音量和延长音符。
- en: 'We covered the following concepts in this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下概念：
- en: How to add the HTML5 `<audio>` element to a web page and use its attributes
    to control it
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将HTML5的`<audio>`元素添加到网页中并使用其属性来控制它
- en: Using the Audio API from JavaScript to programmatically control the playback
    of an audio element
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript从音频API来编程控制音频元素的播放
- en: How to load audio files and cache them for playback later
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加载音频文件并缓存以供以后播放
- en: How to play, pause, and reset an audio file
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何播放、暂停和重置音频文件
- en: How to hook up keyboard events to the document and handle them in our applications
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将键盘事件连接到文档并在我们的应用程序中处理它们
- en: How to change the volume of an `audio` element using a range input control
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用范围输入控件改变`audio`元素的音量
- en: How to check if any HTML5 input type is supported by the browser
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检查浏览器是否支持任何HTML5输入类型
- en: In the next chapter, we will take our piano application and turn it into a game
    called Piano Hero. We will learn about timing, animating elements, and playing
    back music by creating an audio sequencer.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的钢琴应用程序变成一个叫做钢琴英雄的游戏。我们将学习关于时间、动画元素和通过创建音频序列器播放音乐。
