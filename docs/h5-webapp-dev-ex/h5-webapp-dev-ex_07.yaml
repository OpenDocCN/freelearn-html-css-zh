- en: Chapter 7. Piano Hero
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 钢琴英雄
- en: '"One good thing about music, when it hits you, you feel no pain."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"音乐的一大好处是，当它打动你时，你感觉不到痛苦。"'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: – Bob Marley
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- 鲍勃·马利'
- en: '*In this chapter we will turn the piano application from the previous chapter
    into a game where the player must play the notes of a song at the correct time
    as they fall down the screen. We will create a splash page that keeps track of
    image loading and allows the player to choose game options. We will create an
    audio sequencer to play the songs from music data. During the game we will collect
    piano keyboard input and validate it to determine the player''s score.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将把上一章的钢琴应用程序转变成一个游戏，玩家必须在音符按下屏幕时以正确的时间演奏歌曲的音符。我们将创建一个启动页面，用于跟踪图像加载并允许玩家选择游戏选项。我们将创建一个音频序列以播放音乐数据中的歌曲。在游戏过程中，我们将收集钢琴键盘输入并验证以确定玩家的得分。*'
- en: 'We will learn the following in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将学到以下内容：
- en: How to use an HTML5 progress bar element to track the loading of resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用HTML5进度条元素跟踪资源的加载
- en: How to use JavaScript timers to control playback of audio to play songs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JavaScript定时器来控制音频播放以播放歌曲
- en: How to animate DOM elements to move them around the screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用DOM元素动画来移动它们在屏幕上
- en: How to transition between game states
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在游戏状态之间过渡
- en: How to get user input and verify it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取用户输入并验证它
- en: Creating Piano Hero
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建钢琴英雄
- en: Our Piano Hero game will start with the HTML5 piano application we built in
    the previous chapter. We will add an audio sequencer to it to play prerecorded
    songs. To score points, the player will need to follow along and play the notes
    of the song at the correct time. There will also be a practice mode that just
    plays the song so the player can hear it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的钢琴英雄游戏将从我们在上一章中构建的HTML5钢琴应用程序开始。我们将添加一个音频序列到其中以播放预先录制的歌曲。为了得分，玩家需要跟着演奏歌曲的音符，并在正确的时间演奏。还将有一个练习模式，只播放歌曲，以便玩家能听到它。
- en: Our game will have two different main panels. The first will be the splash panel,
    which is the starting point of the game. When the application first starts, it
    will display a progress bar as the audio loads. When loading is complete, it will
    show the options for playing the game. When the player clicks on the play button
    they will transition to the game panel.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将有两个不同的主面板。第一个将是启动面板，这是游戏的起点。当应用程序首次启动时，它将显示一个进度条，因为音频正在加载。加载完成后，它将显示游戏的选项。当玩家点击播放按钮时，他们将转到游戏面板。
- en: The game panel contains the piano keyboard and an area that shows the notes
    to play dropping down from above it. If the user plays the correct note at the
    correct time, they get points. At the end of the song, the player's score and
    some statistics are displayed. When the game is done, the application will transition
    back to the splash panel where the user can select options and play again.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏面板包含钢琴键盘和一个显示要演奏的音符从上面掉下来的区域。如果用户在正确的时间演奏了正确的音符，他们会得到积分。在歌曲结束时，玩家的得分和一些统计数据将被显示。游戏结束后，应用程序将转回到启动面板，用户可以选择选项并再次游戏。
- en: It's often helpful to draw a flowchart that shows how the game transitions from
    one state to another.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有助于绘制一个流程图，显示游戏如何从一个状态过渡到另一个状态。
- en: '![Creating Piano Hero](img/5947OT_07_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建钢琴英雄](img/5947OT_07_03.jpg)'
- en: Time for action – creating the splash panel
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建启动面板
- en: Let's start by copying the piano application that we created in the previous
    chapter, and renaming the files to `pinaoHero.html`, `pianoHero.js`, and `pianoHero.css`.
    We will also rename the main application object to `PianoHeroApp`. You can find
    the code for this section in `Chapter 7/example7.1`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一章创建的钢琴应用程序开始，并将文件重命名为`pinaoHero.html`，`pianoHero.js`和`pianoHero.css`。我们还将主应用程序对象重命名为`PianoHeroApp`。您可以在`第7章/example7.1`中找到本节的代码。
- en: 'Now let''s create the splash panel. First we''ll define the HTML in `pianoHero.html`.
    We will add a new `<div>` element above the keyboard element to hold the splash
    panel:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建启动面板。首先我们将在`pianoHero.html`中定义HTML。我们将在键盘元素上方添加一个新的`<div>`元素来容纳启动面板：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First we add a section with a class of `"loading"` that displays the status
    of loading the audio when the application first starts up. Notice that we are
    using the new HTML5 `<progress>` element. This element is used to implement a
    progress bar in your application. It has a `max` attribute that defines the maximum
    value, and a `value` attribute to set the current value. Since we are showing
    percent complete we set the `max` to `100`. We will update the `value` attribute
    from JavaScript as audio files are loaded.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个带有`"loading"`类的部分，显示应用程序首次启动时加载音频的状态。请注意，我们正在使用新的HTML5`<progress>`元素。该元素用于在应用程序中实现进度条。它有一个`max`属性，定义最大值，和一个`value`属性来设置当前值。由于我们显示百分比完成，我们将`max`设置为`100`。随着音频文件的加载，我们将从JavaScript更新`value`属性。
- en: 'Then we add a section with a class of `"error"` that will show an error message
    if there is an error loading the audio. Otherwise it will be hidden:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加一个带有`"error"`类的部分，如果加载音频时出错将显示错误消息。否则它将被隐藏：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Lastly, we add a section that shows the game options and buttons. This panel
    is shown after all audio has been loaded:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个显示游戏选项和按钮的部分。这个面板在所有音频加载完成后显示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here the user selects the song and difficulty from the drop-down lists. The
    difficulty is expressed in terms of the rate of speed that the song plays. A value
    of one is the default speed of 120 beats per minute. A value less than one is
    slower, and more than one is faster.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户从下拉列表中选择歌曲和难度。难度是以歌曲播放速度的比率来表示。值为1是默认速度，即每分钟120拍。小于1的值是更慢的，大于1的值是更快的。
- en: 'Now we need to style the splash panel. Please see the source code for all of
    the styles. The one noteworthy piece of styling is for the **PIANO HERO** title,
    which we placed inside an `<h1>` header element:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为启动面板设置样式。请查看所有样式的源代码。一个值得注意的样式是**PIANO HERO**标题，我们将其放在`<h1>`标题元素中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We set the color for the text to dark blue. Then we use `text-shadow` to produce
    an interesting block text effect. When using `text-shadow,` you may specify any
    number of shadows separated by commas. The shadows will be drawn in order from
    last to first. So in this case, we first draw a dark blue shadow with an offset
    of 5 pixels, then a white shadow with an offset of 3 pixels, and finally the dark
    blue text will be drawn on top of that:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文本的颜色设置为深蓝色。然后我们使用`text-shadow`来产生有趣的块文本效果。在使用`text-shadow`时，您可以通过逗号分隔指定任意数量的阴影。阴影将按照从后到前的顺序绘制。所以在这种情况下，我们首先绘制一个偏移为5像素的深蓝色阴影，然后是一个偏移为3像素的白色阴影，最后深蓝色文本将被绘制在其上方：
- en: '![Time for action – creating the splash panel](img/5947OT_07_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-创建闪屏面板](img/5947OT_07_02.jpg)'
- en: 'Now let''s create a new JavaScript file named `splashPanel.js`, and define
    a new object called `SplashPanel` in it that will contain all of the code to control
    the splash panel. The constructor will take one parameter, a reference to `audioManager`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为`splashPanel.js`的新JavaScript文件，并在其中定义一个名为`SplashPanel`的新对象，该对象将包含控制闪屏面板的所有代码。构造函数将接受一个参数，即对`audioManager`的引用：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We define a `$div` object to hold a reference to the splash panel''s root `<div>`
    element, and an `error` variable to set if there was an error loading the audio.
    Next we define the public `show()` and `hide()` methods. These will be called
    by the main application object to show or hide the panel:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`$div`对象来保存对闪屏面板根`<div>`元素的引用，并设置了一个`error`变量来设置是否在加载音频时出现错误。接下来，我们定义了公共的`show()`和`hide()`方法。这些方法将由主应用程序对象调用以显示或隐藏面板。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next we will move the `loadAudio()` method from `PianoHeroApp` to `SplashPanel`.
    In this method we need to make a couple of minor changes to the call to `audioManager.getAudio()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`loadAudio()`方法从`PianoHeroApp`移动到`SplashPanel`。在这个方法中，我们需要对`audioManager.getAudio()`的调用进行一些小的更改：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our function that gets called each time an audio file is loaded, we first
    check if there was an error, and if so get it out. Then we check if all of the
    audio files have been loaded (`loaded == count`), and if so call the `showOptions()`
    method. Otherwise we call the `updateProgress()` method to update the progress
    bar:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们每次加载音频文件时调用的函数中，我们首先检查是否有错误，如果有，则将其取出。然后我们检查是否已加载所有音频文件（`loaded == count`），如果是，则调用`showOptions()`方法。否则，我们调用`updateProgress()`方法来更新进度条：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `updateProgress()` method takes the loaded count and total count as parameters.
    We compute the percent complete and use that to update the value of the `<progress>`
    element. We also set the inner text of the `<progress>` element. This will only
    show for browsers that don't support the `<progress>` element.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateProgress()`方法将加载计数和总计数作为参数。我们计算完成的百分比，并使用它来更新`<progress>`元素的值。我们还设置了`<progress>`元素的内部文本。这只会在不支持`<progress>`元素的浏览器中显示。'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `showOptions()` method is called after all audio has been loaded. First
    we hide the element with the `"loading"` class, and then fade in the element with
    the `"options"` class. This hides the progress section and shows the section that
    contains the game options.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载完所有音频后，将调用`showOptions()`方法。首先隐藏具有`"loading"`类的元素，然后淡入具有`"options"`类的元素。这将隐藏进度部分并显示包含游戏选项的部分。
- en: 'Our error handler function calls `showError()`, passing it the audio element
    that failed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的错误处理程序调用`showError()`，将失败的音频元素传递给它：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `showError()` method we set the `error` flag to `true` so we know not
    to continue in the `getAudio()` call. First we hide the loading section, then
    we append the name of the file that failed to the error message, and show the
    error section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`showError()`方法中，我们将`error`标志设置为`true`，以便我们知道不要在`getAudio()`调用中继续。首先隐藏加载部分，然后将失败的文件名附加到错误消息中，并显示错误部分。
- en: 'The last thing we need in our splash panel is to hook up event handlers to
    the buttons. There are two buttons, **Start Game** and **Play Song**. The only
    difference between them is that the **Play Song** button plays the song without
    scoring, so the user can hear the song and practice:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们闪屏面板中的最后一件事是将事件处理程序连接到按钮。有两个按钮，**开始游戏**和**播放歌曲**。它们之间唯一的区别是**播放歌曲**按钮会播放歌曲而不计分，因此用户可以听歌曲并练习：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use the same event handler for both buttons. First we get the options that
    the user selected, including the song and playback rate. You can find the selected
    `<option>` element in jQuery using the `:selected` selector. We determine which
    button the user pressed by looking at the button's `id` attribute. Then we call
    the `startGame()` method on the global `app` object passing in the selected options.
    We will write that method later.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个按钮使用相同的事件处理程序。首先获取用户选择的选项，包括歌曲和播放速率。您可以使用jQuery的`:selected`选择器找到所选的`<option>`元素。我们通过查看按钮的`id`属性来确定用户按下了哪个按钮。然后我们在全局`app`对象上调用`startGame()`方法，传入所选的选项。我们稍后将编写该方法。
- en: '![Time for action – creating the splash panel](img/5947OT_07_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-创建闪屏面板](img/5947OT_07_01.jpg)'
- en: '*What just happened?*'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a splash panel that shows the loading progress of the audio files
    using an HTML5 `<progress>` element. When it is finished it shows the game options,
    and then waits for the user to select options and start the game.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个闪屏面板，使用HTML5的`<progress>`元素显示音频文件的加载进度。加载完成后，它会显示游戏选项，然后等待用户选择选项并开始游戏。
- en: Time for action – creating the game panel
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建游戏面板
- en: 'The next thing we will create is the game panel. We already have the piano
    keyboard, which will be part of it. We also need an area above it to show the
    notes dropping down, and a place to show the results when the game has finished.
    Let''s add these to our HTML file inside the `game` element and above the keyboard:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建游戏面板。我们已经有了钢琴键盘，它将是其中的一部分。我们还需要在其上方添加一个区域来显示下降的音符，并在游戏结束时显示结果的地方。让我们将这些添加到我们的HTML文件中的`game`元素内部和键盘上方：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `<div id="notes-panel">` element will be used to hold the elements that
    represent the notes to play. It is empty for now. The `note` elements will be
    added dynamically to this element while the game is playing. It has a `<div>`
    element with the title in it that will show up behind the notes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div id="notes-panel">`元素将用于容纳代表要演奏的音符的元素。现在它是空的。在游戏进行时，`note`元素将动态添加到这个元素中。它有一个带有标题的`<div>`元素，将显示在音符的后面。'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `<div id="results-panel">` element will be shown when the game is completed.
    We add the `<span>` placeholders to show a score, the total number of notes along
    with the number of correct ones, and some accuracy statistics.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div id="results-panel">`元素将在游戏完成时显示。我们添加`<span>`占位符来显示得分，音符的总数以及正确的数量，以及一些准确度统计。'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We also added some buttons to the `<div class="controls">` element below the
    keyboard. The **Stop** button will stop the game, **Restart** will start the current
    song over from the beginning, and **Quit** will take the player back to the splash
    panel.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在键盘下方的`<div class="controls">`元素中添加了一些按钮。**停止**按钮将停止游戏，**重新开始**将从头开始播放当前歌曲，**退出**将把玩家带回到启动面板。
- en: 'Now let''s create a `GamePanel` object in a file named `gamePanel.js` to contain
    all of the code needed to implement the game. The constructor will take a reference
    to the `audioManager` object:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在一个名为`gamePanel.js`的文件中创建一个`GamePanel`对象，以包含实现游戏所需的所有代码。构造函数将接受对`audioManager`对象的引用：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we define a few variables to keep track of the game state. The `practiceMode`
    variable determines if we are playing the game or practicing. `noteCount`, `notesCorrect`
    and `score` are used to keep track of how the player is doing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一些变量来跟踪游戏状态。`practiceMode`变量确定我们是在玩游戏还是练习。`noteCount`、`notesCorrect`和`score`用于跟踪玩家的表现。
- en: We move all of the code to support the keyboard from the `PianoHeroApp` object
    to the `GamePanel` object. This includes the `keyCodesToNotes`, `sustain`, and
    `volume` variables. We also move the `initKeyboard()` , `keyDown()`, `keyUp()`,
    `pressPianoKey()`, `releasePianoKey()`, `getPianoKeyElement()` , and `isInputTypeSupported()`
    methods. Finally, we move the `onKeyDown()` and `onKeyUp()` event handlers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有支持键盘的代码从`PianoHeroApp`对象移动到`GamePanel`对象。这包括`keyCodesToNotes`、`sustain`和`volume`变量。我们还移动了`initKeyboard()`、`keyDown()`、`keyUp()`、`pressPianoKey()`、`releasePianoKey()`、`getPianoKeyElement()`和`isInputTypeSupported()`方法。最后，我们移动了`onKeyDown()`和`onKeyUp()`事件处理程序。
- en: 'Now let''s add some public methods for the application to interact with the
    game panel. Like the splash panel, we need methods to show and hide it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为应用程序与游戏面板交互添加一些公共方法。与启动面板一样，我们需要方法来显示和隐藏它：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `show()` public method fades the game panel in. We pass in a reference to
    the `startGame()` method, which we will write in the next section, to be called
    when the fade in has completed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`show()`公共方法将游戏面板淡入。我们传入一个对`startGame()`方法的引用，我们将在下一节中编写该方法，以在淡入完成时调用。'
- en: '*What just happened?*'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created the game panel by adding markup for an area to hold animated `note`
    elements, and an area to show the score. These are in addition to our keyboard
    we created in the previous chapter. Then, we created a JavaScript object to hold
    all of the code for the game panel, including all of the code we wrote previously
    for the keyboard.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加标记来创建游戏面板，用于容纳动画`note`元素的区域，以及显示得分的区域。这些是我们在上一章中创建的键盘之外的内容。然后，我们创建了一个JavaScript对象来保存游戏面板的所有代码，包括我们之前为键盘编写的所有代码。
- en: Time for action – creating the controller
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建控制器
- en: At this point there's not much left in our main application object, `PianoHeroApp`.
    We moved all of the code to load the audio to the `SplashPanel` object, and all
    of the code to make the keyboard work to the `GamePanel` object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此时在我们的主应用程序对象`PianoHeroApp`中剩下的不多了。我们将所有加载音频的代码移到了`SplashPanel`对象中，将使键盘工作的所有代码移到了`GamePanel`对象中。
- en: 'The `PianoHeroApp` object will now only act as a state controller to hide and
    show the correct panels. First we need to add some variables to hold references
    to the panels:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`PianoHeroApp`对象现在只作为状态控制器来隐藏和显示正确的面板。首先，我们需要添加一些变量来保存对面板的引用：'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We define variables to hold the audio manager, the splash panel, and the game
    panel objects. We also have a `curPanel` variable, which will be set to the current
    panel that is showing. To start with we will set it to `undefined`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义变量来保存音频管理器、启动面板和游戏面板对象。我们还有一个`curPanel`变量，它将被设置为当前显示的面板。一开始我们将把它设置为`undefined`。
- en: 'Next, we will create a private `showPanel()` method that will hide the currently
    showing panel, if there is one, and show a different one:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个私有的`showPanel()`方法，它将隐藏当前显示的面板（如果有的话），并显示另一个面板：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method takes the panel to show as a parameter. This will be a reference
    to either `SplashPanel` or `GamePanel`. First we check to see if a panel is showing,
    and if so we call its `hide()` method. Then we set `curPanel` to the new panel
    and call its `show()` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法以要显示的面板作为参数。这将是对`SplashPanel`或`GamePanel`的引用。首先，我们检查是否正在显示面板，如果是，我们调用它的`hide()`方法。然后我们将`curPanel`设置为新面板，并调用它的`show()`方法。
- en: 'Next we define the public `startGame()` method. If you remember from the code
    we wrote for the `SplashPanel` object, this will get called from the event handler
    when the user clicks either on the **Play Game** or **Play Song** button. It passes
    in the game options the player selected:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义公共的`startGame()`方法。如果你还记得我们为`SplashPanel`对象编写的代码，这个方法将在用户点击**开始游戏**或**播放歌曲**按钮时从事件处理程序中调用。它会传入玩家选择的游戏选项：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `startGame()` method takes three parameters; the name of the song to play,
    the playback rate (which controls how fast the game progresses), and a Boolean
    value (which determines if the user clicked on the **Play Game** button).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`startGame()`方法接受三个参数；要播放的歌曲的名称，播放速率（控制游戏进度的快慢），以及一个布尔值（确定用户是否点击了**开始游戏**按钮）。'
- en: First we call the `setOptions()` method of the `GamePanel` object, which we
    will write later. We pass through the same parameters we got from the splash panel.
    Then we call the `showPanel()` method passing in the `GamePanel` object. This
    is what will start the game.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`GamePanel`对象的`setOptions()`方法，稍后我们将编写。我们通过与启动面板获得的相同参数进行传递。然后我们调用`showPanel()`方法，传入`GamePanel`对象。这将开始游戏。
- en: 'Next we will define the public `quitGame()` method. This will be called from
    the game panel when the user clicks on the **Quit** button:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义公共的`quitGame()`方法。当用户点击**退出**按钮时，这将从游戏面板中调用：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All we do in this method is call `showPanel()`, passing it the `SplashPanel`
    object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们所做的就是调用`showPanel()`，将`SplashPanel`对象传递给它。
- en: 'The final thing we need to define is the `start()` method of our application:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义的最后一件事是应用程序的`start()`方法：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First we set up keyboard event handlers on the document, just as we did when
    creating the piano application. However, in this application we will forward the
    keyboard event to the current panel. By centralizing the keyboard event handlers
    in the application object, we don't have to write a bunch of code in each panel
    to subscribe and unsubscribe keyboard event handlers from the document when the
    panel is shown or hidden.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在文档上设置键盘事件处理程序，就像我们在创建钢琴应用程序时所做的那样。但是，在这个应用程序中，我们将键盘事件转发到当前面板。通过在应用程序对象中集中处理键盘事件处理程序，我们不必在每个面板中编写大量代码来订阅和取消订阅来自文档的键盘事件处理程序，当面板显示或隐藏时。
- en: The final thing we do is show the splash panel, and then call its `loadAudio()`
    method to kickstart the application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的最后一件事是显示启动面板，然后调用它的`loadAudio()`方法来启动应用程序。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音符
- en: Our splash and game panels implement `show()`, `hide()`, `keydown()`, and `keyup()`
    methods. Since JavaScript is untyped we can't enforce this with interfaces. So
    we program by convention instead, assuming that all panels will implement those
    methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的启动和游戏面板实现了`show()`、`hide()`、`keydown()`和`keyup()`方法。由于JavaScript是无类型的，我们无法通过接口来强制执行这一点。因此，我们改为按照约定进行编程，假设所有面板都将实现这些方法。
- en: '*What just happened?*'
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added code to the main application object to control the state of the game.
    When the player clicks on one of the buttons from the splash panel it starts the
    game, and when they click on **Quit** from the game, it shows the splash panel.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主应用程序对象中添加了代码来控制游戏的状态。当玩家点击启动面板上的按钮之一时，游戏就会开始，当他们从游戏中点击**退出**时，它会显示启动面板。
- en: Creating an audio sequencer
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建音频序列
- en: Before we can play the game, we need some way to play songs on the piano by
    playing back notes in a certain order, at the correct time, and at the correct
    speed. We will create an object called `AudioSequencer` that takes an array of
    musical event objects and turns them into music.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们玩游戏之前，我们需要一种方法来通过按照特定顺序、在正确的时间和以正确的速度播放音符来在钢琴上演奏歌曲。我们将创建一个名为`AudioSequencer`的对象，它接受一个音乐事件对象数组并将它们转换为音乐。
- en: To implement our audio sequencer we need to define a format for our music events.
    We will roughly follow the MIDI format, but much more simplified. MIDI is the
    standard to record and play back music events. Each event contains information
    about how and when to play notes, or turn notes off.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的音频序列，我们需要定义音乐事件的格式。我们将大致遵循MIDI格式，但简化得多。MIDI是记录和回放音乐事件的标准。每个事件包含有关何时以及如何演奏音符或关闭音符的信息。
- en: 'Our event object will contain three fields:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件对象将包含三个字段：
- en: '`deltaTime`: The amount of time to wait before executing the event.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deltaTime`：执行事件之前等待的时间量。'
- en: '`event`: This is an integer event code that determines what the event does.
    It can be one of the following:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`事件`：这是一个整数事件代码，确定事件的操作。它可以是以下之一：'
- en: Turn a note on
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开音符
- en: Turn a note off
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭音符
- en: Cue point will be at the beginning of a song
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示点将在歌曲的开头
- en: End of track will signal that the song is over
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曲目结束将表示歌曲结束。
- en: '`note`: This is the note to play. It contains the octave and note, and matches
    our audio file names, for example, 3C.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`注意`：这是要演奏的音符。它包含了八度和音符，并且与我们的音频文件名称匹配，例如，3C。'
- en: The audio sequencer will work by looking at the `deltaTime` field in each event
    to determine how long to wait before firing the event. The client will pass in
    an event handler function that will be called when the event is fired. The client
    will then look at the event data and determine which note to play. This loop continues
    until there are no more events left.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 音频序列将通过查看每个事件中的`deltaTime`字段来确定在触发事件之前等待多长时间。客户端将传递一个事件处理程序函数，当事件触发时将调用该函数。然后客户端将查看事件数据并确定要演奏哪个音符。这个循环会一直持续，直到没有更多的事件为止。
- en: '![Creating an audio sequencer](img/5947OT_07_07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![创建音频序列](img/5947OT_07_07.jpg)'
- en: Time for action – creating AudioSequencer
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建AudioSequencer
- en: 'Let''s create our `AudioSequencer` object in a file called `audioSequencer.js`.
    We''ll start by defining a few variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个名为`audioSequencer.js`的文件中创建我们的`AudioSequencer`对象。我们将首先定义一些变量：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First we define an `_events` array to hold all of the music events to play.
    The `_playbackRate` variable controls how fast the song plays. A value of `1`
    will be at normal speed, less than `1` slower, and more than `1` faster. The `_playing`
    variable is set to `true` while a song is playing. `eventHandler` will be set
    to a function that gets called when an event is fired, and `timeoutID` will contain
    the handle returned from `setTimeout()` in case the user stops the game and we
    need to cancel the timeout.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`_events`数组来保存所有要播放的音乐事件。`_playbackRate`变量控制歌曲播放的速度。值为`1`时是正常速度，小于`1`时是较慢，大于`1`时是较快。`_playing`变量在播放歌曲时设置为`true`。`eventHandler`将设置为一个在事件触发时调用的函数，`timeoutID`将包含从`setTimeout()`返回的句柄，以防用户停止游戏，我们需要取消超时。
- en: 'Now let''s define some public property methods. The first is `events()`. It
    is used to get or set the `_events` array:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一些公共属性方法。第一个是`events()`。它用于获取或设置`_events`数组：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next is `playbackRate()`. It is used to get or set `_playbackRate`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`playbackRate()`。它用于获取或设置`_playbackRate`：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally we have `isPlaying()`, which is used to determine if a song is currently
    playing:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`isPlaying()`，用于确定歌曲当前是否正在播放：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we will code the public `startPlayback()` method. This method takes two
    parameters; the event handler function and optionally the starting position, which
    is an index into the `_events` array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写公共的`startPlayback()`方法。该方法接受两个参数；事件处理程序函数和可选的起始位置，即`_events`数组的索引：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first thing we do is default the `startPos` parameter to `0,` if it was
    not provided. Next we check that a song isn't already playing, and make sure we
    actually have some events to play. If so we set the `_playing` flag to `true`,
    store the event handler reference, and then call `playEvent()` for the first event.
    We return `true` if playback was successfully started.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`startPos`参数默认设置为`0`，如果没有提供的话。接下来，我们检查歌曲是否已经在播放，并确保我们实际上有一些事件要播放。如果是这样，我们将`_playing`标志设置为`true`，存储事件处理程序的引用，然后为第一个事件调用`playEvent()`。如果成功开始播放，则返回`true`。
- en: 'Now let''s write the `playEvent()` method. It takes one parameter, the index
    of the next event to fire:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写`playEvent()`方法。它接受一个参数，即要触发的下一个事件的索引：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first thing we do is get the event at the specified index in the `_events`
    array. Then we immediately call the event handler's callback function that was
    provided in the `startPlayback()` method, passing it the event code, the note
    to play, and the event index.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是在`_events`数组中获取指定索引处的事件。然后立即调用`startPlayback()`方法中提供的事件处理程序的回调函数，传递事件代码、要播放的音符和事件索引。
- en: Next we increment the index to get the next event. If there is another event
    we call `setTimeout()` to wait for the amount of time specified in the event's
    `deltaTime` field before calling `playEvent()`, again passing it the index of
    the next event. We compute the amount of time to wait by multiplying `deltaTime`
    by the inverse of the playback rate. For example, if the playback rate is 0.5
    then the wait time will be 1 , 0.5 or 2 times the normal rate. This loop continues
    in this fashion until there are no more events to play.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们增加索引以获取下一个事件。如果还有其他事件，我们将调用`setTimeout()`来等待事件的`deltaTime`字段中指定的时间量，然后再次调用`playEvent()`，传递下一个事件的索引。我们通过将`deltaTime`乘以播放速率的倒数来计算等待的时间量。例如，如果播放速率为0.5，则等待时间将是1，0.5或2倍于正常速率。这个循环将继续进行，直到没有更多的事件要播放。
- en: 'The last thing we need is a public `stopPlayback()` method. This method is
    called to stop the event loop, and therefore stop the playback of the audio events:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要一个公共的`stopPlayback()`方法。调用此方法将停止事件循环，从而停止音频事件的播放：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First we check the `_playing` flag to make sure a song is actually playing.
    If so, we set the flag to `false`, and then we call `clearTimeout()` to stop the
    timeout. This will stop `playEvent()` from being called again, which will stop
    the playback loop.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`_playing`标志，以确保歌曲实际上正在播放。如果是这样，我们将标志设置为`false`，然后调用`clearTimeout()`来停止超时。这将阻止再次调用`playEvent()`，从而停止播放循环。
- en: 'The last thing we need is to define the playback event codes, so we don''t
    have to remember the event code numbers. We will define a pseudo enumeration using
    an object on `AudioSequencer` called `eventCodes`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是定义播放事件代码，这样我们就不必记住事件代码编号。我们将使用`AudioSequencer`上的对象定义一个伪枚举，称为`eventCodes`：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*What just happened?*'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created an audio sequencer object that takes an array of music events, similar
    to MIDI events, and calls them at the correct time using the `setTimeout()` function.
    When an event is fired it calls the event handler function, passed in by the game
    panel.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个音频序列对象，它接受一个音乐事件数组，类似于MIDI事件，并使用`setTimeout()`函数在正确的时间调用它们。当事件被触发时，它会调用游戏面板传入的事件处理程序函数。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although we have written this code to play music, you could use the same technique
    anywhere you need things to happen at predetermined intervals.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们编写了这段代码来播放音乐，但你可以在任何需要在预定时间发生事情的地方使用相同的技术。
- en: Playing a song
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放歌曲
- en: Now that we have an audio sequencer, we can go into the game panel and add some
    code to play a song in practice mode. As the song plays it will press the correct
    keys on the screen, just like a player piano. Later we will add code to check
    for player interaction to see how good they follow along with the song.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个音频序列，我们可以进入游戏面板并添加一些代码以在练习模式下播放歌曲。当歌曲播放时，它将在屏幕上按下正确的键，就像玩家钢琴一样。稍后我们将添加代码来检查玩家的互动，看他们跟着歌曲的节奏有多好。
- en: Time for action – adding the audio sequencer
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加音频序列
- en: 'Let''s add the audio sequencer to the game panel. We will go into the `GamePanel`
    object and add an instance of `AudioSequencer` to it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将音频序列添加到游戏面板中。我们将进入`GamePanel`对象，并在其中添加一个`AudioSequencer`的实例：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next let''s write the public `setOptions()` method, which is called from the
    `startGame()` method of `PianoHeroApp`. It takes three parameters; the song name,
    playback rate, and whether to play the game or the song in practice mode:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们编写公共的`setOptions()`方法，该方法从`PianoHeroApp`的`startGame()`方法中调用。它接受三个参数；歌曲名称，播放速率，以及是否在练习模式下播放游戏或歌曲：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first thing we do is set the `events()` property of the audio sequencer
    to the data for the song to play. We get the song data from the `musicData` object,
    which is defined in `musicData.js`. Then, we set the audio sequencer's `playbackRate()`
    property. Lastly we set the `practiceMode` variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将音频序列的`events()`属性设置为要播放的歌曲的数据。我们从`musicData.js`中定义的`musicData`对象中获取歌曲数据。然后，我们设置音频序列的`playbackRate()`属性。最后，我们设置`practiceMode`变量。
- en: 'The `musicData` object contains event data that the sequencer can play for
    all of the songs that the user can select on the splash page. Each song is defined
    as an array of music event objects. Here''s an example of what the data looks
    like for the rhyme *Twinkle, Twinkle Little Star*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`musicData`对象包含了音序器可以为用户在闪屏页面上选择的所有歌曲播放的事件数据。每首歌曲都被定义为一个音乐事件对象的数组。以下是韵律“Twinkle,
    Twinkle Little Star”数据的示例：'
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It starts with a cue point event (`event: 3`), and then turns on note 3C (`event:
    1`). After 500 milliseconds it turns off note 3C (`event: 2`). It continues on
    until the last event, which is end of track (`event: 4`).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '它以一个提示点事件（`event: 3`）开始，然后打开3C音符（`event: 1`）。500毫秒后，关闭3C音符（`event: 2`）。它一直持续到最后一个事件，即曲目结束（`event:
    4`）。'
- en: 'Next let''s write the `startGame()` method, which is called from the `show()`
    method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们编写`startGame()`方法，该方法从`show()`方法中调用：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first thing we do is hide the results panel and show the notes panel. Then
    we reset the score and statistics.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先隐藏结果面板并显示音符面板。然后重置分数和统计信息。
- en: Next, we start an interval timer by calling the JavaScript `setInterval()` function
    and setting the `intervalId` variable to the handle that is returned. We will
    use that later to stop the interval when the game has finished, or the player
    stops the game. This interval is used to animate the elements in the notes panel
    that fall down from the top of the page. We set the interval to fire at a constant
    rate by dividing 1000 milliseconds by the number of frames per second. We will
    use a frame rate of 30 frames per second, which is enough to produce a relatively
    smooth animation and not bog down the game. At every interval of the timer we
    call the `updateNotes()` method, which we'll write in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用JavaScript的`setInterval()`函数并将`intervalId`变量设置为返回的句柄来启动一个间隔计时器。我们稍后将使用它来在游戏结束或玩家停止游戏时停止间隔。此间隔用于动画播放从页面顶部下落的音符面板中的元素。我们通过将1000毫秒除以每秒帧数来设置间隔以以恒定速率触发。我们将使用每秒30帧的帧速率，这足以产生相对平滑的动画，而不会拖慢游戏。在计时器的每个间隔处，我们调用`updateNotes()`方法，我们将在下一节中编写。
- en: 'The final thing we do in this method is call the `startPlayback()` method of
    the audio sequencer, passing it a reference to our audio event handler method,
    `onAudioEvent()`, and a start position of zero:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中的最后一件事是调用音频顺序器的`startPlayback()`方法，将音频事件处理程序方法`onAudioEvent()`的引用和起始位置零传递给它：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This method accepts two parameters: the audio event code and the note to play.
    We use a `switch` statement along with our `eventCodes` enumeration to determine
    how to handle the event. If the event code is `noteOn`, we call the `addNote()`
    method to add a `note` element to the notes panel. If it''s an `endOfTrack` event,
    we call `stopPlayback()` on the audio sequencer. We can ignore all of the other
    events for now.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受两个参数：音频事件代码和要播放的音符。我们使用`switch`语句以及我们的`eventCodes`枚举来确定如何处理事件。如果事件代码是`noteOn`，我们调用`addNote()`方法向音符面板添加一个`note`元素。如果是`endOfTrack`事件，我们在音频顺序器上调用`stopPlayback()`。我们现在可以忽略所有其他事件。
- en: '*What just happened?*'
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added the audio sequencer to our game panel and hooked up a function to handle
    when note events are fired. We added a `startGame()` method that starts the animation
    interval for animating the `note` elements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将音频顺序器添加到游戏面板中，并连接一个处理音符事件触发的函数。我们添加了一个`startGame()`方法，用于启动动画间隔以动画播放`note`元素。
- en: Creating animated notes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画音符
- en: 'Now we are going to implement the code for the notes panel. This is where the
    animation of notes dropping from the top of the page happens. It works something
    like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现音符面板的代码。这是音符从页面顶部下落的动画发生的地方。它的工作方式如下：
- en: The audio sequencer sends an event that a note should be played (see `onAudioEvent()`
    in the previous section).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频顺序器发送一个事件，指示应该播放一个音符（请参阅上一节中的`onAudioEvent()`）。
- en: The note is not actually played at that time. Instead a rectangular element
    that represents the note is added to the top of the notes panel.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此时实际上并没有播放音符。相反，表示音符的矩形元素被添加到音符面板的顶部。
- en: Every time our animation interval timer fires, the y-position of the `note`
    element is incremented so that it moves down.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们的动画间隔计时器触发时，`note`元素的y位置会递增，使其向下移动。
- en: When the element hits the bottom edge of the notes panel (and the top edge of
    the keyboard), it plays the audio clip associated with the note.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素触及音符面板的底边（以及键盘的顶边）时，它会播放与音符相关的音频剪辑。
- en: When the element completely leaves the notes panel, it is removed from the DOM.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素完全离开音符面板时，它将从DOM中移除。
- en: '![Creating animated notes](img/5947OT_07_04.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![创建动画音符](img/5947OT_07_04.jpg)'
- en: Time for action – adding notes
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-添加音符
- en: 'Let''s write the `addNote()` method that was referenced by `onAudioEvent()`
    in the previous section. This method takes one parameter, the name of the note
    to add:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`addNote()`方法，该方法在上一节中由`onAudioEvent()`引用。此方法接受一个参数，要添加的音符的名称：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First we update the `noteCount` variable to keep track of statistics. Then we
    create a new note `<div>` element using jQuery, and give it a class of `"note"`.
    We set the `data-note` custom attribute to the name of the note. We will need
    that later when it reaches the bottom of the panel to know which note to play.
    Lastly, we add it to the notes panel using jQuery's `append()` method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更新`noteCount`变量以跟踪统计信息。然后，我们使用jQuery创建一个新的音符`<div>`元素，并给它一个`"note"`类。我们将`data-note`自定义属性设置为音符的名称。当它到达面板底部时，我们将需要它来知道要播放哪个音符。最后，我们使用jQuery的`append()`方法将其添加到音符面板中。
- en: The next thing we do is position the `note` element over the piano key that
    it represents. We get the piano key element that is associated with the note by
    calling our existing `getPianoKeyElement()` method. We extract the left position
    and width of the piano key, and set the `note` element to the same values so that
    it lines up.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是将`note`元素定位在它所代表的钢琴键上。我们通过调用现有的`getPianoKeyElement()`方法来获取与音符关联的钢琴键元素。我们提取钢琴键的左侧位置和宽度，并将`note`元素设置为相同的值，使其对齐。
- en: The final thing we do is check if the piano key is a black or white key, by
    checking if it has the `"black"` class defined on it. If so, we give the `note`
    element a `"black"` class too. This will make the element appear in a different
    color.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的是检查钢琴键是黑键还是白键，方法是检查它是否定义了`"black"`类。如果是，则我们也给`note`元素添加`"black"`类。这将使元素以不同的颜色显示。
- en: 'Let''s add the styling for the `note` elements:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`note`元素添加样式：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We set the `position` to `absolute` because we need to move them around and
    place them wherever we want. We give them a linear gradient from left to right,
    fading from white to cyan. We also give it a white shadow with no offset. This
    will make it look like it''s glowing against the black background:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`position`设置为`absolute`，因为我们需要移动它们并将它们放在我们想要的任何位置。我们给它们一个从左到右的线性渐变，从白色渐变到青色。我们还给它一个没有偏移的白色阴影。这将使它看起来像是在黑色背景上发光：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The notes with the `"black"` class will override the background color to fade
    from white to magenta.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`“black”`类的音符将覆盖背景颜色，从白色渐变为品红色。
- en: '*What just happened?*'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a method that adds elements that represent notes to the notes panel.
    We positioned those notes so that they are directly over the top of the piano
    key they belong to.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个方法，向音符面板添加代表音符的元素。我们将这些音符定位在它们所属的钢琴键的正上方。
- en: Time for action – animating the notes
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到了行动的时候-为音符添加动画
- en: 'Previously, we started an interval using `setInterval()` in the `startGame()`
    method. The `updateNotes()` method gets called every time the interval expires.
    This method is responsible for updating the position of all of the `note` elements,
    so they appear to move down the screen:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在`startGame()`方法中使用`setInterval()`开始了一个间隔。`updateNotes()`方法在间隔到期时被调用。该方法负责更新所有`note`元素的位置，使它们看起来向下移动屏幕：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First we select all of the `note` elements in the notes panel and iterate over
    them. For each one we do the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择音符面板中的所有`note`元素并对它们进行迭代。对于每一个，我们执行以下操作：
- en: Get the top position and check if it is less than 200, which is the height of
    the notes panel.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取顶部位置并检查是否小于200，这是音符面板的高度。
- en: If the element is still inside the notes panel, we move the element down the
    number of pixels defined by the `pixelsPerFrame` variable. At 30 frames per second
    this is 2 pixels.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果元素仍然在音符面板内，我们将元素向下移动`pixelsPerFrame`变量定义的像素数。每秒30帧，即2像素。
- en: Next we check if the bottom of the `note` element hit the bottom of the notes
    panel by checking if the bottom is more than 200.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们检查`note`元素的底部是否击中了音符面板的底部，方法是检查底部是否大于200。
- en: If so, we set the `currentNote` object's `note` variable to the note, so we
    can check if the user played the correct note later. We also get the exact time
    the note hit the bottom, to determine how close the player was to playing it on
    time.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，我们将`currentNote`对象的`note`变量设置为音符，这样我们可以稍后检查用户是否演奏了正确的音符。我们还获取音符击中底部的确切时间，以确定玩家离按时演奏有多近。
- en: If we are in practice mode, we also play the note by calling `pressPianoKey()`
    and passing it the `note` element.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们处于练习模式，还可以通过调用`pressPianoKey()`并将`note`元素传递给它来演奏音符。
- en: If the `note` element is outside of the notes panel, then we call `releasePianoKey()`
    and remove it from the DOM.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`note`元素在音符面板之外，那么我们调用`releasePianoKey()`并将其从DOM中移除。
- en: The final thing we do is check if there are any more note elements left in the
    notes panel. If not, the game is over and we call `showScore()` to show the results
    panel. Then we call `endGame()`, which stops the animation interval.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是检查音符面板中是否还有任何音符元素。如果没有，游戏结束，我们调用`showScore()`来显示结果面板。然后我们调用`endGame()`，停止动画间隔。
- en: '*What just happened?*'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We animated the `note` elements so that they appear to fall down the screen
    over the keys of the keyboard that they represent. When the notes hit the bottom
    of the notes panel, we play the note if in practice mode. When the `note` element
    moves out of the panel, we remove it from the DOM.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`note`元素进行了动画处理，使它们看起来在键盘上的键上下落。当音符击中音符面板底部时，如果处于练习模式，我们会演奏音符。当`note`元素移出面板时，我们将其从DOM中移除。
- en: Have a go hero
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试一试英雄
- en: Try playing around with the frame rate and see how it affects the quality of
    the animation. What is the lowest frame rate that is acceptable? What is the highest
    frame rate that is perceptible?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整帧速率，看看它如何影响动画的质量。什么是可以接受的最低帧速率？什么是可以察觉到的最高帧速率？
- en: Handling user input
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: The user has started the game and notes are falling down the screen. Now we
    need to check if the player presses the correct piano key at the correct time.
    When they do, we will give them some points based on how accurate they were.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用户已经开始了游戏，音符正在屏幕上下落。现在我们需要检查玩家是否在正确的时间按下了正确的钢琴键。当他们这样做时，我们将根据他们的准确性给他们一些分数。
- en: Time for action – checking the notes
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-检查音符
- en: 'We will add a call to the `checkNote()` method in the `keyDown()` method. The
    `checkNote()` method takes the name of the note as a parameter, and checks if
    there is a `note` element at the bottom of the notes panel that matches it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`keyDown()`方法中添加对`checkNote()`方法的调用。`checkNote()`方法以音符的名称作为参数，并检查音符面板底部是否有与之匹配的`note`元素：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First we check the `currentNote` object that was set previously in `updateNotes()`
    . If its note is the same as the one the user played, then they might get some
    points for playing it at the correct time. To find out if they get points, we
    first find the time difference in milliseconds between the time the note hit the
    bottom of the panel and the current time. If it's within the allowable grace period,
    which we set to 200 milliseconds, then we compute the score.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查之前在`updateNotes()`中设置的`currentNote`对象。如果它的音符与用户演奏的音符相同，那么他们可能会因在正确时间演奏而得到一些分数。要找出他们是否得分，我们首先找出音符击中面板底部的时间与当前时间之间的毫秒时间差。如果在允许的宽限期内，我们将其设置为200毫秒，那么我们计算得分。
- en: 'We first increment the number of correct notes. Then, we determine the score
    by computing the percentage of time they were off by and multiplying it by 10\.
    This way the number of points per note is between 1 and 10\. Finally, to give
    the user some indication that they got it right, we change the background color
    of the element to green and call `addHitEffect()`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先增加了正确音符的数量。然后，我们通过计算他们的偏差百分比并乘以10来确定分数。这样，每个音符的分数在1到10之间。最后，为了给用户一些指示他们做对了，我们将元素的背景颜色改为绿色，并调用`addHitEffect()`：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `addHitEffect()` method flashes the **PIANO HERO** title in the background
    of the notes panel by changing its color, waiting for 100 milliseconds using a
    `setTimeout()` call, and then changing it back to black.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`addHitEffect()`方法通过改变颜色在音符面板的背景中闪烁**PIANO HERO**标题，使用`setTimeout()`调用等待100毫秒，然后将其改回黑色。'
- en: '![Time for action – checking the notes](img/5947OT_07_06.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-检查音符](img/5947OT_07_06.jpg)'
- en: '*What just happened?*'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We added a method to check if the correct piano key was pressed at the correct
    time for a `note` element. If so, we add points depending on how well timed the
    note was played, and change the color of the note to indicate success.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个方法来检查是否在“音符”元素的正确时间按下了正确的钢琴键。如果是这样，我们根据音符的演奏时间来添加分数，并改变音符的颜色以指示成功。
- en: Ending the game
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束游戏
- en: Now the player can play the game and we can keep track of the score and the
    number of notes they got correct. When the game ends, we need to display the results
    panel that shows the score and some statistics.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家可以玩游戏，我们可以跟踪分数和他们正确演奏的音符数量。游戏结束时，我们需要显示结果面板，显示分数和一些统计信息。
- en: Time for action – creating the results panel
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建结果面板
- en: 'After all of the notes have been played for the song, the `updateNotes()` method
    calls `showScore()`, where we will show the player''s score and some statistics:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在歌曲的所有音符都被演奏后，`updateNotes()`方法调用`showScore()`，在那里我们将显示玩家的分数和一些统计信息：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First we hide the notes panel and fade in the score panel in its place. Then,
    we fill in the score and statistics into the placeholders in the DOM. We show
    the score, number of notes correct, and total number of notes. In addition, we
    compute the percentage of notes they got correct using the `notesCorrect` and
    `noteCount` variables.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们隐藏音符面板，并在其位置淡入分数面板。然后，我们在DOM中的占位符中填入分数和统计信息。我们显示分数、正确音符的数量和总音符数量。此外，我们使用`notesCorrect`和`noteCount`变量计算他们正确演奏的音符的百分比。
- en: We get the timing accuracy percentage by factoring it from the score and number
    of notes correct. Remember that there are a total of 10 points possible per note,
    so if they got 17 notes correct the total number of possible points is 170\. If
    the score was 154 that would be 154 / 170 ≈ 91%.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从分数和正确音符的数量中计算来获得时间准确度百分比。请记住，每个音符可能获得的总分数是10分，所以如果他们正确演奏了17个音符，那么可能获得的总分数是170。如果分数是154，那么154/170≈91%。
- en: '![Time for action – creating the results panel](img/5947OT_07_05.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-创建结果面板](img/5947OT_07_05.jpg)'
- en: '*What just happened?*'
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We showed the results panel when the game is over, and populated it with the
    player's score and statistics. Our game is now finished. Go ahead and give it
    a try and become a piano hero!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，我们显示了结果面板，并填充了玩家的分数和统计信息。我们的游戏现在已经完成。试一试，成为钢琴英雄！
- en: Have a go hero
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一试
- en: Try writing an audio recorder class that records when the user plays a note
    on the keyboard, and saves it to an array of data objects that can be played by
    the audio sequencer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个音频记录器类，记录用户在键盘上演奏音符的时间，并将其保存到可以由音频序列器播放的数据对象数组中。
- en: Pop quiz
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: Q1\. Which JavaScript function can be used to create a timer that fires at regular
    intervals until cleared?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪个JavaScript函数可以用来创建一个定时器，直到清除为止？
- en: '`setTimeout()`'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setTimeout()`'
- en: '`setRate()`'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setRate()`'
- en: '`setInterval()`'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setInterval()`'
- en: '`wait()`'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wait()`'
- en: Q2\. Which attributes of a `<progress>` element control the percentage of the
    progress bar that is marked complete?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. `<progress>`元素的哪些属性控制标记为完成的进度条的百分比？
- en: '`value` and `max`'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`value`和`max`'
- en: '`currentValue` and `maxValue`'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`currentValue`和`maxValue`'
- en: '`start` and `end`'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`start`和`end`'
- en: '`min` and `max`'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`min`和`max`'
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We created a game based on the piano application we wrote in the previous chapter.
    We used JavaScript timers to implement an audio sequencer to play back songs and
    create an animation loop. We created splash and game panels and learned how to
    transition game states between them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个基于我们在上一章中编写的钢琴应用程序的游戏。我们使用JavaScript计时器来实现音频序列器以播放歌曲并创建动画循环。我们创建了闪屏和游戏面板，并学会了在它们之间过渡游戏状态。
- en: 'We covered the following concepts in this chapter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们涵盖了以下概念：
- en: How to create a splash panel and use text shadows to produce interesting text
    effects
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个闪屏面板并使用文本阴影产生有趣的文本效果
- en: How to use an HTML5 progress bar element to show the progress of loading dynamic
    resources
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用HTML5进度条元素显示动态资源的加载进度
- en: Using JavaScript timer functions to create an audio sequencer, to control playback
    of audio to play songs
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript计时器函数创建音频序列器，控制音频播放以播放歌曲
- en: How to animate DOM elements using a JavaScript timer
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JavaScript计时器来动画DOM元素
- en: How to transition between game states and panels
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在游戏状态和面板之间过渡
- en: How to collect user input, verify it, and show the results at the end of the
    game
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何收集用户输入，验证它，并在游戏结束时显示结果
- en: In the next chapter, we will learn all about using Ajax to dynamically load
    resources and call web services by building a weather widget.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Ajax来动态加载资源并通过构建天气小部件调用Web服务。
