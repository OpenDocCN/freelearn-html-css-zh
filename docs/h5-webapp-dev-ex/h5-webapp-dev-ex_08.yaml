- en: Chapter 8. A Change in the Weather
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。天气的变化
- en: '"Climate is what we expect, weather is what we get."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"气候是我们所期望的，天气是我们得到的。"'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: – Mark Twain
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -马克·吐温
- en: '*In this chapter, we will build a weather widget to learn about using Ajax
    to load content asynchronously and communicate with web services. We will learn
    about Ajax and how to use jQuery''s Ajax methods to load files that contain XML
    or JSON formatted data. Then we will get the weather conditions from a web service
    to display in the widget. We will also use the HTML Geolocation API to find the
    user''s location so we can show their local weather.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将构建一个天气小部件，以了解如何使用Ajax异步加载内容并与Web服务通信。我们将学习Ajax以及如何使用jQuery的Ajax方法加载包含XML或JSON格式数据的文件。然后我们将从Web服务获取天气状况以在小部件中显示。我们还将使用HTML地理位置API来查找用户的位置，以便显示他们当地的天气。*'
- en: 'We will learn the following in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学到以下内容：
- en: How to get XML and JSON data using jQuery' Ajax methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用jQuery的Ajax方法获取XML和JSON数据
- en: Parsing JSON versus XML returned from services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析从服务返回的JSON与XML
- en: What web services are and how to communicate with them asynchronously using
    Ajax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Web服务以及如何使用Ajax异步与它们通信
- en: The problem with cross site scripting, and the solution JSONP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本的问题，以及解决方案JSONP
- en: How to use HTML5 Geolocation API to get the user's location
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用HTML5地理位置API获取用户的位置
- en: How to connect to a web service to get the current weather report
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何连接到Web服务以获取当前天气报告
- en: Introduction to Ajax
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax简介
- en: Ajax is a technology used by JavaScript to send data to, and receive data from,
    a server. Originally **Ajax** stood for **Asynchronous JavaScript and XML**, but
    now this meaning has been lost as JSON (which we learned about in [Chapter 1](ch01.html
    "Chapter 1. The Task at Hand"), *The Task at Hand*) has begun to replace XML as
    the preferred format for packaging data, and Ajax requests do not need to be asynchronous.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax是JavaScript用于向服务器发送数据和接收数据的技术。最初**Ajax**代表**异步JavaScript和XML**，但现在这个含义已经丢失，因为JSON（我们在[第1章](ch01.html
    "第1章。手头的任务")中学到的，*手头的任务*）已经开始取代XML作为打包数据的首选格式，而Ajax请求不需要是异步的。
- en: Using Ajax will make your applications more dynamic and responsive. Rather than
    having postbacks whenever you need to update a part of a web page, you can load
    only the necessary data and update the page dynamically. With Ajax we can retrieve
    almost anything from the server, including HTML snippets to be inserted into the
    web page and static data to be used by the application. We can also call web services
    that provide access to things such as data and services that are only available
    on the server side.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ajax将使您的应用程序更加动态和响应。与其在每次需要更新网页的部分时都进行回发，您可以仅加载必要的数据并动态更新页面。通过Ajax，我们可以从服务器检索几乎任何东西，包括要插入到网页中的HTML片段和应用程序使用的静态数据。我们还可以调用提供对服务器端唯一可用的数据和服务的Web服务。
- en: Making Ajax requests
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发出Ajax请求
- en: jQuery provides methods that make it easy to access web resources and call web
    services using Ajax. The `ajax()` method is the most primitive of them. If you
    want to have the most control over service calls you can use this method. Most
    of the time it is preferable to use one of the higher level methods such as `get()`
    or `post()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了一些方法，可以轻松访问Web资源并使用Ajax调用Web服务。`ajax()`方法是其中最原始的方法。如果你想对服务调用有最大的控制，可以使用这个方法。大多数情况下，最好使用`get()`或`post()`等更高级的方法。
- en: The `get()` method makes it easier to do an HTTP GET request using Ajax. At
    its simplest, you pass in the URL of the resource or service you want to get and
    it asynchronously sends the request and gets the response. When it's done it executes
    a callback function that you provide.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法使使用Ajax进行HTTP GET请求变得更加容易。最简单的情况下，您传入要获取的资源或服务的URL，它会异步发送请求并获取响应。完成后，它会执行您提供的回调函数。'
- en: 'For example, the following code snippet makes a GET request for an XML file
    on the server, and displays its contents in a dialog:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段对服务器上的XML文件进行GET请求，并在对话框中显示其内容：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All of the jQuery Ajax methods return an object that you can attach `done()`,
    `fail()`, and `always()` callback methods to. The `done()` method gets called
    after the request is successful, `fail()` gets called if there was an error, and
    `always()` gets called last whether the request succeeded or failed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的jQuery Ajax方法都返回一个对象，您可以附加`done()`、`fail()`和`always()`回调方法。`done()`方法在请求成功后调用，`fail()`在出现错误时调用，`always()`在请求成功或失败后都会调用：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The data that gets passed to the `done()` method will be either an XML root
    element, a JSON object, or a string depending on the MIME type specified in the
    response. If it's a JSON object, you can reference the data as you would any JavaScript
    object. If it's an XML element you can use jQuery to traverse the data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`done()`方法的数据将根据响应中指定的MIME类型，要么是XML根元素，要么是JSON对象，要么是字符串。如果是JSON对象，您可以像引用任何JavaScript对象一样引用数据。如果是XML元素，您可以使用jQuery来遍历数据。
- en: 'You may provide query parameters to the request by passing in an object literal
    of name/value pairs:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传入一个名称/值对的对象文字来为请求提供查询参数：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will make the following request:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发出以下请求：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the `post()` method if you prefer to make a POST request rather than GET,
    which may be preferable if you are using a secure protocol such as HTTPS, and
    don''t want the query parameters visible on the request:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢进行POST请求而不是GET请求，则可以使用`post()`方法，如果您使用安全协议（如HTTPS）并且不希望在请求中看到查询参数，则可能更可取：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some browsers, including Chrome, you can't access files with Ajax requests
    using the `file://` protocol. In that case you will need to run your application
    through a web server such as IIS or Apache, or use a different browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些浏览器中，包括Chrome，您无法使用`file://`协议通过Ajax请求访问文件。在这种情况下，您需要通过IIS或Apache运行您的应用程序，或者使用其他浏览器。
- en: Time for action – creating a weather widget
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建一个天气小部件
- en: 'Throughout this chapter we will demonstrate how to make various Ajax calls
    by implementing a widget that shows a weather report. Let''s start by defining
    the widget''s HTML markup:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何通过实现一个显示天气报告的小部件来进行各种Ajax调用。让我们从定义小部件的HTML标记开始：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The widget consists of three different panels, only one of which will show at
    any given time. The `<div class="loading">` panel will be visible while the weather
    data is being retrieved from the server. It has an animated image in it to indicate
    to the user that something is loading.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件由三个不同的面板组成，任何时候只有一个面板会显示。`<div class="loading">`面板在从服务器检索天气数据时可见。它里面有一个动画图像，向用户指示正在加载某些内容。
- en: The `<div class="results">` panel will show the weather data that was returned
    from the server. It contains placeholder fields for us to put the weather data
    into. Notice that we are using custom data attributes on the placeholder `<span>`
    elements. Those will be used later to extract the correct data from the XML document
    or JSON object returned by the server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div class="results">`面板将显示从服务器返回的天气数据。它包含占位符字段，用于放置天气数据。请注意，我们在占位符`<span>`元素上使用了自定义数据属性。稍后将使用这些属性从服务器返回的XML文档或JSON对象中提取正确的数据。'
- en: The `<div class="error">` panel will show an error message if the Ajax request
    failed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div class="error">`面板将在Ajax请求失败时显示错误消息。'
- en: 'Now let''s create the JavaScript code to control the widget in a new file named
    `weatherWidget.js`. We will create a `WeatherWidget` object whose constructor
    takes a reference to the widget''s root element wrapped in a jQuery object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建JavaScript代码来控制小部件，命名为`weatherWidget.js`。我们将创建一个`WeatherWidget`对象，其构造函数接受一个包装在jQuery对象中的小部件根元素的引用：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our object we create one public method called `update()`. This will be called
    from the page to tell the widget to update the weather report. In the `update()`
    method we first hide the results panel and show the loading panel. Then we call
    the `getWeatherReport()` method, which will make the Ajax call and update the
    widget when it is finished. We will write different versions of this method in
    the next few sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的对象中，我们创建了一个名为`update()`的公共方法。这将从页面调用，告诉小部件更新天气报告。在`update()`方法中，我们首先隐藏结果面板，显示加载面板。然后我们调用`getWeatherReport()`方法，它将进行Ajax调用并在完成时更新小部件。在接下来的几节中，我们将编写此方法的不同版本。
- en: '*What just happened?*'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a weather widget that can be placed on any page in a website. It
    has a public `update()` method that is called to tell the widget to update its
    information.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个可以放置在网站任何页面上的天气小部件。它有一个公共的`update()`方法，用于告诉小部件更新其信息。
- en: Time for action – getting XML data
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-获取XML数据
- en: First let's create an example of getting data from an XML file and updating
    the weather widget from its data. We will create a new web page called `weather.html`
    and put the markup for the weather widget into it. This page will have a **Check
    Weather** button. When clicked, it will call the weather widget's `update()` method.
    You can find the code for this example in `Chapter 8/example8.1`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们创建一个从XML文件中获取数据并从其数据更新天气小部件的示例。我们将创建一个名为`weather.html`的新网页，并将天气小部件的标记放入其中。该页面将有一个**检查天气**按钮。单击时，它将调用天气小部件的`update()`方法。您可以在`第8章/示例8.1`中找到此示例的代码。
- en: 'Next we need to create an XML file with some weather information in it. We
    will name the file `weather.xml` and place it in the `data` folder:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个包含一些天气信息的XML文件。我们将文件命名为`weather.xml`，并将其放在`data`文件夹中：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s write the `getWeatherReport()` method in the `WeatherWidget` object:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`WeatherWidget`对象中编写`getWeatherReport()`方法：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this method we use the jQuery `get()` method to perform the Ajax request
    and pass it the path to our XML file. If the server call is successful we call
    the `populateWeather()` method, passing it the data returned from the request.
    This will be the root element of a DOM that represents our XML file. If the request
    fails we call the `showError()` method, passing it the error message.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们使用jQuery的`get()`方法执行Ajax请求，并将XML文件的路径传递给它。如果服务器调用成功，我们调用`populateWeather()`方法，将请求返回的数据传递给它。这将是表示我们的XML文件的DOM的根元素。如果请求失败，我们调用`showError()`方法，将错误消息传递给它。
- en: 'Next let''s write the `populateWeather()` method. This is where we will extract
    the data from the XML document and insert it into the page:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们编写`populateWeather()`方法。这是我们将从XML文档中提取数据并插入到页面中的地方：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need a way to extract data from the XML document retrieved from the server.
    Fortunately for us, jQuery can be used to select elements from any XML document,
    not just the web page's DOM. All we have to do is pass in the root element or
    our XML as the second parameter to a jQuery select. This is exactly what we do
    in the first line of the method to get the `current_observation` element and store
    it in the `$observation` variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来从服务器检索到的XML文档中提取数据。幸运的是，jQuery可以用来选择任何XML文档中的元素，而不仅仅是网页的DOM。我们所要做的就是将我们的XML的根元素作为第二个参数传递给jQuery选择器。这正是我们在方法的第一行中所做的，以获取`current_observation`元素并将其存储在`$observation`变量中。
- en: Next we use jQuery to get the text from the `icon_url` element, and set the
    image's `src` attribute to it. This is an image that represents the current weather.
    We also get the text from the `location element` and insert that into the widget's
    header.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用jQuery从`icon_url`元素中获取文本，并将图像的`src`属性设置为它。这是表示当前天气的图像。我们还从`location`元素中获取文本，并将其插入到小部件的标题中。
- en: Then we iterate over all of the `<span>` elements in the conditions section
    of the widget. For each one we get the value of its `data-field` custom data attribute.
    We use that to find the element with the same name inside the `current_observation`
    element, get its text, and put it into the `<span>` element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历小部件条件部分中的所有`<span>`元素。对于每个元素，我们获取其`data-field`自定义数据属性的值。我们使用它来查找`current_observation`元素中具有相同名称的元素，获取其文本，并将其放入`<span>`元素中。
- en: 'The last thing we do is fade out the loading panel and fade in the results
    panel, to show the current weather on the page. Here''s what it looks like with
    the data loaded:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的最后一件事是淡出加载面板并淡入结果面板，以在页面上显示当前天气。加载的数据如下所示：
- en: '![Time for action – getting XML data](img/5947OT_08_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![执行操作-获取XML数据](img/5947OT_08_02.jpg)'
- en: '*What just happened?*'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We loaded an XML file from the server that contains weather data using jQuery's
    `get()` Ajax method. Then, we extracted the information from the XML document
    using jQuery selects and put it into the widget's placeholder elements to show
    it on the page.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用jQuery的`get()` Ajax方法从服务器加载了一个包含天气数据的XML文件。然后，我们使用jQuery选择从XML文档中提取信息，并将其放入小部件的占位符元素中以在页面上显示它。
- en: Time for action – getting JSON data
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行操作-获取JSON数据
- en: Now let's do the same thing as we did in the previous section, except that we
    will get the data from a file containing JSON formatted data rather than XML.
    The concept is the same, except that what we get back from the Ajax call is a
    JavaScript object rather than an XML document. You can find the code for this
    example in `Chapter 8/example8.2`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做与上一节相同的事情，只是这次我们将从包含JSON格式数据的文件中获取数据，而不是XML。概念是相同的，只是从Ajax调用中返回的是JavaScript对象，而不是XML文档。您可以在`第8章/示例8.2`中找到此示例的代码。
- en: 'First let''s define our JSON file, which we will name `weather.json`, and put
    it in the `data` folder:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义我们的JSON文件，我们将其命名为`weather.json`，并将其放在`data`文件夹中：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This JSON defines an anonymous wrapping object with a `location` object and
    a `current_observation` object inside of it. The `current_observation` object
    contains all of the data that the `current_observation` element had in the XML
    document.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON定义了一个匿名包装对象，其中包含一个`location`对象和一个`current_observation`对象。`current_observation`对象包含XML文档中`current_observation`元素的所有数据。
- en: 'Now let''s rewrite `getWeatherReport()` to get the JSON data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重写`getWeatherReport()`以获取JSON数据：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We still use the `get()` method, but now we are getting the JSON file. Notice
    how this time we are adding a query parameter to the URL set to the current time
    in milliseconds. This is a way to get around the browser's caching. Most browsers
    don't seem to recognize when files have changed using Ajax requests. By adding
    a parameter that changes every time we make the request, it fools the browser
    into thinking it's a new request, bypassing the cached one. The request will look
    something like `data/weather.json?t=1365127077960`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用`get()`方法，但现在我们正在获取JSON文件。请注意，这次我们正在向URL添加查询参数，设置为当前时间的毫秒数。这是绕过浏览器缓存的一种方法。大多数浏览器似乎无法识别使用Ajax请求更改文件时。通过添加每次发出请求时都会更改的参数，它会欺骗浏览器，使其认为这是一个新请求，绕过缓存。请求将类似于`data/weather.json?t=1365127077960`。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When running this application through a web server such as IIS, you may need
    to add the `.json` file type to the list of MIME types for your site (`.json`,
    `application/json`). Otherwise you will get an error that the file is not found.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过诸如IIS之类的Web服务器运行此应用程序时，您可能需要将`.json`文件类型添加到站点的MIME类型列表中（`.json`，`application/json`）。否则，您将收到文件未找到的错误。
- en: 'Now let''s rewrite the `populateWeather()` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重写`populateWeather()`方法：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time jQuery recognizes that we have loaded data in JSON format, and automatically
    converts it to a JavaScript object. So that's what gets passed into the method's
    `data` parameter. To get the observation data we can now simply access the `current_observation`
    field of the `data` object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这次jQuery认识到我们已经以JSON格式加载了数据，并自动将其转换为JavaScript对象。因此，这就是传递给方法的`data`参数。要获取观察数据，我们现在可以简单地访问`data`对象的`current_observation`字段。
- en: Just like before, we iterate over all of the `<span>` placeholder elements,
    but this time we use square brackets to access the data from the `observation`
    object using the `field` custom data attribute as the field name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们遍历所有的`<span>`占位符元素，但这次我们使用方括号来使用`field`自定义数据属性作为字段名从`observation`对象中访问数据。
- en: '*What just happened?*'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We rewrote the weather widget to get the weather data from a JSON formatted
    file. Since jQuery automatically converts JSON data into JavaScript objects, we
    were able to directly access the data rather than use jQuery to search through
    an XML document.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了天气小部件，以从JSON格式文件获取天气数据。由于jQuery会自动将JSON数据转换为JavaScript对象，因此我们可以直接访问数据，而不必使用jQuery搜索XML文档。
- en: HTML5 Geolocation API
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5地理位置API
- en: 'Later we will rewrite the weather widget once again to get the weather from
    a web service instead of a static file on the server. We want to show the user
    the weather for their current location, so we need some way to determine where
    the user is. HTML5 has just the thing for that: the Geolocation API.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将再次重写天气小部件，以从Web服务获取天气，而不是从服务器上的静态文件。我们希望向用户显示其当前位置的天气，因此我们需要某种方式来确定用户的位置。HTML5刚好有这样的东西：地理位置API。
- en: Geolocation is widely supported by nearly every modern browser. The accuracy
    of the location depends on the capabilities of the user's device. Devices that
    have GPS will give you a very accurate location, while those that don't will try
    to determine the user's location as close as they can by some other means, such
    as by IP address.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 地理位置由几乎每个现代浏览器广泛支持。位置的准确性取决于用户设备的功能。具有GPS的设备将提供非常准确的位置，而没有GPS的设备将尝试通过其他方式（例如通过IP地址）尽可能接近地确定用户的位置。
- en: 'The Geolocation API is accessed by using the `navigator.geolocation` object.
    To get the user''s location you call the `getCurrentPosition()` method. It takes
    two parameters- a callback function if it succeeds and a callback function if
    it fails:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`navigator.geolocation`对象访问地理位置API。要获取用户的位置，您调用`getCurrentPosition()`方法。它需要两个参数-如果成功则是回调函数，如果失败则是回调函数：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function that is called on success gets an object passed into it that contains
    another object named `coords`. The following is a list of some of the more useful
    fields the `coords` object contains:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用的函数会传递一个包含另一个名为`coords`的对象的对象。以下是`coords`对象包含的一些更有用的字段的列表：
- en: '`latitude`: This is the user''s latitude in decimal degrees (for example, 44.6770429).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`latitude`：这是用户的纬度，以十进制度表示（例如，44.6770429）。'
- en: '`longitude`: This is the user''s longitude in decimal degrees (for example,
    -85.60261659).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longitude`：这是用户的经度，以十进制度表示（例如，-85.60261659）。'
- en: '`accuracy`: This is the accuracy of the position in meters.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accuracy`：这是位置的精度，以米为单位。'
- en: '`speed`: This is the speed the user is moving in meters per second. This is
    available for devices with GPS.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speed`：这是用户以米每秒为单位的移动速度。这适用于带有GPS的设备。'
- en: '`heading`: This is the heading degrees that the user is moving in. Like speed
    this is for devices with GPS.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heading`：这是用户移动的方向度数。与速度一样，这适用于带有GPS的设备。'
- en: 'For example, if you wanted to get the user''s location you would do the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想获取用户的位置，您可以执行以下操作：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The user must allow your page to use the Geolocation API. If they reject your
    request, the call to `getCurrentPosition()` will fail, and depending on the browser
    your error handler may get called or fail silently. This is what the request looks
    like in Chrome:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须允许您的页面使用Geolocation API。如果他们拒绝您的请求，调用`getCurrentPosition()`将失败，并且根据浏览器，可能会调用错误处理程序或静默失败。在Chrome中，请求如下所示：
- en: '![HTML5 Geolocation API](img/5947OT_08_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![HTML5 Geolocation API](img/5947OT_08_01.jpg)'
- en: 'The error handler gets passed an error object that contains two fields, `code`
    and `message`. The `code` field is an integer error code and `message` is the
    error message string. There are three possible error codes: `permission denied`,
    `position unavailable`, or `timeout`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理程序会传递一个包含两个字段`code`和`message`的错误对象。`code`字段是整数错误代码，`message`是错误消息字符串。有三种可能的错误代码：`permission
    denied`，`position unavailable`或`timeout`。
- en: The Geolocation API also has a `watchPosition()` method. It works the same as
    `getCurrentPosition()`, except that your callback function gets called whenever
    the user moves. This way you can track the user and update their position in your
    application in real time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Geolocation API还有一个`watchPosition()`方法。它的工作方式与`getCurrentPosition()`相同，只是当用户移动时会调用您的回调函数。这样，您可以实时跟踪用户并在应用程序中更新他们的位置。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some browsers you must be running the web page through a web server such
    as IIS or Apache for geolocation to work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些浏览器中，您必须通过IIS或Apache等Web服务器运行网页才能使地理位置功能正常工作。
- en: Time for action – getting geolocation data
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-获取地理位置数据
- en: In this section we will add some code to our weather widget example to access
    the Geolocation API. You can find the code for this section in `chapter8/example8.3`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向我们的天气小部件示例中添加一些代码，以访问Geolocation API。您可以在`chapter8/example8.3`中找到本节的代码。
- en: 'First let''s go into `weather.html` and add a section to show the user''s location
    next to the **Check Weather** button:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们进入`weather.html`，并在**检查天气**按钮旁边添加一个显示用户位置的部分：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We add a `<div>` element with text fields to show the user's latitude and longitude
    that we got from the Geolocation API. We also add a `<div class="error">` element
    to show the error message if geolocation fails.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个带有文本字段的`<div>`元素，以显示我们从Geolocation API获取的用户纬度和经度。我们还添加了一个`<div class="error">`元素，以显示地理位置失败时的错误消息。
- en: 'Now let''s go into `weather.js` and add some code to the `WeatherApp` object.
    We will add a `getLocation()` method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入`weather.js`，并向`WeatherApp`对象添加一些代码。我们将添加一个`getLocation()`方法：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First we check that the Geolocation API is available by checking that the `geolocation`
    object exists in the `navigation` object. Then we call `geolocation.getCurrentPosition()`.
    The callback function takes the `position` object and gets the latitude and longitude
    from its `coords` object. It then sets the latitude and longitude into the text
    fields:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过检查`navigation`对象中是否存在`geolocation`对象来检查Geolocation API是否可用。然后我们调用`geolocation.getCurrentPosition()`。回调函数获取`position`对象，并从其`coords`对象中获取纬度和经度。然后将纬度和经度设置到文本字段中：
- en: '![Time for action – getting geolocation data](img/5947OT_08_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-获取地理位置数据](img/5947OT_08_03.jpg)'
- en: 'If the geolocation request failed for some reason, we get the error message
    from the error object and show it on the page:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因地理位置请求失败，我们从错误对象中获取错误消息，并在页面上显示它：
- en: '![Time for action – getting geolocation data](img/5947OT_08_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-获取地理位置数据](img/5947OT_08_05.jpg)'
- en: '*What just happened?*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We used the Geolocation API to get the user's position. We extracted the latitude
    and longitude and displayed them in text fields on the page. We will pass this
    into the weather service to get the weather for their location.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Geolocation API获取了用户的位置。我们提取了纬度和经度，并在页面上的文本字段中显示了它们。我们将把这些传递给天气服务，以获取他们所在位置的天气。
- en: Have a go hero
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: Create a web application that tracks the user's position using the Geolocation
    API. When the user's location changes, use Ajax to call the Google Static Maps
    API to get a map of the user's current position and update an image on the page.
    Open the application in your smart phone and drive around to see if it works.
    You can find the documentation for Google's Static Maps API at [https://developers.google.com/maps/documentation/staticmaps/](https://developers.google.com/maps/documentation/staticmaps/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Web应用程序，使用Geolocation API跟踪用户的位置。当用户位置发生变化时，使用Ajax调用Google Static Maps API获取用户当前位置的地图，并更新页面上的图像。在您的智能手机上打开应用程序并四处走动，看看它是否有效。您可以在[https://developers.google.com/maps/documentation/staticmaps/](https://developers.google.com/maps/documentation/staticmaps/)找到Google
    Static Maps API的文档。
- en: Using web services
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络服务
- en: Web services are an integral part of creating most enterprise-level web applications
    these days. They provide access to services that can't be accessed directly on
    the client side due to security restrictions. For example, you could have a web
    service that accesses a database to retrieve or store customer information. Web
    services can also provide centralized operations that can be accessed from many
    different applications. For example, a service that supplies weather data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是创建大多数企业级Web应用程序的重要组成部分。它们提供了无法直接在客户端访问的服务，因为存在安全限制。例如，您可以有一个访问数据库以检索或存储客户信息的web服务。Web服务还可以提供可以从许多不同应用程序访问的集中操作。例如，提供天气数据的服务。
- en: Web services can be created using any server side technology that can get a
    web request and return a response. It could be as simple as PHP, or as sophisticated
    as a service-oriented architecture such as .NET's WCF API. If you are the only
    one using your web service then PHP may be sufficient; if a web services is designed
    for public consumption, then maybe not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务可以使用任何可以接收Web请求并返回响应的服务器端技术创建。它可以是简单的PHP，也可以是像.NET的WCF API这样复杂的面向服务的架构。如果您是唯一使用您的Web服务的人，那么PHP可能足够了；如果Web服务是为公众使用而设计的，那么可能不够。
- en: Most web services provide data in either XML or JSON format. In the past, XML
    was the format of choice for web services. However, in recent years JSON has become
    very popular. Not only because more and more JavaScript applications are interacting
    directly with web services, but also because it is a succinct, easy-to-read, and
    easy-to-parse format. Many service providers are now switching over to JSON.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web服务以XML或JSON格式提供数据。过去，XML是Web服务的首选格式。然而，近年来JSON变得非常流行。不仅因为越来越多的JavaScript应用程序直接与Web服务交互，而且因为它是一种简洁、易于阅读和易于解析的格式。许多服务提供商现在正在转向JSON。
- en: It is not in the scope of this book to teach you how to write web services,
    but we will learn how to interact with them by using a web service that provides
    localized weather reports.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的范围不在于教你如何编写web服务，但我们将学习如何通过使用提供本地天气报告的web服务与它们进行交互。
- en: Weather Underground
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Weather Underground
- en: For this example we will get the weather from a real web service. We will use
    the service provided by Weather Underground at [http://www.wunderground.com](http://www.wunderground.com).
    To run the example code you will need a developer API key, which can be obtained
    for free at [http://www.wunderground.com/weather/api/](http://www.wunderground.com/weather/api/).
    The free developer plan allows you to call their services, but limits the number
    of service calls you can make per day.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将从一个真实的web服务中获取天气。我们将使用Weather Underground提供的服务，网址为[http://www.wunderground.com](http://www.wunderground.com)。要运行示例代码，您需要一个开发者API密钥，可以在[http://www.wunderground.com/weather/api/](http://www.wunderground.com/weather/api/)免费获取。免费的开发者计划允许您调用他们的服务，但限制了您每天可以进行的服务调用次数。
- en: Cross-site scripting and JSONP
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站脚本和JSONP
- en: We can call a web service using any of the jQuery Ajax methods discussed in
    the previous sections. There is no problem calling web services that reside in
    the same domain as your web page. However, calling web services that exist in
    another domain presents a security problem. This is known as cross-site scripting,
    or XSS. For example, the page at `http://mysite.com/myPage.html` can't access
    any content from `http://yoursite.com`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面讨论过的任何jQuery Ajax方法来调用Web服务。调用与您的网页位于同一域中的Web服务没有问题。但是，调用存在于另一个域中的Web服务会带来安全问题。这就是所谓的跨站脚本，或XSS。例如，位于`http://mysite.com/myPage.html`的页面无法访问`http://yoursite.com`的任何内容。
- en: The problem with cross-site scripting is that hackers can inject client-side
    scripts into a request that will allow them to run malicious code in the user's
    browser. So how do we get around this restriction? We can use a communication
    technique known as **JSONP**, which stands for **JSON with Padding**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本的问题在于黑客可以将客户端脚本注入到请求中，从而允许他们在用户的浏览器中运行恶意代码。那么我们如何绕过这个限制呢？我们可以使用一种称为**JSONP**的通信技术，它代表**带填充的JSON**。
- en: 'JSONP works due to the fact that there is a security exception for loading
    JavaScript files from other domains. So in order to get around the restriction
    of getting plain JSON formatted data, JSONP simulates a `<script>` request. The
    server returns the JSON data wrapped in a JavaScript function call. If we take
    the JSON from the previous example and put it in a JSONP response, it will look
    something like the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JSONP的工作原理是由于从其他域加载JavaScript文件存在安全异常。因此，为了绕过获取纯JSON格式数据的限制，JSONP模拟了一个`<script>`请求。服务器返回用JavaScript函数调用包装的JSON数据。如果我们将前面示例中的JSON放入JSONP响应中，它将看起来像以下代码片段：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The great thing about using jQuery to make our Ajax requests is that we don't
    even have to think about how JSONP works. All we need to know is that we need
    to use it when calling services in other domains. To tell jQuery to use JSONP
    we pass in a `dataType` parameter set to `"jsonp"` to the `ajax()` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery进行Ajax请求的好处是，我们甚至不需要考虑JSONP的工作原理。我们只需要知道在调用其他域中的服务时需要使用它。要告诉jQuery使用JSONP，我们将`dataType`参数设置为`"jsonp"`传递给`ajax()`方法。
- en: 'The `ajax()` method can take in an object of name/value pairs that contains
    all of the parameters for making a request, including the URL. We put our `dataType`
    parameter in that object:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ajax()`方法可以接受一个包含所有请求参数的名称/值对对象，包括URL。我们将`dataType`参数放在该对象中：'
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Time for action – calling the weather service
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-调用天气服务
- en: Now that we have the user's location we can pass it to the Underground Weather
    service to get the user's current weather. We will use JSONP to call the service
    since the service exists in an external domain. Let's go into the `WeatherWidget`
    object and make a few changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了用户的位置，我们可以将其传递给Underground Weather服务，以获取用户当前的天气。由于服务存在于外部域中，我们将使用JSONP来调用该服务。让我们进入`WeatherWidget`对象并进行一些更改。
- en: 'First we need to change the constructor to take the Weather Underground API
    key. Since we''re writing a generic widget that could go on any page on any site,
    the developer of the page will need to provide their key:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改构造函数以获取Weather Underground API密钥。由于我们正在编写一个通用小部件，可以放置在任何站点的任何页面上，页面的开发人员需要提供他们的密钥：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next we will change the `getWeatherReport()` method. It now takes the coordinates
    of the place we want to get a weather report for. In this case it''s the user''s
    position that we got from the Geolocation API:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将更改`getWeatherReport()`方法。现在它获取我们想要获取天气报告的地点的坐标。在这种情况下，我们从地理位置API中获取的是用户的位置：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We make the call to the Weather Underground service using the `ajax()` method
    and JSONP. The base request to the service is [http://api.wunderground.com/api/](http://api.wunderground.com/api/)
    followed by the API key. To get the current weather conditions we add `/conditions/q/`
    to the URL, followed by the latitude and longitude separated by a comma. Last
    we append `".json"` to tell the service to give us data back in JSON format. The
    URL ends up looking like [http://api.wunderground.com/api/xxxxxxxx/conditions/q/44.99,-85.48.json](http://api.wunderground.com/api/xxxxxxxx/conditions/q/44.99,-85.48.json).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ajax()`方法和JSONP调用Weather Underground服务。服务的基本请求是[http://api.wunderground.com/api/](http://api.wunderground.com/api/)后跟API密钥。要获取当前天气状况，我们在URL中添加`/conditions/q/`，后跟以逗号分隔的纬度和经度。最后，我们添加`".json"`告诉服务以JSON格式返回数据。URL最终看起来像[http://api.wunderground.com/api/xxxxxxxx/conditions/q/44.99,-85.48.json](http://api.wunderground.com/api/xxxxxxxx/conditions/q/44.99,-85.48.json)。
- en: The `done()` and `fail()` handlers are the same as they were in the previous
    example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`done()`和`fail()`处理程序与前面的示例中的处理程序相同。'
- en: 'Now let''s change the `populateWeather()` method to extract the data returned
    from the service:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更改`populateWeather()`方法，以提取从服务返回的数据：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This version of the `populateWeather()` method is nearly identical to the one
    we used for our JSON file example. The only difference is that we add an image
    to the footer of the widget showing the Weather Underground logo, which is part
    of the terms of service for using their service.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`populateWeather()`方法几乎与我们在JSON文件示例中使用的方法相同。唯一的区别是我们在小部件的页脚中添加了一个显示Weather
    Underground标志的图像，这是使用他们的服务的服务条款的一部分。
- en: 'The only thing left to do is go back into the web page''s main `WeatherApp`
    object, and change the call to `WeatherWidget` to provide the API key and location:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情就是回到网页的主`WeatherApp`对象，并更改对`WeatherWidget`的调用，以提供API密钥和位置：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next we change `getCurrentWeather()`, which is called when the **Check Weather**
    button is clicked, to pass the user''s coordinates to the widget''s `update()`
    method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更改`getCurrentWeather()`，当单击**检查天气**按钮时调用该方法，将用户的坐标传递给小部件的`update()`方法：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After fading in the widget, we get the coordinates from the text input fields.
    Then we call the widget''s `update()` method, passing the coordinates to it. There
    you have it; the weather for the user''s location is shown:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件淡入后，我们从文本输入字段中获取坐标。然后我们调用小部件的`update()`方法，将坐标传递给它。这样，用户位置的天气就显示出来了：
- en: '![Time for action – calling the weather service](img/5947OT_08_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-调用天气服务](img/5947OT_08_04.jpg)'
- en: '*What just happened?*'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We changed the weather widget to use the Weather Underground service to get
    the current weather for the user's location, which we got from the Geolocation
    API. We used JSONP to call the service since it's not in the same domain as our
    web page.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了天气小部件，使用Weather Underground服务获取了从地理位置API获取的用户位置的当前天气。我们使用JSONP调用服务，因为它不在与我们网页相同的域中。
- en: Pop quiz
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验
- en: Q1\. What jQuery method do you use to make an Ajax request?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 你使用哪个jQuery方法来发出Ajax请求？
- en: '`ajax()`'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ajax()`'
- en: '`get()`'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get()`'
- en: '`post()`'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`post()`'
- en: All of the above
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: Q2\. When do you need to use JSONP to make an Ajax request?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 何时需要使用JSONP进行Ajax请求？
- en: When calling a web service
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用web服务时
- en: When making a request to another domain
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向另一个域发出请求时
- en: When making a request to the same domain
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向同一域发出请求时
- en: When doing a POST request
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行POST请求时
- en: Q3\. What information does the Geolocation API provide?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Q3\. 地理位置API提供什么信息？
- en: The user's latitude and longitude
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户的纬度和经度
- en: The user's country
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户的国家
- en: The user's address
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户的地址
- en: All of the above
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we created a weather widget that can be placed on any page.
    We made Ajax requests to get static XML and JSON data from the server. We learned
    how to find the user's location using the Geolocation API, and used that to call
    a web service to get localized weather data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个可以放置在任何页面上的天气小部件。我们使用Ajax请求从服务器获取静态XML和JSON数据。我们学会了如何使用地理位置API找到用户的位置，并使用它来调用web服务以获取本地化的天气数据。
- en: 'We covered the following concepts in this chapter:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涵盖了以下概念：
- en: How to read XML and JSON files from the server using Ajax
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Ajax从服务器读取XML和JSON文件
- en: How to extract data from XML returned from server calls using jQuery
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用jQuery从服务器调用返回的XML中提取数据
- en: How to get the user's current position anywhere in the world using the HTML5
    Geolocation API
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用HTML5地理位置API在世界任何地方获取用户的当前位置
- en: How to interact with web services asynchronously using Ajax
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Ajax异步与web服务交互
- en: Using JSONP to get around the security restrictions of cross site scripting
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSONP绕过跨站点脚本的安全限制
- en: How to get the weather report for a user's current location using geolocation
    and a web service
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用地理位置和web服务获取用户当前位置的天气报告
- en: In the next chapter, we will learn about creating multithreaded JavaScript applications
    using the Web Workers API. We will create an application that draws Mandelbrot
    fractals without locking up the browser.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Web Workers API创建多线程JavaScript应用程序。我们将创建一个应用程序，绘制Mandelbrot分形图，而不会锁定浏览器。
