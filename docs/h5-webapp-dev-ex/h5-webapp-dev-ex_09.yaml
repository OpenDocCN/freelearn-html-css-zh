- en: Chapter 9. Web Workers Unite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。Web Workers Unite
- en: '"If you want creative workers, give them enough time to play."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"如果你想要有创造力的工作者，就给他们足够的玩耍时间。"'
- en: '*—John Cleese*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*—约翰·克里斯*'
- en: '*In this chapter we will learn how to use HTML5 web workers to run background
    processes in another thread. We can use this to make applications with long running
    processes more responsive. We will draw a Mandelbrot fractal on a canvas using
    a web worker to generate it asynchronously without locking up the browser window.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将学习如何使用HTML5 web worker在另一个线程中运行后台进程。我们可以使用这个功能使具有长时间运行进程的应用程序更具响应性。我们将使用web
    worker在画布上绘制Mandelbrot分形，以异步方式生成它，而不会锁定浏览器窗口。*'
- en: 'We will learn the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: How to make web applications more responsive by using web workers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用web workers使web应用程序更具响应性的方法
- en: How to start and manage a web worker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启动和管理web worker
- en: How to communicate with a web worker and send data back and forth
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与web worker通信并来回发送数据
- en: How to draw a Mandelbrot fractal on a canvas using a web worker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用web worker在画布上绘制Mandelbrot分形
- en: Tips for debugging web workers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试web workers的技巧
- en: Web workers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web workers
- en: Web workers provide a way to run JavaScript code in the background on a separate
    thread from the main thread of a web application. Although it may seem like JavaScript
    is multithreaded because of its asynchronous nature, the truth is that there is
    only one thread. If you tie that thread up with a long running process, the web
    page will become unresponsive until it finishes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Web workers提供了一种在Web应用程序的主线程之外的后台线程中运行JavaScript代码的方式。尽管由于其异步性质，JavaScript可能看起来是多线程的，但事实上只有一个线程。如果你用一个长时间运行的进程来占用这个线程，网页将变得无响应，直到进程完成。
- en: In the past you could alleviate this problem by breaking long-running processes
    into chunks to do a little bit of the work at a time. After each chunk you would
    call `setTimeout(),` passing it a value of zero for the timeout. When you call
    `setTimeout()` `,` what actually happens is that an event gets put into the event
    queue after the amount of time specified. This allows other event already in the
    queue a chance to get handled until your timer event makes it to the front of
    the queue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，您可以通过将长时间运行的进程分成块来缓解这个问题，以便一次处理一点工作。在每个块之后，您将调用`setTimeout()`，将超时值设为零。当您调用`setTimeout()`时，实际上会在指定的时间后将事件放入事件队列。这允许队列中已经存在的其他事件有机会被处理，直到您的计时器事件到达队列的最前面。
- en: If you've ever worked with threads before you will be aware that it is easy
    to run into concurrency issues. One thread could be working on the same data as
    another thread, which could cause corrupted data, or even worse, deadlocks. Fortunately
    web workers don't give us much of a chance to run into concurrency issues. Web
    workers are not allowed to access non-thread safe components such as the DOM.
    They also can't access the `window`, `document`, or `parent` objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前使用过线程，您可能会意识到很容易遇到并发问题。一个线程可能正在处理与另一个线程相同的数据，这可能导致数据损坏，甚至更糟糕的是死锁。幸运的是，web
    worker不会给我们太多机会遇到并发问题。web worker不允许访问非线程安全的组件，如DOM。它们也无法访问`window`、`document`或`parent`对象。
- en: This thread safety does come at a price, though. Since a web worker can't access
    the DOM, it can't do any work that manipulates page elements. It can't directly
    manipulate any of the data structures from the main thread, either. At this point
    you might be thinking, if the web worker can't access anything then what good
    is it?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种线程安全是有代价的。由于web worker无法访问DOM，它无法执行任何操作来操作页面元素。它也无法直接操作主线程的任何数据结构。此时你可能会想，如果web
    worker无法访问任何东西，那它有什么用呢？
- en: Well, web workers can't access data in the main thread, but they can pass data
    back and forth via messages. The key thing to remember, however, is that any data
    passed to a web worker is serialized before being sent and then de-serialized
    on the other end so that it is working on a copy, not the original data. The web
    worker can then do some processing on the data and send it back, using serialization
    again, to the main thread. Just remember that there will be some overhead to passing
    large data structures so you might still want to chunk your data and process it
    in smaller batches.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，web worker无法访问主线程中的数据，但它们可以通过消息来回传递数据。然而，需要记住的关键一点是，传递给web worker的任何数据在发送之前都会被序列化，然后在另一端进行反序列化，以便它在副本上工作，而不是原始数据。然后，web
    worker可以对数据进行一些处理，并再次使用序列化将其发送回主线程。只需记住，传递大型数据结构会有一些开销，因此您可能仍然希望将数据分块并以较小的批次进行处理。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some browsers do support the ability to transfer objects without making a copy,
    which is great for large data structures. At this time it is only supported by
    a few browsers so we will not cover it here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器确实支持在不复制的情况下传输对象，这对于大型数据结构非常有用。目前只有少数浏览器支持这一功能，所以我们在这里不会涉及。
- en: Spawning a web worker
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成web worker
- en: 'The code for a web worker is defined in its own JavaScript file separate from
    the main application. The main thread spawns a web worker by creating a new `Worker`
    object giving it the path to the file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: web worker的代码在其自己的JavaScript文件中定义，与主应用程序分开。主线程通过创建一个新的`Worker`对象并给它文件路径来生成一个web
    worker：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The application and the worker communicate with each other by sending messages.
    To receive messages we add a message event handler to the worker using `addEventListener()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和worker通过发送消息进行通信。要接收消息，我们使用`addEventListener()`为worker添加消息事件处理程序：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An `event` object gets passed as a parameter to the event handler. It has a
    `data` field that contains any data passed back from the worker. The `data` field
    can be anything that can be represented with JSON including strings, number, data
    objects, and arrays.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`event`对象作为参数传递给事件处理程序。它有一个`data`字段，其中包含从worker传回的任何数据。`data`字段可以是任何可以用JSON表示的东西，包括字符串、数字、数据对象和数组。
- en: 'To start a worker after it has been created you send a message to it using
    the `postMessage()` method. It takes one optional parameter which is the data
    to send to the worker. In this example it''s simply a string:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Worker后，可以使用`postMessage()`方法向其发送消息。它接受一个可选参数，即要发送给Worker的数据。在这个例子中，它只是一个字符串：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implementing a web worker
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Web Worker
- en: 'As mentioned previously, the code for the web worker is specified in a separate
    file. Inside a worker you also add an event listener to receive messages from
    the application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Web Worker的代码在单独的文件中指定。在Worker内部，您还可以添加一个事件监听器，以接收来自应用程序的消息：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside the worker there is a `self` keyword that references the global scope
    of the worker. Using the `self` keyword is optional, like using the `window` object
    (all global variables and functions are attached to the `window` object). We will
    use it here just to show the context.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Worker内部，有一个`self`关键字，它引用Worker的全局范围。使用`self`关键字是可选的，就像使用`window`对象一样（所有全局变量和函数都附加到`window`对象）。我们在这里使用它只是为了显示上下文。
- en: 'The worker can send messages back to the main thread using `postMessage()`
    . It works exactly the same as it does in the main thread:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Worker可以使用`postMessage()`向主线程发送消息。它的工作方式与主线程完全相同：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When a worker is finished it can call the `close()` method to terminate the
    worker. After closing, a worker it can no longer be used:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当Worker完成后，可以调用`close()`方法来终止Worker。关闭后，Worker将不再可用：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also import other external JavaScript files into a worker using the
    `importScripts()` method. It takes the path to one or more script files:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`importScripts()`方法将其他外部JavaScript文件导入Worker。它接受一个或多个脚本文件的路径：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This works well for using the same library of code in both your main thread
    and the web worker.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于在主线程和Web Worker中使用相同的代码库非常有效。
- en: Time for action – using a web worker
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用Web Worker
- en: Let's create a really simple application that gets the user's name and passes
    it to a web worker. The web worker will return a "hello" message back to the application.
    The code for this section can be found in `Chapter 9/example9.1`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单的应用程序，获取用户的名称并将其传递给Web Worker。Web Worker将向应用程序返回一个“hello”消息。此部分的代码可以在`Chapter
    9/example9.1`中找到。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The web workers don't work in some browsers unless you are running them through
    a web server such as IIS or Apache.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些浏览器中，Web Worker不起作用，除非您通过IIS或Apache等Web服务器运行它们。
- en: 'First we create an application with `webWorkerApp.html`, `webWorkerApp.css`,
    and `webWorkerApp.js` files. We add a text input field to the HTML asking for
    the user''s name and a response section to display the message from the worker:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含`webWorkerApp.html`、`webWorkerApp.css`和`webWorkerApp.js`文件的应用程序。我们在HTML中添加一个文本输入字段，询问用户的名称，并添加一个响应部分，用于显示来自Worker的消息：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `webWorkerApp.js`, when the user clicks on the submit button we call the
    `executeWorker()` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`webWorkerApp.js`中，当用户点击提交按钮时，我们调用`executeWorker()`方法：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First we get the name the user entered into the text field. Then we create a
    new `Worker` that has its code defined in `helloWorker.js`. We add a message event
    listener that gets a message back from the worker and puts it into the page's
    response section. Last but not least we send the user's name to the worker using
    `postMessage()` to start it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们获取用户在文本字段中输入的名称。然后我们创建一个在`helloWorker.js`中定义了其代码的新的`Worker`。我们添加一个消息事件监听器，从Worker那里获取消息并将其放入页面的响应部分。最后，我们使用`postMessage()`将用户的名称发送给Worker以启动它。
- en: 'Now let''s create the code for our web worker in `helloWorker.js`. There we
    add the code to get the message from the main thread and send a message back:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`helloWorker.js`中创建我们的Web Worker的代码。在那里，我们添加了从主线程获取消息并发送消息的代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First we add an event listener to get the message from the application. We extract
    the name from the `event.data` field and pass that into the `sayHello()` function.
    The `sayHello()` function simply prepends "Hello" to the user's name and sends
    the message back to the application using `postMessage()`. Back in the main application
    it gets the message and displays it on the page.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个事件监听器来获取应用程序的消息。我们从`event.data`字段中提取名称，并将其传递给`sayHello()`函数。`sayHello()`函数只是在用户的名称前面加上“Hello”，然后使用`postMessage()`将消息发送回应用程序。在主应用程序中，它获取消息并在页面上显示它。
- en: '*What just happened?*'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a simple application that gets the user's name and passes it to a
    web worker. The web worker sends a message back to the application where it is
    displayed on the page - that's how easy it is to use web workers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的应用程序，获取用户的名称并将其传递给Web Worker。Web Worker将消息发送回应用程序，在页面上显示 - 这就是使用Web
    Worker的简单方法。
- en: The Mandelbrot set
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mandelbrot集
- en: To demonstrate how to use web workers to do some real processing we will create
    an application that draws **Mandelbrot fractals** . Drawing a Mandelbrot is pretty
    intensive and takes a lot of processing power. If you don't run it in a separate
    thread, the application will become unresponsive while it's drawing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 演示如何使用Web Worker来进行一些真正的处理，我们将创建一个绘制Mandelbrot分形的应用程序。绘制Mandelbrot需要相当多的处理能力。如果不在单独的线程中运行，应用程序在绘制时会变得无响应。
- en: Drawing a Mandelbrot is a relatively simple process. We will use the **escape
    time algorithm** . For each pixel in the image we will determine how many iterations
    it takes to reach a critical escape condition. The number of iterations determines
    the color of the pixel. If we don't reach the escape condition within a maximum
    number of iterations, it is considered to be inside the Mandelbrot set and we
    color it black.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制Mandelbrot是一个相对简单的过程。我们将使用**逃逸时间算法**。对于图像中的每个像素，我们将确定达到临界逃逸条件需要多少次迭代。迭代次数决定像素的颜色。如果我们在最大迭代次数内未达到逃逸条件，则被视为在Mandelbrot集内，并将其涂黑。
- en: 'For more information about this algorithm and the Mandelbrot set see the Wikipedia
    page:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此算法和Mandelbrot集的更多信息，请参阅维基百科页面：
- en: '[http://en.wikipedia.org/wiki/Mandelbrot_set](http://en.wikipedia.org/wiki/Mandelbrot_set)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Mandelbrot_set](http://en.wikipedia.org/wiki/Mandelbrot_set)'
- en: Time for action – implementing the algorithm
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-实施算法
- en: 'Let''s create a `MandelbrotGenerator` object in a new file named `mandelbrotGenerator.js`.
    This object will implement the algorithm that generates the Mandelbrot. The constructor
    takes the canvas width and height, and the bounds of the Mandelbrot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个名为`mandelbrotGenerator.js`的新文件中创建一个`MandelbrotGenerator`对象。这个对象将实现生成Mandelbrot的算法。构造函数接受画布的宽度和高度，以及Mandelbrot的边界：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next we define the variables that the algorithm uses:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义算法使用的变量：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `scalarX` and `scalarY` variables are used to convert the Mandelbrot coordinates
    to canvas coordinates. They are computed by dividing the width or height of the
    Mandelbrot by the width or height of the canvas. For example, while the canvas
    may be set to 640 by 480 pixels, the bounds of the Mandelbrot may be something
    like (-2, -2) for top left and (2, 2) for bottom right. In this case the Mandelbrot
    height and width are both 4:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`scalarX`和`scalarY`变量用于将Mandelbrot坐标转换为画布坐标。它们是通过将Mandelbrot的宽度或高度除以画布的宽度或高度来计算的。例如，虽然画布可能设置为640x480像素，但Mandelbrot的边界可能是左上角(-2，-2)和右下角(2，2)。在这种情况下，Mandelbrot的高度和宽度都是4：'
- en: '![Time for action – implementing the algorithm](img/5947OT_09_01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-实施算法](img/5947OT_09_01.jpg)'
- en: Next we set the maximum number of iterations for the algorithm to 1000\. If
    you set it higher you will get better results but it will take longer to compute.
    Using 1000 provides a good middle ground between processing time and acceptable
    results. The `abort` variable is used to stop the algorithm. The `inSetColor`
    variable controls what color pixels that are in the Mandelbrot set get colored.
    We set it to black. Finally there is an array of colors that will get used to
    color pixels that aren't in the set.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将算法的最大迭代次数设置为1000。如果您将其设置得更高，您将获得更好的结果，但计算时间将更长。使用1000提供了处理时间和可接受结果之间的良好折衷。`abort`变量用于停止算法。`inSetColor`变量控制Mandelbrot集中的像素的颜色。我们将其设置为黑色。最后，有一个颜色数组，用于给不在集合中的像素上色。
- en: 'Let''s write those methods to convert canvas coordinates to Mandelbrot coordinates
    first. They simply multiply the position by the scalar and add the top or left
    offset:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先编写这些方法，将画布坐标转换为Mandelbrot坐标。它们只是将位置乘以标量，然后加上顶部或左侧的偏移量：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s define the main loop of the algorithm in a public method named `draw()`.
    It takes the image data from a canvas to draw on as a parameter:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在一个名为`draw()`的公共方法中定义算法的主循环。它以要绘制的画布上的图像数据作为参数：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the outer loop we iterate over all of the rows of pixels in the canvas. Inside
    this loop we call `getMandelbrotY()`, passing in the canvas y-position and get
    back the corresponding y-position in the Mandelbrot.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部循环中，我们遍历画布中所有行的像素。在这个循环内，我们调用`getMandelbrotY()`，传入画布的y位置，并返回Mandelbrot中相应的y位置。
- en: 'Next we iterate over all of the pixels in the row. For each pixel we:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历行中的所有像素。对于每个像素，我们：
- en: Call `getMandelbrotX()`, passing in the canvas x-position and get back the corresponding
    x-position in the Mandelbrot.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`getMandelbrotX()`，传入画布的x位置，并返回Mandelbrot中相应的x位置。
- en: Call `getIterations()`, passing in the Mandelbrot x and y positions. This method
    is where it will find the number of iterations it takes to reach the escape condition.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`getIterations()`，传入Mandelbrot的x和y位置。这个方法将找到达到逃逸条件所需的迭代次数。
- en: Call `getColor()`, passing in the number of iterations. This method gets the
    color for the number of iterations.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`getColor()`，传入迭代次数。这个方法获取迭代次数的颜色。
- en: Finally we call `setPixel()`, passing in the image data, x and y positions,
    and the color.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`setPixel()`，传入图像数据、x和y位置以及颜色。
- en: 'Let''s implement the `getIterations()` method next. This is where we determine
    if the pixel is within the Mandelbrot set or not. It takes the Mandelbrot x and
    y positions as parameters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们实现`getIterations()`方法。这是我们确定像素是否在Mandelbrot集合内的地方。它以Mandelbrot的x和y位置作为参数：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First we initialize working `x` and `y` positions to zero and the `iteration`
    counter to zero. Next we start a `do-while` loop. Inside the loop we increment
    the `iteration` counter and if it is more than `maxIterations` we return `-1`.
    This signals that the escape condition was not met and the point is inside the
    Mandelbrot set.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将工作的`x`和`y`位置初始化为零，`iteration`计数器初始化为零。接下来，我们开始一个`do-while`循环。在循环内，我们递增`iteration`计数器，如果它大于`maxIterations`，我们返回`-1`。这表示逃逸条件未满足，该点在Mandelbrot集合内。
- en: Next we compute the x and y variables for checking the escape condition. Then
    we check the condition to determine whether to continue with the loop. Once the
    escape condition has been met we return the number of iterations it took to find
    it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们计算用于检查逃逸条件的x和y变量。然后我们检查条件，以确定是否继续循环。一旦满足逃逸条件，我们返回找到它所需的迭代次数。
- en: 'Now we will write the `getColor()` method. It takes the iteration count as
    a parameter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写`getColor()`方法。它以迭代次数作为参数：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the `iteration` parameter is less than zero it means it's in the Mandelbrot
    set and we return the `inSetColor` object. Otherwise we look up the color object
    in the colors array by using the modulus operator to constrain the number of iterations
    to the length of the array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`iteration`参数小于零，这意味着它在Mandelbrot集合中，我们返回`inSetColor`对象。否则，我们使用模运算符在颜色数组中查找颜色对象，以限制迭代次数的长度。
- en: 'Finally we will write the `setPixel()` method. It takes the image data, canvas
    x and y positions, and the color:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写`setPixel()`方法。它接受图像数据、画布x和y位置以及颜色：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This should look very familiar from [Chapter 5](ch05.html "Chapter 5. Not So
    Blank Canvas"), *Not So Blank Canvas*, where we learned how to manipulate image
    data. First we find the index of the pixel in the image data array. Then we set
    each of the color channels from the `color` object and set the opacity to the
    maximum value of `255`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来非常熟悉，就像[第5章](ch05.html "第5章。并不是空白画布")中的内容，我们学习了如何操作图像数据。首先，我们找到图像数据数组中的像素的索引。然后，我们从`color`对象中设置每个颜色通道，并将不透明度设置为`255`的最大值。
- en: '*What just happened?*'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We implemented the algorithm to draw a Mandelbrot to a canvas's image data.
    Each pixel is set to either black if it's in the Mandelbrot set or some color
    depending on how many iterations it took to find the escape condition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了绘制Mandelbrot到画布图像数据的算法。每个像素要么设置为黑色，要么根据找到逃逸条件所需的迭代次数设置为某种颜色。
- en: Creating a Mandelbrot application
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Mandelbrot应用程序
- en: Now that we have the algorithm implemented let's create an application that
    uses it to draw a Mandelbrot on the page. We will start off drawing it without
    a web worker to show how the process makes the web page unresponsive. Then we
    will use a web worker to draw the Mandelbrot in the background to see the difference.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了算法，让我们创建一个应用程序来使用它在页面上绘制Mandelbrot。我们将首先在没有Web Worker的情况下进行绘制，以展示这个过程如何使网页无响应。然后我们将使用Web
    Worker在后台绘制Mandelbrot，以查看差异。
- en: Time for action – creating a Mandelbrot application
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建Mandelbrot应用程序
- en: Let's start off by creating a new application with `mandelbrot.html`, `mandelbrot.css`,
    and `mandelbrot.js` files. We also include `mandelbrotGenerator.js` we created
    previously for the application. You can find the code for this section in `Chapter
    9/example9.2`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的应用程序开始，其中包括`mandelbrot.html`、`mandelbrot.css`和`mandelbrot.js`文件。我们还包括了之前为应用程序创建的`mandelbrotGenerator.js`。您可以在`第9章/example9.2`中找到本节的代码。
- en: 'In the HTML file we add a `<canvas>` element to the HTML to draw the Mandelbrot
    on and set the size to 640 by 480:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文件中，我们向HTML添加了一个`<canvas>`元素来绘制Mandelbrot，并将大小设置为640x480：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also add three buttons with pre-set Mandelbrot bounds defined as arrays
    in JSON format in the `data-settings` custom data attribute:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了三个按钮，其中预设的Mandelbrot边界以JSON格式定义为`data-settings`自定义数据属性中的数组：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let''s go into the JavaScript file and add the code to call the Mandelbrot
    generator. Here we define variables to hold references to the canvas and its context:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入JavaScript文件，并添加调用Mandelbrot生成器的代码。在这里，我们定义变量来保存对画布及其上下文的引用：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next we add a `drawMandelbrot()` method that will get called when one of the
    buttons is clicked. It takes the bounds of the Mandelbrot to draw as parameters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个`drawMandelbrot()`方法，当其中一个按钮被点击时将被调用。它以Mandelbrot的边界作为参数进行绘制：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First we display a status of **Drawing…** in the status bar. Then we get the
    image data for the entire canvas. Next we create a new instance of the `MandelbrotGenerator`
    object, passing in the canvas and bounds settings. Then we call its `draw()` method
    passing, in the image data. When it has finished we draw the image data back to
    the canvas and set the status to **Finished**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在状态栏中显示**绘制中...**的状态。然后，我们获取整个画布的图像数据。接下来，我们创建`MandelbrotGenerator`对象的一个新实例，传入画布和边界设置。然后我们调用它的`draw()`方法，传入图像数据。当它完成时，我们将图像数据绘制回画布，并将状态设置为**完成**。
- en: 'The last thing we need to do is update the application''s `start()` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是更新应用程序的`start()`方法：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we add one click event handler for all of the buttons. When a button is
    clicked on we get the `settings` custom data attribute, which is an array, and
    pass the values into `drawMandelbrot()` to draw it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为所有按钮添加了一个点击事件处理程序。当点击按钮时，我们获取`settings`自定义数据属性（一个数组），并将值传递给`drawMandelbrot()`进行绘制。
- en: 'That''s it- let''s open it in the browser and take a look. Depending on the
    browser you are using (some are a lot faster than others) and the speed of your
    system, the Mandelbrot should take long enough to draw that you notice the page
    has become unresponsive. If you try to click one of the other buttons nothing
    will happen. Also notice that although we call `setStatus("Drawing...")` you never
    see the status actually change. That''s because the drawing algorithm takes over
    before the runtime gets a chance to update the text on the page:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样-让我们在浏览器中打开并查看一下。根据您使用的浏览器（有些比其他浏览器快得多）和您系统的速度，Mandelbrot应该需要足够长的时间来绘制，以至于您会注意到页面已经变得无响应。如果您尝试点击其他按钮，将不会发生任何事情。还要注意，尽管我们调用了`setStatus("Drawing...")`，但您从未看到状态实际上发生变化。这是因为绘图算法在运行时有机会更新页面上的文本之前就接管了控制权：
- en: '![Time for action – creating a Mandelbrot application](img/5947OT_09_02.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动-创建Mandelbrot应用程序](img/5947OT_09_02.jpg)'
- en: '*What just happened?*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created an application to draw Mandelbrot sets using the drawing algorithm
    we created in the previous section. It doesn't use a web worker yet, so the page
    becomes unresponsive while it's drawing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个应用程序来绘制Mandelbrot集，使用了我们在上一节中创建的绘图算法。它还没有使用Web Worker，因此在绘制时页面会变得无响应。
- en: Time for action – Mandelbrot using a web worker
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-使用Web Worker的Mandelbrot
- en: Now we will implement the same thing except this time we will use a web worker
    to offload the processing onto another thread. This will free up the main thread
    to handle page updates and user interaction. You can find the source code for
    this section in `Chapter 9/example9.3`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现相同的功能，只是这次我们将使用Web Worker来将处理转移到另一个线程。这将释放主线程来处理页面更新和用户交互。您可以在`第9章/example9.3`中找到本节的源代码。
- en: 'Let''s go into the HTML and add a checkbox where we can select whether to use
    web workers or not. This will make it easier to compare results in the browser:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入HTML并添加一个复选框，我们可以选择是否使用Web Worker。这将使在浏览器中比较结果更容易：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll also add a stop button. There was no way to stop before without web
    workers because the UI was locked up, but now we will be able to implement it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个停止按钮。以前没有Web Worker的情况下无法停止，因为UI被锁定，但现在我们将能够实现它：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s go ahead and create our web worker in a new file named `mandelbrotWorker.js`.
    Our worker needs to use the `MandelbrotGenerator` object so we will import that
    script into the worker:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续在一个名为`mandelbrotWorker.js`的新文件中创建我们的Web Worker。我们的worker需要使用`MandelbrotGenerator`对象，因此我们将该脚本导入worker：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s define our message event handler for the worker. Upon receiving
    a message with the data necessary to draw the Mandelbrot, the worker will start
    generating it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为worker定义消息事件处理程序。在接收到包含绘制Mandelbrot所需数据的消息时，worker将开始生成它：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First we create a new instance of `MandelbrotGenerator`, passing in the values
    we got from the main application thread including the canvas width and height
    and the Mandelbrot bounds. Then we call the generator's `draw()` method, passing
    in the image data which is also included in the message. After the generator is
    done, we pass the image data with the Mandelbrot drawn into back to the main thread
    by calling `postMessage()` with the image data as the parameter. Lastly, we call
    `close()` to terminate the worker.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`MandelbrotGenerator`的一个新实例，传入我们从主应用程序线程获取的值，包括画布的宽度和高度以及Mandelbrot边界。然后，我们调用生成器的`draw()`方法，传入消息中也包含的图像数据。生成器完成后，我们通过调用`postMessage()`将包含绘制Mandelbrot的图像数据传递回主线程。最后，我们调用`close()`来终止worker。
- en: That's it for the worker. Let's go back to our main application object, `MandelbrotApp`
    and add code to start the web worker when one of the buttons is clicked.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，worker就完成了。让我们回到我们的主应用程序对象`MandelbrotApp`，并添加代码，以便在单击按钮时启动Web Worker。
- en: 'Back in `mandelbrot.js`, we need to add a global variable to the application
    object named worker that will hold a reference to the web worker. Then we rewrite
    `drawMandelbrot()` to add some new code to start the worker:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mandelbrot.js`中，我们需要向应用程序对象添加一个名为worker的全局变量，该变量将保存对Web Worker的引用。然后，我们重写`drawMandelbrot()`以添加一些新代码来启动worker：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First we check if the `worker` variable is set. If so the worker is already
    running and there''s no need to continue. Then we clear the canvas and set the
    status. Next we check if the **Use worker** checkbox is checked. If so, we call
    `startWorker(),` passing in the Mandelbrot bounds parameters. The `startWorker()`
    method is where we create the web worker and start it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`worker`变量是否已设置。如果是，则worker已经在运行，无需继续。然后我们清除画布并设置状态。接下来，我们检查**使用worker**复选框是否被选中。如果是，我们调用`startWorker()`，传入Mandelbrot边界参数。`startWorker()`方法是我们创建Web
    Worker并启动它的地方：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First we create a new `Worker,` passing into it the path to `mandelbrotWorker.js`.
    Then we add a message event handler to the worker which will get called when it
    is done. It takes the image data it got back from the worker and draws it to the
    canvas.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的`Worker`，将`mandelbrotWorker.js`的路径传递给它。然后，我们向worker添加一个消息事件处理程序，当worker完成时将调用该处理程序。它获取从worker返回的图像数据并将其绘制到画布上。
- en: Next we start the worker. First we get the image data from the canvas's context.
    Then we put the image data, the canvas width and height, and the Mandelbrot bounds
    into an object that we pass to the worker by calling `postMessage()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们启动worker。首先，我们从画布的上下文中获取图像数据。然后，我们将图像数据、画布的宽度和高度以及Mandelbrot边界放入一个对象中，通过调用`postMessage()`将其传递给worker。
- en: 'There''s one thing left to do. We need to implement the stop button. Let''s
    write a `stopWorker()` method that will be called when the stop button is clicked:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事要做。我们需要实现停止按钮。让我们编写一个`stopWorker()`方法，当单击停止按钮时将调用该方法：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First we check if the worker is running by checking if the `worker` variable
    is set. If so we call the worker's `terminate()` method to stop the worker. Calling
    `terminate()` is equivalent to calling `self.close()` from inside the worker.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过检查`worker`变量是否已设置来检查worker是否正在运行。如果是，我们调用worker的`terminate()`方法来停止worker。调用`terminate()`相当于在worker内部调用`self.close()`。
- en: '*What just happened?*'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么?*'
- en: We implemented a web worker that can draw the Mandelbrot from a background thread.
    This allows the user to continue to interact with the page while the Mandelbrot
    is drawing. We demonstrated this by adding a stop button that can stop the drawing
    process. You will also notice that the **Drawing…** status message now gets displayed
    while the fractal is being drawn.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个可以从后台线程绘制Mandelbrot的Web Worker。这使用户可以在Mandelbrot绘制时继续与页面交互。我们通过添加一个停止按钮来演示这一点，该按钮可以停止绘制过程。您还会注意到，在绘制分形时，**正在绘制...**状态消息现在会显示出来。
- en: Have a go hero
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试试看
- en: One problem with our Mandelbrot application is that we are serializing and transferring
    the entire canvas's image data to the web worker and back. In our example that
    is 640 * 480 * 4 bytes, or 1,228,800 bytes. That's 1.2 GB! See if you can come
    up with a way to chunk up the drawing of the Mandelbrot into smaller pieces. If
    you want to see how I did it look at `Chapter 9/example9.4`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Mandelbrot应用程序的一个问题是，我们正在序列化和传输整个画布的图像数据到Web Worker，然后再传回。在我们的示例中，这是640 *
    480 * 4字节，或1,228,800字节。那是1.2 GB！看看您是否能想出一种将Mandelbrot的绘制分成更小块的方法。如果您想看看我是如何做到的，请查看`第9章/示例9.4`。
- en: Debugging web workers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Web Worker
- en: Debugging web workers can be difficult. You don't have access to the `window`
    object so you can't call `alert()` to display a message or `console.log()` to
    write out to the browser's JavaScript console. You can't write out a message to
    the DOM either. You can't even attach a debugger and step through the code. So
    what's a poor developer to do?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Web Worker可能很困难。您无法访问`window`对象，因此无法调用`alert()`来显示消息，也无法使用`console.log()`来写入浏览器的JavaScript控制台。您也无法向DOM写入消息。甚至无法附加调试器并逐步执行代码。那么，一个可怜的开发人员该怎么办呢？
- en: 'One thing you can do is add an error listener to the worker, so you get notified
    of any errors inside the worker''s thread:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为worker添加错误监听器，以便在worker线程内发生任何错误时收到通知：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The event object passed into the error handler contains the `filename`, `lineno`,
    and `message` fields. From those you can tell exactly where an error happened.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理程序传入的事件对象包含`filename`、`lineno`和`message`字段。通过这些字段，您可以准确地知道错误发生的位置。
- en: But what if you aren't getting an error, things just aren't working right? First
    of all, I recommend that you keep the code that does all of the processing for
    your worker in a separate file, like we did in `mandelbrotGenerator.js`. This
    allows you to run the code from your main thread as well as a worker. If you need
    to debug it you can run it directly from the application and debug as you normally
    would.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你没有收到错误，事情只是不正常工作呢？首先，我建议你将所有处理工作的代码放在一个单独的文件中，就像我们在`mandelbrotGenerator.js`中所做的那样。这样可以让你从主线程以及工作者中运行代码。如果需要调试，你可以直接从应用程序运行它，并像平常一样进行调试。
- en: 'One debugging trick you can use is to define a `console` object in your web
    worker that sends messages back to the main thread where they can be logged using
    the window''s console:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用的一个调试技巧是在Web工作者中定义一个`console`对象，将消息发送回主线程，然后可以使用窗口的控制台记录它们：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In your application, you then listen for the message and log it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在你的应用程序中，监听消息并记录它：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pop quiz
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: Q1\. How do you send data to a web worker?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 如何向Web工作者发送数据？
- en: You can't send data to a worker.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不能向工作线程发送数据。
- en: Using the `postMessage()` method.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`postMessage()`方法。
- en: Using the `sendData()` method.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sendData()`方法。
- en: Using the `sendMessage()` method.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sendMessage()`方法。
- en: Q2\. Which resource in the main thread does a web worker have access to?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. Web工作者在主线程中可以访问哪些资源？
- en: The DOM.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DOM。
- en: The `window` object.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`window`对象。'
- en: The `document` object.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`document`对象。'
- en: None of the above.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we created an application to draw Mandelbrot fractals to learn
    how to use HTML web workers to execute long running processes in a background
    thread. This allowed the browser to remain responsive and accept user input while
    generating the image.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个应用程序来绘制Mandelbrot分形图，以了解如何使用HTML Web工作者在后台线程中执行长时间运行的进程。这使得浏览器能够保持响应并接受用户输入，同时生成图像。
- en: 'We covered the following concepts in this chapter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了以下概念：
- en: How to use web workers to make web applications more responsive
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Web工作者使Web应用程序更具响应性
- en: How to create a web worker and start it
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建Web工作者并启动它
- en: How to send messages and data between the main thread and the web worker
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在主线程和Web工作者之间发送消息和数据
- en: How to draw a Mandelbrot using a web worker
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Web工作者绘制Mandelbrot
- en: How to catch errors thrown from a web worker
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何捕获从Web工作者抛出的错误
- en: How to debug web workers
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调试Web工作者
- en: In the next and final chapter we will learn how to prepare a web application
    for release by combining and compressing its JavaScript files. This will give
    the application a lighter network footprint. In addition we will see how to use
    the HTML5 Application Cache to cache an application so it will run even when the
    user is offline.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将学习如何通过组合和压缩其JavaScript文件来准备Web应用程序以发布。这将使应用程序在网络上的印记更轻。此外，我们将看到如何使用HTML5应用程序缓存来缓存应用程序，以便在用户离线时运行。
