- en: Chapter 7. Unobtrusive JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。不显眼的JavaScript
- en: 'In this chapter you will learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到：
- en: Writing "Hello World" unobtrusively
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不显眼地编写“Hello World”
- en: Creating a glowing "submit" button with the event listener
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件监听器创建一个发光的“submit”按钮
- en: Making a button stand out when you hover over it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您悬停在按钮上时使按钮突出显示
- en: Resizing an element with unobtrusive jQuery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不显眼的jQuery调整元素
- en: Masking a password with unobtrusive JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不显眼的JavaScript掩盖密码
- en: Using an event listener to animate an image shadow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件监听器来为图像阴影添加动画
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The concept of unobtrusive JavaScript fits right into responsive design. By
    keeping your interaction layer at an arm's length from your presentation layer,
    you can build a great degree of flexibility into your web app. Because mobile
    devices have very different input methods, you may need to call a function through
    a different event. You may want to create a desktop version of a page with JavaScript
    and use jQuery Mobile instead for your mobile version; with the same template
    files, by using unobtrusive JavaScript, this is not a difficult task.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不显眼的JavaScript的概念完全符合响应式设计。通过将交互层与演示层保持一定距离，您可以为您的Web应用程序构建很大程度的灵活性。因为移动设备有非常不同的输入方法，您可能需要通过不同的事件调用一个函数。您可能希望为页面创建一个桌面版本，并为移动版本使用jQuery
    Mobile；通过使用不显眼的JavaScript，使用相同的模板文件，这并不是一项困难的任务。
- en: Writing "Hello World" unobtrusively
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不显眼地编写“Hello World”
- en: An important facet of responsive design is interaction. As we know that mobile
    devices and desktops have very different user interfaces, we cannot expect that
    our JavaScript interaction scripts will work across all devices. An illustrative
    example is the `.mouseover()` or mouse hover event listener. The mouse is not
    attached to a touch screen device, so any misdirected attempt at the `.mouseover()`
    event would likely function as a `.click()` event. The solution to this is to
    fully remove your interaction script from your templates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式设计的一个重要方面是交互。我们知道移动设备和台式机有非常不同的用户界面，我们不能期望我们的JavaScript交互脚本能在所有设备上运行。一个例子是`.mouseover()`或鼠标悬停事件监听器。鼠标不连接到触摸屏设备上，因此任何错误的`.mouseover()`事件尝试可能会作为`.click()`事件执行。解决方法是完全从模板中移除交互脚本。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This method is referred to as "Unobtrusive JavaScript". Here, instead of embedding
    scriptlets like `onclick()` in your HTML template, you can create an external
    JavaScript that runs through a series of event listeners to set up your interaction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为“不显眼的JavaScript”。在这里，您可以通过一系列事件监听器创建一个外部JavaScript，而不是在HTML模板中嵌入`onclick()`之类的脚本。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's start with a simple example; we will create only a button and an alert.
    Many JavaScripts start as a test; in essence, I will create an event listener
    and then debug it with an alert. We start by creating an HTML page with a simple
    `submit` button.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始；我们将只创建一个按钮和一个警报。许多JavaScript都是从测试开始的；实质上，我将创建一个事件监听器，然后用警报进行调试。我们首先创建一个带有简单`submit`按钮的HTML页面。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There you go, that was a simple task, but not very exciting. That''s just a
    basic `submit` button, even though it did not submit anything. So let''s make
    this more interesting, one step at a time. Start by adding some custom text to
    the button, so that we at least have some expectation of what might happen when
    this page is ready. We add `value="Say Hello"`. That''s enough for the `body`
    tags, next we add a `script` tag to the header:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，这是一个简单的任务，但并不是很令人兴奋。那只是一个基本的`submit`按钮，即使它没有提交任何内容。所以让我们一步一步地让它变得更有趣。首先在按钮上添加一些自定义文本，这样当页面准备好时，我们至少有一些期望会发生什么。我们添加`value="Say
    Hello"`。这对于`body`标签来说已经足够了，接下来我们在头部添加一个`script`标签：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the script tags, you will need to add an event to start the JavaScript.
    The script would otherwise not run without the `$(document).ready(function(){...});`
    function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本标签内，您需要添加一个事件来启动JavaScript。否则，脚本将无法运行，没有`$(document).ready(function(){...});`函数：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside this function, replace `//do something` with a listener for the `:submit`
    button click event that fires a function to somehow put Hello World on the screen:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，用一个监听器替换`//do something`，监听`:submit`按钮的点击事件，触发一个函数，以某种方式将Hello World显示在屏幕上：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, we have created a JavaScript that loads as the page loads and listens
    for when the user clicks on the button. When the `click` event occurs, a function
    executes, but right now that function is empty. Our next task is to create the
    method of adding the "Hello World" text to the page.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个JavaScript，它在页面加载时加载，并监听用户点击按钮的事件。当`click`事件发生时，一个函数执行，但现在该函数是空的。我们的下一个任务是创建一种方法，将“Hello
    World”文本添加到页面上。
- en: 'Inside the function, we want to append the "Hello World" text to the parent
    element of the `:submit` button. Since the `:submit` button is the object from
    which the method is firing, we can reference it by using `$(this)` in jQuery.
    To attach the "Hello World" text, use the jQuery `.append()` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们希望将“Hello World”文本附加到`:submit`按钮的父元素上。由于`:submit`按钮是触发方法的对象，我们可以在jQuery中使用`$(this)`来引用它。要附加“Hello
    World”文本，使用jQuery的`.append()`方法：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The jQuery will append the "Hello World" text to the end of HTML's `body` tag.
    To have more control over where the text is appended, wrap the button in a parent
    `div` element.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery将“Hello World”文本附加到HTML的`body`标签的末尾。为了更好地控制文本的附加位置，将按钮包装在父`div`元素中。
- en: Open the HTML file in the browser and test the button's functions. If pressing
    the button does not make the text **Hello World** appear under the button, then
    something has gone wrong. Go back through the tutorial and see where you went
    astray.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开HTML文件并测试按钮的功能。如果按下按钮没有使文本**Hello World**出现在按钮下方，那么就出了问题。回到教程中看看哪里出错了。
- en: Before continuing, we can't just let the text be plain text. We want to be able
    to do more with this later. Mark it up with a paragraph tag that includes an `ID`
    attribute, `helloWorld`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们不能让文本保持原样。我们希望以后能够做更多事情。用一个包含`ID`属性`helloWorld`的段落标签标记它。
- en: At this point, we have accomplished our basic intention, to clicks a button,
    and write Hello World. That is good, but not good enough; because we always over-deliver,
    don't we?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了我们的基本意图，点击按钮，写下Hello World。这很好，但还不够好；因为我们总是要超额交付，不是吗？
- en: Outside the `.click()` event function, add a variable `foo` for the string `Hello
    World`. Next, replace the `.append(...)` function's internal Hello World text
    with the `foo` variable. Removing the text from the method and replacing it with
    a variable makes things easier to work with, and is only a small step towards
    improving this function. Refresh and test your page to make sure everything still
    works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.click()`事件函数之外，添加一个变量`foo`，表示字符串`Hello World`。接下来，用`foo`变量替换`.append(...)`函数内部的Hello
    World文本。从方法中删除文本并用变量替换它使得工作更容易，并且只是改进这个函数的一小步。刷新并测试你的页面，确保一切仍然正常。
- en: Inside the `body` tags, we are now going to personalize this page by sending
    the text to the script through a form `input` element. Inside your HTML body tags,
    enter a text `input` element with `id="bar"` and `placeholder="Enter your name"`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`body`标签内，我们现在将通过一个表单`input`元素将文本发送到脚本以个性化这个页面。在你的HTML body标签内，输入一个带有`id="bar"`和`placeholder="输入你的名字"`的文本`input`元素。
- en: 'To receive the text from our input box, we need to add a new variable bar inside
    your function. Set it equal to the value of the input:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收来自我们输入框的文本，我们需要在你的函数内添加一个新变量`bar`。将它设置为等于输入的值：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, update your `.append()` method by changing it to include `foo`, `bar`,
    and some new text, all wrapped in a styleable element:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过更改`.append()`方法来包括`foo`、`bar`和一些新文本，所有这些都包裹在一个可样式化的元素中：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, when you refresh this page, you see that the text box has been added. Try
    it out by entering your name in the input box and watch the results.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你刷新这个页面时，你会发现文本框已经添加了。尝试在输入框中输入你的名字并观察结果。
- en: This is great, but not complete. Now it's time for some cleanup. Let's go through
    some scenarios that we want to avoid. We do not want to be able to submit an empty
    input or keep adding more lines of **Hello World**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但不完整。现在是时候进行一些清理了。让我们通过一些我们想要避免的情景。我们不希望能够提交空输入或继续添加更多的**Hello World**行。
- en: First, take care of the blank input box. Let us add an `if` condition to check
    that the input text is not blank before we append it to the HTML. After the line
    that gets the input value, add a new line with the conditional statement checking
    that the variable is not a blank string. This condition wraps the `append` statement.
    Also add an `else` statement for when the input is a blank string. Inside it,
    copy the `.append()` method with text reminding the user to enter a value in the
    text input.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，处理空白输入框。让我们添加一个`if`条件来检查输入文本在附加到HTML之前是否为空。在获取输入值的行之后，添加一个新行，其中包含检查变量是否为空字符串的条件语句。这个条件包裹了`append`语句。还要为输入为空字符串时添加一个`else`语句。在其中，复制`.append()`方法，并提醒用户在文本输入中输入值的文本。
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This adds some validation to your form that will nag your user to enter your
    name if the **submit** button is clicked with a blank text box. There are two
    more clean-up items left, so hang on for a few more minutes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您的表单添加一些验证，如果单击**提交**按钮时文本框为空，它将提醒用户输入姓名。还有两个清理项目，所以再等几分钟。
- en: First, we want the appended HTML to reset each time. So add a line right after
    your `if` conditional statement and before the `else` statement, removing the
    `.newText` element added earlier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望附加的HTML每次重置。因此，在你的`if`条件语句之后，在`else`语句之前添加一行，删除之前添加的`.newText`元素。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, right before the end of the `if` conditional, reset the input form
    to have a blank value by using the `.val()` method. Also add an `ID` attribute
    to the text input to connect the value to the input.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`if`条件结束之前，使用`.val()`方法重置输入表单的值为空。还要为文本输入添加一个`ID`属性，以将值连接到输入。
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's it! We have kind of over killed it, but we have a pretty good Hello World
    web app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们有点过度了，但我们有一个相当不错的Hello World网络应用。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unobtrusive JavaScript works by loading up the script on page load and operates
    by using listeners to wait for specific events to occur on the page. This may
    be an adjustment in how you write, but then there is an advantage in being able
    to separate the interaction from the presentation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不显眼的JavaScript通过在页面加载时加载脚本，并通过使用监听器等待页面上发生特定事件来运行。这可能需要调整你的写作方式，但能够将交互与呈现分开是有优势的。
- en: Creating a glowing "submit" button with the event listener
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个发光的“提交”按钮，并添加事件监听器。
- en: Working with forms is often an overlooked aspect of most web design topics,
    even more so, responsive web design. Often non-transactional pages do not use
    forms beyond the simple **Contact Us** page, therefore the form design is often
    an afterthought. However, in the realm of transactional e-commerce and Software
    as a Service industries, forms are the most important elements the user interacts
    with. In this world, responsive design is more than just responsive layouts and
    images, it includes thoughtful interaction. In this recipe we can imagine a scenario
    where a user is at the end of a form process and is ready to submit the form.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 处理表单通常是大多数网页设计主题中被忽视的一个方面，尤其是响应式网页设计。通常非交易页面除了简单的**联系我们**页面外不使用表单，因此表单设计通常是事后想到的。然而，在交易电子商务和软件即服务行业中，表单是用户交互中最重要的元素。在这个世界中，响应式设计不仅仅是响应式布局和图片，还包括周到的交互。在这个示例中，我们可以想象一个用户处于表单流程的最后阶段，准备提交表单。
- en: It's not an uncommon occurrence to see a person rather comically click the **submit**
    button and watch the page just sit there, seemingly doing nothing (but it is actually
    performing the `post` action of the form) and react by clicking the same button
    again and again and again. In the simple **Contact Us** scenario, this could generate
    some additional form submission e-mails, but in the transactional situation, this
    could activate a long string of business logic and become disruptive to other
    processes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的情况是，一个人滑稽地点击 **submit** 按钮，然后看着页面似乎什么都没发生（但实际上是在执行表单的 `post` 操作），然后再次点击同一个按钮，一遍又一遍。在简单的
    **联系我们** 场景中，这可能会生成一些额外的表单提交电子邮件，但在交易情况下，这可能会激活一长串的业务逻辑，并对其他流程造成干扰。
- en: On the user side, there can be the idea that if nothing happens immediately
    after clicking the **submit** button, something has gone wrong and the site has
    failed; and the end result is the abandoned transaction and the damaged trust
    of your site. There are a number of things you can and should do about this. One
    of them is adding visual cues to let the user know that they have successfully
    clicked the button, and something is going to happen. Consider the transaction
    being performed behind the scenes and the time it will take. If you anticipate
    a long wait, be aware that your user might not know this. People usually expect
    that in the Internet world of instant gratification everything is instant, and
    anything that isn't instant is broken.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，有可能会有这样的想法，即在点击 **submit** 按钮后立即没有发生任何事情，说明出了问题，网站出现了故障；最终结果是放弃交易并损害了您网站的信任。您可以和应该做很多事情。其中之一是添加视觉提示，让用户知道他们已成功点击按钮，即将发生某些事情。考虑在幕后执行的交易以及所需的时间。如果您预计会有很长的等待时间，请注意您的用户可能不知道这一点。人们通常期望在互联网世界中得到即时满足，一切都是即时的，任何不是即时的东西都是有问题的。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Writing "Hello World" unobtrusively* recipe, we wrote a simple submit
    button function. We can use this as the basic building block for this recipe.
    If you do not have that code handy, you can get the finished version of it online
    at Packt Publishing's website ([http://www.packtpub.com/](http://www.packtpub.com/)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *以不显眼的方式编写 "Hello World"* 配方中，我们编写了一个简单的提交按钮函数。我们可以将其作为此配方的基本构建块。如果您没有这段代码，您可以在
    Packt Publishing 的网站上找到它的最终版本（[http://www.packtpub.com/](http://www.packtpub.com/)）。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First we need to break out the meat of the submit function into a separate
    function that is called by the `.click()` event function. Cut out everything from
    inside the function and paste it outside the `$(document).ready(function() {...});`
    function. Replace everything that you have cut out with a function call to the
    new function. In the function call, include the declared variable `foo` with the
    `ID` value of `$(this)` by the `.attr()` method. Then, wrap the code you pasted
    in a new function of the same name, and assign it to receive the two variables.
    Finally add an `ID` attribute to your submit input. Your code should look similar
    to the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将提交函数的主要部分分离出来，放到一个由 `.click()` 事件函数调用的单独函数中。将函数内部的所有内容剪切出来，粘贴到 `$(document).ready(function()
    {...});` 函数之外。用新函数的函数调用替换您剪切出的所有内容。在函数调用中，使用 `.attr()` 方法将声明的变量 `foo` 与 `$(this)`
    的 `ID` 值包含在一起。然后，将您粘贴的代码包裹在同名的新函数中，并将其分配为接收这两个变量。最后，向您的提交输入添加一个 `ID` 属性。您的代码应该类似于以下内容：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First things first, remove the `bar` variable from the `formAction()` function
    and paste it inside the `.click()` event listener function. This builds the variable
    on every click event. Now onto building new functions; add a new function to the
    JavaScript called `buttonAnimate()` and call it after the `formAction()` call
    in the `.click()` event listener. In the `buttonAnimate()` function call, send
    the `bar` variable. Finally, add the `bar` variable to the `formAction()` function
    call and the function declaration variables. The key development is that we have
    added the input value as a variable in the `.click()` event listener function
    and sent it to the two function calls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 `formAction()` 函数中移除 `bar` 变量，并将其粘贴到 `.click()` 事件监听器函数中。这样可以在每次点击事件中构建变量。现在开始构建新函数；在
    JavaScript 中添加一个名为 `buttonAnimate()` 的新函数，并在 `.click()` 事件监听器中的 `formAction()`
    调用之后调用它。在 `buttonAnimate()` 函数调用中，发送 `bar` 变量。最后，将 `bar` 变量添加到 `formAction()`
    函数调用和函数声明变量中。关键的发展是我们已经将输入值作为变量添加到了 `.click()` 事件监听器函数中，并将其发送到了两个函数调用中。
- en: With that out of the way, we can now start writing in our new function of animating
    effects on the button. Take a small break and get some coffee. We are going to
    temporarily shift gears and write some CSS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以开始编写一个新函数，用于在按钮上实现动画效果。休息一下，喝杯咖啡。我们将暂时转换方向，编写一些 CSS。
- en: Add a stylesheet to your project; inside the stylesheet, add two classes, `.valid`
    and `.invalid`, which will act on the button for its two different response states,
    `valid` and `invalid`. The `pass` scenario occurs when the text is entered into
    the form when submitted and the `fail` scenario occurs when the **submit** button
    is pressed without the text being entered in the `form` element.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将样式表添加到您的项目中；在样式表中，添加两个类，`.valid` 和 `.invalid`，它们将分别对按钮的两种不同响应状态 `valid` 和 `invalid`
    进行操作。`pass` 场景发生在提交表单时输入文本，`fail` 场景发生在在 `form` 元素中未输入文本的情况下按下 **submit** 按钮。
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `valid` state, we have submitted the form with text in the input box.
    We want to add CSS to the button that represents a positive state; the button
    has been activated, indicating that something correct has happened. I have added
    a border, shadow, text-shadow, background color, text color, and border-radius.
    This will be a sufficient indicator that something expected has happened.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `valid` 状态下，我们已经在输入框中提交了表单。我们希望为代表正面状态的按钮添加 CSS；按钮已被激活，表示发生了某些正确的事情。我添加了边框、阴影、文本阴影、背景颜色、文本颜色和边框半径。这将足以表明发生了预期的事情。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We add the same CSS style types to the `invalid` state, where the user has submitted
    the form with no text in the input box. In this instance, we want to give visual
    clues that something has gone wrong, and prompt the user for their attention to
    try again. In this scenario, orange and red are good colors to signal that an
    error has been made. In addition, we also add a CSS blur effect with a transition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将相同的CSS样式类型添加到`invalid`状态，用户在输入框中没有输入文本提交表单时。在这种情况下，我们希望给出视觉线索表明出了问题，并提示用户重新尝试。在这种情况下，橙色和红色是用来表示错误的好颜色。此外，我们还添加了一个带有过渡效果的CSS模糊效果。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is all the CSS we are going to write for this recipe. Next, we are going
    to write the JavaScript to connect the two different styles to the actual states.
    Way back earlier in this recipe, we created an empty function called `buttonAnimate()`
    that received the variable `bar`, now it's time to build that out. Inside it,
    add the same `if` conditional statement to check if `bar` is an empty string.
    If it is, add the `valid` class to the `submit` button, and if it is not, add
    the class `invalid`. This added `invalid` class alerts the user that something
    has gone awry, and an action needs to be taken.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为这个食谱要编写的所有CSS。接下来，我们将编写JavaScript来将两种不同的样式连接到实际状态。在这个食谱的早些时候，我们创建了一个名为`buttonAnimate()`的空函数，它接收了变量`bar`，现在是时候构建它了。在其中，添加相同的`if`条件语句来检查`bar`是否为空字符串。如果是，将`valid`类添加到`submit`按钮，如果不是，则添加`invalid`类。添加`invalid`类会提醒用户出现了问题，需要采取行动。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the appropriate action is taken, that is, when the user clicks on the
    form element to enter text, the button should be reset to its original state;
    technically, the new added class should be removed. That code is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当采取适当的行动时，也就是当用户点击表单元素输入文本时，按钮应该被重置为其原始状态；从技术上讲，新添加的类应该被移除。代码如下：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The final bit of cleanup left is to remove either or both classes from the beginning
    of the `if` and `else` conditions. Use the .`removeClass()` method on the `submit`
    element twice to remove the class opposite to the class to be added.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点清理工作是从`if`和`else`条件的开头删除一个或两个类。在`submit`元素上使用`.removeClass()`方法两次来删除与要添加的类相反的类。
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now reload and test out the page and see the magic you created. It will look
    like the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新加载并测试页面，看看您创建的魔法。它将看起来像下面的截图：
- en: '![How to do it...](img/5442OT_07_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5442OT_07_01.jpg)'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: jQuery is a great library that does the heavy lifting for you to create great
    web apps quickly and with very little code. In the old world of plain old JavaScript,
    this functionality would have cost you much more code and time. It has the library
    functions to read the form's values, append HTML easily, and toggle the CSS classes
    on and off. All you need is to implement some jQuery methods and CSS, and the
    rest is done for you.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个很棒的库，它可以帮助您快速创建出色的Web应用程序，而且代码很少。在旧的纯JavaScript世界中，这个功能会花费您更多的代码和时间。它有库函数来读取表单的值，轻松附加HTML，并在CSS类之间切换。您只需要实现一些jQuery方法和CSS，剩下的就交给它了。
- en: Making a button stand out when you hover over it
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你悬停在按钮上时让它突出显示
- en: Sometimes the big challenge in responsive design is being able to really over
    deliver a project when the requirements are only to build something that is just
    good enough. A button is an opportunity where you can deliver that extra level
    of polish for a product that astonishes the users. If we were not over delivering,
    we could just throw a `:hover` selector at this and be done. However, in this
    recipe, we're going to make a button that shines like a boss when you hover over
    it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，响应式设计中的一个大挑战是在要求只是构建足够好的东西时，能够真正超出交付一个项目。按钮是一个机会，您可以为令用户惊叹的产品提供额外的抛光。如果我们不是在超出交付，我们可以只是添加一个`:hover`选择器就完成了。然而，在这个食谱中，我们将制作一个在悬停时闪闪发光的按钮。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Know the pitfalls of over delivering. Giving more than asked is something we
    should all strive for, but beware of setting unreasonable expectations that you
    cannot meet, and drive an otherwise successful project into failure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 了解过度交付的缺陷。超出要求是我们都应该努力追求的，但要注意不要设定无法满足的不合理期望，从而导致本来成功的项目失败。
- en: In a previous recipe, we created a form with a button that animated when you
    clicked on it. For this recipe, you can continue working with that code. You can
    also go and download the code for that recipe, or this recipe for that matter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们创建了一个带有按钮的表单，当您点击它时会有动画效果。对于这个食谱，您可以继续使用那段代码。您也可以去下载那个食谱的代码，或者下载这个食谱的代码。
- en: Or you could just make a form and button element. It's not that hard.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以只是创建一个表单和按钮元素。这并不难。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are essentially starting with a page with two form elements; an input box
    and a submit button. As I mentioned earlier, these were built in a previous recipe;
    you could also just build them here. The JavaScript we built in the recipe will
    work with the new interaction, but is not required. The `input` element has the
    `id` attribute `fooBar`, and the button has the `id` attribute `submit`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上是从一个页面开始，有两个表单元素；一个输入框和一个提交按钮。正如我之前提到的，这些是在之前的食谱中构建的；您也可以在这里构建它们。我们在食谱中构建的JavaScript将与新的交互一起工作，但不是必需的。`input`元素具有`id`属性`fooBar`，按钮具有`id`属性`submit`。
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s start by making the default look of the button more interesting. Add
    to your CSS a style for the `input#submit` element. Inside the style, add a blue
    background color, a white font color, an 8-point border radius, a 14-pixel font
    size, and padding of 5 pixels and 8 pixels. This can be done using the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使按钮的默认外观更有趣开始。在您的CSS中为`input#submit`元素添加样式。在样式中，添加蓝色背景颜色，白色字体颜色，8点边框半径，14像素字体大小和5像素和8像素的填充。可以使用以下代码完成：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that the button's default look is defined, let's talk about the interactive
    design. Here, we get into the actual advantage of using JavaScript for a `.mouseover()`
    event instead of a CSS `:hover` selector. I would like to interact with the `form`
    element and query if text has been entered in it or not. If text is entered, we
    want a special visual cue indicating that the form is ready to be submitted; if
    no text is submitted, a strong visual cue should tell the user to stop and go
    back to check their form again.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按钮的默认外观已经定义，让我们谈谈交互设计。在这里，我们进入使用JavaScript进行`.mouseover()`事件的实际优势，而不是使用CSS的`:hover`选择器。我想与`form`元素交互，并查询是否已输入文本。如果输入了文本，我们希望有一个特殊的视觉提示，表明表单已准备好提交；如果没有提交文本，强烈的视觉提示应告诉用户停下来，返回检查他们的表单。
- en: 'First, if the form is ready to be submitted, the button will appear to extend
    out towards the mouse pointer and turn green. The CSS will include a green background
    color with the `!important` override, a box shadow, and a text-shadow. See the
    following code snippet for the exact CSS syntax:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果表单已准备好提交，按钮将似乎向鼠标指针延伸并变成绿色。CSS将包括一个绿色的背景颜色，带有`!important`覆盖，一个盒子阴影和一个文本阴影。请参阅以下代码片段，了解确切的CSS语法：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Alternately, if the form input is empty, the button will turn red and retract
    away from the mouse pointer. This CSS will have a red background color with the
    `!important` override, and inset shadow, and a text shadow that makes the text
    blurred.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果表单输入为空，按钮将变成红色，并远离鼠标指针。这个CSS将有一个红色的背景颜色，带有`!important`覆盖，和一个内阴影，以及一个使文本模糊的文本阴影。
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That''s the extent of the CSS we are creating. It''s time to build the interactivity.
    In your header, if you have not already done so, create the opening and closing
    `<script>` tags. First, we create the `(document).ready` listener:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们正在创建的CSS的范围。现在是时候构建交互性了。在您的头部，如果还没有这样做，请创建开头和结尾的`<script>`标签。首先，我们创建`(document).ready`监听器：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That does not do much, but it is a start. So let us move forward to building
    the interactivity. Inside the `(document).ready` listener function, add an event
    listener for the `.mouseover()` event and one for the `.mouseout()` event. The
    `.mouseover()` listener replaces the hover in function, and will both animate
    the button and add one of the CSS classes we built earlier, while the `.mouseout()`
    listener completes the hover out function, and will ultimately remove the `class`
    attribute of the `.mouseover()` function that was added.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有做太多事情，但这是一个开始。让我们继续构建交互性。在`(document).ready`监听器函数内部，添加一个`.mouseover()`事件监听器和一个`.mouseout()`事件监听器。`.mouseover()`监听器替换了`hover`函数，并且将同时动画按钮并添加我们之前构建的CSS类之一，而`.mouseout()`监听器完成了`hover`函数，并最终移除了`.mouseover()`函数添加的`class`属性。
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Moving forward, let us build the `.mouseover()` event listener function first.
    At its core, it performs two functions; first, it queries the value of the form
    `input` element, and then changes the `submit` button based on the value of the
    form `input` element. The first part, querying the value of the input, will look
    like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，让我们首先构建`.mouseover()`事件监听器函数。在其核心，它执行两个功能；首先，它查询表单`input`元素的值，然后根据表单`input`元素的值更改`submit`按钮。第一部分，查询输入的值，将如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first condition, when the value of the form is not an empty string, should
    create new variables, `classtoAdd = "buttonLight"` and `paddingAdd = "5px 8px
    5px 9px"`. The other condition, when the value of the form is an empty string,
    creates the same variables, `classtoAdd = "redButtonLight"` and `paddingAdd =
    "5px 9px 5px 7px"`. These will be applied to the `submit` button in the next part
    of this function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单的值不是空字符串时，第一个条件应该创建新的变量，`classtoAdd = "buttonLight"`和`paddingAdd = "5px 8px
    5px 9px"`。另一个条件，当表单的值是空字符串时，创建相同的变量，`classtoAdd = "redButtonLight"`和`paddingAdd
    = "5px 9px 5px 7px"`。这些将应用于函数的下一部分中的`submit`按钮。
- en: The next part of the function starts by animating the opacity and padding of
    the button with the `.animate()` method, and adding the class determined by the
    `classtoAdd` variable. The animation should be somewhat quick, say 100 milliseconds.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一部分是通过`.animate()`方法开始动画按钮的不透明度和填充，并添加由`classtoAdd`变量确定的类。动画应该相当快，比如100毫秒。
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That is all that is required for the `.mouseover()` event. What is needed next
    is the `.mouseout()` function's inner workings. Again, animate the `submit` button's
    `position` and `padding` attributes, but for a longer time, and then remove the
    `class` attributes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`.mouseover()`事件所需的全部内容。接下来需要的是`.mouseout()`函数的内部工作。同样，动画`submit`按钮的`position`和`padding`属性，但时间更长，然后移除`class`属性。
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And that is it. Launch the page and watch the interaction of the button. The
    following screenshot is illustrating the same:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。启动页面，观察按钮的交互。以下截图说明了同样的内容：
- en: '![How to do it...](img/5442OT_07_02.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5442OT_07_02.jpg)'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe uses event listeners to replace the simple CSS `:hover` selector
    that can only deploy with limited logic with a `.mouseover()` event listener that
    can make a query against the form `input` element to see if the form data is not
    empty. Based on the page's form state, the script can assign a different CSS class
    to the button. This adds another level of logic to the client side of the application
    and a richer interactivity to your application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用事件监听器来替换简单的CSS `:hover`选择器，后者只能使用有限的逻辑，而使用`.mouseover()`事件监听器可以针对表单`input`元素进行查询，以查看表单数据是否为空。根据页面的表单状态，脚本可以为按钮分配不同的CSS类。这为应用程序的客户端端增加了另一个逻辑层，并为您的应用程序增加了更丰富的交互性。
- en: Resizing an element with unobtrusive jQuery
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不显眼的jQuery调整元素大小
- en: The purpose of this recipe is to build a smart image element handler in your
    project. This will be a simple element that can respond to your screen size. We
    can do all this with an unobtrusive jQuery script.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的目的是在您的项目中构建一个智能图像元素处理程序。这将是一个简单的元素，可以响应您的屏幕大小。我们可以用一个不显眼的jQuery脚本来完成所有这些。
- en: In a previous recipe, we resized an image with server-side scripting using PHP.
    This recipe is going to achieve a similar result, but it will be client side instead
    of server side, and it will be for a mobile-first responsive design.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的配方中，我们使用PHP对服务器端脚本调整了图像的大小。这个配方将实现类似的结果，但是它将是客户端而不是服务器端，并且将用于移动优先响应式设计。
- en: This recipe is a good tool for mobile-first responsive design. For instance,
    if you want a scaled down image to display the loading of the document first,
    and if the screen is large, the script will replace the image with a larger version
    of the image. The unobtrusive aspect of this means that the script can easily
    be called by adding a `class` attribute to the image.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是移动优先响应式设计的一个好工具。例如，如果你想要一个缩小的图像来显示文档的加载，如果屏幕很大，脚本将用更大的图像版本替换图像。这种不显眼的特点意味着脚本可以通过向图像添加`class`属性来轻松调用。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe starts from scratch, so you won''t be required to go download anything
    to get started. You do, however, need to plug in to the jQuery libraries to make
    this work. In your header, include the path to the jQuery libraries online:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是从头开始的，所以你不需要下载任何东西就可以开始。但是，你需要连接到jQuery库才能使其工作。在你的头部，包括jQuery库在线的路径：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <img src="img/robot-small.png" class="scalable" />
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <img src="img/robot-small.png" class="scalable" />
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: div.wrap{width:75%;}
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: div.wrap{width:75%;}
- en: div.wrap div:first-child{float:left;width:50%;background-color:#ccc;}
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: div.wrap div:first-child{float:left;width:50%;background-color:#ccc;}
- en: div.wrap div:nth-child(2){float:right;width:50%;background-color:#666;}
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: div.wrap div:nth-child(2){float:right;width:50%;background-color:#666;}
- en: div.wrap div img{width:100%;height:auto;}
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: div.wrap div img{width:100%;height:auto;}
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: function replaceImage(size){...}
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: function replaceImage(size){...}
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: if (size == 'small') {…} else {…};
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: if (size == 'small') {…} else {…};
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: if($("img.scalable").attr("src").indexOf('large')>1){…}
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: if($("img.scalable").attr("src").indexOf('large')>1){…}
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: var newImageReplace = $("img.scalable").attr("src").replace("-large.", "-small.");
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: var newImageReplace = $("img.scalable").attr("src").replace("-large.", "-small.");
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: $("img.scalable").attr({src:newImageReplace});
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: $("img.scalable").attr({src:newImageReplace});
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '} else {'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: if($("img.scalable").attr("src").indexOf('small')>1){
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: if($("img.scalable").attr("src").indexOf('small')>1){
- en: var newImageReplace =    $("img.scalable").attr("src").replace("-small.", "-large.");
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: var newImageReplace =    $("img.scalable").attr("src").replace("-small.", "-large.");
- en: $("img.scalable").attr({src:newImageReplace});
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: $("img.scalable").attr({src:newImageReplace});
- en: '};'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '};'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: function measureWindow(){
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: function measureWindow(){
- en: var getWindowWidth = $(window).width();
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: var getWindowWidth = $(window).width();
- en: if (getWindowWidth < 600){
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: if (getWindowWidth < 600){
- en: replaceImage("small");
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: replaceImage("small");
- en: '} else {'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: replaceImage("large");
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: replaceImage("large");
- en: '};'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '};'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: $(document).ready(function(){
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: $(document).ready(function(){
- en: measureWindow();
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: measureWindow();
- en: '});'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: $(window).resize(function(){
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: $(window).resize(function(){
- en: measureWindow();
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: measureWindow();
- en: '});'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Masking a password with unobtrusive JavaScript
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用不显眼的JavaScript屏蔽密码
- en: The most common way to handle masking a password is to use the password type
    when creating an input element. This is the best practice when used on a desktop.
    When entering a password on a mobile device however, there is a high potential
    for input error on the device's touch input. These input errors are often not
    caught because you cannot see the encrypted text. This is a problem that the designers
    of iOS really got right. They created an input where the input text is visible
    for a short time before turning into a `*`, or changes upon entry of the next
    character.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 处理密码屏蔽的最常见方法是在创建输入元素时使用密码类型。这是在桌面上使用时的最佳实践。然而，在移动设备上输入密码时，设备的触摸输入很容易出现输入错误。这些输入错误通常不会被捕捉到，因为你看不到加密的文本。这是iOS设计者真正做对的地方。他们创建了一个输入，其中输入文本在变成`*`之前短暂可见，或者在输入下一个字符时发生变化。
- en: In this recipe, we will create a password input that mimics this solution for
    your password input.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将为您的密码输入创建一个模仿这个解决方案的密码输入。
- en: You can use this form element to mask other form entries as well. But be sure
    you understand that the underlying hidden form contains the entry to be transmitted.
    It is not encrypted unless you specify so. This only prevents the password from
    being seen visually.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用这个表单元素来屏蔽其他表单条目。但是请确保你理解，底层的隐藏表单包含要传输的条目。除非你指定，否则它不是加密的。这只是防止密码在视觉上被看到。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You don't need to get any files locally to get started. Only, in your header,
    include the link to the jQuery libraries. This will allow you to plug in to the
    jQuery libraries and use them to extend the functionality of your code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要在本地获取任何文件就可以开始。只需要在头部包括jQuery库的链接。这将允许你连接到jQuery库并使用它们来扩展你的代码的功能。
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first task is to create in your HTML body, two `input` elements. The first
    has the attributes of `type` and `ID` of the password. This will be the encrypted
    version submitted in the form, but will ultimately be hidden from view. The second
    will have the ID `altDisplay` and be disabled, so the user cannot click inside
    it. This one will be displayed on top of the other one and it will appear to be
    the one the user is typing into. At the end, we will add a style to hide the password
    field.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是在你的HTML主体中创建两个`input`元素。第一个具有密码的`type`和`ID`属性。这将是在表单中提交的加密版本，但最终将被隐藏起来。第二个将具有ID`altDisplay`并被禁用，所以用户不能在其中点击。这个将显示在另一个上面，看起来像用户正在输入的那个。最后，我们将添加一个样式来隐藏密码字段。
- en: That is all that is needed for the HTML body of the recipe, of course you can
    add other form elements as needed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是配方的HTML主体所需的一切，当然你可以根据需要添加其他表单元素。
- en: In the header, add a JavaScript `<script>` element, and inside add the jQuery
    `$(document).ready` function. Inside it, add a listener to the `#password` input
    for the `.keyup()` event. This occurs after the key is pressed down, and when
    the key is let up, the event fires.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部，添加一个JavaScript `<script>`元素，在里面添加jQuery `$(document).ready`函数。在里面，为`#password`输入添加一个`.keyup()`事件的监听器。这发生在按下键之后，当松开键时，事件触发。
- en: But there is a small bump in the road to manage before we get into the meat
    of this recipe. First, not all keys pressed enter a letter; there are *Shift*,
    *Tab*, and function keys, and then there is the *Delete* key. Each key has a numerical
    identifier, and you can find it by logging in the console `e.which`. You will
    need the numerical key identifiers to write a condition to filter out non-character
    keyup events.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们进入这个教程的实质内容之前，有一个小障碍需要解决。首先，并非所有按下的键都是字母；还有*Shift*、*Tab*和功能键，还有*Delete*键。每个键都有一个数字标识符，您可以通过在控制台中记录`e.which`来找到它。您将需要这些数字键标识符来编写一个条件来过滤掉非字符`keyup`事件。
- en: First we should make a series of `if` conditions to make sure that we are not
    getting a keystroke that is not an actual character. Inside that, create an additional
    `if` statement to check that the *Delete* (8) key was not entered. If not, we
    can proceed with the function to handle a regular character `keyup` event, otherwise
    we will need to add functionality to handle the `delete keyup` event (that will
    come later).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该制作一系列的`if`条件，以确保我们没有得到一个不是实际字符的按键。在其中，创建一个额外的`if`语句来检查*删除*（8）键是否未被输入。如果没有，我们可以继续处理常规字符`keyup`事件的功能，否则我们将需要添加功能来处理`delete
    keyup`事件（稍后会介绍）。
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the condition of a character `keyup`, we will get the current values of both
    input fields into variables `altDisplayVal` and `passwordVal`. The value present
    in the `#altDisplay` input is taken and it's values are all changed to `*` in
    a regular expression and stored in the `regAltDisplayVal` variable. The value
    in the `#password` is taken and the last letter is taken out and put into a new
    variable with the `.charAt()` method. These two new variables are added together
    to become the new value of the `#altDisplay` input.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符`keyup`的条件下，我们将获取两个输入字段的当前值，分别存入变量`altDisplayVal`和`passwordVal`中。获取`#altDisplay`输入中的值，并使用正则表达式将其所有值更改为`*`，并存储在`regAltDisplayVal`变量中。获取`#password`中的值，并取出最后一个字母放入一个新变量中，使用`.charAt()`方法。然后将这两个新变量相加，成为`#altDisplay`输入的新值。
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That handled `keyup` on a character key, next let's write functionality for
    the delete key. The delete key is different in that it removes the last character
    in the character string. To handle the delete keyup event, get the last character
    in the `#password` input with the `.charAt()` method and hold it in the `delLast`
    variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了`keyup`上的字符键，接下来让我们为删除键编写功能。删除键不同之处在于它会删除字符字符串中的最后一个字符。要处理删除键的keyup事件，请使用`.charAt()`方法获取`#password`输入中的最后一个字符，并将其保存在`delLast`变量中。
- en: Then use the `.slice()` method to first get through the next-to-last characters
    for the `delTxt` variable. Use a regular expression to change the characters into
    `*` and store them in the `regDelTxt` variable. Finally, add the `regDelTxt` and
    `delLast` variables to make the new value of the `#altDisplay` input element.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`.slice()`方法首先获取`delTxt`变量的倒数第二个字符。使用正则表达式将字符更改为`*`并将它们存储在`regDelTxt`变量中。最后，将`regDelTxt`和`delLast`变量添加到`#altDisplay`输入元素的新值中。
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And that takes care of the JavaScript. You can now launch the page and see
    both the input elements on the page. Enter the text in the first input element,
    and then it will enter into the second as `*`. Now the only problem is that having
    two side-by-side form elements in the page does not make this an iOS style password
    element. To make it really work, we need to overlay the `#password` input over
    `#altDisplay` and make it invisible. You can do this with some CSS, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，JavaScript部分已经完成。您现在可以启动页面，看到页面上的两个输入元素。在第一个输入元素中输入文本，然后它将作为`*`输入到第二个输入元素中。现在唯一的问题是，在页面上有两个并排的表单元素并不会使其成为iOS风格的密码元素。要使其真正起作用，我们需要将`#password`输入覆盖在`#altDisplay`上并使其不可见。您可以通过一些CSS来实现这一点，如下所示：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There, try that. On refreshing your screen, you will see only one input element.
    When you enter text into it, it transforms into stars.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，试试看。刷新屏幕后，您将只看到一个输入元素。当您在其中输入文本时，它会变成星号。
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This does not actually change the input submitted; it only hides it, and translates
    the values in the hidden field into star characters. It should be a good mimic
    of the iOS password entry.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不改变提交的输入；它只是隐藏它，并将隐藏字段中的值转换为星号字符。这应该是iOS密码输入的一个很好的模仿。
- en: Using an event listener to animate an image shadow
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件侦听器来为图像阴影添加动画
- en: Since this is the last recipe, it should be a fun recipe. This one takes a responsive
    image, like the one we built back in [Chapter 1](ch01.html "Chapter 1. Responsive
    Elements and Media"), *Responsive Elements and Media*, and uses jQuery event listeners
    and CSS3 to animate a shadow to follow your cursor.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是最后一个教程，它应该是一个有趣的教程。这个教程会使用jQuery事件监听器和CSS3来使阴影随着鼠标移动而动。
- en: This is a simple recipe, but it still works in a responsive way. The image will
    respond to the page width, while the jQuery is written such that it still measures
    the image position and mouse position on every mouse movement.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的教程，但它仍然以响应的方式工作。图像将响应页面宽度，而jQuery是这样编写的，以至于它仍然在每次鼠标移动时测量图像位置和鼠标位置。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe needs you to work with jQuery. So in the header of your new file,
    add a link to the jQuery libraries. Other than that, you are ready to go.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程需要您使用jQuery。因此，在新文件的头部，添加一个指向jQuery库的链接。除此之外，您已经准备好了。
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, create the body of your HTML file using a div element with the class
    `wrap`. Inside it, add an image with the class `topRight`. Next up; the CSS.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用一个带有类`wrap`的div元素创建HTML文件的主体。在其中，添加一个带有类`topRight`的图像。接下来是CSS。
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add a section for the CSS. First, add a `text-align: center` style to the body.
    Next, give the `.wrap` div element a width of `30%`, and an automatic horizontal
    width. This is shown in the following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '添加CSS部分。首先，为body添加`text-align: center`样式。接下来，给`.wrap` div元素一个宽度为`30%`，并自动水平宽度。代码片段如下所示：'
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The next set of CSS is varying the image class variations that will be assigned
    by the jQuery script depending on the mouse position. Each contains a differently
    angled `box-shadow`. Name the different classes `topLeft`, `topRight`, `bottomLeft`,
    and `bottomRight`. Each will have a shadow offset of `5` pixels, a spread of `2`
    pixels, and blur radius of `2` pixels.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组CSS是根据鼠标位置由jQuery脚本分配的图像类变化。每个都包含一个不同角度的`box-shadow`。命名不同的类`topLeft`，`topRight`，`bottomLeft`和`bottomRight`。每个都将具有`5`像素的阴影偏移，`2`像素的扩展和`2`像素的模糊半径。
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Excellent work so far. Now it is time to build the JavaScript. Inside your `script`
    tag, create the standard `$(document).ready` event function. Then, to start add
    a `.mousemove()` event listener function to the body. Inside it, create two new
    variables `imgHorz` and `imgVert` for the horizontal and vertical positions of
    the `.wrap img` div element.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，工作得非常出色。现在是构建JavaScript的时候了。在您的`script`标签内部，创建标准的`$(document).ready`事件函数。然后，开始添加一个`.mousemove()`事件监听器函数到body。在其中，为`.wrap
    img` div元素的水平和垂直位置创建两个新变量`imgHorz`和`imgVert`。
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, after the variables have been created, we create some conditions based
    on the variable values compared to the position of the mouse at the time of the
    event. If the results are true, then remove all CSS classes before adding one
    of the image classes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在创建了变量之后，我们根据变量值与事件发生时鼠标位置的比较创建一些条件。如果结果为真，则在添加图像类之前删除所有CSS类。
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then you will want to add three additional `else`/`if` conditions to add the
    other classes. The following code snippet shows the four conditions displayed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将希望添加三个额外的`else`/`if`条件来添加其他类。以下代码片段显示了显示的四个条件：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And that wraps up the JavaScript.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们结束了JavaScript。
- en: One last thing, we also need to animate the transition between CSS styles. So,
    instead of adding more JavaScript, add a CSS transition to the `.wrap img` element
    (each browser needs its own transition command).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事，我们还需要对CSS样式之间的过渡进行动画处理。因此，不要添加更多的JavaScript，而是将CSS过渡添加到`.wrap img`元素（每个浏览器都需要自己的过渡命令）。
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That was a fairly simple recipe, and the end result is a fun image element
    where the shadow follows the mouse around. The following screenshot is an illustration
    of this recipe:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的配方，最终结果是一个有趣的图像元素，其中阴影跟随鼠标移动。以下截图是这个配方的示例：
- en: '![How to do it...](img/5442OT_07_6_event_listener_animate_image_shadow.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5442OT_07_6_event_listener_animate_image_shadow.jpg)'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe measures the location of the image and the mouse on every `.mousemove()`
    event. The result of each is that a new shadow is applied to the object. Now it
    is important to think about what events are appropriate for mobile devices versus
    desktops. A `.mousemove()` event won't work as there is no mouse attached to a
    mobile device. From here, I would refer to [Chapter 5](ch05.html "Chapter 5. Making
    Mobile-first Web Applications"), *Making Mobile-first Web Applications*, for a
    refresher on how to load JavaScripts such as jQuery Mobile for mobile devices.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方在每个`.mousemove()`事件上测量图像和鼠标的位置。每次事件的结果是将新的阴影应用于对象。现在重要的是要考虑哪些事件适合移动设备，哪些适合桌面设备。`.mousemove()`事件不起作用，因为移动设备上没有鼠标。从这里开始，我会参考[第5章](ch05.html
    "第5章。制作移动优先的Web应用程序")，“制作移动优先的Web应用程序”，以便在移动设备上加载jQuery Mobile等JavaScript的复习。
- en: We built simple UI interactions using unobtrusive JavaScript. I hope that these
    simple scripts are not only useful examples that you could actually use in a project,
    but they also demonstrate effectively how to write JavaScript that could live
    outside of your template files. This fits into your responsive design when you
    pair it with mobile versions of the script that can be called to the mobile devices.
    Going forward, this will help you create more responsive and fluidly transitioning
    web projects.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不显眼的JavaScript构建了简单的UI交互。我希望这些简单的脚本不仅是您可以在项目中实际使用的有用示例，而且还有效地演示了如何编写可以存在于模板文件之外的JavaScript。当您将其与可以调用到移动设备的脚本的移动版本配对时，这将符合您的响应式设计。未来，这将帮助您创建更具响应性和流畅过渡的网络项目。
- en: Live long and prosper, my friends.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 愿你们长寿而繁荣。
