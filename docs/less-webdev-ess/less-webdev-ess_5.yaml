- en: Chapter 5. Integrate Less in Your Own Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 将Less集成到你自己的项目中
- en: Now it's time to integrate *Less* in your workflow and projects. In this chapter,
    you will learn to migrate your current projects or start a new project from scratch
    using *Less*. The techniques and tools to convert your CSS code to *Less* code
    will be discussed, and finally, you will learn to build and use responsive grids
    with *Less*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将*Less*集成到你的工作流程和项目中了。在本章中，你将学会迁移你当前的项目或从头开始使用*Less*。将讨论将你的CSS代码转换为*Less*代码的技术和工具，最后，你将学会使用*Less*构建和使用响应式网格。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Importing CSS into *Less*
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CSS导入到*Less*中
- en: Migrating your projects to *Less*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的项目迁移到*Less*
- en: Starting a project from scratch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始一个项目
- en: Media queries and responsive design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体查询和响应式设计
- en: Using grids in your projects and designs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的项目和设计中使用网格
- en: While working with *Less* and seeing how it addresses the problems of duplicate
    code and the inability to reuse your CSS, you should have wondered when to start
    using *Less* for your projects. Although this may be the most important question
    of this book, the answer is quite simple. You will have to start *now*! The problems
    with CSS can be some defects in your **design process**. There will never be an
    excuse to not solve the defects as soon as they are detected. If you don't start
    now, you probably never will, and you will end up spending too much time debugging
    your CSS code instead of working on your real design tasks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*Less*并看到它如何解决重复代码和无法重用CSS的问题时，你可能会想知道何时开始在项目中使用*Less*。尽管这可能是本书中最重要的问题，答案却很简单。你将不得不立刻开始！CSS的问题可能是你**设计过程**中的一些缺陷。一旦检测到缺陷，就没有理由不立即解决它们。如果你现在不开始，你可能永远不会开始，最终你将花费太多时间调试你的CSS代码，而不是在真正的设计任务上工作。
- en: Importing CSS into Less
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将CSS导入到Less中
- en: As you already know now, valid CSS is also valid *Less* code. CSS code can be
    imported into *Less*. There are different ways to do this. After importing your
    CSS, you can run the result through the compiler. This offers you an easy way
    to start using *Less* in your current project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在已经知道的那样，有效的CSS也是有效的*Less*代码。CSS代码可以被导入到*Less*中。有不同的方法来做到这一点。在导入你的CSS之后，你可以通过编译器运行结果。这为你提供了一个在当前项目中开始使用*Less*的简单方法。
- en: Consider creating a **style guide** before starting to import your CSS code.
    Style guides help you test your code, as described in [Chapter 4](ch04.html "Chapter 4. Avoid
    Reinventing the Wheel"), *Avoid Reinventing the Wheel*. Also, remember that *Less*
    is a **CSS preprocessor**. This means you have to compile your *Less* code into
    CSS before taking it into production. Client-side compiling with `less.js` should
    only be used for test purposes! Only importing your CSS and compiling it back
    into CSS again makes no sense. After importing, you should start improving your
    code. Importing CSS also offers the opportunity to combine the pre-existing CSS
    with newly written *Less* code and allows you to do the conversion to *Less* iteratively
    and gradually.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始导入你的CSS代码之前，考虑创建一个**样式指南**。样式指南有助于测试你的代码，如[第4章](ch04.html "第4章 避免重复造轮子")中所述，*避免重复造轮子*。还要记住，*Less*是一个**CSS预处理器**。这意味着你必须在将*Less*代码投入生产之前将其编译成CSS。客户端编译只应用于测试目的！只是导入你的CSS并将其重新编译成CSS是没有意义的。导入CSS还提供了将现有CSS与新编写的*Less*代码结合以及逐步进行*Less*转换的机会。
- en: Using the @import rule
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@import规则
- en: Earlier, you saw that the `@import` rule in *Less* is used to import *Less*
    files into your project. This rule in *Less* is an extended version of the same
    rule in CSS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你已经看到*Less*中的`@import`规则用于将*Less*文件导入到你的项目中。*Less*中的这个规则是CSS中相同规则的扩展版本。
- en: 'In the examples in the preceding chapters, the `@import` rule was only used
    to import *Less* files. By default, each file is imported once. The complete syntax
    is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前章节的示例中，`@import`规则只用于导入*Less*文件。默认情况下，每个文件只被导入一次。完整的语法如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are six keywords that can be used with this rule: `reference`, `inline`,
    `less`, `css`, `once`, and `multiple`. The `reference` keyword, for example, `@import
    (reference) "file.less"`, will make mixins and classes from `file.less` available,
    without compiling them into the resulting CSS.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个关键字可以与这个规则一起使用：`reference`，`inline`，`less`，`css`，`once`和`multiple`。例如，`@import
    (reference) "file.less"`中的`reference`关键字将使`file.less`中的mixin和类可用，而不会将它们编译到生成的CSS中。
- en: 'This can easily be shown with an example. You can download all the example
    code of all the chapters of this book from the Packt website ([www.packtpub.com](http://www.packtpub.com)).
    The example layout from the preceding chapters will be used here again. Please
    remember that the main file of this project, `styles.less`, imports the other
    project files. Now you can use this to reuse the navbar. Start by creating a new
    file and write the following code into it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地通过一个例子来展示。你可以从Packt网站([www.packtpub.com](http://www.packtpub.com))下载本书所有章节的示例代码。之前章节的示例布局将在这里再次使用。请记住，这个项目的主文件`styles.less`导入了其他项目文件。现在你可以使用它来重用导航栏。首先创建一个新文件，并将以下代码写入其中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These two lines will compile into the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行将编译成以下代码：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Please also notice that the preceding result contains the values as defined
    in `variables.less` from the original project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，前面的结果包含了原始项目中`variables.less`中定义的值。
- en: 'The `inline` keyword is used to import code that is not compatible with *Less*.
    Although *Less* accepts standard CSS, comments and hacks won''t get compiled sometimes.
    Use the `inline` keyword to import the CSS as it is into the output. As shown
    in the following code, the `inline` keyword differs quite a bit from the `css`
    keyword. The `less` keyword forces the imported code to be compiled. When using
    `@import (less) "styles.css"`, all code will be compiled as usual. In the meantime,
    the `css` keyword forces `@import` to act as a normal CSS import. The following
    code shows the difference between `inline` and `css`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline`关键字用于导入与*Less*不兼容的代码。虽然*Less*接受标准CSS，但有时注释和hack不会被编译。使用`inline`关键字将CSS按原样导入输出。如下面的代码所示，`inline`关键字与`css`关键字有很大的不同。`less`关键字强制导入的代码被编译。使用`@import
    (less) "styles.css"`时，所有代码将像往常一样被编译。与此同时，`css`关键字强制`@import`作为普通的CSS导入。下面的代码显示了`inline`和`css`之间的区别：'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Imported style sheets (with `@import`) in your compiled CSS code are declared
    before all the other rules. These style sheets can play a role in the **CSS precedence**,
    which is discussed in [Chapter 1](ch01.html "Chapter 1. Improving Web Development
    with Less"), *Improving Web Development with Less*. For this reason, you cannot
    apply advanced techniques such as namespacing, and you should import files that
    are not created using *Less* at the beginning.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译的CSS代码中，使用`@import`导入的样式表在所有其他规则之前声明。这些样式表可以在**CSS优先级**中发挥作用，这在[第1章](ch01.html
    "第1章。使用Less改进Web开发")中有所讨论，*使用Less改进Web开发*。因此，您不能应用高级技术，如命名空间，应该在开始时导入未使用*Less*创建的文件。
- en: 'CSS 2.1 user agents must ignore any `@import` rule that is present inside a
    block or after any nonignored statement, other than `@charset` or `@import` ([http://www.w3.org/TR/CSS21/syndata.html#at-rules](http://www.w3.org/TR/CSS21/syndata.html#at-rules)).
    If you import a file with the same name twice, only one will be compiled by default.
    The same will happen if you use the `once` keyword; on the other hand, if you
    use the `multiple` keyword, the file will be compiled in the output twice. The
    following code will give you an example of multiple output when using the `multiple`
    keyword:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 2.1用户代理必须忽略任何出现在块内或在任何非忽略语句之后的`@import`规则，除了`@charset`或`@import`（[http://www.w3.org/TR/CSS21/syndata.html#at-rules](http://www.w3.org/TR/CSS21/syndata.html#at-rules)）。如果导入具有相同名称的文件两次，默认只会编译一个。如果使用`once`关键字，也会发生相同的情况；另一方面，如果使用`multiple`关键字，文件将在输出中被编译两次。下面的代码将为您演示使用`multiple`关键字时的多重输出的示例：
- en: 'If the `styles.less` file contains the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`styles.less`文件包含以下代码：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And your *Less* code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您的*Less*代码如下：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code will output the following CSS code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将输出以下CSS代码：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Migrating your project
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移您的项目
- en: With the different import rules, you can start using Less in your project without
    having to change your code. After importing your CSS, you can start defining variables
    and using mixins step by step. Always check the output of your new code before
    you start using it for production.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的导入规则，您可以在项目中开始使用Less而无需更改代码。导入CSS后，您可以逐步开始定义变量和使用混合。在开始将其用于生产之前，始终检查新代码的输出。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please remember that style guides can help you manage the migration of your
    project, and also don't forget that you have to compile your *Less* on the server
    side into CSS code before using it in production.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，样式指南可以帮助您管理项目的迁移，也不要忘记在生产环境中使用*Less*之前，在服务器端将其编译为CSS代码。
- en: Organizing your files
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织您的文件
- en: 'Try to organize your files in the same way as in the preceding examples. Create
    separate files for your project''s variables and mixins. If your project defined
    a style sheet in `project.css` earlier, your main *Less* file can look, for instance,
    like the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以与前面示例相同的方式组织您的文件。为项目的变量和混合创建单独的文件。如果您的项目之前在`project.css`中定义了样式表，您的主*Less*文件可能如下所示：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will import your original `project.css` in the preceding code; alternatively,
    you can rename it as `project.less`. Also notice that you will finally compile
    a new CSS file, which will be used in your project. It's possible to use the same
    name for this file; make sure that you do not overwrite your original CSS file.
    Although your new CSS files should apply the same styles, these files are better
    organized and *Less* grantees they contain only valid CSS. The compiler will also
    compress the CSS file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您将导入原始的`project.css`；或者，您可以将其重命名为`project.less`。还要注意，您最终将编译一个新的CSS文件，该文件将用于您的项目。可以使用相同的名称来命名此文件；确保不要覆盖原始的CSS文件。虽然新的CSS文件应用相同的样式，但这些文件更有组织性，*Less*保证它们只包含有效的CSS。编译器还将压缩CSS文件。
- en: Converting CSS code to Less code
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将CSS代码转换为Less代码
- en: In the process of **migration**, you may prefer to not have to convert your
    code step by step. There are some tools available that can convert CSS code to
    *Less* code. These tools should be used with care. **Lessify** helps you organize
    your CSS code into *Less* code. Lessify puts rules for the same element or class
    together. You can use Lessify by visiting [http://leafo.net/lessphp/lessify/](http://leafo.net/lessphp/lessify/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在**迁移**过程中，您可能更喜欢不必一步一步地转换代码。有一些可用的工具可以将CSS代码转换为*Less*代码。这些工具应该谨慎使用。**Lessify**可以帮助您将CSS代码组织成*Less*代码。Lessify将相同元素或类的规则放在一起。您可以通过访问[http://leafo.net/lessphp/lessify/](http://leafo.net/lessphp/lessify/)来使用Lessify。
- en: 'Consider the following CSS code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下CSS代码：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After using Lessify, the preceding CSS code compiles into the following *Less*
    code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lessify后，前面的CSS代码编译成以下*Less*代码：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can find another tool called CSS2Less at [http://css2less.cc/](http://css2less.cc/).
    Also, this tool only groups class and element rules. Lessify and Css2Less can
    help you a little when organizing your styles. Neither tool works with **media
    queries**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://css2less.cc/](http://css2less.cc/)找到另一个工具叫做CSS2Less。此外，这个工具只会分组类和元素规则。Lessify和Css2Less在组织你的样式时可能会有所帮助。这两个工具都不支持**媒体查询**。
- en: From all that you have learned so far, it seems like a good practice to start
    your project by developing your *Less* code. So, start your project by building
    a style guide using *Less*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从迄今为止学到的所有知识来看，通过开发你的*Less*代码来开始项目似乎是一个不错的做法。因此，通过使用*Less*构建样式指南来开始你的项目。
- en: 'Your `project.less` file can look like the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`project.less`文件可能如下所示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Integrate the `project.less` file with the client side `less.js` compiler into
    your style guide. After this, start adding your design elements or alternatively,
    add comments in your code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将`project.less`文件与客户端`less.js`编译器集成到你的样式指南中。之后，开始添加你的设计元素，或者在你的代码中添加注释。
- en: When you are done with your style guide, you can start building your final HTML
    code. If you have to build a responsive website, you should first determine which
    **screen sizes** you will need. For instance, mobile, tablet, and desktop can
    be a good choice.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成了你的样式指南，你可以开始构建最终的HTML代码。如果你要构建一个响应式网站，你应该首先确定你将需要哪些**屏幕尺寸**。例如，移动设备、平板和台式机可能是一个不错的选择。
- en: To better understand how you can use *Less* in this stage of your process, the
    following two sections describe the role of **CSS media queries** in responsive
    design and teach you how to use **grids**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解在流程的这个阶段如何使用*Less*，以下两个部分描述了**CSS媒体查询**在响应式设计中的作用，并教你如何使用**网格**。
- en: Media queries and responsive design
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体查询和响应式设计
- en: Media queries is a CSS3 module and is a W3C candidate recommendation since June
    2012\. Media queries add the possibility of applying a style sheet to CSS only
    when a media query evaluates as true. A media query evaluates the device's type
    and device's features. The device's types are screen, speech, and print, among
    others, and the features are width, **device-width**, and resolution, among others.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询是CSS3模块，自2012年6月以来一直是W3C的候选推荐。媒体查询增加了在媒体查询评估为true时仅将样式表应用于CSS的可能性。媒体查询评估设备的类型和设备的特性。设备的类型有屏幕、语音和打印等，特性有宽度、**设备宽度**和分辨率等。
- en: Nowadays, the screen type and device's width play an important role in responsive
    web design. With the use of media queries, someone can restrict CSS rules to a
    specified screen width and thus change the representation of a website with varying
    screen resolutions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，屏幕类型和设备宽度在响应式网页设计中扮演着重要的角色。通过使用媒体查询，可以将CSS规则限制在指定的屏幕宽度上，从而根据不同的屏幕分辨率改变网站的呈现方式。
- en: 'A typical media query will look like the following line of code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的媒体查询看起来像下面的代码行：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For instance, the following media query sets the font color to black when the
    viewport''s width is larger than 767 pixels:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下媒体查询在视口宽度大于767像素时将字体颜色设置为黑色：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we can see that all the style rules between the accolades
    are only applied if the screen width is 768 pixels or larger. These style rules
    will follow the normal **cascading rules**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以看到花括号之间的所有样式规则只有在屏幕宽度大于768像素时才会应用。这些样式规则将遵循正常的**级联规则**。
- en: Making your layout fluid
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使你的布局流动
- en: Until now, your layout has had a fixed width defined by `@basic-width`. A fluid
    design defines its widths as a percentage of the viewport or browser window.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的布局一直由`@basic-width`定义的固定宽度。流动设计将其宽度定义为视口或浏览器窗口宽度的百分比。
- en: 'To make your layout fluid, define `@basic-width: 900px;` in `less/responsive/project.less`.
    This set value will not define the width of your design any more but will only
    set the `max-width` variable after your changes.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '为了使你的布局流动，定义`@basic-width: 900px;`在`less/responsive/project.less`中。这个设定值不再定义你设计的宽度，而是在你的改变后只设置`max-width`变量。'
- en: After this, open `less/responsive/mixinsresponsive.less` in the `.center-content()`
    mixin and change `width:@basic-width;` to `max-width:@basic-width;`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，打开`.center-content()` mixin中的`less/responsive/mixinsresponsive.less`，将`width:@basic-width;`改为`max-width:@basic-width;`。
- en: The header is now fluid, without any further changes. The footer columns are
    also based on `@basic-width`, so you will have to change them too.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 页眉现在是流动的，无需进一步更改。页脚列也是基于`@basic-width`的，所以你也需要对它们进行更改。
- en: 'The width of the footer columns is set by the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 页脚列的宽度由以下代码设置：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Please change the width of the footer columns in `less/responsive/footer.less`
    using the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用以下代码在`less/responsive/footer.less`中更改页脚列的宽度：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Browser support for the `calc()` function can be checked by visiting [http://caniuse.com/#feat=calc](http://caniuse.com/#feat=calc).
    Also remember the note on `calc()` and the use of **string interpolation** from
    [Chapter 1](ch01.html "Chapter 1. Improving Web Development with Less"), *Improving
    Web Development with Less*. *Less* code is stateless, so these width calculations
    should be done by CSS in the browser. The browser has the real width in pixels
    the moment the CSS has been loaded, so the browser can calculate the column width
    in pixels and render it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过访问[http://caniuse.com/#feat=calc](http://caniuse.com/#feat=calc)来检查`calc()`函数的浏览器支持情况。还要记住[第1章](ch01.html
    "第1章。使用Less改进Web开发")中关于`calc()`和**字符串插值**的说明，*使用Less改进Web开发*。*Less*代码是无状态的，因此这些宽度计算应该由浏览器中的CSS完成。一旦CSS加载完成，浏览器就有了真实的像素宽度，因此浏览器可以计算并呈现列的宽度。
- en: Finally, you will have to change `less/contentresponsive.less` and add the media
    queries to it. If the screen width is smaller than 500 pixels, the navigation
    and content should stack in your layout.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将需要改变`less/contentresponsive.less`并在其中添加媒体查询。如果屏幕宽度小于500像素，导航和内容应该在你的布局中堆叠。
- en: 'First, make `#content` and `#sidebar` fluid by setting their width to `width:
    2 / 3 * 100%;` and `width: 1/ 3 * 100%;`, respectively. Now, the width is fluid
    and you can add the media queries. For `#content`, you should change the code
    into the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，通过将宽度设置为`width: 2 / 3 * 100%;`和`width: 1/ 3 * 100%;`，使`#content`和`#sidebar`变为流体。现在，宽度是流体的，您可以添加媒体查询。对于`#content`，您应该将代码更改为以下代码：'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code sets the width of `#content` to `100%` if the screen width
    is less than 500 pixels. It also removes the float of the element. You should
    do the same for `#sidebar`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码如果屏幕宽度小于500像素，则将`#content`的宽度设置为`100%`。它还会删除元素的浮动。您应该对`#sidebar`做同样的操作。
- en: After these changes for a screen width of 500 pixels, the navigation stacks
    below the content.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些更改后，屏幕宽度为500像素时，导航将堆叠在内容下方。
- en: 'How to interchange the position of the navigation and content for a screen
    with a screen width less than 500 pixels can be seen at `http://localhost/indexresponsivechange.html`.
    You can accomplish this in two steps. First, interchange the content of `#content`
    and `#sidebar` inside your HTML document. Open `http://localhost/indexresponsivechange.html`
    and compare the source code with `http://localhost/indexresponsive.html`. After
    these changes, the sidebar will show on the left-hand side of the screen. To move
    the sidebar to the right, you should set its float to `right` instead of `left`,
    as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在屏幕宽度小于500像素的屏幕上交换导航和内容的位置，可以在`http://localhost/indexresponsivechange.html`中看到。您可以通过两个步骤完成这个过程。首先，在HTML文档中交换`#content`和`#sidebar`的内容。打开`http://localhost/indexresponsivechange.html`，并将源代码与`http://localhost/indexresponsive.html`进行比较。进行这些更改后，侧边栏将显示在屏幕的左侧。要将侧边栏移动到右侧，您应该将其浮动设置为`right`而不是`left`，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On a small screen, the layout will now look like the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在小屏幕上，布局现在看起来像以下的截图：
- en: '![Making your layout fluid](img/1465OS_05_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使您的布局流动](img/1465OS_05_01.jpg)'
- en: An example of how your layout could look on a mobile phone
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在手机上您的布局可能会是这样的一个例子
- en: Testing your layouts on a mobile phone
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在手机上测试您的布局
- en: 'You will surely check your responsive layout on your mobile phone too. Make
    sure that you add the following additional line of code in the head of your HTML
    document:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您肯定也会在手机上检查响应式布局。确保在HTML文档的头部添加以下额外的代码行：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code forces the mobile browser to load your website in a viewport
    that is equal to the screen width of your device. By default, mobile browsers
    load websites in a viewport that is larger than the screen size. Doing this lets
    nonmobile websites load as intended on a big screen. After loading the website,
    it's up to the user to scroll and zoom into the results. If your optimized mobile
    layout loads in a viewport with a width larger than 500 pixels, the media queries
    won't work, forcing the viewport to the device's screen dimensions, preventing
    the media query from not being applied. Note that this also means you will have
    to test this example with a mobile phone for which the screen is not wider than
    500 pixels. You can also test your designs on websites such as [http://www.responsinator.com/](http://www.responsinator.com/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码强制移动浏览器在视口中加载您的网站，该视口等于设备的屏幕宽度。默认情况下，移动浏览器会在比屏幕尺寸更大的视口中加载网站。这样做可以让非移动网站在大屏幕上按预期加载。加载网站后，用户可以滚动和放大结果。如果您优化的移动布局在宽度大于500像素的视口中加载，媒体查询将无法工作，强制视口调整为设备的屏幕尺寸，从而防止媒体查询不被应用。请注意，这也意味着您将不得不使用屏幕宽度不超过500像素的手机测试此示例。您还可以在[http://www.responsinator.com/](http://www.responsinator.com/)等网站上测试您的设计。
- en: Coding first for mobile
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首先为移动设备编码
- en: 'Nowadays, it''s common to write the styles for mobile devices first and then
    use media queries to alter them to fit bigger screens. Examples of the mobile-first
    principle of coding can be found in `header.less` and `content.less` from the
    files of your example layout. Also open `less/responsive/footer.less` and see
    how the media query adds the float:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，先为移动设备编写样式，然后使用媒体查询来调整它们以适应更大的屏幕是很常见的。您可以在示例布局的文件`header.less`和`content.less`中找到编码的移动设备优先原则的示例。还可以打开`less/responsive/footer.less`，看看媒体查询如何添加浮动：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This example shows a **mobile first** way of coding. Elements stack by default
    and become horizontal when the screen size grows. Notice that older browsers such
    as Internet Explorer 8 do not support media queries and will always show you the
    stacked version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一种**移动设备优先**的编码方式。元素默认堆叠，并在屏幕尺寸增大时变为水平。请注意，诸如Internet Explorer 8之类的旧版浏览器不支持媒体查询，并且始终会显示堆叠版本。
- en: Using grids in your designs and work flow
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的设计和工作流程中使用网格
- en: The preceding media query example did not use a grid. You may be wondering what
    a grid is and why you should use it. **Grid-based layouts** divide your design
    into a collection of equal-sized columns and rows. Content and graphical elements
    can be organized according to this layout. Grids help in creating a logical and
    formal structure for designs. It prevents inconsistencies between the original
    design and the final implementation in HTML as designers and developers work with
    the same grid.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的媒体查询示例没有使用网格。您可能想知道什么是网格，以及为什么应该使用它。**基于网格的布局**将设计分成一系列大小相等的列和行。内容和图形元素可以根据此布局进行组织。网格有助于为设计创建逻辑和正式的结构。它可以防止原始设计与HTML中最终实现之间的不一致，因为设计师和开发人员使用相同的网格。
- en: Grids are also helpful in responsive design, because the grid's columns can
    easily be rearranged to fit different screen widths.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 网格在响应式设计中也很有帮助，因为网格的列可以轻松重新排列以适应不同的屏幕宽度。
- en: In the preliminary chapters of this book you already read about CSS modules
    that defined layout structures. Flex boxes and columns can be used to define CSS
    layouts and grids. Although these layouts are responsive by default or can easily
    be defined as responsive, they are not the common way to define your CSS layouts
    yet. As mentioned earlier, most modern browsers are not ready to support these
    modules. Luckily, there are alternative ways to define a grid with CSS.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的初步章节中，您已经了解了定义布局结构的CSS模块。Flex boxes和columns可以用来定义CSS布局和网格。尽管这些布局默认情况下是响应式的，或者可以很容易地定义为响应式，但它们还不是定义CSS布局的常用方式。如前所述，大多数现代浏览器尚未准备支持这些模块。幸运的是，有其他方法可以使用CSS定义网格。
- en: The width of the columns of your grid can be defined as a percentage of the
    grid or a fixed width. Fluid grids define their widths as a percentage of the
    viewport. In fluid grids, the column widths vary with the screen width. Fluid
    layouts can rearrange the content to occupy the available screen width, so the
    user has to scroll less. On the other hand, designers have less control over the
    exact representation of the design. For this reason, the majority of responsive
    grids are a hybrid of fluid and fixed grids.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的列宽可以定义为网格的百分比或固定宽度。流体网格将其宽度定义为视口的百分比。在流体网格中，列宽随屏幕宽度变化。流体布局可以重新排列内容以占用可用的屏幕宽度，因此用户需要滚动的次数更少。另一方面，设计师对设计的精确表示没有太多控制。因此，大多数响应式网格是流体和固定网格的混合体。
- en: The role of CSS float in grids
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格中CSS浮动的作用
- en: The CSS `float` property is a position property in CSS; the float pushes the
    elements to the left (or right) side of the screen and allows other elements to
    wrap around it. For this reason, CSS `float` plays an important role in most **CSS
    grids**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CSS的`float`属性是CSS中的一个位置属性；浮动将元素推到屏幕的左侧（或右侧），并允许其他元素围绕它包裹。因此，CSS的`float`在大多数**CSS网格**中起着重要作用。
- en: 'An example will help you understand how this works. You will create a grid
    with two columns. Start writing the *Less* code for a fixed grid. The example
    is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例将帮助您了解这是如何工作的。您将创建一个具有两列的网格。开始编写固定网格的*Less*代码。示例如下：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can use the compiled CSS of the preceding code with the following HTML
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上述代码的编译CSS和以下HTML代码：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can inspect the result of the preceding code by visiting `http://localhost/grid.html`
    from the downloadable example code of this book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问本书可下载示例代码中的`http://localhost/grid.html`来检查上述代码的结果。
- en: 'Now, you have an example of a fixed grid. This grid can be made fluid by changing
    the fixed width using the following *Less* code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个固定网格的示例。通过使用以下*Less*代码更改固定宽度，可以使此网格成为流体网格：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this grid, the `.container` class holds the grid. This container contains
    rows (defined) with the `.row` class. You have to define only two extra classes
    because this grid has two columns. The first class, `.col`, defines a single column
    and the second class, `.col2`, defines a double column.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网格中，`.container`类包含网格。此容器包含了使用`.row`类定义的行。您只需要定义两个额外的类，因为此网格有两列。第一个类`.col`定义了单列，第二个类`.col2`定义了双列。
- en: Making your grid responsive
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使您的网格具有响应性
- en: To make grids responsive, you have to define one or more break points. Break
    points define the screen widths at which a website responds to provide a suitable
    layout; below or above the break point the grid can provide a different layout.
    In the example grid, you can describe two situations. In the first situation,
    below the break point (for instance 768 px), the screens are small. On small screens
    (keep a mobile phone screen in mind), the columns of the grid should stack. Above
    the break point, for tablet and desktop screens, the grid should become horizontal
    and the columns of the grid rows will float next to each other.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使网格具有响应性，您必须定义一个或多个断点。断点定义了网站响应以提供合适布局的屏幕宽度；在断点以下或以上，网格可以提供不同的布局。在示例网格中，您可以描述两种情况。在第一种情况下，在断点以下（例如768像素），屏幕很小。在小屏幕上（记住手机屏幕），网格的列应该堆叠。在断点以上，对于平板电脑和台式机屏幕，网格应该变为水平，网格行的列将浮动在一起。
- en: 'In *Less*, you can write the first situation for small screens using the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Less*中，您可以使用以下代码为小屏幕编写第一种情况：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: All columns get a width of `100%` of the viewport and none of them float. Starting
    your code with the smallest screens first will generate a "mobile-first" grid.
    Mobile first designs start with a basic design for small screens (and mobile browsers,
    which, not always, have full CSS and JavaScript capabilities) and rearrange and
    add content when the screen size is bigger. You already saw that the grid became
    horizontal for larger screens. Other examples can be the navigation, which has
    got another representation, or an image slider, which is only visible for desktop
    users.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有列都占视口的`100%`宽度，没有一个浮动。从最小的屏幕开始编写代码将生成“移动优先”网格。移动优先设计从小屏幕（和移动浏览器）开始，为大屏幕重新排列和添加内容。您已经看到网格在较大屏幕上变为水平。其他示例可能是导航，它有另一种表示，或者图像滑块，它只对桌面用户可见。
- en: 'Have a go at making your grid responsive now by adding a media query and defining
    a break point in *Less*, as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试通过添加媒体查询并在*Less*中定义断点来使您的网格具有响应性，如下所示：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code compiled into CSS code will look like the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编译为CSS代码的上述代码将如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's easy to see that now the `.row` classes only float on screens wider than
    768 pixels. Width columns will stack if the screen size is less than 786 pixels.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看到现在`.row`类只在宽度大于768像素的屏幕上浮动。如果屏幕尺寸小于786像素，宽度列将堆叠。
- en: The role of the clearfix
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除浮动的作用
- en: In the preceding example, columns became horizontal by applying `float:left`
    to them. The `clearfix()` mixin clears the float of an element after it has been
    rendered without additional markup, so it can be used for the `.row` classes of
    the grid. Using these clearfixes guarantees that your elements only float in their
    own row.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，列通过应用`float:left`而变为水平。`clearfix()`混合在元素渲染后清除元素的浮动，无需额外的标记，因此可以用于网格的`.row`类。使用这些清除可以保证您的元素只在自己的行中浮动。
- en: Using a more semantic strategy
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更具语义性的策略
- en: In the previous section, you built a grid using `div` elements and CSS classes.
    Many CSS frameworks, such as **Twitter's Bootstrap** and **ZURB Foundation**,
    construct their grids this way. Critics of the approach claim that it breaks the
    semantic nature of HTML5\. For this reason, they sometimes even compare it with
    the old-school way of defining layouts with HTML tables. HTML5 introduces semantic
    tags, which not only describe the structure but also the meaning of a document.
    For instance, the `header` tag is semantic; everyone knows what a header is and
    browsers know how to display them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您使用`div`元素和CSS类构建了一个网格。许多CSS框架，如**Twitter的Bootstrap**和**ZURB Foundation**，都是以这种方式构建它们的网格。批评者声称这种方法破坏了HTML5的语义性质。因此，他们有时甚至将其与使用HTML表定义布局的老式方法进行比较。HTML5引入了语义标签，不仅描述结构，还描述文档的含义。例如，`header`标签是语义的；每个人都知道头部是什么，浏览器知道如何显示它们。
- en: Using mixins instead of classes could help you make your grids more semantic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合而不是类可以帮助您使您的网格更具语义。
- en: 'An example of such a mixin is the following *Less* code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的混合示例是以下*Less*代码：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code can be compiled using the following *Less* code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以使用以下*Less*代码进行编译：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The HTML for the preceding CSS code will look like the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述CSS代码的HTML将如下所示：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Please note that in the preceding code, `@number` sets the total width to `@number`
    times the width of a column, and the total number of columns in the preceding
    grid will be fixed to `12`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，`@number`设置总宽度为`@number`乘以列宽度，并且上述网格中的列总数将固定为`12`。
- en: Building your layouts with grid classes
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用网格类构建您的布局
- en: 'The `.make-columns()` mixin can also be used to create your grid classes, as
    shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`.make-columns()`混合也可以用于创建您的网格类，如下面的代码所示：'
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code will compile into the following CSS code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将编译为以下CSS代码：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, the mixins to build the grid classes are called recursively.
    Please recall [Chapter 3](ch03.html "Chapter 3. Nested Rules, Operations, and
    Built-in Functions"), *Nested Rules, Operations, and Built-in Functions*, in which
    you have already seen how to use guards and recursion to construct a loop.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，使用混合来构建网格类是递归调用的。请回顾[第3章](ch03.html "第3章。嵌套规则、操作和内置函数")中已经看到如何使用保护和递归构建循环。
- en: Building nested grids
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建嵌套网格
- en: If you set `@grid-container-width` to `100%` and make your grid fluid, the `.make-columns()`
    mixin can also be used to build nested grids.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`@grid-container-width`设置为`100%`并使您的网格流动，`.make-columns()`混合也可以用于构建嵌套网格。
- en: Visit `http://localhost/nestedgrid.html` for an example of such a nested grid.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost/nestedgrid.html`以查看此类嵌套网格的示例。
- en: 'In HTML, you could write the following code to create a page with a header,
    content part, sidebar, and footer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，您可以编写以下代码来创建一个带有标题、内容部分、侧边栏和页脚的页面：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The content part will be divided into three equal-sized columns. To archive
    the preceding code, you could write the following code in *Less*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 内容部分将分为三个相等大小的列。要实现上述代码，您可以在*Less*中编写以下代码：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `.make-columns(4);` statement for `div.content-column` will create
    a width of `33.3%` (*4 / 12 * 100%*). The 33.3 percent will be calculated of the
    direct parent. The direct parent of `div.content-column` is `section#content`
    in this example. The `section#content` HTML element itself gets a width of 66.6
    percent (*8 / 12 *100%*) of the viewport.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于`div.content-column`的`.make-columns(4);`语句将创建`33.3%`的宽度（*4 / 12 * 100%*）。33.3%将根据直接父元素进行计算。在这个例子中，`div.content-column`的直接父元素是`section#content`。`section#content`
    HTML元素本身将占视口的`66.6%`的宽度（*8 / 12 *100%*）。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please note that if you should use the preceding grid in your project, you should
    separate your code into different files. If you create different files for your
    variables and mixins, your code will be clear and clean.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在项目中使用上述网格，应将代码分成不同的文件。如果为变量和混合创建不同的文件，您的代码将清晰而干净。
- en: Alternative grids
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代网格
- en: 'In the preceding example, you have seen the grid defined with columns that
    become horizontal when the screen size increases. These grids use CSS float to
    align the columns next to each other. In some situations, mostly for older browsers,
    this may cause some problems in pixel calculation. This problem is sometimes described
    as the "subpixel rounding" problem. Although `box-sizing: border-box;` will fix
    related issues, as described in [Chapter 1](ch01.html "Chapter 1. Improving Web
    Development with Less"), *Improving Web Development with Less*, one can choose
    to use a different grid definition.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的示例中，您已经看到了随着屏幕尺寸增加而变为水平的列定义的网格。这些网格使用CSS浮动来将列对齐在一起。在某些情况下，主要是对于旧版本的浏览器，这可能会导致像素计算方面的一些问题。这个问题有时被描述为“亚像素舍入”问题。尽管`box-sizing:
    border-box;`可以解决相关问题，如[第1章](ch01.html "第1章。使用Less改进Web开发")中所述，*使用Less改进Web开发*，但可以选择使用不同的网格定义。'
- en: 'CSS isolation provides a solution. CSS isolation is not easy to understand.
    Susy ([http://susydocs.oddbird.net/](http://susydocs.oddbird.net/)) describes
    it as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: CSS隔离提供了一个解决方案。CSS隔离并不容易理解。Susy ([http://susydocs.oddbird.net/](http://susydocs.oddbird.net/))将其描述如下：
- en: Every float is positioned relative to its container, rather than the float before
    it. It's a bit of a hack, and removes content from the flow, so I don't recommend
    building your entire layout on isolated floats, but it can be very useful as a
    spot-check when rounding errors are really causing you a headache.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个浮动都相对于其容器定位，而不是前面的浮动。这有点像一个黑客，会将内容从流中移除，所以我不建议在孤立的浮动上构建整个布局，但在舍入错误真的让你头疼时，它可能非常有用。
- en: CSS isolation is originally a part of Zen Grids ([http://zengrids.com/](http://zengrids.com/)).
    Zen Grid implementation has been written in SCSS/SASS. It will be relatively easy
    to rewrite this to *Less*; you could try this as an exercise. If you want to try
    this grid system, you can also download some example *Less* code from [https://github.com/bassjobsen/LESS-Zen-Grid](https://github.com/bassjobsen/LESS-Zen-Grid).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: CSS隔离最初是Zen Grids ([http://zengrids.com/](http://zengrids.com/))的一部分。Zen Grid的实现是用SCSS/SASS编写的。将其重写为*Less*将相对容易；你可以尝试这个作为练习。如果你想尝试这个栅格系统，你也可以从[https://github.com/bassjobsen/LESS-Zen-Grid](https://github.com/bassjobsen/LESS-Zen-Grid)下载一些示例*Less*代码。
- en: Building your project with a responsive grid
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应式栅格构建你的项目
- en: In the preceding examples, only the grid columns were defined. This should give
    you a good and realistic impression of how grids work and how to use them. A complete
    grid code also defines responsive containers and row classes. Most grids will
    also have so-called gutters between their columns. A gutter (mostly fixed) is
    a space that separates columns. This also means that a width spanning two columns
    include one gutter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，只定义了栅格列。这应该给你一个很好和现实的印象，栅格是如何工作以及如何使用它们的。完整的栅格代码还定义了响应式容器和行类。大多数栅格还会在列之间有所谓的间距。间距（通常是固定的）是分隔列的空间。这也意味着跨越两列的宽度包括一个间距。
- en: In [Chapter 4](ch04.html "Chapter 4. Avoid Reinventing the Wheel"), *Avoid Reinventing
    the Wheel*, you have learned to reuse *Less* and prebuilt mixins; you can do the
    same for grids. It won't be necessary to write the complete code yourself. Frameworks
    such as Twitter's Bootstrap, the Golden Grid System ([http://goldengridsystem.com/](http://goldengridsystem.com/)),
    or Less Framework 4 ([http://lessframework.com/](http://lessframework.com/)) will
    provide you with all the *Less* code and mixins you need. Some of these frameworks
    will be discussed in further detail in [Chapter 6](ch06.html "Chapter 6. Bootstrap
    3, WordPress, and Other Applications"), *Bootstrap3, WordPress, and Other Applications*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。避免重复造轮子")*避免重复造轮子*中，你已经学会了重用*Less*和预构建的mixin；你也可以对栅格做同样的事情。你不需要自己编写完整的代码。Twitter的Bootstrap、Golden
    Grid System ([http://goldengridsystem.com/](http://goldengridsystem.com/))或Less
    Framework 4 ([http://lessframework.com/](http://lessframework.com/))等框架将为你提供所需的所有*Less*代码和mixin。这些框架中的一些将在[第6章](ch06.html
    "第6章。Bootstrap 3、WordPress和其他应用")*Bootstrap3、WordPress和其他应用*中进一步讨论。
- en: The following examples will use Preboot's grid mixins to build your project's
    grid. Finally, you will rebuild the layout example you used earlier.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用Preboot的栅格mixin来构建项目的栅格。最后，你将重新构建之前使用的布局示例。
- en: Using Preboot's grid system
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Preboot的栅格系统
- en: Preboot's grid system enables you to build mobile-first grid layouts with a
    few variables and mixins. As you have seen earlier, you can use Preboot's mixins
    to create a semantic grid or define more general grid classes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Preboot的栅格系统使你能够使用少量变量和mixin构建移动优先的栅格布局。正如你之前看到的，你可以使用Preboot的mixin来创建语义化的栅格或定义更一般的栅格类。
- en: 'Preboot defines the grid''s variables, which are shown as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Preboot定义了栅格的变量，如下所示：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code snippet, `@grid-column-padding` defines the width of the
    gutter, as mentioned earlier. The grid columns are coded with the mobile-first
    approach. This means that by default, they stack vertically and float horizontally
    when the viewport's width is equal to or is wider than `@grid-float-breakpoint`.
    Let's not forget, of course, that `@grid-columns` sets the number of grid columns.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`@grid-column-padding`定义了栅格的间距宽度，正如前面提到的。栅格列采用了移动优先的方法进行编码。这意味着默认情况下，它们在视口宽度等于或大于`@grid-float-breakpoint`时会垂直堆叠并水平浮动。当然，不要忘记`@grid-columns`设置了栅格列的数量。
- en: 'Preboot doesn''t provide a container that holds the rows of the grid. You could
    define this variable yourself to define a maximum width for your grid, as shown
    in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Preboot没有提供包含栅格行的容器。你可以自己定义这个变量，以定义你的栅格的最大宽度，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are three available mixins for each part of a standard grid system, which
    are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标准栅格系统的部分都有三个可用的mixin，分别是：
- en: '`.make-row()`: This provides a wrapper for the columns to align their content
    via a negative margin and clear the floats'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.make-row()`: 为列提供一个包装器，通过负边距对齐它们的内容并清除浮动'
- en: '`grid.make-column(n)`: This is used to generate `n` number of columns as a
    percentage of the available grid columns (set via a variable to `12` by default)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid.make-column(n)`: 用于生成`n`个栅格列，作为可用栅格列的百分比（默认设置为`12`）'
- en: '`.make-column-offset(n)`: This pushes a column to the right by `n` columns
    via the margin'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.make-column-offset(n)`: 通过边距将列向右推`n`列'
- en: 'Now you can use preceding variables and mixins with Preboot to make a visible
    representation of the grid. To begin with, define some grid rows in HTML as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用前面的变量和mixin与Preboot一起制作栅格的可见表示。首先，在HTML中定义一些栅格行，如下所示：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The grid used here contains 12 columns and you can see the number of columns
    in each row should sum up to 12 too.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的栅格包含12列，你可以看到每行的列数应该总和为12。
- en: Now you can write the *Less* code for the preceding grid, which makes use of
    Preboot's mixins and variables. Again, you can split up your code into separated
    files to keep things clear.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以编写前面栅格的*Less*代码，其中使用了Preboot的mixin和变量。同样，你可以将代码分成不同的文件，以保持清晰。
- en: 'The `project.less` file contains the following *Less* code which imports all
    required files into the project:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.less`文件包含以下*Less*代码，将所有所需的文件导入项目：'
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `variables.less` file contains the following *Less* code that defines the
    project''s variables:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: variables.less文件包含以下*Less*代码，定义了项目的变量：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `mixins.less` file contains the mixins for the project:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixins.less`文件包含了项目的mixin：'
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note the usage of the `#preboot > .make-column(@number);` namespace here. The
    loop construct should now look familiar to you.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里使用了`#preboot > .make-column(@number);`命名空间。现在循环结构应该对您来说很熟悉了。
- en: 'And the `grid.less` file contains the *Less* code, which defines the grid''s
    classes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid.less`文件包含了定义网格类的*Less*代码：'
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code will create the CSS classes for your grid. Note that the
    `.container` class will be used to set the maximum width for the grid. It also
    sets a padding, which is needed to correct the gutter around the grid. Each row
    has a padding of half the size of `@grid-column-padding`. Between two rows, the
    `.containter` class makes the gutter equal to `@grid-column-padding`, but now,
    the left- and right-hand side of the grid only has a padding that is half the
    size of `@grid-column-padding`. The `.row` class corrects this by adding a negative
    margin of half the size of `@grid-column-padding`. Finally, the padding of the
    container prevents this negative margin from putting the grid off the screen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建用于您的网格的CSS类。请注意，`.container`类将用于设置网格的最大宽度。它还设置了填充，这是需要纠正网格周围的槽口的。每行的填充为`@grid-column-padding`大小的一半。在两行之间，`.containter`类使槽口等于`@grid-column-padding`，但现在，网格的左右两侧只有填充，大小为`@grid-column-padding`的一半。`.row`类通过添加大小为`@grid-column-padding`一半的负边距来纠正这一点。最后，容器的填充防止了这个负边距使网格偏离屏幕。
- en: Please also notice the ampersand in the `& { .make-grid-classes(12); }` statement.
    This ampersand (reference) guarantees that the inherited `.make-row` mixin will
    be visible when you need it. The namespaced mixin is not visible in the global
    scope. This problem may be fixed in later versions of *Less*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意`& { .make-grid-classes(12); }`语句中的和符号。这个和符号（引用）保证了继承的`.make-row` mixin在需要时可见。命名空间mixin在全局范围内不可见。这个问题可能在以后的*Less*版本中得到解决。
- en: 'And finally the `styles.less` file contains the *Less* code which defines the
    styles to make the grid columns visible:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`styles.less`文件包含了定义样式以使网格列可见的*Less*代码：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The compiled CSS from `styles.less` will only be used to make the grid columns
    visible. As mentioned in [Chapter 1](ch01.html "Chapter 1. Improving Web Development
    with Less"), *Improving Web Development with Less*, `[class^="col-"]` is a **CSS
    selector** that selects your grid''s columns which have a class starting with
    `col-`, your grid''s columns. Each column gets a height (`height`), background
    color (`background-color`), and border (`border)`. Also, here, the `box-sizing:
    border-box;` statement guarantees that the border width does not influence the
    width of the columns.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '从`styles.less`编译的CSS只用于使网格列可见。如[第1章](ch01.html "第1章。使用Less改进Web开发")中所述，*使用Less改进Web开发*，`[class^="col-"]`是一个**CSS选择器**，选择具有以`col-`开头的类的网格列。每列都有高度（`height`）、背景颜色（`background-color`）和边框（`border`）。此外，在这里，`box-sizing:
    border-box;`语句确保边框宽度不影响列的宽度。'
- en: 'You can see the final result by visiting `http://localhost/prebootgridclasses.html`
    on your browser. The result will look like the following image:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器中访问`http://localhost/prebootgridclasses.html`来查看最终结果。结果将如下图所示：
- en: '![Using Preboot''s grid system](img/1465OS-05-02.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![使用Preboot的网格系统](img/1465OS-05-02.jpg)'
- en: Representation of Preboot's grid with 12 columns
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Preboot的12列网格的表示
- en: 'When you see the preceding representation of the grid, you may wonder where
    to find the gutters. As mentioned earlier, the gutter will be constructed with
    a padding of the columns. You can make this visible by adding some content in
    the columns. So, try adding the following code into your HTML file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您看到网格的前面的表示时，您可能会想知道槽口在哪里。如前所述，槽口将由列的填充构成。您可以通过在列中添加一些内容来使其可见。因此，请尝试将以下代码添加到您的HTML文件中：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After adding the preceding code into your HTML file, the result will look like
    the following image:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码添加到HTML文件后，结果将如下图所示：
- en: '![Using Preboot''s grid system](img/1465OS-05-03.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![使用Preboot的网格系统](img/1465OS-05-03.jpg)'
- en: Preboot's grid with 12 columns; the content makes the gutters visible
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Preboot的12列网格；内容使槽口可见
- en: In the preceding image you will see the gutters of the grid. Please also notice
    that the `.col-6` class only has gutters on each side, so the total content width
    of a `.col-6` will be 6 columns, including five gutters.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图片中，您将看到网格的槽口。还请注意，`.col-6`类只在两侧有槽口，因此`.col-6`的总内容宽度将是6列，包括五个槽口。
- en: Using the grid mixins to build a semantic layout
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格mixin来构建语义布局
- en: In the preceding section, you used Preboot's grid mixins to build grid classes.
    In the final section of this chapter, you will use these mixins to build a semantic
    layout.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您使用了Preboot的网格mixin来构建网格类。在本章的最后一节中，您将使用这些mixin来构建语义布局。
- en: You can use the same example used earlier. Before you start, you should undo
    the changes made in the examples with media queries. You don't need these media
    queries here because the grid is responsive by default.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用之前使用的相同示例。在开始之前，您应该撤消在媒体查询示例中所做的更改。您在这里不需要这些媒体查询，因为网格默认是响应式的。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can watch the result by visiting `http://localhost/semanticgrid.html`, and
    you will find the Less files of this example in the `/less/semanticgrid/` folder.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问`http://localhost/semanticgrid.html`来观看结果，并且您将在`/less/semanticgrid/`文件夹中找到此示例的Less文件。
- en: In the current example layout, the container styles are applied to the body
    element. Nowadays, there seems to be no reason to add an extra `div` container
    (wrapper). All modern browsers handle the body as a normal block level element.
    If you prefer to add an extra wrapper for some reason, please do so. A plausible
    reason to do so would be, for instance, adding copyrights under your layout; of
    course, the body doesn't allow you to add something after it. In both cases, this
    container holds the grids' rows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例布局中，容器样式应用于body元素。现在似乎没有理由添加额外的`div`容器（包装器）。所有现代浏览器都将body视为普通的块级元素。如果出于某种原因希望添加额外的包装器，请这样做。例如，出于某种原因添加版权信息到您的布局；当然，body不允许您在其后添加内容。在这两种情况下，此容器保存网格的行。
- en: 'Open `/less/semanticgrid/project.less` and write the following *Less* code
    for the container mentioned into it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`/less/semanticgrid/project.less`，并将以下*Less*代码写入其中提到的容器：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Please notice that `@basic-width` in `/less/semanticgrid/variables.less` is
    set to 900 pixels to make it clear that the grid is responsive with a break point
    at 768 pixels.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`/less/semanticgrid/variables.less`中，`@basic-width`设置为900像素，以明确表明网格在768像素处具有断点响应。
- en: 'In this semantic example, you will use a grid with only three columns, defined
    in `/less/semanticgrid/variables.less`, using the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在此语义示例中，您将使用在`/less/semanticgrid/variables.less`中定义的仅三列网格，使用以下代码：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `/less/semanticgrid/project.less`, you can see that this example doesn''t
    use a namespace for Preboot. The latest version of *Less*, when this book was
    written, doesn''t support using namespace''s variables in the global scope. In
    further releases, you can expect #`namespace > @variable` to work, but it doesn''t
    work as of now. Using a namespace will make the setting of, for instance, `@grid-columns`
    inside the namespace from the global scope complex or impossible.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/less/semanticgrid/project.less`中，您可以看到此示例不使用Preboot的命名空间。在撰写本书时，最新版本的*Less*不支持在全局范围内使用命名空间的变量。在以后的版本中，您可以期望`#namespace
    > @variable`起作用，但目前还不起作用。使用命名空间将使命名空间内的设置（例如`@grid-columns`）从全局范围内变得复杂或不可能。
- en: Now, open `/less/semanticgrid/header.less`. In this file, you can remove the
    old `.centercontent` class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`/less/semanticgrid/header.less`。在此文件中，您可以删除旧的`.centercontent`类。
- en: Use the `.make-row()` mixin of Preboot to make the `header` tag act like a row
    and use the `.make-column(3)` mixin call for `h1` inside this header. The `h1`
    element will have a width of three columns now.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Preboot的`.make-row()` mixin使`header`标签像一行一样工作，并在其中使用`.make-column(3)` mixin调用`h1`。现在，`h1`元素将具有三列的宽度。
- en: Do the same for `/less/semanticgrid/content.less` but use `.make-column(2)`
    for the content and `.make-column(1)` for the sidebar here.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对`/less/semanticgrid/content.less`执行相同操作，但在此处使用`.make-column(2)`为内容和`.make-column(1)`为侧边栏。
- en: 'Again, you will see that in the mobile version, the navigation is under the
    content as explained earlier. You can fix this using the same trick you have seen
    earlier in the media queries example. In [Chapter 6](ch06.html "Chapter 6. Bootstrap
    3, WordPress, and Other Applications"), *Bootstrap3, WordPress, and Other Applications*,
    you will learn other ways to solve problems like this. For now, reverse the sidebar
    and the content in your HTML code so that the sidebar is before the content. After
    this, you should give the sidebar a `float: right` call, as shown in the following
    code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，您将看到在移动版本中，导航位于内容下面，就像之前解释的那样。您可以使用在媒体查询示例中看到的相同技巧来解决此问题。在[第6章](ch06.html
    "第6章。Bootstrap 3，WordPress和其他应用程序")中，*Bootstrap3，WordPress和其他应用程序*，您将学习解决此类问题的其他方法。目前，反转HTML代码中的侧边栏和内容，以便侧边栏在内容之前。之后，您应该给侧边栏一个`float:
    right`调用，如以下代码所示：'
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, you have to change the footer. Please use `.make-row()` again for the
    `footer` tag. The `div` elements inside the footer, which form the columns, will
    be styled with `.make-column(1)`. After doing this, you will see that the footer's
    columns are shown next to each other without any white space between them. Remember
    that the gutter of the grid is between the content of the columns and not between
    the columns itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要更改页脚。请再次为`footer`标签使用`.make-row()`。页脚内的`div`元素，即列，将使用`.make-column(1)`进行样式设置。完成此操作后，您将看到页脚的列相互挨着，之间没有任何空白。请记住，网格的间距在列的内容之间，而不是在列本身之间。
- en: 'To fix the problem mentioned earlier, apply `background-color`, `border-radius`,
    and `box-shadow` on the `p` element inside the `div` element, as shown in the
    following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决前面提到的问题，请在`div`元素内部的`p`元素上应用`background-color`，`border-radius`和`box-shadow`，如以下代码所示：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code will make the gutter visible, as seen earlier. The gutter
    of the grid adds some white space between the columns. There will also be a gutter
    on the left-hand side of the left column and on the right-hand side of the right
    column. This will make the total visible width of the footer columns smaller than
    the header. You can remove this gutter by setting the padding of `div` to `0`
    on these sides. Change the padding on the middle column to give the three columns
    the same width again. This can be done using the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将使栅格之间的间距可见，就像之前看到的那样。网格的间距在列之间添加了一些空白。左列的左侧和右列的右侧也会有间距。这将使页脚列的总可见宽度小于页眉。您可以通过在这些侧面将`div`的填充设置为`0`来去除此间距。再次更改中间列的填充，以再次使三列具有相同的宽度。可以使用以下代码来实现：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Visit `http://localhost/semanticgrid.html` to see the final result of the preceding
    code. Resize your browser window to see that it is indeed responsive.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost/semanticgrid.html`，查看前面代码的最终结果。调整浏览器窗口大小，以确保它确实是响应式的。
- en: Extending your grids
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展您的网格
- en: In the preceding examples, you used one grid with one break point. Below the
    break point, your rows simply stack. This seems to work in many cases, but sometimes,
    it will be useful to have a grid for small screens as well. Imagine that you build
    a photo gallery. On large screens, there will be four photos in a row. For smaller
    screens, the photos shouldn't stack but show up with two instead of four in a
    row.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您使用了一个带有一个断点的网格。在断点以下，您的行简单地堆叠。这在许多情况下似乎有效，但有时，也有必要为小屏幕创建一个网格。想象一下，您构建了一个照片库。在大屏幕上，一行中会有四张照片。对于较小的屏幕，照片不应该堆叠，而是一行中显示两张而不是四张。
- en: Again, you can solve this situation using grid classes or mixins for a more
    semantic solution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用网格类或mixin来解决这种情况，以获得更语义化的解决方案。
- en: In both situations, you should also make your photos responsive. You can do
    this by adding styles for your images. Setting `max-width` to `100%` and `height`
    to `auto` does the trick in most cases. The `max-width` variable prevents images
    from being displayed wider than their original size and ensures that they get
    100 percent of their parent's width in other situations. On small screens, these
    images will get 100 percent width of the viewport.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您还应该使您的照片具有响应性。您可以通过为您的图片添加样式来实现这一点。将`max-width`设置为`100%`，将`height`设置为`auto`在大多数情况下都可以奏效。`max-width`变量可以防止图像显示宽于其原始尺寸，并确保它们在其他情况下获得其父元素宽度的100%。在小屏幕上，这些图像将获得视口宽度的100%。
- en: 'To make your images responsive by default, you can add the following code to
    your project''s *Less* code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的图像默认具有响应性，您可以将以下代码添加到您项目的*Less*代码中：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you prefer to make your image explicitly responsive by adding a class to
    each image in your source, you can you use the following *Less* code to make such
    a class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢通过为源中的每个图像添加一个类来明确地使您的图像具有响应性，您可以使用以下*Less*代码来创建这样一个类：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Adding grid classes for the small grid
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为小网格添加网格类
- en: When using grid classes, you have to change the original `.make-column` mixin
    from Preboot. This `.make-columns()` mixin sets the styles for a column and add
    a media query. The media query in the `.make-columns()` mixin lets the columns
    float horizontally for wider viewports. For the new small grid, you don't need
    a media query, because the columns shouldn't be stacked at all.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格类时，您必须更改Preboot中的原始`.make-column` mixin。这个`.make-columns()` mixin设置了列的样式并添加了一个媒体查询。`.make-columns()`
    mixin中的媒体查询让列在更宽的视口上水平浮动。对于新的小网格，您不需要媒体查询，因为列根本不应该堆叠。
- en: 'To accomplish this, you can split the mixin into two new mixins, as shown in
    the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您可以将mixin拆分为两个新的mixin，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After writing the preceding mixins, you should also create two mixins which
    do a loop to make your grid classes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 编写了前面的mixin之后，您还应该创建两个mixin，这两个mixin会循环创建您的网格类。
- en: 'The first mixin should look like the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个mixin应该如下代码所示：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The preceding mixins will be called from `grid.less` using the `.make-grid-columns(12);`
    statement. These mixins will be compiled into the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的mixin将通过`grid.less`中的`.make-grid-columns(12);`语句调用。这些mixin将编译成以下代码：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After doing this, you can easily see that the preceding code can be optimized
    to the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后，您可以很容易地看到前面的代码可以优化为以下代码：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The second mixin will look like the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个mixin将如下代码所示：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding mixins will be called from `grid.less` using the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的mixin将通过以下代码在`grid.less`中调用：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding code will create two sets of grid classes. The large grid classes
    will only be applied when the media query is true. You will perhaps wonder why
    you can't create these grid classes in one single loop. This is because of the
    *last declaration wins* rule; you should define all your large grid classes after
    the small grid classes. If, for instance, `col-large-2` is defined before `col-small-3`,
    you can't use `<div class="col-small-3 col-large-2">` because `col-small-3` overrules
    the styles of `col-large-2`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建两组网格类。大网格类只有在媒体查询为真时才会应用。您可能会想为什么不能在一个单独的循环中创建这些网格类。这是因为*最后的声明获胜*规则；您应该在小网格类之后定义所有的大网格类。例如，如果`col-large-2`在`col-small-3`之前定义，您就不能使用`<div
    class="col-small-3 col-large-2">`，因为`col-small-3`会覆盖`col-large-2`的样式。
- en: 'After creating your mixins as described earlier, you can write your HTML code
    as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了前面描述的mixin之后，您可以按照以下方式编写您的HTML代码：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code will show four columns on your screen. These columns are
    wider than 768 pixels. The code will also show two columns on smaller screens.
    You can see an example of this by visiting: `http://localhost/prebootgridclassesextend.html`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在您的屏幕上显示四列。这些列宽度大于768像素。该代码还将在较小的屏幕上显示两列。您可以通过访问`http://localhost/prebootgridclassesextend.html`来查看这个例子。
- en: Applying the small grid on your semantic code
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的语义化代码中应用小网格
- en: If you have chosen the semantic way to build your grids, the following example
    will help you to add a small grid to the footer of the layout you built earlier.
    You can use the files from `/less/semanticgrid/content.less` again in this example.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择了语义化的方式来构建您的网格，下面的例子将帮助您在之前构建的布局的页脚中添加一个小网格。您可以在这个例子中再次使用`/less/semanticgrid/content.less`中的文件。
- en: The layout has a break point at 768 pixels. Below this break point, on a small
    screen, the footer should have three columns, and on big screens, the footer columns
    should stack.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 布局在768像素处有一个断点。在这个断点以下，即在小屏幕上，页脚应该有三列，在大屏幕上，页脚列应该堆叠。
- en: 'You can reuse the Preboot mixins you used earlier in this chapter to build
    a responsive grid, to create the footer columns as described previously. First,
    split the mixin into two new mixins: one mixin for floating and one for styling
    the columns, as shown in the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重用本章前面使用的Preboot mixin来构建一个响应式网格，以创建如前所述的页脚列。首先，将mixin拆分为两个新的mixin：一个用于浮动，一个用于样式化列，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After creating these mixins, you can use them together with media queries as
    follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些mixin之后，您可以将它们与媒体查询一起使用，如下所示：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Unfortunately, you have arrived at the end of this chapter. Hopefully, you feel
    that you are already able to start your own project with *Less*. In this chapter,
    you learned how to use *Less* for your projects. You also learned how to use media
    queries and grids to build responsive websites. You are ready to start using *Less*
    in your projects now. Finally, you will have more time for your real design tasks.
    In the next chapter, you will be introduced to other projects and frameworks using
    *Less*. You will also learn how you can use these for your projects.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，你已经到达了本章的结尾。希望你觉得自己已经能够用*Less*开始自己的项目了。在本章中，你学会了如何在项目中使用*Less*。你还学会了如何使用媒体查询和网格来构建响应式网站。现在你已经准备好在项目中开始使用*Less*了。最后，你将有更多时间来处理真正的设计任务。在下一章中，你将介绍其他使用*Less*的项目和框架。你还将学习如何在自己的项目中使用它们。
