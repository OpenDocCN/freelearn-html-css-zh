["```js\nfunction myAnimationLoop(time) {\n   // 1\\. Perform the animation\n   myAnimation(time);\n\n   // 2\\. Register with request animation frame\n   requestAnimationFrame(myAnimationLoop);\n}\n\nfunction myAnimation(time) {\n   // Perform animation here\n}\n```", "```js\nfunction myAnimation(time) {\n   // 1\\. Perform the animation\n   myAnimation(time);\n\n   // 2\\. Register with request animation frame\n   requestAnimationFrame(myAnimationLoop);\n}\n```", "```js\n// 1\\. Create some element\nvar el = document.createElement(\"h1\");\nel.textContent = \"I Love HTML5!\";\nel.style.position = \"absolute\";\n\n// 2\\. Attach it to the document\ndocument.body.appendChild(el);\n\n// 3\\. Set some variables to control the animation\nvar loop = 0;\nvar lastFrame = 0;\nvar fps = 1000 / 60;\n\n// 4\\. Perform the animation one frame at a time\nfunction slideRight(time) {\n\n   // 5\\. Control the animation to a set frames per second\n   if (time - lastFrame >= fps) {\n\n      var left = parseInt(el.style.left);\n\n      // 6\\. Perform the animation while some condition is true\n      if (left + el.offsetWidth < document.body.offsetWidth) {\n         el.style.left = (left + loop) + \"px\";\n         loop += 5;\n\n         // 7\\. Perform the time control variable\n         lastFrame = time;\n      } else {\n\n         // 8\\. If the animation is done, return from this function\n         el.style.left = document.body.offsetWidth - el.offsetWidth;\n         return true;\n      }\n   }\n\n   // 9\\. If the animation is not done yet, do it again\n   requestAnimationFrame(slideRight);\n}\n\n// 10\\. Register some event to begin the animation\nel.addEventListener(\"click\", function(){\n   el.style.left = 0;\n   loop = 0;\n   slideRight(0);\n});\n```", "```js\nvar nums = [1, 2, 3, 4, 5];\nfor (var i = 0, len = nums.length; i < len; i++) {\n   // ...\n}\n```", "```js\nvar typedArr = new Int32Array(10);\n```", "```js\ntypedArr instanceof Int32Array; // True\ntypedArr.length == 10; // True\n\ntypedArr.push(23); // TypeError: <Int32Array> has no method 'push'\ntypedArr.pop(); // TypeError: <Int32Array> has no method 'pop'\ntypedArr.sort(); // TypeError; <Int32Array> has no method 'sort'\n\ntypedArr.buffer instanceof ArrayBuffer; // True\ntypedArr.buffer.byteLength == 40; //True\n\ntypedArr instanceof Array; // False\n```", "```js\nvar typedArr = new Uint32Array(3);\n\ntypedArr[] = 0; // SyntaxError\n\ntypedArr[0] = 3;\ntypedArr[1] = 4;\ntypedArr[2] = 9;\n\nfor (var i = 0, len = typedArr.length; i < len; i++) {\n   typedArr[i] >= 0; // True\n}\n```", "```js\nvar buffer = new ArrayBuffer(32);\nbuffer.byteLengh == 32; // True\n\nvar i32View = new Int32Array(buffer);\ni32View.length == 8; // True\n```", "```js\n// 96 bytes in the buffer\nvar buffer = new ArrayBuffer(96);\n\n// Each element in the buffer is 32 bits long, or 4 bytes\nvar view = new Int32Array(buffer);\n\n// 96 / 4 = 24 elements in this typed array\nview.length == 24;\n```", "```js\n// Create a typed array with 4 elements, each 32 bits long\nvar i32viewA = new Int32Array(4);\n\n// Create the same typed array, but using an explicit ArrayBuffer first\nvar buffer = new ArrayBuffer(16)\nvar i32viewB = new Int32Array(buffer)\n```", "```js\nvar canvasA = document.createElement(\"canvas\");\nvar ctx2d = canvas.getContext(\"2d\");\nctx2d instanceof CanvasRenderingContext2D; // True\n\nvar canvasB = document.createElement(\"canvas\");\nvar ctx3d = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\nctx3d instanceof WebGLRenderingContext; // True\n```", "```js\n<style>\ncanvas {\n   border: 3px solid #ddd;\n   width: 500px;\n   height: 300px;\n}\n</style>\n\n<script>\n   var canvas = document.createElement(\"canvas\");\n   var ctx = canvas.getContext(\"2d\");\n\n   document.body.appendChild(canvas);\n\n   alert(ctx.canvas.width);\n</script>\n```", "```js\nvar canvas = document.querySelector(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\n\n// Clear the entire canvas\nctx.clearRect(0, 0, canvas.width, canvas.height);\n\n// Only clear the half inside area of the canvas\nctx.clearRect(canvas.width * 0.25, canvas.height * 0.25,\n   canvas.width * 0.5, canvas.height * 0.5);\n\n// Clear a square 100x100 at the lower right bottom of the canvas\nctx.clearRect(canvas.width - 100, canvas.height - 100, 100, 100);\n```", "```js\n// Short hand hex colors are fine\nctx.fillStyle = \"#c00\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\n// Keyword colors are fine, though not as precise\nctx.strokeStyle = \"white\";\n\nctx.lineWidth = 10;\nctx.strokeRect(25, 25, 100, 100);\nctx.strokeRect(175, 25, 100, 100);\n\n// Alpha transparency is also allowed\nctx.fillStyle = \"rgba(100, 255, 100, 0.8)\";\n\nctx.fillRect(5, 50, canvas.width - 10, 50);\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\n// This call is completely useless\nctx.strokeStyle = \"#c0c\";\nctx.lineWidth = 5;\n\nctx.moveTo(0, 0);\nctx.lineTo(100, 100);\nctx.lineTo(canvas.width, 0);\n\n// This call is also useless because the line hasn't been drawn yet\nctx.strokeStyle = \"#ca0\";\nctx.moveTo(10, canvas.height - 10);\nctx.lineTo(canvas.width - 10, canvas.height * 0.5);\n\n// This color is applied to every line drawn so far\nctx.strokeStyle = \"#f5a\";\n\n// The line is finally drawn here\nctx.stroke();\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.strokeStyle = \"#c0c\";\n\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\nctx.rect(10, 10, 50, 50);\nctx.rect(75, 50, 50, 50);\n\nctx.moveTo(180, 100);\nctx.arc(180, 100, 30, 1, 3, true);\n\nctx.moveTo(225, 40);\nctx.arc(225, 40, 20, 0, Math.PI * 2, false);\n\nctx.stroke();\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\nctx.fillStyle = \"#f00\";\nctx.font = \"2.5em 'Times New Roman'\";\n\nctx.fillText(\"I Love HTML5!\", 20, 75);\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\n// Now the origin is at point 50x50\nctx.translate(50, 50);\n\nctx.fillStyle = \"#f00\";\nctx.fillRect(0, 0, 50, 50);\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\n// With transformations, order is very important\nctx.scale(2, 1);\nctx.translate(50, 50);\nctx.rotate(0.80);\nctx.translate(10, -20);\n\nctx.fillStyle = \"#f00\";\nctx.fillRect(0, 0, 50, 50);\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\nvar img = new Image();\nimg.onload = function(){\n   ctx.drawImage(img, 0, 0, this.width, this.height);\n};\n\nimg.src = \"img/html5-logo.png\";\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\nvar img = new Image();\nimg.onload = function(){\n\n   ctx.drawImage(img,\n      // Sample part of the upper left corner of the source image\n      35, 60, this.width / 2, this.height / 2,\n\n      // And draw it onto the entire canvas, even if it distorts the image\n      0, 0, canvas.width, canvas.height);\n};\n\nimg.src = \"img/html5-logo.png\";\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\nvar img = new Image();\nimg.onload = function(){\n   ctx.drawImage(img, 35, 60, this.width / 2, this.height / 2, 0, 0, canvas.width, canvas.height);\n\n   // Extract pixel data from canvas context\n   var pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n   pixels instanceof ImageData; // True\n   pixels.data instanceof Uint8ClampedArray; // True\n   pixels.width == canvas.width; // True\n   pixels.height == canvas.height; // True\n\n   // Insert pixel data into canvas context\n   ctx.putImageData(pixels, 0, 0);\n};\n\nimg.src = \"img/html5-logo.png\";\n```", "```js\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\nvar img = new Image();\nimg.onload = function(){\n   ctx.drawImage(img, 35, 60, this.width / 2, this.height / 2, 0, 0, canvas.width, canvas.height);\n\n   // Extract pixel data from canvas context\n   var pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n   // Iterate over every four elements, which together represent a single pixel\n   for (var i = 0, len = pixels.data.length; i < len; i += 4) {\n      var red = pixels.data[i];\n      var green = pixels.data[i + 1];\n      var blue = pixels.data[i + 2];\n      var gray = (red + green + blue) / 3;\n\n     // PS: Alpha channel can be accessed at pixels.data[i + 3]\n\n      pixels.data[i] = gray;\n      pixels.data[i + 1] = gray;\n      pixels.data[i + 2] = gray;\n   }\n\n   // Insert pixel data into canvas context\n   ctx.putImageData(pixels, 0, 0);\n};\n\nimg.src = \"img/html5-logo.png\";\n```", "```js\n   ctx.putImageData(pixels, 0, 0);\n\n   var imgUrl_LQ = canvas.toDataURL(\"image/jpeg\", 0.0);\n   var out = new Image();\n   out.src = imgUrl_LQ;\n   document.body.appendChild(out);\n\n   var imgUrl_HQ = canvas.toDataURL(\"image/jpeg\", 1.0);\n   var out = new Image();\n   out.src = imgUrl_HQ;\n   document.body.appendChild(out);\n\n   var imgUrl_raw = canvas.toDataURL(\"image/png\");\n   var out = new Image();\n   out.src = imgUrl_raw;\n   document.body.appendChild(out);\n```", "```js\nself.addEventListener(\"message\", getPrimes);\n```", "```js\n// index.html\nvar worker = new Worker(\"get-primes.worker.js\");\n\nworker.addEventListener(\"message\", function(event){\n   var primes = event.data.primes;\n   var ul = document.createElement(\"ul\");\n\n   // Parse each prime returned from the worker\n   for (var i = 0, len = primes.length; i < len; i++) {\n      var li = document.createElement(\"li\");\n      li.textContent = primes[i];\n      ul.appendChild(li);\n   }\n\n   // Clear any existing list items\n   var uls = document.querySelectorAll(\"ul\");\n   for (var i = 0, len = uls.length; i < len; i++)\n      uls[i].remove();\n\n   // Display the results\n   document.body.appendChild(ul);\n});\n\nvar input = document.createElement(\"input\");\ninput.addEventListener(\"keyup\", function(event){\n   var key = event.which;\n\n   // Call the worker when the Enter key is pressed\n   if (key == 13 /* Enter */) {\n      var input = this.value;\n\n      // Only use input that's a positive number\n      if (!isNaN(input) && input > 0) {\n         worker.postMessage({max: input});\n      } else if (input == -1) {\n         worker.terminate();\n         this.remove();\n      }\n   }\n});\n\ninput.setAttribute(\"autofocus\", true);\ndocument.body.appendChild(input);\n```", "```js\n// get-primes.worker.js\n\n// Register the onMessage callback\nself.addEventListener(\"message\", getPrimes);\n\n// This function implements the Sieve of Eratosthenes to generate the primes.\n// Don't worry about the algorithm so much \u2013 focus on the Worker API\nfunction getPrimes(event) {\n\n   var max = event.data.max;\n   var primes = [];\n   var d = [];\n\n   for (var q = 2; q < max; q++) {\n      if (d[q]) {\n         for (var i = 0; i < d[q].length; i++) {\n            var p = d[q][i];\n            if (d[p + q])\n               d[p + q].push(p);\n            else\n               d[p + q] = [p];\n         }\n         delete d[q];\n      } else {\n         primes.push(q);\n         if (q * q < max)\n            d[q * q] = [q];\n      }\n   }\n\n   // Return the list of primes to the parent thread\n   self.postMessage({primes: primes});\n}\n```", "```js\n<!doctype html>\n<html manifest=\"manifest.appcache\">\n```", "```js\nAddType text/cache-manifest .appcache\n```", "```js\nCACHE MANIFEST\n```", "```js\nApplication Cache Error event: Failed to parse manifest\n```", "```js\nCACHE MANIFEST\n\n# HTML5 Snake, Version 1.0.0\n\nCACHE:\nindex.html\njs/next-empty.worker.js\njs/renderer.class.js\njs/snake.class.js\nimg/block-green.png\nimg/fruit-01.png\nfonts/geo.woff\nfonts/vt323.woff\ncss/style.css\n\nNETWORK:\n*\n\nFALLBACK:\nfallback.html\n```", "```js\n<h1>HTML5 Snake</h1>\n\n<section id=\"scores\">\n   <h3>Score: <span>0</span></h3>\n   <h3>High Score: <span>0</span></h3>\n</section>\n\n<section id=\"gameMenu\" class=\"hide\">\n   <h3>Ready!</h3>\n   <button>Play</button>\n</section>\n```", "```js\nvar Renderer = function(canvas) {\n\n   var canvas = canvas;\n   var ctx = canvas.getContext(\"2d\");\n   var width = canvas.width;\n   var height = canvas.height;\n\n   var getIndex = function(x, y) {\n      return width * y + x;\n   };\n\n   var getPosition = function(index) {\n      return {\n         x: index % width,\n         y: parseInt(index / width)\n      };\n   };\n\n   this.clear = function() {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n   };\n\n   this.draw = function(points, img) {\n      for (var i = 0, len = points.length; i < len; i += 2) {\n         ctx.drawImage(img, points[i] * img.width, points[i + 1] * img.height, img.width, img.height);\n      }\n   };\n};\n```", "```js\nvar Snake = function(x, y, width, height, maxSize) {\n   var isAlive = true;\n   var size = 0;\n   var body = new Int8Array(maxSize * 2);\n   for (var i = 0, len = body.length; i < len; i++)\n      body[i] = -1;\n   body[0] = x, body[1] = y;\n   var worldWidth = width;\n   var worldHeight = height;\n   var skin;\n   var dir = { 38: false, 40: false, 37: false, 39: false };\n   var keys = { UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39 };\n   // To move the snake, we first move each body part to where the\n   // part before it used to be, starting at the tail and moving\n   // towards the head. Lastly, we update the head's position\n   var move = function() {\n      // Traverse the snake backwards and shift each piece one spot\n      for (var i = size * 2 + 1; i > 1; i -= 2) {\n         body[i] = body[i - 2];\n         body[i - 1] = body[i - 3];\n      }\n      if (dir[keys.UP]) {\n         body[1]--;\n      } else if (dir[keys.DOWN]) {\n         body[1]++;\n      } else if (dir[keys.LEFT]) {\n         body[0]--;\n      } else if (dir[keys.RIGHT]) {\n         body[0]++;\n      }\n   };\n   // Update the snake's position vectors on key presses\n   this.doOnKeyDown = function(event) {\n      var key = event.which;\n      // Don't process a key that's already down\n      if (dir[key])\n         return;\n      dir[keys.UP] = false;\n      dir[keys.DOWN] = false;\n      dir[keys.LEFT] = false;\n      dir[keys.RIGHT] = false;\n      if (key == keys.UP && !dir[keys.DOWN]) {\n         return dir[keys.UP] = true;\n      } else if (key === keys.DOWN && !dir[keys.UP]) {\n         return dir[keys.DOWN] = true;\n      } else if (key === keys.LEFT && !dir[keys.RIGHT]) {\n         return dir[keys.LEFT] = true;\n      } else if (key === keys.RIGHT && !dir[keys.LEFT]) {\n         return dir[keys.RIGHT] = true;\n      }\n   };\n   // This allows us to use different images to represent the snake\n   this.setSkin = function(img) {\n      skin = new Image();\n      skin.onload = function() {\n         skin.width = this.width;\n         skin.height = this.height;\n      };\n      skin.src = img;\n   };\n      this.move = move;\n   this.getSkin = function() { return skin; };\n   this.setDead = function(isDead) { isAlive = !isDead; };\n   this.isAlive = function() { return isAlive; };\n   this.getBody = function() { return body; };\n   this.getHead = function() { return {x: body[0], y: body[1]}; };\n   this.grow = function() { if (size * 2 < body.length) return size++; };\n   // Check if the snake is at a certain position on the grid\n   this.isAt = function(x, y, includeHead) {\n      var offset = includeHead ? 0 : 2;\n      for (var i = 2, len = body.length; i < len; i += 2) {\n         if (body[i] == x && body[i + 1] == y)\n            return true;\n      }\n      return false;\n   };\n   this.reset = function(x, y) {\n      for (var i = 0, len = body.length; i < len; i++)\n         body[i] = -1;\n      body[0] = x;\n      body[1] = y;\n      size = 0;\n      isAlive = true;\n      dir[keys.UP] = false;\n      dir[keys.DOWN] = false;\n      dir[keys.LEFT] = false;\n      dir[keys.RIGHT] = false;\n   };\n};\n```", "```js\nvar fruit = {\n   position: new Int8Array(2),\n   reset: function() {\n      this.position[0] = -1;\n      this.position[1] = -1;\n   },\n   isAt: function(x, y) {\n      return this.position[0] == x && this.position[1] == y;\n   },\n   img: null\n};\n```", "```js\nfunction gameLoop() {\n   // Only do anything here if the snake is not dead\n   if (snake.isAlive()) {\n\n      // Make the frame rate no faster than what we determine (30 fps)\n      renderTime.now = Date.now();\n      if (renderTime.now - renderTime.last >= renderTime.fps) {\n         // If there is no fruit on the grid, place one somewhere. Here we\n         // use a web worker to calculate an empty square on the map\n         if (fruit.position[0] < 0) {\n            cellGen.postMessage({\n               points: snake.getBody(),\n               width: worldWidth,\n               height: worldHeight\n            });\n         } else {\n\n            snake.move();\n            head = snake.getHead();\n\n            // Check if the snake has ran into itself, or gone outside the grid\n            if (snake.isAt(head.x, head.y, false) ||\n                   head.x < 0 || head.y < 0 ||\n                   head.x >= worldWidth || head.y >= worldHeight) {\n               snake.setDead(true);\n            }\n\n            // Check if the snake has eaten a fruit\n            if (fruit.isAt(head.x, head.y)) {\n               fruit.reset();\n               snake.grow();\n               score.up();\n            }\n\n            renderTime.last = renderTime.now;\n         }\n      }\n\n      // Render everything: clear the screen, draw the fruit, draw the snake,\n      // and register the callback with rAF\n      renderer.clear();\n      renderer.draw(fruit.position, fruit.img);\n      renderer.draw(snake.getBody(), snake.getSkin());\n      requestAnimationFrame(gameLoop);\n   }\n\n   // If the snake is dead, stop rendering and disable\n   // the key handlers that controlled the snake\n   else {\n      document.body.removeEventListener(\"keydown\", snake.doOnKeyDown);\n   }\n}\n```"]