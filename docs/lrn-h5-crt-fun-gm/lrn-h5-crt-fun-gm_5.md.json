["```js\n// ---------------------------------\n// Host document: web-messaging.html\n// ---------------------------------\nvar doc = document.querySelector(\"iframe\").contentWindow;\n// alternatively:\n// var doc = window.open(\"web-messaging-rec.html\", \"\", \"width=800,height=600\");\n// Post a message to the child document\ndoc.postMessage({msg: \"Hello!\"}, \"http://localhost\");\n// --------------------------------------\n// Child document: web-messaging-rec.html\n// --------------------------------------\nwindow.addEventListener(\"message\", function(event) {\n   var data = event.data;\n   // Post a message back to the parent document\n   event.source.postMessage({msg: \"Thanks for saying \" + data.msg}, \"*\");\n});\n```", "```js\n// 1\\. Create an array to hold each frame (aka. window)\nvar frames = new Array();\n// 2\\. Let's keep track of some settings for these frames\nframes.max = 3;\nframes.width = 200;\nframes.height = 300;\nframes.margin = 50;\n// 3\\. Finally, we'll need a snake to move around\nvar snake = {\n  max: 3,\n  pos: {\n    x: 0,\n    y: 0\n  },\n  w: 25,\n  h: 25,\n  speed: 3,\n  dir: {\n    x: 1,\n    y: 0\n  },\n  color: \"#0a0\"\n};\n```", "```js\n// Define a few global variables in order to keep the code shorter and simpler\nvar isPaused = true;\nvar timer;\nvar dirChange = 100;\nvar btn = document.createElement(\"button\");\nbtn.textContent = \"Add Window\";\nbtn.addEventListener(\"click\", function(event){\n  var left = frames.length * frames.width + frames.margin * frames.length;\n  frames[frames.length] = window.open(\"/packt/snake-v2/snake-panels.html\", \"\",\n    \"width=\" + frames.width + \",\" +\n    \"height=\" + frames.height + \",\" +\n    \"top=100, left=\" + left);\n  isPaused = false;\n  clearTimeout(timer);\n  play();\n}, false);\ndocument.body.appendChild(btn);\n// We'll close all the windows we have opened to save us the\n// trouble of clicking each window when we want them closed\nfunction closeAll() {\n  for (var i = 0, len = frames.length; i < len; i++) {\n    frames[i].close();\n  }\n}\nwindow.onunload = closeAll;\n```", "```js\nfunction play() {\n  // This is used to change the snake's position randomly\n  // from time to time. The reason for this is so we don't\n  // need to implement any event handling to handle user input,\n  // since this is just a simple demonstration.\n  if (dirChange-- < 0) {\n    dirChange = 100;\n    var rand = parseInt(Math.random() * 1000) % 4;\n    // Make the snake move to the right\n    if (rand == 0) {\n      snake.dir.x = 1;\n      snake.dir.y = 0;\n    // Make the snake move to the left\n    } else if (rand == 1) {\n      snake.dir.x = -1;\n      snake.dir.y = 0;\n    // Make the snake move down\n    } else if (rand == 2) {\n      snake.dir.x = 0;\n      snake.dir.y = 1;\n      // Make the snake move up\n    } else if (rand == 3) {\n      snake.dir.x = 0;\n      snake.dir.y = -1;\n    }\n  };\n  // Update the snake's position, making sure to wrap the snake\n  // around each window. If it goes too far to the right, and\n  // wanders off one window, it needs to wrap to the left side\n  // of the next window.\n  snake.pos.x += snake.dir.x * snake.speed;\n  snake.pos.x %= frames.width * frames.length;\n  snake.pos.y += snake.speed * snake.dir.y;\n  if (snake.pos.y < 0)\n    snake.pos.y = frames.height - snake.h;\n  if (snake.pos.y + snake.h > frames.height)\n    snake.pos.y = 0;\n  if (snake.pos.x < 0)\n    snake.pos.x = (frames.width - snake.w) * frames.width * frames.length;\n  var shouldDraw;\n  for (var i = 0, len = frames.length; i < len; i++) {\n    // Determine which window the snake is in, and tell only that\n    // window that it needs to render the snake\n    shouldDraw = snake.pos.x + snake.w <= frames.width * (i + 1) &&\n        snake.pos.x >= frames.width * i ||\n        snake.pos.x <= frames.width * (i + 1) &&\n        snake.pos.x >= frames.width * i;\n    // Lastly, we pass all this information to each window in canvas coordinates.\n    frames[i].postMessage({\n      x: snake.pos.x % frames.width,\n      y: snake.pos.y,\n      w: snake.w,\n      h: snake.h,\n      shouldDraw: shouldDraw,\n      color: snake.color\n    }, \"*\");\n  }\n}\n```", "```js\n// 1\\. Create a canvas\nvar canvas = document.createElement(\"canvas\");\ncanvas.width = 400;\ncanvas.height = 300;\n// 2\\. Attach the canvas to the DOM\ndocument.body.appendChild(canvas);\n// 3\\. Get a reference to the canvas' context\nvar ctx = canvas.getContext(\"2d\");\n// 4\\. Set up the callback to receive messages from some parent window\nfunction doOnMessage(event) {\n  // 5\\. For security, make sure we only process input from a trusted window\n  if (event.origin == \"http://localhost\") {\n    var data = event.data;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    // 6\\. And here's where the magic happens for this window. If told to\n    // draw something through the message received, go ahead and do so.\n    if (data.shouldDraw) {\n      ctx.fillStyle = data.color;\n      ctx.fillRect(data.x, data.y, data.w, data.h);\n    }\n  }\n}\nwindow.addEventListener(\"message\", doOnMessage, false);\n```", "```js\nvar typedArray = new Uint32Array(100);\nlocalStorage.setItem(\"my-array\", typedArray);\nvar myArray = localStorage.getItem(\"my-array\");\nmyArray == \"[object Uint32Array]\"; // True\n```", "```js\n// 1\\. Define some class\nvar Person = function(name) {\n  this.name = name;\n};\n// 2\\. Add functions to the class\nPerson.prototype.greet = function(){\n  return \"Hello, \" + this.name;\n};\n// 3\\. Create an array of objects of that class\nvar people = new Array();\npeople.push(new Person(\"Rodrigo\"));\npeople.push(new Person(\"Silveira\"));\n// 4\\. Stringify the complex array, and store it away\nvar json = JSON.stringify(people);\nlocalStorage.setItem(\"people\", json);\n// 5\\. Retrieve that serialized data, and parse it back into what it was\npeople = JSON.parse(localStorage.getItem(\"people\"));\npeople[0].name == \"Rodrigo\"; // True\npeople[0] instanceof Person; // False\npeople[0].greet(); // TypeError: Object has no method 'greet'\n```", "```js\nvar name = sessionStorage.getItem(\"coolestPerson\");\n// Only set a new value if the key exists,\n// and the value is not what we want\nif (name != null && name != \"Rodrigo\") {\n  sessionStorage.setItem(\"coolestPerson\", \"Rodrigo\");\n}\n```", "```js\nif (\"coolestPerson\" in sessionStorage) {\n   // \u2026\n}\n```", "```js\nsessionStorage.clear();\nsessionStorage.length == 0; // True\nsessionStorage.setItem(\"name\", \"Rodrigo\");\nsessionStorage.setItem(\"book\", \"Learn HTML5\");\nsessionStorage.setItem(\"publisher\", \"Packt Pub\");\nsessionStorage.setItem(\"isColor\", true);\nsessionStorage.setItem(\"rating\", 5);\nvar values = new Array();\nfor (var i = 0, len = sessionStorage.length; i < len; i++) {\n   var key = sessionStorage.key(i);\n   var value = sessionStorage.getItem(key);\n   values.push({key: key, value: value});\n}\nvalues.length == sessionStorage.length; // True\nvalues[0].key == \"book\"; // True*\nvalues[0].value == \"Learn HTML5\"; // True*\n```", "```js\nvar dbName = \"myDatabase\";\nvar dbVersion = 1;\nvar request = indexedDB.open(dbName, dbVersion);\n```", "```js\nvar dbName = \"myDatabase\";\nvar dbVersion = 1;\nvar db = null;\nvar request = indexedDB.open(dbName, dbVersion);\nrequest.onerror = function(event) {\n   console.log(\"Error:\", event);\n};\nrequest.onsuccess = function(event) {\n   db = event.target.result;\n};\n```", "```js\nvar dbName = \"myDatabase\";\nvar dbVersion = 1;\nvar db = null;\nvar store = null;\nvar request = indexedDB.open(dbName, dbVersion);\nrequest.onupgradeneeded = function(event) {\n   db = event.target.result;\n   store = db.createObjectStore(\"myDataStore\", {keyPath: \"myKey\"});\n};\n```", "```js\nrequest.onupgradeneeded = function(event) {\n  var settings = {\n    keyPath: \"myKey\",\n    autoIncrement: true\n  };\n  db = event.target.result;\n  store = db.createObjectStore(\"myDataStore\", settings);\n};\n```", "```js\nvar TodoItem = function(task) {\n  this.task = task;\n  this.completed = false;\n};\ntry {\n  var trans = db.transaction(storeName, \"readwrite\");\n  var store = trans.objectStore(storeName);\n  var task1 = new TodoItem(\"Buy more pizza\");\n  var task2 = new TodoItem(\"Finish writing the book\");\n  var task3 = new TodoItem(\"Shave before going to work\");\n  var request = store.put(task1);\n  // We can reuse this request object to store multiple objects\n  request = store.put(task2);\n  request = store.put(task3);\n  request.onsuccess = function(e) {\n    log(\"Success!\" + value.key);\n  };\n  request.onerror = function(e) {\n    log(e.stack);\n  };\n} catch (e) {\n   log(e.stack);\n}\n```", "```js\nrequest.onupgradeneeded = function(event) {\n  var settings = {\n    keyPath: \"myKey\",\n    autoIncrement: true\n  };\n  db = event.target.result;\n  store = db.createObjectStore(\"myDataStore\", settings);\n  var indexSettings = {\n    unique: true\n  };\n  store.createIndex(\"taskIndex\", \"task\", indexSettings);\n};\n```", "```js\nvar TodoItem = function(task) {\n  this.task = task;\n  this.completed = false;\n};\nfunction getTask(taskName, callback) {\n  // 1\\. Open a transaction. Since we don't need to write anything to\n  // the data store, a simple readonly transaction will sufice.\n  var trans = db.transaction(storeName, \"readonly\");\n  var store = trans.objectStore(storeName);\n  // 2\\. specify an index to use, and the data to get from it\n  var req = store.index(\"taskIndex\").get(taskName);\n  req.onsuccess = function(e) {\n    var todoItem = e.target.result;\n    // todoItem.task => \"Buy more pizza\"\n    // todoItem.completed => false\n    callback(todoItem);\n  };\n  req.onerror = function(e) {\n    // Handle error\n  };\n};\n// Search for a TodoItem object with a task property of \"Buy more pizza\"\ngetTask(\"Buy more pizza\", function(taskItem) {\n  console.log(\"TaskItem object: \" + taskItem.task);\n});\n```", "```js\nvar TodoItem = function(task) {\n  this.task = task;\n  this.completed = false;\n};\nfunction getTask(taskName, callback) {\n  // 1\\. Open a transaction. Since we don't need to write anything to\n  // the data store, a simple readonly transaction will sufice.\n  var trans = db.transaction(storeName, \"readonly\");\n  var store = trans.objectStore(storeName);\n  // 2\\. specify the range in the data store to request data from\n  var keyRange = IDBKeyRange.lowerBound(0);\n  var req = store.openCursor(keyRange);\n  req.onsuccess = function(e) {\n    // cursor IDBCursorWithValue\n    //   key : int\n    //   primaryKey : int\n    //   source : IDBObjectStore\n    //   value : Object\n    //\n    var cursor = e.target.result;\n    // Before we continue, we need to make sure that we\n    // haven't hit the end of the result set\n    if (!cursor) {\n      callback();\n    }\n    // If there are still results, let's process them\n    //    cursor.value === todoItem\n    //    cursor.value.task => \"Buy more pizza\"\n    //    cursor.value.completed => false\n    // Since results are plain, typeless object literals, we need to rebuild\n    // each object from scratch.\n    var todoItem = new TodoItem(cursor.value.task);\n    todoItem.myKey = cursor.value.myKey;\n    todoItem.completed = cursor.value.completed;\n    todoItems.push(todoItem);\n     // Tell the cursor to fetch the next result\n      cursor.continue();\n  };\n  req.onerror = function(e) {\n    // Handle error\n  };\n};\n// Retrieve every TodoItem in the data store\nvar todoItems = new Array();\ngetTask(\"Buy more pizza\", function() {\n  for (var i = 0; i < todoItems.length; i++) {\n    console.log(\"TaskItem object: \" + todoItems[i].task);\n  }\n})\n```", "```js\nvar TodoItem = function(task) {\n  this.task = task;\n  this.completed = false;\n  this.toHTML = function() {\n    var el = document.createElement(\"li\");\n    el.textContent = this.task;\n    if (this.completed) {\n      el.style.textDecoration = \"line-through\";\n    }\n    return el;\n  };\n};\nfunction inflatObject(class, object) {\n  // 1\\. Create an instance of whatever class we reference\n  var obj = new class();\n  // 2\\. Copy every property from the object returned by the cursor\n  // into the newly created object\n  for (var property in object) {\n    obj[property] = object[property];\n  }\n  // 3\\. Return the inflated object\n  return obj;\n}\n// \u2026\nvar req = store.openCursor(keyRange);\nreq.onsuccess = function(e) {\n  var cursor = e.target.result;\n  // Before we continue, we need to make sure that we\n  // haven't hit the end of the result set\n  if (!cursor) {\n    callback();\n  }\n  var todoItem = inflatObject(TodoItem, cursor.value);\n  // We could even call methods on the new inflated object\n  var itemElement = todoItem.toHTML();\n  document.body.appendChild(itemElement);\n  todoItem.myKey == cursor.myKey; // True\n  todoItem.task == cursor.task; // True\n  todoItem.completed == cursor.completed; // True\n  todoItems.push(todoItem);\n  // Tell the cursor to fetch the next result\n  cursor.continue();\n};\n```", "```js\nfunction deleteTask(taskId, callback) {\n  // 1\\. Open a transaction. Since we definitely need to change the object\n  // in the data store, we need proper access and benefits\n  var trans = db.transaction(storeName, \"readwrite\");\n  var store = trans.objectStore(storeName);\n  // 2\\. specify an index to use, and the data to get from it\n  var req = store.delete(taskId);\n  req.onsuccess = function(e) {\n    // Do something, then call callback\n  };\n  req.onerror = function(e) {\n    // Handle error\n  };\n};\n```", "```js\nvar trans = db.transaction(storeName, \"readwrite\");\nvar store = trans.objectStore(storeName);\nvar req = store.clear();\nreq.onsuccess = function(e) {\n  // Do something, then call callback\n};\nreq.onerror = function(e) {\n  // Handle error\n};\n```", "```js\n  // 1\\. Be sure to set the transaction to readwrite. Else, there will be a nice\n  // exception raised if we try to delete readonly data.\n  var trans = db.transaction(storeName, \"readwrite\");\n  var store = trans.objectStore(storeName);\n  // 2\\. specify the range in the data store to request data from\n  var keyRange = IDBKeyRange.lowerBound(0);\n  var req = store.openCursor(keyRange);\n  req.onsuccess = function(e) {\n    var cursor = e.target.result;\n    // Before we continue, we need to make sure that we\n    // haven't hit the end of the result set\n    if (!cursor) {\n      callback();\n    }\n    // Here, we could have accessed the object's primary ID through\n    // the cursor object in cursor.value.myKey. However, accessing\n    // cursor.primaryKey maps to the specific property name that holds\n    // the value of the primary key.\n    store.delete(cursor.primaryKey);\n    // Tell the cursor to fetch the next result\n    cursor.continue();\n  };\n```", "```js\nfunction setHighScore(newScore, el) {\n  var element = document.querySelector(el);\n  // Multiply by 1 to cast the value from a string to a number\n  var score = localStorage.getItem(\"high-score\") * 1;\n  // Check if there is a numerical score saved\n  if (score && !isNaN(score)) {\n    // Check if new score is higher than current high score\n    if (newScore > element.textContent * 1) {\n      localStorage.setItem(\"high-score\", newScore);\n      element.textContent = newScore;\n    } else {\n        element.textContent = score;\n    }\n  } else {\n    localStorage.setItem(\"high-score\", newScore);\n    element.textContent = newScore;\n  }\n}\n```", "```js\nfunction saveEvent(event, snake, fruit) {\n  var eventObj = sessionStorage.getItem(event);\n  // If this is the first time the event is set, create its structure\n  if (!eventObj)  {\n    eventObj = {\n      snake: new Array(),\n      fruit: new Array()\n    };\n    eventObj.snake.push(snake);\n    eventObj.fruit.push(fruit);\n    eventObj = JSON.stringify(eventObj);\n    sessionStorage.setItem(event, eventObj);\n  } else {\n    eventObj = JSON.parse(eventObj);\n    eventObj.snake.push(snake);\n    eventObj.fruit.push(fruit);\n    eventObj = JSON.stringify(eventObj);\n    sessionStorage.setItem(event, eventObj);\n  }\n  return JSON.parse(eventObj);\n}\n```", "```js\nfunction clearEvent(event) {\n  return sessionStorage.removeItem(event);\n}\n```", "```js\nif (fruit.isAt(head.x, head.y)) {\n  // Save current game state\n  saveEvent(\"eat\", snake.getBody(), fruit.position);\n  fruit.reset();\n  snake.grow();\n  score.up();\n  // Save high score if needed\n  setHighScore(document.querySelector(\"#scores h3:first-child span\").textContent);\n}\n// \u2026\nif (!snake.isAlive()) {\n  saveEvent(\"die\", snake.getBody(), fruit.position);\n}\n```", "```js\n// Use each cached buffer to generate each screen shot\nfunction getEventPictures(event, canvas) {\n  // Take the buffer from session storage\n  var obj = sessionStorage.getItem(event);\n  // Create an array to hold the generated images\n  var screenShots = new Array();\n  if (!obj)\n    return screenShots\n  obj = JSON.parse(obj);\n  var canvas = canvas.cloneNode();\n  var renderer = new Renderer(canvas);\n  // Go through each game state, and simply draw the data as though it\n  // was being drawn for the actual game in action\n  for (var i = 0, len = obj.snake.length; i < len; i++) {\n    renderer.clear();\n    renderer.draw(obj.snake[i], snake.getSkin());\n    renderer.draw(obj.fruit[i], fruit.img);\n    var screenShot = renderer.toImg();\n    screenShots.push(screenShot);\n  }\n  return screenShots;\n}\n// Display a list of images to the user\nfunction drawScreenShots(imgs) {\n  var panel = document.querySelector(\"#screenShots\");\n  for (var i = 0, len = imgs.length; i < len; i++) {\n    var a = document.createElement(\"a\");\n    a.target = \"_blank\";\n    a.href = imgs[i].src;\n    a.appendChild(imgs[i]);\n    panel.appendChild(a);\n  }\n}\n```"]