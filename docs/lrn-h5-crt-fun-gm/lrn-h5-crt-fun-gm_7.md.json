["```js\nwindow.requestAnimationFrame = (function() {\n\n  // Check if the unprefixed version is present\n  if (window.requestAnimationFrame) {\n    return window.requestAnimationFrame;\n  }\n\n  // Check for WebKit based implementation\n  if (window.webkitRequestAnimationFrame) {\n    return window.webkitRequestAnimationFrame;\n  }\n\n  // Check for Mozilla based implementation\n  if (window.mozRequestAnimationFrame) {\n    return window.mozRequestAnimationFrame;\n  }\n\n  // Check for Microsoft based implementation\n  if (window.msRequestAnimationFrame) {\n    return window.msRequestAnimationFrame;\n  }\n\n  // Check for Opera based implementation\n  if (window.oRequestAnimationFrame) {\n    return window.oRequestAnimationFrame;\n  }\n\n  // If nothing else, simulate the functionality with\n  // something similar - a custom timer\n  return function(callback) {\n    var fps = 1000 / 60;\n    var timestamp = Date.now();\n\n    setTimeout(function(){\n      callback(timestamp);\n    }, fps);\n  };\n})();\n```", "```js\n// ---------------------------------\n// Default Stylesheet: style.css\n// ---------------------------------\n.background-img {\n  background: url(\"/img/bg.png\");\n}\n\n// ---------------------------------\n// HTML Template: template.html\n// ---------------------------------\n<div id=\"container\" class=\"background-img\"></div>\n```", "```js\n// ---------------------------------\n// Enhanced Stylesheet: enhanced.css\n// ---------------------------------\n\n@-webkit-keyframes animagedBg {\n  from {\n    background-position: 0 0;\n  }\n  to {\n    background-position: 1300% 600%;\n  }\n}\n\n.anim-background {\n  -webkit-animation: animagedBg;\n  -webkit-animation-duration: 500s;\n  -webkit-animation-timing-function: linear;\n  -webkit-animation-iteration-count: infinite;\n}\n\n// ---------------------------------\n// JavaScript Detection: main.js\n// ---------------------------------\n\n// Returns true if the browser is mobile\nfunction isMobile(userAgent) {\n  var mobileAgents = [\n    \"ANDROID\",\n    \"BLACKBERRY\",\n    \"IPHONE\",\n    \"IPAD\",\n    \"IPHONE\",\n    \"OPERA MINI\",\n    \"IEMOBILE\"\n  ];\n\n  return mobileAgents.indexOf(userAgent.toUpperCase()) >= 0;\n}\n\nvar mobile = isMobile(navigator.userAgent);\n\n// If the browser is not mobile, add enhanced CSS functionality\nif (!mobile) {\n  var container = document.querySelector(\"#container\");\n  container.classList.add(\"anim-background\");\n}\n```", "```js\n// ---------------------------------\n// Media queries on the HTML file\n// ---------------------------------\n<link rel=\"stylesheet\"\n  media=\"screen and (min-device-width: 960px)\"\n  href=\"default-style.css\" />\n\n// ---------------------------------\n// Media queries within a CSS file\n// ---------------------------------\n@media screen and (min-device-width: 960px) {\n  html, body {\n    margin: 0;\n    padding: 0;\n  }\n\n  /* ... */\n}\n```", "```js\n// Applies media queries to:\n// viewport width between [200px, 450px] OR wider than orequals to 1200px\n@media\n  all and (min-width: 200px) and (max-width: 450px),\n  (min-width: 1200px) {\n  /* ... */\n}\n\n// Applies media queries to:\n// non-printer viewport width between [200px, 450px]\n// OR any media type wider than or equal to 1200px\n@media\n  not print and (min-width: 200px) and (max-width: 450px),\n  all (min-width: 1200px) {\n  /* ... */\n}\n```", "```js\n@media all and (min-width: 250px) {\n  body {\n    background: red;\n  }\n}\n\n@media all and (max-width: 249px) {\n  body {\n    background: blue;\n  }\n}\n```", "```js\n@media print and (min-width: 7.0in) {\n  h1 {\n    color: red;\n  }\n}\n\n@media print and (max-width: 6.5in) {\n  h1 {\n    color: blue;\n  }\n}\n```", "```js\n@media all and (min-height: 500px) {\n  article {\n    width: 100%;\n    float: none;\n  }\n}\n\n@media all and (max-height: 499px) {\n  article {\n    width: 33%;\n    float: left;\n  }\n}\n```", "```js\n@media all and (min-device-width: 1601px) {\n  h1 {\n    color: red;\n  }\n}\n\n@media all and (max-device-width: 1599px) {\n  h1 {\n    color: green;\n  }\n}\n\n@media all and (device-width: 1600px) {\n  h1 {\n    color: blue;\n  }\n}\n```", "```js\n@media all and (orientation: portrait) {\n  body {\n    backgroundcolor: red;\n  }\n}\n\n@media all and (orientation: landscape) {\n  body {\n    backgroundcolor: green;\n  }\n}\n\n@media all and\n  not (orientation: portrait) and\n  not (orientation: portrait) {\n  body {\n    backgroundcolor: blue;\n  }\n}\n```", "```js\n// Aspect ratio is exactly twice as high as wide\n@media all and (aspect-ratio: 1/2) {\n  h1 {\n    color: blue;\n    font-size: 1.0em;\n  }\n}\n\n// Aspect ratio is at least three times as high as wide\n@media all and (min-aspect-ratio: 1/3) {\n  h1 {\n    color: red;\n    font-size: 0.5em;\n  }\n}\n\n// Aspect ratio is no more than four times as wide as high\n@media all and (max-aspect-ratio: 4/1) {\n  h1 {\n    color: green;\n    font-size: 3.0em;\n  }\n}\n\n// Aspect ratio is an exact square\n@media all and (aspect-ratio: 1/1) {\n  h1 {\n    color: yellow;\n    font-size: 2.0em;\n  }\n}\n\n// Aspect ratio is no more than half as high as wide \u2013 ERROR!\n@media all and (max-aspect-ratio: 1/0.5) {\n  h1 {\n    color: green;\n    font-size: 3.0em;\n  }\n}\n```", "```js\n// Aspect ratio evaluates to 1/1\n@media all and (device-aspect-ratio: 1/1) {\n  h1 {\n    color: blue;\n    font-size: 3.0em;\n  }\n}\n\n// Aspect ratio evaluates to 1/1\n@media all and (device-aspect-ratio: 1/1) {\n  h1 {\n    color: red;\n    font-size: 3.0em;\n  }\n}\n\n// Aspect ratio evaluates to 1/1\n@media all and (device-aspect-ratio: 2/2) {\n  h1 {\n    color: green;\n    font-size: 0.5em;\n  }\n}\n\n// Aspect ratio evaluates to 1/1\n@media all and (device-aspect-ratio: 10/10) {\n  h1 {\n    color: purple;\n    font-size: 0.5em;\n  }\n}\n\n// Aspect ratio evaluates to 1/1\n@media all and (device-aspect-ratio: 2000/2000) {\n  h1 {\n    color: orange;\n    font-size: 10.5em;\n  }\n}\n\n// Aspect ratio evaluates to 1/1\n@media all and (device-aspect-ratio: 17/17) {\n  h1 {\n    color: transparent;\n    font-size: 0.0em;\n    display: none;\n  }\n}\n```", "```js\n// Aspect ratio evaluates to 1/1\n//  Properties set: color, font-size\n//  Properties overridden: none\n@media all and (device-aspect-ratio: 1/1) {\n  h1 {\n    color: blue;\n    font-size: 1.5em;\n  }\n}\n\n// Aspect ratio evaluates to 1/1\n//  Properties set: color, border, padding\n//  Properties overridden: color\n@media all and (device-aspect-ratio: 1/1) {\n  h1 {\n    color: red;\n    border: 1px solid green;\n    padding: 20px;\n  }\n}\n\n// Aspect ratio evaluates to 1/1 and anything landscape\n//  Properties set: color\n//  Properties overridden: color\n@media all and (min-device-aspect-ratio: 1/1) {\n  h1 {\n    color: green;\n  }\n}\n```", "```js\n@media all and (device-aspect-ratio: 1/1) {\n  h1 {\n    color: green;\n    border: 1px solid green;\n    padding: 20;\n  }\n}\n```", "```js\n@media all and (color: 2) {\n  h1 {\n    color: green;\n    border: 1px solid green;\n    padding: 20;\n  }\n}\n```", "```js\n@media all and (color: 0) {\n  h1 {\n    color: green;\n    border: 1px solid green;\n    padding: 20;\n  }\n}\n// This query produces the exact same result as the previous one\n@media all and (min-color: 1) {\n  h1 {\n    color: green;\n    border: 1px solid green;\n    padding: 20;\n  }\n}\n```", "```js\n@media all and (color-index: 256) {\n  h1 {\n    color: green;\n    border: 1px solid green;\n    padding: 20;\n  }\n}\n```", "```js\n@media all and (monochrome: 1) {\n  h1 {\n    color: black;\n    border: 1px solid black;\n    padding: 20;\n  }\n}\n```", "```js\n@media not all and (monochrome) {\n  h1 {\n    color: red;\n    border: 1px solid purple;\n    padding: 20;\n  }\n}\n\n// This query produces the exact same result as the previous one\n@media all and (color) {\n  h1 {\n    color: red;\n    border: 1px solid purple;\n    padding: 20;\n  }\n}\n```", "```js\n@media all and (resolution: 300dpi) {\n  h1 {\n    color: black;\n    border: 1px solid black;\n    padding: 20;\n  }\n}\n```", "```js\n@media all and (scan: interlace) {\n  h1 {\n    color: black;\n    border: 1px solid black;\n    padding: 20;\n  }\n}\n\n@media all and (scan: progressive) {\n  h1 {\n    color: red;\n    border: 1px solid red;\n    padding: 20;\n  }\n}\n```", "```js\n// Evaluates to true on grid-based devices\n@media all and (grid) {\n  h1 {\n    color: black;\n    border: 1px solid black;\n    padding: 20;\n  }\n}\n\n// Evaluates to true on grid-based devices\n@media all and (grid: 1) {\n  h1 {\n    color: black;\n    border: 1px solid black;\n    padding: 20;\n  }\n}\n\n// Evaluates to true on bitmap-based devices\n@media all and (grid: 0) {\n  h1 {\n    color: black;\n    border: 1px solid black;\n    padding: 20;\n  }\n}\n\n// Evaluates to true on bitmap-based devices\n@media not all and (grid) {\n  h1 {\n    color: black;\n    border: 1px solid black;\n    padding: 20;\n  }\n}\n```", "```js\ndocument.body.addEventListener(\"touchstart\", doOnTouchStart);\n\nfunction doOnTouchStart(event) {\n  event.preventDefault();\n\n  // ...\n}\n```", "```js\ndocument.body.addEventListener(\"touchend\", doOnTouchEnd);\n\nfunction doOnTouchEnd(event) {\n  event.preventDefault();\n\n  // ...\n}\n```", "```js\ndocument.body.addEventListener(\"touchmove\", doOnTouchMove);\n\nfunction doOnTouchMove(event) {\n  event.preventDefault();\n\n  // ...\n}\n```", "```js\n<meta name=\"viewport\"\n  content=\"width=device-width, initial-scale=1.0,\n    user-scalable=no\" />\n```", "```js\n<style>\nbody, html {\n  width: 200%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  position: relative;\n  top: 0;\n  left: 0;\n}\n\ndiv {\n  position: absolute;\n  background: #c00;\n  border-radius: 100px;\n}\n</style>\n```", "```js\n// Global array that keeps track of all active touches.\n// Each element of this array is a DOM element representingthe location\n// and area of each touch.\nvar touches = new Array();\n\n// Draw each DOM element in the touches array\nfunction drawTouches() {\n  for (var i = 0, len = touches.length; i < len; i++) {\n    document.body.appendChild(touches[i]);\n  }\n}\n\n// Deletes every DOM element drawn on screen\nfunction clearMarks() {\n  var marks = document.querySelectorAll(\"div\");\n\n  for (var i = 0, len = marks.length; i < len; i++) {\n    document.body.removeChild(marks[i]);\n  }\n}\n\n// Create a DOM element for each active touch detected by the\n// input device. Each node is positioned where the touch was\n// detected, and has a width and height close to what the device\n// determined each touch was\nfunction addTouch(event) {\n  // Get a reference to the touches TouchList\n  var _touches = event.touches;\n\n  // Flush the current touches array\n  touches = new Array();\n\n  for (var i = 0, len = _touches.length; i < len; i++) {\n    var width = _touches[i].webkitRadiusX * 20;\n    var height = _touches[i].webkitRadiusY * 20;\n\n    var touch = document.createElement(\"div\");\n    touch.style.width = width + \"px\";\n    touch.style.height = height + \"px\";\n    touch.style.left = (_touches[i].pageX - width / 2) + \"px\";\n    touch.style.top = (_touches[i].pageY - height / 2) + \"px\";\n\n    touches.push(touch);\n  }\n}\n\n// Cancel the default behavior for a drag gesture,\n// so that the application doesn't scroll.\ndocument.body.addEventListener(\"touchmove\", function(event) {\n  event.preventDefault();\n});\n\n// Register our function for all the touch events we want to track.\ndocument.body.addEventListener(\"touchstart\", addTouch);\ndocument.body.addEventListener(\"touchend\", addTouch);\ndocument.body.addEventListener(\"touchmove\", addTouch);\n\n// The render loop\n(function render() {\n  clearMarks();\n  drawTouches();\n\n  requestAnimationFrame(render);\n})();\n```", "```js\nvar width = _touches[i].webkitRadiusX * 20;\nvar height = _touches[i].webkitRadiusY * 20;\nvar force = _touches[i].webkitForce;\n\nvar touch = document.createElement(\"div\");\ntouch.style.width = width + \"px\";\ntouch.style.height = height + \"px\";\ntouch.style.left = (_touches[i].pageX - width / 2) + \"px\";\ntouch.style.top = (_touches[i].pageY - height / 2) + \"px\";\ntouch.style.opacity = force;\n\ntouches.push(touch);\n```", "```js\nbody, html {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\nbody {\n  background: url(\"../img/space-bg-01.jpg\") repeat;\n}\n```", "```js\n/**\n * Make the background image continually move up and to the left,\n * giving the illusion that the game world is scrolling at anangle.\n */\n@-webkit-keyframes NebulaBg {\n  from {\n    background-position: 0 0;\n  }\n  to {\n    background-position: 1300% 600%;\n  }\n}\n\n/**\n * Add the animation to this class, and add a transition\n * to any box-shadow applied to whatever element this class isattached to.\n */\n.animBody {\n  -webkit-transition: box-shadow 8s;\n\n  -webkit-animation: NebulaBg;\n  -webkit-animation-duration: 500s;\n  -webkit-animation-timing-function: linear;\n  -webkit-animation-iteration-count: infinite;\n}\n```", "```js\n.energyBar {\n  position: absolute;\n  top: 2%;\n  left: 4%;\n  z-index: 99999;\n  width: 92%;\n  height: 25px;\n  border: 1px solid #ff5;\n  background: #c00;\n  overflow: hidden;\n}\n\n.energyBar div {\n  background: #ff5;\n  height: 100%;\n  width: 100%;\n  -webkit-transition: width 0.2s;\n}\n```", "```js\n// Namespace the component in order to keep the global namespaceclean\nvar Packt = Packt || {};\nPackt.Components = Packt.Components || {};\n\nPackt.Components.Component = function(entity) {\n  var entity = entity;\n\n  this.doSomething = function() {\n};\n```", "```js\nvar Packt = Packt || {};\nPackt.Components = Packt.Components || {};\nPackt.Components.Sprite = function(pEntity, pImgSrc, pWidth, pHeight) {\n  var entity = pEntity;\n  var img = new Image();\n  img.src = pImgSrc;\n\n  var width = pWidth;\n  var height = pHeight;\n  var sWidth = pWidth;\n  var sHeight = pHeight;\n  var sX = 0;\n  var sY = 0;\n  var ctx = null;\n\n  // Inject the canvas context where the rendering of the entity\n  // managed by this component is done\n  function setCtx(context) {\n    ctx = context;\n  }\n\n  // Public access to the private function setCtx\n  this.setCtx = setCtx;\n\n  // If the image used to render the entity managed by thiscomponent\n  // is part of an atlas, we can specify the specific region\n  // within the atlas that we want rendered\n  this.setSpriteCoords = function(x, y, width, height) {\n    sX = x;\n    sY = y;\n    sWidth = width;\n    sHeight = height;\n  };\n\n  // Render the entity\n  this.update = function() {\n    if (ctx && entity.isActive()) {\n      var pos = entity.getPosition();\n      ctx.drawImage(img, sX, sY, sWidth, sHeight, pos.x, pos.y,width, height);\n    }\n  };\n\n  // Return both values at once, instead of using two getterfunctions\n  this.getSize = function() {\n    return {\n      width: width,\n      height: height\n    };\n  };\n};\n```", "```js\nvar Packt = Packt || {};\nPackt.Components = Packt.Components || {};\n\nPackt.Components.Move = function(entity, speed) {\n  var entity = entity;\n  var speed = speed;\n  var direction = new Packt.Vec2(0, 0);\n\n  // Move the entity in the direction it is facing by a constantspeed\n  this.update = function() {\n    var pos = entity.getPosition();\n    direction.normalize();\n\n    var newPos = {\n      x: pos.x + direction.get(\"x\") * speed,\n      y: pos.y + direction.get(\"y\") * speed\n    };\n\n    entity.setPosition(newPos);\n  };\n\n  // Allow the input mechanism to tell the entity where to move\n  this.setDirection = function(x, y) {\n    direction.set(x, y);\n  };\n};\n```", "```js\nvar Packt = Packt || {};\nPackt.Components = Packt.Components || {};\n\nPackt.Components.TouchDrag = function(entity, canvas) {\n  var entity = entity;\n  var canvas = canvas;\n  var isDown = false;\n  var pos = entity.getPosition();\n\n  canvas.getCanvas().addEventListener(\"touchstart\", doOnTouchDown);\n  canvas.getCanvas().addEventListener(\"touchend\", doOnTouchUp);\n  canvas.getCanvas().addEventListener(\"touchmove\", doOnTouchMove);\n\n  // Set a isDown flag on the entity, indicating that the playeris currently\n  // touching the entity that is to be controlled\n  function doOnTouchDown(event) {\n    event.preventDefault();\n    var phy = entity.getComponent(\"physics\");\n    var touch = event.changedTouches;\n\n    if (phy) {\n      isDown = phy.collide(touch.pageX, touch.pageY, 0, 0);\n    }\n  }\n\n  // Whenever the player releases the touch on the screen,\n  // we must unset the isDown flag\n  function doOnTouchUp(event) {\n    event.preventDefault();\n    isDown = false;\n  }\n\n  // When the player drags his/her finger across the screen,\n  // store the new touch position if and only if the player\n  // is actually dragging the entity\n  function doOnTouchMove(event) {\n    event.preventDefault();\n    var touch = event.changedTouches;\n\n    if (isDown) {\n      pos.x = touch.pageX;\n      pos.y = touch.pageY;\n    }\n  }\n\n  // Reposition the player's entity so that its center is placed\n  // right below the player's finger\n  this.centerEntity = function() {\n    if (isDown) {\n      var sprite = entity.getComponent(\"sprite\");\n\n      if (sprite) {\n        var size = sprite.getSize();\n        var x = pos.x - size.width / 2;\n        var y = pos.y - size.height / 2;\n\n        entity.setPosition({x: x, y: y});\n      }\n    }\n  };\n\n  this.getPosition = function() {\n    return pos;\n  };\n};\n```", "```js\nvar Packt = Packt || {};\nPackt.Components = Packt.Components || {};\n\nPackt.Components.Physics = function(entity) {\n  var entity = entity;\n\n  // Check if these two rectangles are intersecting\n  this.collide = function(x, y, w, h) {\n    var sprite = entity.getComponent(\"sprite\");\n    if (sprite) {\n      var pos = entity.getPosition();\n      var size = sprite.getSize();\n\n      if (pos.x > x + w) {\n        return false;\n      }\n\n      if (pos.x + size.width < x) {\n        return false;\n      }\n\n      if (pos.y > y + h) {\n        return false;\n      }\n\n      if (pos.y + size.height < y) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  // Return the entity's location and dimensions\n  this.getBodyDef = function() {\n    var pos = entity.getPosition();\n    var sprite = entity.getComponent(\"sprite\");\n    var size = sprite.getSize() || {width: 0, height: 0};\n\n    return {\n      x: pos.x,\n      y: pos.y,\n      width: size.width,\n      height: size.height\n    };\n  };\n};\n```", "```js\nvar Packt = Packt || {};\nPackt.Components = Packt.Components || {};\nPackt.Components.Strength = function(pEntity, pHP, pEnergy) {\n  var entity = pEntity;\n  var hp = pHP;\n  var energy = pEnergy;\n\n  // This is how much damage the entity causes to other entities\n  // upon collision between the two\n  this.getHP = function() {\n    return hp;\n  };\n\n  // This represents how much energy the entity has left. When\n  // the energy gets to or below zero, the entity dies\n  this.getEnergy = function() {\n    return energy;\n  };\n\n  // Update the entity's energy levels\n  this.takeDamage = function(damage) {\n    energy -= damage;\n    return energy;\n  };\n};\n```", "```js\nvar Packt = Packt || {};\nPackt.Components = Packt.Components || {};\n\nPackt.Components.LaserGun = function(entity, canvas, maxShots) {\n  var entity = entity;\n  var MAX_SHOTS = maxShots;\n  var canvas = canvas;\n  var shots = new Array();\n  var shotsPerSec = 1000 / 15;\n  var timeLastShot = 0;\n\n  // Move all lasers forward, and remove any lasers outsidethe screen\n  this.update = function() {\n    for (var i = 0, len = shots.length; i < len; i++) {\n      try {\n        shots[i].update();\n        var shotPos = shots[i].getPosition();\n\n        if (shotPos.y < -100) {\n          shots.splice(i, 1);\n        }\n      } catch (e) {}\n    }\n  };\n\n  // Create a new laser entity, and assign all of the components\n  // it will need in order to actually destroy other ships\n  this.add = function(x, y) {\n    var time = Date.now();\n\n    // Don't add a new laser until at least some time has passed,\n    // so that we don't fire too many lasers at once\n    if (time - timeLastShot >= shotsPerSec) {\n\n      // Restrict the amount of lasers that can be on the screenat once\n      if (shots.length < MAX_SHOTS) {\n        var shot = new Packt.Entity(Packt.ENTITY_TYPES.BULLET, x, y);\n        var spriteComp = new Packt.Components.Sprite(\n          shot, \"./img/laser-blue.png\", 8, 32);\n        spriteComp.setCtx(canvas.getContext());\n        var strengthComp = new Packt.Components.Strength(shot, 10, 0);\n        var physComp = new Packt.Components.Physics(shot);\n        var mockMove = new Packt.Components.Move(shot, 15);\n\n        shot.addComponent(\"sprite\", spriteComp);\n        shot.addComponent(\"move\", mockMove);\n        shot.addComponent(\"physics\", physComp);\n        shot.addComponent(\"strength\", strengthComp);\n\n        shot.setOnUpdate(function() {\n          mockMove.setDirection(0, -1);\n          mockMove.update();\n        });\n\n        shots.push(shot);\n      }\n\n      timeLastShot = time;\n    }\n  };\n\n  // Return a list of active shots\n  this.getShots = function() {\n    return shots;\n  };\n};\n```", "```js\nvar Packt = Packt || {};\nPackt.ENTITY_TYPES = {\n  SHIP: 0,\n  BULLET: 1\n};\n\nPackt.Entity = function(type, x, y) {\n  var type = type;\n  var pos = {\n    x: x,\n    y: y\n  };\n\n  var isActive = true;\n  var components = new Object();\n\n  // Make this function empty by default, and allow the user tooverride it\n  var update = function(){};\n\n  // Add a component to this entity if one by this name has notyet been added\n  function addComponent(key, component) {\n    if (!components[key]) {\n      components[key] = component;\n    }\n\n    return component;\n  }\n\n  // Attempt to remove an entity by its name\n  function removeComponent(key) {\n    if (components[key]) {\n      return delete components[key];\n    }\n\n    return false;\n  }\n\n  // Return a reference to a component\n  function getComponent(key) {\n    return components[key] || null;\n  }\n\n  // Draw this component\n  function draw() {\n    if (components.sprite) {\n      components.sprite.update();\n    }\n  }\n\n  // Expose these functions through a public interface\n  this.addComponent = addComponent;\n  this.removeComponent = removeComponent;\n  this.getComponent = getComponent;\n  this.getPosition = function() {\n    return pos;\n  };\n\n  this.setPosition = function(newPos) {\n    pos = newPos;\n  };\n\n  this.isActive = function() {\n    return isActive;\n  };\n\n  this.setActive = function(active) {\n    isActive = active;\n  };\n\n  this.draw = draw;\n  this.update = update;\n  this.update = function() {\n    update();\n  };\n  // Save a reference to a new update callback function\n  this.setOnUpdate = function(cb){\n    update = cb;\n  };\n};\n```", "```js\nvar Packt = Packt || {};\nPackt.Widgets = Packt.Widgets || {};\n\nPackt.Widgets.EnergyBar = function(cssClass) {\n  var energy = 100;\n\n  // Create the DOM element to represent this widget on screen\n  var container = document.createElement(\"div\");\n  container.classList.add(cssClass);\n\n  var bar = document.createElement(\"div\");\n  bar.style.width = energy + \"%\";\n  container.appendChild(bar);\n\n  // Return the DOM element so it can be appended to the document\n  this.getElement = function() {\n    return container;\n  };\n\n  // Increase the player's energy level and update the DOM element\n  // that represents it on screen. To decrease the energy level, simply\n  // pass a negative number to this function\n  this.addEnergy = function(amount) {\n    energy += amount;\n    bar.style.width = energy + \"%\";\n  };\n\n  // Set the energy level directly, instead of just adding to\n  // or removing from it\n  this.setEnergy = function(amount) {\n    energy = amount;\n    bar.style.width = energy + \"%\";\n  };\n};\n```", "```js\n// Namespace the canvas abstraction\nvar Packt = Packt || {};\n\n// Construct a canvas of an arbitrary size\nPackt.Canvas = function(w, h) {\n  var width = w;\n  var height = h;\n  var canvas = document.createElement(\"canvas\");\n\n  canvas.width = width;\n  canvas.height = height;\n\n  var ctx = canvas.getContext(\"2d\");\n\n  this.getCanvas = function() {\n    return canvas;\n  };\n\n  this.getContext = function() {\n    return ctx;\n  };\n\n  this.getWidth = function() {\n    return width;\n  };\n\n  this.getHeight = function() {\n    return height;\n  };\n\n  // Allow the client to clear the entire rendering buffer without\n  // needing to know how things are done under the hood, andwithout\n  // anyone needing to worry about the width and height of thecanvas\n  this.clear = function() {\n    ctx.clearRect(0, 0, width, height);\n  };\n};\n```", "```js\n// Namespace the enemy manager object\nvar Packt = Packt || {};\n\nPackt.EnemyManager = function(canvas) {\n  var entities = new Array();\n  var canvas = canvas;\n  var worldWidth = canvas.getWidth();\n  var worldHeight = canvas.getHeight();\n\n  // By returning the list of active enemies to the client code,\n  // we can pass on the responsibility of rendering each entity,\n  // as well as allow other components to interact with theentities\n  this.getEntities = function() {\n    return entities;\n  };\n\n  // Create a new entity at a certain screen location, along\n  // with a list of components\n  function addEnemies(x, y, components) {\n    var entity = new Packt.Entity(Packt.ENTITY_TYPES.SHIP, x || 0,y || -100);\n    for (var c in components) {\n      entity.addComponent(c, components[c]);\n    };\n\n    var strengthComp = new Packt.Components.Strength(entity, 0.5, 25);\n    var physComp = new Packt.Components.Physics(entity);\n    var mockMove = new Packt.Components.Move(entity, (Math.random() * 5 >> 0) + 2);\n\n    var enemySprite = \"./img/enemy-red.png\";\n\n    // Randomly assign a different skin to the sprite component\n    if (parseInt(Math.random() * 100) % 2 == 0) {\n      enemySprite = \"./img/spaceship.png\";\n    }\n\n    var spriteComp = new Packt.Components.Sprite(entity, enemySprite, 64, 64);\n\n    spriteComp.setCtx(canvas.getContext());\n    spriteComp.setSpriteCoords(0, 0, 64, 64);\n    entity.addComponent(\"sprite\", spriteComp);\n    entity.addComponent(\"move\", mockMove);\n    entity.addComponent(\"physics\", physComp);\n    entity.addComponent(\"strength\", strengthComp);\n\n    // Randomly assign a starting direction to each entity\n    var randPathX = (Math.random() * 100 % 10) - 5;\n    var randPathY = (Math.random() * 100 % 50) + 10;\n    entity.setOnUpdate(function() {\n      mockMove.setDirection(randPathX, 1);\n      mockMove.update();\n    });\n\n    entities.push(entity);\n  }\n\n  this.add = addEnemies;\n\n  // Remove dead entities from our management\n  this.remove = function(entity) {\n    for (var i = 0, len = entities.length; i < len; i++) {\n      if (entities[i] === entity) {\n        entities.splice(i, 1);\n        return entity;\n      }\n    }\n\n    return null;\n  };\n\n  // Update each entity's position, and remove dead entities\n  this.update = function() {\n    var enemiesDeleted = 0;\n    for (var i = 0, len = entities.length; i < len; i++) {\n      try {\n        entities[i].update();\n\n        var pos = entities[i].getPosition();\n\n        if (pos.y > worldHeight + 100 || !entities[i].isActive())\n        {\n          entities.splice(i, 1);\n          enemiesDeleted++;\n        }\n\n        if (pos.x < -100) {\n          pos.x = worldWidth + 50;\n          entities[i].setPosition(pos);\n        } else if (pos.x > worldWidth + 100) {\n          pos.x = -50;\n          entities[i].setPosition(pos);\n        }\n      } catch (e) {}\n    }\n\n    if (enemiesDeleted > 0) {\n      for (var i = 0; i < enemiesDeleted; i++) {\n        var offset = (Math.random() * 100 >> 0) % (worldWidth / 75 >> 0);\n        var x = 50 * offset + 25 + (25 * offset);\n        var y = 0 - Math.random() * 100 - 100;\n        addEnemies(x, y, {});\n      }\n    }\n  };\n};\n```", "```js\n// Namespace the game loop class\nvar Packt = Packt || {};\n\nPackt.GameLoop = function(fps) {\n  var fps = fps;\n  var frameDelay = 1000 / fps;\n  var lastFrameTime = 0;\n  var isRunning = true;\n\n  // By default, the game tick is empty, indicating that we expect\n    the client\n  // to provide their own update function\n  var update = function(){};\n\n  // Once the game loop object is set to running, this functionwill be called\n  // as close to the specified frame rate as it can, until theclient code\n  // sets the object's running state to false\n  function run(time) {\n    if (isRunning) {\n      var delta = time - lastFrameTime;\n\n      if (delta >= frameDelay) {\n        update();\n        lastFrameTime = time;\n      }\n\n      requestAnimationFrame(run);\n    }\n  }\n\n  // Allows client code to start/stop the game loop\n  this.setRunning = function(running) {\n    isRunning = running;\n    return isRunning;\n  };\n\n  this.isRunning = function() {\n    return isRunning;\n  };\n\n  this.run = run;\n\n  // Allows client code to override default update function\n  this.setOnUpdate = function(cb){\n    update = cb;\n  };\n};\n```", "```js\n(function main(){\n  var WIDTH = document.body.offsetWidth;\n  var HEIGHT = document.body.offsetHeight;\n  var MAX_ENEMIES = 100;\n\n  // The main canvas where the game is rendered\n  var canvas = new Packt.Canvas(WIDTH, HEIGHT);\n  document.body.appendChild(canvas.getCanvas());\n\n  // The energy widget\n  var playerEnergy = new Packt.Widgets.EnergyBar(\"energyBar\");\n  document.body.appendChild(playerEnergy.getElement());\n\n  // The player entity, along with its required components\n  var player = new Packt.Entity(Packt.ENTITY_TYPES.SHIP,\n    canvas.getWidth() / 2, canvas.getHeight() - 100);\n\n  var playerLaserGunComp = new Packt.Components.LaserGun(player, canvas, 10);\n  var playerStrengthComp = new Packt.Components.Strength(player, 0, 100);\n  var playerMoveComp = new Packt.Components.Drag(player, canvas);\n  var playerPhysComp = new Packt.Components.Physics(player);\n  var playerSpriteComp = new Packt.Components.Sprite(player, \"./img/fighter.png\", 64, 64);\n  playerSpriteComp.setCtx(canvas.getContext());\n  playerSpriteComp.setSpriteCoords(64 * 3, 0, 64, 64);\n  player.addComponent(\"sprite\", playerSpriteComp);\n  player.addComponent(\"drag\", playerMoveComp);\n  player.addComponent(\"physics\", playerPhysComp);\n  player.addComponent(\"strength\", playerStrengthComp);\n  player.addComponent(\"laserGun\", playerLaserGunComp);\n\n  // Override the player's update function\n  player.setOnUpdate(function() {\n    var drag = player.getComponent(\"drag\");\n    drag.centerEntity();\n\n    var pos = player.getPosition();\n    var laserGun = player.getComponent(\"laserGun\");\n    laserGun.add(pos.x + 28, pos.y);\n    laserGun.update();\n  });\n\n  // The enemy manager\n  var enMan = new Packt.EnemyManager(canvas);\n  for (var i = 0; i < MAX_ENEMIES; i++) {\n    var offset = i % (WIDTH / 75 >> 0);\n    var x = 50 * offset + 25 + (25 * offset);\n    var y = -50 * i + 25 + (-50 * i);\n    enMan.add(x, y, {});\n  }\n\n  // The physics manager\n  var phy = new Packt.PhysicsManager();\n  phy.setPlayer(player);\n\n  // The game loop, along with its overriden update function\n  var gameLoop = new Packt.GameLoop(60);\n  gameLoop.setOnUpdate(function() {\n    // Check if game is over\n    if (playerStrengthComp.getEnergy() < 0) {\n      document.body.classList.add(\"zoomOut\");\n\n      var ctx = canvas.getContext();\n      ctx.globalAlpha = 0.01;\n\n      gameLoop.setRunning(false);\n    }\n\n    // Add everyone to the physics manager to check for collision\n    var enemies = enMan.getEntities();\n    for (var i = 0, len = enemies.length; i < len; i++) {\n      phy.addEnemy(enemies[i]);\n    }\n\n    var playerLasers = playerLaserGunComp.getShots();\n    for (var i = 0, len = playerLasers.length; i < len; i++) {\n      phy.addPlayerShots(playerLasers[i]);\n    }\n\n    // Update positions\n    enMan.update();\n    player.update();\n\n    // Check for collisions\n    phy.checkCollisions();\n\n    // Draw\n    canvas.clear();\n    for (var i = 0, len = enemies.length; i < len; i++) {\n      enemies[i].draw();\n    }\n\n    for (var i = 0, len = playerLasers.length; i < len; i++) {\n      playerLasers[i].draw();\n    }\n\n    player.draw();\n    playerEnergy.setEnergy(playerStrengthComp.getEnergy());\n  });\n\n  // Get the game going\n  gameLoop.run();\n})();\n```", "```js\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>2D Space Shooter</title>\n    <link rel=\"stylesheet\" href=\"./css/style.css\" />\n  </head>\n\n  <body class=\"animBody\">\n    <script src=\"img/Vec2.js\"></script>\n    <script src=\"img/Sprite.js\"></script>\n    <script src=\"img/Move.js\"></script>\n    <script src=\"img/Entity.js\"></script>\n    <script src=\"img/Canvas.js\"></script>\n    <script src=\"img/GameLoop.js\"></script>\n    <script src=\"img/TouchDrag.js\"></script>\n    <script src=\"img/Physics.js\"></script>\n    <script src=\"img/Strength.js\"></script>\n    <script src=\"img/LaserGun.js\"></script>\n    <script src=\"img/PhysicsManager.js\"></script>\n    <script src=\"img/EnemyManager.js\"></script>\n    <script src=\"img/EnergyBar.js\"></script>\n    <script src=\"img/main.js\"></script>\n  </body>\n</html>\n```", "```js\nPackt.Components.TouchDrag = function(entity, canvas) {\n  var touchId = 0;\n\n  // When a successful touch is first captured, cache the touch'sidentification\n  function doOnTouchDown(event) {\n    event.preventDefault();\n    var phy = entity.getComponent(\"physics\");\n    var touch = event.changedTouches;\n\n    if (phy) {\n      touchId = touch.identifier;\n      isDown = phy.collide(touch[touchId].pageX, touch[touchId].pageY, 0, 0);\n    }\n  }\n\n  // Clear the touch flag on the entity, as well as the touch id\n  function doOnTouchUp(event) {\n    event.preventDefault();\n    isDown = false;\n    touchId = 0;\n  }\n\n  // Always move the entity based on the cached touch id\n  function doOnTouchMove(event) {\n    event.preventDefault();\n    var touch = event.changedTouches;\n\n    if (isDown) {\n      pos.x = touch[touchId].pageX;\n      pos.y = touch[touchId].pageY;\n    }\n  }\n};\n```"]