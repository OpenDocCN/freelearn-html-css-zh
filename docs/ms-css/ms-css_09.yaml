- en: Flexbox, Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flexbox，第1部分
- en: Flexbox is a module for laying out portions of a page, and it currently has
    great browser support, starting with Internet Explorer 10\. Technically, it's
    not designed for full-page layout; it's more for layout of portions of your page,
    or a given component.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox是用于页面部分布局的模块，目前在Internet Explorer 10及以上版本中有很好的浏览器支持。从技术上讲，它并不是为全页面布局设计的；它更多用于页面的部分布局或给定组件的布局。
- en: 'For instance, the following three columns (The Octopus, The Crab, and The Whale)
    were laid out using floats, but we''re going to use flexbox to do the exact same
    thing:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下三列（章鱼，螃蟹和鲸鱼）是使用浮动布局的，但我们将使用flexbox来完成完全相同的事情：
- en: '![](img/00378.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00378.jpeg)'
- en: 'Flexbox is a big topic, so we''re going to be covering it across two chapters.
    This chapter will cover the basics, we''ll tackle implementing flexbox, switching
    from floats to flexbox, and go through all the flexbox properties and shorthands.
    In the next chapter we''ll build a new section—the following product listing—to
    demonstrate how we can build different things with flexbox:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox是一个大主题，所以我们将在两章中涵盖它。本章将介绍基础知识，我们将解决实现flexbox，从浮动切换到flexbox，并介绍所有flexbox属性和简写。在下一章中，我们将构建一个新的部分-以下产品列表-以演示如何使用flexbox构建不同的东西。
- en: '![](img/00379.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00379.jpeg)'
- en: I'm going to code in the latest version of Chrome, which as of now supports
    the non-prefixed versions of all flexbox properties. This is going to un-complicate
    the learning experience. But, before we're done we'll need to add vendor prefixes
    for maximum browser compatibility.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在最新版本的Chrome中编码，目前支持所有flexbox属性的非前缀版本。这将简化学习体验。但在完成之前，我们需要为最大的浏览器兼容性添加供应商前缀。
- en: 'We are going to cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Overview of the flexible box layout module of CSS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS的弹性盒布局模块概述
- en: Switching from floats to flexbox
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浮动切换到flexbox
- en: Flexbox properties and shorthands
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flexbox属性和简写
- en: Overview of the flexible box layout module
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性盒布局模块概述
- en: What is flexbox? Commonly referred to as flexbox, it's real name is *flexible
    box layout module*. It provides a more efficient way to lay out, align, and distribute
    space among child elements of a parent element, even when their size and quantity
    is unknown or dynamic. Flexbox defines a whole new layout mode.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是flexbox？通常称为flexbox，它的真实名称是*flexible box layout module*。它提供了一种更有效的方式来布局，对齐和分配父元素的子元素之间的空间，即使它们的大小和数量是未知的或动态的。Flexbox定义了一种全新的布局模式。
- en: 'Traditionally, there is *block mode*, which was designed for document layout.
    There is *inline mode*, which was designed for text; *table mode*, which was designed
    for tabular data (tables); and *positioned mode*, which was designed for explicit
    positioning without much regard for other elements around it. Now there is *flexbox
    mode*. So what does flexbox do? It can do a lot of really useful things. At the
    core, flexbox is for layout and alignment. The following list illustrates its
    more common use cases:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，有*块模式*，用于文档布局。有*内联模式*，用于文本；*表模式*，用于表格数据（表格）；和*定位模式*，用于明确位置而不太关心周围的其他元素。现在有*flexbox模式*。那么flexbox做什么？它可以做很多真正有用的事情。在核心，flexbox用于布局和对齐。以下列表说明了它更常见的用例：
- en: Layout of elements vertically or horizontally.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的垂直或水平布局。
- en: Alignment of elements to the left or right, like you can with floats but without
    all the extra baggage that comes along with floats. You can also center elements,
    horizontally or vertically.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的左对齐或右对齐，就像您可以使用浮动一样，但没有浮动带来的额外麻烦。您还可以水平或垂直居中元素。
- en: Also, you have control over the display direction. For instance, you can have
    the elements displayed in the source order by default or in reverse direction.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，您可以控制显示方向。例如，默认情况下，您可以按源顺序显示元素，也可以按相反方向显示。
- en: Furthermore, you can take explicit control of elements and change their display
    order.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，您可以明确控制元素并更改它们的显示顺序。
- en: Another thing it does easily is it gives you equal height columns, which could
    only be achieved previously using hacks
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它轻松实现的另一件事是给你相等高度的列，这以前只能通过使用黑客来实现
- en: Its real delight is how it can distribute elements in a parent in regards to
    the available space.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它真正的乐趣在于它如何在父元素中分配元素以适应可用空间。
- en: Geared towards responsive design
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向响应式设计
- en: Flex terminology
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性术语
- en: So this is all exciting stuff and I'm sure you want to start seeing it in action,
    but before we jump in, we need to do some homework and learn the flex terminology.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这都是令人兴奋的事情，我相信你想开始看到它的实际效果，但在我们跳入之前，我们需要做一些功课并学习弹性术语。
- en: Flex container and flex items
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flex容器和flex项目
- en: First of all, there is something called a *flex container*, which is essentially
    an element that contains all the *flex items*. In other words, it's the parent
    of a collection of elements; flex items are child elements of their parent, or
    flex container.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个称为*flex容器*的东西，它本质上是包含所有*flex项目*的元素。换句话说，它是一组元素的父元素；flex项目是其父元素或flex容器的子元素。
- en: '![](img/00380.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00380.jpeg)'
- en: Main size and cross size
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要尺寸和交叉尺寸
- en: 'There''s something called the *main size* and *cross size*, as shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个称为*主尺寸*和*交叉尺寸*的东西，如下所示：
- en: '![](img/00381.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00381.jpeg)'
- en: By default, the main size is the width and cross size is the height, but this
    can change if you modify the `flex-direction`, something we'll learn about in
    the next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，主尺寸是宽度，交叉尺寸是高度，但如果修改`flex-direction`，这可能会改变，这是我们将在下一节学习的内容。
- en: Main axis and cross axis
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主轴和交叉轴
- en: 'Furthermore, there is something called the *main axis*, which runs horizontally
    by default, and *cross axis*, which runs vertically by default, as shown in the
    following image:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个称为*主轴*的东西，默认情况下水平运行，以及*交叉轴*，默认情况下垂直运行，如下图所示：
- en: '![](img/00382.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00382.jpeg)'
- en: Justify-content and align-items
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Justify-content和align-items
- en: 'There''s a property you''ll learn about later in this chapter called `justify-content`,
    which controls alignment along the main axis; the `align-items` property controls
    alignment along the cross axis. Here''s an important concept. The main axis and
    cross axis can be toggled based on the `flex-direction` being set to either a
    `column` or `row`. So the main axis is always the horizontal axis by default,
    unless you use `flex-direction: column` and the vertical axis becomes the main
    axis!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章节中，您将学习到一个叫做`justify-content`的属性，它控制沿主轴的对齐方式；`align-items`属性控制沿交叉轴的对齐方式。这是一个重要的概念。主轴和交叉轴可以根据`flex-direction`设置为`column`或`row`来切换。因此，主轴默认始终是水平轴，除非您使用`flex-direction:
    column`，垂直轴就成为主轴！'
- en: If this is your first taste of flexbox your probably saying, "Hey, slow down!"
    Not to worry, this is just an introduction to the terminology and a few of the
    properties and concepts; don't expect to have all this sink in right away. We'll
    refer more to the preceding diagrams as we start using different properties throughout
    the next sections, and we'll cover every single property in depth in the upcoming
    sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次接触flexbox，您可能会说：“嘿，慢点！”不用担心，这只是术语和一些属性和概念的介绍；不要指望立刻就能理解这一切。随着我们在接下来的章节中开始使用不同的属性，我们将更多地参考前面的图表，并且我们将在接下来的章节中深入讨论每一个属性。
- en: From floats to flexbox
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从浮动到flexbox
- en: In this section, we'll get to work and change our columns module from a float-based
    layout to a flexbox-based layout (I'm excited!).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始工作，将我们的列模块从基于浮动的布局更改为基于flexbox的布局（我很兴奋）。
- en: 'First, we''ll remove all the float-related properties from the columns and
    break them down to square one; then, we''ll use `display: flex` to transform the
    float layout into our flexbox-based layout to see immediate results. Finally,
    we''ll explore how `flex-direction` will be useful in a responsive design; we''ll
    discuss this when we get down to smaller screen sizes.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们将从列中删除所有与浮动相关的属性，并将它们分解到最初的状态；然后，我们将使用`display: flex`将浮动布局转换为基于flexbox的布局，以立即看到结果。最后，我们将探讨`flex-direction`在响应式设计中的用途；当我们开始讨论较小的屏幕尺寸时，我们将讨论这一点。'
- en: Removing float-related properties from the columns section
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列部分删除与浮动相关的属性
- en: 'OK, here''s our three-column layout:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我们的三列布局：
- en: '![](img/00383.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00383.jpeg)'
- en: 'Let''s recall how it moves to a one-column tube at smaller widths:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回想一下，它在较小的宽度下变成了一个一列的管道：
- en: '![](img/00384.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00384.jpeg)'
- en: Alright, let's go to the CSS file. Now we'll remove all the float-based properties
    from our columns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们去CSS文件。现在我们将从我们的列中删除所有基于浮动的属性。
- en: 'Starting with this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从这开始：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s basically remove everything to make it look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基本上删除所有内容，使其看起来像这样：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, there let''s rip out the float-based code in the responsive media query.
    So starting with this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在响应式媒体查询中删除基于浮动的代码。所以从这开始：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s change it to this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它改成这样：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And inside one more media query for very small widths, let''s remove the last
    reference to the column. So, starting with this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并在一个非常小的宽度的媒体查询中，让我们删除对列的最后一个引用。所以，从这开始：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s remove the `.column {}` rule set, so it looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除`.column {}`规则集，使其看起来像这样：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alright, if we refresh the browser and widen it, we will be back to a stacked
    layout:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，如果我们刷新浏览器并扩大它，我们将回到堆叠布局：
- en: '![](img/00385.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00385.jpeg)'
- en: We've successfully remove our float-based layout from this section as our three
    columns are gone.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地从本节中删除了基于浮动的布局，因为我们的三列已经消失了。
- en: 'Turning on flexbox using display: flex'
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '使用`display: flex`打开flexbox'
- en: 'Now we''ll rebuild the columns using flexbox. We''ll take a look at our index.html
    file. Here''s are markup for this area we are calling columns:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用flexbox重新构建列。我们将查看我们的index.html文件。这是我们称之为列的区域的标记：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each of these `<div class="column"></div>` will be our flex items; `<div class="wrapper">`
    will be our flex container. For ease of understanding, I''m going to simplify
    our markup down to this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`<div class="column"></div>`将成为我们的flex项目；`<div class="wrapper">`将成为我们的flex容器。为了便于理解，我将简化我们的标记如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s add a new class to the flex container called "columns" that we''ll use
    to target the flex container with our flexbox code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为flex容器添加一个新的类名"columns"，我们将使用它来定位我们的flex容器与我们的flexbox代码：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s add a new rule set targeting our would-be flex container. To convert
    something into a flex container, simply add `display: flex`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们添加一个新的规则集，以定位我们将要成为flex容器的元素。要将某物转换为flex容器，只需添加`display: flex`：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The children of a flex container will automatically become flex items.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: flex容器的子元素将自动成为flex项目。
- en: Note the grandchildren and great-grandchildren elements will not be considered
    flex items, only the immediate children.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，子子孙孙的元素不会被视为flex项目，只有直接的子元素。
- en: 'Here''s what we get:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的：
- en: '![](img/00386.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00386.jpeg)'
- en: 'We''ve basically achieved our float layout with one simple property: `display:
    flex`. The spacing is a little tight, but we have a horizontal layout nonetheless.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '我们基本上通过一个简单的属性`display: flex`实现了我们的浮动布局。间距有点紧，但我们仍然有一个水平布局。'
- en: 'Flex overrides floats. Let''s say we have many floats, namely `float: left`,
    `float: right`, and `float: none`; whatever it might be, flex items ignore floats,
    that is, they have zero impact. So once a container element gets `display: flex`,
    making the children elements flex items, floats are now ignored on those flex
    items. I can float to my heart''s delight, but it will have zero impact on flex
    items. .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'Flex覆盖浮动。假设我们有许多浮动，即`float: left`，`float: right`和`float: none`；无论是什么，flex项目都会忽略浮动，也就是说，它们没有任何影响。因此，一旦容器元素设置为`display:
    flex`，使子元素成为flex项目，浮动现在将被忽略在这些flex项目上。我可以随心所欲地浮动，但它对flex项目没有任何影响。'
- en: 'Also, another thing to keep in mind is that each column are now of equal height.
    But let''s just do one thing. Let''s add a border around the flex items:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事要记住的是，每列现在都是相等的高度。但让我们做一件事。让我们在flex项目周围添加一个边框：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s what that looks like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子：
- en: '![](img/00387.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00387.jpeg)'
- en: 'Equal-height columns right? Well, each column has the exact same amount of
    content. So even if we were using floats for layout, we''d have equal-height columns.
    The unequal height comes when the amount of content varies in each column. I''ll
    remove some of the paragraph text in the crab column:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 等高列，对吧？嗯，每列的内容量完全相同。所以即使我们使用浮动布局，我们也会得到等高的列。不等高是因为每列的内容量不同。我将删除螃蟹列中的一些段落文本：
- en: '![](img/00388.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00388.jpeg)'
- en: After doing this, you can see that even though it has a lot less content, it
    still has the same height. Albeit, a few other things happened here, namely the
    crab column is a different width than the other 2 columns. We'll talk about this
    later in the chapter, but we do get equal height by default, which is a quick
    win that is difficult to accomplish using a float-based layout.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些之后，你会发现即使它的内容少了很多，它的高度仍然相同。尽管在这里发生了一些其他事情，特别是螃蟹列的宽度与其他两列不同。我们将在本章后面讨论这个问题，但是我们默认情况下确实获得了等高，这是一个很难通过基于浮动的布局来实现的快速胜利。
- en: Changing the flex-direction
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变flex-direction
- en: Let's look at how easy it is to change the layout direction by adding the `flex-direction`
    property with a value of `column`. This property applies to the `.columns` flex
    container. I've also removed the pink `border` as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通过添加`flex-direction`属性并将其值设置为`column`来改变布局方向有多简单。这个属性适用于`.columns`的flex容器。我还删除了粉色的`border`。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll save this and boom! We went from horizontal to vertical:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存这个设置，哇！我们从水平变成了垂直：
- en: '![](img/00389.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00389.jpeg)'
- en: Some of our center alignment, which we probably wanted, has gone; however, the
    layout is vertical nonetheless. So that's interesting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些我们可能想要的居中对齐已经消失了；然而，布局仍然是垂直的。所以这很有趣。
- en: 'Another thing we can is set the `flex-direction` to be `column-reverse`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是我们可以将`flex-direction`设置为`column-reverse`：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Earlier, our octopus appeared first; now if we refresh the browser, our whale
    comes first and the octopus comes last:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们的章鱼首先出现；现在如果我们刷新浏览器，我们的鲸鱼首先出现，章鱼最后出现：
- en: '![](img/00390.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00390.jpeg)'
- en: 'If we look at our DevTools, though, we will see that the octopus is still first
    in the source order but the last one to be displayed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们查看我们的DevTools，我们会发现章鱼仍然是源顺序中的第一个，但是最后一个被显示出来：
- en: '![](img/00391.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00391.jpeg)'
- en: So the source order hasn't changed, only the display order.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，源顺序没有改变，只是显示顺序改变了。
- en: 'This is a good time to talk about our flexbox diagram. When `flex-direction`
    is set to `row`, this diagram applies—flex items are laid out horizontally:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个好时机来谈谈我们的flexbox图表。当`flex-direction`设置为`row`时，这个图表适用——flex项目水平排列：
- en: '![](img/00392.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00392.jpeg)'
- en: 'However, when `flex-direction` is changed to a `column`, the diagram changes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当`flex-direction`改为`column`时，图表也会改变：
- en: '![](img/00393.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00393.jpeg)'
- en: The cross axis now runs from left to right and the main axis runs from top to
    bottom, and the flex items are now stacked on top of each other.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉轴现在从左到右，主轴从上到下，flex项目现在堆叠在彼此上方。
- en: 'The default value of `flex-direction` is `row`; `flex-direction: row`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-direction`的默认值是`row`；`flex-direction: row`。'
- en: 'We can also set `flex-direction` to `row-reverse`, which does what you think
    it does: it lines the flex items horizontally but in reverse order. Let''s take
    a look at the following image; we have the whale, crab, and octopus in reverse
    order:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`flex-direction`设置为`row-reverse`，它会按你所想的那样：水平排列flex项目，但顺序相反。让我们看一下下面的图片；我们有鲸鱼、螃蟹和章鱼的顺序相反：
- en: '![](img/00394.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00394.jpeg)'
- en: 'Let''s remove the `flex-direction` property from the `.column` flex container,
    and it will default to row, which is what we want:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`.column`的flex容器中删除`flex-direction`属性，它将默认为行，这正是我们想要的：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Browser shrinking
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器缩小
- en: 'Now let''s think about smaller devices by shrinking our browser. It gets a
    little tight down near tablet dimensions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一下更小的设备，缩小我们的浏览器。在接近平板尺寸时，会有点紧：
- en: '![](img/00395.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00395.jpeg)'
- en: 'In our media query, where we had originally removed all of the `float` stuff.
    Let''s change the `flex-direction` to `column`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的媒体查询中，我们最初删除了所有的`float`内容。让我们将`flex-direction`改为`column`：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''re back to a one-column-stacked layout for narrower browser widths:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又回到了较窄浏览器宽度下的一列堆叠布局：
- en: '![](img/00396.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00396.jpeg)'
- en: As you can see, there are still some issues with spacing and alignment, which
    we'll address with flexbox in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，仍然存在一些间距和对齐的问题，我们将在下一节中使用flexbox来解决这些问题。
- en: 'In summary, we removed all our float-based layout CSS from our column section,
    and we added a flexbox layout using `display: flex`. We also changed `flex-direction`,
    which as we saw determines the direction of the main axis and cross axis.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '总之，我们从列部分中删除了所有基于浮动的布局CSS，并添加了使用`display: flex`的flexbox布局。我们还改变了`flex-direction`，正如我们所看到的，它决定了主轴和交叉轴的方向。'
- en: Understanding flex-grow, flex-basis, flex-shrink, and flex
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解flex-grow、flex-basis、flex-shrink和flex
- en: Let's take a crack at understanding flexbox's sizing properties. In this section,
    we'll look at sizing flex items with `flex-grow`, `flex-shrink`, `flex-basis`,
    and the shorthand for them all; `flex`. All of these properties apply to flex
    items, not to flex containers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解flexbox的尺寸属性。在这一节中，我们将使用`flex-grow`、`flex-shrink`、`flex-basis`以及它们的快捷方式`flex`来调整flex项目的尺寸。所有这些属性都适用于flex项目，而不是flex容器。
- en: Using flex-grow
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flex-grow
- en: 'First, we''ll look at a new page—`flexbox.html`. As you might have guessed,
    there''s a `<section>` that will be the flex container, and 5 `<div>`''s which
    will be the flex items. :'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一个新页面——`flexbox.html`。你可能已经猜到了，有一个`<section>`将成为flex容器，还有5个`<div>`将成为flex项目。
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s the CSS we''ll start with before adding flexbox properties:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在添加flexbox属性之前将要开始的CSS：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here''s what it looks like in the browser:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在浏览器中的样子：
- en: '![](img/00397.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00397.jpeg)'
- en: 'Let''s switch on flexbox by adding `display: flex` to the flex container in
    our CSS file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '通过在我们的CSS文件中的flex容器中添加`display: flex`来打开flexbox：'
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alright, if we refresh our browser, this creates a horizontal row for us, as
    shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，如果我们刷新浏览器，这为我们创建了一个水平行，如下面的截图所示：
- en: '![](img/00398.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00398.jpeg)'
- en: 'The first flexbox sizing property we''ll look at is `flex-grow`, which is a
    factor. It determines how to distribute "leftover space" along the main axis of
    the flex container. Let''s be clear on what I mean when I say, "leftover space".
    That is the unfilled space inside of the flex container that the flex items don''t
    occupy. In our case, that is this empty space on the right:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: flex-grow是我们将要看的第一个flexbox大小调整属性，它是一个因子。它确定如何沿着flex容器的主轴分配“剩余空间”。让我们明确一下，当我说“剩余空间”时我的意思是什么。那就是flex容器内未填充的空间，即flex项没有占用的空间。在我们的例子中，就是右侧的这个空白空间：
- en: '![](img/00399.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00399.jpeg)'
- en: 'Again, `flex-grow` determines how to distribute that leftover space to the
    flex items. Let''s apply it to our flex items using a value of `1`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`flex-grow`决定如何将剩余空间分配给flex项。让我们应用它到我们的flex项，使用值`1`：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`flex-grow: 1` will force the leftover space to be evenly distributed to all
    the flex items. Each flex item gets an equal amount of the space that was previously
    unoccupied:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-grow: 1`将强制将剩余空间均匀分配给所有的flex项。每个flex项都会得到之前未占用的空间的相等部分：'
- en: '![](img/00400.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00400.jpeg)'
- en: As I shrink the browser, we can see that we achieved a perfectly fluid grid
    without using the `width` property and calculating the exact percentage of how
    100 divides equally into 5!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我缩小浏览器时，我们可以看到我们实现了一个完全流动的网格，而不使用`width`属性和计算100如何平均分成5的确切百分比！
- en: '![](img/00401.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00401.jpeg)'
- en: 'Let''s create a new ruleset for just the second flex item (each flex item has
    a unique class, the second one being `flex-item2`). And we''ll add a `flex-grow`
    property with a value of `2`, and this will distribute twice as much of the leftover
    space to that second flex-item:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为第二个flex项创建一个新的规则集（每个flex项都有一个唯一的类，第二个是`flex-item2`）。我们将添加一个`flex-grow`属性，值为`2`，这将把剩余空间的两倍分配给第二个flex项：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we refresh the browser, it should look something like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新浏览器，它应该看起来像这样：
- en: '![](img/00402.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00402.jpeg)'
- en: 'Notice that `flex-item2` isn''t necessarily twice the width of the others;
    it''s just getting twice the leftover space as the others. That''s a notable distinction.
    And, if we shrink the browser window, we can see how it gets narrower as the browser
    window shrinks until we get down to a certain width, then they''re all roughly
    the same. When there is extra space, it tries to distribute more to `flex-item2`
    since it has a higher `flex-grow` factor:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`flex-item2`的宽度不一定是其他项的两倍；它只是得到了其他项两倍的剩余空间。这是一个值得注意的区别。而且，如果我们缩小浏览器窗口，我们可以看到随着浏览器窗口的缩小，它变窄，直到达到一定的宽度，然后它们大致相同。当有额外的空间时，它会尝试分配更多的空间给`flex-item2`，因为它具有更高的`flex-grow`因子：
- en: '![](img/00403.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00403.jpeg)'
- en: 'We could also set `flex-grow` of `flex-item2` to `0`, which is the default
    value for `flex-grow`. This basically says don''t distribute any of the leftover
    space to this flex item:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`flex-item2`的`flex-grow`设置为`0`，这是`flex-grow`的默认值。这基本上表示不要将任何剩余空间分配给这个flex项：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second flex item doesn''t grow to take up any of the extra space; the remaining
    four items take the extra space available:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个flex项不会增长以占用任何额外的空间；剩下的四个项会占用可用的额外空间：
- en: '![](img/00404.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00404.jpeg)'
- en: Using flex-basis
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flex-basis
- en: 'Let''s check out another property for flex items: `flex-basis`. Note that `flex-basis`
    is the initial main size of the flex item, before leftover space is distributed
    according to the flex factors, which are `flex-grow` and `flex-shrink`; we''ll
    talk about the latter shortly. For now, let''s think of `flex-basis` as just a
    width. So, for `flex-item2`, let''s give it `flex-basis` of `400px` and remove
    its `flex-grow` factor:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下flex项的另一个属性：`flex-basis`。请注意，`flex-basis`是在根据`flex-grow`和`flex-shrink`进行剩余空间分配之前的flex项的初始主尺寸；我们很快会讨论后者。现在，让我们把`flex-basis`简单地看作是宽度。所以，对于`flex-item2`，让我们给它一个`flex-basis`为`400px`并移除它的`flex-grow`因子：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you refresh the browser, it will size the second flex item to `400px`. But
    if we really look at this, it''s sizing it to a little more than 400 pixels:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新浏览器，它将把第二个flex项的大小设置为`400px`。但是如果我们真正看一下，它的大小要比400像素多一点：
- en: '![](img/00405.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00405.jpeg)'
- en: 'However, I''m still applying `flex-grow` as `1` to all flex items including
    this one. Let''s change this to make it so our second flex item has the default
    value `flex-grow: 0;`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，我仍然将`flex-grow`应用到所有的flex项，包括这一个。让我们改变一下，让我们的第二个flex项具有默认值`flex-grow: 0;`：'
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now when you refresh your browser, you can see it''s exactly 400 pixels:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你刷新浏览器，你会看到它确切地是400像素：
- en: '![](img/00406.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00406.jpeg)'
- en: 'It''ll be exactly 400 pixels until we start shrinking the browser; at some
    point, it''s going to start giving way. Once space starts to get very limited,
    it decides to make it less than 400 pixels; this is where the *initial main size*
    part of the `flex-basis` definition comes into play. We''re telling flexbox we
    want a width of 400 pixels for the second flex item, and flexbox will obey that
    until the flex container runs out of space to accommodate that. Then, it starts
    to reduce the width of the second flex item to less than the `flex-basis: 400px`
    to entertain the best layout that it can.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它会一直是400像素，直到我们开始缩小浏览器；在某个时候，它会开始让步。一旦空间开始变得非常有限，它决定将它缩小到小于400像素；这就是`flex-basis`定义中*初始主尺寸*部分发挥作用的地方。我们告诉flexbox我们希望第二个flex项的宽度为400像素，flexbox会遵守这一点，直到flex容器没有足够的空间来容纳它。然后，它开始减小第二个flex项的宽度，以适应最佳布局。
- en: 'Let''s remove `flex-grow` again:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次移除`flex-grow`：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that `flex-basis` is not just a width: it''s the width when `flex-direction`
    is set to `row`, which is the default, and it''s the height when `flex-direction`
    is set to `column`. And technically speaking, since it''s not width or height,
    it''s the main size.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`flex-basis`不仅仅是宽度：当`flex-direction`设置为`row`时，它是宽度，这是默认值，当`flex-direction`设置为`column`时，它是高度。从技术上讲，因为它不是宽度或高度，它是主要尺寸。
- en: Are you starting to understand why we spent all that time going over flex terminology?
    If any of this is not making sense to you, I recommend going back to the start
    of this chapter to review flex terminology.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始明白为什么我们花了那么多时间来学习flex术语了吗？如果其中有任何内容让您感到困惑，我建议您回到本章的开头复习flex术语。
- en: 'So let''s change `flex-direction` to `column`. We''ll do this on the flex container:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们将`flex-direction`更改为`column`。我们将在flex容器上执行此操作：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A `flex-basis` of `400px` is now the height of the second flex item, now that
    the main axis is running vertically. You can see this in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于主轴是垂直运行，`400px`的`flex-basis`现在是第二个flex项目的高度。您可以在以下截图中看到：
- en: '![](img/00407.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00407.jpeg)'
- en: 'So `flex-basis` overrides any heights that are set. Let''s take an example
    and enter a `height` of `800px` for the second flex item:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`flex-basis`会覆盖任何设置的高度。让我们举个例子，为第二个flex项目输入一个`height`为`800px`：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We see that the height is still 400 pixels. Really, I should say the main size
    is 400 pixels, and it should look something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到高度仍然是400像素。实际上，我应该说主要尺寸是400像素，它应该看起来像这样：
- en: '![](img/00408.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00408.jpeg)'
- en: 'So, `flex-basis` also accepts two keywords: `auto` and `content`. The `auto`
    keyword means, "go look at the `width` or `height` property". Since `flex-direction`
    is currently `column`, when we change `flex-basis` to `auto`, the `height` of
    `800px` should no longer be ignored:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`flex-basis`还接受两个关键字：`auto`和`content`。`auto`关键字的意思是，“去查看`width`或`height`属性”。由于`flex-direction`目前是`column`，当我们将`flex-basis`更改为`auto`时，`800px`的`height`不应再被忽略：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And the height is now 800 pixels:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 高度现在是800像素：
- en: '![](img/00409.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00409.jpeg)'
- en: So, again, `auto` is the default value of `flex-basis`. There's also another
    keyword available called `content`; this means the size of the flex item is based
    on the size of the flex item's content. This is currently not supported by the
    most recent version of Chrome, so I won't demo it; however, it sounds like it
    could be useful in future once browsers start implementing it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`auto`是`flex-basis`的默认值。还有另一个可用的关键字叫做`content`；这意味着flex项目的大小是基于flex项目内容的大小。目前最新版本的Chrome不支持这一点，所以我不会演示它；但是，一旦浏览器开始实现它，它似乎会在未来变得有用。
- en: 'Alright, I''ll remove the `height` and `flex-basis`. I''ll also remove the
    `flex-direction` ending up with our CSS in this state:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我将删除`height`和`flex-basis`。我还将删除`flex-direction`，最终得到我们的CSS如下：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here''s what that looks like:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的样子：
- en: '![](img/00410.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00410.jpeg)'
- en: Using flex-shrink
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flex-shrink
- en: A `flex-shrink` can be thought of as the opposite of `flex-grow`. While `flex-grow`
    determines how much of the extra space a flex item should consume, proportionate
    to others when there is leftover space, `flex-shrink` determines how much the
    flex item itself should shrink proportionately to others when there isn't any
    leftover space. So, let's see this in action and step this out.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-shrink`可以被认为是`flex-grow`的相反。虽然`flex-grow`确定了当有剩余空间时，flex项目应该消耗多少额外空间，与其他项目成比例，`flex-shrink`确定了当没有剩余空间时，flex项目本身应该如何与其他项目成比例收缩。因此，让我们看看这个过程并逐步进行。'
- en: 'First, let''s add `flex-basis` of `200px` to each flex item and temporarily
    remove `flex-grow`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为每个flex项目添加`flex-basis`为`200px`，并临时删除`flex-grow`：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So if `flex-basis` is set to 200 pixels, each flex item will be 200 pixels
    wide and any extra space is not allowed in any of the flex items because `flex-grow`
    was removed. Here''s how it should look:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`flex-basis`设置为200像素，每个flex项目将是200像素宽，任何额外的空间都不允许在任何flex项目中，因为`flex-grow`已被移除。它应该看起来像这样：
- en: '![](img/00411.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00411.jpeg)'
- en: 'Let''s add `flex-grow` of `1` back to our `flex-item` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`flex-grow`的值重新添加到我们的`flex-item`类中：`1`。
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Again, the extra space is distributed to each flex item. The `flex-basis` property
    was just a starting point for the initial main size (notice I didn''t said "initial
    main size" and not "width"). But each flex item got wider to eat up the extra
    space that was allocated evenly to each item. This is how your page should look
    at the moment:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，额外的空间分配给每个flex项目。`flex-basis`属性只是初始主尺寸的起点（请注意我没有说“初始宽度”，而是“宽度”）。但是每个flex项目都变得更宽，以吸收均匀分配给每个项目的额外空间。这是您的页面目前应该看起来的样子：
- en: '![](img/00412.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00412.jpeg)'
- en: 'Let''s throw a `flex-shrink` property on the second flex item. We''ll use a
    factor of `2`, as shown in the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在第二个flex项目上添加一个`flex-shrink`属性。我们将使用一个因子`2`，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we decrease the browser size, all the items shrink. Except for the second
    flex item, which shrinks twice as much as other flex items, as shown in the following
    screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 随着浏览器尺寸的减小，所有项目都会收缩。除了第二个flex项目，它的收缩量是其他flex项目的两倍，如下面的截图所示：
- en: '![](img/00413.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00413.jpeg)'
- en: 'If not specified for a flex item, `flex-shrink` defaults to `1`. So let''s
    add `flex-shrink: 1` to all the flex items except for the second flex item, which
    has `flex-shrink` set to `2`, just to demonstrate that nothing will change:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '如果没有为flex项目指定，`flex-shrink`的默认值为`1`。因此，让我们为所有flex项目添加`flex-shrink: 1`，除了第二个flex项目，它的`flex-shrink`设置为`2`，只是为了证明没有任何变化： '
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see that when we make the browser smaller, there really is no change;
    the second flex item is still shrinking more than the others, as shown in the
    following samples:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们使浏览器变小时，实际上没有任何变化；第二个flex项目仍然比其他项目收缩得更多，如下面的示例所示：
- en: '![](img/00414.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00414.jpeg)'
- en: 'Another neat thing you can do is set `flex-shrink` to `0` to ensure that an
    item does not shrink. Let''s do this for the second flex item:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以做的一个好玩的事情是将`flex-shrink`设置为`0`，以确保项目不会收缩。让我们为第二个flex项目这样做：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Refresh the browser now. All the other flex items shrink when space is limited,
    except for item 2; it maintains its `flex-basis: 200px`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '现在刷新浏览器。当空间有限时，所有其他flex项目都会收缩，除了项目2；它保持着`flex-basis: 200px`：'
- en: '![](img/00415.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00415.jpeg)'
- en: Using the flex shorthand
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flex快捷方式
- en: 'There''s also a shorthand property, called `flex`, that we can substitute for
    using `flex-grow`, `flex-shrink`, and `flex-basis`. Let''s swap out `flex-basis`,
    `flex-grow`, and `flex-shrink` for just `flex`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `flex` 的快捷属性，可以替代使用 `flex-grow`、`flex-shrink` 和 `flex-basis`。让我们用 `flex`
    替换 `flex-basis`、`flex-grow` 和 `flex-shrink`：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So, the order of the values in `flex` is as follows: `flex-grow`, `flex-shrink`,
    and `flex-basis`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`flex` 中值的顺序如下：`flex-grow`、`flex-shrink` 和 `flex-basis`：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we refresh the browser, it will do exactly the same thing it was doing when
    we used the non-shorthand properties:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新浏览器，它将做与我们使用非快捷属性时完全相同的事情：
- en: '![](img/00416.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00416.jpeg)'
- en: 'For the second flex item, all it has is `flex-shrink`, so we can use a shorthand
    of `flex: 1 0`. The `flex-basis` will be intelligently set to its default of `auto`
    and can be omitted. We need to make the value `1 0` though because the default
    value for `flex-grow` is `1`, so even though we didn''t have a `flex-grow` set
    explicitly we need to add it''s value to our shorthand. We''ll also delete the
    existing `flex-shrink`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '对于第二个 flex 项目，它只有 `flex-shrink`，所以我们可以使用 `flex: 1 0` 的快捷方式。`flex-basis` 将智能地设置为其默认值
    `auto`，可以省略。我们需要将值设置为 `1 0`，因为 `flex-grow` 的默认值是 `1`，因此即使我们没有显式设置 `flex-grow`，我们也需要将其值添加到我们的快捷方式中。我们还将删除现有的
    `flex-shrink`：'
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, we see no change in the browser, which is what we wanted from our little
    refactor:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在浏览器中我们看不到任何变化，这正是我们从小的重构中想要的：
- en: '![](img/00417.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00417.jpeg)'
- en: 'So `flex: 1 0` means `flex-grow = 1` and `flex-shrink = 0`. As mentioned, `flex-basis`
    defaults to `auto`, so we don''t need to add that here. There''s also a keyword
    of `none`, which basically says don''t grow, don''t shrink, and look at my width
    or height for the main size, in other words, don''t flex. The shorthand is nice
    and compact, but when getting started with flexbox I recommend using each property
    on its own, until you gain a full understanding of what each one is doing.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，`flex: 1 0` 意味着 `flex-grow = 1` 和 `flex-shrink = 0`。如前所述，`flex-basis` 默认为
    `auto`，因此我们不需要在这里添加它。还有一个关键字 `none`，基本上是说不要增长、不要收缩，并且查看我的宽度或高度作为主要大小，换句话说，不要伸缩。这个快捷方式很简洁，但在开始使用
    flexbox 时，我建议使用每个属性单独使用，直到完全理解每个属性在做什么。'
- en: More layout, more positioning
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多布局，更多定位
- en: This section is on more layout and more positioning with flexbox. Here, we'll
    check out a new property, `justify-content`, as well as how to nest flexboxes
    within each other, and finally using automatic margins.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了使用 flexbox 进行更多布局和更多定位。在这里，我们将查看一个新属性 `justify-content`，以及如何在彼此之间嵌套 flexbox，最后使用自动边距。
- en: 'Before we get started, let''s reset some of our `flex` properties by getting
    rid of our flex shorthand:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们通过去掉我们的 flex 快捷方式来重置一些 `flex` 属性：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By removing the flex shorthand, each flex item stops worrying about growing,
    shrinking, or what their initial main size should be:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除 flex 快捷方式，每个 flex 项目都不再关心增长、收缩或它们的初始主要大小应该是什么：
- en: '![](img/00418.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00418.jpeg)'
- en: Using the justify-content property
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `justify-content` 属性
- en: 'First up is `justify-content`, which is a flex container property that determines
    whether the content is justified - or positioned - at the start of the main axis,
    the end of the main axis, or somewhere in between. Let''s add `justify-content`
    and set it to `flex-start`, as shown in the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是 `justify-content`，这是一个决定内容是否在主轴的起始位置、结束位置或中间位置对齐的 flex 容器属性。让我们添加 `justify-content`
    并将其设置为 `flex-start`，如下面的代码片段所示：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`flex-start` is the default value for `justify-content`, so nothing changes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-start` 是 `justify-content` 的默认值，因此没有任何变化：'
- en: '![](img/00419.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00419.jpeg)'
- en: '`flex-start` positions the flex items at the start of the main axis. Remember,
    when `flex-direction` is not specified, or specified as `row`, the main axis runs
    from left to right horizontally. So `flex-start` would be the left edge and `flex-end`
    would be the right edge:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-start` 将 flex 项目定位在主轴的起始位置。请记住，当未指定 `flex-direction` 或指定为 `row` 时，主轴水平从左到右。因此，`flex-start`
    将是左边缘，`flex-end` 将是右边缘：'
- en: '![](img/00420.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00420.jpeg)'
- en: 'Now let''s change the value to `flex-end`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将值更改为 `flex-end`：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The content is now positioned to the right:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 内容现在定位到右侧：
- en: '![](img/00421.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00421.jpeg)'
- en: 'This is a lot like using `float:right`, except without all the extra baggage
    and issues that come along with floats: no clearing, no collapsing, and no reshuffling
    of the floated items. Essentially, we just position the flex items to the right.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这很像使用 `float:right`，只是没有所有额外的麻烦和与浮动相关的问题：没有清除、没有折叠，也没有重新排列浮动项目。基本上，我们只是将 flex
    项目定位到右侧。
- en: 'That''s pretty useful and all, but the real magic happens when we use `justify-content:
    center`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '这非常有用，但真正的魔力是当我们使用 `justify-content: center` 时发生的：'
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Oh my gosh, we've just centered the flex items!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，天哪，我们刚刚将 flex 项目居中了！
- en: '![](img/00422.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00422.jpeg)'
- en: 'There was never a `float: center`. Admittedly, we could center things by setting
    the left and right margins to `auto` on the container. But the problem with that
    was we always had to specify the `width` of the container when we do this; therefore,
    if the number of items in the container changed, we would have to change the `width`
    property as well. There are other tricks to centering things, but none this easy
    and flexible.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '从来没有 `float: center`。诚然，我们可以通过在容器上将左右边距设置为 `auto` 来居中物品。但问题是，这样做时我们总是必须指定容器的
    `width`；因此，如果容器中的项目数量发生变化，我们还必须更改 `width` 属性。有其他居中的技巧，但没有一个像这样简单和灵活。'
- en: 'Flexbox is inherently more prepared for dynamic content and doesn''t need any
    `width` defined; let''s add another flex item to the HTML to prove this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox 本质上更适合动态内容，不需要定义任何 `width`；让我们在 HTML 中添加另一个 flex 项目来证明这一点：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we have six items and all of them are still centered:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有六个项目，它们都仍然居中：
- en: '![](img/00423.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00423.jpeg)'
- en: 'But wait, there''s more! There''s a keyword called `space-between` that we
    can use:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，还有更多！有一个名为 `space-between` 的关键字可以使用：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This keyword, `space-between`, redistributes the extra space evenly between
    each item. So there''s "space between" each element:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键字`space-between`在每个项之间均匀分配了额外的空间。因此每个元素之间都有"空间"：
- en: '![](img/00424.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00424.jpeg)'
- en: Notice that the first and last elements are hugging the edge; the first flex
    item hugs the left-most edge of its container; and the last flex item hugs the
    right-most edge of its container.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一个和最后一个元素紧贴边缘；第一个flex项紧贴其容器的最左边缘；最后一个flex项紧贴其容器的最右边缘。
- en: 'There''s another value, though, `space-around` that does something slightly
    different:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个值，`space-around`做了一些略有不同的事情：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that `space-around` redistributes the extra space of the container around
    all the flex items, even the first and the last, whereas `space-between` inserts
    extra space only between each item.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`space-around`重新分配了容器周围所有flex项的额外空间，甚至是第一个和最后一个，而`space-between`只在每个项之间插入额外的空间。
- en: '![](img/00425.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00425.jpeg)'
- en: 'Let''s revisit the Home page and implement this in a more practical example,
    that is, our three columns:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到主页，在一个更实际的例子中实现这一点，也就是我们的三列：
- en: '![](img/00426.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00426.jpeg)'
- en: 'Our three columns are set to `display: flex` but no other flex properties are
    applied. The flex items are kind of centered already because the flex container
    is centered. However, we want some space between each flex item. So in our area
    of the CSS for our columns, let''s say `justify-content: space-between`. Unrelated
    to what we''re currently doing. I am also setting `max-width: 50%` on our sea
    creatures so they are not so big. But more important is the `justify-content`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的三列设置为`display: flex`，但没有应用其他flex属性。flex项已经有点居中，因为flex容器已经居中。然而，我们希望每个flex项之间有一些空间。因此，在我们的CSS区域中，让我们说`justify-content:
    space-between`。与我们目前正在做的无关。我还在我们的海洋生物上设置了`max-width: 50%`，这样它们就不会太大。但更重要的是`justify-content`：'
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Nothing changes!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何变化！
- en: '![](img/00427.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00427.jpeg)'
- en: This is because of the text in each column. The content is pushing each flex
    item to fill out the space available. So we need to add a `width` to these items
    or `flex-basis` to explicitly define how wide we prefer each column to be. This
    is because since there's no extra space, there's no way for flexbox to redistribute
    the flex items to put extra space between each flex item. We need some extra space.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每列中的文本。内容推动每个flex项填充可用的空间。因此，我们需要为这些项添加`width`或`flex-basis`，以明确定义我们希望每列有多宽。这是因为由于没有额外的空间，flexbox无法重新分配flex项以在每个flex项之间放置额外的空间。我们需要一些额外的空间。
- en: 'Let''s do this by adding `flex-basis: 30%` to each column:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们通过向每列添加`flex-basis: 30%`来实现这一点：'
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Refresh the page and this is what you should see:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面，你应该看到这个：
- en: '![](img/00428.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00428.jpeg)'
- en: 'Notice the space is evenly distributed between each item. Lovely! We still
    have a little cleaning to do, though. The button at the bottom is not consistently
    at the bottom of each column; this is not so noticeable now because the content
    within each column is relatively the same; however, it will become more apparent
    if we make the amount of content in each column a lot different:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意空间在每个项之间均匀分布。太棒了！我们还有一点清理要做。底部的按钮在每列底部的位置不一致；现在这并不太明显，因为每列内的内容相对相同；然而，如果我们使每列中的内容量有很大的不同，这将变得更加明显：
- en: '![](img/00429.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00429.jpeg)'
- en: How do we fix this? Well, remember, in our case, the flex container is the columns,
    and each column is a flex item. The button is not a flex item because it is within
    the column. This is where nested flexboxes come into play.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？好吧，记住，在我们的情况下，flex容器是列，每列是一个flex项。按钮不是一个flex项，因为它在列内。这就是嵌套的flexbox发挥作用的地方。
- en: Nesting Flexboxes
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套的Flexbox
- en: 'Let''s convert the column into a nested flex container:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将列转换为嵌套的flex容器：
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Of course, the flex items of a container are set as `flex-direction:row` by
    default, so they all sit next to each other horizontally, which totally destroyed
    things:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，容器的flex项默认设置为`flex-direction:row`，因此它们都水平地坐在一起，这完全破坏了事情：
- en: '![](img/00430.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00430.jpeg)'
- en: 'That''s not what we want it to look like, obviously, but we can easily remedy
    this. Let''s change `flex-direction` to `column`, as shown in the following code
    snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是我们想要的样子，但我们可以很容易地解决这个问题。让我们将`flex-direction`更改为`column`，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Nice, we''re back in business. Looks identical to what it did before we made
    the columns a flex container:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们又回到了正轨。看起来和我们将列设置为flex容器之前一样：
- en: '![](img/00431.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00431.jpeg)'
- en: 'How does this help us? Well, we could start using `justify-content` and maybe
    we could say `justify-content`, `space-between`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们有什么帮助？嗯，我们可以开始使用`justify-content`，也许我们可以说`justify-content`，`space-between`：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This makes the button sit nicely at the bottom but now in the middle of the
    content. The space between each flex item is spaced out evenly, which ends up
    being different for each column, and thus not looking great:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这使按钮在底部很好地放置，但现在在内容的中间。每个flex项之间的空间均匀分布，这对于每列来说是不同的，因此看起来不太好：
- en: '![](img/00432.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00432.jpeg)'
- en: 'Let''s revert back to the default value for `justify-content`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们恢复`justify-content`的默认值：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This moves everything back to the top because `flex-direction` is `column`,
    and the main axis now runs up and down:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这将所有内容移回顶部，因为`flex-direction`是`column`，主轴现在是上下方向的：
- en: '![](img/00433.jpeg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00433.jpeg)'
- en: Using automatic margins
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自动边距
- en: 'Something notable about flexbox is that it does a fresh take of the `auto`
    keyword for `margin`. Automatic margins are now working very closely with flexbox.
    I can now target my button as the selector and give it `margin-top` of `auto`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 关于flexbox的一个显著特点是它对`margin`的`auto`关键字进行了全新的处理。自动边距现在与flexbox密切配合。我现在可以将我的按钮作为选择器，并给它`margin-top`为`auto`：
- en: '[PRE49]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Boom! The space above the button is now automatically calculated, and the button
    is positioned at the bottom of each column:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！按钮上方的空间现在自动计算，按钮位于每列的底部：
- en: '![](img/00434.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00434.jpeg)'
- en: 'This also works when flex-direction is row; you can use `margin-left: auto;`
    or `margin-right: auto` to hug flex items to the outer edges of their flex container.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '当flex-direction是row时，这也适用；您可以使用`margin-left: auto;`或`margin-right: auto`将flex项紧贴到其flex容器的外边缘。'
- en: 'To illustrate an example of this, let''s go back to our flexbox demo sample,
    and we can change `justify-content` of the flex container to `flex-start` and
    then add another rule set that pushes the final flex item to hug the right edge
    using `margin-left: auto`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '为了举例说明，让我们回到我们的flexbox演示示例，我们可以将flex容器的`justify-content`更改为`flex-start`，然后添加另一个规则集，使用`margin-left:
    auto`将最后一个flex项推到右边缘：'
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'All of the flex-items are lined up on the left -at their `flex-start` - except
    for the last flex item, which is hugging the right -or at the `flex-end` - because
    we''re calculating it''s left margin automatically:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的flex项都排在左边-在它们的`flex-start`处-除了最后一个flex项，它紧贴在右边-或者在`flex-end`处-因为我们自动计算它的左边距：
- en: '![](img/00435.jpeg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00435.jpeg)'
- en: 'Let''s go back to the Home page and look at our columns. One last thing about
    these columns: the red headline is not aligned at the same vertical position for
    each one because each of our sea creature SVG''s are of a slightly different height:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到主页，看看我们的列。关于这些列的最后一件事：红色标题不是每个都在同一垂直位置对齐，因为我们的每个海洋生物SVG的高度略有不同：
- en: '![](img/00436.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00436.jpeg)'
- en: 'Let''s give each sea creature a `flex-basis` of `150px`. Since, `flex-direction`
    is `column`, `flex-basis` can be thought of as the height; therefore, we''re basically
    giving each figure the same height of `150px`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给每个海洋生物一个`flex-basis`为`150px`。由于`flex-direction`是`column`，`flex-basis`可以被视为高度；因此，我们基本上给每个图形相同高度的`150px`：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now those red headlines will all sit neatly together:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些红色标题将整齐地排在一起：
- en: '![](img/00437.jpeg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00437.jpeg)'
- en: In summary, `justify-content` positions and redistributes extra space along
    the main axis. You can nest flexboxes all day long, and automatic margins are
    pretty sweet and allow you to position content to hug the opposite edge of a flex
    container, which is an enormously common UI pattern.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`justify-content`沿着主轴定位和重新分配额外的空间。您可以整天嵌套flexbox，并且自动边距非常方便，可以让您将内容定位到flex容器的相反边缘，这是一个非常常见的UI模式。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've covered a ton of ground with flexbox in this chapter including all of
    the basic flexbox properties. We'll carry that on in the next chapter when we
    look at how to align and flow flexbox content, and the properties that are required
    to do that. We'll also create a new UI pattern—a product listing—and see how flexbox
    can help there.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了flexbox的大量内容，包括所有基本的flexbox属性。在下一章中，当我们学习如何对齐和流动flexbox内容以及所需的属性时，我们将继续进行。我们还将创建一个新的UI模式-产品列表-并看看flexbox如何在那里发挥作用。
