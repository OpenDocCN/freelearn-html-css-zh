- en: Chapter 1. Harness the Power of Sass for Responsive Web Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 利用Sass为响应式网页设计赋能
- en: Before we dive into mastering responsive web design with HTML5 and CSS3, we
    need to be on the same page as far as technologies go, in our case, CSS preprocessors
    and, specifically, Sass.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入掌握使用HTML5和CSS3进行响应式网页设计之前，我们需要就技术达成共识，就我们的情况而言，CSS预处理器，特别是Sass。
- en: In this book, all CSS is going to be written in Sass in SCSS format. The way
    we write CSS has changed; it has improved tremendously.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，所有的CSS都将以SCSS格式写成Sass。我们编写CSS的方式已经改变，改进非常大。
- en: 'CSS preprocessors such as Sass, LESS, and Stylus give the web/mobile designers
    and developers new superpowers. Yes, I used the word *superpowers* because that''s
    exactly how I felt only a few hours after using Sass for the first time, and what
    I used was as basic as it gets:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CSS预处理器如Sass、LESS和Stylus为网络/移动设计师和开发人员提供了新的超能力。是的，我用了*超能力*这个词，因为这正是我第一次使用Sass仅仅几个小时后的感受，而我使用的只是最基本的东西：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'See the nested `li` selector? Yeah, that''s Sass in action. When the preceding
    code is compiled, this is what it looks like:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 看到嵌套的`li`选择器了吗？是的，那就是Sass在起作用。当前面的代码被编译时，就会变成这样：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载示例代码文件，用于您购买的所有Packt
    Publishing图书。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: 'Let''s see what''s in store for us in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本章给我们带来了什么：
- en: How does Sass work?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass是如何工作的？
- en: The basic concepts of Sass to consider for **Responsive Web Design** (**RWD**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要考虑的Sass的基本概念**响应式网页设计**（**RWD**）
- en: How does Sass work?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sass是如何工作的？
- en: 'Knowing how Sass works is a matter of understanding several basic technological
    concepts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Sass的工作原理涉及理解几个基本的技术概念：
- en: 'Sass can be based on two different technologies: Ruby or LibSass. In this book,
    we''re going to use Sass based on Ruby.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sass可以基于两种不同的技术：Ruby或LibSass。在本书中，我们将使用基于Ruby的Sass。
- en: Sass is a Ruby gem. Gems are packages for use in Ruby. A Ruby gem is a software
    that runs only on Ruby. Ruby is a programming language, just like PHP, .NET, Java,
    and so on.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sass是一个Ruby gem。Gems是用于Ruby的软件包。Ruby gem是一种只能在Ruby上运行的软件。Ruby是一种编程语言，就像PHP、.NET、Java等一样。
- en: We can make Sass run via the command line, but we can also run Sass with a third-party
    application, making the use of the command line unnecessary.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过命令行运行Sass，但也可以使用第三方应用程序运行Sass，从而不需要使用命令行。
- en: Sass is a programming/scripting language used to create CSS.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sass是一种用于创建CSS的编程/脚本语言。
- en: CSS is a very repetitive language. Sass allows authors to optimize those repetitive
    tasks and create CSS faster and more efficiently.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSS是一种非常重复的语言。Sass允许作者优化这些重复的任务，更快、更高效地创建CSS。
- en: Part of the Sass workflow is when Sass is *watching* an SCSS file, for example,
    `book-styles.scss`. When it detects a change in that SCSS file, it then compiles
    it into a CSS file `book-styles.css`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sass工作流程的一部分是当Sass正在*监视*一个SCSS文件时，例如`book-styles.scss`。当它检测到该SCSS文件的更改时，它会将其编译成一个CSS文件`book-styles.css`。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '*Watching an SCSS file* means that the Sass watcher is running in the background
    looking over the SCSS file(s) for any changes.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*监视一个SCSS文件*意味着Sass监视器在后台监视SCSS文件的任何更改。'
- en: Installing Sass
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Sass
- en: 'Here are the steps we''re going to follow:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要遵循的步骤：
- en: Download the Ruby installer
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Ruby安装程序
- en: Open the command line
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行
- en: Install the Sass gem
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Sass gem
- en: Downloading the Ruby installer
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载Ruby安装程序
- en: '**Windows**: Download the Ruby installer from the following link:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**：从以下链接下载Ruby安装程序：'
- en: '[http://rubyinstaller.org/downloads/](http://rubyinstaller.org/downloads/)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://rubyinstaller.org/downloads/](http://rubyinstaller.org/downloads/)'
- en: '**Mac**: Ruby comes preinstalled on all Macs, so there''s no need to download
    anything.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mac**：Ruby预装在所有的Mac上，所以不需要下载任何东西。'
- en: Opening the command line
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开命令行
- en: '**Windows and Mac**: Open the command line.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows和Mac**：打开命令行。'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Windows Tip!**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows提示！**'
- en: Press *Windows* + *R*, type `CMD`, and then press *Enter*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Windows* + *R*，输入`CMD`，然后按*Enter*。
- en: '![Opening the command line](img/B02102_01_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![打开命令行](img/B02102_01_01.jpg)'
- en: Installing the Sass gem
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Sass gem
- en: 'Type the following command into the command prompt (it doesn''t matter which
    folder you''re in):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中键入以下命令（无论您在哪个文件夹中都可以）：
- en: 'Windows, use the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Windows，使用以下命令：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Mac, use the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Mac，使用以下命令：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Installing the Sass gem](img/B02102_01_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![安装Sass gem](img/B02102_01_02.jpg)'
- en: It'll take a few seconds to install Sass.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Sass需要几秒钟时间。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At the time of writing, the latest version of Sass was 3.4.14\. The version/revisions
    might be different by the time the book comes out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Sass的最新版本是3.4.14。版本/修订可能在书出版时有所不同。
- en: That's it! Sass is now installed on your machine.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！Sass现在已经安装在您的计算机上。
- en: Using Sass
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sass
- en: What I'm about to show you is completely different to what any other Sass tutorial
    out there tells you to do. Most of those tutorials complicate things too much.
    This is the simplest way to use Sass you'll ever read.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要向您展示的内容与其他任何Sass教程告诉您要做的完全不同。大多数教程都把事情复杂化了。这是您将阅读到的使用Sass的最简单的方法。
- en: The following screenshots are on Windows, but the process can be applied exactly
    the same regardless of platform.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的屏幕截图是在Windows上的，但是这个过程可以在任何平台上完全相同地应用。
- en: 'In the following steps, you will see examples of how the necessary folders
    and files look after being created, not how to create them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，您将看到创建后的必要文件夹和文件的示例，而不是如何创建它们：
- en: Create a `/Demo` folder anywhere on your drive:![Using Sass](img/B02102_01_04.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的驱动器的任何位置创建一个`/Demo`文件夹：![使用Sass](img/B02102_01_04.jpg)
- en: Inside that folder, create two subfolders, `/css` and `/scss`:![Using Sass](img/B02102_01_05.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中，创建两个子文件夹，`/css`和`/scss`：![使用Sass](img/B02102_01_05.jpg)
- en: Create a `.scss` file. Go into the `/scss` folder and create a file called `styles.scss`:![Using
    Sass](img/B02102_01_06.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`.scss`文件。进入`/scss`文件夹并创建一个名为`styles.scss`的文件：![使用Sass](img/B02102_01_06.jpg)
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice the file extension `.scss`? This is your Sass file. Yes, right now there's
    nothing in it, it's empty.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件扩展名`.scss`？这是你的Sass文件。是的，现在里面什么都没有，它是空的。
- en: 'Go back to the command line for a minute and follow these steps:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到命令行一分钟，按照以下步骤操作：
- en: In the command line, type `cd <space>`
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入`cd <空格>`
- en: A space after `cd` means *Change Directory*. From your file manager, drag and
    drop the `/Demo` folder into the command prompt/terminal window and press *Enter*.![Using
    Sass](img/B02102_01_06a.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cd`后加一个空格意味着*改变目录*。从你的文件管理器中，将`/Demo`文件夹拖放到命令提示符/终端窗口中，然后按*Enter*。![使用Sass](img/B02102_01_06a.jpg)
- en: You should be in the `/Demo` folder now.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该在`/Demo`文件夹中。
- en: '![Using Sass](img/B02102_01_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sass](img/B02102_01_07.jpg)'
- en: 'Make Sass *watch* your `/scss` and `/css` folders by typing this in the command
    line:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令行中输入以下内容，让Sass *监视*你的`/scss`和`/css`文件夹：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make Sass watch the `/scss` and `/css` folders.![Using Sass](img/B02102_01_08.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让Sass监视`/scss`和`/css`文件夹。![使用Sass](img/B02102_01_08.jpg)
- en: That's it! You are now using Sass!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你现在正在使用Sass！
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `--watch` flag tells Sass to pay attention to the `/scss` and `/css` folders
    so that when we make a change to a `.scss` file (in our case, `styles.scss`),
    Sass will detect the change and compile the SCSS into the final CSS file we're
    going to use in our website or app.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`--watch`标志告诉Sass关注`/scss`和`/css`文件夹，这样当我们对`.scss`文件（在我们的例子中是`styles.scss`）进行更改时，Sass将检测到更改并将SCSS编译成我们将在网站或应用程序中使用的最终CSS文件。'
- en: 'Edit the `.scss` file and watch Sass compile it into a `.css` file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`.scss`文件并观察Sass将其编译成`.css`文件：
- en: Open your text editor (I use Sublime Text).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的文本编辑器（我用Sublime Text）。
- en: Open the `styles.scss` file.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`styles.scss`文件。
- en: Add some CSS to it.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加一些CSS。
- en: Save the `styles.scss` file.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`styles.scss`文件。
- en: From your command line/terminal, verify that the compiling was successful.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的命令行/终端中，验证编译是否成功。
- en: Open your `styles.css` file and enjoy your new creation.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`styles.css`文件，享受你的新作品。
- en: '![Using Sass](img/B02102_01_09.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sass](img/B02102_01_09.jpg)'
- en: The basic concepts of Sass for RWD
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RWD的Sass基本概念
- en: For starters, Sass is a programming/scripting language. I bet you didn't see
    that one coming. Yes, it's a programming/scripting language focused on increasing
    the efficiency of web designers and web developers creating CSS. In this book,
    we're going to focus on the simple parts of Sass that can help us write CSS more
    efficiently, and more importantly, we'll have fun doing it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Sass是一种编程/脚本语言。我打赌你没有想到。是的，它是一种专注于提高网页设计师和开发人员创建CSS效率的编程/脚本语言。在本书中，我们将专注于Sass的简单部分，这些部分可以帮助我们更有效地编写CSS，更重要的是，我们会在其中获得乐趣。
- en: 'Implementing RWD is time consuming: coding, testing, creating assets, browser
    troubleshooting, and then testing some more. The more we streamline our coding
    processes and the less repetitive work we do, the more efficient we become and
    the more value we add to a project, our team, the business and eventually, our
    users. Sass is going to do just that—help us streamline the coding of CSS.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实施RWD是耗时的：编码、测试、创建资产、浏览器故障排除，然后再进行更多测试。我们简化编码过程的程度越高，重复性工作越少，我们就变得越有效率，为项目、团队、业务甚至最终用户增加的价值也就越多。Sass将会做到这一点——帮助我们简化CSS的编码。
- en: 'Let''s discuss the following concepts first:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论以下概念：
- en: Sass or SCSS
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass或SCSS
- en: Variables
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Mixins
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合
- en: Arguments
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数
- en: Nesting
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套
- en: Partial files
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分文件
- en: '@import'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@import'
- en: Source maps
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源映射
- en: Sass comments
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass注释
- en: Sass or SCSS
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sass或SCSS
- en: 'There are two ways we can write Sass-style CSS: the Sass syntax and the SCSS
    syntax.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两种方式编写Sass风格的CSS：Sass语法和SCSS语法。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make no mistake; Sass is written with capital S and the rest with lower case
    and SCSS is all uppercase.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要误解；Sass是大写S，其余都是小写，而SCSS全部大写。
- en: The Sass syntax
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sass语法
- en: The Sass syntax, also known as the *indented syntax*, was the initial and only
    way to write Sass. But it looked a bit too different than regular CSS, making
    the learning curve steeper than it really needed to be.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Sass语法，也被称为*缩进语法*，是最初和唯一的编写Sass的方式。但它看起来与常规CSS有些不同，使学习曲线比实际需要的更陡峭。
- en: This syntax didn't use any braces or semicolons. In some cases, instead of colons
    it used the equals sign. Unlike SCSS, indentation was very strict and mandatory.
    Many developers weren't too fond of these aspects of the Sass syntax.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法没有使用任何大括号或分号。在某些情况下，它使用等号而不是冒号。与SCSS不同，缩进非常严格且是强制性的。许多开发人员对Sass语法的这些方面并不太喜欢。
- en: 'Here''s a basic example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的例子：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This compiles to the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译成以下代码：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The SCSS syntax
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SCSS语法
- en: When SCSS was introduced with the release of version 3 of Sass, things got a
    lot easier for those of us who are not programmers but want to harness the power
    of Sass.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当SCSS在Sass的第3个版本中引入时，对于我们这些不是程序员但想要利用Sass功能的人来说，事情变得更容易了。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SCSS stands for **Sassy CSS**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SCSS代表**Sassy CSS**。
- en: If you already write CSS, you already write SCSS. All the things we already
    used while writing CSS are the same things we'll use when writing Sass with the
    SCSS syntax. So, the learning curve is initially nonexistent.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经写CSS，那么你已经写了SCSS。我们在编写CSS时已经使用的所有东西，在使用SCSS语法编写Sass时也是一样的。因此，学习曲线最初是不存在的。
- en: Then, you realize that you can also use bits of Sass that enhance what you already
    know, making learning Sass an awesome experience because you can get good at it
    quite fast. It honestly feels like you're gaining superpowers. I'm not kidding.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会意识到你还可以使用一些增强你已经知道的Sass功能，这使得学习Sass成为一种很棒的体验，因为你可以相当快地变得擅长它。说实话，这感觉就像你正在获得超能力。我不是在开玩笑。
- en: 'Here''s the same example we saw before with the SCSS syntax:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们之前看到的相同示例，使用SCSS语法：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Wait a second! That's CSS! Yes, and it's also SCSS.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！那是CSS！是的，它也是SCSS。
- en: 'Let''s see that same example in a different way using the SCSS syntax as well:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以不同的方式使用SCSS语法看同一个例子：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The ampersand symbol, `&`, in SCSS allows us to add the name of the parent selector
    to the nested selectors without having to type the whole thing, keeping us on
    the *DRY* side of things.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在SCSS中，`&`符号允许我们将父选择器的名称添加到嵌套选择器中，而无需输入整个内容，使我们保持*DRY*的状态。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: DRY means Don't Repeat Yourself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: DRY表示不要重复自己。
- en: 'Both SCSS examples compile to the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个SCSS示例编译为以下代码：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sass variables
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sass变量
- en: 'Let''s understand a few things first:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们了解一些事情：
- en: A variable is simply a way to store a value for later use
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量只是一种存储值以供以后使用的方法
- en: This value is usually associated with a simple *user-friendly* word
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个值通常与一个简单的*用户友好*单词相关联
- en: Sass variables have to start with a dollar sign (`$)` symbol
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass变量必须以美元符号(`$)`开头
- en: The great benefit of variables is that if we need to change the value, we would
    make the change in a single place rather than finding and replacing the value
    across the entire document
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的巨大好处是，如果我们需要更改值，我们只需在一个地方进行更改，而不是在整个文档中查找和替换值
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When listing more than one variable, there should be a semicolon symbol (`;`)
    at the end of each variable. If there's only one variable, there's no need for
    the semicolon. However, this is a good practice to always end variables with a
    semicolon even if it's just one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出多个变量时，每个变量的末尾应该有一个分号(`;`)。如果只有一个变量，则不需要分号。然而，即使只有一个变量，最好也以分号结束变量，这是一个好习惯。
- en: 'Here''s an example of a Sass variable:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Sass变量的一个例子：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I recommend you name variables using the *camelCase* style in order to differentiate
    them from dash-separated class names and CSS properties. This is very helpful
    when scanning the SCSS document, because the variables are easier to detect.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您使用*驼峰命名法*来命名变量，以便将它们与以破折号分隔的类名和CSS属性区分开。在扫描SCSS文档时，这非常有帮助，因为变量更容易检测到。
- en: As we can see, we're storing a color value. The name we're using, `brandBlue`,
    is certainly more user friendly than `#416e8e`. Also, we're using the dollar sign
    symbol (`$`) and ending it with a semicolon (`;`) for good measure if/when we
    need to add more variables. Now, if we need to change the value later, all we'd
    need to do is change it in one location.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们正在存储一个颜色值。我们使用的名称`brandBlue`肯定比`#416e8e`更用户友好。此外，我们使用了美元符号(`$`)并以分号(`;`)结束，以防我们需要添加更多变量。现在，如果以后需要更改值，我们只需要在一个位置进行更改。
- en: The variables should always be included at the top of your SCSS file so Sass
    knows where to go when using them. You can also include them via a partial file,
    but we'll talk about what partial files are later on in the chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 变量应始终包含在SCSS文件的顶部，以便Sass知道在使用它们时应该去哪里。您还可以通过部分文件包含它们，但我们将在本章后面讨论部分文件是什么。
- en: 'Here''s an example of how to use an SCSS variable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用SCSS变量的示例：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code compiles to the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码编译为以下内容：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sass mixins
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sass mixin
- en: Mixins are one of the most powerful features of Sass. **Mixins** are a group
    of CSS declarations (a property and value) that are stored for later use, just
    like a variable. So instead of typing all those CSS declarations over and over
    again, we just type the mixin's name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Mixin是Sass最强大的功能之一。**Mixin**是一组CSS声明（属性和值），可以存储以供以后使用，就像变量一样。因此，我们不必一遍又一遍地输入所有这些CSS声明，只需输入mixin的名称。
- en: 'A few things to consider about Sass mixins are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Sass mixin需要考虑的几件事情如下：
- en: They start with the `@mixin` directive
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们以`@mixin`指令开头
- en: A mixin is called with the `@include` directive
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@include`指令调用mixin
- en: We can store any amount of CSS/SCSS data in a mixin
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在mixin中存储任意数量的CSS/SCSS数据
- en: Try to use *arguments* when creating a mixin so it's more scalable
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在创建mixin时使用*参数*，这样它就更具可扩展性
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We haven't seen what *arguments* are yet, but it's important to mention the
    word now so you can start getting familiar with different Sass terminology. We'll
    cover Sass arguments in the next section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到*参数*是什么，但现在提到这个词很重要，这样你就可以开始熟悉不同的Sass术语。我们将在下一节中介绍Sass参数。
- en: 'Let see an example of a mixin:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个mixin的例子：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We call a mixin in our SCSS file as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在SCSS文件中调用mixin如下：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When compiled, it looks like this in the CSS:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，在CSS中看起来像这样：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's recap what we did in the mixin.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在mixin中所做的事情。
- en: 'We used the `@mixin` directive:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`@mixin`指令：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We used the camelCase naming convention to differentiate the mixin''s name
    from dash-separated class names and CSS properties:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用驼峰命名约定来区分mixin的名称和以破折号分隔的类名和CSS属性：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We used Sass variables within the mixin:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在mixin中使用了Sass变量：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We used the keyword `black` in the `box-shadow` color property instead of using
    the hex `#000` or `rgb (0, 0, 0)` values:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`box-shadow`颜色属性中使用关键字`black`，而不是使用十六进制`#000`或`rgb (0, 0, 0)`值：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For that matter, we could''ve also used our variable name like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们也可以像这样使用我们的变量名：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also omitted the `0` in the alpha value (`.3`). This is actually not a Sass
    feature; this is a CSS feature:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还省略了alpha值中的`0`（`.3`）。这实际上不是Sass的特性；这是CSS的特性：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: On decimal values that start with a zero, the zero can be omitted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在以零开头的小数值上，零可以被省略。
- en: 'Again, the preceding mixin compiles to the following CSS:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，上述mixin编译为以下CSS：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sass arguments
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sass参数
- en: In our first mixin example, we didn't have any arguments. This is really not
    ideal because it doesn't allow us to use different values in the same properties.
    In reality, not using any arguments in a mixin isn't really any different than
    typing the same properties and values every time we need them. We are not really
    doing any DRY.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个mixin示例中，我们没有任何参数。这实际上并不理想，因为它不允许我们在相同的属性中使用不同的值。实际上，在mixin中不使用任何参数并不比每次需要它们时键入相同的属性和值有任何不同。我们并没有真正做到DRY。
- en: '*Arguments* are the part(s) of a mixin in which you can put your own values
    depending on your needs. Arguments make a mixin worth creating.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*参数*是mixin的一部分，您可以根据需要放入自己的值。参数使mixin值得创建。'
- en: 'In the mixin example mentioned earlier, let''s add an argument:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的mixin示例中，让我们添加一个参数：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The argument for `padding` allows us to set any value we want. We are not *forced*
    to have the padding as `10px` every time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`padding`参数允许我们设置任何我们想要的值。我们并不*强制*每次都将填充设置为`10px`。'
- en: 'This is how we set the value of the argument:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何设置参数的值：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This compiles to the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译为以下内容：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, there's a potential problem with the argument; if we don't set a value
    for the `padding`, we're going to get an error when compiling.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，参数存在潜在问题；如果我们不为`padding`设置值，编译时会出现错误。
- en: So the solution here is to set a *default* value; if we don't define a value
    for `padding` for some reason, Sass is going to take that default value and use
    it when compiling without throwing an error.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的解决方案是设置一个*默认*值；如果由于某种原因我们没有为`padding`定义一个值，Sass将采用默认值并在编译时使用它而不会抛出错误。
- en: 'Here''s how we set a default value of an argument:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何设置参数的默认值：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is how we call the mixin, without declaring any `padding` value:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何调用mixin，而不声明任何`padding`值：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The compiled CSS is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的CSS如下：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to use several arguments in the same mixin
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何在同一个mixin中使用多个参数
- en: 'Building on the preceding mixin, let''s add a few more arguments to make it
    more robust and scalable:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的mixin基础上，让我们添加一些更多的参数，使其更加健壮和可扩展：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is how we declare the arguments when including our mixin:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在包含mixin时如何声明参数的方式：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can use the same mixin and obtain different styles without having to type
    all the properties repeatedly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的mixin并获得不同的样式，而无需重复输入所有属性。
- en: 'The preceding mixin and its arguments compile to the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的mixin及其参数编译为以下代码：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting default values in multiple arguments
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多个参数中设置默认值
- en: Sometimes, we need to define some default values in case we only need to declare
    one or a few arguments. In other words, by declaring default values in our arguments,
    we'll always be sure that a value is created and we don't get any errors when
    compiling our SCSS file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要定义一些默认值，以防我们只需要声明一个或几个参数。换句话说，通过在我们的参数中声明默认值，我们将始终确保创建一个值，并且在编译我们的SCSS文件时不会出现任何错误。
- en: 'Here''s how we set default values in our arguments:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何在参数中设置默认值：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we need to declare only the *first* property, `padding`, we can do this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要声明*第一个*属性`padding`，我们可以这样做：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This compiles to the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译为以下内容：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some Sass compilers will turn a shorthand color hex value, `#333`, to a longhand
    value, `#333333`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 某些Sass编译器将简写的颜色十六进制值`#333`转换为长格式值`#333333`。
- en: As we can see, only the first argument, `padding`, was declared. Other arguments
    used their default values and compiled successfully.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，只有第一个参数`padding`被声明。其他参数使用了它们的默认值并成功编译。
- en: But let's say we still want to declare only one argument but not the `padding`,
    which is the first in the list of arguments. Let's say we want to declare the
    background color!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，假设我们仍然只想声明一个参数，而不是`padding`，它是参数列表中的第一个。假设我们想声明背景颜色！
- en: 'In this case, we need to declare the value by typing the name of the variable:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要通过输入变量的名称来声明值：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If we want to declare only a single argument that is different from the first
    one, we need to declare the whole argument name.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想声明一个与第一个参数不同的单个参数，我们需要声明整个参数名称。
- en: There are more advanced ways to declare arguments, but this is sufficient for
    the scope of this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更高级的声明参数的方法，但这对于本书的范围来说已经足够了。
- en: Nesting in Sass
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sass中的嵌套
- en: Nesting in Sass is a perfect way to make our SCSS more readable. Just like in
    HTML where tags get nested based on their parent elements, Sass uses exactly the
    same structure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Sass中的嵌套是使我们的SCSS更易读的完美方式。就像在HTML中，标签基于其父元素进行嵌套一样，Sass使用完全相同的结构。
- en: 'Here''s an example of two-level selector nesting for a navigation bar:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是导航栏的两级选择器嵌套示例：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Beware of deep nesting! Best practices recommend nesting a maximum of three
    levels. Otherwise, we will run into selector specificity and maintainability issues
    down the road.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意深层嵌套！最佳实践建议最多嵌套三个级别。否则，我们将在未来遇到选择器特异性和可维护性问题。
- en: 'Did you notice that I used the `$brandBlue` color variable again? The preceding
    SCSS for the navigation bar compiles to the following CSS:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到我再次使用了`$brandBlue`颜色变量？前面的导航栏的SCSS编译为以下CSS：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Partial files (partials) in Sass
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sass中的局部文件（partials）
- en: Partial files are SCSS files we create to house SCSS snippets. Partials allow
    us to modularize our files, for example, `_variables.scss`. Partials start with
    the underscore symbol (`_`) and end with the extension `.scss`. The underscore
    symbol tells the compiler that this file and its contents do not need to be compiled
    into a separate CSS file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 局部文件是我们创建的用于存放SCSS片段的SCSS文件。局部文件允许我们模块化我们的文件，例如，`_variables.scss`。局部文件以下划线符号（`_`）开头，并以扩展名`.scss`结尾。下划线符号告诉编译器，这个文件及其内容不需要编译成单独的CSS文件。
- en: Partials are called using the `@import` directive, just like it is done in CSS.
    The main differences are that there's no need to specify the underscore symbol
    and the file extension.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 局部文件使用`@import`指令调用，就像在CSS中一样。主要区别在于无需指定下划线符号和文件扩展名。
- en: 'Let''s create a partial file and put these color variables in it. We''re going
    to call this partial file, `_variables.scss`. The variables (snippets) in the
    `_variables.scss` partial are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个局部文件，并把这些颜色变量放在里面。我们将称这个局部文件为`_variables.scss`。`_variables.scss`局部中的变量（片段）如下：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s then say that our main SCSS file is named `styles.scss`. We now have
    two files: `styles.scss` and `_variables.scss`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们假设我们的主SCSS文件名为`styles.scss`。现在我们有两个文件：`styles.scss`和`_variables.scss`。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The main SCSS file of a project does not start with an underscore symbol.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的主SCSS文件不以下划线符号开头。
- en: 'We call `_variables.scss` into `styles.scss` using the `@import` directive:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@import`指令将`_variables.scss`调用到`styles.scss`中：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that the underscore symbol and file extension are not needed when referencing
    a partial; they can be omitted. However, if you want to add them, that's fine
    too. Omitting them keeps the code cleaner.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在引用局部文件时，下划线符号和文件扩展名是不需要的；它们可以被省略。但是，如果你想添加它们，也可以。省略它们可以使代码更清晰。
- en: The Sass extend/inherit feature
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sass扩展/继承功能
- en: 'Many professionals say extend or inherit is one of the most useful features
    of Sass. Others actually recommend staying away from it. This book''s recommendation
    is: just use Sass as much as possible and experiment with different features so
    you can create your own opinions. When you have enough experience, you can decide
    which side you want to join.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 许多专业人士说，扩展或继承是Sass最有用的功能之一。其他人实际上建议远离它。本书的建议是：尽可能多地使用Sass，并尝试不同的功能，这样你就可以形成自己的观点。当你有足够的经验时，你可以决定加入哪一方。
- en: '**Extending** in Sass means that we can use a selector''s properties in another
    selector without having to type all those properties again. This is called **inheriting**.
    We use the `@extend` directive for this.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sass中**扩展**意味着我们可以在另一个选择器中使用选择器的属性，而不必再次输入所有这些属性。这就是所谓的**继承**。我们使用`@extend`指令来实现这一点。
- en: 'For example, consider the following selector:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下选择器：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Suppose we want to inherit all the properties of this selector on a different
    selector. We''re also going to modify one property, since they are almost identical,
    using the `@extend` directive to reuse the styles of the first selector in the
    second one:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在不同的选择器上继承这个选择器的所有属性。我们还要修改一个属性，因为它们几乎是相同的，使用`@extend`指令在第二个选择器中重用第一个选择器的样式：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This compiles to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下内容：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that `.generic-container` and `.box-customer-service` are in the same
    rule; this means that `.box-customer-service` is inheriting all the properties
    and values of `.generic-container`. Then, there's a separate rule for `.box-customer-service`,
    where only the `padding` property is declared since it's the only difference between
    the two containers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`.generic-container`和`.box-customer-service`在同一条规则中；这意味着`.box-customer-service`继承了`.generic-container`的所有属性和值。然后，有一个单独的规则为`.box-customer-service`，只声明了`padding`属性，因为这是两个容器之间的唯一区别。
- en: Sass comments
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sass注释
- en: 'Since we know that a CSS document is a valid SCSS document, using the CSS comment
    syntax is also valid:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道CSS文档是有效的SCSS文档，因此使用CSS注释语法也是有效的：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In Sass, there''s another way. We can comment using double slashes (`//`) at
    the beginning:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sass中，还有另一种方法。我们可以在开头使用双斜杠（`//`）进行注释。
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The difference between the two styles is that the traditional CSS comment using
    `/**/` syntax gets added to the compiled file, whereas the comments with Sass
    using `//` does not get added.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 两种样式之间的区别在于使用`/**/`语法的传统CSS注释会添加到编译后的文件中，而使用`//`的Sass注释则不会添加。
- en: 'The comments with the Sass syntax are very helpful to document our SCSS files
    without having to worry about all those comments getting compiled and bloating
    our final CSS file. The Sass comment in the following example doesn''t get compiled:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Sass语法中的注释非常有用，可以在不必担心所有这些注释被编译并使最终的CSS文件变得臃肿的情况下记录我们的SCSS文件。以下示例中的Sass注释不会被编译：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, the traditional CSS comment does get compiled:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，传统的CSS注释确实被编译了：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Tip
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Now, depending on the options set on the compiler, the final CSS can be minimized.
    Thus, the traditional CSS comments will get stripped out in order to optimize
    file size.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据编译器上设置的选项，最终的CSS可以被最小化。因此，传统的CSS注释将被剥离以优化文件大小。
- en: Vendor prefixing
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供应商前缀
- en: Vendor prefixing is basically adding a specific *tag* to a CSS3 property or
    value that hasn't been widely used by the web development industry and communities
    or finalized and included in the CSS3 specification.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商前缀基本上是为尚未被广泛使用或最终包含在CSS3规范中的CSS3属性或值添加特定的*标签*。
- en: 'The *vendor* part refers to the abbreviation tags that represent the names
    of the companies that create the browsers: Mozilla, Opera, and Microsoft.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*供应商*部分指的是代表创建浏览器的公司名称的缩写标签：Mozilla、Opera和Microsoft。'
- en: There's one exception though, Apple. Although Apple created Safari, the vendor
    prefix is based on the layout engine of the browser rather than the company name.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有一个例外，苹果。尽管苹果创建了Safari，但供应商前缀是基于浏览器的布局引擎而不是公司名称。
- en: 'Mozilla: `-moz-`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla：`-moz-`
- en: 'Opera: `-o-`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera：`-o-`
- en: 'Microsoft: `-ms-`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软：`-ms-`
- en: 'Webkit (Apple): `-webkit-`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webkit（苹果）：`-webkit-`
- en: 'The *prefix* part refers to the description of adding the vendor tags *before*
    the CSS property or CSS value. Each vendor prefix only works in its own browser,
    so for the preceding list, here are the browsers they belong to:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*前缀*部分指的是在CSS属性或CSS值之前添加供应商标签的描述。每个供应商前缀只在自己的浏览器中有效，因此对于上述列表，这里是它们所属的浏览器：'
- en: 'Mozilla: This prefix `-moz-` works in Firefox'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla：这个前缀“-moz-”在Firefox中有效
- en: 'Opera: This prefix `-o-` works in Opera'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera：这个前缀“-o-”在Opera中有效
- en: 'Microsoft: This prefix `-ms-` works in Internet Explorer'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软：这个前缀“-ms-”在Internet Explorer中有效
- en: 'Webkit (Apple): This prefix `-webkit-` works in Safari'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webkit（苹果）：这个前缀“-webkit-”在Safari中有效
- en: If you're wondering where Google Chrome is in all this, there's a simple explanation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道谷歌Chrome在这一切中的位置，这有一个简单的解释。
- en: 'Although Google created Chrome, there is no specific prefix for Chrome. In
    the beginning, Chrome was using the same layout engine as Safari: Webkit. Thus,
    the Webkit-based prefixes not only affected Safari, but also affected Chrome and
    other Chromium-based products.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管谷歌创建了Chrome，但Chrome没有特定的前缀。起初，Chrome使用与Safari相同的布局引擎：Webkit。因此，基于Webkit的前缀不仅影响了Safari，还影响了Chrome和其他基于Chromium的产品。
- en: However, Google Chrome no longer uses Webkit; it now uses its own layout engine
    called Blink. However, in order to maintain compatibility and avoid fragmenting
    the Web even more, Chrome still supports the `-webkit-` prefix.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，谷歌浏览器不再使用Webkit；它现在使用自己的布局引擎称为Blink。然而，为了保持兼容性并避免进一步分裂网络，Chrome仍然支持`-webkit-`前缀。
- en: Opera had a similar story where they had their own layout engine, Presto, and
    then switched to Webkit. It now uses Blink. There are other browser vendors in
    addition to the ones mentioned before and they use their own prefixes as well,
    such as the Konqueror browser with its prefix, `-k-`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Opera有一个类似的故事，他们有自己的布局引擎Presto，然后切换到Webkit。现在它使用Blink。除了之前提到的浏览器供应商之外，还有其他浏览器供应商，他们也使用自己的前缀，比如Konqueror浏览器的前缀`-k-`。
- en: 'Here''s an example of a vendor-prefixed CSS property:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有供应商前缀的CSS属性的例子：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And, here''s an example of a prefixed CSS value:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个带前缀的CSS值的例子：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The order of vendor prefixing
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 供应商前缀的顺序
- en: The reality is that the order in which we can list the vendor prefixes doesn't
    matter; what matters is that we always place the nonvendor prefixed version at
    the end.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们列出供应商前缀的顺序并不重要；重要的是我们总是将非供应商前缀的版本放在最后。
- en: 'Staying with the example of the linear-gradient property, we should do it like
    this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以linear-gradient属性为例，我们应该这样做：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Tip
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can also use `background: linear-gradient(red, blue);` if you like.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你喜欢，你也可以使用`background: linear-gradient(red, blue);`。'
- en: The reason the nonvendor-prefixed declaration should always be last is, if the
    browser vendor modifies its prefix or drops the support for it, the last line
    will always override anything above it because of the cascade. This makes the
    whole CSS rule more future-proof. Plus, we won't have to rewrite our style sheets
    every time a vendor changes something.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 非供应商前缀的声明应该始终放在最后，因为如果浏览器供应商修改其前缀或停止支持它，最后一行将始终覆盖上面的任何内容，因为级联。这使整个CSS规则更具未来性。此外，我们不必在供应商更改内容时重写样式表。
- en: Now, many CSS3 properties and values do not need all vendor prefixes. Most of
    the time, they only need a couple of vendor prefixes, and other times the nonvendor-prefixed
    - properties or values is enough.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多CSS3属性和值不需要所有供应商前缀。大多数情况下，它们只需要一些供应商前缀，其他时候非供应商前缀的属性或值就足够了。
- en: But how do we know which CSS3 properties and values can be prefixed or not so
    that we can create styles that are supported by certain legacy browsers without
    having to memorize so much information?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何知道哪些CSS3属性和值可以加前缀，哪些不需要，这样我们就可以创建受某些旧浏览器支持的样式，而不必记住太多信息？
- en: The answer is *automating* the vendor prefixing process.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是*自动化*供应商前缀的过程。
- en: Automating vendor prefixing
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动添加供应商前缀
- en: There are several problems that come with vendor prefixing, and we can't get
    away from these if we want some of our CSS3 properties to work in current browsers
    and/or certain legacy ones. Vendor prefixing is dirty work and we *don't* have
    to do it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商前缀带来了一些问题，如果我们希望一些CSS3属性在当前浏览器和/或某些旧浏览器中工作，我们就无法摆脱这些问题。供应商前缀是肮脏的工作，我们*不*必须这样做。
- en: So how do we automate the process of vendor prefixing while keeping our work
    as DRY as possible? There are several ways.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在尽可能保持DRY的情况下自动化供应商前缀的过程呢？有几种方法。
- en: Using Compass
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Compass
- en: Compass is a framework for Sass that helps us write CSS more efficiently. Compass
    has a massive library of mixins that we can use to leverage dealing with vendor
    prefixes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Compass是一个帮助我们更有效地编写CSS的Sass框架。Compass有一个庞大的mixin库，我们可以使用它来处理供应商前缀。
- en: The installation of Compass is outside the scope of this book, so we're going
    to focus on the basic usage to deal with vendor prefixes and will assume that
    it is already installed on your machines. Refer to the Compass site for detailed
    instructions on how to install it ([http://compass-style.org/](http://compass-style.org/)).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Compass的安装超出了本书的范围，因此我们将专注于处理供应商前缀的基本用法，并假设它已经安装在您的机器上。请参考Compass网站，了解如何安装它的详细说明（[http://compass-style.org/](http://compass-style.org/)）。
- en: Once we have Compass installed, we need to import the specific module that contains
    the mixins we need.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Compass，我们需要导入包含我们需要的mixin的特定模块。
- en: 'Staying with the linear gradient example we used before, let''s import Compass''
    `images` module into our SCSS file. Place this at the top of your main SCSS file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用之前使用的线性渐变示例，让我们将Compass的`images`模块导入到我们的SCSS文件中。将其放在主SCSS文件的顶部：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we can use the corresponding mixin:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用相应的mixin：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will compile to the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译为以下内容：
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There are a few new things here.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新东西。
- en: 'The first declaration uses a base64 embedded SVG file. This is because legacy
    IEs and old versions of Opera have issues rendering gradients so an SVG is their
    fallback. Dealing with these types of issues is completely unnecessary by today''s
    standards:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个声明使用了一个base64嵌入的SVG文件。这是因为旧版IE和旧版Opera存在渲染渐变的问题，因此SVG是它们的备用方案。按照今天的标准，处理这些问题是完全不必要的。
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `background-size: 100%;` parameter is used so that the embedded SVG covers
    the whole container. Again, dealing with something like this is just a waste of
    time. Moreover, our code keeps getting bloated trying to support old technology.
    Consider the next block of code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`background-size: 100%;`参数用于使嵌入的SVG覆盖整个容器。再次处理这样的事情只是浪费时间。此外，我们的代码不断膨胀，试图支持旧技术。考虑下面的代码块：'
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The third declaration is the old CSS linear gradient syntax that was supported
    only by Webkit browsers; more unnecessary code bloating in our file:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个声明是旧的CSS线性渐变语法，只有Webkit浏览器支持；这在我们的文件中会导致不必要的代码膨胀：
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The fourth and fifth declarations are basically for old Firefox, Chrome, and
    Safari versions:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第四和第五个声明基本上是为旧版Firefox、Chrome和Safari版本准备的：
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The last declaration is the proposed syntax without any vendor prefixes:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个声明是没有供应商前缀的建议语法：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As we can see, Compass is a very handy tool and it allows us to customize the
    output. However, this may end up being more work than necessary.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Compass是一个非常方便的工具，它允许我们自定义输出。然而，这可能会变得比必要的工作更多。
- en: 'A few things to consider before concluding whether Compass is the best solution
    for us:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在得出Compass是否是我们的最佳解决方案之前，有一些事情需要考虑：
- en: Compass needs to be installed. This is usually done via the command line.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要安装Compass。这通常是通过命令行完成的。
- en: Once Compass is installed, we don't have to use the command line anymore to
    use its mixins.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦安装了Compass，我们就不必再使用命令行来使用它的mixin。
- en: Compass has a massive library of mixins that can help deal with vendor prefixing
    and many other things.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compass有一个庞大的mixin库，可以帮助处理供应商前缀和许多其他事情。
- en: Each time we need to work with a specific CSS3 property or value, we have to
    import the corresponding module in our main SCSS file with the `@import` directive.
    This means that we have to spend a lot of time finding the modules we need and
    learn to use them.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们需要处理特定的CSS3属性或值时，我们必须在我们的主SCSS文件中使用`@import`指令导入相应的模块。这意味着我们必须花费大量时间找到我们需要的模块并学会使用它们。
- en: The learning curve of using Compass is medium, we need to be a bit knowledgeable
    in other technical aspects to get to use Compass even at its most basic.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Compass的学习曲线是中等的，我们需要在其他技术方面有一定的了解才能使用Compass，即使是最基本的使用也是如此。
- en: Compass has great documentation and is a project in constant development.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compass有很好的文档，并且是一个不断发展的项目。
- en: 'There''s a similar, well-known mixin library called Bourbon: [http://bourbon.io/](http://bourbon.io/).'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个类似的著名的mixin库叫做Bourbon：[http://bourbon.io/](http://bourbon.io/)。
- en: Using -prefix-free
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用“-prefix-free”
- en: '`-prefix-free` is a JavaScript file created by Lea Verou. When the script is
    called by the browser, it detects it and then adds that browser''s specific prefixes
    to the CSS. The `-prefix-free` file is intelligent enough to determine which prefixes
    are needed and only inject those.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: “-prefix-free”是由Lea Verou创建的JavaScript文件。当浏览器调用该脚本时，它会检测到，然后将该浏览器特定的前缀添加到CSS中。
    “-prefix-free”文件足够智能，可以确定需要哪些前缀，并且只注入那些前缀。
- en: Using `-prefix-free` is simple. Just add a call the JavaScript file. As per
    Lea Verou's recommendation, it's best to include this script after the style sheets
    in order to reduce the **Flash of Unstyled Content** (**FOUC**).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“-prefix-free”很简单。只需调用JavaScript文件。根据Lea Verou的建议，最好在样式表之后包含此脚本，以减少**未样式内容的闪烁**（**FOUC**）。
- en: You can visit the `-prefix-free` project at [http://leaverou.github.io/prefixfree/](http://leaverou.github.io/prefixfree/).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问“-prefix-free”项目：[http://leaverou.github.io/prefixfree/](http://leaverou.github.io/prefixfree/)。
- en: 'Since our HTML is so short, we can follow the tip mentioned before:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的HTML代码如此简短，我们可以遵循之前提到的提示：
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It's certainly tempting to use this method since calling a mere JavaScript file
    to deal with automating vendor prefixes sounds like the best idea ever.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法肯定是诱人的，因为调用一个简单的JavaScript文件来处理自动添加供应商前缀听起来就像是最好的主意。
- en: 'Let''s see a short list of things to consider before deciding to use `-prefix-free`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在决定使用“-prefix-free”之前需要考虑的事项的简短列表：
- en: It's incredibly easy to use.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常容易使用。
- en: It's an additional HTTP request. The fewer requests our site/page(s) have the
    faster they are, hence the better UX we provide our users. It's also beneficial
    for SEO.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个额外的HTTP请求。我们的网站/页面的请求越少，它们就越快，因此我们为用户提供的用户体验就越好。这对SEO也是有益的。
- en: It's an extra file to manage. Yes, once we upload the JavaScript file we may
    not need to go back to it—unless we're updating it, which means we need to run
    extensive tests locally so that we don't break anything in production.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个额外的文件要管理。是的，一旦我们上传了JavaScript文件，我们可能不需要再回头看它——除非我们要更新它，这意味着我们需要在本地进行广泛的测试，以免在生产环境中出现任何问题。
- en: It puts a bit more strain on the user's browsers to do the heavy lifting since
    everything happens in the browser.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会给用户的浏览器增加一些负担，因为所有事情都发生在浏览器中。
- en: It doesn't work in files being called using the `@import` directive. This could
    also be seen as a good thing because if we're using `@import` to import files,
    we have a different and even bigger problem in our hands.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在使用`@import`指令调用的文件中不起作用。这也可以被视为一件好事，因为如果我们使用`@import`来导入文件，我们就会面临一个不同甚至更大的问题。
- en: If we're serving style sheets from a different domain than our main site, `-prefix-free`
    won't work on those external CSS files.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们从与我们的主站点不同的域名提供样式表，那么“-prefix-free”将无法在这些外部CSS文件上工作。
- en: Chrome and Opera have issues with allowing `-prefix-free` to work locally. Although
    this is easy to fix, it just adds another layer of complexity to our workflow.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome和Opera在允许“-prefix-free”在本地工作方面存在问题。虽然这很容易解决，但它只是增加了我们工作流程的复杂性。
- en: If there are inline styles, some unprefixed CSS values and properties won't
    work in IE.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有内联样式，一些未添加前缀的CSS值和属性在IE中将无法工作。
- en: With this list, we are now in a better position to make a more informed decision
    that will benefit the project, ourselves and our users.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个列表，我们现在可以更好地做出一个更明智的决定，这将使项目、我们自己和我们的用户受益。
- en: Using Autoprefixer
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Autoprefixer
- en: Autoprefixer is a *CSS postprocessor* that uses the CanIUse.com database to
    append vendor prefixes to an already compiled CSS file.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Autoprefixer是一个*CSS后处理器*，它使用CanIUse.com数据库为已编译的CSS文件添加供应商前缀。
- en: The term *postprocessor* means that it processes the CSS *after* (post) it has
    been created. In other words, if we have an SCSS file called `styles.scss`, this
    file gets compiled into `styles.css` after we save it. At that moment, Autoprefixer
    takes that generated `styles.css` file, opens it, adds all the necessary vendor
    prefixes to each property and value, saves the file, and closes it. In addition,
    you can configure it to create a new separate file as well. Once this is done,
    we can use this file in our website/app.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*后处理器*意味着它在创建CSS之后（后）处理它。换句话说，如果我们有一个名为`styles.scss`的SCSS文件，当我们保存它时，该文件会被编译为`styles.css`。在那一刻，Autoprefixer获取生成的`styles.css`文件，打开它，为每个属性和值添加所有必要的供应商前缀，保存文件，并关闭它。此外，您还可以配置它创建一个新的单独文件。完成后，我们可以在我们的网站/应用程序中使用此文件。
- en: The major advantage that this method has over any other automated vendor prefixing
    method is that it uses the CanIUse.com database; this means that as soon as a
    browser vendor no longer requires its prefix for a CSS property or value, all
    we need to do is run our CSS files through Autoprefixer and it will be up to date
    in seconds.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相对于任何其他自动供应商前缀方法的主要优势是它使用CanIUse.com数据库；这意味着一旦浏览器供应商不再需要其前缀用于CSS属性或值，我们只需通过Autoprefixer运行我们的CSS文件，它将在几秒钟内更新。
- en: 'The major disadvantage of Autoprefixer is that it has so many ways to use it
    that it could be a bit overwhelming for some. To name a few, we can use it via
    the command line but we''d need to have `Node.js` installed first:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Autoprefixer的主要缺点是它有太多的使用方式，对一些人来说可能有点压倒性。举几个例子，我们可以通过命令行使用它，但首先需要安装`Node.js`：
- en: '[PRE59]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can also use Autoprefixer with Compass, but we need to have Ruby installed
    first:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在Compass中使用Autoprefixer，但首先需要安装Ruby：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can use it with CodeKit on Mac and with Prepros or Koala App on Windows/Mac/Linux.
    We can also install plugins for Sublime Text, Brackets, or Atom Editor. There
    are Grunt and Gulp plugins as well.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Mac上使用CodeKit，在Windows/Mac/Linux上使用Prepros或Koala App。我们还可以为Sublime Text、Brackets或Atom
    Editor安装插件。还有Grunt和Gulp插件。
- en: 'Let''s see a short list of things to consider before deciding to use Autoprefixer:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用Autoprefixer之前，让我们看一下需要考虑的事项的简要清单：
- en: The fact that it uses the CanIUse.com database is by far the best feature and
    advantage over any other automated vendor prefixing application, because we can
    always be sure that our CSS files have the latest prefixes, or none if the browser
    vendor has dropped any of them.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用CanIUse.com数据库的事实是远远超过任何其他自动供应商前缀应用程序的最佳功能和优势，因为我们始终可以确保我们的CSS文件具有最新的前缀，或者如果浏览器供应商删除了其中任何一个。
- en: It can be integrated into many applications.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以集成到许多应用程序中。
- en: It can be a bit daunting to install for new web designers or developers.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新的网页设计师或开发人员来说，安装可能有点令人生畏。
- en: Autoprefixer comes preinstalled in other applications, so all we need to do
    is run those applications and we're automatically using Autoprefixer without having
    to set anything up.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autoprefixer已经预装在其他应用程序中，所以我们只需要运行这些应用程序，就可以自动使用Autoprefixer，而无需进行任何设置。
- en: Autoprefixer can be downloaded from [https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Autoprefixer可以从[https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)下载。
- en: Using Pleeease
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Pleeease
- en: Yes, it's *Pleeease* with three *e*. Pleeease is also a CSS postprocessor like
    Autoprefixer and it also depends on having `Node.js` installed. It only runs via
    the command line, but it's actually quite simple. Pleeease uses Autoprefixer,
    which means that it uses the CanIUse.com database as well to define which CSS
    properties and/or values need prefixing.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它是三个*e*的*Pleeease*。Pleeease也是一个类似Autoprefixer的CSS后处理器，它也依赖于已安装的`Node.js`。它只能通过命令行运行，但实际上非常简单。Pleeease使用Autoprefixer，这意味着它也使用CanIUse.com数据库来定义哪些CSS属性和/或值需要前缀。
- en: 'Once Pleeease is installed, we need to create a configuration file (a JSON
    file) in which the most important thing we need to define is the source CSS file
    and the destination CSS file:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Pleeease后，我们需要创建一个配置文件（JSON文件），其中我们需要定义的最重要的事情是源CSS文件和目标CSS文件：
- en: '[PRE61]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once we have that configuration file set, we run this in the command line:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了配置文件，我们在命令行中运行这个命令：
- en: '[PRE62]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Pleeease takes the `style.css` file, adds all necessary vendor prefixes, and
    creates `styles.fixed.css`, which is the file we use in production.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Pleeease获取`style.css`文件，添加所有必要的供应商前缀，并创建`styles.fixed.css`，这是我们在生产中使用的文件。
- en: 'There are other important things that Pleeease does at this point:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Pleeease还有其他重要的事情：
- en: Compiles the same media queries into one `@media` block
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相同的媒体查询编译为一个`@media`块
- en: Inlines `@import` style sheets (this is great because we end up with one single
    CSS file for production)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`@import`样式表内联（这很棒，因为我们最终只会得到一个单一的CSS文件用于生产）
- en: Minifies/compresses the final file
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终文件进行了最小化/压缩
- en: If you're comfortable using the command line and JSON files, Pleeease can be
    a very useful part of your arsenal. If you prefer to stay away from the command
    line, that's fine too; there are other friendlier ways to automate vendor prefixing.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯使用命令行和JSON文件，Pleeease可以成为您工具库中非常有用的一部分。如果您更喜欢远离命令行，也没关系；还有其他更友好的方法来自动添加供应商前缀。
- en: 'Here are a few things to consider before deciding if Pleeease is the way to
    go to automate vendor prefixing:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否使用Pleeease自动添加供应商前缀之前，有一些需要考虑的事项：
- en: It requires the use of the command line to install and use, but the commands
    are quite simple.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用命令行进行安装和使用，但命令非常简单。
- en: It uses a JSON file to configure its settings.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用JSON文件来配置其设置。
- en: It uses Autoprefixer, which means it uses the CanIUse.com database as well.
    This makes it incredibly powerful when it comes to knowing which properties and/or
    values need or don't need to be prefixed.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用Autoprefixer，这意味着它也使用CanIUse.com数据库。这使得它在知道哪些属性和/或值需要或不需要前缀时非常强大。
- en: It makes several other improvements to the final CSS file, such as packing the
    same media queries in a single `@media` rule, minifying the result, and so on.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对最终的CSS文件进行了几项其他改进，比如将相同的媒体查询打包在一个`@media`规则中，最小化结果等等。
- en: It can be integrated with the Grunt, Gulp, Brunch, and Node.js workflows.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以与Grunt、Gulp、Brunch和Node.js工作流集成。
- en: You can download Pleeease from [http://pleeease.io/](http://pleeease.io/).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://pleeease.io/](http://pleeease.io/)下载Pleeease。
- en: Using Emmet
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Emmet
- en: Emmet allows us to write CSS and HTML faster. It's a plugin for text editors
    such as Sublime Text, Coda, TextMate, and even Dreamweaver.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Emmet使我们能够更快地编写CSS和HTML。它是文本编辑器的插件，如Sublime Text、Coda、TextMate，甚至Dreamweaver。
- en: Emmet also helps us with vendor prefixing our CSS3 properties and values, which
    is what we're going to focus on in the following examples.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Emmet还帮助我们为CSS3属性和值添加供应商前缀，这是我们接下来要重点关注的。
- en: Tip
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Emmet used to be called *Zen Coding*.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Emmet以前被称为*Zen Coding*。
- en: 'Once the Emmet plugin is installed in our favorite text editor, we type this
    in our SCSS file:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Emmet插件安装在我们喜爱的文本编辑器中，我们在SCSS文件中输入以下内容：
- en: '[PRE63]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Tip
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`-trf` is the abbreviation of the CSS3 property *transform*.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`-trf`是CSS3属性*transform*的缩写。'
- en: 'Then we press *Tab* on our keyboard and the code automatically gets changed
    to this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在键盘上按下*Tab*，代码会自动更改为这样：
- en: '[PRE64]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: All we need to do to add vendor prefixes is start our abbreviation with a dash
    (`-`). This tells Emmet that it needs to add the necessary vendor prefixes when
    hitting the key *Tab*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在缩写的开头加一个破折号(`-`)来添加供应商前缀。这告诉Emmet在按下*Tab*键时需要添加必要的供应商前缀。
- en: Tip
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The transform values were not defined in the previous example because we want
    to show the result from using Emmet. Obviously, we'd have to add those values
    in the end.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中未定义变换值，因为我们想展示使用Emmet的结果。显然，我们最终需要添加这些值。
- en: 'Here are a few things to consider before deciding to use Emmet to automate
    vendor prefixing:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否使用Emmet自动添加供应商前缀之前，有一些事情需要考虑：
- en: It's up to us to define what gets prefixed and what doesn't, so we may end up
    prefixing properties and values that no longer need to be prefixed. Thus, we end
    up bloating our CSS files.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由我们来定义什么需要加前缀，什么不需要，所以我们可能最终会给不再需要前缀的属性和值加上前缀。因此，我们最终会使我们的CSS文件变得臃肿。
- en: If we forget to add a dash at the beginning of a property/value, it won't be
    prefixed and maybe that property/value does need prefixed. Thus, we'll spend more
    time troubleshooting.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们忘记在属性/值的开头添加破折号，它就不会被加前缀，也许这个属性/值确实需要前缀。因此，我们会花更多时间进行故障排除。
- en: Emmet works with the most popular text editors out there, so chances are we'll
    be able to use it.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emmet与最流行的文本编辑器兼容，所以我们很可能能够使用它。
- en: The learning curve to use Emmet is incredibly low.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Emmet的学习曲线非常低。
- en: Emmet does not depend on the use of the command line.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emmet不依赖于使用命令行。
- en: Emmet has great documentation and it's in constant development.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emmet有很好的文档，并且在不断发展。
- en: You can download Emmet from [http://emmet.io/](http://emmet.io/).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://emmet.io/](http://emmet.io/)下载Emmet。
- en: Using a third-party application
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用第三方应用程序
- en: As we have seen, the previous methods for automating vendor prefixing are all
    over the place, from methods that are used via the command line and methods that
    make you find a specific module to import before being able to use to JavaScript
    solutions.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，以前用于自动添加供应商前缀的方法是各种各样的，从通过命令行使用的方法到让您在使用JavaScript解决方案之前找到特定模块导入的方法。
- en: The most important of all the features mentioned is that Autoprefixer uses the
    CanIUse.com database. This is pretty much what we want to use, since all we need
    to do is write the CSS3 properties and values and forget about vendor prefixing
    altogether, leaving it to Autoprefixer and CanIUse.com to add them for us.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的所有功能中最重要的是Autoprefixer使用CanIUse.com数据库。这基本上是我们想要使用的，因为我们只需要编写CSS3属性和值，然后完全忘记供应商前缀，让Autoprefixer和CanIUse.com为我们添加它们。
- en: Fortunately, there are third-party applications out there that already come
    with Autoprefixer installed. This means we don't have to set anything via the
    command line, or install a plugin, or anything like that. Just install the app,
    activate the Autoprefixer checkbox, and off we go!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，已经有第三方应用程序安装了Autoprefixer。这意味着我们不需要通过命令行设置任何东西，也不需要安装插件，或者类似的东西。只需安装应用程序，激活Autoprefixer复选框，然后开始使用！
- en: 'We mentioned several applications before: CodeKit, Prepros, and the Koala app.
    They all do basically the same things, but they excel in two things:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到了几个应用程序：CodeKit、Prepros和Koala应用。它们基本上都做同样的事情，但它们在两个方面表现出色：
- en: They can *watch* our SCSS files and compile them for us.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以*监视*我们的SCSS文件并为我们编译它们。
- en: They can automatically add vendor prefixes via Autoprefixer.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以通过Autoprefixer自动添加供应商前缀。
- en: These two features have a huge impact on our workflow, allowing us to focus
    our energies on the important stuff, such as RWD and a better user experience.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个功能对我们的工作流程有很大影响，使我们能够将精力集中在重要的事情上，比如RWD和更好的用户体验。
- en: 'However, there are a few things to consider before deciding if a third-party
    application is the best solution for vendor prefixing:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用第三方应用程序是否是添加供应商前缀的最佳解决方案之前，有一些事情需要考虑：
- en: Prepros and CodeKit are paid apps. Koala is free but supporting the author with
    a small donation shows appreciation for his work. However, they are not expensive
    by any means; the benefits are worth tens of times over when we compile a file
    for the first time.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prepros和CodeKit是付费应用程序。Koala是免费的，但通过小额捐赠支持作者对他的工作表示感激。然而，它们绝对不贵；当我们第一次编译文件时，收益是十倍的价值。
- en: They are extremely easy to set up.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常容易设置。
- en: They have great documentation, communities and are in constant development by
    the authors.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有很好的文档、社区，并且由作者不断开发。
- en: For many non-frontend developers who work with CSS and HTML, these applications
    allow them to focus on other important things such as user experience, design,
    usability, and SEO—without worrying about JSON files, command line, plugins, and
    so on.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于许多与CSS和HTML一起工作的非前端开发人员来说，这些应用程序使他们能够专注于其他重要事项，如用户体验、设计、可用性和SEO，而不必担心JSON文件、命令行、插件等等。
- en: The recommended vendor prefixing method
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 推荐的供应商前缀方法
- en: This book recommends that you use CodeKit, Prepros, or Koala apps to deal with
    vendor prefixes. These applications not only compile the SCSS files, but also
    automatically run them through Autoprefixer when saving those SCSS files.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本书建议您使用CodeKit、Prepros或Koala应用程序来处理供应商前缀。这些应用程序不仅可以编译SCSS文件，还可以在保存这些SCSS文件时自动通过Autoprefixer运行它们。
- en: So let's take a look at Prepros, which can run on the most popular operating
    systems such as Windows, Linux, and Mac.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来看看Prepros，它可以在Windows、Linux和Mac等最流行的操作系统上运行。
- en: Using a third-party program to compile
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用第三方程序进行编译
- en: 'Using the command line to compile our SCSS files is really not that difficult:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行编译我们的SCSS文件真的并不那么困难：
- en: '[PRE65]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That's all we need to do in the command line to have Sass watch over the SCSS
    files in the `/scss` folder and compile them into the `/css` folder. It really
    is that simple.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在命令行中需要做的一切，以便Sass监视`/scss`文件夹中的SCSS文件，并将它们编译到`/css`文件夹中。真的就是这么简单。
- en: The problem with the previous situation is that we need to run this command
    every single time we have to work on a different project. Although we can automate
    this in many different ways, some find the use of the command line either daunting
    or just unnecessary.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的情况是，每次我们需要在不同的项目上工作时，都需要运行这个命令。虽然我们可以用许多不同的方式来自动化这个过程，但有些人觉得使用命令行要么令人生畏，要么只是不必要的。
- en: The Prepros app
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Prepros应用程序
- en: 'Prepros is a tool for web designers and developers that deals with many parts
    of a regular workflow: compiling, CSS prefixing, live refresh, JavaScript concatenation,
    file minification, optimizing images, browser testing synchronization, source
    maps creation for compiled files, built-in server, FTP, and so on.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Prepros是一个面向网页设计师和开发人员的工具，涉及到常规工作流程的许多部分：编译、CSS前缀、实时刷新、JavaScript合并、文件最小化、图像优化、浏览器测试同步、为编译文件创建源映射、内置服务器、FTP等等。
- en: For the scope of this book, we're going to focus on how it can help us compile
    our SCSS files while adding vendor prefixes automatically.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的范围内，我们将重点介绍它如何帮助我们在自动添加供应商前缀的同时编译我们的SCSS文件。
- en: You can download it from [https://prepros.io/](https://prepros.io/). Prepros
    is a paid application. However, spending $29 is not going to break the bank. I
    assure you that right after the first compilation, this app will have paid itself.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://prepros.io/](https://prepros.io/)下载它。Prepros是一个付费应用程序。不过，花29美元并不会让你破产。我向你保证，第一次编译之后，这个应用程序就会为自己赚回成本。
- en: There is also a way to use Prepros for free and enjoy all the features of the
    app. However, this comes at the expense of having to keep closing the *buy the
    app* pop-up window about every 5 minutes.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以免费使用Prepros并享受应用程序的所有功能。不过，这是以不得不每5分钟左右关闭*购买应用程序*弹出窗口为代价的。
- en: 'This is the current welcome screen of Prepros (it may have changed by now):'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Prepros的当前欢迎界面（可能已经改变）：
- en: '![The Prepros app](img/B02102_01_10.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![Prepros应用程序](img/B02102_01_10.jpg)'
- en: 'Remember the steps in the installation of Sass where we created a `/Demo` folder
    and created two subfolders, `/scss` and `/css`, within it? We are going to drag
    and drop the `/Demo` folder onto the Prepros interface:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得安装Sass时的步骤吗？我们创建了一个`/Demo`文件夹，并在其中创建了两个子文件夹`/scss`和`/css`？我们将把`/Demo`文件夹拖放到Prepros界面上：
- en: '![The Prepros app](img/B02102_01_11.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![Prepros应用程序](img/B02102_01_11.jpg)'
- en: 'A sad face appears, letting us know that the project is empty. This is true
    since we haven''t added any files to the `/scss` folder:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一个悲伤的表情出现了，让我们知道项目是空的。这是真的，因为我们还没有向`/scss`文件夹中添加任何文件：
- en: '![The Prepros app](img/B02102_01_12.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![Prepros应用程序](img/B02102_01_12.jpg)'
- en: 'So, let''s create a .`scss` file in the `/scss` folder:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们在`/scss`文件夹中创建一个`.scss`文件：
- en: '![The Prepros app](img/B02102_01_13.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![Prepros应用程序](img/B02102_01_13.jpg)'
- en: Prepros will automatically detect the new `styles.scss` file and compile it
    to create the `styles.css` file, which is saved in the `/css` folder.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Prepros将自动检测新的`styles.scss`文件并将其编译为`styles.css`文件，保存在`/css`文件夹中。
- en: '![The Prepros app](img/B02102_01_14.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![Prepros应用程序](img/B02102_01_14.jpg)'
- en: 'Clicking on the `styles.scss` file will bring out the file''s default settings:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 单击`styles.scss`文件将显示文件的默认设置：
- en: '![The Prepros app](img/B02102_01_15.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![Prepros应用程序](img/B02102_01_15.jpg)'
- en: 'Let''s modify some of these settings so Prepros can automatically perform the
    following operations:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改一些设置，以便Prepros可以自动执行以下操作：
- en: Add vendor prefixes.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加供应商前缀。
- en: Create source maps.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建源映射。
- en: Not compress our compiled CSS (at least yet).
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不压缩我们编译的CSS（至少暂时不压缩）。
- en: Tip
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `source map` is a file with the `.map` extension that gets generated together
    with our CSS file. This map file contains the necessary information that links
    each line of our CSS file to their corresponding line in our SCSS files and partials.
    This is crucial when we need to inspect the styles of an element via the DevTools
    of any modern web browser.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`source map`是一个带有`.map`扩展名的文件，它与我们的CSS文件一起生成。这个映射文件包含了将我们的CSS文件的每一行链接到我们的SCSS文件和局部文件中相应行的必要信息。当我们需要通过任何现代网页浏览器的DevTools检查元素的样式时，这一点至关重要。'
- en: In the **OUTPUT STYLE** section, we're going to leave the setting as **Expanded**.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在**输出样式**部分，我们将把设置保留为**Expanded**。
- en: '![The Prepros app](img/B02102_01_16.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![Prepros应用程序](img/B02102_01_16.jpg)'
- en: 'The differences between the four styles of output are simple:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 四种输出样式之间的区别很简单：
- en: Expanded output
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展输出
- en: 'This is the traditional CSS styling where each selector, property, and value
    is in a separate line:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传统的CSS样式，其中每个选择器、属性和值都在单独的一行上：
- en: '[PRE66]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Nested output
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套输出
- en: 'You can see that the second rule is indented, which means it belongs to the
    `header` selector:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到第二个规则是缩进的，这意味着它属于`header`选择器：
- en: '[PRE67]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Compact output
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 紧凑输出
- en: 'All rules reside in a single line, as shown here:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 所有规则都在一行中，如下所示：
- en: '[PRE68]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Compressed output
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 压缩输出
- en: 'This is the minified version, which is the version we should use in production:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这是被压缩的版本，这是我们在生产中应该使用的版本：
- en: '[PRE69]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That's it. We now leave Prepros running. It will add all vendor prefixes and
    compile the SCSS files every time we save it. Let's see this in action.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们现在让Prepros运行。它将添加所有供应商前缀，并在我们保存时编译SCSS文件。让我们看看它的运行情况。
- en: Add some CSS and let the Prepros app do the rest!
  id: totrans-448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一些CSS，让Prepros应用程序完成剩下的工作！
- en: Every time we hit **Save**, Prepros will show either one of the following dialog
    boxes at the bottom-right corner of our screen.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们点击**保存**，Prepros都会在屏幕右下角显示以下对话框中的一个。
- en: '**Success** will give us the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**成功**将给我们以下输出：'
- en: '![Add some CSS and let the Prepros app do the rest!](img/B02102_01_17.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![添加一些CSS，让Prepros应用程序完成剩下的工作！](img/B02102_01_17.jpg)'
- en: '**Error** will give us the following output:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误**将给我们以下输出：'
- en: '![Add some CSS and let the Prepros app do the rest!](img/B02102_01_18.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![添加一些CSS，让Prepros应用程序完成剩下的工作！](img/B02102_01_18.jpg)'
- en: Let's take our `styles.scss` file and let's add a simple CSS rule that requires
    some vendor prefixing.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿出我们的`styles.scss`文件，然后添加一个需要一些供应商前缀的简单CSS规则。
- en: '![Add some CSS and let the Prepros app do the rest!](img/B02102_01_19.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![添加一些CSS，让Prepros应用程序完成剩下的工作！](img/B02102_01_19.jpg)'
- en: When we save the `styles.scss` file, Prepros shows the green/success dialog
    box and compiles our SCSS file to `styles.css`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存`styles.scss`文件时，Prepros会显示绿色/成功的对话框，并将我们的SCSS文件编译成`styles.css`。
- en: 'This is what the compiled file looks like with all the prefixes added automatically:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译后的文件，自动添加了所有前缀：
- en: '![Add some CSS and let the Prepros app do the rest!](img/B02102_01_20.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![添加一些CSS，让Prepros应用程序完成剩下的工作！](img/B02102_01_20.jpg)'
- en: Defining how many legacy browser versions to support for prefixing
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义要为前缀添加支持的旧版浏览器版本数量
- en: As browsers evolve, CSS3 properties and values are standardized and less of
    them require vendor prefixing. Our CSS files should reflect that so we don't fill
    our style sheets with unnecessary prefixes.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 随着浏览器的发展，CSS3属性和值被标准化，越来越少的属性需要供应商前缀。我们的CSS文件应该反映这一点，这样我们就不会在样式表中填充不必要的前缀。
- en: 'Prepros allows us to define how many legacy browser versions we want to support
    when applying prefixes. The steps are as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Prepros允许我们定义在应用前缀时要支持多少个旧版浏览器版本。步骤如下：
- en: Click on the **MORE OPTIONS** menu at the top:![Defining how many legacy browser
    versions to support for prefixing](img/B02102_01_21.jpg)
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部点击**更多选项**菜单：![定义要为前缀添加支持的旧版浏览器版本数量](img/B02102_01_21.jpg)
- en: Click on **Project Options** from the drop-down menu:![Defining how many legacy
    browser versions to support for prefixing](img/B02102_01_22.jpg)
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中点击**项目选项**：![定义要为前缀添加支持的旧版浏览器版本数量](img/B02102_01_22.jpg)
- en: Click on the **CSS** menu option:![Defining how many legacy browser versions
    to support for prefixing](img/B02102_01_23.jpg)
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**CSS**菜单选项：![定义要为前缀添加支持的旧版浏览器版本数量](img/B02102_01_23.jpg)
- en: Scroll all the way to the bottom and type the number `2` in the **AutoPrefixer**
    field:![Defining how many legacy browser versions to support for prefixing](img/B02102_01_24.jpg)
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到底部，在**AutoPrefixer**字段中输入数字`2`：![定义要为前缀添加支持的旧版浏览器版本数量](img/B02102_01_24.jpg)
- en: Once this is done, save the `styles.scss` file. We'll see that the CSS3 linear
    gradient property doesn't really need to be prefixed after Prepros compiles the
    CSS file:![Defining how many legacy browser versions to support for prefixing](img/B02102_01_25.jpg)
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些操作后，保存`styles.scss`文件。我们会发现，CSS3线性渐变属性在Prepros编译CSS文件后实际上不需要添加前缀：![定义要为前缀添加支持的旧版浏览器版本数量](img/B02102_01_25.jpg)
- en: Tip
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are not able to see the linear gradient property prefixed in the beginning,
    try changing the value to something very high, such as `40` so that it reads *last
    40 versions*. Save your SCSS document and check your CSS file again.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到线性渐变属性在开头被加上前缀，尝试将值更改为非常高的值，比如`40`，这样它就会显示*最后40个版本*。保存你的SCSS文档，然后再次检查你的CSS文件。
- en: That's all there is to it.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: One compiler only
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只有一个编译器
- en: One very important note before we continue. So far, we've talked about using
    the command line via the `--watch` flag and using Prepros to compile our SCSS
    files. Note that *only one compiler* needs to run at any given time. Having both
    the CMD and Prepros compiling the same SCSS file is not necessary.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一点非常重要的说明。到目前为止，我们已经讨论了通过`--watch`标志使用命令行以及使用Prepros来编译我们的SCSS文件。请注意，*只需要运行一个编译器*。同时运行CMD和Prepros编译相同的SCSS文件是不必要的。
- en: Sass mixins to house our media queries
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sass mixins来存放我们的媒体查询
- en: 'There are many ways to create a Sass mixin to house media queries: mixins with
    variables only, mixins with the *No Queries* fallback for older browsers that
    don''t support media queries, and plugins (for Compass) such as Breakpoint. There
    are other techniques too, such as Named Media Queries. Another technique is a
    simple three-line mixin that will work for anything we want.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以创建一个Sass mixin来存放媒体查询：只有变量的mixin，为不支持媒体查询的旧版浏览器提供*No Queries*回退的mixin，以及（对于Compass）插件，比如Breakpoint。还有其他技术，比如命名媒体查询。另一种技术是一个简单的三行mixin，可以用于我们想要的任何东西。
- en: They're all fine and very powerful. However, for the scope of this book, we're
    going to focus on two simple methods that will allow us to be efficient, keep
    things simple, and harness the power of mixins.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都很好，而且非常强大。然而，在本书的范围内，我们将专注于两种简单的方法，这将使我们能够高效，保持简单，并利用mixin的功能。
- en: All that you have learned about Sass so far, especially the part about mixins,
    culminates in the creation of a partial file that will house our media queries
    for RWD.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你学到的关于Sass的一切，特别是关于mixin的部分，都体现在创建一个用于存放RWD媒体查询的部分文件中。
- en: Remember that partial files are SCSS files we create to house SCSS snippets.
    Their file name starts with an underscore symbol and ends with the `.scss` extension.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，部分文件是我们创建的用于存放SCSS片段的SCSS文件。它们的文件名以下划线符号开头，以`.scss`扩展名结尾。
- en: Media queries mixin methods
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体查询mixin方法
- en: There are as many methods to name media queries and breakpoints as there are
    web designers and frontend developers. Everyone has their own way and style.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 命名媒体查询和断点的方法和网页设计师和前端开发人员一样多。每个人都有自己的方式和风格。
- en: Regardless of the method you use, the important thing is to start using a Sass
    mixin to automate this process. As we build sites or apps and become better web
    designers / frontend developers, we'll find that other solutions may work better.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种方法，重要的是开始使用Sass mixin来自动化这个过程。随着我们构建站点或应用程序并成为更好的网页设计师/前端开发人员，我们会发现其他解决方案可能效果更好。
- en: 'There are several ways to name your media queries mixins:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以命名您的媒体查询mixin：
- en: Let the content define the breakpoints. In other words, when you resize your
    browser window during testing and you see that the content breaks or doesn't display
    in an ideal, legible way—bam! create a breakpoint (this is the recommended method).
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让内容定义断点。换句话说，当您在测试期间调整浏览器窗口大小，并且看到内容中断或无法以理想的、可读的方式显示时——创建一个断点（这是推荐的方法）。
- en: Name media queries using abstract names such as `small`, `medium`, and `large`,
    or `s`, `m`, and `l`.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象名称命名媒体查询，如`small`、`medium`和`large`，或`s`、`m`和`l`。
- en: Use device-specific names (I do not recommend this method).
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定设备名称（我不建议使用此方法）。
- en: In this book we're going to focus only on the first and second methods mentioned
    in preceding list.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将只关注前面列表中提到的第一种和第二种方法。
- en: Let the content define the breakpoints
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让内容定义断点
- en: Since we don't know where our content is going to break and we need an initial
    mixin that we can add values to as we build our responsive site/app, we're going
    to start with a few known, width-specific values. Understand that these values
    may very well change and many other values will be added to this mixin.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道我们的内容会在哪里中断，我们需要一个初始mixin，我们可以在构建响应式站点/应用程序时添加值，我们将从一些已知的、特定宽度的值开始。请理解这些值很可能会改变，并且会向这个mixin添加许多其他值。
- en: 'We''re going to name this file `_mediaqueries.scss`. The media queries mixin
    looks like this:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个文件命名为`_mediaqueries.scss`。媒体查询mixin看起来像这样：
- en: '[PRE70]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is how we use the mixin in our main SCSS file:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在主SCSS文件中使用mixin的方法：
- en: '[PRE71]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is what the mixin compiles to:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这是mixin编译的结果：
- en: '[PRE72]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the media queries examples of this book, we're going to declare the width
    values in `em` units rather than pixels. This is because using `em` helps scale
    all values better, independent of the screen densities. Let's see what's happening
    here.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的媒体查询示例中，我们将使用`em`单位而不是像素来声明宽度值。这是因为使用`em`有助于更好地缩放所有值，独立于屏幕密度。让我们看看这里发生了什么。
- en: Mixin
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Mixin
- en: 'First, we see the Sass-style comment describing that this mixin is for a mobile-first
    approach:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到Sass风格的注释，描述这个mixin是为移动优先方法而设计的：
- en: '[PRE73]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Then, we have the opening `@mixin` directive. This directive contains the name
    of the mixin, `minw`, which is the abbreviation of *minimum-width*. We're going
    to keep this name simple because we're going to type it a lot, so it's faster
    to type `minw` than *minimum-width* while still maintaining a meaningful term.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有开放的`@mixin`指令。这个指令包含mixin的名称`minw`，它是*minimum-width*的缩写。我们将保持这个名称简单，因为我们将经常输入它，所以输入`minw`比输入*minimum-width*更快，同时仍然保持有意义的术语。
- en: 'In parenthesis, we have the `($point)` argument that will store the value we
    specify when defining which breakpoint we''re going to be using:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中，我们有`($point)`参数，它将存储我们在定义要使用的断点时指定的值：
- en: '[PRE74]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Then, we have an opening `@if` statement. Remember we said that Sass was a programming/scripting
    language? What best represents a programming language than `if-else` statements?
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个开放的`@if`语句。记住我们说过Sass是一种编程/脚本语言吗？有什么比`if-else`语句更能代表编程语言呢？
- en: 'The `@if` statement is followed by the `$point` variable that equals (`==`)
    320 pixels width. The two equals signs (`==`) mean that it is absolutely equal
    to the value, that is, `320`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`@if`语句后面是等于(`==`) 320像素宽度的`$point`变量。两个等号(`==`)表示它绝对等于值，即`320`：'
- en: '[PRE75]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: After that, we have the CSS `@media` directive that we've seen many times before.
    Within this directive, we specify the width in `em`, in this first case, `20em`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有CSS `@media` 指令，我们以前见过很多次。在这个指令中，我们以`em`为单位指定宽度，在这个例子中是`20em`。
- en: '[PRE76]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, we have the `@content` directive that allows us to put any content in
    between the brackets:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`@content`指令，允许我们在括号之间放任何内容：
- en: '[PRE77]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is followed by the `@else` statement with the `$point` variable, the two
    equals (`==`) signs, and the value of `640`. If the defined value is `640` instead
    of `320`, then the mixin can go ahead and use this specific media query for 640
    pixels width.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是带有`@else`语句的`$point`变量，两个等号(`==`)和值`640`。如果定义的值是`640`而不是`320`，那么mixin可以继续使用这个特定的媒体查询，适用于640像素宽度。
- en: '[PRE78]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This means that 640 pixels is `40em`:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着640像素是`40em`：
- en: '[PRE79]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Finally, we have the same media query structure for 768 pixels width. 768 pixels
    is the same as `47.5em`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有相同的媒体查询结构，适用于768像素宽度。768像素等于`47.5em`。
- en: 'Consider the following points before choosing the method of letting content
    define the breakpoints:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择让内容定义断点的方法之前，请考虑以下几点：
- en: The great thing about using specific width values (remember, these values are
    content-based) as media queries names (320, 640, or 768) is that when we use the
    mixin, we truly know what specific width we're targeting.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定宽度值（记住，这些值是基于内容的）作为媒体查询名称（320、640或768）的好处是，当我们使用mixin时，我们真正知道我们要定位的具体宽度是什么。
- en: This means that no matter how many breakpoints we have, we will always know
    which width we're targeting.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着无论我们有多少个断点，我们都将始终知道我们要定位的宽度。
- en: We can have as many breakpoints as we need, and we'll never have to go back
    to the mixin to remind us which name belongs to which width.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以有尽可能多的断点，而且我们永远不必回到mixin去提醒我们哪个名称对应哪个宽度。
- en: Named media queries
  id: totrans-516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命名媒体查询
- en: This is the favorite of many frontend developers. This mixin is almost the same
    as the one we just saw; the difference is that instead of using specific widths
    and knowing that those widths will change and others will be added, this mixin
    uses abstract names for device-specific widths and usually there's an already
    defined list of breakpoints.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这是许多前端开发人员喜爰的。这个mixin几乎与我们刚刚看到的那个相同；不同之处在于，它不是使用特定的宽度并知道这些宽度将改变并添加其他宽度，而是使用设备特定宽度的抽象名称，通常已经定义了断点列表。
- en: 'Here''s what this mixin looks like:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个mixin的样子：
- en: '[PRE80]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This is how we use it:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用它的方式：
- en: '[PRE81]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And this is how it looks compiled:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译后的样子：
- en: '[PRE82]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Consider the following points before choosing the Named Media Queries method:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择命名媒体查询方法之前，请考虑以下几点：
- en: The use of abstract names can be confusing if you have many breakpoints.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有很多断点，使用抽象名称可能会令人困惑。
- en: At some point, you're either going to run out of abstract names, or have so
    many of them that you can't really remember which name belongs to which width.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个时候，你要么会用尽抽象名称，要么会有太多抽象名称，以至于你真的记不住哪个名称对应哪个宽度。
- en: The basic mixin
  id: totrans-527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本mixin
- en: 'This is the recommended mixin to use when working with media queries, and it
    has the following advantages:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在处理媒体查询时推荐使用的mixin，它具有以下优点：
- en: It allows us to keep thinking in pixels when defining our widths, but the output
    is in relative units (`em`).
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们在定义宽度时继续以像素为单位思考，但输出是以相对单位（`em`）为单位。
- en: It's quite simple to understand and to scale.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这很容易理解和扩展。
- en: If we're using the desktop-first approach, all we need to do is change the mixin
    name from `mobileFirst` to `desktopFirst`, and change the `min-width` keyword
    to `max-width`.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用桌面优先的方法，我们只需要将mixin名称从`mobileFirst`更改为`desktopFirst`，并将`min-width`关键字更改为`max-width`。
- en: 'If we want to use pixel-based width, we just need to remove `16` from the division:
    `/16+em`.'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想使用基于像素的宽度，我们只需要从除法中去掉`16`：`/16+em`。
- en: Since it doesn't use named variables to represent different widths, there is
    no need to remember which named variable corresponds to which width.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它不使用命名变量来表示不同的宽度，所以不需要记住哪个命名变量对应哪个宽度。
- en: We'll never run out of named variables since it doesn't use them.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们永远不会用尽命名变量，因为它不使用它们。
- en: 'Now, considering that our recommendation is to let the content define the breakpoints,
    here''s the mixin:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到我们的建议是让内容定义断点，这里是mixin：
- en: '[PRE83]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'That''s it—a mere three-line mixin. This is how we use it:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——一个仅有三行的mixin。这是我们如何使用它的方式：
- en: '[PRE84]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This is what it compiles to:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它编译成的样子：
- en: '[PRE85]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, you might be asking yourselves, "where did the `em` values come from?"
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问自己，“`em`值是从哪里来的？”
- en: It's simple. We divide the desired width by 16\. The reason we're dividing by
    16 is because `16px` is the default font size of all browsers. By doing this,
    we get our values in `em` units.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们将期望的宽度除以16。我们除以16的原因是因为`16px`是所有浏览器的默认字体大小。通过这样做，我们得到了以`em`单位为单位的值。
- en: 'Consider the following examples if you want to use `16px` as your default font
    size:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用`16px`作为默认字体大小，请考虑以下示例：
- en: '*320px/16px = 20em*'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*320px/16px = 20em*'
- en: '*640px/16px = 40em*'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*640px/16px = 40em*'
- en: '*768px/16px = 47.5em*'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*768px/16px = 47.5em*'
- en: 'If you decide that your default font size is not going to be `16px` but rather
    `18px`, then the same process applies. Divide the desired width by `18px`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定你的默认字体大小不是`16px`而是`18px`，那么同样的过程适用。将期望的宽度除以`18px`：
- en: '*320px/18px = 17.77em*'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*320px/18px = 17.77em*'
- en: '*640px/18px = 35.55em*'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*640px/18px = 35.55em*'
- en: '*768px/18px = 42.66em*'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*768px/18px = 42.66em*'
- en: The choice is yours.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 选择权在你手中。
- en: Tip
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All our examples are going to be based on a `16px` default font size.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的示例都将基于`16px`的默认字体大小。
- en: Summary
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We covered a lot in this chapter, but the best is yet to come. We learned how
    to install Sass and how to make it *watch* our SCSS files. We also learned that
    there are two different syntaxes: Sass and SCSS. We now know that any CSS file
    is a valid SCSS file, and if we know how to write CSS now, we also know how to
    write SCSS. We talked about different basic concepts of Sass like variables, mixins,
    arguments, nesting, partial files, the `@import` directive, source maps, and Sass
    comments.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，但最好的还在后面。我们学会了如何安装Sass以及如何让它*监视*我们的SCSS文件。我们还了解到有两种不同的语法：Sass和SCSS。我们现在知道任何CSS文件都是有效的SCSS文件，如果我们现在知道如何编写CSS，我们也知道如何编写SCSS。我们讨论了Sass的不同基本概念，如变量、mixin、参数、嵌套、部分文件、`@import`指令、源映射和Sass注释。
- en: 'We also learned what vendor prefixing is and the different ways out there that
    help automate this process. We decided to use Prepros for the following tasks:
    watch, compile the SCSS files and automate prefixing. We learned to create a partial
    file to house our media queries mixin called `_mediaqueries.scss`. We also learned
    different methods to name media queries with the basic mixin that shows us how
    simple dealing with media queries can be while adhering to the best practice of
    letting the content define the breakpoints.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了什么是供应商前缀和帮助自动化这个过程的不同方法。我们决定使用Prepros来执行以下任务：监视、编译SCSS文件和自动添加前缀。我们学会了创建一个部分文件来容纳我们的媒体查询mixin，名为`_mediaqueries.scss`。我们还学会了使用基本mixin来命名媒体查询的不同方法，这个mixin向我们展示了如何简单地处理媒体查询，同时遵循让内容定义断点的最佳实践。
- en: In the next chapter, we're going to *dive* into HTML5 and how to mark up our
    content to prepare it for RWD. Get your snorkels ready!
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究HTML5以及如何标记我们的内容以准备进行RWD。准备好你的浮潜装备！
