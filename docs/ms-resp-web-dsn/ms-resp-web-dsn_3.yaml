- en: Chapter 3. Mobile-first or Desktop-first?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。移动优先还是桌面优先？
- en: In my years of experience designing and building responsive websites, I've found
    that in order to have a better view of the content and the messages, it's easier
    to visualize things with a desktop-first approach during the wireframe and design
    phases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我多年的响应式网站设计和构建经验中，我发现为了更好地查看内容和消息，在线框和设计阶段使用桌面优先方法更容易可视化事物。
- en: As we are able to see more content in a given layout with a desktop-first approach,
    it allows us to translate the hierarchy of the content that was provided to us
    into a layout that represents said hierarchy. Doing this in a small canvas of
    320 pixel width is more difficult than it needs to be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于桌面优先方法允许我们在给定布局中看到更多内容，因此我们可以将提供给我们的内容的层次结构转化为代表该层次结构的布局。在320像素宽的小画布上进行此操作比需要更困难。
- en: When you accomplish that hierarchy, it will remain the same on small-screen
    devices, and the only thing that changes is the layout.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成了这种层次结构，它将在小屏设备上保持不变，唯一改变的是布局。
- en: '*Best practices* recommend building mobile-first, but many web professionals
    don''t really know why we build *mobile-first* in the first place. Pun intended.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*最佳实践*建议首先构建移动，但许多网络专业人员实际上并不知道为什么我们首先构建*移动*。双关语。'
- en: So, let's clear it up. The reason we build mobile-first is because of three
    principles mentioned by Luke Wroblewski, the author who actually coined the term
    *mobile-first* in 2009\. You will notice that none of those principles are related
    to HTML, CSS, and/or JavaScript. In other words, you don't build mobile-first
    because of any advantage with HTML, CSS, or JavaScript. For more information,
    visit [http://www.lukew.com/ff/entry.asp?933](http://www.lukew.com/ff/entry.asp?933).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们澄清一下。我们首先构建移动的原因是由Luke Wroblewski提到的三个原则，他实际上在2009年创造了*移动优先*这个术语。您会注意到这些原则都与HTML、CSS和/或JavaScript无关。换句话说，您不是因为HTML、CSS或JavaScript的任何优势而首先构建移动。有关更多信息，请访问[http://www.lukew.com/ff/entry.asp?933](http://www.lukew.com/ff/entry.asp?933)。
- en: 'Consider the following points:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下几点：
- en: '**Mobile is exploding**: Well, mobile has already exploded. This basically
    means that it''s a lot easier, faster, and more convenient for people to use their
    mobile devices to access the web. So if you build your website to be compatible
    with mobile devices first, there''s a better chance of providing a better user
    experience and being viewed by more people than if you have a desktop-only website/app.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动正在爆炸**：嗯，移动已经爆炸了。这基本上意味着人们更容易、更快速、更方便地使用移动设备访问网络。因此，如果您首先构建与移动设备兼容的网站，就有更好的机会提供更好的用户体验，并被更多人查看，而不是拥有仅限桌面的网站/应用程序。'
- en: '**Mobile forces you to focus**: Since there''s a lot less space on a mobile
    device''s screen than on a desktop screen, there''s a mandatory need to prioritize.
    This means that the most important tasks and/or messages need to be visible right
    away.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动迫使您专注**：由于移动设备屏幕上的空间比桌面屏幕上的空间少得多，因此有必要进行优先排序。这意味着最重要的任务和/或消息需要立即可见。'
- en: '**Mobile extends your capabilities**: Mobile devices have features that a desktop
    device doesn''t have: GPS, accelerometer, multitouch inputs, voice recognition,
    front and rear cameras, and so on. When going mobile-first, you can use these
    advanced technologies to create richer, more exciting experiences.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动扩展了您的能力**：移动设备具有桌面设备没有的功能：GPS、加速计、多点触控输入、语音识别、前后摄像头等。在进行移动优先时，您可以使用这些先进技术来创建更丰富、更令人兴奋的体验。'
- en: 'Now that you have a final design, you now need to implement that design into
    HTML, CSS, and JavaScript. For this phase, you should use the mobile-first approach
    and take into account the three reasons we mentioned earlier:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了最终设计，现在您需要将该设计实施到HTML、CSS和JavaScript中。在这个阶段，您应该使用移动优先方法，并考虑我们之前提到的三个原因：
- en: Building mobile-fist means your website/app can be seen by more people
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建移动优先意味着您的网站/应用程序可以被更多人看到
- en: It makes you prioritize the content
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使您优先考虑内容
- en: If you need to, it will allow you to use the advanced features and capabilities
    of mobile devices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，它将允许您使用移动设备的高级功能和能力
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Create your designs in a desktop-first view, but implement them with mobile-first.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在桌面优先视图中创建您的设计，但使用移动优先进行实施。
- en: Sass mixins for mobile-first and desktop-first media queries.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动优先和桌面优先媒体查询的Sass混合。
- en: Dealing with legacy browsers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理旧版浏览器。
- en: How to deal with high-density screens.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理高密度屏幕。
- en: Why RWD is sometimes not necessarily the right solution.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么RWD有时并不一定是正确的解决方案。
- en: Retrofitting an old website with RWD.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RWD改造旧网站。
- en: Create your designs in a desktop-first view, but implement them with mobile-first
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在桌面优先视图中创建您的设计，但使用移动优先进行实施
- en: 'Let''s look at some terminology so that we''re on the same page:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些术语，以便我们在同一页面上：
- en: '**Wireframe**: This is a very basic visual representation of a layout using
    only outlines, in other words, in black and white. There are no colors, no branding,
    and no defined styles of any kind.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线框**：这是使用仅轮廓的非常基本的布局的视觉表示。没有颜色，没有品牌，也没有任何定义的样式。'
- en: '**Design/Comp**: This is a *fleshed out* wireframe with colors, branding, and
    styles. It''s a very close representation (usually, say, 95 percent close to the
    final product) of the final page/site/app without going into markup or coding
    of any kind.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计/构图**：这是一个带有颜色、品牌和样式的*充实*线框。它是最终页面/站点/应用程序的非常接近表示（通常说，接近最终产品的95%）而不涉及任何标记或任何类型的编码。'
- en: '**HTML mockup or HTML template**: This is when the design has been implemented
    into an actual HTML page with CSS and—sometimes—JavaScript. It can only be viewed
    in the browser. It''s practically an exact representation (99 percent close to
    the final product) of how the page/site/web app will look and work like.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML模拟或HTML模板**：这是当设计已经被实现到一个实际的HTML页面中，带有CSS和—有时—JavaScript。它只能在浏览器中查看。它几乎是页面/站点/网络应用的最终产品的精确表示（接近99%）。'
- en: With the terminology clear, let's continue.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 术语明确后，让我们继续。
- en: Some professionals, including me, recommend using more modern and efficient
    techniques to create visual assets in order to optimize the time spent during
    the process of wireframing and creating designs/comps. Techniques such as style
    tiles, mood boards, element collages, and atomic design differentiate themselves
    from traditional wireframing and designs/comps methodologies. They offer the opportunity
    to explore layouts and styles, independent of screen widths, technologies, and
    even content creation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些专业人士，包括我在内，建议使用更现代和高效的技术来创建视觉资产，以优化线框和设计/构图过程中的时间。诸如样式瓷砖、情绪板、元素拼贴和原子设计等技术与传统的线框和设计/构图方法有所不同。它们提供了独立于屏幕宽度、技术甚至内容创建的布局和样式的探索机会。
- en: For the scope of this book, we are going to focus on how a few things of the
    traditional wireframing and designs/comps methodologies can still be harnessed
    while maximizing the use of our time in these initial stages of mastering **Responsive
    Web Design** (**RWD**) with HTML5 and CSS3.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的范围内，我们将专注于如何在掌握HTML5和CSS3的**响应式网页设计**（**RWD**）的初期阶段最大化利用时间的同时，仍然可以利用传统线框和设计/构图方法的一些内容。
- en: Why create designs in a desktop-first view?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要以桌面优先的方式创建设计？
- en: 'The reason behind creating designs in a desktop-first view is simple: real
    estate (space).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以桌面优先的方式创建设计的原因很简单：房地产（空间）。
- en: As designers, we are required to reflect the hierarchy of the content in a visual
    way. To accomplish this, we use many design principles such as rhythm, proximity,
    whitespace, patterns, contrast, balance, grid, symmetry, and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计师，我们需要以视觉方式反映内容的层次结构。为了实现这一点，我们使用许多设计原则，如节奏、接近性、空白、模式、对比、平衡、网格、对称等等。
- en: When the canvas on which we're creating a wireframe or design/comp is big enough
    to try different arrangements and layouts, we have the necessary flexibility to
    explore different ways that can represent the said content hierarchy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建线框或设计/构图的画布足够大，可以尝试不同的排列和布局，我们就有了必要的灵活性来探索可以代表所述内容层次结构的不同方式。
- en: 'For example, we''re using a 12-column grid and the content we were provided
    with dictates the following content hierarchy:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们正在使用一个12列网格，我们提供的内容决定了以下内容层次结构：
- en: The business wants users to be able to provide their e-mail IDs to receive our
    newsletter.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这家企业希望用户能够提供他们的电子邮件ID以接收我们的新闻通讯。
- en: We want to display a *featured post* chosen by the editorial department.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望展示编辑部选择的*特色文章*。
- en: 'With the preceding content hierarchy, we can immediately start picturing different
    layouts to convey this hierarchy:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面的内容层次结构，我们可以立即开始构想不同的布局来传达这个层次结构：
- en: For users to provide their e-mail addresses, we'll create a form with a heading,
    a paragraph, an input type e-mail, and a button. This form will be on the top-left
    corner below the header and it could have a width of three to four columns. I'm
    thinking that maybe four columns is too wide though, but let's wireframe it and
    see how that feels and what usability, accessibility, and legibility issues or
    benefits this could have.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让用户提供他们的电子邮件地址，我们将创建一个带有标题、段落、电子邮件输入类型和按钮的表单。这个表单将位于页眉下方的左上角，并且可能有三到四列的宽度。我认为可能四列太宽了，但让我们先画线框看看感觉如何，以及这可能会有什么可用性、可访问性和可读性问题或好处。
- en: For the *featured post*, we'll use the remaining columns. If the e-mail form
    is three-column wide, we'll use the remaining nine; if the e-mail form is four-column
    wide, we'll just use the remaining eight columns. The featured post has a lot
    more content, such as the heading, author, date, category, snippet, thumbnail,
    and a link to the full post.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*特色文章*，我们将使用剩余的列。如果电子邮件表单是三列宽，我们将使用剩下的九列；如果电子邮件表单是四列宽，我们将只使用剩下的八列。特色文章有更多的内容，如标题、作者、日期、类别、摘要、缩略图和指向完整文章的链接。
- en: With a wide canvas in our design/wireframing application, we can play with these
    different approaches and eventually end with a proposed layout that's sound and
    represents the content hierarchy as required by the business or stakeholders.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计/线框应用程序中有一个宽敞的画布，我们可以尝试这些不同的方法，并最终得出一个合理的建议布局，以满足企业或利益相关者的要求，并且代表内容层次结构。
- en: Creating a layout like this one with a mobile-first approach with a small canvas
    is practically impossible. The small real estate screen is incredibly restrictive
    and limited. But when things start to grow, we would need to make this exploration
    process each time we think of a specific breakpoint.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以移动优先的方式创建这样一个布局几乎是不可能的。小型房地产屏幕非常受限制和有限。但当事情开始增长时，我们需要每次考虑特定断点时进行这个探索过程。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Actually, we shouldn't be thinking about breakpoints at this point (no pun intended),
    because the content—not specific device widths—is what dictates where a new breakpoint
    needs to be added.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在这一点上不应该考虑断点（无意冒犯），因为内容而不是特定的设备宽度决定了需要添加新断点的位置。
- en: Once we have a layout defined that reflects the content hierarchy, we will be
    in a good spot because when that content is rearranged on smaller screens, no
    matter which widths, the hierarchy will remain intact.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了反映内容层次结构的布局，我们就会处于一个良好的位置，因为当这些内容在较小的屏幕上重新排列时，无论宽度是多少，层次结构都将保持完整。
- en: Why implement with mobile-first?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要以移动优先的方式实施？
- en: 'Let''s clarify a term first: *implement* means create an HTML mockup with CSS
    and, if necessary, JavaScript, based on a wireframe or design/comp.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先澄清一个术语：*implement*意味着根据线框图或设计/构图创建一个带有CSS和必要时JavaScript的HTML模型。
- en: 'The reasons mentioned at the beginning of this chapter are the answer to the
    question *why implement with mobile-first?* Remember: mobile is exploding (well,
    it already did), mobile forces you to focus and mobile extends your capabilities.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开头提到的原因是回答“为什么要首先使用移动设备实施？”记住：移动设备正在爆炸（实际上已经爆炸了），移动设备迫使你集中注意力，并扩展了你的能力。
- en: None of those reasons could be accomplished with a desktop-first implementation,
    except maybe (that's a huge *maybe*) the second premise.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第二个前提（这是一个巨大的*也许*）之外，这些原因都无法通过桌面优先实现。
- en: Let's change gears and move on to a subject a bit more technical that will help
    us understand how Sass mixins can help us master RWD for the mobile-first and
    desktop-first methodologies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换个话题，转向一个更加技术性的主题，这将帮助我们了解Sass mixin如何帮助我们掌握移动设备优先和桌面优先方法。
- en: So, let's recap. Use desktop-first to create your designs and wireframes. Having
    a large canvas allows us to explore different layouts and properly arrange the
    hierarchy of the content. When it's time to implement (create HTML mockups), use
    mobile-first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾一下。使用桌面优先来创建你的设计和线框图。有一个大画布可以让我们探索不同的布局，并正确安排内容的层次结构。当需要实施（创建HTML模型）时，使用移动设备优先。
- en: Sass mixins for the mobile-first and desktop-first media queries
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动设备优先和桌面优先媒体查询的Sass mixin
- en: 'For our examples, there are two types of Sass mixins we''re going to use in
    this book: a mobile-first mixin that uses the `min-width` property and a desktop-first
    mixin that uses the `max-width` property. We already saw the following mixins
    and how they worked in [Chapter 1](ch01.html "Chapter 1. Harness the Power of
    Sass for Responsive Web Design"), *Harness the Power of Sass for Responsive Web
    Design*, but here''s a refresher.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，在本书中我们将使用两种类型的Sass mixin：一种使用`min-width`属性的移动设备优先mixin，另一种使用`max-width`属性的桌面优先mixin。我们已经在[第1章](ch01.html
    "第1章。利用Sass实现响应式网页设计的强大功能")中看到了以下mixin及其工作原理，*利用Sass实现响应式网页设计的强大功能*，但这里是一个复习。
- en: The mobile-first mixin
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动设备优先mixin
- en: 'We''re going to use the following mobile-first mixin:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下移动设备优先mixin：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is how we use it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用它的方式：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This compiles to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下内容：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The desktop-first mixin
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桌面优先mixin
- en: 'Here''s the desktop-first mixin we''re going to use:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要使用的桌面优先mixin：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is how we use it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用它的方式：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This compiles to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下内容：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The great thing about using these mixins is that it's incredibly easy to find
    out which approach is being used, because we can see either the term `forLargeScreens`
    or `forSmallScreens` is repeated all over our SCSS file. If someone else were
    to edit any of the work we initially did, they will get a clear idea of which
    approach we used to build our site/app just by scanning the SCSS file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些mixin的好处是，非常容易找出正在使用的方法，因为我们可以在整个SCSS文件中看到`forLargeScreens`或`forSmallScreens`这个术语被重复使用。如果其他人要编辑我们最初做的任何工作，他们将清楚地了解我们用哪种方法构建了我们的站点/应用，只需扫描SCSS文件。
- en: Dealing with legacy browsers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理旧版浏览器
- en: Within the question "mobile-first or desktop-first?" there's an area that we
    need to cover about legacy browsers. Each project, each client, and their corresponding
    analytics (if they have any, which they should) have different requirements that
    affect how we are supposed to deal with those older browsers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在“移动设备优先还是桌面优先？”的问题中，有一个领域我们需要涵盖一下，那就是旧版浏览器。每个项目，每个客户及其相应的分析（如果有的话，他们应该有），都有不同的要求，影响我们应该如何处理那些旧版浏览器。
- en: If you're building with a desktop-first approach, your current workflow should
    remain the same as this is pretty much what we've been doing since before RWD
    became practically mandatory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是用桌面优先的方法构建的，你当前的工作流程应该保持不变，因为这几乎就是在响应式网页设计变得几乎是强制性之前我们一直在做的事情。
- en: 'This means that you would still use something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你仍然会使用类似这样的东西：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This compiles to the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下内容：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'IE7 and IE8 do not support media queries, but the preceding code will work
    just fine because the `header { width: 50%; }` rule is not inside a media query.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'IE7和IE8不支持媒体查询，但前面的代码将正常工作，因为`header { width: 50%; }`规则不在媒体查询内。'
- en: 'However, if you''re doing mobile-first, then `header { width: 50%; }` is going
    to be inside a media query so that IE7 and IE8 won''t be able to see that rule:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，如果你是以移动设备为先，那么`header { width: 50%; }`将在媒体查询内，因此IE7和IE8将无法看到该规则：'
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This compiles to the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下内容：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What do you do then? The solution is quite simple: use the `Respond.js` script.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你该怎么办？解决方案非常简单：使用`Respond.js`脚本。
- en: How to use Respond.js for RWD
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用Respond.js进行RWD
- en: '`Respond.js` is a type of script called a *polyfill*. A polyfill, according
    to the one who coined the term in the first place, Remy Sharp, is a piece of code
    that provides the technology that we, web developers, expect browsers to provide
    natively.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Respond.js`是一种称为*polyfill*的脚本。根据最初提出这个术语的人Remy Sharp的说法，polyfill是一段代码，提供了我们，网页开发人员，期望浏览器本地提供的技术。'
- en: In web design and development, polyfills are more abundant as JavaScript implementations,
    in our case, Scott Jehl's `Respond.js`. But we could also say that there are polyfills
    in CSS too, for example, the well-known `reset.css` from Eric Meyer and `Normalize.css`
    from Nicolas Gallagher and Jonathan Neal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页设计和开发中，polyfill比JavaScript实现更丰富，例如Scott Jehl的`Respond.js`。但我们也可以说CSS中也有polyfill，例如Eric
    Meyer的著名的`reset.css`和Nicolas Gallagher和Jonathan Neal的`Normalize.css`。
- en: 'The `Respond.js` script is a polyfill that makes legacy browsers (IE6/7/8)
    support a particular CSS feature they were never made to support: media queries.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Respond.js`脚本是一种polyfill，使旧版浏览器（IE6/7/8）支持它们从未支持过的特定CSS功能：媒体查询。'
- en: You can download `Respond.js` from [https://github.com/scottjehl/Respond](https://github.com/scottjehl/Respond).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/scottjehl/Respond](https://github.com/scottjehl/Respond)下载`Respond.js`。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although I'm suggesting the use of a polyfill, we need to be mindful of the
    additional HTTP request the site/app needs to make in order to fetch this JavaScript
    file. The fewer requests our sites/apps make, the faster they are going to be
    creating many benefits such as improved user experience and positive SEO impact.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我建议使用polyfill，但我们需要注意网站/应用程序需要进行额外的HTTP请求以获取此JavaScript文件。我们的网站/应用程序发出的请求越少，它们就会越快，从而带来许多好处，如改善用户体验和积极的SEO影响。
- en: 'So, here''s what you need to do:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要做以下事情：
- en: Make sure the call to `Respond.js` is *after* the call to your CSS file(s) (hopefully
    it is just one CSS file).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保对`Respond.js`的调用在调用CSS文件之后*（希望只有一个CSS文件）*。
- en: Call the `Respond.js` script.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Respond.js`脚本。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Performance best practices recommend placing nonessential scripts at the bottom
    of the markup right before the closing `</body>` tag. Since `Respond.js` is aimed
    at legacy browsers, let's go ahead and do that. Another benefit of placing scripts
    at the bottom of the markup is that it helps to avoid blocking the rendering of
    the page.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 性能最佳实践建议将非必要的脚本放在标记的底部，就在关闭的`</body>`标签之前。由于`Respond.js`针对的是旧版浏览器，让我们继续这样做。将脚本放在标记底部的另一个好处是有助于避免阻塞页面的渲染。
- en: 'Here''s our example HTML:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的示例HTML：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our `styles.scss` file, we type the following lines:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`styles.scss`文件中，我们输入以下行：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This compiles to the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译为以下内容：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, when you resize an IE7 or IE8 browser window, it will be able to display
    a red background if the window width is 640 pixels or less, and a green background
    if the window is 641 pixels or more.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您调整IE7或IE8浏览器窗口大小时，如果窗口宽度为640像素或更小，则它将能够显示红色背景，如果窗口为641像素或更大，则显示绿色背景。
- en: The days of an IE-specific style sheet are dead
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IE特定样式表的时代已经过去
- en: 'I''ve avoided creating IE-specific style sheets since I started writing CSS.
    The reasons for this are simple:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我开始编写CSS以来，我一直避免创建IE特定的样式表。这样做的原因很简单：
- en: '**File management**: The fewer files there are to manage when going to production,
    the smoother every process goes; not to mention being less prone to errors.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件管理**：在进行生产时，文件越少，每个过程就越顺利；更不用说更不容易出错。'
- en: '**Scalability**: If you need to add, remove, or edit a style, you and your
    team know that the final change(s) needs to end up in your main and only CSS file,
    in our case, the SCSS file.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：如果需要添加、删除或编辑样式，您和您的团队知道最终的更改需要出现在您的主要且唯一的CSS文件中，我们的情况下是SCSS文件。'
- en: '**Organization**: Keep everyone on the same page when adding, removing, or
    editing IE-specific styles in the right CSS file(s), in our case, SCSS file(s).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织**：在添加、删除或编辑正确的CSS文件（在我们的情况下是SCSS文件）中的IE特定样式时，让每个人都保持一致。'
- en: '**Performance**: One less HTTP request is a good thing, a very good thing.
    Anything we can do for performance, no matter how small, can go a long way for
    a good user experience; not to mention a fast website is good for SEO.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：少一个HTTP请求是一件好事，非常好的事情。无论多么小，我们为性能所做的任何事情都可以为良好的用户体验带来很大帮助；更不用说快速的网站对SEO有好处。'
- en: Other benefits of not using an IE-specific style sheet
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不使用IE特定样式表的其他好处
- en: In legacy browsers, page rendering is not blocked when they try to download
    the IE-specific style sheet. Also, troubleshooting is easier. So what do we use
    then?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版浏览器中，当它们尝试下载IE特定的样式表时，页面渲染不会被阻塞。此外，故障排除更容易。那么我们该使用什么呢？
- en: 'There are several ways to deal with IE by keeping everything in one style sheet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以通过将所有内容放在一个样式表中来处理IE：
- en: Use CSS hacks (not recommended).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS hack（不建议）。
- en: Use `Modernizr.js`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Modernizr.js`。
- en: Use conditional classes in the `<html>` tag.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`<html>`标签中使用条件类。
- en: Let's talk a bit more about a popular method, using conditional classes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再谈谈一个流行的方法，使用条件类。
- en: Use conditional classes in the <html> tag
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在`<html>`标签中使用条件类
- en: 'Paul Irish''s 2008 article ([http://www.paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/](http://www.paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/))
    specifies a method that I recommend for several reasons:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Paul Irish在2008年的文章（[http://www.paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/](http://www.paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/)）指定了一个我推荐的方法，原因有几个：
- en: It's easy to implement; it's just a matter of copying and pasting this block
    of markup at the top of our HTML file.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易实现；只需将此标记块复制并粘贴到我们的HTML文件顶部即可。
- en: It's not intrusive, since there's no need for anyone in the chain (users, browsers,
    servers, and us) to deal with additional files.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这并不具有侵入性，因为没有任何人需要处理额外的文件（用户、浏览器、服务器和我们）。
- en: It doesn't require JavaScript to work; if a visitor has JavaScript unavailable
    or disabled, everything will still work.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要JavaScript即可工作；如果访问者无法使用或禁用JavaScript，一切仍将正常工作。
- en: 'This is the one I use:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用的一个：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: IE10 and above does not support *conditional comments* anymore, that's why there
    isn't any mention of IE10 in the conditional classes markup.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: IE10及以上不再支持*条件注释*，这就是条件类标记中没有提及IE10的原因。
- en: 'With the preceding conditional classes in place, targeting a specific IE (IE7
    in this example) looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面的条件类，针对特定IE（此示例中为IE7）的定位如下：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we need to target all IEs, we would do this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要针对所有IE进行定位，我们会这样做：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This compiles to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译为以下内容：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For all other browsers, we would do this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他浏览器，我们会这样做：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It doesn't matter which of the methods you use, `Modernizr.js` or conditional
    classes, it's all personal preference. You'll be doing *the right thing* by using
    either of those two methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种方法，“Modernizr.js”或条件类，都是个人偏好。使用这两种方法中的任何一种都是*正确的*做法。
- en: Remember, avoid CSS hacks at all costs. As web designers and web developers,
    we have a moral responsibility of creating a better web for everyone.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，无论如何都要避免CSS hack。作为网页设计师和网页开发人员，我们有责任为每个人创造一个更好的网络。
- en: How to deal with high-density screens
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何处理高密度屏幕
- en: There are many articles on the Web that explain what **Dots Per Inch** (**DPI**),
    **Pixels Per Inch** (**PPI**), and **Density-independent Pixel** (**DP/DiP**)
    are. Although it may be important to understand the intricate details of such
    technologies and terms, let's keep the scope of the book in the realms of what
    the basis of high density screens is and what we need to understand to create
    sound responsive designs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上有很多文章解释了**每英寸点数**（DPI），**每英寸像素**（PPI）和**密度无关像素**（DP/DiP）是什么。虽然了解这些技术和术语的复杂细节可能很重要，但让我们把本书的范围限制在高密度屏幕的基础和我们需要了解的内容上。
- en: Bitmaps or vectors for high-density screens?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位图还是矢量适用于高密度屏幕？
- en: Vectors like SVGs, Icon Fonts, or regular fonts are a visual representation
    of mathematical equations, thus they never lose quality, no matter their size.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 像SVG、图标字体或常规字体这样的矢量是数学方程的视觉表示，因此无论它们的大小如何，它们永远不会失去质量。
- en: 'In order for bitmap images to display well on high-density screens, we have
    to export a high-resolution version of the *normal-quality* image. This means
    that we need to create two files (or more) for every bitmap image we plan to use:
    one normal-quality image for non-high-density screens (standard LCD displays,
    old TFT monitors, some TVs, and so on) and one (or more) high-quality image for
    high-density screens (any *retina* devices and Super AMOLED displays, for example).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使位图图像在高密度屏幕上显示良好，我们必须导出*正常质量*图像的高分辨率版本。这意味着我们需要为我们计划使用的每个位图图像创建两个文件（或更多）：一个用于非高密度屏幕（标准液晶显示器，旧TFT监视器，一些电视等）的正常质量图像，以及一个（或更多）用于高密度屏幕（例如任何*视网膜*设备和Super
    AMOLED显示器）的高质量图像。
- en: This is where good design judgment comes into play, because sometimes we may
    not necessarily need to export two (or more) bitmap images every time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是良好的设计判断发挥作用的地方，因为有时我们可能并不一定需要每次都导出两个（或更多）位图图像。
- en: There are several techniques that we can use to deal with images when we have
    to consider high-density screens. These techniques are explained in detail in
    [Chapter 6](ch06.html "Chapter 6. Working with Images and Videos in Responsive
    Web Design"), *Working with Images and Videos in Responsive Web Design*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须考虑高密度屏幕时，有几种技术可以用来处理图像。这些技术在《第6章》*响应式网页设计中的图像和视频处理*中有详细解释。
- en: Sometimes RWD is not necessarily the right solution
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有时RWD并不一定是正确的解决方案
- en: 'Take, for example, the booking section of most travel sites. The sheer amount
    and type of information a site like this manages makes it quite difficult to have
    a responsive site. When visiting the eight highest ranked travel sites in Google''s
    search results, this is what I saw:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数旅行网站的预订部分。这类网站管理的大量信息和类型使得响应式网站变得非常困难。当访问谷歌搜索结果中排名前八的旅行网站时，我看到了以下情况：
- en: '[http://www.kayak.com/](http://www.kayak.com/)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.kayak.com/](http://www.kayak.com/)'
- en: '**Homepage**: Responsive'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：响应'
- en: '**Booking page**: Not responsive'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订页面**：不响应'
- en: '[http://www.expedia.com/](http://www.expedia.com/)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.expedia.com/](http://www.expedia.com/)'
- en: '**Homepage**: Responsive'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：响应'
- en: '**Booking page**: Responsive'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订页面**：响应'
- en: '[https://www.hotwire.com/](https://www.hotwire.com/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.hotwire.com/](https://www.hotwire.com/)'
- en: '**Homepage**: Not responsive'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：不响应'
- en: '**Booking page**: Responsive'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订页面**：响应'
- en: '[http://www.travelocity.com/](http://www.travelocity.com/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.travelocity.com/](http://www.travelocity.com/)'
- en: '**Homepage**: Responsive'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：响应'
- en: '**Booking page**: Responsive'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订页面**：响应'
- en: '[http://www.orbitz.com/](http://www.orbitz.com/)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.orbitz.com/](http://www.orbitz.com/)'
- en: '**Homepage**: Not responsive'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：不响应'
- en: '**Booking page**: Not responsive'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订页面**：不响应'
- en: '[http://www.priceline.com/](http://www.priceline.com/)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.priceline.com/](http://www.priceline.com/)'
- en: '**Homepage**: Not responsive'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：不响应'
- en: '**Booking page**: Not responsive'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订页面**：不响应'
- en: '[http://www.tripadvisor.in/](http://www.tripadvisor.in/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.tripadvisor.in/](http://www.tripadvisor.in/)'
- en: '**Homepage**: Not responsive'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：不响应'
- en: '**Booking page**: Not responsive'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订页面**：不响应'
- en: '[https://www.hipmunk.com/](https://www.hipmunk.com/)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.hipmunk.com/](https://www.hipmunk.com/)'
- en: '**Homepage**: Not responsive'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：不响应'
- en: '**Booking page**: Not responsive'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订页面**：不响应'
- en: 'Here is a brief list of our findings:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的一些发现的简要列表：
- en: Since Expedia acquired Travelocity, they share the same platform. The difference
    is in the branding; thus, I will consider these two sites as one.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自从Expedia收购了Travelocity，它们共享相同的平台。区别在于品牌定位；因此，我将考虑这两个网站为一个。
- en: The homepages of five out of seven sites (71 percent) are not responsive.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 七个网站中有五个（71％）的主页不响应。
- en: The booking pages of five out of seven sites (71 percent) are not responsive.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 七个网站中有五个（71％）的预订页面不响应。
- en: Only one site (Expedia/Travelocity) out of seven (14 percent) is fully responsive.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 七个网站中只有一个（Expedia/Travelocity）是完全响应的（14％）。
- en: Four out of seven sites (57 percent) have no RWD whatsoever.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 七个网站中有四个（57％）根本没有RWD。
- en: We can conclude that the most popular travel sites have not fully embraced RWD
    yet, but some are hybrids between fixed width and responsive layouts. That's why
    all of those sites have separate mobile apps. For them, RWD may not be a priority,
    so they rely on their mobile apps to balance this deficiency.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，最受欢迎的旅行网站尚未完全采用RWD，但有些是固定宽度和响应式布局的混合体。这就是为什么所有这些网站都有单独的移动应用程序。对于它们来说，RWD可能不是优先考虑的，因此它们依赖于它们的移动应用程序来弥补这一不足。
- en: Although very rare these days, sometimes we may need to build a site or page
    that is not responsive. Actually, there are some pages out there today that are
    not responsive.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在今天已经非常罕见，但有时我们可能需要构建一个不响应的网站或页面。实际上，今天有一些页面是不响应的。
- en: CodePen is one of the most popular frontend sandboxes out there and the editor
    of CodePen is not responsive. Why? Because it doesn't need to be. It's very unlikely
    that a developer would go to CodePen to write HTML, Sass, and JavaScript using
    their phone.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: CodePen是最受欢迎的前端沙箱之一，而CodePen的编辑器不是响应式的。为什么？因为它不需要。开发人员很少会使用手机去CodePen编写HTML、Sass和JavaScript。
- en: 'With that being said, if you ever need to build a site/page that doesn''t need
    to be responsive, there are two good options as far as CSS grid systems go:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果您需要构建一个不需要响应的站点/页面，就CSS网格系统而言，有两个很好的选择：
- en: Use our old friend, the 960 Grid System ([http://960.gs/](http://960.gs/)).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的老朋友，960网格系统（[http://960.gs/](http://960.gs/)）。
- en: Use the 1140 Grid System ([http://www.1140px.com/](http://www.1140px.com/)).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用1140网格系统（[http://www.1140px.com/](http://www.1140px.com/)）。
- en: 'There are a few things to consider:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事需要考虑：
- en: The 960 Grid System is aimed at screens 1024px wide.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 960网格系统针对1024px宽的屏幕。
- en: The 1140 Grid System is aimed at screens 1280px wide.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1140网格系统针对1280px宽的屏幕。
- en: The 1140 Grid System includes media queries by default, so we need to take this
    into account and decide whether it's best to leave them or if it's best to delete
    them to reduce file size and selector limitations in IE6-IE9.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1140网格系统默认包含媒体查询，因此我们需要考虑并决定是最好保留它们还是最好删除它们以减小文件大小并减少IE6-IE9中的选择器限制。
- en: Because I always thought that the 10px padding on the left and right of the
    960 Grid System left the content too close to the edges of the main container,
    I added 10 more pixels to each side, increasing the padding to 20px—turning the
    960 Grid System into a 980 Grid System. From now on, we will refer to it as the
    980GS.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我一直认为960网格系统左右各有10px的填充使内容离主容器的边缘太近，我在每一侧增加了10个像素，将填充增加到20px，将960网格系统变成了980网格系统。从现在开始，我们将称其为980GS。
- en: Retrofitting an old website with RWD
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RWD改装旧网站
- en: If and when the moment comes, we need to be prepared to make a nonresponsive
    or fixed-width site/app responsive.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有必要，我们需要准备使非响应式或固定宽度的站点/应用程序变得响应式。
- en: There are two ways of retrofitting a nonresponsive or fixed-width site/app.
    One way is using the **Adaptive Web Design** (**AWD**) technique that uses absolute
    units (that is, pixels). The other way is using RWD and transforming all pixel
    values to percentages with a very simple formula.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种改装非响应式或固定宽度的站点/应用程序的方法。一种是使用**自适应Web设计**（**AWD**）技术，使用绝对单位（即像素）。另一种是使用RWD，并使用非常简单的公式将所有像素值转换为百分比。
- en: Regardless of which techniques we use, we are going to have to use a desktop-first
    approach since the site we're dealing with was built for wide screens only. This
    means that we're going to use the `max-width` property in our media queries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用哪种技术，我们都必须使用桌面优先的方法，因为我们处理的站点只适用于宽屏。这意味着我们将在媒体查询中使用`max-width`属性。
- en: Before we look at both retrofitting techniques, we need a base page to start
    with.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看两种改装技术之前，我们需要一个基础页面来开始。
- en: The base page
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础页面
- en: 'The graphic you see here is proportional to a 12-column 980GS layout. The browser
    window is 1024px wide and the page is 980px wide:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此处看到的图形与12列980GS布局成比例。浏览器窗口宽度为1024px，页面宽度为980px：
- en: '![The base page](img/B02102_03_01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![基础页面](img/B02102_03_01.jpg)'
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Our main container in gray, which is 980px wide, already has 10px padding to
    the left and right. This means that the sections inside always need to add up
    to **960px**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们灰色的主容器宽度为980px，左右已经有10px的填充。这意味着内部的部分总是需要加起来等于**960px**。
- en: 'The following are the container''s components:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是容器的组件：
- en: The main container in gray is 980px wide with 10px padding on the left and right.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰色的主容器宽度为980px，左右各有10px的填充。
- en: 'The **Header** in green and **Footer** in red are 960px or 12-column wide each:
    940px with a 10px margin on the left and right.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色的**头部**和红色的**页脚**分别为960px或12列宽：940px带有左右各10px的边距。
- en: 'The **Nav** section in blue is 240px or 3-column wide: 220px with 10px left
    margin and right margins.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色的**导航**部分宽度为240px或3列：220px带有10px的左边距和右边距。
- en: 'The **Content** section in yellow is 710px or 9-column wide: 700px with 10px
    right margin.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色的**内容**部分宽度为710px或9列：700px带有10px的右边距。
- en: The gutter in white is 20px wide, that is, a 10px right margin from **Nav**
    and a 10px left margin from **Content**.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白色的间距宽度为20px，即**导航**右边距为10px，**内容**左边距为10px。
- en: So, *220px Nav + 710px Content + 20px gutter + 10px margins = 960px*.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，*220px导航 + 710px内容 + 20px间距 + 10px边距 = 960px*。
- en: HTML
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML
- en: 'Here''s the markup that represents our base page:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代表我们基础页面的标记：
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: CSS/SCSS
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS/SCSS
- en: Regarding our CSS/SCSS, we are only going to need to create one partial, the
    `_980gs.scss` file that contains the fixed-width grid.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的CSS/SCSS，我们只需要创建一个部分，即包含固定宽度网格的`_980gs.scss`文件。
- en: 'Then, we''re going to create a `styles.scss` file with which we are going to
    perform the following operations:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个`styles.scss`文件，我们将执行以下操作：
- en: Import the `_980gs.scss` file.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入`_980gs.scss`文件。
- en: Include our simple desktop-first Sass mixin to handle the media queries.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括我们简单的桌面优先Sass mixin来处理媒体查询。
- en: Create all the necessary media queries using the `max-width` property.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`max-width`属性创建所有必要的媒体查询。
- en: Compile it to `styles.css` and use it in our page.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其编译为`styles.css`并在我们的页面中使用。
- en: Creating the _980gs.scss file
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建_980gs.scss文件
- en: 'The `_980gs.scss` file contains the basic grid and looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`_980gs.scss`文件包含基本网格，如下所示：'
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Retrofitting with AWD
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWD进行改装
- en: Unlike RWD where the widths are fluid and elastic (ems and percentages), hence
    the term *relative units*, in AWD, the widths are fixed (pixels). Hence, we use
    the term *absolute units* and elements will *snap* to these fixed widths when
    we resize our browser window.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与RWD不同，其宽度是流体和弹性的（ems和百分比），因此术语*相对单位*，在AWD中，宽度是固定的（像素）。因此，我们使用术语*绝对单位*，当我们调整浏览器窗口大小时，元素将*捕捉*到这些固定宽度。
- en: In AWD, we use pixels for practically every width, even our media queries.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWD中，我们几乎每个宽度都使用像素，甚至我们的媒体查询也是如此。
- en: Creating the styles.scss file
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建styles.scss文件
- en: 'The first thing we''re going to do in the `styles.scss` file is to import the
    partial `_980gs.scss` file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是在`styles.scss`文件中导入部分`_980gs.scss`文件：
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we''re going to include our simple desktop-first mixin to handle the
    media queries. However, remember I mentioned before how this is mixin is scalable
    and we could make it compile pixel-based values if we wanted to? All we need to
    do is remove the value `/16+em` from the division `$media/16+em`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将包含我们简单的桌面优先mixin来处理媒体查询。然而，请记住我之前提到过这个mixin是可扩展的，如果我们想要的话，我们可以使它编译基于像素的值？我们所需要做的就是从除法`$media/16+em`中移除值`/16+em`：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following rules are merely for styling purposes in order to accomplish
    the same design we saw in the screenshot before:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则仅用于样式目的，以实现我们在之前截图中看到的相同设计：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At this point, our page is 980px wide and it looks like the screenshot we initially
    saw.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的页面宽度为980px，看起来和最初看到的截图一样。
- en: 'Let''s define the widths at which we are going to make our base page *snap*
    to:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义基本页面*捕捉*的宽度：
- en: At 980px, we're going to snap the page to 768px.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在980px时，我们将把页面捕捉到768px。
- en: At 768px, we're going to snap the page to 640px.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在768px时，我们将把页面捕捉到640px。
- en: At 640px, we're going to snap the page to 480px.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在640px时，我们将把页面捕捉到480px。
- en: At 480px, we're going to snap the page to 320px.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在480px时，我们将把页面捕捉到320px。
- en: This is where the fun begins. Let's start retrofitting this page by creating
    the media queries for each section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是乐趣开始的地方。让我们通过为每个部分创建媒体查询来开始改造这个页面。
- en: 980px to 768px (AWD)
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 980px到768px（AWD）
- en: 'The following media queries are aimed at 768px:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下媒体查询针对768px：
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Admittedly, it is a bit hard to perceive the difference in the book from 980px
    to 768px, but believe me, the following screenshot fully represents a browser
    window 980px wide and a page 768px wide:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，从980px到768px，书中的差异有点难以察觉，但相信我，以下截图完全代表了浏览器窗口宽980px，页面宽768px：
- en: '![980px to 768px (AWD)](img/B02102_03_02.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![980px到768px（AWD）](img/B02102_03_02.jpg)'
- en: As you can see, the moment the screen is 980px, the width of our main container
    (`.container_12`) goes from 980px to 768px. Our main container has 10px padding
    to the left and the right, so the widths of all other sections should add up to
    match 748px.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一旦屏幕宽度达到980px，我们的主容器（`.container_12`）的宽度就从980px变为768px。我们的主容器左右各有10px的填充，因此所有其他部分的宽度应该加起来匹配748px。
- en: Let's take a look.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看。
- en: 'Our **Header** and **Footer** that use the same class `.grid_12` are now 728px
    wide. So if we add: *728px + 10px left margin + 10px right margin = 748px*.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**Header**和**Footer**使用相同的类`.grid_12`，现在宽度为728px。因此，如果我们加上：*728px + 10px左边距
    + 10px右边距 = 748px*。
- en: 'If we add the widths of our **Nav** (`.grid_3`) and **Content** (`.grid_9`)
    sections:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将**Nav**（`.grid_3`）和**Content**（`.grid_9`）部分的宽度相加：
- en: '*200px Nav + 508px Content = 708px*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*200px Nav + 508px Content = 708px*'
- en: '*708px + 20px gutter = 728px*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*708px + 20px gutter = 728px*'
- en: '*728px + 10px left margin on Nav + 10px right margin on Content = 748px*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*728px + Nav的左边距10px + Content的右边距10px = 748px*'
- en: Stay with me, I promise this will be very interesting.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 跟着我，我保证这会非常有趣。
- en: 768px to 640px (AWD)
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 768px到640px（AWD）
- en: 'The following media queries are aimed at 640px:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下媒体查询针对640px：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ok, this layout is now a single column page. We're starting to see some results.
    Nice!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这个布局现在是单列页面。我们开始看到一些结果了。不错！
- en: '![768px to 640px (AWD)](img/B02102_03_03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![768px到640px（AWD）](img/B02102_03_03.jpg)'
- en: Again, remember that our main container has 10px padding to the left and the
    right, thus the widths of all other sections should add up to match 620px.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，请记住，我们的主容器左右各有10px的填充，因此所有其他部分的宽度应该加起来匹配620px。
- en: 'Let''s make sure our numbers add up:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们的数字加起来：
- en: 'Our **Header** and **Footer** that use the same class `.grid_12` are now 600px
    wide. So if we add: *600px + 10px left margin + 10px right margin = 620px*.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**Header**和**Footer**使用相同的类`.grid_12`，现在宽度为600px。因此，如果我们加上：*600px + 10px左边距
    + 10px右边距 = 620px*。
- en: 'If we add the widths of our **Nav** (`.grid_3`) and **Content** (`.grid_9`)
    sections:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将**Nav**（`.grid_3`）和**Content**（`.grid_9`）部分的宽度相加：
- en: '*160px Nav + 420px Content = 580px*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*160px Nav + 420px Content = 580px*'
- en: '*580px + 20px gutter = 600px*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*580px + 20px gutter = 600px*'
- en: '*600px + 10px left margin on Nav + 10px right margin on Content = 620px*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*600px + Nav的左边距10px + Content的右边距10px = 620px*'
- en: Let's make this page even smaller!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个页面变得更小！
- en: 640px to 480px (AWD)
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 640px到480px（AWD）
- en: 'The following media queries are aimed at 480px:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下媒体查询针对480px：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''re making some well-deserved progress! Here, the browser window is 640px
    wide and the page is 480px wide:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了一些应得的进展！在这里，浏览器窗口宽640px，页面宽480px：
- en: '![640px to 480px (AWD)](img/B02102_03_04.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![640px到480px（AWD）](img/B02102_03_04.jpg)'
- en: Remember that our main container has 10px padding to the left and the right,
    thus the widths of all other sections should add up to match 460px.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的主容器左右各有10px的填充，因此所有其他部分的宽度应该加起来匹配460px。
- en: Now, we are going to change from a 2-column to a 1-column layout. This means
    that all sections now have the exact same width.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从2列布局更改为1列布局。这意味着所有部分现在具有完全相同的宽度。
- en: 'This also means that in our SCSS file, we can create a single media block for
    all three classes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着在我们的SCSS文件中，我们可以为所有三个类创建一个单一的媒体块：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s make sure our numbers add up:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保我们的数字加起来：
- en: 'Our **Header**, **Nav**, **Content**, and **Footer** sections are now 440px
    wide, stacked one on top of the other. So if we add: *440px of all sections +
    10px left margin + 10px right margin = 460px*.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**Header**，**Nav**，**Content**和**Footer**部分现在宽度为440px，依次堆叠在一起。因此，如果我们加上：*所有部分的440px
    + 10px左边距 + 10px右边距 = 460px*。
- en: Here we go, the last piece of this puzzle!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来了，这个谜题的最后一块！
- en: 480px to 320px (AWD)
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 480px到320px（AWD）
- en: 'The following media queries are aimed at 320px:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下媒体查询针对320px：
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There we go! In this screenshot, the browser window is 320px wide—the content
    is 320px wide as well and fits very nicely:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来了！在这个屏幕截图中，浏览器窗口宽度为320px，内容也是320px宽，非常合适：
- en: '![480px to 320px (AWD)](img/B02102_03_05.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![480px到320px（AWD）](img/B02102_03_05.jpg)'
- en: 'We already know that our main container has 10px padding to the left and the
    right. In this case, we are going to remove that padding to gain those 20 pixels,
    since our screen real estate is now very small:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们的主容器左右各有10像素的填充。在这种情况下，我们将去掉填充以获得这20像素，因为我们的屏幕空间现在非常小：
- en: '[PRE28]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The 10px spacing on the left and right are now going to be created by the left
    and right margins from the other sections. This means that the width of each section
    should be 300px.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 左右各10像素的间距现在将由其他部分的左右边距创建。这意味着每个部分的宽度应为300像素。
- en: 'Adding the new 320px breakpoint is easy:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的320像素断点很容易：
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s make sure our numbers add up:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保我们的数字加起来：
- en: 'Our **Header**, **Nav**, **Content**, and **Footer** sections are now 300px
    wide, stacked one on top of the other. So if we add: *300px of all sections +
    10px left margin + 10px right margin = 320px*.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**标题**、**导航**、**内容**和**页脚**部分现在都是300像素宽，依次堆叠在一起。所以如果我们加上：*所有部分的300像素 + 10像素左边距
    + 10像素右边距 = 320像素*。
- en: That's it. We have now retrofitted a fixed-width page to be responsive with
    the AWD technique.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们现在已经使用AWD技术将固定宽度页面改为响应式。
- en: 'The final SCSS is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的SCSS如下：
- en: '[PRE30]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It compiles to the following CSS:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它编译成以下CSS：
- en: '[PRE31]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As you can see, several breakpoints are repeated in our final CSS file. This
    is an issue with Sass. However, it's really not an issue or something we need
    to worry about because when this file is gzipped by the server, it will compress
    it at its maximum. If we minimize the final output (which we should anyhow), we'll
    be compressing the file even more. The repeated `@media` breakpoints have very
    little if any impact on performance.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的最终CSS文件中重复了几个断点。这是Sass的一个问题。然而，这实际上并不是一个问题，也不是我们需要担心的事情，因为当服务器对该文件进行gzip压缩时，它将以最大限度进行压缩。如果我们最小化最终输出（无论如何我们都应该这样做），我们将进一步压缩文件。重复的`@media`断点对性能几乎没有任何影响。
- en: Now, let's see how retrofitting the same page looks when using percentages and
    RWD.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用百分比和RWD改装相同页面的样子。
- en: Retrofitting with RWD
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RWD进行改装
- en: We just saw how using AWD is accomplished, using pixels. With RWD and a very
    simple equation, we can retrofit a site using relative units, in our case percentages.
    Not to mention it will be a lot easier than using AWD.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用像素来实现AWD。通过RWD和一个非常简单的方程，我们可以使用相对单位（在我们的情况下是百分比）来改装网站。更不用说这将比使用AWD要容易得多。
- en: The RWD magic formula
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RWD的魔法公式
- en: 'Discovered/created by Ethan Marcotte, who coined the term *Responsive Web Design*,
    the RWD magic formula is a very simple equation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由Ethan Marcotte发现/创造，他创造了*响应式网页设计*这个术语，RWD的魔法公式是一个非常简单的方程：
- en: (target ÷ context) x 100 = result %
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: （目标 ÷ 上下文）x 100 = 结果 %
- en: Before we start turning pixels into percentages, we need to see which width
    our *context* is going to be.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始将像素转换为百分比之前，我们需要看看我们的*上下文*将是哪个宽度。
- en: The main container
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主容器
- en: 'Our context is going to be the main container of the page `.container_12`,
    which has a maximum width of 980px. However, there''s a catch involving the main
    container and the columns that will turn this 980px context into 960px. Notice
    the 10px left-right padding on the `.container_12` section and the 10px left-right
    margin in the `.grid` rules:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的上下文将是页面的主容器`.container_12`，最大宽度为980像素。然而，主容器和列之间存在一个问题，将这个980像素的上下文变成960像素。请注意`.container_12`部分的左右10像素填充和`.grid`规则中的左右10像素边距：
- en: '[PRE32]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The 10px left-right margin in the `.grid` rule means that the widths of all
    the columns have an additional 20px. So, for example, the header and footer that
    are 940px wide are really 960px wide. The `box-sizing: border-box;` property only
    accounts for subtracting what''s inside the box model (padding), not what''s outside
    (margin).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`.grid`规则中的10像素左右边距意味着所有列的宽度都增加了20像素。所以，例如，宽度为940像素的标题和页脚实际上是960像素宽。`box-sizing:
    border-box;`属性只考虑减去盒模型内部的内容（填充），而不考虑外部的内容（边距）。'
- en: One solution would be to remove the 10px left-right padding on `.container_12`
    and increase the left-right margin in the `.grid` rule to 20px in order to keep
    the gutters; otherwise, the columns would touch.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是去掉`.container_12`的左右10像素填充，并在`.grid`规则中增加左右边距为20像素，以保持间距；否则，列会相互接触。
- en: Now, the gutters become wider and this may not be intended for design purposes,
    and—believe it or not—somehow an extra 1px is added to the widest containers.
    In our case, it is added to the header and footer.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，间距变得更宽，这可能不是出于设计目的，而且——信不信由你——在最宽的容器中会多出1像素。在我们的情况下，它会添加到标题和页脚中。
- en: As a designer, I know I do not want to deal with any of those issues if I don't
    have to.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计师，我知道如果不得不处理这些问题，我是不想要的。
- en: 'The second solution is simpler: make the context 960px. This way, we can remove
    the 10 extra pixels globally without affecting the integrity of the main container
    and the columns, and the resulting values are almost the same since we''re getting
    percentages.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案更简单：将上下文设为960像素。这样，我们可以全局去掉多余的10像素，而不会影响主容器和列的完整性，由于我们得到的是百分比，所以结果几乎相同。
- en: 'In other words: *(960px ÷ 980px) x 100 = 97.95918367346939% (97.95%)*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：*(960像素 ÷ 980像素) x 100 = 97.95918367346939% (97.95%)*
- en: 'It''s practically the same as: *(940px ÷ 960px) x 100 = 97.91666666666667%
    (97.91%)*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上等同于：*(940像素 ÷ 960像素) x 100 = 97.91666666666667% (97.91%)*
- en: In the second solution, the 1px issue does happen, but happens at random widths
    when resizing the browser. However, the 1px issue is permanent with the first
    solution, regardless of the browser's width.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种解决方案中，1像素的问题确实会发生，但是在调整浏览器宽度时会在随机宽度时发生。然而，在第一种解决方案中，1像素的问题是永久性的，无论浏览器的宽度如何。
- en: With this part clear, we are then going to turn all pixel-based widths into
    percentages using 960px as their context.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚这一点后，我们将把所有基于像素的宽度转换为使用960像素作为上下文的百分比。
- en: The Header and Footer sections
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题和页脚部分
- en: 'Both the **Header** and **Footer** sections have the same width, 940px. Knowing
    that their context is 960px, let''s go ahead and find their widths in percentages
    using the magic formula: *(940px ÷ 960px) x 100 = 97.91666666666667%*.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**Header**和**Footer**部分的宽度都是940px。知道它们的上下文是960px，让我们继续使用魔术公式找到它们的百分比宽度：*(940px
    ÷ 960px) x 100 = 97.91666666666667%*。'
- en: You might be asking yourselves, "are that many decimals necessary?" Not all
    of them, but at least two are recommended.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，“这么多小数点有必要吗？”不是所有的小数点，但至少建议使用两位。
- en: So we end up with the **Header** and **Footer** sections of 97.91 percent.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们最终得到**Header**和**Footer**部分为97.91%。
- en: Some developers recommend using all the decimals and letting the browser decide
    how many it wants to use. In the past, I decided to challenge this recommendation
    and use only two decimals to see what happened. Since I started using two decimals,
    I haven't experienced any unwanted behavior or width issues whatsoever in any
    browser.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员建议使用所有小数，并让浏览器决定要使用多少。过去，我决定挑战这个建议，只使用两位小数来看看会发生什么。自从我开始使用两位小数以来，在任何浏览器中都没有遇到任何不良行为或宽度问题。
- en: Firefox and IE11 trim the excess decimals to two. Chrome, on the other hand,
    leaves all the decimals. I recommend using no less than two decimals, which is
    what we're going to use in the book to keep things simple and short. However,
    if you prefer to use all the decimals, by all means, go for it! At this point,
    it is a matter of personal preference.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox和IE11会将多余的小数点截断为两位。另一方面，Chrome会保留所有小数点。我建议至少使用两位小数，这也是我们在书中使用的方式，以保持简单和简洁。但是，如果您更喜欢使用所有小数点，那就尽管去做！这在这一点上是个人偏好的问题。
- en: Tip
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Avoid rounding up the values, and let the browsers deal with the decimals as
    they are. Doing this also keeps you focused on what matters most: being efficient
    and trying to create something memorable for the users.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 避免四舍五入值，并让浏览器处理小数点。这样做也可以让您专注于最重要的事情：高效并尝试为用户创造令人难忘的体验。
- en: The Nav section
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nav部分
- en: 'To find the width of the **Nav** section in percentages, we use 960px as its
    context as well: *(220px ÷ 960px) x 100 = 22.91666666666667%*.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到**Nav**部分的百分比宽度，我们同样使用960px作为上下文：*(220px ÷ 960px) x 100 = 22.91666666666667%*。
- en: Using two decimals, we end up with a **Nav** section of 22.91 percent.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两位小数，我们最终得到**Nav**部分为22.91%。
- en: The Content section
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Content部分
- en: 'To find out the width of the **Content** section in percentages, our formula
    looks almost identical. The only difference is that we are changing the first
    value which corresponds to the width of the **Content** section in pixels: *(700px
    ÷ 960px) x 100 = 72.91666666666667%*.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出**Content**部分的百分比宽度，我们的公式看起来几乎一样。唯一的区别是我们正在改变第一个值，即**Content**部分的宽度（以像素为单位）：*(700px
    ÷ 960px) x 100 = 72.91666666666667%*。
- en: Using only two decimals, our final value is a **Content** section of 72.91 percent.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用两位小数，我们最终得到**Content**部分为72.91%。
- en: 'This is what our initial retrofitting RWD SCSS file starts to look like:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们初始的改装RWD SCSS文件的样子：
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, let's take a step back and address a few other pixel-based widths before
    we continue. Remember the 10px padding to the left and the right of the main container
    `.container_12`? We need to turn those 10px into percentages as well.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们退一步，先处理一些其他基于像素的宽度。还记得主容器`.container_12`左右各有10px的填充吗？我们也需要将这10px转换为百分比。
- en: 'With our magic formula, we do it like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的魔术公式，我们这样做：
- en: '*(10px ÷ 960px) x 100 = 1.041666666666667%*.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*(10px ÷ 960px) x 100 = 1.041666666666667%*。'
- en: Using only two decimals, our final value is a left and right padding of 1.04
    percent.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用两位小数，我们最终得到左右填充为1.04%。
- en: 'Let''s add this value to our SCSS:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个值添加到我们的SCSS中：
- en: '[PRE34]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, all our columns have a 10px margin to the left and right. Since we already
    know that 10px is 1.04 percent, let''s add this value to all our columns in our
    SCSS:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们所有的列左右各有10px的边距。由于我们已经知道10px等于1.04%，让我们将这个值添加到我们SCSS中的所有列中：
- en: '[PRE35]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we have a browser window 1024px wide, a layout 980px wide, and all the
    columns at their corresponding percentage values. In reality, this is practically
    impossible without looking at the code to visually tell the differences between
    the fixed width and the percentage-based layouts.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个宽度为1024px的浏览器窗口，一个宽度为980px的布局，以及所有列都具有相应的百分比值。实际上，这几乎是不可能的，除非查看代码以在固定宽度和基于百分比的布局之间进行视觉区分。
- en: We're doing good here!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做得很好！
- en: '![The Content section](img/B02102_03_01.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![Content部分](img/B02102_03_01.jpg)'
- en: Let the fun begin. Let's add our first media query.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让乐趣开始吧。让我们添加我们的第一个媒体查询。
- en: 980px to 768px (RWD)
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 980px到768px（RWD）
- en: 'The following media query is aimed at 768px:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下媒体查询针对768px：
- en: '[PRE36]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since the widths of the **Header**, **Footer**, **Nav**, and **Content** sections,
    their paddings, and their margins are set in percentages now, we don't have to
    declare any media queries for them—at least not yet because the layout hasn't
    changed.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**Header**、**Footer**、**Nav**和**Content**部分的宽度、填充和边距现在都以百分比设置，我们不必为它们声明任何媒体查询——至少目前还不需要，因为布局还没有改变。
- en: 'When we resize our browser window, the **Header**, **Footer**, **Nav**, and
    **Content** sections automatically respond, shrink proportionally, snap properly,
    and fit the new width of the main container `.container_12` without breaking the
    layout. This is shown in the following screenshot:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调整浏览器窗口大小时，**Header**、**Footer**、**Nav**和**Content**部分会自动响应，按比例缩小，正确对齐，并适应主容器`.container_12`的新宽度，而不会破坏布局。如下截图所示：
- en: '![980px to 768px (RWD)](img/B02102_03_02.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![980px到768px（RWD）](img/B02102_03_02.jpg)'
- en: This is awesome!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: Let's add another breakpoint.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个断点。
- en: 768px to 640px (RWD)
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 768px到640px（RWD）
- en: In the following breakpoint (640px), our layout is going to change to a single
    column. So we are going to add a new media query that will make the **Nav** and
    **Content** sections as wide as the **Header** and **Footer** sections, and make
    them stack on top of each other.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下断点（640px）中，我们的布局将变为单列。因此，我们将添加一个新的媒体查询，使**Nav**和**Content**部分与**Header**和**Footer**部分一样宽，并使它们堆叠在一起。
- en: 'The following media query is aimed at 640px and makes the **Nav** and **Content**
    sections full width:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下媒体查询针对640px，并使**Nav**和**Content**部分全宽：
- en: '[PRE37]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Ok, we now have a single-column layout. Not bad, not bad!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有了单列布局。还不错，还不错！
- en: '![768px to 640px (RWD)](img/B02102_03_03.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![768px到640px（RWD）](img/B02102_03_03.jpg)'
- en: 640px to 480px (RWD)
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 640px到480px（RWD）
- en: We are now going as small as 480px and the one-column layout won't change, only
    the widths of all the containers will change.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的宽度已经缩小到480px，单列布局不会改变，只有所有容器的宽度会改变。
- en: 'The following media query is aimed at 480px:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下媒体查询针对480px：
- en: '[PRE38]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our layout is getting narrower and all we needed to do was add a new media query
    and that was it! No need to mess around with the other containers; they all adapt
    perfectly to any width we define.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的布局变窄了，我们需要做的就是添加一个新的媒体查询，就这样！不需要在其他容器上瞎折腾；它们都完美地适应了我们定义的任何宽度。
- en: '![640px to 480px (RWD)](img/B02102_03_04.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![640px到480px（RWD）](img/B02102_03_04.jpg)'
- en: 480px to 320px (RWD)
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 480px到320px（RWD）
- en: Finally, we address the 320px width without modifying the one-column layout.
    We remove the padding on `.container_12` to make use of all the available screen
    real estate.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解决了320px的宽度，而不修改单列布局。我们去掉了`.container_12`上的填充，以利用所有可用的屏幕空间。
- en: 'The following media query is aimed at 320px:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下媒体查询针对320px：
- en: '[PRE39]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once more, we do not have to add anything to the **Header**, **Footer**, **Nav**,
    and **Content** sections, since all of them are now 97.91 percent wide. This makes
    them responsive and we don't have to worry about anything else.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们不必添加任何内容到**Header**、**Footer**、**Nav**和**Content**部分，因为它们现在都是97.91%宽。这使它们具有响应性，我们不必担心其他任何事情。
- en: '![480px to 320px (RWD)](img/B02102_03_05.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![480px到320px（RWD）](img/B02102_03_05.jpg)'
- en: 'The final SCSS, combining all breakpoints and widths, is as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的SCSS，结合所有断点和宽度，如下所示：
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It compiles to the following CSS:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 它编译成以下CSS：
- en: '[PRE41]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, it's a lot less code using RWD than AWD to retrofit a site.
    Granted, these examples are an extreme simplification of a site/app layout, but
    now you are aware of the basic concepts of each technique when the time to make
    the call of using AWD or RWD knocks on your door.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用RWD比AWD来改造站点的代码要少得多。当然，这些例子是对站点/应用布局的极端简化，但现在你已经了解了在使用AWD或RWD时做出决定的基本概念。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We discussed a lot of interesting stuff in this chapter, for sure. We saw how
    using desktop-first to create our designs and wireframes is beneficial because
    having a large canvas allows us to explore different layouts and properly arrange
    the hierarchy of the content.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了很多有趣的内容。我们看到，使用桌面优先来创建设计和线框图是有益的，因为拥有一个大画布可以让我们探索不同的布局，并正确安排内容的层次结构。
- en: When creating HTML mockups, using mobile-first is better because a mobile-friendly
    site will have more reach, allow focused content, and leverage mobile devices'
    technologies.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建HTML模型时，使用移动优先更好，因为移动友好的站点将具有更广泛的覆盖范围，允许专注的内容，并利用移动设备的技术。
- en: We were able to retrofit with AWD and RWD a fixed-width site using the magic
    formula. We also discussed the benefits of RWD, since it required a lot less code.
    However, the analysis of the travel sites clearly shows us that RWD sometimes
    isn't the right solution.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用魔术公式对固定宽度的站点进行AWD和RWD的改造。我们还讨论了RWD的好处，因为它需要的代码要少得多。然而，对旅行网站的分析清楚地告诉我们，RWD有时并不是正确的解决方案。
- en: We also saw how `Respond.js` can be used to make legacy browsers support media
    queries if we are building with a mobile-first approach. Using conditional classes
    is a good technique because it's not intrusive, it's very easy to implement, and
    it has no JavaScript dependencies.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了`Respond.js`如何用于使旧版浏览器支持媒体查询，如果我们采用移动优先的方法构建。使用条件类是一种很好的技术，因为它不会侵入，很容易实现，并且没有JavaScript依赖。
- en: 'In the next chapter, we''re going to talk about some of the most interesting
    subjects in the world of RWD: CSS grids, CSS frameworks, and the power of Flexbox.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一章中，我们将讨论RWD世界中一些最有趣的主题：CSS网格、CSS框架和Flexbox的强大。 '
- en: Let's do this!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
