- en: Using SVG in HTML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTML中使用SVG
- en: 'So far in this book, you''ve been exposed to the fundamental building blocks
    of SVG: the features and functionality that are defined in the SVG specification
    itself. While SVG can, and does, live on its own, it really shines when it''s
    unleashed on the modern web. The web now is a multiple-device, multiple form-factor,
    and multiple connection speed environment, and SVG helps to solve many thorny
    problems facing the modern web developer. To that end, the next few chapters will
    focus on integrating SVG with other core technologies: HTML, CSS, and JavaScript.
    This chapter is very much straightforward and focuses on working with SVG inside
    the context of an HTML document. Everything on the web starts with HTML, so making
    sure your SVG is happy inside your HTML is the way to go.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，您已经接触到了SVG的基本构建块：在SVG规范中定义的功能和功能。虽然SVG可以独立存在，但当它在现代网络上得到应用时，它真正发挥作用。现在的网络是多设备、多形态和多连接速度的环境，SVG有助于解决现代网络开发人员面临的许多棘手问题。因此，接下来的几章将重点介绍SVG与其他核心技术的集成：HTML、CSS和JavaScript。本章非常直接，重点是在HTML文档的上下文中使用SVG。网络上的一切都始于HTML，因此确保您的SVG在HTML中正常运行是正确的方法。
- en: You have already learned about the basics of inserting SVG into your HTML documents
    as images or inline SVG elements in [Chapter 1](https://cdp.packtpub.com/mastering_svg/wp-admin/post.php?post=29&action=edit),
    *Introducing Scalable Vector Graphics*. This chapter adds some details on top
    of that foundation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了如何将SVG插入HTML文档中作为图像或内联SVG元素的基础知识，可以在[第1章](https://cdp.packtpub.com/mastering_svg/wp-admin/post.php?post=29&action=edit)
    *介绍可伸缩矢量图形*中找到。本章将在此基础上添加一些细节。
- en: 'In this chapter, you''ll learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: SVG and accessibility
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG和可访问性
- en: The benefits of using SVG images for responsive web design and as part of a
    responsive images solution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SVG图像进行响应式网页设计以及作为响应式图像解决方案的好处
- en: Details about working with inline SVG in the context of an HTML document
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML文档的上下文中使用内联SVG的工作细节
- en: So, let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: SVG, HTML, and accessibility
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG、HTML和可访问性
- en: Accessibility on the web strives to ensure that people with disabilities can
    access sites and applications. The general goal is to provide content that is
    served and structured in such a way that users with disabilities can access it
    directly or, if direct access isn't possible because of their disability (for
    example, audio content is needed for a hearing-impaired user), to provide properly
    structured alternative content that conveys the same information. This structured
    alternative content can then be accessed through **Assistive Technology** (**AT**).
    The most common example of AT is the *screen reader. *
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网络可访问性旨在确保残障人士可以访问网站和应用程序。总体目标是提供以这样一种方式提供内容，以便残障用户可以直接访问，或者如果由于其残障（例如，听障用户需要音频内容），无法直接访问，则提供结构良好的替代内容，以传达相同的信息。然后，可以通过**辅助技术**（**AT**）访问这些结构良好的替代内容。辅助技术的最常见示例是*屏幕阅读器*。
- en: 'Screen readers exist for all platforms. Some free applications you can test
    with include the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有平台都有屏幕阅读器。您可以使用一些免费应用程序进行测试，包括以下内容：
- en: NVDA (Windows)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVDA（Windows）
- en: Apple VoiceOver (OS X)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple VoiceOver（OS X）
- en: Orca (Linux)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Orca（Linux）
- en: In the case of SVG, a visual format, the focus is on providing, *when it's appropriate*,
    textual content that describes the image.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SVG这种视觉格式，重点是在适当的情况下提供描述图像的文本内容。
- en: As you're hopefully aware, HTML itself has tools and best practices for accessibility.
    In addition to those in HTML, there is also a set of technologies called **Accessible
    Rich Internet Applications** (**ARIA)**, which defines ways to make the web and
    web applications more accessible to people with disabilities. ARIA provides a
    set of special accessibility attributes that, when added to HTML, provide accessibility
    information about the page or application. For example, the `role` attribute defines
    the *type* of object the element is (article, menu, or image).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能知道的那样，HTML本身具有辅助功能的工具和最佳实践。除了HTML中的工具外，还有一组名为**可访问丰富互联网应用**（**ARIA**）的技术，它定义了使网络和网络应用对残障人士更具可访问性的方法。
    ARIA提供了一组特殊的辅助功能属性，当添加到HTML中时，可以提供有关页面或应用程序的辅助功能信息。例如，`role`属性定义了元素的*类型*（文章、菜单或图像）。
- en: 'As you saw in [Chapter 1](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml), *Introducing
    Scalable Vector Graphics*, there are two common ways to get your SVG into your
    HTML document: as the `src` of an image and as an inline SVG element (or elements).
    This section will add some notes about working with SVG, HTML, and ARIA attributes
    to ensure that your content is still accessible using both techniques.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml) *介绍可伸缩矢量图形*中看到的，将SVG插入HTML文档的两种常见方法是作为图像的`src`和作为内联SVG元素（或元素）。本节将添加一些关于使用SVG、HTML和ARIA属性的注意事项，以确保您的内容在使用这两种技术时仍然具有可访问性。
- en: SVG as an image src
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG作为图像的src
- en: The easiest way to get SVG into a document is as the `src` of an `img` element.
    Doing so, as we saw in [Chapter 1](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml), *Introducing
    Scalable Vector Graphics*, is as simple as referencing the `*.svg` element the
    same way you would reference any image as the `src` attribute on an `img` element.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将SVG放入文档的最简单方法是作为`img`元素的`src`。正如您在[第1章](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml)
    *介绍可伸缩矢量图形*中看到的那样，这样做就像引用`*.svg`元素一样简单，就像在`img`元素的`src`属性上引用任何图像一样。
- en: As for accessibility, if you follow best practices with regards to accessibility
    and images, you can continue to do the same with SVG images. The `alt` attribute
    should be there and, if it's needed for AT, it should properly describe the content
    ([https://webaim.org/techniques/alttext/](https://webaim.org/techniques/alttext/)).
    You might wonder why you would have to do this, especially with an SVG image that
    already has descriptive text as part of its source. Note that any textual content
    in the SVG file is, in effect, locked away from a screen reader, so even if you're
    using SVG, a descriptive, markup-based image format, it behaves, in this case
    at least, just like a common bitmapped file format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 至于可访问性，如果您遵循有关可访问性和图像的最佳实践，您可以继续对SVG图像执行相同的操作。alt属性应该存在，并且如果辅助技术需要，它应该正确描述内容。您可能会想知道为什么您需要这样做，尤其是对于已经在其源中具有描述性文本的SVG图像。请注意，SVG文件中的任何文本内容实际上被屏幕阅读器锁定，因此即使您使用SVG，作为一种具有描述性的基于标记的图像格式，它在这种情况下至少表现得就像一个常见的位图文件格式。
- en: 'Other than the alternative text, there''s just one wrinkle with older versions
    of Safari (older than Safari Desktop 9.1.1 or version 9.3.2 on iOS) that you should
    take into account. In those older versions, the `alt` text won''t be being read
    by VoiceOver, the Apple screen reader, unless the `role="img"` ARIA role was set
    on the `img` element:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了替代文本之外，旧版Safari（早于Safari桌面9.1.1版或iOS上的9.3.2版）有一个小问题需要考虑。在这些旧版本中，除非在img元素上设置了role="img"
    ARIA角色，否则VoiceOver，苹果屏幕阅读器，将不会读取alt文本：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inline SVG
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联SVG
- en: Inline SVG offers a broader palette for accessibility. For example, unlike the
    SVG as an `img src` scenario, that we just discussed, if there are one or more `<text>` elements
    in your SVG, then that text is available to be read directly by a screen reader.
    If the text is properly descriptive of the image, then you have already provided
    an accessible image. You don't need to do anything else.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内联SVG为可访问性提供了更广泛的选择。例如，与我们刚讨论的SVG作为img src的情况不同，如果SVG中有一个或多个text元素，则该文本可以直接被屏幕阅读器读取。如果文本对图像有适当的描述，那么您已经提供了一个可访问的图像。您无需做其他任何事情。
- en: 'If the text in your SVG is not descriptive of the image or if your image has
    no text, then you can take advantage of two SVG elements, `title`, and `desc`,
    to provide accessible text. These elements, coupled with the `aria-labelledby` attribute,
    provide a two-leveled approach to accessibility. The following code example shows
    the basics of how this works. The image itself is an illustration of an apple.
    Rendered in a browser, it looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SVG中的文本对图像没有描述性，或者图像没有文本，那么您可以利用两个SVG元素，即title和desc，提供可访问的文本。这些元素与aria-labelledby属性结合使用，提供了一种两级的可访问性方法。以下代码示例显示了这种工作方式的基本原理。图像本身是一个苹果的插图。在浏览器中呈现时，看起来像这样：
- en: '![](img/02823222-c153-42e5-9c00-010ab9b4b9d3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02823222-c153-42e5-9c00-010ab9b4b9d3.png)'
- en: The markup is as follows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 标记如下。
- en: The SVG element itself has two important attributes. It has a `role` of `img`,
    which indicates that the element is identified as a graphic. It also leverages
    the `aria-labelledby` attribute, which references two separate IDs, `"apple-title"`
    and `"apple-desc"`. The `aria-labelledby` attribute creates a relationship between
    the element it's a property of and other elements that label it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SVG元素本身有两个重要的属性。它具有一个role为img的属性，表示该元素被标识为图形。它还利用了aria-labelledby属性，该属性引用了两个单独的ID，即"apple-title"和"apple-desc"。aria-labelledby属性在元素本身和其他标签它的元素之间创建了一个关系。
- en: We meet the first of those two elements as the first child of the  SVG element,
    the `title` element.  The `title` element is available for SVG elements to provide
    a textual description of the element. It is not rendered directly by the browser,
    but should be read by a screen reader and can be rendered in a tooltip, much like
    how text in an `alt` attribute shows up in some browsers. It has an `id` of `"apple-title"`.
    Following that is the optional `desc` element. `desc` allows you to provide a
    longer text description of the image. It has an `id` of `"apple-desc"`. It too
    can be read by a screen reader and doesn't get rendered directly into the browser.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遇到这两个元素中的第一个元素，即SVG元素的第一个子元素，即title元素。title元素可用于为SVG元素提供元素的文本描述。它不会直接由浏览器呈现，但应该由屏幕阅读器读取，并且可以呈现为工具提示，就像alt属性中的文本在某些浏览器中显示的方式一样。它的id是"apple-title"。接下来是可选的desc元素。desc允许您提供图像的更长文本描述。它的id是"apple-desc"。它也可以被屏幕阅读器读取，并且不会直接呈现在浏览器中。
- en: 'The final piece of interesting markup is `role="presentation"`, which is applied
    to each of the child `path` elements. Doing that pulls those elements out of the
    accessibility tree ([https://www.w3.org/TR/svg-aam-1.0/#exclude_elements](https://www.w3.org/TR/svg-aam-1.0/#exclude_elements))
    so, from an accessibility perspective, the SVG element is treated as one graphic:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的标记的最后一部分是role="presentation"，它应用于每个子path元素。这样做可以将这些元素从可访问性树中排除出去，因此从可访问性的角度来看，SVG元素被视为一个图形：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This section describes accessibility with static SVG images. There are additional
    accessibility techniques possible with dynamic SVG, including other ARIA attributes,
    such as ARIA-live regions ([https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)).
    Where applicable, you'll learn about those in the following chapters. That said,
    getting the basics right for static SVG is a great start and learning to test
    your SVG with a screen reader will put you on the right path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了静态SVG图像的可访问性。动态SVG还有其他可行的可访问性技术，包括其他ARIA属性，例如ARIA-live区域。在适用的情况下，您将在以下章节中了解这些内容。也就是说，正确掌握静态SVG的基础知识是一个很好的开始，学会使用屏幕阅读器测试SVG将使您走上正确的道路。
- en: SVG and responsive web design
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG和响应式网页设计
- en: '**Responsive web design** (**RWD**) is a technique for developing sites and
    applications that leverage  fluid layout grids and CSS3 media queries ([https://www.w3.org/TR/css3-mediaqueries/](https://www.w3.org/TR/css3-mediaqueries/))
    to create layouts that can adapt and respond to the characteristics of the device
    or user agent, stretching and shrinking to present layouts that work on a variety
    of screen sizes without prior knowledge of the device characteristics.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式网页设计**（**RWD**）是一种开发网站和应用程序的技术，利用流体布局网格和CSS3媒体查询（[https://www.w3.org/TR/css3-mediaqueries/](https://www.w3.org/TR/css3-mediaqueries/)）来创建可以适应和响应设备或用户代理特征的布局，从而可以伸缩以呈现适用于各种屏幕尺寸的布局，而无需事先了解设备特征。'
- en: When RWD started to take off, one of the issues that quickly bubbled up to the
    surface as a pain point was the difficulty of serving correctly sized images (for
    both file weight and dimensions), depending on any of the multitudes of variables
    that would impact the end user's experience. Screen resolution, pixel depth, and
    available bandwidth all combine to make the question of what size image to serve
    to a user a complex one.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当RWD开始流行起来时，一个迅速浮出水面的问题是难以根据影响最终用户体验的多种变量之一（屏幕分辨率、像素深度和可用带宽）来提供正确大小的图像（文件大小和尺寸）。用户体验。屏幕分辨率、像素深度和可用带宽都结合在一起，使得为用户提供何种大小的图像成为一个复杂的问题。
- en: What followed was a years-long quest for a markup pattern that would create
    responsive content images. *Content images* are images served with an `img` tag
    that are meant to be presented as content. This is compared to images used solely
    for design, which can and should already be handled with CSS. With media queries
    strongly supported, CSS already provides a number of tools to present the correct
    image depending on a number of factors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是多年的追求标记模式，以创建响应式内容图像。*内容图像*是使用`img`标签提供的图像，旨在作为内容呈现。这与仅用于设计的图像相比，后者可以并且应该已经用CSS处理。由于媒体查询得到了强有力的支持，CSS已经提供了许多工具，可以根据多种因素呈现正确的图像。
- en: 'Some of the requirements for responsive images were as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式图像的一些要求如下：
- en: '**Smallest possible file size**: This is really the core issue. It just manifests
    itself in many ways. In a perfect world, we would only ever send the smallest
    possible number of bytes needed to render the image at an acceptable quality level.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽可能使用最小的文件大小**：这实际上是核心问题。它以许多方式表现出来。在理想的世界中，我们只会发送渲染图像所需的最小字节数，以达到可接受的质量水平。'
- en: '**Take advantage of the browser preloader**: All modern web browsers use a
    technique where the browser skips ahead, while simultaneously reading through
    the document and building out the DOM, and reads through the document, looking
    for additional assets that it can go ahead and start to download.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用浏览器预加载程序**：所有现代Web浏览器都使用一种技术，其中浏览器会跳过，同时阅读文档并构建DOM，并阅读文档，寻找可以开始下载的其他资产。'
- en: '**Serve correctly sized images to multiple resolutions**: If you''re serving
    a big image to a `2048` pixel monitor, then you want it to be a big image of `1600`
    pixels or more. A big image on a tablet or phone, on the other hand, might only
    need to be `320` or `480` pixels wide. Sending the correct amount of data, in
    this case, can significantly improve performance.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为多个分辨率提供正确大小的图像：如果您要为`2048`像素的显示器提供大图像，则希望它是`1600`像素或更大的大图像。另一方面，平板电脑或手机上的大图像可能只需要`320`或`480`像素宽。在这种情况下发送正确数量的数据可以显著提高性能。
- en: '**Serve the correct image for multiple pixel-ratio devices**: To produce clean
    images on devices with a high device pixel ratio, you need to send down proportionally
    larger files that are displayed for a given set of CSS pixels. Images that are
    crisp on a standard desktop display would show artifacts on a high pixel density
    display. Obviously, you can just send higher resolution images to all browsers,
    but those pixels come at a bandwidth price, so it''s much better to just send
    the correct images to the correct devices.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为多个像素比设备提供正确的图像**：为了在具有高设备像素比的设备上产生清晰的图像，您需要发送比例更大的文件，这些文件将显示给定CSS像素的图像。在标准桌面显示器上清晰的图像会在高像素密度显示器上显示出瑕疵。显然，您可以向所有浏览器发送更高分辨率的图像，但这些像素需要带宽，因此最好只向正确的设备发送正确的图像。'
- en: '**Choose different sizes of images or entirely different images at different
    breakpoints**: There is a desire to be able to show different images for different
    orientations and screen resolutions. On a large screen, in an article describing
    flora in Tuscon, Arizona, you might use a wide image that shows a variety of the
    hardy plant life you can find there. On a small screen in portrait orientation,
    where the impact of the variety would be lost as it would display only an inch
    high with little detail, an image of a Saguaro cactus with a strongly vertical
    aspect ratio might be a better choice.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择不同尺寸的图像或完全不同的图像在不同的断点**：希望能够在不同的方向和屏幕分辨率下显示不同的图像。在大屏幕上，描述亚利桑那州图森的植物的文章中，您可能会使用一个宽图像，显示那里可以找到的各种耐旱植物。在纵向的小屏幕上，由于只显示一英寸高且细节很少，多样性的影响会消失，具有明显垂直宽高比的仙人掌图像可能是更好的选择。'
- en: '**Use design breakpoints**: There has been plenty of development based around
    the concept of media query breakpoints. They''re one of the primary technologies
    at the heart of RWD. Images need to be controlled alongside all the other design
    changes that occur in a responsive site.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用设计断点**：围绕媒体查询断点的概念进行了大量开发。它们是RWD核心技术之一。图像需要与响应式网站中发生的所有其他设计更改一起进行控制。'
- en: The multiple solutions (the `picture` element and the `srcset` and `sizes` attributes)
    that came out of that quest are incredibly powerful. It took a while (a couple
    of years and lots of internet angst) but eventually, everything we needed to serve
    the *correct *image with the *correct* file size and the *correct *dimensions
    was available for us in browsers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那次探索得出的多种解决方案（`picture`元素和`srcset`和`sizes`属性）非常强大。花了一些时间（几年时间和大量的互联网烦恼），但最终，我们在浏览器中获得了为我们提供*正确*图像、*正确*文件大小和*正确*尺寸的一切所需的东西。
- en: It's not *easy. *It's a complicated problem, as it has got a complicated solution.
    The coding is complicated and it is complicated to understand and it requires
    multiple versions generated of every image you want to present on the web.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这不容易。这是一个复杂的问题，因为它有一个复杂的解决方案。编码是复杂的，理解起来也很复杂，需要生成每个要在网页上呈现的图像的多个版本。
- en: Let's see how the new solutions work and then we'll see how SVG (where it's
    available to you because of image requirements) can make it a lot less complicated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看新的解决方案是如何工作的，然后我们将看看SVG（如果由于图像要求而可用）如何使它变得不那么复杂。
- en: The srcset attribute
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: srcset属性
- en: The `srcset` attribute is a new attribute added to the `img` element. You can
    use it alongside the new `picture` element, and we will do so in a little bit.
    For now, let's look at it by itself. Like I said, this stuff is complicated, so
    it's worth taking the time to build up slowly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`srcset`属性是添加到`img`元素的新属性。您可以将其与新的`picture`元素一起使用，我们稍后会这样做。现在，让我们单独看一下。就像我说的，这些东西很复杂，所以值得花时间慢慢建立。'
- en: Like the standard `src` attribute, the `srcset` attribute tells the browser
    where to get the file to use for the contents of the `img` element. Unlike the
    single image that is referenced by `src`, however, the `srcset` attribute presents
    a comma delineated list of URLs. The `srcset` attribute also provides *hints*
    regarding the image size or pixel density.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的`src`属性一样，`srcset`属性告诉浏览器从哪里获取要用于`img`元素内容的文件。但与`src`引用的单个图像不同，`srcset`属性呈现了一个逗号分隔的URL列表。`srcset`属性还提供了关于图像大小或像素密度的*提示*。
- en: Let's look at an example to understand how those hints work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来理解这些提示是如何工作的。
- en: The `srcset` attribute in the following sample hints about the device pixel
    ratio. In this case, there are two options. The first option is `more-colors-small.jpg`,
    which is `600*350` (600 by 350) pixels wide and is meant to display at a standard
    resolution. The second image, `more-colors-large.jpg`, is `1200*700` pixels and
    is meant for higher resolution displays. It will still display at `600*350` *CSS*
    pixels but it's got enough additional image information to look clean in higher
    pixel density displays as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`srcset`属性提示有关设备像素比。在这种情况下，有两个选项。第一个选项是`more-colors-small.jpg`，宽度为`600*350`（600乘以350）像素，用于显示标准分辨率。第二个图像`more-colors-large.jpg`，宽度为`1200*700`像素，用于更高分辨率的显示。它仍然以`600*350`
    *CSS*像素显示，但它有足够的额外图像信息，可以在更高像素密度的显示器上显示得更清晰。
- en: 'The `src` attribute acts as a fallback for browsers that don''t support `srcset`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`属性作为不支持`srcset`的浏览器的后备：'
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the solution for the device pixel ratio use case.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设备像素比用例的解决方案。
- en: With `src` as a fallback for every browser that supports images and an `alt`
    attribute for those that don't, this is a good, backward-compatible solution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个支持图像的浏览器，`src`作为后备，对于不支持图像的浏览器，`alt`属性作为后备，这是一个很好的向后兼容的解决方案。
- en: The srcset and sizes attributes
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: srcset和sizes属性
- en: To solve more complicated use cases, the `srcset` attribute can work in tandem
    with the new `sizes` attribute to use media queries to serve separate image sources,
    displayed with different relative dimensions based on the browser window. The
    code sample illustrates how this works.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决更复杂的用例，`srcset`属性可以与新的`sizes`属性一起使用，使用媒体查询来提供不同的图像源，根据浏览器窗口显示不同的相对尺寸。代码示例说明了这是如何工作的。
- en: In this example, the element starts with an `src` attribute for non-supporting
    browsers. In this case, I've chosen a smallish image to ensure that it loads speedily,
    no matter what device or browser. Following that there's the new `sizes` attribute.
    `sizes` accepts a media query/image size pair (or list of pairs).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，元素以`src`属性作为不支持图像的浏览器的后备。在这种情况下，我选择了一个较小的图像，以确保无论设备或浏览器如何，它都能快速加载。接下来是新的`sizes`属性。`sizes`接受媒体查询/图像大小对（或对列表）。
- en: 'The following diagram breaks down the components. The first part is the media
    query. This media query should be familiar if you''ve used them in your CSS. If
    the query is `true`, then the image size is set to **60vw** (60% of **viewport
    width** (**vw**)). If the media query fails, the size falls back to the default
    size of **100vw**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表分解了组件。第一部分是媒体查询。如果您在CSS中使用过媒体查询，这个媒体查询应该很熟悉。如果查询为`true`，则图像大小设置为**60vw**（**视口宽度**（**vw**）的60%）。如果媒体查询失败，则大小回退到**100vw**的默认大小：
- en: '![](img/bbd2c9a2-3f27-441e-b3a2-757b5ca15f83.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbd2c9a2-3f27-441e-b3a2-757b5ca15f83.png)'
- en: There can be any number of **media query/size pairs**. The first one to match
    wins and, if none match, then the fallback value is used.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有任意数量的**媒体查询/大小对**。第一个匹配的媒体查询获胜，如果没有匹配，则使用回退值。
- en: 'The `srcset` attribute here is more expansive. The list has a series of images
    between `200` pixels wide and `1600` pixels wide. The second part of the value
    pair in the source set, instead of indicating the preferred pixel density, hints
    to the browser the pixel width of the image (200w, 400w, and so on). It''s the
    up to browser to mix and match the best pixel width with the appropriate size
    at different dimensions and pixel densities:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`srcset`属性更加广泛。列表中有一系列宽度在`200`像素到`1600`像素之间的图像。源集中值对的第二部分，而不是指示首选像素密度，提示浏览器图像的像素宽度（200w，400w等）。浏览器可以根据不同的尺寸和像素密度混合和匹配最佳像素宽度与适当尺寸：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The length part of `size` can be specified in any valid CSS length, which adds
    to the possibilities and complexity of this attribute. This chapter will stick
    with `vw` measurements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`的长度部分可以用任何有效的CSS长度来指定，这增加了这个属性的可能性和复杂性。本章将坚持使用`vw`度量。'
- en: The picture element
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片元素
- en: 'In its original concept, `picture` was designed as a parallel `img` element,
    modeled on the syntax of the HTML5 `video` and `audio` elements. The idea was
    to have a `picture` element wrapping a series of `source` elements, which would
    represent the options for the image source. It would wrap a default `img` element
    for non-supporting browsers. A `media` attribute on each source would hint to
    the browser the correct source to use:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初的概念中，`picture`被设计为`img`元素的并行元素，模仿HTML5的`video`和`audio`元素的语法。其想法是有一个`picture`元素包裹一系列`source`元素，这些元素将代表图像源的选项。它会包裹一个默认的`img`元素，供不支持的浏览器使用。每个源上的`media`属性将提示浏览器使用正确的源：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For a variety of implementation-related reasons, this initial proposal was shot
    down. `srcset` filled in some of the void, but since it didn't solve all the responsive
    image use cases, there was always a hole in the specification landscape.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 出于各种实施相关的原因，这个最初的提案被否决了。`srcset`填补了一些空白，但由于它没有解决所有响应式图像使用案例，规范景观中总是有一个空白。
- en: Years passed and *eventually*, after many false starts, `picture` was resurrected
    and reworked to fill that hole.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 多年过去了，*最终*，经过多次失败的尝试，`picture`被重新设计和重塑，以填补那个空白。
- en: Now, however, instead of being a replacement for `img`, `picture` is now an
    *enhancement* to the `img` element to help browsers sort out the best possible
    solution for the source of an image.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在，`picture`不再是`img`的替代品，而是`img`元素的*增强*，以帮助浏览器找出图像源的最佳解决方案。
- en: 'Let''s take a look at an example. While the `srcset` examples worked with different
    resolution versions of the same image, this `picture` example aims to provide
    different images for different resolutions. Here, in larger browser windows, an
    image that is wider than it is tall will be shown:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。虽然`srcset`的例子使用了同一图像的不同分辨率版本，但这个`picture`的例子旨在为不同分辨率提供不同的图像。在较大的浏览器窗口中，将显示一个宽度大于高度的图像：
- en: '![](img/aaadf6a9-52c3-4e9d-b0d3-4942e8db8ae2.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaadf6a9-52c3-4e9d-b0d3-4942e8db8ae2.jpg)'
- en: 'In browser windows smaller than 1,024 pixels, a square image will be used:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在小于1,024像素的浏览器窗口中，将使用一个正方形图像：
- en: '![](img/e1bec99b-43f4-4fc2-a239-7e6ec7a760c9.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1bec99b-43f4-4fc2-a239-7e6ec7a760c9.jpg)'
- en: The markup for this is relatively complicated and needs some explaining.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标记相对复杂，需要一些解释。
- en: In the `head`, notice the presence of the `picturefill.min.js` file. Picturefill
    ([https://github.com/scottjehl/picturefill](https://github.com/scottjehl/picturefill))
    is a Polyfill ([https://remysharp.com/2010/10/08/what-is-a-polyfill](https://remysharp.com/2010/10/08/what-is-a-polyfill))
    for the `picture` element,  which supplies JavaScript driven picture element support
    to non-supporting browsers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`head`中，注意到`picturefill.min.js`文件的存在。Picturefill ([https://github.com/scottjehl/picturefill](https://github.com/scottjehl/picturefill))是`picture`元素的Polyfill
    ([https://remysharp.com/2010/10/08/what-is-a-polyfill](https://remysharp.com/2010/10/08/what-is-a-polyfill))，为不支持的浏览器提供了JavaScript驱动的图片元素支持。
- en: In the body of the HTML document, the `picture` element wraps the entire solution.
    It lets the browser know that it should use this `picture` element to sort out
    the proper source for the child `img` element. We don't get to the `img` element
    immediately, however. The first child element we encounter is the `source` element.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文档的主体中，`picture`元素包裹整个解决方案。它让浏览器知道它应该使用这个`picture`元素来为子`img`元素找到正确的源。然而，我们并不立即进入`img`元素。我们遇到的第一个子元素是`source`元素。
- en: From a developer perspective, `source` works the way the original proposal intended.
    If the media query matches, that `source` is used. If it doesn't match, you move
    onto the next media query in the stack.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，`source`的工作方式与最初的提案意图相同。如果媒体查询匹配，就使用该`source`。如果不匹配，则转到堆栈中的下一个媒体查询。
- en: 'Here, you have a media query looking for pages with a minimum width of `1024`
    pixels. If the media query matches, the `srcset` attribute is used to let the
    browser choose between three separate source images, ranging from `600` pixels
    to `1600` pixels wide. Since this image is intended to be displayed at `50vw`,
    that will give good coverage for the majority of displays. Following that, there''s
    the fallback `img` element that also contains a `srcset`. If the browser doesn''t
    support `picture` and `source` or if the previous media queries don''t match,
    you use `srcset` attribute here to get the source for this image. The `sizes`
    attribute allows you to further adjust the display for the range of sizes smaller
    than `1024` pixels:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您有一个媒体查询，寻找最小宽度为`1024`像素的页面。如果媒体查询匹配，`srcset`属性用于让浏览器在`600`像素到`1600`像素宽的三个不同源图像中进行选择。由于此图像旨在以`50vw`显示，这将为大多数显示器提供良好的覆盖范围。接下来是备用的`img`元素，它也包含一个`srcset`。如果浏览器不支持`picture`和`source`，或者前面的媒体查询不匹配，您可以在这里使用`srcset`属性来获取此图像的源。`sizes`属性允许您进一步调整小于`1024`像素的范围的显示：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While it''s complicated, this `picture` pattern solves the question of both
    different image sizes and different formats for separate art direction choices.
    Now that (lengthy) explanation is out of the way, let''s take a look at how SVG
    can solve some of those same problems with a lot less markup. You''ve already
    seen in [Chapter 1](https://cdp.packtpub.com/mastering_svg/wp-admin/post.php?post=29&action=edit),
    *Introducing Scalable Vector Graphics*, an example of an SVG image as the `src`
    of an `img` element scaling up and down at will. In fact, with SVG, responsive
    images are as simple as the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然复杂，这种`picture`模式解决了不同图像尺寸和不同格式的分离艺术指导选择的问题。既然（冗长的）解释已经结束，让我们看看SVG如何以更少的标记解决同样的问题。您已经在[第1章](https://cdp.packtpub.com/mastering_svg/wp-admin/post.php?post=29&action=edit)中看到了*介绍可缩放矢量图形*，SVG图像作为`img`元素的`src`进行缩放。实际上，使用SVG，响应式图像就像以下代码一样简单：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It allows you to infinitely scale up and down with no loss of fidelity or extra
    bytes and there's no `srcset` needed! There are ways to improve that simple solution
    with CSS, which we'll see in the next chapter, but for now, just know that this
    pattern will work. From a 3,000+ pixel behemoth monitor to a tiny feature phone
    (assuming it supports SVG), the preceding markup will scale nicely.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许您无限缩放，而不会丢失保真度或增加额外字节，也不需要`srcset`！有一些方法可以通过CSS改进这种简单的解决方案，我们将在下一章中看到，但现在，只需知道这种模式将起作用。从一个3000多像素的巨型显示器到一个小巧的功能手机（假设它支持SVG），前面的标记将很好地进行缩放。
- en: What about the art direction use case? That's also much simpler with SVG. Because
    we don't have to provide multiple versions of the image (every SVG image can scale
    as much as needed), the markup for the art direction use case is as follows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术指导用例怎么样？使用SVG也更简单。因为我们不必提供图像的多个版本（每个SVG图像都可以根据需要进行缩放），艺术指导用例的标记如下。
- en: We have the same `picture` element we saw before. There's one child `source`
    element that has a media query pointing to browsers larger than `1024` pixels.
    If that's `true`, then the landscape image will be used. Then, there's a child
    `img` element with a `srcset` pointing to a square image and `width` of 100%.
    If the media query on the first `source` element fails, we get to this image.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有与之前看到的相同的`picture`元素。有一个子`source`元素，其中包含一个指向大于`1024`像素的浏览器的媒体查询。如果为`true`，则将使用横向图像。然后，有一个子`img`元素，其中`srcset`指向一个正方形图像，`width`为100%。如果第一个`source`元素上的媒体查询失败，我们就会得到这个图像。
- en: 'It''s not as simple as a plain old `img` but it''s a lot simpler than the version
    with multiple bitmapped images in each `srcset`. Output two images and you''re
    ready to go with even the most complicated case, art direction, and scaling across
    multiple screen resolutions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它不像普通的`img`那样简单，但比每个`srcset`中的多个位图图像版本要简单得多。输出两个图像，即可处理最复杂的情况，艺术指导和跨多个屏幕分辨率的缩放：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While SVG isn't available for every use case, it's by far the most flexible
    image format for RWD. From the simple `width="100%"` technique for scaling images
    based on one image source to the simpler implementation of the art direction use
    case utilizing the `picture` element, SVG offers enormous benefits in these multiple
    resolutions, multiple device world.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SVG并非适用于每种用例，但它是远远最灵活的RWD图像格式。从基于一个图像源的简单`width="100%"`技术来缩放图像，到使用`picture`元素更简单地实现艺术指导用例，SVG在这个多分辨率、多设备的世界中提供了巨大的好处。
- en: Additional details on inline SVG in an HTML document
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML文档中内联SVG的附加细节
- en: As you've already learned, using inline SVG is just about as straightforward
    as HTML markup and is often going to be the best (or only, in the case of interactive
    SVG) option for you to embed SVG into your documents. That said, as with anything
    on the web, there are always some edge cases, notes, and gotchas that you need
    to keep in mind when working with inline SVG. This section outlines two such concerns.
    The first is about trying to leverage the browser's cache and the other is to
    be aware of the potentially large increase in DOM complexity when working with
    SVG.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经了解的那样，使用内联SVG与HTML标记一样简单，通常是您嵌入SVG到文档中的最佳（或唯一，在交互式SVG的情况下）选项。也就是说，与网络上的任何内容一样，当使用内联SVG时，总会有一些边缘情况、注意事项和需要牢记的要点。本节概述了其中两个问题。第一个是尝试利用浏览器的缓存，另一个是要注意在处理SVG时DOM复杂性可能会大幅增加。
- en: Caching
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Unlike an SVG image linked to as the `src` of an `img` element or referenced
    with CSS, inline SVG can't be cached and referenced on another page or different
    view of a single-page application. While there remains a performance benefit to
    minimizing the number of HTTP requests (which inline SVG does by dropping the
    need for a request to a separate SVG document), that's not always the most optimal
    pattern. If you're using the same SVG image multiple times across multiple pages,
    or multiple site visits, there's going to be a benefit in having a file that can
    be cached and read again later. This is especially true of larger, more complicated
    SVG images, which can have a large download footprint.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与作为`img`元素的`src`链接的SVG图像或通过CSS引用的SVG图像不同，内联SVG无法被缓存并在另一页或单页应用程序的不同视图中引用。虽然最小化HTTP请求的数量仍然有性能优势（内联SVG通过消除对单独SVG文档的请求来实现），但这并不总是最优化的模式。如果您在多个页面上多次使用相同的SVG图像，或者多次访问多个站点，那么拥有一个可以被缓存并稍后再次读取的文件将会有益处。这对于更大、更复杂的SVG图像尤其如此，它们可能具有较大的下载占用空间。
- en: If you really need to use inline SVG (all interactive examples, for example),
    you can still try to leverage the browser cache in different ways by linking to
    external library SVG elements using the `use` element. You might be adding some
    HTTP requests up front, but you won't have to continually download and parse the
    inline markup defining those reusable components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的需要使用内联SVG（例如所有交互式示例），您仍然可以尝试通过使用`use`元素链接到外部库SVG元素来以不同的方式利用浏览器缓存。您可能会在前期添加一些HTTP请求，但您不必不断下载和解析定义这些可重用组件的内联标记。
- en: And really, thinking about reusable components is a good way to think about
    structuring any aspect of your project so that's a benefit above and beyond leveraging
    the browser's cache.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，考虑可重用组件是思考项目结构的一种好方法，因此这是利用浏览器缓存之外的好处。
- en: Complexity
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂性
- en: While I've actually tried to limit the complexity of the SVG code samples you've
    seen so far in this book, you have already seen some very *busy *examples of SVG.
    In fact, when working with anything more complicated than a handful of `rect`, `circle`, or
    `text` elements, the size and/or readability of SVG code can go downhill very
    quickly.  This is especially true of generated code where it's not really meant
    for human consumption.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我实际上已经尝试限制您在本书中迄今为止看到的SVG代码示例的复杂性，但您已经看到了一些非常繁忙的SVG示例。实际上，当处理比一小部分“rect”、“circle”或“text”元素更复杂的任何内容时，SVG代码的大小和/或可读性可能会迅速下降。这在生成的代码中尤其如此，因为它实际上并不是为了人类消费而设计的。
- en: 'This complexity can be a problem in two separate ways: a more complicated authoring
    environment and a slowdown in the rendering and performance of your page.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂性可能会以两种不同的方式成为问题：创作环境更加复杂，页面的渲染和性能变慢。
- en: Authoring
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创作
- en: SVG documents can grow quite large, even for simple images. Depending on the
    number of effects and the number of elements, the markup used to draw an SVG image
    could quickly overwhelm everything else on the page. For that reason, it's worth
    keeping large SVG elements as separate document fragments and pulling them into
    your documents as needed. Depending on how they're being used, this might be with
    the `use` element inside a containing SVG document or might be a case of importing
    a document fragment using your page composition tool of choice. There are a large
    number of server-side and/or client-side solutions for bringing together pieces
    of markup and text together (for example, JavaScript template solutions, CMSs,
    blog platforms, and server-side scripting languages, such as PHP), so I'm not
    going to create an example of potentially limited use. I'll trust you'll leverage
    the one closest to your heart.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SVG文档可能会变得非常庞大，即使是简单的图像也是如此。根据效果的数量和元素的数量，用于绘制SVG图像的标记可能会迅速压倒页面上的其他所有内容。因此，值得将大型SVG元素保留为单独的文档片段，并根据需要将它们引入您的文档中。根据它们的使用方式，这可能是在包含SVG文档内部使用“use”元素，或者可能是使用您选择的页面组合工具导入文档片段的情况。有许多服务器端和/或客户端解决方案可以将标记和文本片段组合在一起（例如，JavaScript模板解决方案，CMS，博客平台和服务器端脚本语言，如PHP），因此我不打算创建一个潜在有限用途的示例。我相信您会利用最贴近您心的解决方案。
- en: You'd still have to deal with it when inspecting the page, but it's much nicer
    than having 500 lines of markup in a 700-line file being taken up by an SVG illustration
    showing a supply chain diagram or something similar.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然必须在检查页面时处理它，但这比在一个700行文件中占据500行标记的SVG插图要好得多，该插图显示了供应链图表或类似内容。
- en: The Document Object Model
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档对象模型
- en: In addition to problems with authoring, you can also run into browser performance
    problems with very complicated SVG. This is true whichever way you're importing
    them, since even SVG imported as an `img src` is more than just a collection of
    pixels, but this can become more acute if you're already doing a lot of interaction
    with the DOM. In general, the number of elements in your document directly affects
    the speed and responsiveness of the page ([https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing](https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing)).
    When you have many hundreds or many thousands of potentially interactive SVG elements
    on the page, each of which has to be calculated (some with very complicated calculations
    under the hood) and rendered by the browser, things can slow down very quickly
    indeed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创作问题，您还可能遇到非常复杂的SVG在浏览器性能方面的问题。这是真实的，无论您以何种方式导入它们，因为即使SVG作为“img src”导入，它也不仅仅是一组像素，但如果您已经在DOM中进行了大量交互，这种情况可能会更加严重。一般来说，文档中的元素数量直接影响页面的速度和响应性（https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing）。当页面上有成百上千个潜在的可交互SVG元素时，每个元素都需要由浏览器计算（其中一些在内部进行非常复杂的计算）并呈现，事情可能会非常快地变慢。
- en: Most of the time, you're not going to run into performance problems of this
    sort. At least I hope you are not. It *is* possible, however, so keep the possibility
    filed away and hopefully, you'll never have to use the knowledge.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您不太可能遇到这种性能问题。至少我希望您不会。然而，这是可能的，因此请将可能性存档，希望您永远不必使用这些知识。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about working with SVG in the context of an HTML
    document.  First, you learned about SVG accessibility with both inline SVG elements
    and SVG images as the `src` of an `img` element. This includes details on the
    `alt` attribute for `img` elements and details of the `title` and `desc` elements
    in inline SVG.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了在HTML文档环境中使用SVG。首先，您了解了使用内联SVG元素和SVG图像作为“img”元素的“src”时的SVG可访问性。这包括“img”元素的“alt”属性的详细信息，以及内联SVG中“title”和“desc”元素的详细信息。
- en: Following that you learned about the solutions for responsive images and how
    using SVG can greatly simplify the implementation of even the most complicated
    responsive image use case. Finally, you learned some other aspects of inline SVG
    to pay attention to when implementing these solutions in the real world.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您了解了响应式图像的解决方案，以及如何使用SVG可以极大地简化甚至是最复杂的响应式图像使用情况的实现。最后，您了解了在实际世界中实施这些解决方案时需要注意的内联SVG的其他方面。
- en: Next up, we'll look at the important intersection of CSS and SVG. The next chapter
    will build on everything we've learned and will introduce some powerful new tools
    for you to add to your SVG toolbox.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下CSS和SVG的重要交集。下一章将建立在我们所学到的一切基础上，并将为您介绍一些强大的新工具，供您添加到SVG工具箱中。
