- en: Working with SVG and CSS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG和CSS
- en: This chapter will focus on the intersection between SVG and CSS. While JavaScript
    is the most powerful tool for working with SVG, SVG without CSS wouldn't be nearly
    as popular as it has become. SVG, as you've learned, is well-suited for the modern
    web and is often the best answer to an RWD question. Because of that, it's been
    wholeheartedly embraced by designers and developers for producing images for the
    web.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍SVG和CSS的交集。虽然JavaScript是处理SVG最强大的工具，但没有CSS的SVG不会像现在这样受欢迎。正如你已经了解的那样，SVG非常适合现代网络，通常是对RWD问题的最佳答案。因此，它已经被设计师和开发人员全力以赴地用于为网络生成图像。
- en: This preference for SVG is a good one for the web as a whole and should be cultivated.
    This chapter will hopefully illustrate why.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整个网络来说，这种对SVG的偏好是一个很好的选择，应该加以培养。本章将希望说明为什么。
- en: 'In this chapter, we''ll learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下内容：
- en: Using CSS background images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS背景图像
- en: How to optimize data URIs for SVG
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何优化SVG的数据URI
- en: SVG sprites versus icon fonts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG精灵与图标字体
- en: How the different ways of embedding SVG interact with CSS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的SVG嵌入方式如何与CSS互动
- en: Using common CSS properties to manipulate SVG
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常见的CSS属性来操作SVG
- en: Using SVG-specific CSS properties to manipulate SVG
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SVG特定的CSS属性来操作SVG
- en: Basic CSS animations and transitions with SVG
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SVG的基本CSS动画和过渡
- en: CSS background images
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS背景图像
- en: You've already seen examples of using CSS for background images all the way
    back in [Chapter 1](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml), *Introducing
    Scalable Vector Graphics*. This section will add some more details to using SVG
    in this way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[第1章](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml)中看到了使用CSS作为背景图像的例子，*介绍可伸缩矢量图形*。本节将为使用SVG的这种方式添加一些更多的细节。
- en: 'In this initial, basic example, we add an SVG image of a stylized letter R
    as the background image of a `div`. One important aspect is setting the `background-size`
    property. The natural size of the SVG image is `458` by `392`. In this case it''s
    set to be half that size in order to fit into the size of the `div`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最初的基本示例中，我们将一个风格化的字母R的SVG图像添加为`div`的背景图像。一个重要的方面是设置`background-size`属性。SVG图像的自然大小是`458`乘以`392`。在这种情况下，它被设置为原来大小的一半，以适应`div`的大小：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Rendered in the browser, we get the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，我们得到以下结果：
- en: '![](img/f9e4f359-a25f-4ec2-aab1-06ecd07114a7.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9e4f359-a25f-4ec2-aab1-06ecd07114a7.png)'
- en: Other than providing for high pixel density displays (which *is* a great feature),
    this doesn't get you much beyond what a PNG provides.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供高像素密度显示（这确实是一个很棒的功能）之外，这并没有比PNG提供更多。
- en: 'In an environment where relative units are being used, you can leverage SVG''s
    ability to scale with `contain` or `cover` as the value of `background-size` to
    really take advantage of SVG. In the following example, the same previous logo
    is applied as a background image, alongside some text. All of the metrics are
    relative, using the root em (rem) unit. The background image is set with a `background-size`
    value of `contain`. `contain` ensures that the logo will be shown, *in its entirety*,
    constrained by the height and width of the containing element. Since we''re using
    an SVG image as the background image, the base font for the document (and therefore
    the calculation of the *root em*) could scale from 16 pixels (the browser default)
    to 1,600 pixels and the SVG background would be able to scale to match:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用相对单位的环境中，你可以利用SVG的能力，将`background-size`的值设置为`contain`或`cover`，以真正充分利用SVG。在下面的例子中，与之前相同的标志被应用为背景图像，旁边还有一些文本。所有的度量都是相对的，使用根em（rem）单位。背景图像设置为`contain`的`background-size`值。`contain`确保标志将完整地显示，受包含元素的高度和宽度的限制。由于我们使用SVG图像作为背景图像，文档的基本字体（因此计算*根em*）可以从16像素（浏览器默认值）缩放到1600像素，SVG背景将能够缩放以匹配：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Rendered in the browser, we get the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，我们得到以下结果：
- en: '![](img/04b8f8c6-75a8-4ef7-8070-fe306cc8ecd3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04b8f8c6-75a8-4ef7-8070-fe306cc8ecd3.png)'
- en: There's not much here that's new,  but it's such an important use for SVG on
    the modern web it's worth taking some time to reinforce the pattern.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的东西，但这是现代网页上SVG的一个非常重要的用途，值得花一些时间来强调这种模式。
- en: Data URLs for SVG background images
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG背景图像的数据URL
- en: 'If you''re performance-minded, you might be wondering about the technique of
    embedding a background image directly in your CSS via a data: URL. Data URLs allow
    you to embed files directly into a document via a special `data: URL`.  This technique
    allows you to save an HTTP request.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你注重性能，你可能会想知道通过data: URL直接在CSS中嵌入背景图像的技术。数据URL允许你通过特殊的`data: URL`将文件直接嵌入文档中。这种技术允许你节省一个HTTP请求。'
- en: 'When working with binary formats such as JPGs or PNGs, the image data needs
    to be `base64`-encoded. While this will work with SVG images, it''s actually faster
    ([https://css-tricks.com/probably-dont-base64-svg/](https://css-tricks.com/probably-dont-base64-svg/)) to
    embed the SVG images as an SVG source. This works because, in addition to `base64`-encoded
    data, you can directly embed text. SVG is, of course, a text format.  You just
    need to do a couple of things to the SVG to make it work properly. You should
    read the full article by Taylor Hunt for the details ([https://codepen.io/tigt/post/optimizing-svgs-in-data-uris](https://codepen.io/tigt/post/optimizing-svgs-in-data-uris))
    but the basic steps are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用诸如JPG或PNG之类的二进制格式时，图像数据需要进行`base64`编码。虽然这对SVG图像也适用，但实际上，将SVG图像作为SVG源嵌入更快（[https://css-tricks.com/probably-dont-base64-svg/](https://css-tricks.com/probably-dont-base64-svg/)）。这是因为除了`base64`编码的数据外，你还可以直接嵌入文本。SVG当然是一种文本格式。你只需要对SVG进行一些处理才能使其正常工作。你应该阅读Taylor
    Hunt的完整文章以获取详细信息（[https://codepen.io/tigt/post/optimizing-svgs-in-data-uris](https://codepen.io/tigt/post/optimizing-svgs-in-data-uris)），但基本步骤如下：
- en: Use single quotes for attribute values
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单引号作为属性值
- en: URL-encode any non-safe characters (`<`, `>`, `#`, and so on)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对任何非安全字符（`<`，`>`，`#`等）进行URL编码
- en: Double quote the data URL
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双引号数据URL
- en: 'Converting the initial example, we get code that looks as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 转换初始示例，我们得到的代码如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While this is actually pretty straightforward to prep by hand (the example here
    was hand-coded), there are some tools available that can do this for you if you're
    looking to squeeze out all the bytes. There's a node module ([https://www.npmjs.com/package/mini-svg-data-uri](https://www.npmjs.com/package/mini-svg-data-uri))
    and a SASS function ([https://codepen.io/jakob-e/](https://codepen.io/jakob-e/))
    that can help you build this capability into your workflow.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这实际上是非常简单的手工准备（这里的示例是手工编码的），但如果您想要挤出所有字节，有一些可用的工具可以为您完成这项工作。有一个node模块（[https://www.npmjs.com/package/mini-svg-data-uri](https://www.npmjs.com/package/mini-svg-data-uri)）和一个SASS函数（[https://codepen.io/jakob-e/](https://codepen.io/jakob-e/)），可以帮助您将此功能构建到您的工作流程中。
- en: SVG sprites and icon sets
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG精灵和图标集
- en: This section isn't strictly about CSS, but does discuss a replacement for a
    common CSS-driven solution for adding icons to applications so this seems such
    as the best place to discuss it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分并不严格涉及CSS，但讨论了一种常见的基于CSS的解决方案的替代方案，用于向应用程序添加图标，因此这似乎是讨论它的最佳地方。
- en: If you're reading this book you're probably somewhat familiar with the idea
    of icon fonts such as GLYPHICONS ([http://glyphicons.com/](http://glyphicons.com/)) or
    Font Awesome ([https://fontawesome.com/icons?from=io](https://fontawesome.com/icons?from=io)).
    If you're not, they are fonts that, instead of representing characters that can
    be read as language (as in, the characters that you're reading right now), they
    present different images that can be used as icons for a site or application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在阅读本书，您可能对图标字体的概念有所了解，比如GLYPHICONS（[http://glyphicons.com/](http://glyphicons.com/)）或Font
    Awesome（[https://fontawesome.com/icons?from=io](https://fontawesome.com/icons?from=io)）。如果您不了解，它们是字体，而不是表示可以作为语言阅读的字符（就像您现在正在阅读的字符），它们呈现可以用作站点或应用程序图标的不同图像。
- en: For example, you could create an interface for a video player using *Font Awesome*
    without having to design a single element.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用*Font Awesome*创建视频播放器的界面，而无需设计单个元素。
- en: The following code sample shows what that implementation might look such as.
    In addition to Font Awesome, the following example uses Bootstrap styles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了该实现可能看起来如何。除了Font Awesome，以下示例还使用了Bootstrap样式。
- en: 'The basic pattern for Font Awesome is to include the icons as an empty element.
    In this case an `i`. Each one has two common classes: `fa` and `fa-2x`. These
    indicate that the element is a Font Awesome icon and that it should render at
    `2x` the normal size. After that, the individual icons are added with `fa-`classes
    that indicate the type of icon to be used:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome的基本模式是将图标作为空元素包含。在这种情况下是`i`。每个图标都有两个常见的类：`fa`和`fa-2x`。这些类表示元素是Font
    Awesome图标，并且应该以正常大小的`2x`渲染。之后，使用`fa-`类添加各个图标，表示要使用的图标类型：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Rendered in the browser, it looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现如下：
- en: '![](img/d5cedaab-822a-4474-918e-f3d7a4018eb1.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5cedaab-822a-4474-918e-f3d7a4018eb1.png)'
- en: That's all very clean and easy to understand. Because of that, these icon fonts
    are very popular. I've used them in multiple environments and I am impressed with
    their general ease of use and the ability they offer to get up and running very
    quickly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都非常清晰易懂。正因为如此，这些图标字体非常受欢迎。我在多个环境中使用过它们，对它们的通用易用性和快速启动能力印象深刻。
- en: 'That said, there are downsides to using icon fonts. Two prominent downsides
    are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，使用图标字体也有缺点。两个突出的缺点是：
- en: 'Accessibility: There are ways to do icon fonts well with regard to accessibility
    ([https://www.filamentgroup.com/lab/bulletproof_icon_fonts.html](https://www.filamentgroup.com/lab/bulletproof_icon_fonts.html)),
    but out of the box, you''re inserting gibberish characters into an empty element.
    Screen readers can read that nonsense, creating a confusing experience for users
    who rely on AT to browse the web.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可访问性：有方法可以很好地使用图标字体，以便实现可访问性（[https://www.filamentgroup.com/lab/bulletproof_icon_fonts.html](https://www.filamentgroup.com/lab/bulletproof_icon_fonts.html)），但开箱即用，您正在向空元素插入无意义的字符。屏幕阅读器可以读取这些无意义的字符，为依赖AT浏览网页的用户创建混乱的体验。
- en: 'Semantics: Empty elements are *empty. *Icon fonts using `i` or `span` don''t
    really hold any meaning.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义：空元素是*空的。*使用`i`或`span`的图标字体实际上没有任何含义。
- en: There are other issues including the finicky nature of loading web fonts in
    general and problems for dyslexic users ([https://cloudfour.com/thinks/seriously-dont-use-icon-fonts/](https://cloudfour.com/thinks/seriously-dont-use-icon-fonts/)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他问题，包括加载Web字体的挑剔性以及对阅读障碍用户的问题（[https://cloudfour.com/thinks/seriously-dont-use-icon-fonts/](https://cloudfour.com/thinks/seriously-dont-use-icon-fonts/)）。
- en: 'The good news is, if you''re interested in better semantics, better accessibility
    and more straightforward implementation, there''s an SVG alternative to icon fonts:
    using *SVG sprites*. To be fair, SVG sprites aren''t a perfect solution either
    as the most elegant variation on them requires an IE/Edge-shaped workaround,.
    But for certain configurations (specifically single-page apps) SVG sprites are
    a great choice for icon delivery.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果您对更好的语义、更好的可访问性和更直接的实现感兴趣，有一种SVG替代图标字体的方法：使用*SVG精灵*。公平地说，SVG精灵也不是一个完美的解决方案，因为最优雅的变体需要IE/Edge形状的解决方法。但对于某些配置（特别是单页应用程序），SVG精灵是图标交付的绝佳选择。
- en: Let's take a look at how it works.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。
- en: For this example, we're going to use Front Awesome v5 which provides SVG Versions
    of all of their icons to replicate the previous set of controls.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用Front Awesome v5，它提供了所有图标的SVG版本，以复制先前的控件集。
- en: Here's how the same controls are implemented using SVG sprites.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用SVG精灵实现相同控件的方法。
- en: First, let's look at a detail of the sprite file itself. In it, all of the icons
    are defined as a `symbol` element that corresponds to the same name referenced
    via the class name for the CSS icon. Each `symbol` element includes the accessible
    `title` element.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下精灵文件本身的细节。在其中，所有图标都被定义为与CSS图标的类名相对应的`symbol`元素。每个`symbol`元素都包括可访问的`title`元素。
- en: 'Each of the icons in the set is represented in the file `fa-solid.svg`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的每个图标都在文件`fa-solid.svg`中表示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the HTML file, things are slightly different, but all in all the pattern
    is much the same. We still link to Bootstrap for convenience. We no longer link
    to anything from Font Awesome in the `head`. We just have a small block of CSS
    to size the icons on our page. In a real-world example, you might do a bit more
    to style these, but for now this is enough to make it functional.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文件中，情况略有不同，但总体模式基本相同。我们仍然链接到Bootstrap以方便使用。我们不再在`head`中链接来自Font Awesome的任何内容。我们只需要一小块CSS来调整页面上图标的大小。在实际的示例中，您可能会做更多的样式处理，但目前这已经足够使其正常工作。
- en: In the body of the document, we have a new pattern. Instead of the `button.btn
    > i.fa` pattern, we have `button.btn > svg > use`, with the use pointing to a
    specific symbol in the `fa-solid.svg` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档的主体部分，我们有一个新的模式。与`button.btn > i.fa`模式不同，我们有`button.btn > svg > use`，其中use指向`fa-solid.svg`文件中的特定符号。
- en: 'Other than that, we have an Internet Explorer shaped wrinkle. Internet Explorer
    won''t allow you to `use` an element from an external document. The script *svg4everybody*
    polyfills that shortcoming and allows you to link to external SVG in IE:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们有一个适用于Internet Explorer的问题。Internet Explorer不允许您从外部文档中使用元素。脚本*svg4everybody*填补了这个缺陷，并允许您在IE中链接到外部SVG：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I mentioned how single-page apps can be treated differently. If you're working
    on a single-page application and want to use SVG icons, you can *inline *the symbols
    in your page and use them without any polyfill script in all modern browsers.
    With single-page apps you might be inlining things such as CSS already to save
    on HTTP requests, so adding a section of SVG inline in your document can be part
    of the same process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了单页面应用程序可能会被不同对待。如果您正在开发单页面应用程序并且想要使用SVG图标，您可以在页面中*内联*符号，并且在所有现代浏览器中*使用*它们，而无需任何填充脚本。对于单页面应用程序，您可能已经在文档中内联了CSS等内容以节省HTTP请求，因此在文档中内联一部分SVG可以成为相同过程的一部分。
- en: I'm not going to detail how this might work from a build or page creation perspective,
    since there are many ways to do this (either as part of a build process or through
    a server-side templating system), but the output might look something such as
    the following code sample.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算详细说明这可能是如何从构建或页面创建的角度工作的，因为有很多种方法可以做到这一点（可以作为构建过程的一部分或通过服务器端模板系统），但输出可能看起来像以下代码示例。
- en: The biggest difference is the definition of the symbols in the inline `svg`
    element at the top of the `body`. This adds complexity to the page, but saves
    on HTTP requests. So if you're building a single-page app and don't need to rely
    on caching a separate sprite file, this is going to be slightly faster.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别是在`body`顶部的内联`svg`元素中定义符号。这增加了页面的复杂性，但节省了HTTP请求。因此，如果您正在构建单页面应用程序并且不需要依赖缓存单独的精灵文件，这将会稍微更快一些。
- en: 'Other than that, the references are directly to a document fragment of the
    same page, as opposed to linking to a separate file. This means we don''t need
    svg4everybody and Internet Explorer is happy to support `use`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，引用直接指向同一页面的文档片段，而不是链接到单独的文件。这意味着我们不需要svg4everybody，而且Internet Explorer很乐意支持`use`：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As with icon fonts, SVG sprites are fully customizable with CSS.  You've already
    seen an example where we changed the size and color of the icons in the preceding
    examples. As you read through the rest of the chapter, you'll encounter the many
    ways that you can manipulate SVG with CSS. It's quite a powerful combination!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与图标字体一样，SVG精灵可以完全使用CSS进行自定义。您已经看到了一个示例，在前面的示例中我们改变了图标的大小和颜色。当您阅读本章的其余部分时，您将会遇到许多使用CSS操纵SVG的方法。这是一个非常强大的组合！
- en: Styling inline SVG
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对内联SVG进行样式设置
- en: This section is going to focus on some of the many ways you can manipulate inline
    SVG elements with CSS. This section will not be exhaustive, but will cover many
    of the most common properties that you'll use when working with SVG.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍您可以使用CSS操纵内联SVG元素的许多方法。本节不会详尽无遗，但将涵盖您在处理SVG时将使用的许多常见属性。
- en: 'These fall into two classes of properties:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性分为两类：
- en: CSS properties that you're probably familiar with from working with CSS and
    HTML, and that will also work with SVG
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能已经熟悉的CSS和HTML中的CSS属性，也适用于SVG
- en: CSS properties that are specific to SVG itself
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于SVG本身的CSS属性
- en: Let's start with the familiar CSS properties.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从熟悉的CSS属性开始。
- en: Using common CSS properties to manipulate SVGs
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常见的CSS属性来操纵SVG
- en: This section is going to focus on common CSS properties that work with SVG.
    With a couple of exceptions, most of the ones you'll actually pay attention to
    are related to text.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍与SVG一起使用的常见CSS属性。除了一些例外，您实际上会关注的大多数属性都与文本相关。
- en: Basic font properties
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本字体属性
- en: If you've worked with CSS for any length of time, you've likely manipulated
    the font face and style for an element. Those same properties are available for
    SVG elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用CSS工作了一段时间，您可能已经操纵了元素的字体和样式。这些属性对SVG元素也是可用的。
- en: 'The following code sample shows four `text` elements. The first shows no styles
    applied to it and shows the default rendering of a `text` element in SVG. The
    next three elements are enhanced by CSS styles. The first class `text` adds the
    excellent Raleway typeface (available as a Google web font) and a new `font-size`
    (`2em`). The next two classes, `text-italic` and `text-bold`, build on that with
    the use of `font-style` and `font-weight` respectively:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了四个`text`元素。第一个没有应用任何样式，并显示了SVG中`text`元素的默认渲染。接下来的三个元素通过CSS样式进行了增强。第一个类`text`添加了优秀的Raleway字体（作为Google网络字体可用）和一个新的`font-size`（`2em`）。接下来的两个类，`text-italic`和`text-bold`，分别使用`font-style`和`font-weight`进行了增强：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Rendered in the browser, you can see the result as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，您可以看到以下结果：
- en: '![](img/bd2446b2-db15-4324-8731-57c1a383cef4.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd2446b2-db15-4324-8731-57c1a383cef4.png)'
- en: 'In case you were wondering, the shorthand properties also work as well. So
    simply defining a `font` property is supported, as the following code sample shows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想，简写属性也同样适用。因此，简单地定义一个`font`属性是支持的，如下面的代码示例所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This renders in the browser as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这在浏览器中呈现如下：
- en: '![](img/3b27ab70-50bb-4be0-8422-6dc36a9e99e8.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b27ab70-50bb-4be0-8422-6dc36a9e99e8.png)'
- en: Text properties
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本属性
- en: The next set of CSS properties supported in SVG all relate to blocks of text.
    So not just the individual glyph, as defined by the font properties, but the way
    that a larger grouping of glyphs fit together.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在SVG中支持的下一组CSS属性都与文本块有关。因此，不仅仅是由字体属性定义的单个字形，还有更大的字形组合方式。
- en: The following code sample illustrates several of them. The first class, `text`,
    again changes the `font-family` and `font-size`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了其中的几个。第一个类`text`再次更改了`font-family`和`font-size`。
- en: 'Following that, we have several other classes that show SVG support for text
    properties. The first illustrates support for `direction`, which allows you to
    define blocks of text that will work properly in languages that is read right-to-left
    (for example, Farsi, Arabic, and  Hebrew). This example simply anchors the English-based
    property definition to the right side of the box. Following that, we set the `letter-spacing`
    (tracking) property to a roomy `1em`, add an underline using `text-decoration`,
    and set the `word-spacing` to  `2em`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有几个其他类，展示了SVG对文本属性的支持。第一个示例展示了对`direction`的支持，它允许您定义在从右到左阅读的语言中正常工作的文本块（例如，波斯语、阿拉伯语和希伯来语）。这个例子简单地将基于英语的属性定义锚定到框的右侧。接下来，我们将`letter-spacing`（跟踪）属性设置为宽敞的`1em`，使用`text-decoration`添加下划线，并将`word-spacing`设置为`2em`：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Rendered in the browser, that sample looks as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，该示例如下所示：
- en: '![](img/b1833428-1f15-4a59-9831-75cc1435644c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1833428-1f15-4a59-9831-75cc1435644c.png)'
- en: Miscellaneous CSS properties
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项CSS属性
- en: The final example in this section shows support for the cursor, display, and
    visibility properties. Of these, the most useful will be cursor. In this example,
    we change the `cursor` of a `rect` element to be the help cursor. Drag handles,
    resize handles, clickable pointers, and so on are all going to be common values
    used in interactive SVG.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的最后一个示例显示了对光标、显示和可见性属性的支持。其中，最有用的将是光标。在这个例子中，我们将`rect`元素的`cursor`更改为帮助光标。拖动手柄、调整大小手柄、可点击的指针等都将是交互式SVG中常用的值。
- en: Following that we use the `display` and `visibility` properties to hide elements.
    While the differences between the two are obvious in HTML, there's less practical
    difference between the two properties in SVG. In HTML elements with `display:none`
    are not factored into the rendering of the document. They do not effect the overall
    flow of the document. They're in the DOM and are accessible from JavaScript but
    they're, in effect, ignored by the rendering engine. Elements set with `visibility:hidden`,
    on the other hand, remain part of the flow of the document. A 200-pixel high `div`
    will still take up 200 pixels. It will just do so invisibly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`display`和`visibility`属性来隐藏元素。虽然在HTML中两者之间的区别很明显，在SVG中这两个属性之间的实际区别较小。在HTML中，使用`display:none`的元素不会影响文档的呈现。它们不会影响文档的整体流程。它们在DOM中，并且可以从JavaScript中访问，但实际上被呈现引擎忽略。另一方面，使用`visibility:hidden`设置的元素仍然是文档流的一部分。一个高200像素的`div`仍然会占据200像素。它只是以不可见的方式这样做。
- en: 'Since most elements in SVG are positioned with `(x,y)` properties on a coordinate
    system, the differences between the two might be subtle. SVG elements with `visibility:hidden`
    normally don''t have any flow to interrupt (`tspan` would be one exception) so
    there''s no practical difference in layout. The one difference is in the way JavaScript
    events are handled. We''ll look at this in more depth later, both in the next
    section and in the later JavaScript chapters. But depending on how the `pointer-events` property
    is set, `visibility:hidden` elements might still interact with the user through
    JavaScript events. By default they will not, but it''s still possible:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SVG中的大多数元素都是在坐标系上使用`(x,y)`属性进行定位，因此两者之间的差异可能是微妙的。通常，使用`visibility:hidden`的SVG元素没有任何流程中断（`tspan`可能是一个例外），因此在布局上没有实际的区别。唯一的区别在于JavaScript事件的处理方式。我们将在后面更深入地研究这一点，既在下一节中，也在后面的JavaScript章节中。但根据`pointer-events`属性的设置方式，`visibility:hidden`元素可能仍然通过JavaScript事件与用户交互。默认情况下，它们不会，但这仍然是可能的：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Rendered in the browser, when hovering over the element with the mouse cursor
    this sample looks as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现时，当鼠标悬停在元素上时，此示例如下所示：
- en: '![](img/3ebea4ad-6971-40de-91aa-5b93cc6f53b9.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ebea4ad-6971-40de-91aa-5b93cc6f53b9.png)'
- en: If you're familiar with CSS, then you'll know there are other possible values
    for `display`. While I'm sure there are valid use cases for setting an SVG element
    to have another `display` value, it's not going to be something you'll commonly
    do, so I'm not going to talk about that here.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉CSS，那么您会知道`display`还有其他可能的值。虽然我相信设置SVG元素具有另一个`display`值的情况是有效的，但这不是您通常会做的事情，所以我不会在这里讨论这个问题。
- en: Using SVG-specific CSS properties to manipulate SVGs
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG特定的CSS属性来操作SVG
- en: This section will talk about the different CSS properties that you can use to
    work with SVG. Most of these properties have already been seen in previous chapters
    as attributes of specific SVG elements. You'll find that the combination of these
    representational attributes and the possibility of using CSS for sharing styles
    across SVG elements and SVG documents represents a powerful combination.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论您可以用来处理SVG的不同CSS属性。这些属性中的大多数在以前的章节中已经作为特定SVG元素的属性看到了。您会发现这些表现属性的组合以及使用CSS在SVG元素和SVG文档之间共享样式的可能性代表了一个强大的组合。
- en: CSS properties will override presentation attributes, but will not override `style` attributes
    (which really just means that SVG + CSS behaves the way you would expect it to
    if you're familiar with the way that CSS specificity works ([https://css-tricks.com/specifics-on-css-specificity/](https://css-tricks.com/specifics-on-css-specificity/))).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 属性将覆盖演示属性，但不会覆盖 `style` 属性（这实际上意味着 SVG + CSS 的行为方式与您熟悉的 CSS 特异性工作方式相同）。
- en: Color and painting properties
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色和绘画属性
- en: This first example illustrates the ability to change the fill of an element.
    The `fill` property accepts any valid CSS color value ([https://developer.mozilla.org/en-US/docs/Web/CSS/color_value](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)),
    as well as a link to a paint server (for example, a `pattern` defined in a `defs`
    section). `fill-opacity` changes the opacity of the fill itself (as the alpha
    value in an `rgba` color definition does) and not the whole element, as the CSS `opacity`
    property would.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个示例说明了更改元素填充的能力。`fill` 属性接受任何有效的 CSS 颜色值（[https://developer.mozilla.org/en-US/docs/Web/CSS/color_value](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)），以及指向绘图服务器的链接（例如，在
    `defs` 部分中定义的 `pattern`）。`fill-opacity` 更改填充本身的不透明度（就像 `rgba` 颜色定义中的 alpha 值一样），而不是整个元素，就像
    CSS 的 `opacity` 属性一样。
- en: In this example, we define four classes. The first two, `red-fill` and `blue-fill`,
    define two different primary colors, red and blue, for fills. The third, `half-opacity`, defines
    `50%` opacity. The final one, `gradient`, defines the fill as a link to a paint
    server defined in the SVG element.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了四个类。前两个，`red-fill` 和 `blue-fill`，定义了两种不同的主要颜色，红色和蓝色，用于填充。第三个，`half-opacity`，定义了
    `50%` 的不透明度。最后一个 `gradient`，定义了填充为 SVG 元素中定义的绘图服务器的链接。
- en: 'They''re then applied with the same `class` attribute you would use with a
    regular HTML element:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它们与您使用常规 HTML 元素时使用的相同的 `class` 属性一起应用：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Rendered in the browser, we get the following result:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，我们得到以下结果：
- en: '![](img/f8ff0f54-974e-4d07-9667-36978aed3bc8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8ff0f54-974e-4d07-9667-36978aed3bc8.png)'
- en: Stroke properties
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描边属性
- en: Another very useful set of properties that are available to manipulate SVG from
    CSS are related to strokes. All of the stroke properties are available as CSS
    properties. Similar to the `fill` properties, these are going to come in very
    handy in creating consistent interfaces and visualizations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的一组属性，可用于从 CSS 操作 SVG 的属性与描边有关。所有描边属性都可以作为 CSS 属性使用。与 `fill` 属性类似，这些属性在创建一致的界面和可视化方面非常有用。
- en: This example shows the usage of `stroke` and `stroke-width` as part of a base
    `stroke` class. This sets up a common stroke style so that we can apply the other
    stroke manipulation properties to our examples. Following that, we set the two
    dash properties, `stroke-dashoffset` and `stroke-dasharray`, and apply those to
    the first two `rect` elements using the `stroke-dasharray` and `stroke-dashoffset`
    classes. After that, we apply `stroke-linecap` to a `line` element using the `stroke-linecap-join`
    class.  Following that, we apply the `stroke-linejoin-round` class to a final
    `rect` element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了作为基本 `stroke` 类的一部分使用 `stroke` 和 `stroke-width` 的用法。这样设置了一个常见的描边样式，以便我们可以将其他描边操作属性应用到我们的示例中。在那之后，我们设置了两个虚线属性，`stroke-dashoffset`
    和 `stroke-dasharray`，并将这些属性应用到前两个 `rect` 元素，使用 `stroke-dasharray` 和 `stroke-dashoffset`
    类。之后，我们使用 `stroke-linecap-join` 类将 `stroke-linecap` 应用到 `line` 元素。在那之后，我们将 `stroke-linejoin-round`
    类应用到最后一个 `rect` 元素。
- en: The `property/value` pairs match the same patterns you learned about in [Chapter
    2](fcc9b174-2f03-4b20-96be-5c62deae4581.xhtml), *Getting Started with Authoring
    SVG*, when you initially learned about these presentation attributes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`property/value` 对匹配了您在 [第 2 章](fcc9b174-2f03-4b20-96be-5c62deae4581.xhtml)
    中学到的相同模式，*开始使用 SVG 进行创作*，当您最初学习这些演示属性时。'
- en: 'All of these are available as CSS properties, which should help you to create
    consistent reusable stroke patterns for elements in your SVG document:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以作为 CSS 属性使用，这应该有助于您为 SVG 文档中的元素创建一致可重用的描边模式：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rendered in the browser, the preceding code produces the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，上述代码产生以下输出：
- en: '![](img/392f79ea-a0e4-4cd0-a038-2548045f2cf9.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/392f79ea-a0e4-4cd0-a038-2548045f2cf9.png)'
- en: Text properties
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本属性
- en: This section will introduce some SVG-specific text properties. The first few
    examples deal with the baseline of text in SVG. Depending on the sort of work
    you're doing, you may never have to tweak a text element's baseline (the visual
    plane on which a line of text sits). But you *may* have to, especially if you're
    doing work with multi-lingual layouts or complicated text-based illustrations
    (like a logo). So it's worth introducing you to these properties. The baseline
    related properties are `alignment-baseline`, `dominant-baseline`, and `baseline-shift`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍一些 SVG 特定的文本属性。前几个示例涉及 SVG 中文本的基线。根据您的工作类型，您可能永远不需要调整文本元素的基线（文本行所在的视觉平面）。但是，您可能需要，特别是如果您正在处理多语言布局或复杂的基于文本的插图（如标志）。因此，值得向您介绍这些属性。与基线相关的属性是
    `alignment-baseline`、`dominant-baseline` 和 `baseline-shift`。
- en: In addition to those, this section will also look at the `text-anchor` property,
    which changes the anchor point of a `text` element.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，本节还将介绍 `text-anchor` 属性，该属性可以更改 `text` 元素的锚点。
- en: 'As a brief note about the baseline properties, there''s more to them than this,
    but the following description will give you enough of a foundation to get what''s
    going on in the code sample.  This is *probably* enough for you to get by using
    these properties:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基线属性的简要说明，还有更多内容，但以下描述足以为您提供足够的基础，以理解代码示例中发生的情况。这 *可能* 足够让您使用这些属性：
- en: '`dominant-baseline` is used to adjust the baseline for a `text` element'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dominant-baseline` 用于调整 `text` 元素的基线'
- en: '`alignment-baseline` is used to adjust the baseline for a child element relative
    to the baseline of its parent `text` element'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignment-baseline` 用于调整子元素相对于其父 `text` 元素基线的基线'
- en: '`baseline-shift` is probably the most useful, providing the common *subscript*
    and *superscript* functionality by shifting the dominant baseline up or down'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseline-shift`可能是最有用的，通过将主基线上移或下移来提供常见的*下标*和*上标*功能'
- en: '`dominant-baseline` and `alignment-baseline` accept similar values. The two
    used here are *hanging*, which drops the text off the bottom of the text box,
    and *middle, *which centers the text vertically on the bottom of the text box.
    In this example `dominant-baseline` is applied to `text` elements with the two
    different values and `alignment-baseline` is applied to two different child `tspan`
    elements with the two different values.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`dominant-baseline`和`alignment-baseline`接受类似的值。这里使用的两个值是*hanging*，它将文本从文本框底部删除，以及*middle*，它将文本垂直居中在文本框底部。在这个示例中，`dominant-baseline`应用于具有两个不同值的`text`元素，而`alignment-baseline`应用于具有两个不同值的两个子`tspan`元素。'
- en: Following that, the common superscript and subscript patterns are created with
    the `super` and `sub` values of `baseline-shift`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，使用`baseline-shift`的`super`和`sub`值创建了常见的上标和下标模式。
- en: 'Finally, the `text-anchor` property is illustrated by three different values
    applied to a text element centered in the middle of the viewport. `text-anchor` aligns
    text to different points in the text box: `start`, `middle`, and to `end` of the
    sentence.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`text-anchor`属性通过应用于视口中间居中的文本元素的三个不同值进行说明。`text-anchor`将文本对齐到文本框中的不同点：`start`，`middle`和句子的`end`。
- en: 'The code sample that follows illustrates the usage of these baseline attributes
    as well as the usage of the `text-anchor` property:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码示例说明了这些基线属性的用法，以及`text-anchor`属性的用法：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Rendered in the browser, these effects are visible in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，这些效果在以下截图中可见：
- en: '![](img/7bf69f05-021a-4376-a4e3-29783c150d53.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bf69f05-021a-4376-a4e3-29783c150d53.png)'
- en: The darker bands show the initial textbox based on the *x*, *y* position of
    the text element. You can see how `hanging` and `middle` clearly shift the baseline
    of the font in reference to the *x*, *y* position.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 较暗的条带显示了基于文本元素的*x*，*y*位置的初始文本框。您可以看到`hanging`和`middle`如何清楚地移动了字体的基线，相对于*x*，*y*位置。
- en: The `text-anchor` example is illustrated with the addition of a line that indicates
    the `(x,y)` position of those text elements. They are placed at the center of
    the SVG element, which illustrates the effect of that property on a text element.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`text-anchor`示例通过添加一条指示这些文本元素的`(x,y)`位置的线来进行说明。它们放置在SVG元素的中心，这说明了该属性对文本元素的影响。'
- en: Compositing properties
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合成属性
- en: Browser support for the compositing properties is pretty crummy at present.
    Microsoft doesn't have full support for the `clip` properties, at the time of
    writing, and mask property support is terrible across the board). That's unfortunate,
    as they'd present powerful options for defining and reusing clip-paths and masks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，浏览器对合成属性的支持非常糟糕。在撰写本文时，微软对`clip`属性的支持不完整，而mask属性的支持在各个浏览器中都很糟糕。这很不幸，因为它们可以提供强大的选项来定义和重用剪切路径和蒙版。
- en: The one working example I'm going to show illustrates how to define a `clip-path`
    using CSS. There are two variations. The first simply references a `clipPath`
    element by `id`. This is straightforward and works in modern browsers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我要展示的一个有效示例是如何使用CSS定义`clip-path`。有两种变体。第一种只是通过`id`引用了一个`clipPath`元素。这很简单，在现代浏览器中可以工作。
- en: The second example allows for greater separation of concerns. Instead of having
    to define an element with a path to use for clipping, you can provide polygon
    coordinates directly to CSS. `polygon`, `circle`, and `inset` are available values
    for this property. This syntax replaces the now deprecated `clip` property. If
    you're familiar with `clip`, you should note a couple of things. First, notice
    that there is no direct replacement for the `rect` value. Thankfully, as we show
    here, polygon is more than enough to replace `rect`. Secondly, `clip-path` does *not*require
    an element to be absolutely positioned (although, that's not a particular concern
    when using this property in SVG).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例允许更好地分离关注点。您不必定义一个带有路径的元素来进行剪切，而是可以直接向CSS提供多边形坐标。`polygon`，`circle`和`inset`是此属性的可用值。这种语法取代了现在已弃用的`clip`属性。如果您熟悉`clip`，您应该注意几件事。首先，请注意没有`rect`值的直接替代品。值得庆幸的是，正如我们在这里展示的，多边形已经足够替代`rect`。其次，`clip-path`*不需要*将元素绝对定位（尽管在SVG中使用此属性时，这并不是一个特别关注的问题）。
- en: The syntax for the polygon value is slightly different from the one used for
    a `polygon` element's `path` attribute. Instead of the commas being arbitrary
    and there just for legibility (as is the case with a d attribute of a path element),
    the pairs of points in this CSS property need to be comma-separated and require
    units. Otherwise, it works the same way as a `polygon` in SVG.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形值的语法与用于`polygon`元素的`path`属性的语法略有不同。与路径元素的d属性的逗号是任意的，仅用于可读性不同，这个CSS属性中的点对需要用逗号分隔并且需要单位。否则，它的工作方式与SVG中的`polygon`相同。
- en: 'This example replicates the rectangle seen in the `clipPath` example by mapping
    out the points as a `polygon`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例通过将点映射为`polygon`来复制`clipPath`示例中看到的矩形：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Rendered in the browser, you get the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，您将获得以下输出：
- en: '![](img/91606b93-28e5-4e81-b24c-cc3c041b39d5.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91606b93-28e5-4e81-b24c-cc3c041b39d5.png)'
- en: 'As I mentioned, support for the `mask` properties is problematic, so I don''t
    have fully realized examples. There are three patterns that are defined:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，对`mask`属性的支持存在问题，因此我没有完全实现的示例。有三种定义的模式：
- en: 'The first is similar to the `clip-path` property. You can define a `mask-image`
    property and pass a mask image into it via a `url`:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个与`clip-path`属性类似。您可以定义一个`mask-image`属性，并通过`url`将一个蒙版图像传递给它：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second option is to use a portion of a linked image using a fragment identifier:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个选项是使用片段标识符来使用链接图像的一部分：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The third, and most interesting option, would allow you to create masks in
    the property value:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个，也是最有趣的选项，允许您在属性值中创建蒙版：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This technology isn't ready for prime time yet, but it's good to know what's
    on the horizon, especially as it would allow you to reuse masks defined in a central
    place using nothing but a CSS class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术尚未准备好投入使用，但了解未来的技术发展是很重要的，特别是它将允许您仅使用CSS类来重用在一个中心位置定义的蒙版。
- en: Interactivity properties
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互属性
- en: The final CSS property we're going to look at is the `pointer-events` property.
    The `pointer-events` property indicates whether or not an SVG element can become
    the target of pointer events (inclusive of all inputs, including mouse, pen, or
    touch inputs).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的最后一个CSS属性是`pointer-events`属性。`pointer-events`属性指示SVG元素是否可以成为指针事件的目标（包括所有输入，包括鼠标、笔或触摸输入）。
- en: The basic way to implement `pointer-events` is to turn them on or off. The following
    example shows this in action. This example will also include a little bit of JavaScript,
    so you can get a small head start on [Chapter 6](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml),
    *JavaScript and SVG*, where we'll dive headlong into manipulating SVG with JavaScript.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`pointer-events`的基本方法是打开或关闭它们。以下示例展示了这一点。此示例还将包括一点JavaScript，这样您就可以在[第6章](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml)
    *JavaScript和SVG*中提前了解一些关于使用JavaScript操纵SVG的知识。
- en: In this sample, we have two `rect` elements. One is set with a class of `pointer-default`.
    This class has a single property, `pointer-events` set to `visiblePainted`. `visiblePainted`
    is the default value for `pointer-events` on an SVG element. It indicates that
    the entire visibly painted area of the element should accept mouse events. That
    means both the border and the fill.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们有两个`rect`元素。其中一个设置了类名`pointer-default`。该类有一个名为`pointer-events`的属性，值为`visiblePainted`。`visiblePainted`是SVG元素上`pointer-events`的默认值。它表示元素的整个可见绘制区域应接受鼠标事件。这意味着边框和填充区域都包括在内。
- en: The second `rect` has a class of `pointer-none`. The value of its single property,
    `pointer-events`, is `none`. This indicates that the element should not receive
    mouse events.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`rect`的类名是`pointer-none`。其单个属性`pointer-events`的值为`none`。这表示该元素不应接收鼠标事件。
- en: At the bottom of the page there's a small JavaScript block that shows the property
    in action. It also illustrates the sort of differences you might encounter when
    working with SVG and JavaScript. In it, we use some core **Document Object Model**
    (**DOM**) methods to attach a click event handler to each of the `rect` elements. 
    First, we use `document.querySelectorAll` to get a reference to all of the `rect`
    elements on the page. If you're unfamiliar with it, `querySelectorAll` can be
    thought of as a standardized, browser-native version of the famous jQuery interface.
    You pass in a CSS selector and it returns a static `nodeList` containing the results
    of your query.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 页面底部有一个小的JavaScript块，展示了该属性的作用。它还说明了在处理SVG和JavaScript时可能遇到的差异。在其中，我们使用一些核心**文档对象模型**（**DOM**）方法来为每个`rect`元素附加点击事件处理程序。首先，我们使用`document.querySelectorAll`来获取页面上所有`rect`元素的引用。如果您不熟悉它，`querySelectorAll`可以被视为著名的jQuery接口的标准化、浏览器原生版本。您传入一个CSS选择器，它返回一个包含查询结果的静态`nodeList`。
- en: We immediately loop through the array-like `nodeList` with the convenience method,
    `forEach`, and attach event handlers to each of the nodes. This event handler
    is designed to change the text of the adjacent `text` element whenever a square
    is clicked.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即通过方便的`forEach`方法循环遍历类似数组的`nodeList`，并为每个节点附加事件处理程序。此事件处理程序旨在在单击方块时更改相邻`text`元素的文本。
- en: If you're used to using `innerHTML` to set text content, you will notice the
    property `textContent` used here instead. Why? SVG doesn't have an `innerHTML`
    (*which makes sense, since it's not HTML*).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯使用`innerHTML`来设置文本内容，您会注意到这里使用的是`textContent`属性。为什么呢？因为SVG没有`innerHTML`（这是有道理的，因为它不是HTML）。
- en: 'Running this in the browser, you''ll see that only clicks on the `rect` with
    the default `pointer-events` value will change the text. The `rect` with `pointer-events`
    set to `none` doesn''t do anything:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行此代码，您会发现只有默认`pointer-events`值的`rect`单击才会更改文本。设置为`none`的`rect`不会有任何反应：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following illustration shows the page after both `rect` elements were clicked:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图显示了点击两个`rect`元素后的页面：
- en: '![](img/ff426ca6-ed41-4900-b59c-42a1565b380d.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff426ca6-ed41-4900-b59c-42a1565b380d.png)'
- en: 'The following table illustrates the other possible values for this property.
    They offer a lot of control in the way you can interact with SVG elements. Depending
    on how much precise interactivity you''re planning on doing, you might end up
    taking advantage of that precision:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下表说明了此属性的其他可能值。它们在与SVG元素交互的方式上提供了很多控制。根据您计划进行多少精确的交互，您可能最终会利用这种精度：
- en: '| Property | Definition |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 定义 |'
- en: '| `visiblePainted` | The element can be targeted if the `visibility` property
    is set to `visible` and the pointer is over a  *painted area*. With this value
    the painted area includes the `stroke` (if it''s set to a value other than `none`)
    and the `fill` (if it''s set to a value other than `none`). |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `visiblePainted` | 如果`visibility`属性设置为`visible`，并且指针位于*painted area*上，则可以将该元素作为目标。使用此值，绘制区域包括`stroke`（如果它设置为除`none`之外的值）和`fill`（如果它设置为除`none`之外的值）。'
- en: '| `visibleFill` | The element can be targeted if the `visibility` property
    is set to `visible` and the pointer is over the interior (the `fill` area), whether
    or not the `fill` is set.  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `visibleFill` | 如果`visibility`属性设置为`visible`，并且指针位于内部（`fill`区域）上，则可以将该元素作为目标，无论`fill`是否设置。|'
- en: '| `visibleStroke` | The element can be targeted if the `visibility` property
    is set to `visible` and the pointer is over the perimeter (the `stroke` area),
    whether or not the `stroke` is set.  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `visibleStroke` | 如果`visibility`属性设置为`visible`，并且指针位于周边（`stroke`区域）上，则可以将该元素作为目标，无论`stroke`是否设置。|'
- en: '| `visible` | The element can be targeted if the `visibility` property is set
    to `visible` and the pointer is over the interior or perimeter, whether or not
    the fill or stroke are set.  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 如果`visibility`属性设置为`visible`并且指针位于内部或周边，则可以定位元素，无论是否设置了fill或stroke。|'
- en: '| `painted` | The element can be targeted if the `visibility` property is set
    to `visible` and the pointer is over a  *painted area*. With this value the painted
    area includes the `stroke` (if it''s set to a value other than `none`) and the `fill` (if
    it''s set to a value other than `none`. The value of the `visibility` property
    isn''t taken into account. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `painted` | 如果`visibility`属性设置为`visible`并且指针位于*painted area*上，则可以定位元素。使用此值，绘制区域包括`stroke`（如果设置为除`none`之外的值）和`fill`（如果设置为除`none`之外的值）。不考虑`visibility`属性的值。|'
- en: '| `fill` | The element can be targeted if the pointer is over the interior
    (the `fill` area), whether or not the fill is set. The value of the `visibility` property
    isn''t taken into account. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `fill` | 如果指针位于内部（`fill`区域），则可以定位元素，无论是否设置了fill。不考虑`visibility`属性的值。|'
- en: '| `stroke` | The element can be targeted if the pointer is over the perimeter
    (the `stroke` area), whether or not the fill is set. The value of the `visibility` property
    isn''t taken into account. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `stroke` | 如果指针位于周边（`stroke`区域），则可以定位元素，无论是否设置了fill。不考虑`visibility`属性的值。|'
- en: '| `all` | The element can be targeted if the pointer is over the interior or
    perimeter of the element. The values of the stroke, `fill`, and `visibility` properties
    aren''t taken into account. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 如果指针位于元素的内部或周边，则可以定位元素。不考虑`stroke`，`fill`和`visibility`属性的值。|'
- en: '| `none` | The element does not receive pointer events. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 元素不接收指针事件。|'
- en: Styles in standalone SVG images
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立SVG图像中的样式
- en: 'While all the examples so far have been about inline SVG inside an HTML document,
    you can also use CSS within a standalone SVG image. The following SVG image shows
    using CSS to adjust the display of multiple SVG `text` elements. Interesting details
    include the **character data** (`<![CDATA[ ]]>`) block wrapping the styles contained
    in the `style` element:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的例子都是关于内联SVG在HTML文档中，你也可以在独立的SVG图像中使用CSS。以下SVG图像显示了使用CSS来调整多个SVG `text`
    元素的显示。有趣的细节包括包裹在`style`元素中的样式的**字符数据**（`<![CDATA[ ]]>`）块：
- en: '![](img/f4f236f0-0d64-4253-9d0d-4b2414e2bf44.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4f236f0-0d64-4253-9d0d-4b2414e2bf44.png)'
- en: If you haven't dealt with a lot of XML (and it's not nearly as common as it
    once was, so that might be the case), `CDATA` is used to indicate to the XML parser
    that the section might contain characters that could be interpreted as XML, but
    shouldn't be.  JavaScript (with the prevalence of `<` and `>`) is the most common
    use case (and the one you'll know if you were building websites in 1999) but CSS
    could potentially fall into the same trap, so it's good to use it here as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有处理过很多XML（它现在并不像以前那样常见，所以可能是这种情况），`CDATA`用于指示XML解析器，该部分可能包含可被解释为XML但不应该的字符。
    JavaScript（由于`<`和`>`的普遍存在）是最常见的用例（如果你在1999年构建网站，你会知道），但CSS也可能陷入同样的陷阱，所以在这里使用它也是很好的。
- en: The next thing to note is the absence of external style sheets. If you're going
    to create an SVG image that will be imported as an `img src` or as a background
    image in CSS, it needs to be entirely self-contained.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要注意的是外部样式表的缺失。如果要创建一个将作为`img src`导入或作为CSS背景图像的SVG图像，它需要完全自包含。
- en: 'Other than that, this works much like the HTML and CSS combination that''s
    likely familiar to you:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，这与你可能熟悉的HTML和CSS组合工作方式非常相似：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Rendered in the browser, this image looks as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现，此图像如下所示：
- en: '![](img/e0bc4eea-e9b3-4b85-aec7-39a2cd30e670.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0bc4eea-e9b3-4b85-aec7-39a2cd30e670.png)'
- en: Basic CSS animations and transitions with SVG
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG的基本CSS动画和过渡
- en: One of the most interesting ways to work with SVG and CSS is with CSS *animations*
    and *transitions*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SVG和CSS的最有趣的方式之一是使用CSS *动画*和*过渡*。
- en: '**Animations**: This allow you to assign animations to elements. These animations
    are defined as a series of changes to CSS properties.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**：这允许你为元素分配动画。这些动画被定义为一系列对CSS属性的更改。'
- en: '**Transitions**: This allow you to control the time it takes for CSS property
    changes to take effect. Instead of immediately changing, they *transition* between
    states.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡**：这允许你控制CSS属性更改生效所需的时间。它们不是立即改变，而是在状态之间*过渡*。'
- en: These are a very powerful set of features and are an important conceptual and
    technical addition to your SVG toolkit.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一组非常强大的功能，并且是SVG工具包的重要概念和技术补充。
- en: CSS animations
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS动画
- en: CSS animations in SVG work the same way as they do in HTML, with the addition
    of the ability to use the SVG-specific properties.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: SVG中的CSS动画与HTML中的工作方式相同，还可以使用SVG特定的属性。
- en: Basic animation format
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本动画格式
- en: 'The basic pattern is as follows. SVG is simple. It''s a single `rect` element.
    The CSS has two interesting components. The first is the class `rect`, which references
    one property, `animation`. `animation`; this is a shorthand property that maps
    to a whole series of `animation-`properties. In this case, we''re setting two
    of them. The first of the mapped properties is `animation-name`, which references
    the animation defined in the `@keyframes` animation named `movement`. The second
    one we''re setting is the `animation-duration`, which we set to three seconds
    (`3s`). The `@keyframes` animation is where the magic happens. In it, we set two
    sets of keyframes. The first set marks the initial (`0%`) and final state (`100%`)
    of the animation with the same property, a CSS `transform` with a `translate`
    function set to `(0,0)`. This is the initial (and finishing) state. We''re going
    to animate against the `transform` property in the next keyframe. In it, set for
    the middle of the animation (`50%`), we translate the `rect` 400 pixels to the
    right:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 基本模式如下。SVG很简单。它是一个单独的`rect`元素。CSS有两个有趣的组件。第一个是类`rect`，它引用了一个属性`animation`。`animation`是一个简写属性，映射到一整套`animation-`属性。在这种情况下，我们设置了其中的两个。映射属性的第一个是`animation-name`，它引用了`@keyframes`动画中定义的动画`movement`。我们设置的第二个是`animation-duration`，我们将其设置为三秒（`3s`）。`@keyframes`动画是魔术发生的地方。在其中，我们设置了两组关键帧。第一组标记了动画的初始（`0%`）和最终状态（`100%`），使用了相同的属性，即CSS
    `transform`，设置为`(0,0)`的`translate`函数。这是初始（和最终）状态。我们将在下一个关键帧中对`transform`属性进行动画。在其中，我们设置了动画的中间部分（`50%`），我们将`rect`向右移动400像素：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The effect is that the rectangle slowly moves from left to right and then back
    again as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 效果是矩形慢慢从左到右移动，然后再返回：
- en: '![](img/f592bd8f-a4fc-4746-a77f-feb2083f8cab.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f592bd8f-a4fc-4746-a77f-feb2083f8cab.png)'
- en: Animating a clip path
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画剪辑路径
- en: One relatively simple example (from a CSS perspective) of how powerful animations
    can be with SVG is animating a clip path. Using the `polygon` option we just learned
    about, you can animate between two (or more) shapes defined as a `clip-path`.
    If they have the *same number of points*, the browser will smoothly animate between
    positions defined as keyframes in your animation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从CSS的角度来看，SVG中动画剪辑路径的一个相对简单的例子是非常强大的。使用我们刚学到的`polygon`选项，你可以在两个（或更多）被定义为`clip-path`的形状之间进行动画。如果它们有*相同数量的点*，浏览器将平滑地在动画中定义的位置之间进行动画。
- en: 'The following example shows just that. In this example we create a class `stars`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例就展示了这一点。在这个示例中，我们创建了一个类`stars`：
- en: '`stars` has one `animation` property. It references the `@keyframe stars` block
    defined later on in the style sheet.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stars`有一个`animation`属性。它引用了样式表中稍后定义的`@keyframe stars`块。'
- en: The second argument you're already familiar with, `animation-duration`. Once
    again this is set to three seconds.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数你已经熟悉了，`animation-duration`。这次又设置为三秒。
- en: The third property is potentially new to you. The property value `infinite`
    maps to the `animation-iteration-count` property.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个属性对你来说可能是新的。属性值`infinite`映射到`animation-iteration-count`属性。
- en: '`animation-iteration-count` accepts either a number indicating the specific
    number of times an animation should run or the keyword `infinite`, which indicates
    that the animation should play forever.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-iteration-count`接受一个数字，表示动画应该运行的具体次数，或关键字`infinite`，表示动画应该永远播放。'
- en: 'The `@keyframes` follow the same pattern as the previous animation. We have
    equivalent starting and finishing states (0% and 100%). These are defined as a
    polygon `clip-path` that illustrates a star. The mid-point of the animation (`50%`),
    redefines the polygon as a square. Since the number of points needs to be equivalent
    between the states of an animation, this means that we''re defining many more
    than four points to animate between these states:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`@keyframes`遵循与之前动画相同的模式。我们有相同的起始和完成状态（0%和100%）。这些被定义为一个多边形`clip-path`，用于说明一个星星。动画的中点（`50%`）将多边形重新定义为正方形。由于动画状态之间需要等效的点数，这意味着我们需要定义多于四个点来在这些状态之间进行动画：'
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following time-lapse screenshot shows how the animation unfolds over the
    three seconds that it runs. Be sure to run it in a supporting browser to see how
    interesting this effect can be:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下时间间隔截图显示了动画在运行的三秒内是如何展开的。确保在支持的浏览器中运行，看看这种效果有多有趣：
- en: '![](img/19aaa7d0-e34e-42d7-9c8a-ba4621dccb08.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19aaa7d0-e34e-42d7-9c8a-ba4621dccb08.png)'
- en: Animating multiple properties and assigning multiple animations to an element
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时对一个元素进行多个属性的动画和分配多个动画
- en: 'Two more things to note about animations are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动画还有两件事需要注意：
- en: You can animate multiple CSS properties at one time
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以同时对多个CSS属性进行动画
- en: You can also apply multiple animations to the same element
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以将多个动画应用于同一个元素
- en: 'The following code sample shows how these two features work. There are three
    important sections. The first is the single class,  `rect`. It has *two* comma-separated
    arguments for the `animation` property, the animations `box` and `change-color-and-fade`. 
    `box` defines two square `clip-path` properties, one `50` pixels from the edge
    of the rectangle, the other `10` pixels in from the edge. `change-color-and-fade` changes
    the background color from red to blue and the opacity from `.5` to `1`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了这两个功能的工作原理。有三个重要部分。第一个是单个类`rect`。它有两个用于`animation`属性的逗号分隔的参数，即动画`box`和`change-color-and-fade`。`box`定义了两个正方形`clip-path`属性，一个距离矩形边缘`50`像素，另一个距离边缘`10`像素。`change-color-and-fade`将背景颜色从红色变为蓝色，不透明度从`.5`变为`1`：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run in the browser, the animation goes through the following stages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行，动画经历以下阶段：
- en: '![](img/e162bfce-9e69-44cc-bddc-08569c2627f2.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e162bfce-9e69-44cc-bddc-08569c2627f2.png)'
- en: CSS transitions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS过渡
- en: The final CSS property we're going to look at in this chapter is the CSS `transition`
    property. `transition` allows you to define the way that the browser animates
    between changes in property values. Instead of the properties changing immediately,
    they can transition more smoothly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们要看的最后一个CSS属性是CSS `transition`属性。`transition`允许您定义浏览器在属性值更改时的动画方式。属性不会立即改变，而是可以更平滑地过渡。
- en: The following example shows how this works. In it we have a small, single-value
    bar chart that fills up when the user hovers over it, showing imaginary progress
    against a goal.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这是如何工作的。在示例中，我们有一个小的、单值的条形图，当用户悬停在上面时会填充，显示对目标的虚拟进度。
- en: The CSS is full of classes to define the text. You'll notice many properties
    you've learned about throughout this chapter. In addition to those, which you
    should have at least some familiarity with after working with them in this chapter,
    there are classes that define the bar chart, one of which is more interesting
    than the other.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: CSS中充满了用于定义文本的类。您会注意到本章中学到的许多属性。除了这些属性，您在本章中应该对它们有一定的了解之外，还有一些定义条形图的类，其中一个比另一个更有趣。
- en: 'The first, `the-bar`, defines the outline of the bar chart. The second, `fill-the-bar`, 
    defines the *progress* part of the bar. It has no stroke and a green fill. The
    interesting part for our purposes is the `transition` property. `transition` is
    a shorthand property for a group of related `transition-`properties. In this case
    we''re using `transition-property` (`transform`) and `transition-duration` (`3s`).
    This indicates that the browser should watch for changes to the `transform` property
    on this element and transition the changes to that property over three seconds.
    Also in this class we define a `scaleY transform` with a value of `1` and anchor
    the `transform` to the `bottom` of the element with `transform-origin`. We need
    a baseline `scaleY` so the browser has a matching property to animate against. `fill-the-bar:hover`
    changes the scale to `7.5` which, given the way this is configured, fills up the
    bar to `75%` of the goal:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`the-bar`定义了条形图的轮廓。第二个`fill-the-bar`定义了条形图的*进度*部分。它没有描边，填充为绿色。对我们来说有趣的部分是`transition`属性。`transition`是一组相关的`transition-`属性的简写。在这种情况下，我们使用了`transition-property`（`transform`）和`transition-duration`（`3s`）。这表示浏览器应该监视此元素上`transform`属性的更改，并在三秒内过渡到该属性的更改。在这个类中，我们还定义了一个`scaleY
    transform`，值为`1`，并使用`transform-origin`将`transform`锚定到元素的`bottom`。我们需要一个基准的`scaleY`，这样浏览器就有一个匹配的属性来进行动画。`fill-the-bar:hover`将比例改变为`7.5`，根据配置的方式，这将填满条形图的`75%`目标：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run in the browser; the transition grows slowly until it fills the appropriate
    space:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行；过渡效果会慢慢增长，直到填满适当的空间：
- en: '![](img/da3c849a-47d6-4b3b-9915-14ddb28b1bfd.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da3c849a-47d6-4b3b-9915-14ddb28b1bfd.png)'
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You've learned a lot in this chapter. CSS is one of the linchpin technologies
    for making fast, maintainable modern websites and applications, and understanding
    the intersection between SVG and CSS is important.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了很多。CSS是制作快速、易于维护的现代网站和应用的关键技术之一，了解SVG和CSS之间的交集是很重要的。
- en: The chapter started with details about the common use case of using SVG for
    CSS background images, including interesting details about using SVG data URLs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以详细介绍了将SVG用作CSS背景图像的常见用例，包括使用SVG数据URL的有趣细节。
- en: Following that, you learned about SVG sprites and icon sets and how and why
    they can be used in place of the common font icon sets so popular on the web today.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习SVG精灵和图标集，以及它们可以如何以及为什么可以用来替代当今网页上流行的常见字体图标集。
- en: Following that, you learned about styling inline SVG, including detailed ways
    to manipulate the font and the flow of lines of text. Following that, you learned
    about many SVG-specific properties including those controlling the `fill`, `stroke`,
    and text of elements. After that, you learned about some cutting edge compositing
    properties, such as `clip-path` and `mask-image`, which are powerful, even if
    browser support isn't fully there yet.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何对内联SVG进行样式设置，包括详细的操作字体和文本行的方式。接着，您将学习许多控制`fill`、`stroke`和元素文本的SVG特定属性。之后，您将了解一些尖端的合成属性，比如`clip-path`和`mask-image`，尽管浏览器的支持还不完全到位，但它们非常强大。
- en: After that, you learned about using CSS to improve consistency and ease of authoring
    in standalone SVG images.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将学习如何使用CSS来提高独立SVG图像的一致性和编写的便利性。
- en: Finally, you learned about basic CSS animations and transitions with SVG, a
    powerful pattern to add interactivity and movement to your sites and applications.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将学习如何使用基本的CSS动画和过渡效果来增加网站和应用的交互性和动态效果。
- en: Next up, we'll take all that we've learned about getting SVG onto the page and
    making sure it looks right, and we'll add JavaScript to the mix, so we can start
    to interact with SVG in increasingly interesting ways.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们学到的关于将SVG放到页面上并确保它看起来正确的所有知识，加上JavaScript，这样我们就可以开始以越来越有趣的方式与SVG进行交互了。
