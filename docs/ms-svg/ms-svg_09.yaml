- en: Helper Libraries Snap.svg and SVG.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助库Snap.svg和SVG.js
- en: 'We''ve learned a lot about SVG so far in this book. If you''ve made it this
    far, you''re ready to do some serious SVG development, and for that there are
    three ways to go:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本书中已经学到了很多关于SVG的知识。如果你已经走到了这一步，你已经准备好进行一些严肃的SVG开发，对此有三种方法：
- en: Continue doing what we've, mostly, done so far in this book-learn about the
    way the core technologies interact and integrate SVG into your sites or applications,
    as you would in any markup. Manipulate it with JavaScript and CSS and you're ready
    to tackle basically anything. This is a valid approach and is the one I often
    take in my own work.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续做我们在本书中大部分已经做过的事情-了解核心技术如何相互作用并将SVG集成到您的站点或应用程序中，就像您在任何标记中一样。用JavaScript和CSS操纵它，你就可以准备好处理基本上任何事情。这是一个有效的方法，也是我在自己的工作中经常采用的方法。
- en: Use task-specific frameworks and libraries. We've started to look at this a
    little bit with GSAP and Vivus for animation. We'll continue to look at this in
    [Chapter 10](b297a139-f545-435c-9ca2-752987638d15.xhtml), *Working with D3.js*,
    when we look at D3, a powerful visualization framework.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定任务的框架和库。我们已经开始用GSAP和Vivus进行动画的一点探索。我们将在[第10章](b297a139-f545-435c-9ca2-752987638d15.xhtml)中继续探讨这个问题，*使用D3.js*，当我们研究D3，一个强大的可视化框架。
- en: Use general purpose SVG libraries that will help you with a variety of SVG-related
    tasks. SVG was brought into the mainstream of web development on the back of one
    such library, Raphael, and there are current libraries available for you to use
    in your own work. This option is the focus of this chapter.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用的SVG库，它将帮助您处理各种与SVG相关的任务。SVG是在一个名为Raphael的库的支持下进入了Web开发的主流，目前有一些库可供您在自己的工作中使用。这个选项是本章的重点。
- en: As previously mentioned, SVG took many years to gain traction owing to limited
    browser support. A general-purpose SVG library called Raphael.js ([http://dmitrybaranovskiy.github.io/raphael/](http://dmitrybaranovskiy.github.io/raphael/))
    helped to bridge that support gap by offering a very clever **Vector Markup Language**
    (**VML**), [https://docs.microsoft.com/en-us/windows/desktop/vml/web-workshop---specs---standards----introduction-to-vector-markup-language--vml-](https://docs.microsoft.com/en-us/windows/desktop/vml/web-workshop---specs---standards----introduction-to-vector-markup-language--vml-),
    polyfill for an older version of Internet Explorer. It also offered a friendly
    API for dealing with SVG in the browser, which helped people unfamiliar with SVG
    to get started quickly and easily.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，由于浏览器的有限支持，SVG花了很多年时间才获得了广泛的应用。一个名为Raphael.js的通用SVG库通过为较旧版本的Internet Explorer提供了一个非常聪明的**矢量标记语言**(**VML**)的polyfill来弥合了这种支持差距。它还为处理浏览器中的SVG提供了一个友好的API，这有助于那些对SVG不熟悉的人快速、轻松地入门。
- en: 'This chapter deals with two of the most popular successors to Raphael.js:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及两个最受欢迎的Raphael.js的后继者：
- en: '`Snap.svg`: a direct successor to Raphael, being a library authored by the
    author of Raphael.js, Dmitry Baranovskiy ([http://snapsvg.io/](http://snapsvg.io/))'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snap.svg`：是Raphael的直接继承者，由Raphael.js的作者Dmitry Baranovskiy([http://snapsvg.io/](http://snapsvg.io/))编写的库。'
- en: '`svg.js`: another small, lightweight library that offers plenty of powerful
    options for manipulating SVG ([http://svgjs.com/](http://svgjs.com/)[)](http://svgjs.com/)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`svg.js`：另一个小巧、轻量级的库，提供了许多强大的选项来操纵SVG([http://svgjs.com/](http://svgjs.com/))'
- en: The rest of the chapter will look at the basics of each library and will then
    go through some familiar examples, reworked to utilize the power of these general
    purpose SVG tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将介绍每个库的基础知识，然后通过一些熟悉的例子，重新利用这些通用的SVG工具的功能。
- en: We'll start with Snap.svg.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Snap.svg开始。
- en: Working with Snap.svg
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Snap.svg
- en: Snap.svg is an SVG utility library from Adobe authored by Dmitry Baranovskiy.
    It is relatively full-featured, has a friendly, easy-to-explore API and is open
    source.  Development on this library has slowed recently, but it's still a useful
    tool and one you should be aware of if you're exploring a general purpose SVG
    library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Snap.svg是Adobe的SVG实用库，由Dmitry Baranovskiy编写。它功能相对齐全，具有友好、易于探索的API，并且是开源的。最近这个库的开发速度有所放缓，但它仍然是一个有用的工具，如果您正在探索通用的SVG库，您应该意识到它。
- en: Let's get started.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Getting started with Snap.svg
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Snap.svg
- en: 'Snap.svg is available on `npm`, so by far the easiest way to get started with
    `Snap.svg` is to install it using `npm`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Snap.svg可以在`npm`上获得，因此最简单的方法是使用`npm`安装它：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's also available for download directly from the website, [http://snapsvg.io/](http://snapsvg.io/), and
    is also available to download or clone from GitHub, [https://github.com/adobe-webplatform/Snap.svg](https://github.com/adobe-webplatform/Snap.svg).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以直接从网站[http://snapsvg.io/](http://snapsvg.io/)下载，也可以从GitHub[https://github.com/adobe-webplatform/Snap.svg](https://github.com/adobe-webplatform/Snap.svg)下载或克隆。
- en: Once you've done that, it's as easy as including the `snap.svg-min.js` from
    `node_modules` or the downloaded folder, and you're ready to start using Snap.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做到了这一点，只需包含`node_modules`中的`snap.svg-min.js`，或者从下载的文件夹中，你就可以开始使用Snap了。
- en: In this first example, we load Snap into the document and then go through some
    Snap basics loading up the Snap API and manipulating some SVG.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们将Snap加载到文档中，然后通过一些Snap基础知识加载Snap API并操纵一些SVG。
- en: Initially, in this first example, we get a reference to a containing `div`,
    using the ID `#target`. Then we create an instance of Snap, using the `new` keyword
    and storing it in a variable, `S`. There are two arguments passed in, `800` and
    `600`. These represent the width and height of the SVG element.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，在这个第一个例子中，我们获取了一个包含`div`的引用，使用ID`#target`。然后我们使用`new`关键字创建了一个Snap的实例，并将其存储在变量`S`中。传入了两个参数，`800`和`600`。这代表了SVG元素的宽度和高度。
- en: While we will use the variable `S` to represent the `Snap.svg` API in this chapter,
    you can name the variable anything you like as long as you assign the return value
    of the `Snap.svg` constructor to it. There's nothing magical about S, other than
    the fact that it's the conventional variable name that the authors of Snap use
    for their examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用变量`S`来表示`Snap.svg`的API，你可以将变量命名为任何你喜欢的名称，只要你将`Snap.svg`构造函数的返回值分配给它。S并没有什么神奇之处，除了它是Snap作者在他们的示例中使用的传统变量名。
- en: Next we use the Snap utility method `S.appendTo` to add our new SVG element
    into the document, using our `#target` element as the container.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Snap的实用方法`S.appendTo`将我们的新SVG元素添加到文档中，使用我们的`#target`元素作为容器。
- en: Now that the SVG element is on the page, we add two new SVG elements into the
    document to show the basic pattern for adding and manipulating SVG elements with
    Snap. We add a circle and a rectangle. The circle is added with `S.circle`, passing
    in three attributes, the `center x`, the `center y`, and the `radius`. Once the
    circle is added, we call the chained method `attr`, passing in a `fill` and a
    `stroke`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在SVG元素已经在页面上，我们向文档中添加了两个新的SVG元素，以展示使用Snap添加和操作SVG元素的基本模式。我们添加了一个圆和一个矩形。圆是用`S.circle`添加的，传入三个属性，`中心x`、`中心y`和`半径`。一旦圆被添加，我们调用链式方法`attr`，传入`fill`和`stroke`。
- en: Next we call `S.rect` to create a rectangle, passing in `x`, `y`, `width`, and
    `height` arguments and, again, using `attr` to add a `fill` and `stroke`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们调用`S.rect`来创建一个矩形，传入`x`、`y`、`width`和`height`参数，并再次使用`attr`来添加`fill`和`stroke`。
- en: 'This jQuery-like pattern of chaining method calls to manipulate SVG elements
    is the core of your interaction with Snap. If you''ve got experience with that
    style of development, you''ll pick up Snap very quickly. The API is clear and
    logical, so it''s easy to experiment with:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于jQuery的方法链式调用来操作SVG元素是与Snap交互的核心。如果你有这种开发风格的经验，你会很快掌握Snap。API清晰而逻辑，因此很容易进行实验：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running the preceding in a browser produces the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行上述代码会产生以下输出：
- en: '![](img/9f040b3f-f908-4c1c-a61b-75c757ef89a2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f040b3f-f908-4c1c-a61b-75c757ef89a2.png)'
- en: Taking that basic pattern, we can now start to recreate some of the demos we
    did previously, using Snap. Seeing how we transition from core technologies to
    libraries can be instructive and can give you a feel for the library and whether
    or not it feels like something you want to use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种基本模式，我们现在可以开始使用Snap重新创建之前做过的一些演示。从核心技术过渡到库可以很有启发性，可以让你对库有所了解，以及它是否适合你使用。
- en: Animation with Snap
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Snap进行动画
- en: Since animation with SVG is such an important feature of the modern web, Snap
    offers several animation utilities. It also offers the ability to manipulate existing
    SVG elements and not just elements generated by Snap itself (which is something
    SVG.js can't do). This demo takes advantage of both of those features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SVG动画是现代网页的一个重要特性，Snap提供了几个动画工具。它还提供了操作现有SVG元素的能力，而不仅仅是Snap本身生成的元素（这是SVG.js无法做到的）。这个演示利用了这两个功能。
- en: The setup is similar to what we saw in earlier examples of this animation demo.
    We start the demo by obtaining three element references, `doc` for the `document`,
    `canvas` for the parent SVG, and `circle` for the `circle` element. Next, we get
    a reference to the `viewBox` and associated `width`, in order to make some calculations
    about the finishing point of the circle. This new finishing point is stored as
    `newX`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设置与我们之前在这个动画演示的例子中看到的类似。我们通过获取三个元素引用`doc`（文档）、`canvas`（父SVG）和`circle`（圆圈元素）来开始演示。接下来，我们获取`viewBox`的引用和相关的`width`，以便对圆的结束点进行一些计算。这个新的结束点被存储为`newX`。
- en: Next comes the Snap specific features of this example. First, we load up a reference
    to the `circle` element with Snap's API. We do this by passing the variable `circle`,
    a DOM reference to the `circle` element, into Snap. If you've worked a lot with
    jQuery, this might be a familiar pattern for you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是这个例子的Snap特定特性。首先，我们使用Snap的API加载了一个对`circle`元素的引用。我们通过将变量`circle`，一个对`circle`元素的DOM引用，传递给Snap来实现这一点。如果你经常使用jQuery，这可能对你来说是一个熟悉的模式。
- en: 'Once that is done we can use the Snap `animate` method to animate the circle
    across the screen. `animate`, in this instance, takes four arguments:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以使用Snap的`animate`方法来使圆圈在屏幕上移动。在这种情况下，`animate`接受四个参数：
- en: The first is an object indicating the end state of the animation. In this case
    we're animating the `cx` property to the calculated `newX` value.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个是一个对象，指示动画的结束状态。在这种情况下，我们正在将`cx`属性动画到计算出的`newX`值。
- en: Then we pass in the duration of the animation, three seconds in milliseconds.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们传入动画的持续时间，三秒的毫秒数。
- en: After that we pass in the animation easing. Once again we're using bounce easing.
    This is available as part of Snap's `mina` object, which provides built-in easing
    options as well as some other utilities for working with animations.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后我们传入动画缓动。我们再次使用了弹跳缓动。这是作为Snap的`mina`对象的一部分提供的，它提供了内置的缓动选项以及一些其他用于处理动画的实用工具。
- en: 'Finally, we pass in a `callback` function to run after the animation is completed.
    This function changes the fill color to red:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们传入一个`callback`函数，在动画完成后运行。这个函数将填充颜色更改为红色：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In addition to the animation utilities seen in this example, Snap also includes
    other utilities for working with SVG. The next section will illustrate some of
    those utilities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在这个例子中看到的动画工具之外，Snap还包括其他用于处理SVG的工具。下一节将介绍其中一些工具。
- en: Snap.svg utilities
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Snap.svg工具
- en: This example will illustrate a couple of useful Snap utilities available for
    working with SVG. The whole purpose of working with a general-purpose library
    like Snap is to use utility methods such as the following. This example shows
    just two such utilities, but this should be enough to show you the sort of things
    that are available.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将说明一些可用于处理SVG的有用的Snap实用程序。使用通用库如Snap的目的是使用诸如以下的实用方法。这个例子只显示了两个这样的实用程序，但这应该足以向您展示可用的东西的类型。
- en: The beginning of the example is standard `Snap.svg` development. You start by
    getting a reference to the `#target` element. We create a `Snap` variable, `S`,
    and then append it to the `#target` element.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的开始是标准的`Snap.svg`开发。您首先获取对`#target`元素的引用。我们创建一个`Snap`变量`S`，然后将其附加到`#target`元素上。
- en: Once it's in the document, we can use the first of two utilities. It's a single
    line assignment to the variable `bbox`, which returns the bounding box of an SVG
    element, in this case, a circle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它在文档中，我们可以使用两个实用程序中的第一个。这是一个单行赋值给变量`bbox`，它返回SVG元素的边界框，这种情况下是一个圆。
- en: A bounding box is the smallest possible rectangle that can contain a shape (or
    group of shapes).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 边界框是可以包含形状（或一组形状）的最小可能矩形。
- en: Let's look at what happens in this assignment. First we create a new `circle`
    at (`255`, `255`) with a `110` pixel radius. Then we add a `fill` and `stroke`
    so that we can see it on the SVG element. Then we call the `getBbox` method, which
    is stored as `bbox`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个赋值发生了什么。首先，我们在（`255`，`255`）处创建一个新的`circle`，半径为`110`像素。然后我们添加`fill`和`stroke`，以便在SVG元素上看到它。然后我们调用`getBbox`方法，存储为`bbox`。
- en: 'When we `console.log` out the `bbox` variable, we see the following values:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们`console.log`出`bbox`变量时，我们看到以下值：
- en: '![](img/8249c115-1a72-40ab-ad36-ab620620d986.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8249c115-1a72-40ab-ad36-ab620620d986.png)'
- en: As you can see, the return value contains a lot more information than just the
    simple coordinates of the smallest possible rectangle that can contain the element.
    It has that information (the `x`, `y`, `height`, and `width`), but it also has
    several other properties that might be useful if you're manipulating the element
    in relation to another element in an animation, visualization, or dynamic drawing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，返回值包含的信息远不止可以包含元素的最小可能矩形的简单坐标。它包含了这些信息（`x`，`y`，`height`和`width`），但它还有其他几个属性，如果您正在处理元素与动画、可视化或动态绘图中的另一个元素的关系，这些属性可能会很有用。
- en: 'The following list shows the values of the bounding box and what they represent:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了边界框的值及其代表的含义：
- en: '`cx` the *x* value of the center of the box'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cx` - 盒子中心的*x*值'
- en: '`cy` the *y* value of the center of the box'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cy` - 盒子中心的*y*值'
- en: '`h` the height of the box'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h` - 盒子的高度'
- en: '`height` the height of the box'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height` - 盒子的高度'
- en: '`path` the path command for the box'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path` - 盒子的路径命令'
- en: '`r0` the radius of a circle that fully encloses the box'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r0` - 完全包围盒子的圆的半径'
- en: '`r1` the radius of the smallest circle that can be enclosed by the box'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r1` - 可以包含在盒子内的最小圆的半径'
- en: '`r2` the radius of the largest circle that can be enclosed'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r2` - 可以包含的最大圆的半径'
- en: '`vb` the box as a `viewBox` command'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vb` - 作为`viewBox`命令的盒子'
- en: '`w` the width of the box'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` - 盒子的宽度'
- en: '`width` the width of the box'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width` - 盒子的宽度'
- en: '`x2` the *x* value of the right side of the box'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x2` - 盒子右侧的*x*值'
- en: '`x` the *x* value of the left side of the box'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` - 盒子左侧的*x*值'
- en: '`y2` the *y* value of the bottom edge of the box'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y2` - 盒子底边的*y*值'
- en: '`y` the *y* value of the top edge of the box'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y` - 盒子顶边的*y*值'
- en: That's a very useful, but possibly unexceptional utility method. As you'll see
    in the SVG.js section, a bounding box is an important and common concept when
    working with SVG.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用但可能普通的实用方法。正如你将在SVG.js部分看到的，边界框是在使用SVG时一个重要且常见的概念。
- en: The next example utility is a little more interesting. Let's take a look at
    how it works.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个实用程序示例更有趣一些。让我们看看它是如何工作的。
- en: 'To do so, we first create a `path` that represents a stylized letter R. You
    saw this R and the associated `path` previously as part of one of our animation
    examples. Once the letter R is inserted into the document, we add a `fill` and
    `stroke` to it, and then apply a transformation to it in order to center it on
    the `circle` we previously created. The end result is shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先创建一个代表风格化字母R的`path`。您之前在我们的动画示例中看到了这个R和相关的`path`。一旦字母R被插入文档中，我们为其添加`fill`和`stroke`，然后对其进行变换，以便将其居中放置在我们之前创建的`circle`上。最终结果如下截图所示：
- en: '![](img/84fe1b92-8341-42d1-8b4e-02dddb89787b.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84fe1b92-8341-42d1-8b4e-02dddb89787b.png)'
- en: Once the path is inserted, we call `console.log` again, with another utility
    method,  `path.getTotalLength()` passed in as an argument. `path.getTotalLength()`
    does what it says on the tin — it returns the total length of the referenced path
    element.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦路径被插入，我们再次调用`console.log`，使用另一个实用方法`path.getTotalLength()`作为参数传入。`path.getTotalLength()`就像它的名字一样
    - 它返回引用路径元素的总长度。
- en: 'If you were, for example, animating along the path over a defined length of
    time, getting the length of the path would be a vital metric. As the following
    screenshot shows, this utility provides that powerful metric with very little
    fuss:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您正在沿着路径在一定时间长度内进行动画，获取路径的长度将是一个重要的度量。正如下面的截图所示，这个实用程序提供了这个强大的度量，而几乎没有麻烦：
- en: '![](img/4fbe144a-9612-4ea8-a469-54be1507c26f.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fbe144a-9612-4ea8-a469-54be1507c26f.png)'
- en: 'The entirety of the code just described is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚描述的整个代码如下：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we've taken a look at some Snap utilities, let's look at Snap's events
    system, which allows you to work with SVG elements in an interactive way while
    still staying tightly within the confines of the Snap API.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了一些Snap实用程序，让我们来看看Snap的事件系统，它允许您以交互方式使用SVG元素，同时仍然紧密地遵循Snap API的限制。
- en: Snap.svg events
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Snap.svg事件
- en: While you may already have a handle on managing events manually using `Element.addEventListener`
    or are already using something like jQuery to handle your events, it's worth noting
    that Snap offers some event utilities of its own. This allows you to cut down
    on external dependencies if you're doing very focused work with SVG. It also allows
    you to skip over any of the quirks that a library like jQuery offers when working
    with SVG elements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能已经掌握了使用`Element.addEventListener`手动管理事件，或者已经使用类似jQuery的东西来处理事件，但值得注意的是，Snap提供了一些自己的事件工具。这使您可以减少外部依赖，如果您正在专注于SVG的工作。它还允许您跳过像jQuery这样的库在处理SVG元素时提供的任何怪癖。
- en: The following example is a familiar one modified to show how Snap.svg events
    work. In this example, we're once again adding `click` event handlers to a blank
    SVG canvas and inserting random sized circles into the SVG element at the point
    of the click. Using Snap to implement this demo is very similar to what you saw
    previously, but it has some conveniences that are worth noting, and it illustrates
    the straightforward way that Snap handles events.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是一个熟悉的示例，修改后显示了Snap.svg事件的工作原理。在这个示例中，我们再次向空白的SVG画布添加`click`事件处理程序，并在点击点将随机大小的圆插入SVG元素。使用Snap来实现这个演示与您之前看到的非常相似，但它有一些值得注意的便利，并且说明了Snap处理事件的简单方式。
- en: The example starts off by getting access to the `#target` element, setting `height`
    and `width` variables, and then creating an instance of Snap appended to the `#target`
    element and stored in the standard Snap variable, `S`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例首先获取`#target`元素的访问权限，设置`height`和`width`变量，然后创建一个附加到`#target`元素并存储在标准Snap变量`S`中的Snap实例。
- en: Once we have Snap loaded, we chain a series of method calls to add a circle
    using the `S.circle` method, set the `fill` using the `attr` method, and then
    add a click event handler to the element using Snap's `click` event utility.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了Snap，我们将一系列方法调用链接在一起，使用`S.circle`方法添加一个圆，使用`attr`方法设置`fill`，然后使用Snap的`click`事件工具为元素添加点击事件处理程序。
- en: 'The `callback` function called when the user clicks on the SVG element is almost
    the same as the vanilla JS Version, although it does use the Snap method `S.circle`
    to insert a circle element using the familiar randomized parameters `fill`, `radius`,
    `newX`, and `newY`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击SVG元素时调用的`callback`函数与普通JS版本几乎相同，尽管它使用Snap方法`S.circle`插入一个圆元素，使用熟悉的随机参数`fill`，`radius`，`newX`和`newY`：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you're used to working with jQuery or other libraries that follow a similar
    pattern, then you should be able to pick up working with Snap's event utilities
    quickly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯于使用jQuery或其他遵循类似模式的库，那么您应该能够快速掌握Snap的事件工具。
- en: Custom data visualization with Snap.svg
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Snap.svg进行自定义数据可视化
- en: The final example using `Snap.svg` shows how it can be used to do custom data
    visualizations. This will show many features of `Snap.svg` in action and will
    provide a final, full look at the library.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个使用`Snap.svg`的示例显示了它如何用于进行自定义数据可视化。这将展示`Snap.svg`的许多功能，并提供对该库的最终全面了解。
- en: This example will once again generate a visualization showing the positive/negative
    delta of home runs hit per year versus the average home runs hit per year by David
    Ortiz of the Boston Red Sox per year over his Red Sox career.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将再次生成一个可视化，显示大卫·奥尔蒂兹在波士顿红袜队职业生涯中每年击出的全垒打的正负增量与每年击出的平均全垒打数之间的对比。
- en: Since we've already seen this visualization, in this section we'll only focus
    on the areas where `Snap.svg` is being used and not on every line of the script.
    If you need a refresher on the hows and whys of data visualization itself and
    how the metrics are calculated, please look back at [Chapter 8](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml), *SVG
    Animation and Visualizations*, for a full explanation of the entire script.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了这个可视化，在本节中我们将只关注使用`Snap.svg`的地方，而不是脚本的每一行。如果您需要对数据可视化本身的方法和原因以及如何计算指标进行复习，请回顾[第8章](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml)，“SVG动画和可视化”，以获得整个脚本的完整解释。
- en: 'The first file you''ll see is the HTML file, which is similar to the original
    version of this visualization. The only real difference is including the `Snap.svg`
    source file from `node_modules`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到的第一个文件是HTML文件，它与此可视化的原始版本类似。唯一的真正区别是包括从`node_modules`中的`Snap.svg`源文件：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Looking at the source of `scripts.js`, the `viz()` function is structurally
    the same, but has some Snap-related differences that you'll want to notice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`scripts.js`的源代码，`viz()`函数在结构上是相同的，但有一些与Snap相关的差异，您会想要注意到。
- en: The `data` variable is exactly the same and is truncated here to make the `viz()`
    function slightly easier to read. See [Chapter 8](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml), *SVG
    Animation and Visualizations*, or the source code to see the full data set.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`变量完全相同，并在此处截断，以使`viz()`函数稍微易于阅读。请参阅[第8章](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml)，“SVG动画和可视化”，或查看源代码以查看完整的数据集。'
- en: Following the `data` variable, some of the interesting stuff starts with the
    `S` variable. As you saw previously, `S` is an instance of `Snap.svg` and that's
    going to be the interface through which we do a lot of our work. Following that,
    there aren't any changes between this version and the original version of this,
    until we use a reference to the Snap reference to the SVG element's DOM node,
    `S.node`, to access the SVG element's `viewBox`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data`变量之后，一些有趣的东西从`S`变量开始。正如您之前看到的，`S`是`Snap.svg`的一个实例，这将是我们进行大部分工作的接口。在那之后，在这个版本和原始版本之间没有任何变化，直到我们使用对SVG元素的DOM节点的Snap引用`S.node`来访问SVG元素的`viewBox`。
- en: Following that, the biggest difference you'll notice is the ability to use the
    Snap convenience methods, `S.rect`, `S.line`, and `S.text` (all paired with `S.attr`)
    to add our lines, boxes, and text elements to the screen. We also use `S.addClass`
    to add a CSS class to one of our lines.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会注意到的最大的区别是能够使用Snap的便利方法`S.rect`、`S.line`和`S.text`（都与`S.attr`配对）将我们的线条、方框和文本元素添加到屏幕上。我们还使用`S.addClass`将CSS类添加到我们的线条中。
- en: 'Because all of these methods exist in `Snap.svg`, the biggest difference between
    this example and our JavaScript-only example is the absence of our own, hand-rolled
    convenience methods. Since Snap provides so many convenient features, we don''t
    need to provide them ourselves. Which is great in and of itself, and, of course,
    Snap includes many more convenience methods than `S.rect`, `S.line`, `S.text`,
    and `S.attr`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有这些方法都存在于`Snap.svg`中，这个例子和我们仅使用JavaScript的例子之间最大的区别是我们自己手动编写的便利方法的缺失。由于Snap提供了许多便利功能，我们不需要自己提供。这本身就很棒，当然，Snap包括的便利方法远远多于`S.rect`、`S.line`、`S.text`和`S.attr`。
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we've taken a good look at `Snap.svg` and hopefully given you a feel
    for what it is like to work with, let's take a look at another `helper` library,
    the appropriately named SVG.js.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经仔细研究了`Snap.svg`，并希望让你感受到与它一起工作的感觉，让我们再看看另一个`helper`库，名为SVG.js。
- en: Working with SVG.js
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG.js
- en: SVG.js was created by Wout Fierens and is currently maintained by Ulrich-Matthias
    Schäfer, Jon Ronnenberg, and Rémi Tétreault. It's designed to be lightweight and
    fast, and to be a friendly interface for working with SVG. It's more actively
    maintained than `Snap.svg`, so it's got that going for it. As of the time of writing,
    the most recent code was added to the project within the past two weeks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SVG.js是由Wout Fierens创建的，目前由Ulrich-Matthias Schäfer、Jon Ronnenberg和Rémi Tétreault维护。它被设计成轻量级和快速，并且是一个友好的SVG工作界面。它的维护活跃度比`Snap.svg`更高，所以它有这个优势。在撰写本文时，最近的代码是在过去两周内添加到项目中的。
- en: Getting started with SVG.js
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用SVG.js
- en: 'Like `Snap.svg`, SVG.js is available on `npm`, so the easiest way to get started
    with SVG.js is to install it using `npm`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Snap.svg`一样，SVG.js也可以在`npm`上获得，因此使用`npm`安装SVG.js是最简单的方法：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Make sure you install `svg.js` with `npm` and not `svg.js`. Both work and both
    point to the correct project. `svg.js` is, however, out of date because the official
    package is `svg.js`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用`npm`安装`svg.js`而不是`svg.js`。两者都可以使用并且都指向正确的项目。然而，`svg.js`已经过时，因为官方包是`svg.js`。
- en: It's also available for download directly from the website [http://svgjs.com/installation/#download](http://svgjs.com/installation/#download).
    It is also available to download or clone from GitHub, [http://svgjs.com/](http://svgjs.com/) and
    is available on `cdnjs`[.](http://snapsvg.io/)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以直接从[http://svgjs.com/installation/#download](http://svgjs.com/installation/#download)下载。也可以从GitHub的[http://svgjs.com/](http://svgjs.com/)下载或克隆，并且可以在`cdnjs`[.](http://snapsvg.io/)上找到。
- en: Once you've done that, it's as easy as including the `svg.min.js` from `node_modules` or
    the downloaded folder, and you're ready to start using SVG.js.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做到了，只需包含`node_modules`或下载文件夹中的`svg.min.js`，你就可以开始使用SVG.js了。
- en: This first example repeats the earlier blue circle/green square demo. The convention
    with SVG.js, as shown in their demos, is to use a variable, `draw`, to hold the
    loaded instance of SVG.js that you work with.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个例子重复了之前的蓝色圆/绿色方块演示。SVG.js的约定，如他们的演示所示，是使用一个变量`draw`来保存你要使用的SVG.js的加载实例。
- en: To create an instance of SVG.js, you pass in a reference to a target HTML element
    and SVG.js inserts a loaded SVG element into the targeted element, ready for you
    to work with. You then chain a method, `SVG.size`, which will set the size of
    the newly created SVG element.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建SVG.js的实例，你需要传入一个目标HTML元素的引用，SVG.js会将一个加载好的SVG元素插入到目标元素中，准备让你使用。然后你可以链式调用`SVG.size`方法，它会设置新创建的SVG元素的大小。
- en: While we will use the variable `draw` to represent the SVG.js API in this chapter,
    you can name the variable anything you like. As long as you assign the return
    value of the SVG.js constructor to it, any variable name will work. There's nothing
    specifically magical about `draw`, other than the fact that it's the conventional
    variable name that the authors of SVG.js use for their examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用变量`draw`来表示SVG.js API，你可以用任何你喜欢的变量名。只要将SVG.js构造函数的返回值分配给它，任何变量名都可以使用。`draw`并没有什么特别神奇的地方，除了它是SVG.js作者在他们的示例中使用的传统变量名。
- en: The same is `true` of `Snap.svg` and the variable `S`. These are just conventions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Snap.svg`和变量`S`也是如此。这些只是约定。'
- en: SVG.js isn't designed to work with an existing SVG element, so you have to slightly
    change your approach if you're used to getting a reference to an existing SVG
    element and then manipulating it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: SVG.js并不是为了与现有的SVG元素一起工作而设计的，因此如果你习惯于获取现有SVG元素的引用然后对其进行操作，你必须稍微改变你的方法。
- en: Once we have a reference to `draw` and our SVG element is added to the page,
    we can start to manipulate the SVG element, adding our square and circle.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了对`draw`的引用并且我们的SVG元素添加到页面上，我们就可以开始操纵SVG元素，添加我们的正方形和圆形。
- en: Looking at the example of the circle, we call the clearly named method `draw.circle` 
    to create a circle. `draw.circle` accepts *one* argument, the *radius* of the
    circle.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看看圆的例子，我们调用了名为`draw.circle`的方法来创建一个圆。`draw.circle`接受*一个*参数，即圆的*半径*。
- en: Interestingly, all of the other attributes are manipulated with the familiar
    (from jQuery and Snap) `attr` method. I think this is a peculiar choice since
    a circle with just a radius isn't very useful. The same goes for `draw.rect`,
    which requires the height and width of the rectangle as arguments and then does
    everything else as attributes with `attr`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，所有其他属性都是用熟悉的（来自jQuery和Snap的）`attr`方法进行操作。我认为这是一个奇怪的选择，因为只有半径的圆并不是很有用。对于`draw.rect`也是一样，它需要矩形的高度和宽度作为参数，然后使用`attr`作为其他属性。
- en: 'This syntax works just fine. But it is interesting that the attributes are
    spread across two methods:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法完全有效。但有趣的是属性分布在两个方法中：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Animation with SVG.js
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG.js动画
- en: Now that we've seen the basic example of inserting elements into the page, let's
    continue the same pattern we followed with `Snap.svg` and look at how to create
    an animation with SVG.js.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了将元素插入页面的基本示例，让我们继续遵循与`Snap.svg`相同的模式，并看看如何使用SVG.js创建动画。
- en: 'We need one more dependency to get animations running properly in SVG.js, `svg.easing.js`.
    This is a library of easing functions that work with SVG animations:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个依赖项才能在SVG.js中正确运行动画，`svg.easing.js`。这是一个与SVG动画一起使用的缓动函数库：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Include that after you include the main SVG.js file and you're ready to go.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含主SVG.js文件之后包含它，然后您就可以开始了。
- en: Getting started with this example, we create several variables to use throughout
    the animation, `width`, `height`, `cx`, `cy`, and `radius`. You saw these previously
    and they map to properties of SVG elements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用这个例子，我们创建了几个变量来在整个动画中使用，`width`，`height`，`cx`，`cy`和`radius`。您之前看到过这些，它们映射到SVG元素的属性。
- en: Then we create our SVG.js instance, using the `height` and `width` values as
    arguments, and store it in the `draw` variable. After that we create the `circle` element
    we will animate, by calling `draw.circle` with the `radius` variable as the sole
    argument. We then call `attr` with a blue `fill` value and the `cx` and `cy` variables
    as values for the `cx` and `cy` attributes respectively. This creates the blue
    circle in the correct spot on the SVG element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了我们的SVG.js实例，使用`height`和`width`值作为参数，并将其存储在`draw`变量中。之后我们通过调用`draw.circle`创建了我们将要进行动画的`circle`元素，参数是`radius`变量。然后我们调用`attr`，传入蓝色的`fill`值和`cx`和`cy`变量作为`cx`和`cy`属性的值。这在SVG元素上正确的位置创建了蓝色的圆。
- en: Then we calculate the `newX` variable. We then animate the circle to that new
    value with the SVG.js method `circle.animate`. The `animate` method takes three
    arguments, `3000`, the length of the animation, `SVG.easing.bounce`, the easing
    function to use (from `svg.easing.js`), and `1000`, the animation delay.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们计算了`newX`变量。然后我们使用SVG.js方法`circle.animate`将圆形动画到新值。`animate`方法接受三个参数，`3000`，动画的长度，`SVG.easing.bounce`，要使用的缓动函数（来自`svg.easing.js`），和`1000`，动画延迟。
- en: Next up there is a chained manipulation method, `center`, which, in this example,
    indicates the type of animation to perform. `center`, by itself, moves an element's
    center to the new `(x,y)` coordinates passed into it. Chaining it with `animate`
    means that you will smoothly animate between the two states. In our example, `center`
    takes the `newX` and original `cy` variables as arguments, which gives us our
    new horizontal placement while retaining our original vertical placement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个链式操作方法，`center`，在这个例子中，表示要执行的动画类型。`center`本身将元素的中心移动到传入的新`(x,y)`坐标。将其与`animate`链接意味着您将在两个状态之间平滑地进行动画。在我们的例子中，`center`将`newX`和原始`cy`变量作为参数，这为我们提供了新的水平放置位置，同时保留了原始的垂直放置位置。
- en: 'Finally, to illustrate an animation `callback` method, we use the method `after`,
    which allows us to run a function after the animation has completed. Here we simply
    change the color of the circle with the `attr` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了说明动画`callback`方法，我们使用`after`方法，它允许我们在动画完成后运行一个函数。在这里，我们只是使用`attr`方法改变了圆的颜色：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we've seen in these two examples, there are some quirks in the SVG.js API.
    Since the quirks are consistent, like setting properties in two chained methods,
    you can very quickly get used to them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这两个示例中看到的，SVG.js API中有一些怪癖。由于这些怪癖是一致的，比如在两个链接的方法中设置属性，您可以非常快速地适应它们。
- en: SVG.js utilities
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG.js实用程序
- en: Like `Snap.svg`, SVG.js has a suite of utility functions to help you work with
    SVG. Some of them are really great. This example shows how many of them work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 像`Snap.svg`一样，SVG.js有一套实用函数，可以帮助您处理SVG。其中一些确实很棒。这个例子展示了其中许多函数的工作原理。
- en: To kick off this example we create a loaded SVG.js variable, draw, and pass
    in `800`, `600` for the `height` and `width`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个例子，我们创建了一个加载了SVG.js变量`draw`，并传入`800`，`600`作为`height`和`width`。
- en: Starting off immediately with some utilities, we call `draw.viewbox()` to get
    the `viewBox` of the SVG element. If you remember the visualization example done
    with `Snap.svg`, you'll recall that we had to navigate multiple properties to
    access the `viewBox` in Snap. There was no convenience method at all, just a property
    of the DOM Node that represented the SVG element.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 立即开始使用一些实用程序，我们调用`draw.viewbox()`来获取SVG元素的`viewBox`。如果您还记得使用`Snap.svg`完成的可视化示例，您会记得我们必须导航多个属性才能访问`Snap`中的`viewBox`。根本没有方便的方法，只是表示SVG元素的DOM节点的属性。
- en: 'Here we have a convenience method that returns it directly:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个方便的方法直接返回它：
- en: '![](img/6299d61f-3d66-43d0-afcf-f28483706ef6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6299d61f-3d66-43d0-afcf-f28483706ef6.png)'
- en: 'Next we load up a variable, `rect` with a `100` by `100` rectangle at (`100`,
    `100`) `console.log` out `rect.bbox()`, which returns the bounding box of the
    rectangle. As you can see in the following screenshot, it has fewer properties
    than the `Snap.svg` example of a bounding box, but it remains useful with all
    of the standard properties you would need to interact cleanly with this element:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`rect`加载一个`100`乘`100`的矩形，位于(`100`, `100`)，然后`console.log`出`rect.bbox()`，它返回矩形的边界框。正如您在下面的截图中所看到的，它的属性比`Snap.svg`示例的边界框要少，但它仍然具有所有您需要与该元素进行干净交互的标准属性：
- en: '![](img/a880d18b-7513-47c9-b13a-4c2fab5aee8d.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a880d18b-7513-47c9-b13a-4c2fab5aee8d.png)'
- en: One very useful utility related to the standard bounding box is illustrated
    next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个非常有用的与标准边界框相关的实用程序被说明了。
- en: First, we transform the rectangle using SVG.js' `transform` method, rotating
    it by 125 degrees. `transform` is a `getter `/ `setter` that will return the current
    transformation value when called without arguments and will set the value when
    called with arguments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用SVG.js的`transform`方法转换矩形，将其旋转125度。`transform`是一个`getter`/`setter`，当没有参数调用时，将返回当前的转换值，当使用参数调用时，将设置该值。
- en: 'Once we''ve transformed the `rect` rectangle, we `console.log` out the return
    value of `rect.rbox()`, which returns a bounding box that represents a visual
    representation of the element which includes all transformations*. *This will
    save you a lot of coding if you''re working with transformed elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们转换了`rect`矩形，我们就会`console.log`出`rect.rbox()`的返回值，它返回一个表示元素的可视表示的边界框，其中包括所有的变换。*如果你正在处理变换后的元素，这将节省你大量的编码工作：
- en: '![](img/0c7752a6-c0b5-4358-b450-07eeb98ada5d.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c7752a6-c0b5-4358-b450-07eeb98ada5d.png)'
- en: 'The next method, `data`, works just like the jQuery data method. Called as
    a `setter`, `rect.data({"data":"storing arbitrary data"}),`, `data` sets arbitrary
    data on an object, stored under a user-supplied label. Called as a `getter`, with
    the label passed in as an argument, `rect.data("data")`, it returns the value
    of the labeled data:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的方法`data`的工作方式与jQuery的data方法完全相同。作为`setter`调用时，`rect.data({"data":"storing
    arbitrary data"}),`，`data`在对象上设置任意数据，存储在用户提供的标签下。作为`getter`调用时，传入标签作为参数，`rect.data("data")`，它返回标记数据的值：
- en: '![](img/94970048-f07a-47e9-bccc-ce0454dc37b9.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94970048-f07a-47e9-bccc-ce0454dc37b9.png)'
- en: The next utility method allows you to adjust the stack of SVG elements. Unlike
    absolutely positioned HTML elements, which have an explicit stacking order (z-index),
    SVG elements are layered based on their appearance in the DOM. Elements that are
    later in the DOM appear to sit on top of elements that appear earlier in the DOM.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个实用方法允许你调整SVG元素的堆栈。与绝对定位的HTML元素不同，它们具有显式的堆叠顺序（z-index），SVG元素是基于它们在DOM中的出现顺序进行分层的。在DOM中后出现的元素似乎位于先出现的元素的顶部。
- en: The next code block shows how you can adjust this stacking order with SVG.js
    utilities.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块展示了如何使用SVG.js实用程序调整这个堆叠顺序。
- en: 'First, we create two squares, a green square and then a blue square. When they
    appear on the screen initially, they look as shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建两个正方形，一个绿色的正方形，然后是一个蓝色的正方形。当它们最初出现在屏幕上时，它们看起来如下截图所示：
- en: '![](img/fa7a2182-d20b-4d0a-b96e-b4eb155f4280.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa7a2182-d20b-4d0a-b96e-b4eb155f4280.png)'
- en: 'Then, inside a one second timeout, we call the `back()` method, which sends
    the element to the back of the stack. After that, the squares look as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在一秒的超时内，我们调用`back()`方法，将元素发送到堆栈的底部。之后，正方形看起来如下：
- en: '![](img/0181a282-3e7c-48b0-980c-d486a87e6ce8.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0181a282-3e7c-48b0-980c-d486a87e6ce8.png)'
- en: 'Now that we have two squares on the screen, it''s time to look at one final,
    super useful, bounding box related utility. If you call `first.bbox().merge` and
    pass in `second.bbox()` as the argument, you get a combined bounding box. This
    is incredibly useful if you''re working with multiple elements that are not part
    of a structured SVG group:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在屏幕上有两个正方形，是时候看一下最后一个非常有用的边界框相关实用程序了。如果你调用`first.bbox().merge`并将`second.bbox()`作为参数传入，你将得到一个合并的边界框。如果你正在处理不属于结构化SVG组的多个元素，这将非常有用：
- en: '![](img/590dc8e3-adcd-40c6-86f2-d5f84c63aa91.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/590dc8e3-adcd-40c6-86f2-d5f84c63aa91.png)'
- en: 'Here is the entire code sample:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个代码示例：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: SVG.js events
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG.js事件
- en: SVG.js also has event handling utilities. The following example will illustrate
    the very familiar event handling pattern provided by SVG.js.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: SVG.js还具有事件处理工具。下面的示例将说明SVG.js提供的非常熟悉的事件处理模式。
- en: Once again, we're illustrating event handling by binding `click` events to a
    function that inserts random-sized circles with random fills on the canvas. This
    will also illustrate one nice usage of the SVG.js `front()` method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次通过将`click`事件绑定到一个函数来说明事件处理，该函数在画布上插入随机大小的圆和随机填充。这也将说明SVG.js `front()`方法的一个很好的用法。
- en: The example starts off by creating the `draw` variable, setting its height and
    width and then creating a `circle` variable with an SVG.js enhanced `circle` element.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 示例从创建`draw`变量开始，设置其高度和宽度，然后创建一个带有SVG.js增强的`circle`元素的`circle`变量。
- en: After that, we bind a `click` event to the circle, which creates the randomly-sized/filled
    circle element using the event utility `circle.click`. It's straightforward. Like
    the `Snap.svg` example or examples from earlier versions of jQuery, you pass in
    the `callback` method as an argument to `click` and that's all it takes to bind
    your events properly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将`click`事件绑定到圆上，使用事件工具`circle.click`创建随机大小/填充的圆元素。这很简单。就像`Snap.svg`示例或早期版本的jQuery示例一样，你将`callback`方法作为参数传递给`click`，这就是正确绑定事件所需的全部内容。
- en: Inside the `callback`, we use `draw.circle` to create our circles with the random
    values generated every time the function runs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`callback`中，我们使用`draw.circle`来创建我们的圆，每次函数运行时都会生成随机值。
- en: 'The one nice bonus of using SVG.js here is that you can always ensure that
    the clickable circle is at the top of the stack by calling `circle.front()` after
    every circle is added. Otherwise, it could eventually be buried by other elements
    appearing on top of it because they were inserted later on in the DOM:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用SVG.js的一个好处是，你可以通过在每个圆添加后调用`circle.front()`来确保可点击的圆始终位于堆栈的顶部。否则，它最终可能会被其他在DOM中后插入的元素埋没，因为它们出现在它的上面：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Custom data visualization with SVG.js
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG.js进行自定义数据可视化
- en: The final example in this chapter is another example of doing a custom data
    visualization. We're going to once again revisit the visualization representing
    David Ortiz's home runs over his career as a member of the Boston Red Sox.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个示例是另一个自定义数据可视化的示例。我们将再次回顾代表大卫·奥尔蒂兹作为波士顿红袜队成员的职业生涯中的全垒打的可视化。
- en: Since we've seen this multiple times, we can simply focus on the ways that SVG.js
    can help us do this work.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了这个多次，我们可以简单地专注于SVG.js如何帮助我们完成这项工作。
- en: 'The first file you''ll see is the HTML file. The only differences between this
    and the vanilla JS Version are the inclusion of the SVG.js source file from `node_modules`
    and the absence of a base SVG element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到的第一个文件是HTML文件。与纯JS版本之间唯一的区别是包含了来自`node_modules`的SVG.js源文件，以及没有基本SVG元素：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `viz()` function is similar to what we saw with the `Snap.svg` Version.
    Once again we've clipped the data object for readability.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`viz()`函数与`Snap.svg`版本中看到的类似。再次，我们为了可读性对数据对象进行了剪裁。'
- en: Following that there's the familiar pattern for working with SVG.js. We set
    `width` and `height` variables and then create the `draw` SVG.js instance using
    the `width` and `height` variables as the arguments.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是使用SVG.js的熟悉模式。我们设置`width`和`height`变量，然后使用`width`和`height`变量作为参数创建`draw`
    SVG.js实例。
- en: The first place where SVG.js comes into play is the easy-to-use `viewBox()`
    method in the `DOMContentLoaded callback` function, which returns the SVG element's
    `viewBox`. We use this variable to calculate multiple variables used in the visualization.
    After more than 20 lines of creating familiar variables (see [Chapter 8](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml),* SVG
    Animation and Visualizations*, for a refresher on what each of these does), we
    draw some boxes, we draw some lines, and we add some text.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: SVG.js首次发挥作用的地方是`DOMContentLoaded回调`函数中易于使用的`viewBox()`方法，该方法返回SVG元素的`viewBox`。我们使用这个变量来计算可视化中使用的多个变量。在创建了超过20行熟悉变量之后（请参阅[第8章](c444b4d6-9f5d-40f5-9de3-e3b72235098d.xhtml)，*SVG动画和可视化*，以便了解每个变量的作用），我们绘制了一些框，画了一些线，并添加了一些文本。
- en: Let's look at an example of how SVG.js can help with each of these.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个SVG.js如何帮助解决这些问题的例子。
- en: Drawing boxes allows us to expose some nice convenience methods that SVG.js
    offers as a replacement to setting properties in `attr`. `draw.rect` is called
    the same as before, passing in the calculated width and height for each box. Then,
    we chain three more method calls to it: `attr` is used to set the `x` and `y`
    and then, as an illustration of their availability, we also use two convenience
    methods, `fill` and `stroke`, to set the `fill` and `stroke` directly. It's quite
    possible to simply set everything as an argument to `attr`, but if you prefer
    to chain method calls in this way, it's a nice option for you to be able to call
    `fill` and `stroke` to set those properties.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制框允许我们暴露一些SVG.js提供的便利方法，作为`attr`中属性设置的替代。`draw.rect`的调用方式与以前相同，传入每个框的计算宽度和高度。然后，我们对其进行了三次方法调用：`attr`用于设置`x`和`y`，然后，作为它们可用性的说明，我们还使用了两个便利方法`fill`和`stroke`，直接设置了`fill`和`stroke`。完全可以将所有内容设置为`attr`的参数，但如果您喜欢以这种方式链接方法调用，那么调用`fill`和`stroke`来设置这些属性是一个不错的选择。
- en: Drawing text introduces a new method, `draw.plain`. There is a `draw.text` method,
    but `draw.text` is designed to work with larger blocks of text and therefore introduces `tspan`
    elements into the mix to help control flow and line breaks. That's actually very
    clever and is a useful option for many situations where you're working with long
    blocks of text in SVG since everything to do with flow and line breaks has to
    be handled manually. In those situations, having multiple elements to work with
    is great.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制文本引入了一个新方法`draw.plain`。有一个`draw.text`方法，但`draw.text`设计用于处理更大的文本块，因此引入了`tspan`元素来帮助控制流和换行。这实际上非常聪明，对于许多情况下需要处理SVG中的长文本块的情况来说，这是一个有用的选择，因为一切与流和换行有关的事情都必须手动处理。在这些情况下，有多个元素可供使用是很好的。
- en: '`draw.plain`, however, is perfect for our needs here as we''re only interested
    in individual text elements. To use it, we call the `draw.plain`, pass in our
    concatenated string as an argument, and then set the `(x,y)` coordinates using
    our good friend `attr`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`draw.plain`非常适合我们这里的需求，因为我们只对单个文本元素感兴趣。要使用它，我们调用`draw.plain`，将我们连接的字符串作为参数传入，然后使用我们的好朋友`attr`设置`(x,y)`坐标。
- en: 'Drawing lines requires four initial arguments, the starting `(x,y)` and the
    finishing `(x,y)`. Once we provide those values as calculated by the rest of the
    `viz()` function, we can do things like add a stroke, via `draw.attr` (as in this
    example) or `draw.stroke` (if you prefer), or add a class using the convenience
    method `draw.addClass`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线需要四个初始参数，起始`(x,y)`和结束`(x,y)`。一旦我们提供了`viz()`函数的其余部分计算出的这些值，我们就可以执行诸如添加描边之类的操作，通过`draw.attr`（就像这个例子中一样）或`draw.stroke`（如果您喜欢），或者使用便利方法`draw.addClass`添加类。
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has provided you with a rapid-fire introduction to two separate
    libraries for working with SVG, `Snap.svg` and SVG.js. Doing the same, familiar
    tasks you previously tackled in vanilla JS in the two libraries has allowed you
    to see the differences between doing these SVG manipulations with vanilla JS and
    doing them with a library. You've also been able to compare the two libraries
    themselves across similar tasks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了两个用于处理SVG的独立库`Snap.svg`和SVG.js的快速介绍。在这两个库中，使用相同的熟悉任务，您可以看到使用原始JS和使用库进行这些SVG操作之间的区别。您还可以比较两个库在类似任务上的差异。
- en: Overall, you've learned a number of different topics with these two libraries,
    including how to get started, how to animate elements, how to handle events, and
    how to do custom data visualizations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，通过这两个库，您学到了许多不同的主题，包括如何入门，如何为元素添加动画，如何处理事件，以及如何进行自定义数据可视化。
- en: Now that we've learned about general purpose libraries, we're going to take
    a look at one final SVG library with a very specific purpose, D3.js. D3 is used
    for heavy duty data visualizations and is one of the most powerful tools out there
    for working with SVG.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了通用库，我们将最后看一下一个非常特定目的的SVG库，D3.js。D3用于重型数据可视化，并且是处理SVG的最强大的工具之一。
