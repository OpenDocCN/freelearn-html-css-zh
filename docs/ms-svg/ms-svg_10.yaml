- en: Working with D3.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用D3.js
- en: aahis chapter will introduce you to **Data-Drive Documents** (**D3**), a powerful
    visualization library and one of the most popular open source projects in the
    world. Interestingly, while it's most important for its data manipulation features,
    D3 is simply one of the most powerful libraries for working with SVG, full stop.
    Even in the context of being a `helper` library of the sort we discussed in the
    previous chapter, it has many very useful features for working with SVG documents,
    including many that replicate the sorts of things that `Snap.svg` and SVG.js offer
    and many more beyond that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将向您介绍**数据驱动文档**（**D3**），这是一个功能强大的可视化库，也是世界上最受欢迎的开源项目之一。有趣的是，尽管它最重要的是其数据操作功能，但D3只是用于直接处理SVG的最强大的库之一。即使在作为我们在上一章中讨论的`helper`库的上下文中，它也有许多非常有用的功能，用于处理SVG文档，包括许多复制`Snap.svg`和SVG.js提供的功能以及更多功能。
- en: D3 doesn't stop there, however. It goes well beyond that SVG authoring and utility
    feature set and goes on to offer a rich suite of tools to do data manipulation
    and subsequent generation of data visualizations. What's more, D3 uses the same
    web standards under the hood that you've been working with throughout the book
    and marries it with a robust API to offer up a true playground for working with
    SVG and data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，D3并不止于此。它远远超出了SVG创作和实用功能集，并提供了丰富的工具套件，用于数据操作和随后生成数据可视化。此外，D3在底层使用了您在整本书中一直在使用的相同的Web标准，并将其与强大的API结合在一起，为处理SVG和数据提供了一个真正的游乐场。
- en: Born out of an earlier visualization library called Protovis ( [http://mbostock.github.io/protovis/](http://mbostock.github.io/protovis/)),
    D3 has been around since the early 2010s and remains under the watchful eye of
    the project's original developer, Mike Bostock. The project is under active development,
    and offers up copious documentation and a wonderful selection of examples to learn
    from.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: D3诞生于一个名为Protovis的早期可视化库（[http://mbostock.github.io/protovis/](http://mbostock.github.io/protovis/)），自2010年代初以来一直存在，并且仍由项目的原始开发人员Mike
    Bostock密切关注。该项目正在积极开发，并提供大量文档和丰富的示例供学习。
- en: It's also, once you get the hang of it, a lot of fun. This is the last new technology
    introduced in the book that's used for working with SVG directly, so it's nice
    to be ending this phase of the book on a high note.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了它，它也会很有趣。这是本书介绍的最后一个新技术，用于直接处理SVG，因此很高兴能以一个高潮结束本书的这一阶段。
- en: Let's have some fun.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩得开心。
- en: 'In this chapter, we''ll learn about several topics, including:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些主题，包括：
- en: How to install D3 and how to do basic SVG manipulations with the library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装D3以及如何使用库进行基本的SVG操作
- en: How to do a bar chart with D3 using scales and functions that help define the
    *x* and *y* axes of a chart
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用D3使用比例尺和帮助定义图表的*x*和*y*轴来制作条形图
- en: How to use the `d3-fetch` utility to get and parse JSON and CSV data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`d3-fetch`实用程序获取和解析JSON和CSV数据
- en: How to use the `enter` and `exit` selections to manipulate the SVG DOM based
    on the changes to a dataset
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`enter`和`exit`选择来根据数据集的更改操作SVG DOM
- en: How to implement a donut chart in D3 using the `arc` and `pie` functions from
    D3
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用D3的`arc`和`pie`函数实现甜甜圈图表
- en: How to implement a chord diagram; a complicated visualization with multiple
    components
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现和弦图；一个包含多个组件的复杂可视化
- en: Getting started with D3
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用D3
- en: The D3 API can take some getting used to. The examples in this chapter will
    strive to illustrate some of the basic concepts as well as dive deeper as we move
    forward to show some of the best that D3 has to offer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: D3 API可能需要一些时间来适应。本章的示例将努力说明一些基本概念，并随着我们的深入展示D3所提供的一些最佳功能。
- en: 'Before we can do any of that, you need to get D3 into your page. To do so,
    you can use `npm` to install it into your project folder:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，您需要将D3引入您的页面。为此，您可以使用`npm`将其安装到您的项目文件夹中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you''ve got it installed, you can link to the minified D3 source from
    your document using a script tag:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用脚本标签从您的文档中链接到压缩的D3源代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you''d prefer not to use `npm`, it''s also available to be linked to from
    [d3js.org](https://d3js.org/) directly:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用`npm`，也可以直接从[d3js.org](https://d3js.org/)链接到它：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Additionally, if you want a local copy, you can clone the project from GitHub
    ( [https://github.com/d3/d3)](https://github.com/d3/d3)), or download the project
    from [d3js.org](https://d3js.org/) and then organize your files in any way you
    like.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想要本地副本，可以从GitHub（[https://github.com/d3/d3](https://github.com/d3/d3)）克隆项目，或者从[d3js.org](https://d3js.org/)下载项目，然后以任何您喜欢的方式组织您的文件。
- en: Once you've got the project installed, you're ready to start to explore the
    D3 API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您就可以开始探索D3 API了。
- en: The following example shows how to implement a simple bar chart using D3\. You've
    seen some of the concepts used to generate a bar chart already in this book, but
    the difference here is that D3 will do it for you. D3 knows all about visualizations
    so it will generate the required metrics for you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用D3实现一个简单的条形图。在本书中，您已经看到了用于生成条形图的一些概念，但这里的区别在于D3会为您完成。D3了解所有关于可视化的知识，因此它将为您生成所需的度量标准。
- en: 'This visualization will compare the top ten individual comic book sales of
    all time. The data ([https://itsalljustcomics.com/all-time-record-comic-book-sales/](https://itsalljustcomics.com/all-time-record-comic-book-sales/))
    it will illustrate is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可视化将比较有史以来销量最高的十本个人漫画书。它将说明的数据如下：[https://itsalljustcomics.com/all-time-record-comic-book-sales/](https://itsalljustcomics.com/all-time-record-comic-book-sales/)
- en: '| **Title/Issue #/Grade** | **Date of sale** | **Sale price** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **标题/期号/等级** | **销售日期** | **销售价格** |'
- en: '| Action Comics 1 9.0  | 2014/08/24  | $3,207,852.00 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 动作漫画1 9.0 | 2014/08/24 | $3,207,852.00 |'
- en: '| Action Comics 1 9.0 | 2011/11/30 | $2,161,000.00 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 动作漫画1 9.0 | 2011/11/30 | $2,161,000.00 |'
- en: '| Action Comics 1 8.5 | 2018/06/13 | $2,052,000.00 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 动作漫画1 8.5 | 2018/06/13 | $2,052,000.00 |'
- en: '| Action Comics 1 8.5 | 2010/03/29 |  $1,500,000.00 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 动作漫画1 8.5 | 2010/03/29 | $1,500,000.00 |'
- en: '| Amazing Fantasy 15 9.6 | 2011/03/09  | $1,100,000.00 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 了不起的幻想15 9.6 | 2011/03/09 | $1,100,000.00 |'
- en: '| Detective Comics 27 8.0 | 2010/02/25  | $1,075,000.00 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 侦探漫画27 8.0 | 2010/02/25 | $1,075,000.00 |'
- en: '| Action Comics 1 Kansas City 8.0  | 2010/02/22  | $1,000,000.00 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 动作漫画1堪萨斯城8.0 | 2010/02/22 | $1,000,000.00 |'
- en: '| Action Comics 1 5.5  | 2016/08/04  | $956,000.00 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 动作漫画1 5.5 | 2016/08/04 | $956,000.00 |'
- en: '| All Star Comics 8 9.4 | 2017/08/27  | $936,223.00 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 全明星漫画8 9.4 | 2017/08/27 | $936,223.00 |'
- en: '| Action Comics 1 5.0 | 2018/03/20  | $815,000.00 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 动作漫画1 5.0 | 2018/03/20 | $815,000.00 |'
- en: 'The end result of the visualization will look like the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化的最终结果将如下截图所示：
- en: '![](img/c63a1b78-0cc5-4b3b-87c0-909679e0da39.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c63a1b78-0cc5-4b3b-87c0-909679e0da39.png)'
- en: All JavaScript code in this chapter is written to take advantage of ES6 features,
    such as arrow functions, const, and let.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有JavaScript代码都是为了充分利用ES6功能而编写的，比如箭头函数、const和let。
- en: 'The markup, which follows, is very simple. We once again include Bootstrap
    for simple layout tasks and `Raleway`, our font of choice in this book. Then we
    set some base CSS styles for text elements and set up a simple container to hold
    the visualization. After that, we include three files: `d3.min.js`, the main D3
    file, `d3-fetch.min.js`, a Fetch utility from D3 ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)),
    and our visualization file, `bar.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是非常简单的标记。我们再次包括Bootstrap来进行简单的布局任务和`Raleway`，这本书中我们选择的字体。然后我们为文本元素设置了一些基本的CSS样式，并设置了一个简单的容器来容纳可视化内容。之后，我们包括了三个文件：`d3.min.js`，主要的D3文件，`d3-fetch.min.js`，D3的Fetch实用程序（[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)），以及我们的可视化文件`bar.js`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the JavaScript here is complicated and introduces many new concepts, I'm
    going to go through each block separately. Look at the full file in the downloaded
    source code if you'd like to see the entire file in one go.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里的JavaScript很复杂，并引入了许多新概念，我将逐个解释每个块。如果您想一次看到整个文件，请查看下载的源代码中的完整文件。
- en: 'Looking at `bar.js`, it consists of one function that draws the entire visualization
    on screen. The start of the function sets several constants that are used throughout
    the visualization: `width`, `height`,  `chartHeight` (used to set the size of
    the chart itself versus the size of the overall SVG), and a `margin` const used
    to ensure that there''s enough margin to hold the entirety of the visualization
    in the SVG element:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`bar.js`，它包含一个在屏幕上绘制整个可视化的函数。函数的开始设置了几个常量，这些常量在整个可视化过程中都被使用：`width`、`height`、`chartHeight`（用于设置图表本身的大小与整个SVG的大小）和一个`margin`常量，用于确保SVG元素中有足够的边距来容纳整个可视化内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Following that, we start to work directly with D3\. D3 allows you to access
    and manipulate existing SVG elements and also, as in the case of the D3 demos
    in this book, generate a D3-enhanced SVG element and append it to the DOM.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始直接使用D3。D3允许您访问和操作现有的SVG元素，并且，就像本书中D3演示的情况一样，生成一个经过D3增强的SVG元素并将其附加到DOM中。
- en: In this case, we're using D3's query selector utility, `d3.select`, to select
    the `#target` element and then append a new SVG element into it. We then use the
    increasingly familiarly named function `attr` to set the `height` and `width`
    of the SVG element. Once the SVG element is in the document, we append a new `g`
    element and immediately translate it by the `margin` on the *x* and *y* axes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用D3的查询选择器实用程序`d3.select`来选择`#target`元素，然后将一个新的SVG元素附加到其中。然后，我们使用越来越熟悉的命名函数`attr`来设置SVG元素的`height`和`width`。一旦SVG元素在文档中，我们附加一个新的`g`元素，并立即通过*x*和*y*轴上的`margin`进行平移。
- en: 'Chained D3 methods behave like jQuery or other libraries that use this pattern
    so the variable `svg` is a D3-enabled reference to the final element in the chain,
    the newly added `g`. Anything that interacts with that variable will start from
    within the context of that `g` element:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的D3方法的行为类似于jQuery或其他使用这种模式的库，因此变量`svg`是对链中最终元素的D3启用引用，即新添加的`g`。任何与该变量交互的内容都将从该`g`元素的上下文开始：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we use some methods to set the scale for the *x* and *y* axes and then
    actually generate both the *x* and *y* axes. This is where D3 really shines. Doing
    this work isn't impossible. It's often simple math. It's just that no one wants
    to write these functions all the time and D3 makes it easy with an entire suite
    of scale functions ([https://github.com/d3/d3-scale](https://github.com/d3/d3-scale)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一些方法来设置*x*和*y*轴的比例，然后实际生成*x*和*y*轴。这就是D3真正发挥作用的地方。做这项工作并不是不可能的。这通常是简单的数学。只是没有人想一直编写这些函数，D3通过一整套比例函数（[https://github.com/d3/d3-scale](https://github.com/d3/d3-scale)）使其变得容易。
- en: The `x` variable holds the return value of a `scaleBand` method call. `scaleBand`
    allows you to break up a numeric scale into component *bands*, which we will use
    to create the horizontal spacing of our bar chart. The initial call is chained
    to two subsequent calls, each of which inform the band about our specific visualization.
    The `range` method call sets the *x* scale to range from `10` pixels up to a calculated
    upper bound (the `width` minus two horizontal margins). `paddingInner `sets the
    inner padding of the bands. This property allows us to create some space between
    the columns.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`变量保存了`scaleBand`方法调用的返回值。`scaleBand`允许您将数值比例划分为组件*band*，我们将使用它来创建条形图的水平间距。初始调用链接到两个后续调用，每个调用都通知了我们特定可视化的band。`range`方法调用将*x*比例尺设置为从`10`像素到计算出的上限（`width`减去两个水平边距）。`paddingInner`设置band的内部填充。这个属性允许我们在列之间创建一些空间。'
- en: The `y` variable is created as a linear scale. Linear scales are continuous,
    regular scales between two values. The values for this particular scale are set
    with a call to `range` with `chartHeight` and `0` as the range values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`变量被创建为线性比例尺。线性比例尺是两个值之间的连续、常规比例尺。这个特定比例尺的值是通过调用`range`并将`chartHeight`和`0`作为范围值来设置的。'
- en: 'Following that, we use the newly created `x` and `y` scales to call two convenience
    methods, `axisLeft` and `axisBottom`. These methods render human-readable reference
    marks for scales. The `xAxis` is created and then the just-created `x` scale is
    passed in to wire up `xAxis` with the values from the `x` scale. The `y` axis
    is generated in exactly the same way:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们使用新创建的`x`和`y`比例尺调用了两个便利方法，`axisLeft`和`axisBottom`。这些方法为比例尺渲染了可读的参考标记。创建了`xAxis`，然后将刚刚创建的`x`比例尺传递给`xAxis`，以将`xAxis`与`x`比例尺的值连接起来。*y*轴的生成方式完全相同：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then use another scale method, `scaleOrdinal`, to create a map between our
    discrete data values and a corresponding set of colors:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用另一个比例尺方法`scaleOrdinal`来创建我们的离散数据值和相应一组颜色之间的映射：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The rest of the method uses a utility from `d3-fetch` and `d3.json` to access
    our data file and then, as `callback` to the fetch request, process the data and
    generate our visualization.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的其余部分使用了`d3-fetch`和`d3.json`中的实用程序来访问我们的数据文件，然后作为`fetch`请求的`callback`来处理数据并生成我们的可视化。
- en: The `callback` methods begin with two calls to `domain` for both the `x` and
    `y` axes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback`方法以对`x`和`y`轴的`domain`进行两次调用开始。'
- en: For an ordinal scale, the `xAxis` and `domain` accept an array and sets the
    domain for the scale to the specific set of values in the array. Here, we `map`
    the returned `data` to create a collection of the `title` properties as the values
    to use in the `xAxis`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于序数比例尺，`xAxis`和`domain`接受一个数组，并将比例尺的域设置为数组中的特定值集。在这里，我们`map`返回的`data`以创建`title`属性的集合，作为`xAxis`中使用的值。
- en: For a linear scale, calling `domain` limits the continuous scale to the specific
    set of values. In this case, we're setting the scale to `0` at the minimum and
    the return value of `d3.max`, which returns the largest value in an array, as
    the maximum.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于线性比例尺，调用`domain`将连续比例尺限制为特定的值集。在这种情况下，我们将比例尺设置为最小值为`0`，最大值为`d3.max`的返回值，该返回值为数组中的最大值。
- en: Following that we start manipulating SVG elements to create the actual visualization.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始操作SVG元素来创建实际的可视化效果。
- en: The first set of chained methods appends a new SVG group element, `g`, and adds
    a pair of classes to it, `x` and `axis`, and then translates it to a point at
    (`0`, `chartHeight`). This places this group at the bottom of the chart, which
    is precisely where you want the legend for the *x*-axis to be.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组链接的方法附加了一个新的SVG组元素`g`，并向其添加了一对类`x`和`axis`，然后将其转换为一个点(`0`, `chartHeight`)。这将该组放置在图表底部，这正是您希望*x*轴的图例所在的位置。
- en: 'Then we use the `d3.call` function to call `xAxis` and generate our *x*-axis.
    `d3.call` is a utility method that allows you to call a function on a selection
    and then return the modified selection. This allows you to encapsulate some functionality
    in a reusable function in a way that enables chaining. Here, we call `xAxis`, the
    configured `axisBottom` method we created earlier, in order to create the *x*-axis
    – complete with all the elements that make up the *x*-axis. Without doing anything
    else, the *x*-axis now looks like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`d3.call`函数调用`xAxis`并生成我们的*x*轴。`d3.call`是一个实用方法，允许您在选择上调用一个函数，然后返回修改后的选择。这使您能够以一种启用链接的方式将一些功能封装在可重用的函数中。在这里，我们调用`xAxis`，即我们之前创建的`axisBottom`方法，以创建*x*轴
    - 包括构成*x*轴的所有元素。不做其他任何操作，*x*轴现在看起来像下面这样：
- en: '![](img/df12a31f-1b9e-4a3d-a55e-c8d1628e5c62.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df12a31f-1b9e-4a3d-a55e-c8d1628e5c62.png)'
- en: As you can see, for some values that layout might be okay, but for our purposes,
    it's not functional. Because of the length of our titles, we need to tweak our
    labels to be legible. We'll rotate them 90 degrees.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于某些值，该布局可能是可以的，但对于我们的目的来说，它并不实用。由于我们标题的长度，我们需要调整标签以便可读。我们将它们旋转90度。
- en: To do so, we chain a few more methods onto our current chain. First we `select`
    all `text` elements that are child nodes of the current selection. These are all
    the `text` elements we just created with `xAxis`. Once we have that selection,
    we apply a transformation of -90 degrees to the text elements. This reorients
    the `text` to be vertical. Following that, we adjust the `dx` and `dy` properties
    to line the text up neatly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们在当前链上再链接了一些方法。首先，我们选择了当前选择的所有子节点中的所有`text`元素。这些都是我们刚刚用`xAxis`创建的所有`text`元素。一旦我们有了这个选择，我们就对文本元素应用了-90度的旋转。这重新定位了文本为垂直。随后，我们调整了`dx`和`dy`属性，使文本整齐地排列。
- en: Next up, we append a new `g` element.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们附加一个新的`g`元素。
- en: Using these groups is not strictly necessary, but they help to organize the
    generated code for debugging and allow you to more easily create selections that
    are easy to manipulate. This is what groups are for.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些组并不是严格必要的，但它们有助于组织生成的代码以进行调试，并且使您更容易创建易于操作的选择。这就是组的作用。
- en: This new `g` element will hold the *y*-axis. The *y*-axis is created in a similar
    way to the *x*-axis – although it's a simpler process, since there's no need to
    manipulate the text elements. A horizontal text layout is fine for the *y*-axis.
    In this call, we add classes to the `g` element, `y` and `axis`, and then call
    `yAxis`, which generates all of the elements that make up the *y*-axis.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`g`元素将保存*y*轴。*y*轴的创建方式与*x*轴类似 - 尽管这是一个更简单的过程，因为不需要操作文本元素。水平文本布局对*y*轴来说是可以的。在这个调用中，我们向`g`元素添加了`y`和`axis`类，然后调用`yAxis`，它生成了构成*y*轴的所有元素。
- en: The final method chain in this `callback` function illustrates a common pattern
    when working in D3\. The first call is to `d3.selectAll`. `selectAll` will access
    *all* the elements that match the provided selector. This returned value is called
    the *selection *in D3\. The selection can either be a list of DOM elements or,
    in this case, an array of placeholder elements matching the items in the data.
    So, empty, in this context is okay, as we will go through the process of manipulating
    the selection and adding our elements to it based on the received data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`callback`函数中的最终方法链展示了在D3中工作时的常见模式。第一个调用是`d3.selectAll`。`selectAll`将访问与提供的选择器匹配的*所有*元素。返回的值在D3中称为*selection*。选择可以是DOM元素的列表，或者在这种情况下，是与数据中的项目匹配的占位符元素的数组。因此，在这种情况下，空是可以的，因为我们将根据接收到的数据来处理选择并向其添加元素。
- en: We'll illustrate `enter` and the associated method, `exit`, in more depth in
    the next section, but in short, if your selection has fewer elements than the
    number of points in the dataset, then those extra data points are stored in what's
    referred to as the *enter selection*. Calling `enter` allows us to enter into
    and manipulate this enter selection. In our case, we're adding a number of `rect`
    elements to the SVG element.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节更深入地说明`enter`和相关方法`exit`，但简而言之，如果您的选择的元素少于数据集中的点数，则这些额外的数据点将存储在所谓的*enter选择*中。调用`enter`允许我们进入并操作这个进入选择。在我们的情况下，我们正在向SVG元素添加许多`rect`元素。
- en: 'Each of those `rect` elements is manipulated in the following ways:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`rect`元素中的每一个都以以下方式进行操作：
- en: Its `fill` is set referencing a member of the `color` scale.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其`fill`是参考`color`比例的成员设置的。
- en: The `x` property is created based on the members of the `x` scale.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`属性是基于`x`比例的成员创建的。'
- en: The `width` is calculated using `x-bandwidth`, which is a method that takes
    the member of the `x` scale and calculates a width based on that scale, including
    any defined padding.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`是使用`x-bandwidth`计算的，这是一个根据该比例计算宽度的方法，包括任何定义的填充。'
- en: The `y` property is created based on the `y` scale previously created
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`属性是基于先前创建的`y`比例创建的'
- en: The `height` is calculated by subtracting this data point's *y* scale value
    from the `chartHeight`. This, in effects, hangs the box from the `y` value down
    to the bottom of the chart.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`是通过从`chartHeight`减去此数据点的*y*比例值来计算的。这实际上是将框从`y`值悬挂到图表底部。'
- en: 'All of these properties combine to create the heart of the visualization:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性组合在一起创建了可视化的核心：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The final line of the file simply calls `bar()` to create the visualization.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的最后一行只是调用`bar()`来创建可视化。
- en: D3's enter and exit
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: D3的enter和exit
- en: As I mentioned in the last section, I want to take a quick, simplified look
    at `enter` and the associated method, `exit`. These methods are important for
    dealing with dynamic datasets. With these methods, you can take an arbitrary selection,
    blend it with data and then manipulate it with D3's tools to craft visualizations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一节中提到的，我想简要地看一下`enter`和相关方法`exit`。这些方法对于处理动态数据集非常重要。使用这些方法，您可以获取任意选择，将其与数据混合，然后使用D3的工具对其进行操作，以创建可视化效果。
- en: In this section, you'll see three examples. The first shows an example of using
    `enter` that illustrates calling the method against a completely empty selection.
    The second illustrates calling `enter` on a selection with existing elements.
    The third illustrates how `exit` works.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将看到三个例子。第一个示例展示了使用`enter`的示例，说明了对完全空选择调用该方法。第二个示例说明了在具有现有元素的选择上调用`enter`。第三个示例说明了`exit`的工作原理。
- en: In this first example, we select the `#target` element and then call `selectAll`
    with `p` as the argument. Since there are no paragraphs in that `#target` element,
    this is an empty selection. Calling `data` on it binds that empty selection to
    our data. Calling `enter` on that bound selection allows us to manipulate our
    selection based on each data point.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，我们选择`#target`元素，然后使用`p`作为参数调用`selectAll`。由于`#target`元素中没有段落，这是一个空选择。在其上调用`data`将空选择绑定到我们的数据。在绑定的选择上调用`enter`允许我们根据每个数据点来操作我们的选择。
- en: 'If you were to log out the return value of `d3.select("#target").selectAll("p").data(data).enter()`
    at this point, it would look like the following screenshot, showing an array of
    five elements with the original data stored as an internal `__data__` property:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时记录`d3.select("#target").selectAll("p").data(data).enter()`的返回值，它将看起来像以下的屏幕截图，显示一个包含原始数据的五个元素的数组，存储为内部的`__data__`属性：
- en: '![](img/2b23bbf2-7266-4d18-b7e8-cc3b4362a068.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b23bbf2-7266-4d18-b7e8-cc3b4362a068.png)'
- en: 'Next we simply `append` a paragraph to the document for each data point and
    use the `text` method to insert a text node representing the data into the document:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地为每个数据点在文档中`append`一个段落，并使用`text`方法将代表数据的文本节点插入文档中：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the code in the browser results in the following output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行代码会产生以下输出：
- en: '![](img/b8179d05-c82f-481d-b425-4bc16f455d21.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8179d05-c82f-481d-b425-4bc16f455d21.png)'
- en: 'The next example is similar, except for the fact that it has an existing paragraph
    element in the `#target div`. Since there''s an existing `p` element, calling
    `d3.select("#target").selectAll("p").data(data).enter()` on the selection results
    in the following output. As you can see, the `_groups` array has the same five
    members, but the first entry, the one that corresponds to the existing member
    in `selection` is empty. That''s because it''s not part of the enter selection
    (as it corresponds to an *existing* element):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例类似，只是在`#target div`中有一个现有的段落元素。由于存在`p`元素，在选择上调用`d3.select("#target").selectAll("p").data(data).enter()`的结果如下。如您所见，`_groups`数组具有相同的五个成员，但第一个条目，与`selection`中的现有成员对应的条目为空。这是因为它不是进入选择的一部分（因为它对应于*现有*元素）：
- en: '![](img/0677d8c8-621e-40b5-97a3-cfede4a6b9b2.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0677d8c8-621e-40b5-97a3-cfede4a6b9b2.png)'
- en: 'Everything else about this example is the same as the previous example of using
    `enter`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的其他内容与使用`enter`的上一个示例相同：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we''re only updating the enter selection in this example, running the
    preceding code in the browser produces the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个示例中只更新了输入选择，因此在浏览器中运行上述代码会产生以下输出：
- en: '![](img/46baebc7-0833-4c4a-b616-43523ce639f0.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46baebc7-0833-4c4a-b616-43523ce639f0.png)'
- en: 'To update the *entire* selection, you simply need to manipulate the original
    selection before you update the enter selection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新*整个*选择，您只需要在更新输入选择之前操纵原始选择：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `exit` selection allows you to clean up elements that no longer have data
    associated with them. The following example shows how this works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`选择允许您清理不再与数据关联的元素。以下示例显示了这是如何工作的。'
- en: The `render` function initially goes through some patterns we've already seen.
    The function calls `selectAll` on `p` elements that are children of `#target div`,
    loads it up with data, enters the enter selection, and appends a series of paragraph
    elements with the correct data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数最初通过一些我们已经看到的模式。该函数在`#target div`的子元素`p`上调用`selectAll`，加载数据，进入输入选择，并附加一系列带有正确数据的段落元素。'
- en: Next we repeat the process and instead of calling `enter`, we call `exit` and
    then immediately call `remove`. The `exit` selection returns any elements in the
    selection that don't correspond to a data point*. *`remove` removes those elements
    from the document. The first time this runs, no elements are removed because the
    data has just been loaded. All elements in the selection are populated with the
    proper data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们重复这个过程，而不是调用`enter`，我们调用`exit`，然后立即调用`remove`。`exit`选择返回选择中不对应数据点的任何元素。`remove`从文档中删除这些元素。第一次运行时，没有元素被删除，因为数据刚刚被加载。选择中的所有元素都用正确的数据填充。
- en: The interesting thing happens in `setTimeout`. In that `callback` function,
    if there are still members of the data array, `data.pop()` is called. `pop` removes
    the last element from the array and then `render` is called, recursively after
    `1` second. When the function runs again and we get to the exit selection, where
    we call `exit.remove`, there *is *a mismatch between the data and the selection.
    The first time this is called recursively, there are five paragraphs, but only
    four data points. Because the fifth paragraph doesn't have a data point associated
    with it, it's removed from the document.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事情发生在`setTimeout`。在那个`callback`函数中，如果数据数组仍然有成员，就会调用`data.pop()`。`pop`从数组中删除最后一个元素，然后在1秒后递归调用`render`。当函数再次运行并且我们到达退出选择时，我们调用`exit.remove`，数据和选择之间存在不匹配。第一次递归调用时，有五个段落，但只有四个数据点。因为第五个段落没有与之关联的数据点，所以它从文档中删除。
- en: 'This process repeats until there are no data points or paragraphs left and
    the recursive calls stop:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程重复，直到没有数据点或段落剩下，递归调用停止：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Hopefully, these simplified examples, dealing with the simplest possible element,
    a humble paragraph, are enough to illustrate the way that this very powerful pattern
    can help to work with datasets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些简化的例子足以说明这种非常强大的模式如何帮助处理数据集。
- en: Now that we've taken a look at these two methods, let's return to some more
    of the fun stuff, with a new, slightly more complicated visualization.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了这两种方法，让我们回到一些更有趣的东西，用一个新的，稍微更复杂的可视化。
- en: Implementing a donut chart with D3
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用D3实现甜甜圈图
- en: 'This next sample illustrates another basic data visualization: in this case,
    a donut chart. Slightly more complicated than a pie chart, this visualization
    illustrates some new features of D3\. When complete, the visualization will look
    like the following screenshot.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例说明了另一种基本的数据可视化：在这种情况下，是一个甜甜圈图。比饼图稍微复杂一些，这个可视化展示了D3的一些新特性。完成后，可视化将如下截图所示。
- en: 'It represents the distribution of individual comic books (referenced by title
    and issue number) among the top 50 comic book sales of all time (public sales,
    at the time of writing). There are a few comics that dominate lists like that
    and this chart will show which ones dominate the most:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表了个别漫画书（按标题和期号引用）在有史以来的前50本漫画书销售中的分布（公开销售，在撰写时）。像这样的列表中有一些主导的漫画书，这张图表将显示哪些最主导：
- en: '![](img/fbc62d23-dba6-4d33-a0aa-57a67117cb73.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbc62d23-dba6-4d33-a0aa-57a67117cb73.png)'
- en: 'The data looks like the following CSV:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据看起来像下面的CSV：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The HTML file is very simple. It includes, once again, `Raleway`, Bootstrap,
    `d3-fetch`, and D3 for dependencies. It includes the same markup we''ve been working
    within several examples in this book and then includes our `donut.js` file, which
    is where everything interesting happens:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件非常简单。它包括了`Raleway`，Bootstrap，`d3-fetch`和D3作为依赖项。它包括了我们在本书中几个示例中一直在工作的相同标记，然后包括我们的`donut.js`文件，这是一切有趣的地方：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Looking at `donut.js`, there's a lot going on, so we'll once again go through
    the file section by section. If you want to see the whole file, please look at
    the full source code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 看着`donut.js`，有很多事情要做，所以我们将再次逐个部分地查看文件。如果您想看整个文件，请查看完整的源代码。
- en: 'The file starts with setting several constants for the `height`, `width`, and
    `radius` of the visualization. We then create a color scale that steps through
    13 shades of blue and green:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 文件从设置可视化的`height`，`width`和`radius`的几个常数开始。然后我们创建一个颜色比例尺，它经过13种蓝色和绿色的色调：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The next two method calls are there just to set up for the later visualization.
    At this point, we don't have any data to work with, but we can still create some
    loaded D3 tools to work with the data when it arrives. The first constant, `arc`,
    will allow us to draw arcs with an `outerRadius` that reaches near to the edge
    of the SVG element and an `innerRadius 200` pixels in from the `outerRadius`. That
    creates a 190 pixel ring.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法调用只是为了为以后的可视化设置。在这一点上，我们没有任何数据可以使用，但是当数据到达时，我们仍然可以创建一些加载的D3工具来处理数据。第一个常数`arc`将允许我们用`outerRadius`绘制弧，该弧接近SVG元素的边缘，并且`innerRadius`在`outerRadius`内200像素。这创建了一个190像素的环。
- en: 'Following that we call `d3.ie`, which is a method that takes data and returns
    `arc`s that represent the correct proportional slice of data for a pie or donut
    chart. We don''t have data yet, but we set the method up to know to use the `numbers`
    property of the data object when it creates the `arc`s:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们调用`d3.ie`，这是一个接收数据并返回代表饼图或甜甜圈图的正确比例切片的方法。我们还没有数据，但是我们设置了该方法，以便在创建`arc`时使用数据对象的`numbers`属性：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next we start to implement some SVG. The first call should be common to you
    by this point. We call `d3.select` to grab the `#target` element and then append
    an SVG element into the DOM. Then we use `attr` to set the `height` and `width`
    and then append a group, `g`, element to the SVG document. That `g` is then transformed
    to the center of the SVG element, translating it by half the width and half the
    height of the SVG element.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们开始实现一些SVG。第一个调用到这个时候应该对你来说是常见的。我们调用`d3.select`来获取`#target`元素，然后将SVG元素附加到DOM中。然后我们使用`attr`来设置`height`和`width`，然后在SVG文档中附加一个组`g`元素。然后将该`g`转换为SVG元素的中心，通过将其平移半个宽度和半个高度。
- en: 'Following that we append a new `text` element to the `g` element that contains
    a small legend for the visualization:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在包含可视化的`g`元素中附加一个新的`text`元素，用于小传说：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we've done all of this setup, it's time to crunch some data and draw
    the visualization. We're starting by using another method from `d3-fetch`, `d3.csv`,
    to fetch a CSV file that contains our data and work with it after D3 parses it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有这些设置，是时候处理一些数据并绘制可视化了。我们首先使用`d3-fetch`中的另一个方法`d3.csv`，来获取包含我们的数据并在D3解析后处理它的CSV文件。
- en: Inside `callback`, there's the now familiar D3 pattern. First, there is a call
    to `svg.selectAll("arc")`, which at this point returns an empty selection. Then
    we call `data`, passing in `pie(data).` `pie` takes the data in and returns the
    start and end angles that we'll use for our donut chart. Next we go into the enter
    selection and append `g` elements for every member of the selection. We haven't
    drawn anything yet, but we have groups set up for each of our data points and
    we have calculated start and end angles applied to the dataset.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`callback`内部，有一个现在熟悉的D3模式。首先，调用`svg.selectAll("arc")`，这时返回一个空选择。然后我们调用`data`，传入`pie(data)`。`pie`接收数据并返回我们用于甜甜圈图的起始和结束角度。接下来我们进入enter选择，并为每个选择的成员附加`g`元素。我们还没有画任何东西，但是我们已经为每个数据点设置了组，并且已经计算了应用于数据集的起始和结束角度。
- en: The next section illustrates just how nice it can be to work with D3.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节说明了与D3一起工作有多么美妙。
- en: At this point, we've got the angles generated by the call to `pie`, attached
    to a number of empty `g` elements. In this next call, we append a `path` element,
    and, with a call to the previously created `arc` method, we populate the `d` attribute
    with the full `arc` required to draw the visualization. That's all it takes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经得到了通过调用`pie`生成的角度，附加到许多空的`g`元素上。在下一个调用中，我们附加了一个`path`元素，并且通过调用先前创建的`arc`方法，将`d`属性填充为绘制可视化所需的完整`arc`。就是这么简单。
- en: All that's left now, for the chart itself, is to populate the fill of the arc
    by returning a value from the color scale we created earlier. This is selected
    based on the index of the data. The data is sorted by its ranking among the comic
    book titles. This creates the nice gradient we see when we run this visualization.
    And if you stopped here, you would actually have a visualization. It wouldn't
    have any text associated with it, but you'd have a nice looking donut chart. Such
    is the power of D3.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于图表本身，唯一剩下的就是通过从之前创建的颜色比例尺返回一个值来填充`arc`的颜色。这是基于数据的索引进行选择。数据根据其在漫画书标题中的排名进行排序。这样在运行此可视化时，我们看到了漂亮的渐变。如果你停在这里，你实际上已经有了一个可视化。它没有与之相关的任何文本，但你已经有了一个看起来不错的甜甜圈图。这就是D3的威力。
- en: That said, we should add some labels, so let's look at how that works. The initial
    pattern is one you should start to be familiar with. We call `selectAll(".label")`,
    load it up with data (manipulated by another call to `pie` to get the same start
    and end angles) and then we manipulate it in the enter selection. In the enter
    selection, we append a `text` element and then take several steps to place the
    text in a useful place across the entire visualization.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们应该添加一些标签，让我们看看它是如何工作的。初始模式是你应该开始熟悉的。我们调用`selectAll(".label")`，加载数据（通过对`pie`的另一个调用来操作，以获得相同的起始和结束角度），然后在enter选择中操作它。在enter选择中，我们附加一个`text`元素，然后采取几个步骤将文本放置在整个可视化中的有用位置。
- en: The first step is to translate the text element to be in the center of `arc`
    using the `arc.centroid` method. Again, this is a great example of how useful
    D3 can be. One small call will allow you to access the geometric center of a complicated
    shape. This works for most of the text elements. We're nearly done.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用`arc.centroid`方法将文本元素平移到`arc`的中心。同样，这是D3有多么有用的一个很好的例子。一个小小的调用就可以让你访问一个复杂形状的几何中心。这对大多数文本元素都适用。我们快要完成了。
- en: 'We just need to tweak the text in two specific cases. Without the next call,
    the text overlaps in unattractive ways in the last few elements of the visualization,
    as can be seen in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要调整两种特定情况下的文本。没有下一个调用，最后几个元素的可视化中文本会以不美观的方式重叠，如下面的截图所示：
- en: '![](img/61ef5499-ed86-42fd-ae21-2ded41d86a74.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61ef5499-ed86-42fd-ae21-2ded41d86a74.png)'
- en: To adjust the placement of those two overlapping elements, we need to figure
    out which ones they are. we know that they are the last two and that they would
    be near the end of the circle. The angles here are measured in radians (360 degrees
    is 2PI or around 6.28 radians). Using rough shorthand for one slice (0.125 radians
    represents roughly one slice in our visualization), we work backward from the
    full circle to test for the last two slices and adjust them slightly using the
    `dy` attribute. The first one is adjusted by `.6em`. The next, final, text element
    is adjusted by `1.5em`. This means that every label is clear to read.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整这两个重叠元素的位置，我们需要找出它们是哪两个。我们知道它们是最后两个，并且它们会靠近圆圈的末端。这里的角度是用弧度来测量的（360度是2PI或大约6.28弧度）。使用粗略的简写，一个切片（0.125弧度大约代表我们可视化中的一个切片），我们从整个圆圈向后测试最后两个切片，并使用`dy`属性稍微调整它们。第一个通过`.6em`进行调整。接下来，最后一个文本元素通过`1.5em`进行调整。这意味着每个标签都清晰可读。
- en: 'The final call actually appends the text to the element using a call to `text` with
    the data''s `title` as an argument:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的调用实际上通过调用`text`并将数据的`title`作为参数将文本附加到元素中：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we've done two standard charts, it's time to do one that's a little
    bit more fun, a chord diagram. This final example will illustrate even more features
    of D3\. It'll be fun.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了两个标准图表，是时候做一个更有趣的弦图了。这个最终的例子将展示D3的更多特性。这会很有趣。
- en: Implementing a chord diagram in D3
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在D3中实现弦图
- en: This final visualization is more complicated on both the data and coding fronts.
    The visualization is based on data released several years ago as part of the Hubway
    Data Visualization Challenges ([http://hubwaydatachallenge.org/](http://hubwaydatachallenge.org/)).
    It's a large dataset that represents every trip, including departure and arrival
    stations, on Boston's Hubway bike-share program (now called Blue Bikes). This
    visualization shows the relationship between the top ten most popular stations,
    illustrating the number of trips that happened between stations in the top ten.
    This is interesting to see which of the major hubs are illustrating potential
    holes in the public transportation network (lots of people are taking trips between
    transit hubs like North Station and South Station) or are potentially being used
    by tourists to see the sights in Boston (many South Station trips return back
    to South Station).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的可视化在数据和编码方面都更加复杂。该可视化基于几年前发布的数据，作为Hubway数据可视化挑战的一部分（[http://hubwaydatachallenge.org/](http://hubwaydatachallenge.org/)）。这是一个庞大的数据集，代表了波士顿的Hubway共享单车项目（现在称为Blue
    Bikes）上的每一次行程，包括出发和到达站。这个可视化展示了波士顿十个最受欢迎站点之间的关系，说明了这些站点之间发生的行程数量。这很有趣，可以看到主要枢纽站之间的潜在公共交通网络漏洞（很多人在主要枢纽站之间出行，比如北站和南站），或者可能被游客用来观光波士顿（很多南站的行程返回到南站）。
- en: 'The final visualization looks like this. Each `arc` represents a departure
    station and the ribbons between the two stations show the relative weight of trips
    between the two stations. The width of the bar when it leaves the `arc` represents
    the numbers of trips. The color of the `arc` is owned by the station in the pair
    that generated more trips between the two:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的可视化看起来是这样的。每个`arc`代表一个出发站，两个站点之间的带状物显示了两个站点之间行程的相对权重。当它离开`arc`时的宽度代表行程的数量。`arc`的颜色由生成两个站点之间更多行程的站点拥有：
- en: '![](img/0e8f63c5-9a15-438f-b6bf-05c99c3b2d91.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e8f63c5-9a15-438f-b6bf-05c99c3b2d91.png)'
- en: The HTML for this visualization, like the rest of these D3 examples is very
    simple. We have `Raleway` and Bootstrap in the head. Then there's a block of CSS
    at the top to add some text styles, as well as a small definition to add a stroke
    color to the small ticks that show the scale numbers along the outer edge of the
    circle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可视化的HTML，就像其他D3示例一样非常简单。我们在头部有`Raleway`和Bootstrap。然后顶部有一段CSS来添加一些文本样式，以及一个小的定义来为圆圈外缘显示刻度数字的小刻度添加描边颜色。
- en: 'Additionally, there''s an `H1` with a legend describing the visualization.
    Then we include just the main D3 file and our visualization file. Everything important
    happens in `chord.js`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，有一个包含可视化描述的`H1`。然后我们只包含主要的D3文件和我们的可视化文件。所有重要的事情都发生在`chord.js`中：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's start looking at `chord.js` by looking at the data. The top of the file
    has hardcoded data for the entire visualization. This is a distillation of a much
    larger dataset and in the original version of this visualization, there was a
    lot of code written to create this data in the specific format required for the
    visualization. The code to generate this data is available on GitHub along with
    the rest of the source code for the book.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始通过查看数据来看`chord.js`。文件顶部有整个可视化的硬编码数据。这是一个更大数据集的精简版本，在这个可视化的原始版本中，有很多代码用于创建特定格式的数据。生成这些数据的代码可以在GitHub上找到，以及本书的其他源代码。
- en: A chord diagram requires a *square matrix*. This is an array of arrays where
    the total number of members in the array matches the total number of members in
    the child arrays and you can map between them. In our example, the parent array
    represents a *departure* station and the values of the child arrays represent
    the total trips to each *arrival* station. The indices of the child arrays match
    up to the indices of the parent array. A departure station can also be an arrival
    station.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 弦图需要一个*方阵*。这是一个数组的数组，其中数组的成员总数与子数组的成员总数相匹配，并且你可以在它们之间进行映射。在我们的例子中，父数组代表一个*出发*站，子数组的值代表到达每个*到达*站的总行程数。子数组的索引与父数组的索引相匹配。一个出发站也可以是到达站。
- en: 'The `names` `const` holds the names for each departure station, matched to
    the index of the departure station in the `matrix` array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`names` `const` 包含每个出发站的名称，与`matrix`数组中出发站的索引相匹配：'
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we've got the data sorted out, let's start to take a look at how we
    generate the actual visualization. The first five blocks of code are all for setup.
    This is what you do with D3, in general, and this one is a little more complicated
    than others so there's more need to do the setup.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了数据，让我们开始看看如何生成实际的可视化。前五个代码块都是用于设置。这是你通常使用D3做的事情，而这个比其他的更复杂，所以需要更多的设置。
- en: The first block involves just the creation of consts for various metrics that
    are required for the visualization. `width` and `height` are common to all of
    our D3 examples. `radius` is a calculated value that represents the full radius
    of a circle that would fit in a square created by the height and width. The `padding`
    const is used to calculate the `outerRadius` of the actual circle of the visualization.
    We then use `outerRadius` to calculate `innerRadius`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块只涉及对可视化所需的各种度量的常量的创建。`width`和`height`对我们所有的D3示例都是常见的。`radius`是一个计算出的值，表示一个圆的完整半径，该圆可以适应由高度和宽度创建的正方形。`padding`常量用于计算可视化实际圆的`outerRadius`。然后我们使用`outerRadius`来计算`innerRadius`。
- en: Following that, we will start to work directly with D3\. The first call is to
    `d3.chord`, the result of which is stored in a const, `chord`. `chord` is a loaded
    method that will generate a chord diagram with our settings. The first setting,
    `padAngle`, is a `radians` argument indicating the space between the `arc`s. With
    a complicated visualization like this, it's nice to have a little space between
    the `arc`s in order to bring some clarity to the separate sections. The second
    setting indicates whether or not we want to sort the sub-groups. In our case,
    we do want that, so we pass in `d3.descending` as the predefined sort.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将直接开始使用D3。第一个调用是`d3.chord`，其结果存储在一个常量`chord`中。`chord`是一个加载方法，将使用我们的设置生成一个弦图。第一个设置`padAngle`是一个`radians`参数，表示`arc`之间的间距。对于这样一个复杂的可视化，`arc`之间有一点空间是很好的，以便为各个部分带来一些清晰度。第二个设置指示我们是否要对子组进行排序。在我们的情况下，我们需要，所以我们传入`d3.descending`作为预定义的排序。
- en: The next variable, `arc`, loads up an instance of `d3.arc` with our calculated
    `innerRadius` and `outerRadius`, just like the donut chart. Once you start to
    think about these things as components you can fit together, possibilities open
    up.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变量`arc`加载了一个`d3.arc`的实例，带有我们计算出的`innerRadius`和`outerRadius`，就像甜甜圈图表一样。一旦你开始把这些东西看作是可以组合在一起的组件，可能性就会打开。
- en: Following that, we will create an instance of D3 `ribbon` with `innerRadius`
    as the only configuration setting, passed in as an argument to the `radius` method.
    This method is used with the `chord` method to create the core of the visualization,
    joining the two ends of the ribbons that connect, which, in our example, are the
    departure and arrival stations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用D3 `ribbon`创建一个实例，`innerRadius`是唯一的配置设置，作为参数传递给`radius`方法。这个方法与`chord`方法一起使用，创建可视化的核心，连接连接的丝带的两端，在我们的例子中是出发和到达站。
- en: 'Finally, we create a `color` scale to map the stations to a rainbow set of
    colors:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`color`比例尺，将车站映射到一组彩虹颜色：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we've set all of that up, it's time to work on getting the visualization
    on the screen. The first block should be very familiar at this point. In it we
    select the `#target` element, append an SVG element, and then set its `width`
    and `height`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了，是时候开始在屏幕上进行可视化工作了。第一个块在这一点上应该非常熟悉。在其中，我们选择`#target`元素，附加一个SVG元素，然后设置它的`width`和`height`。
- en: The next block should be mostly familiar as well. In it we add a `g` group to
    the SVG element, and then translate it to the center of the screen. The interesting
    bit here is a call to `datum`, which is a method very similar to `data`, except
    it propagates the data all the way down the tree. Here we pass in our instance
    of `chord`, along with our `matrix`, and the `chord` method returns the building
    blocks for our data visualization.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个块也应该大部分是熟悉的。在其中，我们向SVG元素添加一个`g`组，然后将其平移到屏幕的中心。这里有趣的部分是对`datum`的调用，这是一个非常类似于`data`的方法，除了它将数据传播到整个树中。在这里，我们传入我们的`chord`实例，以及我们的`matrix`，`chord`方法返回我们数据可视化的构建块。
- en: 'The final block in this section creates the groups that will hold our arc sections,
    paths, and group ticks. We enter the `enter` selection and append a child `g`
    element for the each item of `matrix`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的最后一个块创建了将容纳我们的弧段、路径和组刻度的组。我们进入`enter`选择，并为`matrix`的每个项目附加一个子`g`元素：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At this point, we've done *all* of our setup. It's time, now, to actually draw
    some elements onto the screen.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经完成了*所有*的设置。现在是时候真正地在屏幕上绘制一些元素了。
- en: The first sections added to the visualization are the `arc`s. This pattern will
    be familiar to you from the donut chart. This is exactly the same pattern; just
    here it's part of a larger visualization.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到可视化中的第一个部分是`arc`。这个模式对你来说应该很熟悉，来自甜甜圈图表。这完全相同的模式；只是这里它是更大的可视化的一部分。
- en: The `group` variable is *already part of an* Enter selection so both this and
    the next section, where we add the legends, are already operating on the full
    dataset.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`group`变量已经是一个`Enter`选择的一部分，因此这一部分和我们添加图例的下一部分已经在完整的数据集上运行。'
- en: First we append a `path` and we set the `d` attribute of the `path` with the
    result of our call to `arc`. This returns angles for the start and end of the
    slice. Then we give it a `fill` and a `stroke`. The `stroke` provides our first
    glimpse of another one of D3's utilities. D3.color ([https://github.com/d3/d3-color](https://github.com/d3/d3-color)) offers
    up several options to work with colors. Here, we're using `d3.color.darker` to
    return a slightly darker shade of the color chosen for the `arc` in question,
    in order to give it just enough contrast to show the edges. Finally, we add two
    event handlers that will allow a user to mouse over this station's arc and fade
    all other station's arcs and ribbons. This will allow them to examine this specific
    station's connections without any of the other stations getting in the way. We'll
    talk more about that feature later on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们附加一个`path`，并使用我们对`arc`的调用结果设置`path`的`d`属性。这返回了切片的起始和结束角度。然后我们给它一个`fill`和一个`stroke`。`stroke`提供了D3的另一个实用工具的首次亮相。D3.color
    ([https://github.com/d3/d3-color](https://github.com/d3/d3-color))提供了几种选项来处理颜色。在这里，我们使用`d3.color.darker`来返回所选“弧”的略暗色，以便给它足够的对比度来显示边缘。最后，我们添加了两个事件处理程序，允许用户在鼠标悬停在该站点的弧上时淡化所有其他站点的弧和带。这将使他们能够检查特定站点的连接，而不会受到其他站点的干扰。我们稍后会详细讨论这个功能。
- en: 'Next we add the ribbons. This is a very similar pattern to the `arc`. We start
    with the core `g` group, and append a new group to it, adding a class of ribbons.
    Then we call `selectAll("path")` to get a selection, call `data` to it to apply
    the chord data, and then we go into the `enter` selection to build out the ribbons.
    For each member of the dataset, we append a new `path` and set the path''s `d`
    attribute with a call to `ribbon`. The return value of `ribbon` creates a path
    that connects two angles on one side of the `arc` to two angles on the other side
    of the `arc`. After that, we set the `stroke` and `fill` in the exact same manner
    that we did with the arcs, so everything matches up:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们添加了带。这与“弧”非常相似。我们从核心“g”组开始，附加一个新的带组，添加一个带的类。然后我们调用`selectAll("path")`来进行选择，调用`data`来应用弦数据，然后我们进入“enter”选择来构建带。对于数据集的每个成员，我们附加一个新的`path`，并使用`ribbon`的调用设置路径的`d`属性。`ribbon`的返回值创建了一个连接“弧”一侧的两个角度与“弧”另一侧的两个角度的路径。之后，我们以与弧相同的方式设置`stroke`和`fill`，以便一切匹配：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, the visualization is drawn onto the screen. We can still make
    it better though, so let's do that.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，可视化已经绘制到屏幕上。不过我们仍然可以做得更好，所以让我们来做吧。
- en: The next section adds the small label for each station. As before, we're already
    in an enter selection, so we're already operating on the correct dataset. The
    first call in this chain is to `each`, which allows us to run a function on each
    member of the selection. The `callback` function passed in adds a new property
    to the dataset, `angle`. `angle` is calculated by adding together the start angle
    and finishing angle of the `arc` and dividing it by two, getting the middle of
    the `arc`. We'll use that angle to place the labels in the very next call.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分为每个站点添加了小标签。与之前一样，我们已经处于“enter”选择中，因此我们已经在正确的数据集上操作。这个链中的第一个调用是`each`，它允许我们在选择的每个成员上运行一个函数。传入的`callback`函数添加了一个新的属性到数据集，即`angle`。`angle`通过将“弧”的起始角度和结束角度相加并除以2来计算得到，得到“弧”的中间部分。我们将使用该角度来在下一个调用中放置标签。
- en: The labels we did with the donut chart sat on top of the `arc`. That won't actually
    look all that great with the chord diagram that we have set up and the long text
    labels we have, so we want to move the labels off of the circle. We do that with
    some trigonometry.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用甜甜圈图表做的标签放在了“弧”上。这在我们设置的弦图表和我们拥有的长文本标签上实际上看起来并不那么好，所以我们想把标签移到圆圈外。我们用一些三角学来实现这一点。
- en: The following diagram shows how this works. All of these `text` elements are
    in a group that is in the center of the SVG element. We're looking to move them
    to their new position, outside the circle in line with the middle of the arc they
    are labeling. To do that we take the `d.angle` property that we calculated and
    use that as the hypotenuse (longest side) of a right-angled triangle. Once we've
    got that angle, we can calculate the sine (the ratio of the length of the opposite
    side to the length of the hypotenuse) and the cosine (the ratio of the length
    of the adjacent side to the length of the hypotenuse). Once we have those ratios,
    we simply multiply them by the `outerRadius` (plus a few extra pixels to give
    it some room) to get the length of the adjacent and opposite sides of the triangle.
    We use those values as the *x* and *y* needed to translate the text elements to
    their new position.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这是如何工作的。所有这些`text`元素都在SVG元素的中心的一个组中。我们要将它们移动到它们的新位置，即圆圈外与它们标记的弧的中间对齐。为此，我们取我们计算的`d.angle`属性，并将其用作直角三角形的斜边（最长边）。一旦我们得到了那个角度，我们就可以计算正弦（对边长与斜边长的比值）和余弦（邻边长与斜边长的比值）。一旦我们有了这些比值，我们只需将它们乘以`outerRadius`（再加上一些额外像素以给它一些空间）就可以得到三角形的邻边和对边的长度。我们将这些值用作将文本元素转换到它们的新位置所需的*x*和*y*。
- en: 'This technique will come in handy, all the time:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术将随时派上用场：
- en: '![](img/530b6391-6d4b-4469-8e6c-c1f362eef330.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/530b6391-6d4b-4469-8e6c-c1f362eef330.png)'
- en: The next section adjusts the `text-anchor` property based on the position of
    the text element on the `arc`. If it's greater than halfway (there are two PI
    radians in a circle, so `Math.PI` is equivalent to halfway around the circle),
    then we need to set `text-anchor` to `end` in order to balance them with the labels
    on the right side of the circle. If we don't adjust the text-anchor in this way,
    text elements on the left side of the visualization will overlap with the arcs
    on that side.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分根据“arc”上文本元素的位置调整“text-anchor”属性。如果它大于一半（圆上有两个PI弧度，所以“Math.PI”相当于圆的一半），那么我们需要将“text-anchor”设置为“end”，以便与圆右侧的标签平衡。如果我们不以这种方式调整text-anchor，可视化的左侧文本元素将与该侧的弧重叠。
- en: 'Finally, we append the text itself:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们附加文本本身：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The final SVG elements we're going to do for this visualization is to add the
    group ticks and tick labels to the outer edge. These will allow us to indicate,
    in a friendly way, the scale of the visualization, in thousands.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要为这个可视化添加的最后的SVG元素是在外边缘添加组刻度和刻度标签。这些将允许我们以友好的方式指示可视化的规模，以千为单位。
- en: We start off by creating a new const, `groupTick`, which sets up a new enter
    selection based on the data returned by a call to the `groupTicks` method. `groupTick` takes
    in the existing data from the chain and returns a newly manipulated set of data,
    representing a new tick for every 1,000 units. These new `groupTick` data entries
    have a new angle corresponding to the correct placement on the arc for the tick,
    and a reference to the original data's `value`. Once the `groupTick` data is returned,
    we enter the selection, append a new group and add a class, `group-tick`. Then
    we rotate the element to visually circle the outer edge and translate it to a
    point on `outerRadius`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的常量“groupTick”，它基于对“groupTicks”方法的调用返回的数据设置了一个新的进入选择。“groupTick”接收链中的现有数据，并返回一个新的操纵后的数据集，代表每1000个单位的新刻度。这些新的“groupTick”数据条目具有一个新的角度，对应于刻度在弧上的正确位置，并引用原始数据的“value”。一旦“groupTick”数据返回，我们进入选择，附加一个新的组并添加一个类“group-tick”。然后我们将元素旋转以在外边缘形成视觉圆圈，并将其平移到“outerRadius”的一个点。
- en: Once that's done, we add a six pixel long gray `line` at each tick. Remember,
    `groupTick` is still in an enter selection in this new chain so we can still operate
    on every data point even though we broke the previous chain.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们在每个刻度处添加一个六像素长的灰色“线”。记住，“groupTick”仍然在这个新链中的一个进入选择中，所以即使我们打破了之前的链，我们仍然可以操作每个数据点。
- en: Finally, we enter the selection again and `filter` the data, guarding against
    empty data and then testing whether or not the value is divisible by 5,000 with
    no remainder using the modulus (or remainder) operator ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_())).
    If it is divisible by 5,000, we need to add some text to indicate that we've hit
    5,000 trips for this station. The steps to do this are as follows. Adjust the
    `x` property, to move it further off of `outerRadius`. Adjust the `dy` property
    to move the text element up just a little bit to line up better against the tick
    line.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次进入选择并“filter”数据，防止空数据，然后测试值是否可以被5000整除，使用模数（或余数）运算符（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_())）。如果可以被5000整除，我们需要添加一些文本以指示我们已经为该站点完成了5000次行程。这样做的步骤如下。调整“x”属性，将其移动到“outerRadius”之外。调整“dy”属性，将文本元素向上移动一点，以更好地与刻度线对齐。
- en: Transform the `text` element if the angle is past the halfway point of the circle.
    Once again, we test against `Math.PI` and then, if it is past the halfway point,
    we `rotate` the text by 180 degrees and then translate it by negative 16 pixels,
    to fit it nicely along the edge of `outerRadius`. We also do the same test to
    see if the `text` element is past the halfway point of the circle and if it is
    we change the `text-anchor` property to pin the right edge of the text to the
    circle's edge. Finally, we add a class, `ticks`, to the `text` element and append
    the actual text, using `d3.formatPrefix`. `d3.formatPrefix` formats the number
    to be a friendlier representation of the value. `d3.formatPrefix` returns a function
    that formats numbers based on the supplied formatting argument.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果角度超过圆的一半，则转换“text”元素。再次对“Math.PI”进行测试，然后，如果超过一半，我们将文本旋转180度，然后将其平移16像素，以使其完美地贴合“outerRadius”的边缘。我们还对“text”元素是否超过圆的一半进行相同的测试，如果是，我们将“text-anchor”属性更改为将文本的右边缘固定在圆的边缘。最后，我们向“text”元素添加一个类“ticks”，并使用“d3.formatPrefix”附加实际文本。“d3.formatPrefix”根据提供的格式化参数格式化数字，使其更友好。
- en: 'In this case, we are looking to format the numbers with SI (system of units)
    prefixes ([https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes](https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes)),
    which will convert `5000` to `5k`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望使用SI（国际单位制）前缀（[https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes](https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes)）格式化数字，这将把“5000”转换为“5k”：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final code is the `fade` method referenced earlier. This function selects
    all elements that match the CSS selector. `.ribbons path` filters out any that
    are associated with the current selection and sets their `opacity` to the provided
    `opacity` argument:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码是之前提到的“fade”方法。这个函数选择与CSS选择器匹配的所有元素。“.ribbons path”过滤掉与当前选择相关的任何元素，并将它们的“opacity”设置为提供的“opacity”参数：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The effect looks like the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 效果如下截图所示：
- en: '![](img/eaa04668-dc32-4142-9109-fe294dc6f380.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaa04668-dc32-4142-9109-fe294dc6f380.png)'
- en: And with that, the chord diagram is complete. It's not the most complicated
    visualization you'll ever see with D3, but it's pretty good. Along with the donut
    chart and the bar chart, these three combine to illustrate many of the important
    features of D3.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，弦图就完成了。这并不是你在D3中见过的最复杂的可视化，但它还是相当不错的。连同甜甜圈图和条形图，这三种图表结合起来展示了D3的许多重要特性。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has introduced you to the world of D3\. As deep as this chapter
    has been, it only brushed the surface of what D3 has to offer. Hopefully, you'll
    take what you've learned here and you'll continue to experiment with it in the
    months and years to come. It's a rewarding tool to master.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了D3的世界。尽管本章深入，但只是触及了D3所提供的一部分。希望您能将在这里学到的知识继续在未来的几个月和几年中进行实验。这是一个值得掌握的有益工具。
- en: We have just one, short chapter, remaining in this book where we'll talk about
    some ways to optimize SVG for serving over the web. It's a vital area to at least
    have some knowledge of, especially if you're doing a lot of SVG in your site or
    application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们只剩下一个简短的章节，我们将讨论一些优化SVG在网络上提供的方法。这是一个至关重要的领域，至少应该有一些了解，特别是如果您在您的网站或应用程序中使用了大量的SVG。
