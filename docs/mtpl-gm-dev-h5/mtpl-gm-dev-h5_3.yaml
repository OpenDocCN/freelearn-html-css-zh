- en: Chapter 3. Feeding a Snake in Real Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。实时喂蛇
- en: After having covered the introductory material until now, it is time to let
    the rubber hit the road. This chapter will walk you through the upgrade of a single-player
    game into its multiplayer counterpart.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在现在已经涵盖了介绍性材料之后，是时候让橡皮碰到路了。本章将指导您将单人游戏升级为多人游戏。
- en: Unlike the game we developed in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Multiplayer Game Programming"), *Getting Started with Multiplayer Game Programming*,
    this game will need to be played in real-time, as opposed to being turn-based,
    which brings a whole set of challenges to the table. Once we solve the fundamental
    problems associated with synchronizing real-time game worlds across two or more
    players, we'll look into other fundamental, yet more involving concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第1章](ch01.html "第1章。开始多人游戏编程")中开发的游戏不同，*开始多人游戏编程*，这款游戏需要实时进行，而不是回合制，这给我们带来了一系列挑战。一旦我们解决了跨两个或更多玩家同步实时游戏世界所涉及的基本问题，我们将研究其他基本但更深入的概念。
- en: 'In this chapter, we will discuss the following principles and concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下原则和概念：
- en: Fixing your game loop for multiplayer gaming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复您的游戏循环以进行多人游戏
- en: Implementing an authoritative server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施权威服务器
- en: The lobby and room system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大厅和房间系统
- en: Matchmaking algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配算法
- en: Socket programming with **Socket.io**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Socket.io**进行套接字编程
- en: Hello world for game development
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏开发的hello world
- en: 'Surely, you must have written a *hello world* program when you were learning
    programming. In game development, I''d say the classic *hello world* game every
    developer should start with is snake. The concept is simple: move a block around
    the screen collecting special blocks that cause your block to stretch into a sequence
    of connected blocks that resemble the movement of a snake. If you run the head
    of the snake into its body, you lose.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习编程时，肯定写过一个*hello world*程序。在游戏开发中，我会说每个开发者都应该从经典的*hello world*游戏——贪吃蛇开始。概念很简单：在屏幕上移动一个方块，收集特殊方块，使您的方块拉伸成一系列相连的方块，类似于蛇的移动。如果你把蛇的头撞到它的身体，你就输了。
- en: '![Hello world for game development](img/B04669_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![游戏开发的hello world](img/B04669_03_01.jpg)'
- en: This implementation only allows the snake to move up, down, left, or right.
    Once you specify the direction for the snake to move, it will continue moving
    in that direction until you move it in a different direction. As a bonus, this
    particular implementation allows you to wrap around the screen—that is, if you
    move outside one of the sides of the screen, the snake will appear on the opposite
    side.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现只允许蛇向上、向下、向左或向右移动。一旦您指定了蛇的移动方向，它将继续沿着该方向移动，直到您将其移动到另一个方向。作为奖励，这个特定的实现允许您在屏幕上环绕——也就是说，如果您移动到屏幕的一侧之外，蛇将出现在相反的一侧。
- en: Catching a red block makes the snake grow by one extra block and increments
    your score by 10 points. Running the snake into itself stops the game loop and
    prints a simple game over message.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 捕捉红色方块会使蛇增长一个额外的方块，并将您的得分增加10分。将蛇撞到自己会停止游戏循环，并打印一个简单的游戏结束消息。
- en: In order to keep things simple for this initial version, there aren't any additional
    screens, including a main entry screen. The game simply begins once it is fully
    loaded. As we build upon this single player version of the game, we'll add the
    required screens that will make it more intuitive and user friendly for more than
    one player to join the game.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个初始版本保持简单，没有任何额外的屏幕，包括主入口屏幕。游戏加载完毕后游戏就开始了。随着我们在这个单人版本的游戏上进行扩展，我们将添加必需的屏幕，使其更直观和用户友好，以便多个玩家加入游戏。
- en: Setting up the game
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置游戏
- en: The goal of this initial single player version of the game is to make a playable
    game with as few lines of code by using the most basic model that we can build
    on. Thus, many additional details are left as an exercise for you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始的单人版本的游戏的目标是使用尽可能少的代码制作一个可玩的游戏，使用我们可以构建的最基本的模型。因此，许多额外的细节留作练习。
- en: In preparation for the next step, where we'll add server-side components to
    the game, we've written the first version of the game using Node.js and exported
    it to the browser using Browserify, as discussed in [Chapter 2](ch02.html "Chapter 2. Setting
    Up the Environment"), *Setting Up the Environment*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为游戏添加服务器端组件做好准备，我们使用Node.js编写了游戏的第一个版本，并使用Browserify将其导出到浏览器中，如[第2章](ch02.html
    "第2章。设置环境")中所讨论的那样，*设置环境*。
- en: package.json
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: package.json
- en: 'In keeping with the theme of making everything as simple possible, we will
    use a `package.json` file that only requires the **Express** framework to help
    us with routing and the Grunt plugins to help us to automatically build and export
    our modules with Browserify:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一切尽可能简单，我们将使用一个`package.json`文件，它只需要**Express**框架来帮助我们进行路由和Grunt插件来帮助我们使用Browserify自动构建和导出我们的模块：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Express.js** is a web framework for Node.js that allows us to very quickly
    set up the entire web server to host and serve our game. (refer to [http://expressjs.com/](http://expressjs.com/).)
    While Express plays a major role in our project, as it routes user requests for
    the appropriate files, understanding how it works is not a prerequisite to this
    chapter or the rest of the book. We will cover enough of the absolute basics to
    get you started using this powerful framework.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express.js**是一个用于Node.js的Web框架，它允许我们非常快速地设置整个Web服务器来托管和提供我们的游戏。（参考[http://expressjs.com/](http://expressjs.com/)。）虽然Express在我们的项目中扮演着重要角色，因为它路由用户请求以获取适当的文件，但了解它的工作原理并不是本章或本书的先决条件。我们将涵盖足够的绝对基础知识，让您开始使用这个强大的框架。'
- en: With all this in place, we use the Express command-line tool to build the project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们使用Express命令行工具来构建项目。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After executing the preceding sequence of commands, we have set up our boilerplate
    Node.js server with all of Express'' defaults, which, for our purpose, will work
    just fine. If anything goes wrong for whatever reason, there will be enough error
    messages to help you understand why and what the problems are. Provided that everything
    seems to be going fine after you enter the preceding commands, you can now test
    the project by starting your server with the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令序列后，我们已经设置好了我们的Node.js服务器的样板，其中包括Express的所有默认设置，对于我们的目的来说，这将完全正常工作。如果由于任何原因出现问题，将会有足够的错误消息帮助您理解问题所在。假设在输入上述命令后一切都进行得很顺利，您现在可以通过以下命令启动服务器来测试项目：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will start the server on port `3000`, which you can load on your modern
    browser of choice at `http://localhost:3000/`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口`3000`上启动服务器，您可以在现代浏览器上加载`http://localhost:3000/`。
- en: '![package.json](img/B04669_03_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![package.json](img/B04669_03_03.jpg)'
- en: The project structure will now look like the one in the preceding screenshot,
    except for the files enclosed within the red box that will not be generated by
    Express Generator. We will be creating and editing these files by hand, as you
    will see in the next several sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构现在看起来像前面的屏幕截图中的那样，除了红框内的文件不会被Express Generator生成。我们将手动创建和编辑这些文件，您将在接下来的几节中看到。
- en: Index.jade
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Index.jade
- en: 'By default, Express will create an index file that displays a welcome message.
    Since all we need for now is a single screen to display the game, we''ll just
    edit this file for our own purpose:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Express会创建一个显示欢迎消息的索引文件。由于我们现在只需要一个屏幕来显示游戏，我们将编辑这个文件以满足我们自己的目的：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you squint hard enough, you will see the HTML markup. If you're not familiar
    with the Jade templating language that Express uses by default, don't worry. What
    we do in the template is create a `<p>` element where we'll display the current
    score, one for the game over message, and a canvas element that we'll use to render
    the game. We also include the main script file, which is the output of the Grunt
    task that concatenates all our files and runs Browserify over them so that we
    can load it in the browser. Since `index.jade` is the only thing we'll see of
    Jade in this book, we won't go into it any further. For more information about
    how Jade works and what it can do, visit its website at [http://www.jade-lang.com](http://www.jade-lang.com).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用力眨眼，你会看到HTML标记。如果你不熟悉Express默认使用的Jade模板语言，不用担心。在模板中，我们创建了一个`<p>`元素，用来显示当前得分，一个用于游戏结束消息的元素，以及一个用来渲染游戏的canvas元素。我们还包括了主脚本文件，这是Grunt任务的输出，它将所有文件连接起来，并在它们上运行Browserify，以便我们可以在浏览器中加载它。由于`index.jade`是本书中我们将看到的Jade的唯一内容，我们不会进一步深入讨论。有关Jade的工作原理和功能的更多信息，请访问其网站[http://www.jade-lang.com](http://www.jade-lang.com)。
- en: The game modules
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏模块
- en: With the preceding structure in place, all that we need now is a couple of classes
    that implement the game. We'll do this in five classes so that we can reuse individual
    pieces of logic when we implement the game server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述结构，现在我们所需要的只是实现游戏的几个类。我们将用五个类来实现这个，这样当我们实现游戏服务器时，我们可以重用单独的逻辑片段。
- en: Game.js
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Game.js
- en: 'Here''s how we''ll implement our `game.js` file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将实现的`game.js`文件：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This module is the cornerstone of our project. It defines a very simple interface
    that abstracts away a simple game loop. All that we need to do when we implement
    this class is define the `update()` and `render()` methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块是我们项目的基石。它定义了一个非常简单的接口，抽象了一个简单的游戏循环。当我们实现这个类时，我们所需要做的就是定义`update()`和`render()`方法。
- en: You will notice the use of `requestAnimationFrame`, which is a special function
    defined by browsers to help us render the game. Since the game server won't render
    the game, neither will it have the function available to it, we'll need to adapt
    to that when we start working on the server. We'll talk more about frame rate
    independence in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到使用了`requestAnimationFrame`，这是浏览器定义的一个特殊函数，帮助我们渲染游戏。由于游戏服务器不会渲染游戏，它也不会有这个函数可用，所以当我们开始在服务器上工作时，我们需要适应这一点。我们将在下一节更多地讨论帧速率的独立性。
- en: snake.js
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: snake.js
- en: 'We''ll be adding the following code to our `snake.js` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向我们的`snake.js`文件添加以下代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The snake class extends Node's `EventEmitter` class so that it can emit events
    to the main application. This way we can isolate the specific behavior of the
    class and decouple it from any concrete implementation that responds to the snake
    as per our choice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 蛇类扩展了Node的`EventEmitter`类，以便它可以向主应用程序发出事件。这样我们就可以隔离类的具体行为，并将其与任何根据我们的选择对蛇作出响应的具体实现解耦。
- en: We also create a simple interface that the main application can use to control
    the snake. Again, since the immediate goal of this version is to get the game
    running in a browser, we will make use of browser-specific functionality, which
    in this case is `window.performance.now()`, which we'll replace with a module
    compatible with Node.js when we need to.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个简单的界面，主应用程序可以使用它来控制蛇。同样，由于此版本的即时目标是在浏览器中运行游戏，我们将利用浏览器特定的功能，这种情况下是`window.performance.now()`，当需要时我们将用兼容Node.js的模块替换它。
- en: Other supporting modules
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他支持模块
- en: There are three other classes (namely, `fruit.js`, `keyboard.js`, and `renderer.js`)
    that merely wrap the canvas and canvas context objects, a JavaScript equivalent
    of an enumeration to help us refer to keyboard input, and a simple point that
    we'll use to represent the pellet that the snake will eat. For brevity, we will
    omit the code for these classes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个其他类（即`fruit.js`，`keyboard.js`和`renderer.js`），它们仅仅包装了canvas和canvas上下文对象，一个JavaScript等价的枚举，帮助我们引用键盘输入，以及一个简单的点，我们将用它来表示蛇将吃的小球。为简洁起见，我们将省略这些类的代码。
- en: app.client.js
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.client.js
- en: 'Here''s how our `app.client.js` module should look like:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`app.client.js`模块应该是什么样子的：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first part of the `app.client` module, which is the concrete implementation
    of the game, imports all the required classes and modules and instantiates the
    game loop and player classes. Next (as seen previously) we implement the two game
    loop life cycle methods, namely the `update` and `render` methods. The only change
    that we'll need to make to these two methods when we add multiplayer functionality
    is to update and render an array of snakes rather than a single one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.client` 模块的第一部分是游戏的具体实现，它导入所有必需的类和模块，并实例化游戏循环和玩家类。接下来（如前所述），我们实现了两个游戏循环生命周期方法，即
    `update` 和 `render` 方法。当我们添加多人游戏功能时，我们需要对这两个方法进行的唯一更改是更新和渲染一组蛇，而不是单个蛇。'
- en: Since the actual update for each player is delegated to the `snake` class itself,
    the game loop has no issues over what is done inside that method. In fact, the
    game loop doesn't even care about the output of the `update` methods, as we'll
    see later. The key here is that the game loop's `update` method allows every entity
    in the game to update itself during the update phase.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个玩家的实际更新都委托给了 `snake` 类本身，游戏循环对该方法内部的操作没有任何问题。事实上，游戏循环甚至不关心 `update` 方法的输出，我们稍后会看到。关键在于游戏循环的
    `update` 方法允许游戏中的每个实体在更新阶段更新自身。
- en: Similarly, during the render phase, the game loop only cares about rendering
    the current state of each entity that it wants to render. Although we could have
    also delegated the rendering of the snake and other visual entities, we'll leave
    the concrete rendering inside the game loop for simplicity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在渲染阶段，游戏循环只关心渲染它想要渲染的每个实体的当前状态。虽然我们也可以委托蛇和其他可视实体的渲染，但为了简单起见，我们将具体的渲染留在游戏循环内部。
- en: Finally, at the end of the `app.client` module, we hook up to the incoming events
    that we care about. Here, we listen for game events that were created by the `snake`
    object. The `Snake.events.POWER_UP` and `Snake.events.COLLISION` custom events
    let us execute callback functions to respond to when the snake consumes a pellet
    and collides with itself respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `app.client` 模块的末尾，我们连接到我们关心的传入事件。在这里，我们监听由 `snake` 对象创建的游戏事件。`Snake.events.POWER_UP`
    和 `Snake.events.COLLISION` 自定义事件让我们执行回调函数，以响应蛇吃掉颗粒和与自身碰撞时的情况。
- en: 'Next, we bind to the keyboard and listen for key press events. Due to the game
    mechanics that we implement, we don''t care about any keys that are not being
    pressed, so that''s why we don''t register any listeners for these events. This
    particular block of code is a great candidate for refactoring later on since the
    way the client will receive this kind of input will be different from the server.
    For example, the client will still take input directly from the user using the
    same keyboard events as input, but the server will receive this input from the
    user, which will notify the server of its state through the socket connection:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们绑定键盘并监听按键事件。由于我们实现的游戏机制，我们不关心未被按下的任何键，这就是为什么我们不为这些事件注册任何监听器。这段代码块将来可以进行重构，因为客户端接收此类输入的方式将与服务器不同。例如，客户端仍然会直接从用户那里接收输入，使用相同的键盘事件作为输入，但服务器将从用户那里接收此输入，通过套接字连接通知服务器其状态：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The game loop
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: As you know, the game loop is the very core of any real-time game. Although
    the game loop serves a fairly simple function, let us now consider some of the
    implications of having a game server and client running together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，游戏循环是任何实时游戏的核心。尽管游戏循环的功能相当简单，但现在让我们考虑一下同时运行游戏服务器和客户端的一些影响。
- en: Frame rate independence
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧率独立性
- en: The purpose of the game loop is nothing more than to ensure that the game runs
    in a consistent, ordered manner. For example, if we draw the current game state
    before we update it, the player might find the game to be slightly out of sync
    when they interact with it since the current display would be at least one frame
    behind what the player would expect it to be.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的目的只是确保游戏以一致有序的方式运行。例如，如果我们在更新游戏状态之前绘制当前游戏状态，玩家在与游戏交互时可能会发现游戏略微不同步，因为当前显示的内容至少会比玩家期望的要滞后一个帧。
- en: In addition, and this is particularly so in JavaScript's event-based input system,
    if we update the game every time we receive input from the user, we might have
    different parts of the game updating at different times, making the experience
    even more out of sync.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 JavaScript 的基于事件的输入系统中，如果我们每次从用户那里接收输入就更新游戏，可能会导致游戏的不同部分在不同时间更新，使体验更加不同步。
- en: 'Thus, we put a game loop in place to ensure that, after any input is handled
    and cached and until the next `tick` of the game loop, we can apply the input
    during the `update` phase of the game step and then render the outcome of the
    update:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们设置了游戏循环，以确保在处理和缓存任何输入之后，直到游戏循环的下一个 `tick`，我们可以在游戏步骤的 `update` 阶段应用输入，然后渲染更新的结果：
- en: '![Frame rate independence](img/B04669_03_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: 帧率独立性
- en: The most obvious solution to this problem is to model the input space within
    your game; then, query this during the `update` phase and respond accordingly.
    In other programming environments, we can simply query the input devices directly.
    Since JavaScript exposes events instead, we can't ask the runtime whether the
    left key is currently pressed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题最明显的解决方案是在游戏中建模输入空间；然后，在 `update` 阶段查询并相应地做出响应。在其他编程环境中，我们可以直接查询输入设备。由于
    JavaScript 暴露事件，我们无法询问运行时左键当前是否被按下。
- en: 'Next, we need to update the game, which in most cases means that we''ll move
    something just a tiny bit. After a few frames have been updated, these small movements
    that we''ve updated in each iteration will combine to create a smooth motion.
    In practical terms, what we need to do once the game loop has completed a cycle
    is to call the game loop again for the next cycle:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新游戏，这在大多数情况下意味着我们会微调一些东西。在更新了几帧之后，我们在每次迭代中更新的这些小动作将合并在一起，形成平滑的运动。实际上，一旦游戏循环完成一个周期，我们需要再次调用游戏循环以进行下一个周期的循环：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While a traditional game loop in most other programming languages might look
    something like the preceding code snippet, we can''t do this in JavaScript because
    the while loop would block JavaScript''s single thread, causing the browser to
    lock up:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数其他编程语言中，传统的游戏循环可能看起来像前面的代码片段，但在JavaScript中我们不能这样做，因为while循环会阻塞JavaScript的单个线程，导致浏览器锁死：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A more appropriate approach in JavaScript is to use one of the timer functions
    (either `setTimeout` or `setInterval`) to call the game step method. While this
    solution actually works, unlike the while loop idea, we can run into issues such
    as the game consuming too much CPU (as well as the battery life of a mobile device),
    particularly when the loop continues to execute when the game is not running.
    We can also run into issues with the timer approach if JavaScript is busy with
    other things, and the `tick` function can't be called as often as we'd like.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中更合适的方法是使用定时器函数（`setTimeout`或`setInterval`）之一来调用游戏步骤方法。虽然这个解决方案实际上是有效的，不像while循环的想法，但我们可能会遇到一些问题，比如游戏消耗太多CPU（以及移动设备的电池寿命），特别是当游戏不运行时循环继续执行。如果JavaScript忙于其他事情，定时器方法也可能会出现问题，`tick`函数无法像我们希望的那样频繁地被调用。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may wonder why we make the call to `setTimeout` and `requestAnimationFrame`
    at the beginning of the `tick` method, instead of at the end, after we have actually
    executed the code inside the method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么我们在`tick`方法的开头而不是结尾调用`setTimeout`和`requestAnimationFrame`，而不是在方法内部的代码实际执行后。
- en: The reason for this is that calling either of these two functions simply schedules
    the `callback` function to run at the next event loop cycle. Calling `setTimeout`
    or `requestAnimationFrame` returns execution to the next command in the function
    calling it immediately, then the rest of the function executes to completion.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以这样做是因为调用这两个函数中的任何一个都只是简单地安排`callback`函数在下一个事件循环周期运行。调用`setTimeout`或`requestAnimationFrame`会立即将执行返回给调用它的函数的下一个命令，然后函数的其余部分执行完成。
- en: Once the function returns, JavaScript will execute the next piece of code in
    the event loop, which was added to the loop some time in the past. In other words,
    if JavaScript detects user input while we're executing our game `tick` method
    or some other event takes place, these events will be added to the queue and will
    be handled after our tick method returns. Thus, if we wait until the end of the
    tick method to schedule it again with the event loop, we may find the tick method
    waiting in line (so that it can have a turn at the CPU again) before other callbacks
    are handled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数返回，JavaScript将执行事件循环中添加的下一个代码片段，换句话说，如果JavaScript在执行我们的游戏`tick`方法或其他事件发生时检测到用户输入，这些事件将被添加到队列中，并在tick方法返回后处理。因此，如果我们等到tick方法的结尾再次使用事件循环调度它，我们可能会发现tick方法在排队等候（以便它可以再次获得CPU的使用权）之前，其他回调将被处理。
- en: By scheduling the `tick` method early on, we can be sure that it will be called
    again as soon as it can after it completes its current execution, even if other
    events are triggered during the current execution, and other code is placed on
    the event loop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提前调度`tick`方法，我们可以确保它在当前执行完成后尽快再次被调用，即使在当前执行期间触发了其他事件，并且其他代码被放入事件循环中。
- en: 'Finally, the most appropriate way to write a game loop in JavaScript is to
    use the more recent `window.requireAnimationFrame` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在JavaScript中编写游戏循环的最合适的方法是使用较新的`window.requireAnimationFrame`函数：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`RequestAnimationFrame` is a handy function implemented in browsers that we
    can use to ask the browser to invoke our callback function right before the browser
    performs its next repaint. Since the inner workings of the browser are outside
    the scope of JavaScript, the refreshing rate is now at the operating system level,
    which is much more precise. In addition, since the browser knows when it needs
    to repaint and is much closer to the display device than JavaScript can possibly
    be, it can make many optimizations that we couldn''t do on our own.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`是浏览器中实现的一个方便的函数，我们可以使用它来要求浏览器在进行下一次重绘之前调用我们的回调函数。由于浏览器内部工作超出了JavaScript的范围，刷新率现在处于操作系统级别，这更加精确。此外，由于浏览器知道何时需要重绘，并且比JavaScript更接近显示设备，它可以进行许多我们无法做到的优化。'
- en: Calling `requestAnimationFrame` will return an integer value that will map to
    the provided function in the callback list. We can use this ID number to cancel
    our callback from being triggered when the browser determines that it should have.
    This is a handy way to pause execution of the game loop without using a conditional
    statement at the beginning of the callback, which would normally evaluate to false
    most of the time (or so we hope).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`requestAnimationFrame`将返回一个整数值，该值将映射到回调列表中提供的函数。我们可以使用这个ID号来取消触发我们的回调，当浏览器确定它应该触发时。这是一种方便的方法，可以暂停游戏循环的执行，而不需要在回调的开头使用条件语句，这通常大部分时间都会评估为false（或者我们希望如此）。
- en: Finally, the callback function that we supply to `RequestAnimationFrame` will
    be passed a timestamp value in the form of a `DOMHighResTimeStamp` type. This
    timestamp represents the time when the callbacks registered with `RequestAnimationFrame`
    get triggered in a given cycle. We can use this value to calculate the delta time
    since the previous frame, thus breaking our game loop out of the time-space continuum,
    which we'll discuss next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供给`RequestAnimationFrame`的回调函数将会传递一个时间戳数值，格式为`DOMHighResTimeStamp`类型。这个时间戳代表了在给定周期内，使用`RequestAnimationFrame`注册的回调被触发的时间。我们可以使用这个数值来计算自上一帧以来的时间差，从而将我们的游戏循环脱离时间空间连续性，接下来我们将讨论这一点。
- en: Time-based game loop
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于时间的游戏循环
- en: 'Now that we have an effective way to update our game as fast as the underlying
    hardware is able to, we just need to control the rate at which the update happens.
    One option would be to ensure that the game loop doesn''t execute again until
    at least some time has elapsed. This way we will not update more often than we
    know we have to. The other option is to calculate how long the previous update
    took and send that number into the update function so that it can move everything
    relative to that time difference:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一种有效的方法，可以使我们的游戏更新速度与底层硬件的能力一样快，我们只需要控制更新发生的速率。一种选择是确保游戏循环在至少经过一定时间后才再次执行。这样我们就不会更新得比我们必须要更新的更频繁。另一种选择是计算上一次更新所花费的时间，并将该数字发送到更新函数中，以便根据时间差移动所有内容：
- en: '![Time-based game loop](img/B04669_03_05.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![基于时间的游戏循环](img/B04669_03_05.jpg)'
- en: As illustrated in the preceding figure, if we update the game twice as fast
    in one browser or device, then the time taken to update a single frame (also known
    as the **delta time**) will be half as well. Using this delta as a factor in the
    physics update, we can make each update relative to how long it'll take to update
    a single frame. In other words, in the course of a whole second, we can either
    update the game a few times where each time the update is larger or we update
    the game many times during the same second, but each update would be much smaller.
    At the end of the second, we would have still moved the same distance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，如果我们在一个浏览器或设备上以两倍的速度更新游戏，那么更新单帧所需的时间（也称为**时间差**）也会减半。使用这个时间差作为物理更新的因素，我们可以使每次更新相对于更新单帧所需的时间。换句话说，在整整一秒钟内，我们可以选择在几次更新中每次更新的幅度更大，或者在同一秒内多次更新游戏，但每次更新的幅度更小。在一秒结束时，我们仍然会移动相同的距离。
- en: Multiple game loops
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个游戏循环
- en: Running a game smoothly and consistently across different CPUs is a victory
    on its own. Now that we're past that, let's think about how we can actually achieve
    it across the client and the server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的CPU上平稳一致地运行游戏本身就是一种胜利。既然我们已经过了这一关，现在让我们考虑如何在客户端和服务器上实现这一点。
- en: On the browser, we can run the game for the user using `requestAnimationFrame`,
    as demonstrated earlier. On the server, however, there is no `requestAnimationFrame`.
    Worse yet, we can't quite send updates across the network to all participants
    at a full 60 updates per second. In theory, we could very well do that—maybe for
    a few seconds before the server heats up and melts down. In other words, running
    60 updates per second for every game in the same server would cause tremendous
    load on the server. Thus, we will need to slow down the update's pace on the server.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上，我们可以使用`requestAnimationFrame`来为用户运行游戏，就像之前演示的那样。然而，在服务器上，没有`requestAnimationFrame`。更糟糕的是，我们无法以每秒60次的速度将更新发送到所有参与者。理论上，我们完全可以这样做——也许在服务器在短短几秒内就会过热并崩溃之前。换句话说，对于同一服务器中的每个游戏来说，每秒运行60次更新会给服务器带来巨大的负载。因此，我们需要减慢服务器上更新的速度。
- en: First things first, though. Since there is no `requestAnimationFrame` in Node.js,
    we know that we can't use it. However, since the concrete implementation of the
    game loop for the game server is separate from the game client's, we can just
    choose another timer mechanism that Node offers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于Node.js中没有`requestAnimationFrame`，我们知道我们不能使用它。然而，由于游戏服务器的游戏循环的具体实现与游戏客户端的游戏循环是分开的，我们可以选择Node提供的另一种计时器机制。
- en: Secondly, we need to have a second timer running in the server so that it can
    send updates to the clients at a much slower pace. If we actually try to send
    updates to every single client at 60 frames per second, we will likely overload
    the server very quickly and performance will decrease.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要在服务器上运行第二个计时器，以便以更慢的速度向客户端发送更新。如果我们实际上尝试以每秒60帧的速度向每个客户端发送更新，我们很快就会使服务器过载，并且性能会下降。
- en: The solution to the client update problem is to send updates at a slower but
    consistent rate, allowing the server to be the ultimate authority on game state
    in a way that we can scale. Between updates from the server, if the game requires
    quicker updates, we can make the game client update itself in the best way it
    can; then, once it receives information from the server, we can fix the client
    state if needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 解决客户端更新问题的方法是以更慢但一致的速度发送更新，允许服务器以可扩展的方式成为游戏状态的最终权威。在服务器发送更新之间，如果游戏需要更快的更新，我们可以让游戏客户端以最佳方式更新自身；然后，一旦它从服务器接收到信息，我们可以根据需要修复客户端状态。
- en: There are two timer functions that are commonly used in Node.js as higher resolution
    replacements for `setTimeout()`. These are `setImmediate()` and `process.nextTick()`.
    The reason you will want to use one of these two functions instead of `setTimeout()`
    is because `setTimeout()` doesn't guarantee the delay you specify nor does it
    guarantee the order in which the events will be executed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，有两个常用的计时器函数，可以作为`setTimeout()`的高分辨率替代品。这两个函数分别是`setImmediate()`和`process.nextTick()`。你会选择使用这两个函数而不是`setTimeout()`的原因是因为`setTimeout()`不能保证你指定的延迟，也不能保证事件执行的顺序。
- en: For a better alternative, we can use `setImmediate` to schedule a callback to
    run after every event that is currently sitting on the event queue. We could also
    use `process.nextTick`, which will schedule the callback to run right after the
    current block of code finishes its execution.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更好的替代方案，我们可以使用`setImmediate`来安排一个回调，在当前坐在事件队列上的每个事件之后运行。我们还可以使用`process.nextTick`，它将安排回调在当前代码块执行完毕后立即运行。
- en: While `process.nextTick` might seem like the better option between the two,
    keep in mind that it will not give the CPU a chance to execute other code in the
    event queue (or allow the CPU to rest), causing execution to consume 100 percent
    of the CPU. Thus, for the particular use case of a game loop in your Node.js game
    simulation, you might be better off using `setImmediate`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`process.nextTick`似乎是两者之间更好的选择，但请记住它不会给CPU执行事件队列中的其他代码的机会（或允许CPU休息），导致执行占用CPU的100％。因此，在您的Node.js游戏模拟中的游戏循环的特定用例中，您可能最好使用`setImmediate`。
- en: As mentioned before, there will be two timers or loops running in the game server.
    The first is the physics update loop, which will use `setImmediate` in an attempt
    to efficiently run at a full 60 fps. The second will be the client sync loop,
    which doesn't need to run as fast.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，游戏服务器将运行两个定时器或循环。第一个是物理更新循环，将使用`setImmediate`来尝试以完整的60 fps高效运行。第二个将是客户端同步循环，不需要运行得那么快。
- en: The purpose of the client sync loop is to authoritatively tell the clients what
    the real state of the game is so that each client can update itself. If we try
    to let the server adjust each client at every frame, we would have a very slow
    game and a very slow server. A simple, widely used solution is to only synchronize
    the clients a couple of times per second. In the mean time, each client can play
    the game locally and then make any necessary corrections when the server updates
    its state.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端同步循环的目的是权威性地告诉客户端游戏的真实状态，以便每个客户端可以更新自身。如果我们试图让服务器在每一帧调整每个客户端，游戏和服务器都会变得非常缓慢。一个简单而广泛使用的解决方案是每秒只同步几次客户端。与此同时，每个客户端可以在本地玩游戏，然后在服务器更新其状态时进行任何必要的更正。
- en: Implementing an authoritative server
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施权威服务器
- en: The strategy that we'll use for this server will be to run two game loops for
    two different purposes. The first loop is the physics update, which we'll run
    close to the same frequency as the clients' loop. The second loop, which we'll
    refer to as the client sync loop, is run at a slower pace, and at each tick, it
    will send the entire game state to every connected client.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器的策略是为了两个不同的目的运行两个游戏循环。第一个循环是物理更新，我们会以接近客户端循环频率的频率运行。第二个循环，我们称之为客户端同步循环，以较慢的速度运行，并在每个时刻将整个游戏状态发送给每个连接的客户端。
- en: At this point, we'll only focus on getting the server working as we've described.
    The current implementation of the clients will continue to work as it did, managing
    the entire game logic locally. Any data a client receives from the server (using
    the game sync loop) will only be rendered. Later in the book, we'll discuss the
    concept of client prediction, where we'll use the input from the game sync loop
    as the actual input for the game's logic rather than just rendering it mindlessly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们只关注让服务器按照我们描述的方式工作。客户端的当前实现将继续像以前一样工作，本地管理整个游戏逻辑。客户端从服务器接收的任何数据（使用游戏同步循环）将只被渲染。在本书的后面，我们将讨论客户端预测的概念，其中我们将使用游戏同步循环的输入作为游戏逻辑的实际输入，而不仅仅是无意识地渲染它。
- en: Game server interface
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏服务器接口
- en: The first thing to change from the current implementation of the game client
    will be to break the input and output points so that they can communicate with
    the socket layer in the middle. We can think of this as a programming interface
    that specifies how the server and clients will communicate.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从当前游戏客户端的实现中要改变的第一件事是分解输入和输出点，以便它们可以与中间的套接字层通信。我们可以将其视为一个编程接口，指定服务器和客户端将如何通信。
- en: 'For this, let''s create a simple module in our project to serve as a poor man''s
    enum since enums aren''t available in JavaScript. Though the data in this module
    will not be immutable, it will give us the advantage since the IDE will automatically
    suggest values, correct us when we make a typing mistake, and put all of our intents
    in one place. By convention, any event that starts with the word *server*_ represent
    actions for the server. From example, the event named `server_newRoom` asks the
    server to create a new room:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，让我们在项目中创建一个简单的模块，作为JavaScript中没有枚举的可怜之人的枚举。尽管此模块中的数据不是不可变的，但它将给我们带来优势，因为IDE将自动建议值，在我们犯拼写错误时纠正我们，并将我们所有的意图放在一个地方。按照惯例，任何以*server*_开头的事件代表服务器的操作。例如，名为`server_newRoom`的事件要求服务器创建一个新房间：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now use the string values defined in this module to register callbacks for
    and emit events to sockets in a consistent and predictable way between the client
    and the server. For example, when we emit an event named `modules.exports.server_spawnFruit`,
    we know that what is intended is that a message to be received by the server has
    the action name of `spawnFruit`. In addition, you'll notice that we'll use `socket.io`
    to abstract away the socket communication between the client and the server. If
    you're curious to get started with `socket.io` right now, feel free to skip ahead
    to the end of this chapter and read the *Socket.io* section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用此模块中定义的字符串值来注册回调并以一致和可预测的方式在客户端和服务器之间发出套接字事件。例如，当我们发出名为`modules.exports.server_spawnFruit`的事件时，我们知道意图是让服务器接收到一个名为`spawnFruit`的动作。此外，您会注意到我们将使用`socket.io`来抽象化客户端和服务器之间的套接字通信。如果您现在想开始使用`socket.io`，请随时跳到本章末尾并阅读*Socket.io*部分。
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the given example, we first include our module into a `gameEvents` variable.
    We then register a callback function whenever a socket receives an `server_spawnFruit`
    event. Presumably, this code is in some server code, as indicated by the server
    keyword at the beginning of the key name. This callback function takes a data
    argument created by the client (whoever is sending the command on the other end
    of the socket). This data object has the data that is needed by the specific call
    to spawn a new fruit object for the game.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的示例中，我们首先将我们的模块包含到`gameEvents`变量中。然后，我们注册一个回调函数，每当套接字接收到`server_spawnFruit`事件时就会调用该函数。据推测，这段代码在某个服务器代码中，因为键名开头的server关键字指示了这一点。这个回调函数接受一个由客户端创建的数据参数（在套接字的另一端发送命令的人）。这个数据对象包含了生成游戏中新水果对象所需的数据。
- en: Next, we use the input data into the socket event to perform some task (in this
    case, we generate a random position where a fruit can be added in the game world).
    With this data on hand, we emit a socket command back to the client to send the
    position that we just generated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用套接字事件中的输入数据执行一些任务（在这种情况下，我们生成一个随机位置，可以在游戏世界中添加水果）。有了这些数据，我们向客户端发出一个套接字命令，发送我们刚刚生成的位置。
- en: Updating the game client
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏客户端
- en: The first thing to change in the client code is to add different screens. At
    a minimum, we need two different screens. One of the screens will be the game
    board as we've implemented so far. The other is the lobby, which we'll discuss
    in more detail later. In brief, the lobby is an area where players go before they
    join a specific room, which we'll also discuss shortly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端代码中要改变的第一件事是添加不同的屏幕。至少，我们需要两个不同的屏幕。其中一个屏幕将是游戏板，就像我们迄今为止实现的那样。另一个是大厅，我们稍后会详细讨论。简而言之，大厅是玩家在加入特定房间之前所在的区域，我们稍后也会讨论。
- en: '![Updating the game client](img/B04669_03_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![更新游戏客户端](img/B04669_03_06.jpg)'
- en: Once in the lobby, the player can choose to join an existing room or create
    and join a new room with no players in it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在大厅中，玩家可以选择加入现有房间或创建并加入一个没有玩家的新房间。
- en: 'In a perfect world, your game engine would offer great support for multiple
    screens. Since the sample game we''re writing is not written in such a game engine,
    we''ll just use basic HTML and CSS and write every screen along with any supporting
    props and widgets in the same HTML file that will be served up originally:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界中，你的游戏引擎会为多个屏幕提供很好的支持。由于我们正在编写的示例游戏不是用这样的游戏引擎编写的，我们将只使用基本的HTML和CSS，并在同一个HTML文件中编写每个屏幕以及任何支持的道具和小部件：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are only three blocks of code in the previous template. First, we have
    a `div` element with an ID of `lobby` inside which we dynamically add a list of
    available game rooms. Next, there is a `div` element with an ID of `main`, initially
    with a class of `hidden`, so that this screen is not visible initially. Finally,
    we include the `socket.io` library as well as our app.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个模板中只有三个代码块。首先，我们有一个ID为`lobby`的`div`元素，其中我们动态添加了一个可用游戏房间的列表。接下来，有一个ID为`main`的`div`元素，最初带有一个名为`hidden`的类，因此这个屏幕最初是不可见的。最后，我们包括了`socket.io`库以及我们的应用程序。
- en: 'The simplest way to bind to that HTML structure is to create module-wide global
    variables that reference each desired node. Once these references are in place,
    we can attach the necessary event listeners so that the player can interact with
    the interface:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到HTML结构的最简单方法是创建模块范围的全局变量，引用每个所需的节点。一旦这些引用就位，我们就可以附加必要的事件侦听器，以便玩家可以与界面交互：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the initial game screen is the lobby, and the markup for the lobby is
    already visible, we don't do anything else to set it up. We simply register a
    socket callback to be invoked when we receive a list of available rooms and create
    individual HTML nodes with event listeners for each, attaching them to the DOM
    when we're ready.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于初始游戏屏幕是大厅，并且大厅的标记已经可见，我们不需要做其他设置。我们只需注册一个套接字回调，当我们收到可用房间列表时就调用它，并在准备好时将单独的HTML节点附加到DOM上。
- en: 'Inside a different socket callback function, this time the one associated with
    the `roomJoined` custom event, we first make the lobby screen invisible, and then
    we make the main screen visible. We do this by adding and removing a CSS class
    named hidden, whose definition is shown in the following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的套接字回调函数内部，这次是与`roomJoined`自定义事件相关联的回调函数，我们首先使大厅屏幕不可见，然后使主屏幕可见。我们通过添加和移除名为hidden的CSS类来实现这一点，其定义如下代码片段所示：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Understanding the game loop
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解游戏循环
- en: The next set of changes that we'll need to make on the original game code is
    in the `game` class. As you'll remember, this class defines a basic game life
    cycle, exposing the functions `update` and `render`, which get implemented by
    whoever uses it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对原始游戏代码进行的下一组更改是在`game`类中。你会记得，这个类定义了一个基本的游戏生命周期，暴露了`update`和`render`函数，由使用它的人来实现。
- en: Since the core of the game loop defined in this class (found in `Game.prototype.loop`)
    uses `window.requestAnimationFrame`, we'll need to get rid of that call since
    it will not be available in Node.js (or in any other environment outside the browser).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个类中定义的游戏循环的核心（在`Game.prototype.loop`中找到）使用了`window.requestAnimationFrame`，我们需要摆脱这个调用，因为它在Node.js（或者在浏览器之外的任何其他环境）中都不可用。
- en: One technique that is commonly used to allow us the flexibility to write a single
    module that is used in both the browser and the server is to wrap the browser-
    and server-specific functions in a custom module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于允许我们灵活地编写一个既在浏览器中使用又在服务器中使用的单个模块的技术是将浏览器和服务器特定的函数封装在一个自定义模块中。
- en: Using Browserify, we can write two separate modules that wrap the environment-specific
    functionality but only reference a single one in the code. By configuring Browserify
    property, we can tell it to compile a different module whenever it sees a `require`
    statement for the custom wrapper module. For simplicity, we have only mentioned
    this capability here, but we will not get into it in this book. Instead, we will
    write a single component that automatically detects the environment it's under
    at runtime and responds accordingly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Browserify，我们可以编写两个分开的模块，包装环境特定的功能，但在代码中只引用一个。通过配置Browserify属性，我们可以告诉它在看到对自定义包装模块的`require`语句时编译不同的模块。为简单起见，我们只在这里提到了这种能力，但在本书中我们不会深入讨论。相反，我们将编写一个单一组件，它可以在运行时自动检测所处的环境并做出相应的响应。
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The tick component is made up of a function that returns one of the two functions,
    depending on the availability of `window.requestAnimationFrame`. This pattern
    might look somewhat confusing at first, but it offers the benefit that it only
    detects the environment once and then makes the environment-specific functionality
    every time after the initial setup.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: tick组件由一个函数组成，根据`window.requestAnimationFrame`的可用性返回两个函数中的一个。这种模式一开始可能看起来有些混乱，但它的好处在于它只在初始设置之后检测环境一次，然后每次都根据环境进行特定功能。
- en: Note that what we export from this module is a call to `tick` and not a mere
    reference. This way, when we require the module, what ends up being referenced
    in the client code is the function returned by `tick`. In a browser, this will
    be a reference to `window.requestAnimationFrame`, and in node, it'll be a function
    that calls `setTimeout`, by passing an incrementing number to it, similar to how
    the browser version of tick would.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从这个模块导出的是对`tick`的调用，而不仅仅是一个引用。这样，当我们需要这个模块时，在客户端代码中被引用的是`tick`返回的函数。在浏览器中，这将是对`window.requestAnimationFrame`的引用，在node中，它将是一个调用`setTimeout`的函数，通过向其传递一个递增的数字，类似于浏览器版本的`tick`。
- en: Game client's game loop
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏客户端的游戏循环
- en: Now that the abstract game loop class is ready for use in any environment, let's
    take a look at how we could refactor the existing client implementation so that
    it can be driven by sockets connected to the authoritative server.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，抽象的游戏循环类已经准备在任何环境中使用，让我们看看如何重构现有的客户端实现，以便它可以由连接到权威服务器的socket驱动。
- en: Note how we no longer determine when a new fruit should be generated. All that
    we check for on the client is how we might move the player's character. We could
    let the server tell us where the snake is at each frame, but that would overload
    the application. We could also only render the main snake when the server syncs
    its state, but that would make the entire game seem really slow.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不再确定何时生成新的水果。在客户端上，我们只检查如何移动玩家角色。我们可以让服务器告诉我们每一帧蛇在哪里，但这会使应用程序负担过重。我们也可以只在服务器同步状态时渲染主要蛇，但这会使整个游戏看起来非常慢。
- en: What we do instead is just copy the entire logic here and ignore what the server
    says about it when we sync. Later, we'll talk about client prediction; at that
    point, we'll add some logic here to correct any discrepancies that we find when
    the server syncs with us.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是在这里复制整个逻辑，并在同步时忽略服务器对其的说法。稍后，我们将讨论客户端预测；在那时，我们将在这里添加一些逻辑来纠正我们在服务器同步时发现的任何差异。
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Game server's game loop
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏服务器的游戏循环
- en: This is where things get exciting. Before we implement the game loop for the
    server-side code, we'll first need to implement an API that the client will use
    to query the server and issue other commands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事情变得令人兴奋的地方。在我们为服务器端代码实现游戏循环之前，我们首先需要实现一个API，客户端将使用它来查询服务器并发出其他命令。
- en: 'One of the benefits of using `express` in this project is that it works so
    well with `Socket.io`. Without stealing any thunder from the section later in
    this chapter that is dedicated to Socket.io, this is how our main server script
    will look like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中使用`express`的一个好处是它与`Socket.io`非常配合。在本章后面专门介绍Socket.io之前，我们的主服务器脚本将如下所示：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Adding to the default Express `app.js` script, we import `Socket.io`, the game
    events module that we defined earlier, and the game application that we will discuss
    throughout the rest of the chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的Express `app.js`脚本中，我们导入了`Socket.io`，游戏事件模块，以及我们之前定义的游戏应用程序，这将在本章的其余部分中讨论。
- en: Next, after we've finished setting up Express, we set up our socket communication
    with the clients. The first step is to wait until a connection has been established,
    which will give us access to an individual socket that is bound to an individual
    client.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在设置Express完成后，我们设置与客户端的socket通信。第一步是等待连接建立，这将使我们可以访问绑定到单个客户端的单个socket。
- en: Once we have a live socket, we configure all the events we care about by registering
    custom event listeners to each event. You will notice that some of the sample
    event listeners mentioned previously also emit events back to the requesting socket,
    while others simply call methods on the game object. The difference between the
    two scenarios is that when we only need to talk to a single client (the requesting
    client), we contact that socket directly from the event listener. There are situations,
    however, when we might wish to talk to all the sockets connected to the same room.
    When this is the case, we must let the game object alert all the players that
    it needs since it will know who all are the clients that belong to a given room.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个活跃的socket，我们通过向每个事件注册自定义事件监听器来配置我们关心的所有事件。您会注意到，先前提到的一些示例事件监听器也会向请求的socket发出事件，而其他的则只是在游戏对象上调用方法。两种情况之间的区别在于，当我们只需要与单个客户端（请求的客户端）通信时，我们直接从事件监听器中联系该socket。然而，有时我们可能希望与连接到同一房间的所有socket进行通信。在这种情况下，我们必须让游戏对象通知所有需要的玩家，因为它将知道所有属于给定房间的客户端。
- en: Lobby and room system
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大厅和房间系统
- en: The concepts of game rooms and a lobby are central to multiplayer gaming. In
    order to understand how it works, think about the game server as a building in
    which people go in order to play games together.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏房间和大厅的概念对多人游戏至关重要。为了理解其工作原理，可以将游戏服务器视为人们一起玩游戏的建筑物。
- en: Before entering the building, a player may stand in front of the building and
    enjoy the beauty of the outside walls. In our metaphor, staring at the front of
    the building would be the equivalent of being greeted by a splash screen that
    introduces the game.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入建筑物之前，玩家可以站在建筑物前面，欣赏外墙的美丽。在我们的比喻中，凝视建筑物的前面相当于被游戏介绍的启动画面所欢迎。
- en: Upon entering the building, the player may or may not see some options from
    which to make a choice, such as a listing of the available floor to which he or
    she may want to go. In some games, you can choose the type of game to play as
    well as a difficulty level. Think of this as taking an elevator to a specific
    floor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 进入建筑物后，玩家可能会看到一些选项供其选择，比如他或她可能想去的可用楼层的列表。在一些游戏中，您可以选择要玩的游戏类型以及难度级别。可以将此视为乘坐电梯到特定楼层。
- en: Finally, you arrive at a lobby. Similar to the way a lobby works in real life,
    in multiplayer games, the lobby is a special room that multiple players go to
    before entering a specific room where the playing takes place. In the lobby, you
    can see what the available rooms are and then choose one to join.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您到达了一个大厅。与现实生活中大厅的工作方式类似，在多人游戏中，大厅是多个玩家在进入进行游戏的特定房间之前去的一个特殊房间。在大厅中，您可以看到可用的房间，然后选择一个加入。
- en: Once you have decided which room you'd like to join, you can now enter that
    room and participate in an existing game with other players. Alternatively, you
    can join an empty room and wait for others to join you there.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定加入哪个房间，您现在可以进入该房间并与其他玩家一起参与现有游戏。或者，您可以加入一个空房间，并等待其他人加入。
- en: Typically, there is never an empty room in multiplayer games. Every room has
    at least one player in it, and every player can belong to one room at a time.
    Once all players have left the room, the game server would delete the room and
    release the associated resources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，多人游戏中永远不会有空房间。每个房间至少有一个玩家，并且每个玩家一次只能属于一个房间。一旦所有玩家离开房间，游戏服务器将删除该房间并释放相关资源。
- en: Implementing the lobby
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现大厅
- en: With the basic understanding of a lobby, we can implement it in a number of
    ways. Generally speaking, a lobby is actually a special room that all players
    join before they end up at a room where they'll play a particular game.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对大厅的基本理解，我们可以以多种方式实现它。一般来说，大厅实际上是所有玩家在最终进入进行特定游戏的房间之前加入的一个特殊房间。
- en: One way to implement this is to keep track of all socket connections in your
    server as an array. For all practical purposes, that array of sockets is your
    lobby. Once a player connects to the lobby (in other words, once a player has
    connected to your server), he or she can communicate with other players and possibly
    be an observing participant in a conversation between other players in the lobby.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的一种方法是将服务器中的所有套接字连接跟踪为一个数组。在实际操作中，这些套接字数组就是您的大厅。一旦玩家连接到大厅（换句话说，一旦玩家连接到您的服务器），他或她就可以与其他玩家进行通信，并可能成为大厅中其他玩家之间对话的观察者。
- en: 'In our case, the lobby is simple and to the point. A player is assigned to
    the lobby automatically upon starting the game. Once in the lobby, the player
    queries the server for a list of available rooms. From there, the player can issue
    a socket command to join an existing room or create a new one:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，大厅简单明了。玩家在启动游戏时会自动分配到大厅。一旦进入大厅，玩家可以向服务器查询可用房间的列表。然后，玩家可以发出套接字命令加入现有房间或创建一个新房间：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember that our main server script exposed an interface that sockets could
    use to communicate with the game server. The previously mentioned script is the
    backend service with which the interface communicated. The actual sockets connected
    to the server are stored in and managed by Socket.io.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的主服务器脚本公开了一个接口，套接字可以使用该接口与游戏服务器进行通信。前面提到的脚本是接口通信的后端服务。连接到服务器的实际套接字存储在并由Socket.io管理。
- en: The list of available rooms is implemented as an array of `Room` objects, which
    we'll look at in detail in the next section. Note that every room will need at
    least two things. First, a room will need a way to group players and run the game
    with those same players. Second, a room will need a way for both the client and
    server to uniquely identify each individual room.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可用房间列表是作为一个`Room`对象数组实现的，我们将在下一节详细讨论。请注意，每个房间都需要至少两样东西。首先，房间需要一种方法来分组玩家并与这些玩家一起运行游戏。其次，房间需要一种方法，让客户端和服务器能够唯一识别每个单独的房间。
- en: The two simple approaches to identify the rooms individually are to ensure that
    each room object has an ID property, which would need to be unique across the
    entire game space, or we could use the array index where the room is stored.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 识别各个房间的两种简单方法是确保每个房间对象都有一个ID属性，该属性需要在整个游戏空间中是唯一的，或者我们可以使用存储房间的数组索引。
- en: For simplicity, we've chosen the second. Keep in mind that, should we delete
    a room and splice it off the rooms array, the room ID that some players have may
    now point to the wrong room.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们选择了第二种方法。请记住，如果我们删除一个房间并将其从房间数组中切割出来，一些玩家可能现在指向错误的房间ID。
- en: For example, suppose there are three rooms in the array so that the room ID
    for the rooms are 0, 1, and 2 respectively. Suppose that each of these rooms have
    several players participating in a game there. Finally, imagine that all the players
    in room ID 0 leave the game. If we splice that first room off the array (stored
    at index 0), then the room that used to be the second element in the array (formerly
    stored at index 1) would be shifted down to the front of the array (index 0).
    The third element in the array would also change and would be stored at index
    1 instead of index 2\. Thus, players who used to be in rooms 1 and 2 respectively
    will now report back to the game server with those same room IDs, but the server
    will report the first room as the second one, and the second room will not exist.
    Therefore, we must avoid deleting empty rooms by splicing them off the rooms array.
    Remember that the largest integer that JavaScript can represent is 2^53 (which
    equals 9,007,199,254,740,992), so we will not run out of slots in the array if
    we simply add new rooms to the end of the rooms array.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设数组中有三个房间，房间的ID分别为0、1和2。假设每个房间都有几个玩家参与游戏。最后，想象一下，房间ID为0的所有玩家离开了游戏。如果我们将数组中的第一个房间切掉（存储在索引0处），那么数组中原来的第二个元素（以前存储在索引1处）将被移到数组的前面（索引0）。数组中的第三个元素也会改变，将存储在索引1处而不是索引2。因此，原来在房间1和2中的玩家现在将以相同的房间ID报告给游戏服务器，但服务器将把第一个房间报告为第二个房间，而第二个房间将不存在。因此，我们必须避免通过切掉空房间来删除它们。请记住，JavaScript可以表示的最大整数是2^53（等于9,007,199,254,740,992），因此如果我们只是在房间数组的末尾添加新房间，我们不会用完数组中的槽位。
- en: Implementing the rooms
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现房间
- en: The game room is a module that implements the game class and runs the game loop.
    This module looks fairly similar to the client game as it has references to the
    player and fruit objects and updates the game state at each game tick.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏房间是一个模块，实现了游戏类并运行游戏循环。这个模块看起来与客户端游戏非常相似，因为它引用了玩家和水果对象，并在每个游戏时刻更新游戏状态。
- en: 'One difference you will notice is that there is no render phase in the server.
    In addition, the room will need to expose a few methods so that the server application
    can managed it as needed. Since each room has references to all the players in
    it and every player in the server is represented by a socket, the room can contact
    every player who is connected to it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到一个不同之处是服务器中没有渲染阶段。此外，房间将需要公开一些方法，以便服务器应用程序可以根据需要管理它。由于每个房间都引用了其中的所有玩家，服务器中的每个玩家都由套接字表示，因此房间可以联系到连接到它的每个玩家：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the players array holds a list of object literals that contain a reference
    to a snake object as well as the actual socket. This way both resources are together
    in the same logical place. Whenever we need to ping every player in the room,
    we can simply map over the player's array and then access the socket through `player.socket.emit`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，玩家数组保存了包含对蛇对象的引用以及实际套接字的对象文字列表。这样，两个资源在同一个逻辑位置上。每当我们需要对房间中的每个玩家进行ping时，我们只需映射玩家数组，然后通过`player.socket.emit`访问套接字。
- en: In addition, note that the sync loop is placed inside the main game loop, but
    we only trigger the logic inside the sync loop whenever a certain amount of frames
    have elapsed. The goal is to only synchronize all the clients every so often.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，同步循环放置在主游戏循环内，但我们只在一定数量的帧经过后才触发同步循环内的逻辑。目标是定期同步所有客户端。
- en: Matching players within game rooms
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏房间内匹配玩家
- en: After we have broken down the various concepts into simple fundamentals, you
    will see that implementing each module is not as complicated as they may have
    sounded at first. Player matching is one such example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将各种概念分解为简单的基本原理之后，您将看到实现每个模块并不像一开始听起来那么复杂。玩家匹配就是一个例子。
- en: There are different ways in which you might want to match players in a game
    room. While our sample game doesn't do any complex matching (we allow players
    to blindly match themselves), you should know that there are more options here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏房间中，您可能希望以不同的方式匹配玩家。虽然我们的示例游戏没有进行任何复杂的匹配（我们允许玩家盲目匹配自己），但您应该知道这里有更多的选择。
- en: The following are some ideas about how you might go about matching players into
    the same game world. Keep in mind that there are third-party services, such as
    Google's Play Services API, that you can use to help you with these.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于如何将玩家匹配到同一个游戏世界的想法。请记住，有第三方服务，比如谷歌的Play服务API，可以帮助你处理这些问题。
- en: Inviting friends into your world
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邀请朋友进入你的世界
- en: One of the most engaging ways to match players leverages the social aspect of
    today's world. By integrating with a social network service (or using your own
    social network populated by your players), you can give a player the option to
    invite a friend to play with them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配玩家的最吸引人的方式之一利用了当今世界的社交方面。通过与社交网络服务集成（或使用由玩家填充的自己的社交网络），您可以让玩家选择邀请朋友一起玩。
- en: While this can be a fun experience, it goes without saying that both players
    must be online at the same time for the game to be played. Often, this means that
    when a player sends an invite to his or her friend, an email is sent to the friend
    with information about the invitation. Whenever the friend joins the game room
    and both players are ready, the fun can begin.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能是一种有趣的体验，但不言而喻的是，两个玩家必须同时在线才能进行游戏。通常，这意味着当玩家向他或她的朋友发送邀请时，会向朋友发送一封包含有关邀请信息的电子邮件。每当朋友加入游戏房间并且两个玩家准备好时，游戏就可以开始了。
- en: A variation of this technique is to only show available friends (that is, friends
    who are already online and either in the lobby or in a game room). This way play
    can begin immediately or as soon as the friend exits the current game.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的一个变种是只显示可用的朋友（即已经在线并且在大厅或游戏房间中的朋友）。这样游戏可以立即开始，或者在朋友退出当前游戏后立即开始。
- en: Auto-matching
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动匹配
- en: Perhaps, you don't have a social network to leverage, or perhaps, the player
    doesn't care who the opponents are. When you want the player to be able to just
    get in and play a quick game, auto-matching is a great option.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，您没有社交网络可以利用，或者，玩家不在乎对手是谁。当您希望玩家能够快速进入并玩一局游戏时，自动匹配是一个很好的选择。
- en: There are more specific ways to automatically match players (for example, automatically
    match players based on their skills or some other criteria), but in its most basic
    form, you would need to create a private room for the first player (by private
    room, I mean a room that isn't listed for any player to join—only the game server
    knows about it), then wait for a matching player to join that room.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有更具体的方法可以自动匹配玩家（例如，根据他们的技能或其他标准自动匹配玩家），但在最基本的形式中，您需要为第一个玩家创建一个私人房间（私人房间指的是一个不列出供任何玩家加入的房间，只有游戏服务器知道它），然后等待匹配的玩家加入该房间。
- en: Skill-based matching
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于技能的匹配
- en: Another common way that players are matched into the same game room is by grouping
    players together based on their skill level. The way you keep track of a player's
    skill level can be determined in at least three ways— namely, by asking the user
    what his or her skill level is, by monitoring them during a single session, or
    by persisting the player's information across multiple sessions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的玩家匹配到同一游戏房间的方式是根据他们的技能水平将玩家分组。跟踪玩家的技能水平的方式至少可以有三种确定方式，即询问用户他或她的技能水平是什么，监控他们在单个会话期间的表现，或者在多个会话中持久化玩家的信息。
- en: The first option is the easiest to implement. A common way in which this is
    done is by displaying a menu with three or more options asking the player to choose
    from the options, such as amateur, advanced, and rock star. Based on this selection,
    you will then try to match other players from the same group.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是最容易实现的。通常的做法是通过显示一个菜单，其中有三个或更多的选项，要求玩家从这些选项中选择，例如业余、高级和摇滚明星。根据这个选择，然后您将尝试与同一组的其他玩家匹配。
- en: One possible benefit of this approach is that a new player with no past history
    with the game (from the point of view of the server) can start playing more advanced
    players right away. On the other hand, the same feature can be considered to be
    a downside to the approach as truly advanced players who may only wish to play
    with equally skilled players might get frustrated by being matched up against
    poor players who claim to possess a higher skill level than they really qualify
    for.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个可能的好处是，没有与游戏的过去历史（从服务器的角度来看）的新玩家可以立即开始与更高级的玩家对战。另一方面，同样的功能也可能被认为是这种方法的一个缺点，因为真正高级的玩家可能只希望与同样技能水平的玩家对战，而可能会因为与声称拥有更高技能水平的较差玩家匹配而感到沮丧。
- en: The second option is to start everyone at the same level (or randomly assign
    the first skill level for incoming players). Then, as more games are played, the
    application can keep track of each player's wins and losses along with other metadata
    about each player to allow you to bucket each player into a current skill level.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是让每个人从同一水平开始（或者随机分配新玩家的第一个技能水平）。然后，随着更多的游戏进行，应用程序可以跟踪每个玩家的胜利和失败以及有关每个玩家的其他元数据，以便您可以将每个玩家分成当前的技能水平。
- en: For example, a player may start the game in a beginner's room. After winning
    two games and losing none, you can then put this player in a advanced room. After
    the player has played additional two or three games and has two or three more
    victories under their belt, you can now consider that player to be in the super-advanced
    level.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个玩家可能在一个初学者房间开始游戏。在赢得两场比赛并且没有输掉任何一场之后，您可以将这个玩家放入一个高级房间。在玩家玩了额外的两三场比赛并且赢得了两三场胜利之后，您现在可以认为这个玩家处于超高级水平。
- en: The obvious downside to this approach is that it makes the assumption that an
    individual player will stay logged in long enough to play multiple games. Depending
    on the type of game you're designing, most players won't even be logged in to
    finish a single playing session.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显缺点是，它假设一个个体玩家会保持足够长的登录时间来进行多次游戏。根据您设计的游戏类型，大多数玩家甚至不会登录完成单个游戏会话。
- en: However, if your game is a good candidate for this type of approach (where a
    single game doesn't last longer than a few minutes), then this matching technique
    works out quite well because you won't need to write any long term persistence
    logic or need to authenticate users.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的游戏是这种类型的理想选择（即单个游戏的持续时间不超过几分钟），那么这种匹配技术非常有效，因为您不需要编写任何长期持久性逻辑或需要验证用户。
- en: Finally, you can keep track of a player's skill level by persisting their information
    in some form of backend database. In most cases, this will require players to
    have individual accounts, which will need to be authenticated before the play
    begins.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过在某种后端数据库中持久化他们的信息来跟踪玩家的技能水平。在大多数情况下，这将需要玩家拥有个人帐户，在游戏开始之前需要进行身份验证。
- en: Again, in some cases, you might want to use an existing third-party service
    to authenticate players, and possibly persist information you generate about them
    in the service itself.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在某些情况下，您可能希望使用现有的第三方服务来验证玩家，并可能在服务本身中持久化您生成的有关他们的信息。
- en: While this can get pretty elaborate and engaging, the basic concept is simple—calculate
    some sort of score that can be used to deduce a player's skill level and store
    that information away somewhere in a way that it can be retrieved later. From
    this point of view, you can possibly implement this persistence by storing the
    player's current skill level locally using HTML5's local storage API. The main
    drawback of doing this would be that this data would be stuck in the player's
    machine, so if the player uses a different machine (or wipes out their local storage
    data), you won't have access to the data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能会变得非常复杂和引人入胜，但基本概念很简单——计算一些可以用来推断玩家技能水平的分数，并将该信息存储在某个地方，以便以后可以检索。从这个角度来看，您可能可以通过使用HTML5的本地存储API在本地存储玩家当前的技能水平来实现这种持久性。这样做的主要缺点是，这些数据将被困在玩家的机器上，因此如果玩家使用不同的机器（或者清除本地存储数据），您将无法访问这些数据。
- en: Socket.io
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.io
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Multiplayer Game Programming"),
    *Getting Started with Multiplayer Game Programming*, we implemented the first
    demo game using native HTML5 sockets. Although WebSockets are still totally awesome,
    they are unfortunately still heavily dependent on the specific browser the player
    uses.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始多人游戏编程")中，*开始多人游戏编程*，我们使用原生HTML5套接字实现了第一个演示游戏。尽管WebSockets仍然非常棒，但不幸的是，它们仍然严重依赖于玩家使用的特定浏览器。
- en: Today, every modern browser ships with a complete implementation of WebSockets,
    especially on mobile devices where the world seems to be converging. However,
    for the possible exception where the user's browser doesn't quite support WebSockets
    but does support canvas (or whatever other HTML5 API you game uses), Socket.io
    comes to the rescue.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，每个现代浏览器都配备了完整的WebSockets实现，特别是在移动设备上，世界似乎正在趋同。然而，可能有一种例外情况，用户的浏览器不完全支持WebSockets，但支持canvas（或者其他HTML5
    API），这时Socket.io就派上用场了。
- en: In short, Socket.io is an open source library that offers a fantastic level
    of abstraction over sockets. Not only this, Socket.io also makes it super easy
    to implement the backend service that the frontend socket clients will consume.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Socket.io是一个开源库，提供了对套接字的出色抽象。不仅如此，Socket.io还使实现前端套接字客户端将使用的后端服务变得非常容易。
- en: To implement the server-side code is as easy as specifying the port on which
    the connection will be and then implementing callbacks for events in which you're
    interested.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 实现服务器端代码就像指定连接的端口，然后实现您感兴趣的事件的回调一样容易。
- en: Now, this book is not a comprehensive guide for those wanting to master every
    aspect of Socket.io and will not be too descriptive for a lot of features that
    are offered by the library. However, you might find it useful to know that Socket.io
    offers amazing client-side support. In other words, if the browser using the socket
    doesn't implement the WebSockets specification, then Socket.io will fallback to
    some other technique that can be used to communicate with the server asynchronously.
    While some of these techniques may be too slow for real-time gaming (for example,
    Socket.io will eventually fallback to using HTML iFrames to communicate with the
    server if nothing else is supported by the browser), it is good to know just how
    powerful the library is.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，本书并不是想要掌握Socket.io的每个方面的全面指南，对于该库提供的许多功能，也不会过于描述。然而，您可能会发现Socket.io提供了令人惊叹的客户端支持。换句话说，如果使用套接字的浏览器没有实现WebSockets规范，那么Socket.io将回退到其他一些可以用于与服务器异步通信的技术。虽然其中一些技术可能对实时游戏来说太慢（例如，如果浏览器不支持其他技术，Socket.io最终会回退到使用HTML
    iFrames与服务器通信），但了解该库的强大之处还是很有好处的。
- en: Installing Socket.io
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Socket.io
- en: We will bring Socket.io into our project through NPM. Be sure to stay close
    to the version used in this book (which is 1.3.5), as some of the methods or configurations
    might vary.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过NPM将Socket.io引入我们的项目。一定要使用本书中使用的版本（1.3.5），因为一些方法或配置可能会有所不同。
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, since we're using the Express framework to ease the effort of creating
    the Node.js server, we'll integrate Socket.io with Express.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于我们使用Express框架来简化创建Node.js服务器的工作，我们将Socket.io与Express集成。
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first thing we need to do is `require` Socket.io together with Express and
    all your other dependencies for the server script. We then add Socket.io to the
    Express instance by taking advantage of JavaScript's dynamic nature. We do this
    because Socket.io is not fully set up yet since we'll need access to the HTTP
    server that Express uses. In our case, as is the current standard today, we use
    Express Version 4.9.0 along with express-generator, which generates a file under
    `<project-name>/bin/www` where the low-level server setup takes place. This is
    where we integrate Socket.io into Express, by attaching the same server used by
    Express into our Socket.io instance.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是`require` Socket.io以及Express和服务器脚本的所有其他依赖项。然后，我们利用JavaScript的动态特性将Socket.io添加到Express实例中。我们这样做是因为Socket.io还没有完全设置好，因为我们需要访问Express使用的HTTP服务器。在我们的情况下，按照当前标准，我们使用Express
    Version 4.9.0以及express-generator，它会在`<project-name>/bin/www`下生成一个文件，其中进行低级服务器设置。这是我们将Socket.io集成到Express中的地方，通过将Express使用的相同服务器附加到我们的Socket.io实例中。
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Client-side Socket.io
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端Socket.io
- en: The last step is to use the Socket.io library in our client JavaScript. Here,
    there are only two simple steps that you must be certainly used to by now if you've
    ever done any JavaScript programming at all.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在我们的客户端JavaScript中使用Socket.io库。在这里，只有两个简单的步骤，如果你以前做过任何JavaScript编程，那么你肯定已经习惯了。
- en: First, we copy the client-side library into our public directory so that we
    can include it into our client code. To do this, copy the `ch3/snake-ch3/node_modules/socket.io-client/socket.io.js`
    file into `ch3/snake-ch3/public/js/socket.io.js`. Next, include the library in
    your HTML file using a script tag.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将客户端库复制到我们的公共目录，以便我们可以将其包含到我们的客户端代码中。为此，将`ch3/snake-ch3/node_modules/socket.io-client/socket.io.js`文件复制到`ch3/snake-ch3/public/js/socket.io.js`。接下来，使用脚本标签在您的HTML文件中包含该库。
- en: To start using the socket in your client code, all you need to do is instantiate
    it by requiring it with the domain where the server is running.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在客户端代码中开始使用套接字，你所需要做的就是通过需要它的域来实例化它，服务器正在运行的域。
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, the socket will attempt to connect to your server right away and asynchronously.
    Once it does this, the connect event will fire and the corresponding callback
    will be fired as well, and you would know that the socket is ready to be used.
    From then on you can start emitting events to the other end of the socket.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，套接字将立即异步地尝试连接到您的服务器。一旦它这样做，连接事件将触发，相应的回调也将被触发，您将知道套接字已经准备好使用。从那时起，您可以开始向套接字的另一端发出事件。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Hopefully, this chapter got you excited about the unique aspects of multiplayer
    game development. We took an existing single-player snake game and broke it apart
    into an authoritative server component and a socket-driven frontend component.
    We used Socket.io to link the game client and server together in a very seamless
    integration with Express. We also discussed the concept of a game lobby and game
    rooms as well as the way to match players into the same game world.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章让你对多人游戏开发的独特方面感到兴奋。我们将一个现有的单人贪吃蛇游戏分解成了一个权威服务器组件和一个由套接字驱动的前端组件。我们使用Socket.io将游戏客户端和服务器以非常无缝的方式与Express进行了链接。我们还讨论了游戏大厅和游戏房间的概念，以及将玩家匹配到同一个游戏世界的方法。
- en: In the next chapter, we will improve our Snake game by adding reduced network
    latency with client prediction and correction as well as input interpolation.
    We will also fix the game server's game loop for smoother and more efficient game
    play.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加客户端预测和校正以及输入插值来改进我们的贪吃蛇游戏，以减少网络延迟。我们还将修复游戏服务器的游戏循环，以实现更流畅和更高效的游戏。
