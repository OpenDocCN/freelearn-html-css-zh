["```js\n<!doctype html>\n<html>\n<head>\n    <title> Fullscreen</title>\n    <!-- [some custom CSS here, left out for brevity] -->\n</head>\n<body>\n<ul>\n    <li>\n        <span>1</span>\n    </li>\n    <li>\n        <span>O</span>\n    </li>\n    <li>\n        <span>O</span>\n    </li>\n    <li>\n        <span>1</span>\n    </li>\n</ul>\n<script>\n    var list = document.querySelector('ul');\n\n    list.addEventListener('click', function (event) {\n        var block = event.target;\n        block.requestFullscreen();\n    });\n</script>\n</body>\n</html>\n```", "```js\nvar reqFullscreen = (function () {\n    var method = (function () {\n        var el = document.createElement('div');\n        var supported = '';\n        var variations = [\n            'requestFullscreen',\n            'msRequestFullscreen',\n            'mozRequestFullScreen',\n            'webkitRequestFullscreen'\n        ];\n\n        variations.some(function (method) {\n            supported = method;\n            return el[method] instanceof Function;\n        });\n\n        return supported;\n    }());\n\n    return function (element) {\n        element[method]();\n    };\n}());\n\nvar list = document.querySelector('ul');\n\nlist.addEventListener('click', function (event) {\n    var block = event.target;\n    reqFullscreen(block);\n});\n```", "```js\nvar list = document.querySelector('ul');\nvar btn = document.querySelector('button');\n\nbtn.addEventListener('click', function (event) {\n    // Somehow determine what element to use\n    var firstBlock = list.children[0].children[0];\n\n    reqFullscreen(firstBlock);\n});\n```", "```js\nvar element = document.webkitFullscreenElement;\n```", "```js\nvar canFullscreen = document.webkitFullscreenEnabled; // => bool\n```", "```js\nfull-screen,\n:-moz-full-screen,\n:-moz-full-screen-ancestor,\n:-webkit-full-screen {\n    font-size: 50vw;\n    line-height: 1.25;\n    /* \u2026 */\n}\n```", "```js\n/**\n * @type {GamepadEvent} event\n */\nfunction onGamepadConnected(event) {\n    var gamepad = event.gamepad;\n}\n\nwindow.addEventListener('gamepadconnected', onGamepadConnected);\n```", "```js\nfunction update(){\n    var gamepads = navigator.getGamepads();\n    var gp_1 = gamepads[0];\n\n    if (gp_1.buttons[1].pressed) {\n        // Button 1 pressed on first connected gamepad\n    }\n\n    if (gp_1.axes[1] < 0) {\n        // Left stick held to the left on first connected gamepad\n    }\n\n    requestAnimationFrame(update);\n}\n```", "```js\ninterface Gamepad {\n    readonly attribute DOMString id;\n    readonly attribute long index;\n    readonly attribute boolean connected;\n    readonly attribute DOMHighResTimeStamp timestamp;\n    readonly attribute GamepadMappingType mapping;\n    readonly attribute double[] axes;\n    readonly attribute GamepadButton[] buttons;\n};\n```", "```js\nvar btns = {\n        arrow_up: document.querySelector('.btn .arrow-up'),\n        arrow_down: document.querySelector('.btn .arrow-down'),\n        arrow_left: document.querySelector('.btn .arrow-left'),\n        arrow_right: document.querySelector('.btn .arrow-right'),\n\n        button_a: document.querySelector('.buttons .btn-y'),\n        button_b: document.querySelector('.buttons .btn-x'),\n        button_x: document.querySelector('.buttons .btn-b'),\n        button_y: document.querySelector('.buttons .btn-a'),\n\n        button_select: document.querySelector('.controls .btn- select'),\n        button_start: document.querySelector('.controls .btn- start'),\n\n        keyCodes: {\n            37: 'arrow_left',\n            38: 'arrow_up',\n            39: 'arrow_right',\n            40: 'arrow_down',\n\n            32: 'button_a',\n            65: 'button_b',\n            68: 'button_x',\n            83: 'button_y',\n\n            27: 'button_select',\n            16: 'button_start'\n        },\n\n        keyNames: {\n            axe_left: 0,\n            axe_left_val: -1,\n\n            axe_right: 0,\n            axe_right_val: 1,\n\n            axe_up: 1,\n            axe_up_val: -1,\n\n            axe_down: 1,\n            axe_down_val: 1\n        }\n    };\n\n    Object.keys(btns.keyCodes).map(function(index){\n        btns.keyNames[btns.keyCodes[index]] = index;\n    });\n\nfunction displayKey(keyCode, pressed) {\n    var classAction = pressed ? 'add' : 'remove';\n\n    if (btns.keyCodes[keyCode]) {\n        btns[btns.keyCodes[keyCode]].classList[classAction]('active');\n    }\n}\n\nfunction update(now) {\n        requestAnimationFrame(update);\n\n        // GamepadList[0] references the first gamepad that connected to the app\n        gamepad = navigator.getGamepads().item(0);\n\n        if (gamepad.buttons[0].pressed) {\n            displayKey(btns.keyNames.button_x, true);\n        } else {\n            displayKey(btns.keyNames.button_x, false);\n        }\n\n        if (gamepad.buttons[1].pressed) {\n            displayKey(btns.keyNames.button_a, true);\n        } else {\n            displayKey(btns.keyNames.button_a, false);\n        }\n\n        if (gamepad.buttons[2].pressed) {\n            displayKey(btns.keyNames.button_b, true);\n        } else {\n            displayKey(btns.keyNames.button_b, false);\n        }\n\n        if (gamepad.buttons[3].pressed) {\n            displayKey(btns.keyNames.button_y, true);\n        } else {\n            displayKey(btns.keyNames.button_y, false);\n        }\n\n        if (gamepad.buttons[8].pressed) {\n            displayKey(btns.keyNames.button_select, true);\n        } else {\n            displayKey(btns.keyNames.button_select, false);\n        }\n\n        if (gamepad.buttons[9].pressed) {\n            displayKey(btns.keyNames.button_start, true);\n        } else {\n            displayKey(btns.keyNames.button_start, false);\n        }\n\n        if (gamepad.axes[btns.keyNames.axe_left] === btns.keyNames.axe_left_val){\n            displayKey(btns.keyNames.arrow_left, true);\n        } else {\n            displayKey(btns.keyNames.arrow_left, false);\n        }\n\n        if (gamepad.axes[btns.keyNames.axe_down] === btns.keyNames.axe_down_val) {\n            displayKey(btns.keyNames.arrow_down, true);\n        } else {\n            displayKey(btns.keyNames.arrow_down, false);\n        }\n\n        if (gamepad.axes[btns.keyNames.axe_up] === btns.keyNames.axe_up_val) {\n            displayKey(btns.keyNames.arrow_up, true);\n        } else {\n            displayKey(btns.keyNames.arrow_up, false);\n        }\n\n        if (gamepad.axes[btns.keyNames.axe_right] === btns.keyNames.axe_right_val) {\n            displayKey(btns.keyNames.arrow_right, true);\n        } else {\n            displayKey(btns.keyNames.arrow_right, false);\n        }\n    }\n\n    window.addEventListener('gamepadconnected', function (e) {\n        update(0);\n    });\n```", "```js\nvar pcConfig = {\n    iceServers: [{\n        url: 'stun:stun.l.google.com:19302'\n    }]\n};\n\nvar pcOptions = {\n    optional: [{\n        RtpDataChannels: true\n    }]\n};\n\nvar pc = new webkitRTCPeerConnection(pcConfig, pcOptions);\n```", "```js\n/**\n *\n */\nfunction makeMessage(msg, user, color) {\n    var container = document.createElement('p');\n    var tag = document.createElement('span');\n    var text = document.createElement('span');\n\n    if (color) {\n        tag.classList.add(color);\n    } else if (nickColor) {\n        tag.classList.add(nickColor);\n    }\n\n    tag.textContent = '[' + (user || nick) + '] ';\n    text.textContent = msg;\n\n    container.appendChild(tag);\n    container.appendChild(text);\n\n    var out = document.getElementById('out');\n    var footer = document.getElementById('outFooter');\n    out.appendChild(container);\n    footer.scrollIntoView();\n}\n\n/**\n *\n */\nfunction createOffer() {\n    pc.createOffer(function (offer) {\n        // Note #1\n        makeMessage('offer: ' + encodeURIComponent(offer.sdp));\n\n        // Note #2\n        pc.setLocalDescription(new RTCSessionDescription(offer),\n            // Note #3\n            function () {},\n\n            // Note #4\n            function (e) {\n                console.error(e);\n                makeMessage('error creating offer');\n            }\n        );\n    });\n}\n```", "```js\nfunction setRemoteDesc(sdp, type) {\n    var offer = new RTCSessionDescription();\n    offer.sdp = decodeURIComponent(sdp);\n    offer.type = type;\n\n    makeMessage('remote desc: ' + offer.sdp);\n\n    pc.setRemoteDescription(new RTCSessionDescription(offer),\n        function () {\n        },\n        function (e) {\n            console.log(e);\n            makeMessage('error setting remote desc');\n        }\n    );\n}\n```", "```js\nfunction answerOffer() {\n    pc.createAnswer(function (answer) {\n        makeMessage('answer: ' + encodeURIComponent(answer.sdp));\n        pc.setLocalDescription(new RTCSessionDescription(answer));\n    }, function (e) {\n        console.log(e);\n        makeMessage('error creating answer');\n    });\n}\n```", "```js\npc.onicecandidate = function (event) {\n    if (event.candidate) {\n        makeMessage('ice candidate: ' + JSON.stringify(event.candidate), 'sys', 'sys');\n    }\n};\n\nfunction addIceCandidate(candidate) {\n    pc.addIceCandidate(candidate);\n}\n\naddIceCandidate(JSON.parse({\n   /* encoded candidate object from onIceCandidate callback */\n});\n```", "```js\n// When creating the RTCPeerConnection object, we also create the DataChannel\nvar pc = new webkitRTCPeerConnection(pcConfig, pcOptions);\nvar channelName = 'packtRtc';\nvar dc = dc = pc.createDataChannel(channelName);\n\nfunction sendMessage(msg) {\n    if (dc.readyState === 'open') {\n        var data = {\n            msg: msg,\n            user: nick,\n            color: nickColor\n        };\n\n        // Since this is a chat app, we want to see our own message\n        makeMessage(msg);\n\n        // The actual send command\n        dc.send(JSON.stringify(data));\n    } else {\n        makeMessage('Could not send message: DataChannel not yet open.');\n    }\n}\n\ndc.onmessage = function (event) {\n    var data = JSON.parse(event.data);\n    makeMessage(data.msg, data.user, data.color);\n};\n\ndc.onopen = function () {\n    makeMessage('dataChannel open', 'sys', 'sys');\n};\n\ndc.onerror = function (e) {\n    makeMessage('dataChannel error: ' + e, 'sys', 'sys');\n};\n\ndc.onclose = function () {\n    makeMessage('dataChannel close', 'sys', 'sys');\n};\n```", "```js\nvar constraints = {\n    audio: false,\n    video: {\n        mandatory: {\n            minAspectRatio: 1.333,\n            maxAspectRatio: 1.334\n        },\n        optional: {\n            width: {\n                min: 640,\n                max: 1920,\n                ideal: 1280\n            },\n            height: {\n                min: 480,\n                max: 1080,\n                ideal: 720\n            },\n            framerate: 30\n        }\n    }\n};\n\nvar allowCallback = function(stream){\n    // use captured local media stream\n    // ...\n};\n\nvar denyCallback = function(e){\n    // user denied permission to let your app access media devices\n    console.error('Could not access media devices', e);\n};\n\nnavigator.webkitGetUserMedia(constraints, allowCallback, denyCallback);\n```", "```js\nvar  constraints = {\n    audio: true,\n    video: false\n};\n\n// the above is equivalent to simply {audio: true}\n\nnavigator.webkitGetUserMedia(constraints, allowCallback, denyCallback);\n```", "```js\nvar allowCallback = function(stream){\n    var audioContext = new AudioContext();\n    var mic = audioContext.createMediaStreamSource(stream);\n\n    // ...\n};\n```", "```js\nvar allowCallback = function(stream){\n    var audioContext = new AudioContext();\n    var mic = audioContext.createMediaStreamSource(stream);\n\n    var analyser = audioContext.createAnalyser();\n    analyser.smoothingTimeConstant = 0.3;\n    analyser.fftSize = 128;\n\n    mic.connect(analyser);\n\n    // ...\n};\n```", "```js\nvar allowCallback = function(stream){\n    var audioContext = new AudioContext();\n    var mic = audioContext.createMediaStreamSource(stream);\n\n    var analyser = audioContext.createAnalyser();\n    analyser.smoothingTimeConstant = 0.3;\n    analyser.fftSize = 128;\n\n    mic.connect(analyser);\n\n    var bufferLength = analyser.frequencyBinCount;\n    var frequencyData = new Uint8Array(bufferLength);\n\n    // assume some canvas and ctx objects already loaded and bound to the DOM\n    var WIDTH = canvas.width;\n    var HEIGHT = canvas.height;\n    var lastTime = 0;\n\n    visualize(e);\n\n    function visualize(now) {\n        // we'll slow down the render speed so it looks smoother\n        requestAnimationFrame(draw);\n        if (now - lastTime >= 200) {\n            ctx.clearRect(0, 0, WIDTH, HEIGHT);\n            analyser.getByteFrequencyData(frequencyData);\n\n            var barWidth = (WIDTH / bufferLength) * 2.5;\n            var x = 0;\n\n            [].forEach.call(frequencyData, function (barHeight) {\n                ctx.fillStyle = 'rgb(50, ' + (barHeight + 100) + ', 50)';\n                ctx.fillRect(x, HEIGHT - barHeight / 1, barWidth, barHeight / 1);\n                x += barWidth + 1;\n            });\n\n            lastTime = now;\n        }\n    }\n};\n```", "```js\nnavigator.webkitGetUserMedia({video: true}, function(stream){\n    // ...\n}, function(e){\n    // e => NavigatorUserMediaError {\n    //              constraintName: '',\n    //              message: '',\n    //              name: 'DevicesNotFoundError'\n    //          }\n});\n```", "```js\nvar video = document.createElement('video');\nvideo.setAttribute('controls', true);\nvideo.setAttribute('autoplay', true);\n\ndocument.body.appendChild(video);\n\nvar constraints = {\n    video: true\n};\n\nfunction allowCallback(stream){\n    video.src = window.URL.createObjectURL(stream);\n}\n\nfunction denyCallback(e){\n    console.error('Could not access media devices', e);\n}\n\nnavigator.webkitGetUserMedia(constraints, allowCallback, denyCallback);\n```"]