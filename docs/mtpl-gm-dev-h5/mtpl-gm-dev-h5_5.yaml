- en: Chapter 5. Leveraging the Bleeding Edge
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。利用前沿技术
- en: So far in the book, we have focused our discussion on topics related to multiplayer
    game development. This time around, with the exception of **WebRTC**, we will
    discuss some of the newest APIs in HTML5 that, by themselves, have very little
    to do with multiplayer gaming, but they afford great opportunities in the context
    of game development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经集中讨论了与多人游戏开发相关的主题。这一次，除了**WebRTC**之外，我们将讨论一些HTML5中最新的API，它们本身与多人游戏几乎没有关系，但在游戏开发的背景下提供了很多机会。
- en: 'In this chapter, we will discuss the following principles and concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下原则和概念：
- en: Connecting peers directly with WebRTC
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebRTC直接连接对等方
- en: Adding game pads to your browser-based games
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基于浏览器的游戏添加游戏手柄
- en: Maximizing your games in the **fullscreen** mode
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**全屏**模式下最大化您的游戏
- en: Accessing the user's media devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问用户的媒体设备
- en: HTML5 – the final frontier
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5-最终前沿
- en: Although the technologies with which we'll be experimenting in this chapter
    are exciting and very promising, we must not as yet get too attached to any one
    of them. At the very least, we must be cautious about how we use these APIs because
    they are still either experimental, or the specification is either in the Working
    Draft or Candidate Recommendation stage. In other words, chances are pretty good
    that, as of this writing and for the near, foreseeable future after the publication
    of this book, browser support for each feature may vary, APIs that do support
    each feature might differ slightly across browsers, and the future of the APIs
    may be uncertain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本章中将要尝试的技术令人兴奋并且非常有前途，但我们还不能过于依赖它们。至少，我们必须谨慎地使用这些API，因为它们仍然处于实验阶段，或者规范仍处于工作草案或候选推荐阶段。换句话说，截至目前为止，在本书出版后的可预见的未来，每个功能的浏览器支持可能会有所不同，支持每个功能的API在不同浏览器上可能会略有不同，而API的未来可能是不确定的。
- en: The **World Wide Web Consortium** (**W3C**) defines four development stages
    (also known as maturity levels) that every specification evolves through before
    the specification is final, stable, and considered to be of the W3C standard.
    These four stages are **Working Draft**, **Candidate Recommendation**, **Proposed
    Recommendation**, and **W3C Recommendation**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网联盟**（**W3C**）定义了每个规范在成为最终、稳定并被视为W3C标准之前经历的四个开发阶段（也称为成熟级别）。这四个阶段是**工作草案**、**候选推荐**、**提议推荐**和**W3C推荐**。'
- en: The initial level is Working Draft, in which the community discusses the proposed
    specification and defines the precise details that they try to accomplish. At
    this level, the recommendation is very unstable, and its eventual publication
    is all but guaranteed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 初始级别是工作草案，社区在这一级别讨论了提议的规范并定义了他们试图实现的精确细节。在这个级别上，推荐是非常不稳定的，它的最终发布几乎是不确定的。
- en: The next one is the Candidate Recommendation level, in which feedback is elicited
    from groups that implement the recommendation. Here, the standard is still unstable
    and subject to change (or deprecation, as is sometimes the case), but it tends
    to change less frequently than when it is at the Working Draft stage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是候选推荐级别，在这个级别上从实施推荐中获取反馈。在这里，标准仍然不稳定并且可能会发生变化（或者像有时候一样被废弃），但它的变化频率比在工作草案阶段要低。
- en: Once a specification document is published as a Proposed Recommendation, the
    advisory committee at W3C reviews the proposal. If at least four weeks have gone
    by since the review period began and the document has received enough endorsement
    from the community and implementers, the document is forwarded for publication
    as a recommendation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦规范文档作为候选推荐发布，W3C的咨询委员会将审查提案。如果自审查期开始以来已经过去至少四周，并且文档已经得到了社区和实施者的足够认可，那么文档将被转发为推荐发布。
- en: Finally, when a specification becomes a W3C Recommendation, it carries with
    it the stamp of approval from W3C as an endorsed standard. Sadly, even at this
    point, there are no guarantees that a browser will support a standard or implement
    it according to the specification. However, in our day and age, all major browsers
    do a pretty good job of following specifications and implementing all the useful
    standards that are out there.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当一个规范成为W3C推荐时，它将携带W3C的认可标志作为认可标准。遗憾的是，即使在这一点上，也不能保证浏览器会支持标准或根据规范实施它。然而，在我们这个时代，所有主要的浏览器都非常好地遵循规范，并实施所有有用的标准。
- en: Maximizing your game with the fullscreen mode
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全屏模式最大化您的游戏
- en: Of all the APIs that we'll discuss in this chapter, fullscreen is the simplest
    to understand and use. As you might have guessed, what this API allows you to
    do is set an HTML element node that can be presented in the fullscreen mode.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将讨论的所有API中，全屏是最容易理解和使用的。正如你可能已经猜到的那样，这个API允许你设置一个可以在全屏模式下呈现的HTML元素节点。
- en: 'Note that, although the first Editor''s Draft (the maturation level that comes
    before a recommended standard becomes a Working Draft) for the fullscreen mode
    was published in October 2011, the specification is still in its early drafting
    stages. (refer to the following article for more information: *Using fullscreen
    mode*, *(July 2014)*. [https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode)).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管全屏模式的第一个编辑草案（推荐标准成为工作草案之前的成熟级别）于2011年10月发布，但规范仍处于早期起草阶段。（有关更多信息，请参阅以下文章：*使用全屏模式*，*(2014年7月)*。[https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode)）。
- en: As for the current browser support, you will find that it is pretty safe to
    use the API in all modern browsers, although today there are subtle differences
    in implementation as well as how you should enable the fullscreen mode.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 至于当前浏览器支持情况，您会发现在所有现代浏览器中使用API是相当安全的，尽管今天在实现上有细微差异以及如何启用全屏模式也有所不同。
- en: The main thing to keep in mind when using fullscreen is that you must set a
    single element to the fullscreen mode. This element can indeed have a subtree
    of element nodes, but you will still need to enable the fullscreen mode on a particular
    element. In the context of game development, you will most likely set the main
    canvas element to fullscreen, but this is not a hard requirement. You could just
    as well request that the browser make the entire document fullscreen by calling
    the `requetFullscreen()` method on the body element.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用全屏模式时要牢记的主要事项是，您必须将单个元素设置为全屏模式。这个元素确实可以有一组元素节点的子树，但您仍然需要在特定元素上启用全屏模式。在游戏开发的背景下，您很可能会将主画布元素设置为全屏，但这不是一个硬性要求。您也可以要求浏览器通过在body元素上调用`requetFullscreen()`方法使整个文档进入全屏模式。
- en: There are two methods that are involved in setting an element in the fullscreen
    mode, and removing an element from the fullscreen mode. The methods are `requestFullscreen`
    and `exitFullscreen` respectively. Note that as of this writing, all major browsers
    implement these methods under their individual vendor prefix.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设置元素进入全屏模式和将元素退出全屏模式涉及两种方法，分别是`requestFullscreen`和`exitFullscreen`方法。请注意，截至目前，所有主要浏览器都在其各自的供应商前缀下实现了这些方法。
- en: In addition, remember that the fullscreen mode cannot be enabled unless a user-initiated
    event makes the request to the browser. In other words, you cannot simply attempt
    to change the body element to fullscreen as soon as your DOM has loaded. Likewise,
    you cannot programmatically fire a DOM event (such as triggering a fake click
    on the page or using JavaScript to scroll the page, thus firing an `onScroll`
    event) and use the event handler callback to trick the browser into thinking that
    it was the user that initiated the action.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，除非用户发起的事件向浏览器发出请求，否则无法启用全屏模式。换句话说，你不能在DOM加载后立即尝试将body元素更改为全屏。同样，你也不能以编程方式触发DOM事件（例如在页面上触发虚假点击或使用JavaScript滚动页面，从而触发`onScroll`事件），并使用事件处理程序回调来欺骗浏览器，让它认为是用户发起了该操作。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code demonstrates how to set an element to the fullscreen mode
    after that element receives a click. In this case, you may have noticed that we
    assume that whatever browser executes that code will have dropped their vendor
    support, and we can simply call `requestFullscreen()` as it was intended.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码演示了如何在元素接收到点击后将其设置为全屏模式。在这种情况下，您可能已经注意到，我们假设无论哪个浏览器执行该代码都已经放弃了他们的供应商支持，因此我们可以简单地调用`requestFullscreen()`，就像它原本的意图一样。
- en: A better way to go about this today, since browsers have not yet implemented
    the specification without a vendor prefixing the API, is to use a polyfill or
    helper function that detects whether a vendor prefix is needed and does what is
    needed to make it work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 今天处理这个问题的更好方法是，由于浏览器尚未实现不带供应商前缀的API规范，因此使用polyfill或辅助函数来检测是否需要供应商前缀，并执行必要的操作使其正常工作。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding sample code creates a function called reqFullscreen, which does
    the heavy lifting for us by determining if a vendor prefix is needed; it then
    remembers which version of the fullscreen request needs to be made. We then call
    that function when we want the element to go the fullscreen mode, by passing it
    within the element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例代码创建了一个名为reqFullscreen的函数，它通过确定是否需要供应商前缀来为我们做繁重的工作；然后它记住了需要进行全屏请求的版本。然后，当我们希望元素进入全屏模式时，我们通过将其传递给该函数来调用该函数。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It seems that the makers of browsers have the goal to make experimental APIs
    as confusing as possible for end users. In the case of fullscreen, note that the
    specification names the interface functions as `requestFullscreen` and `exitFullscreen`
    (where the word `Fullscreen` only capitalizes the first letter).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎浏览器制造商的目标是尽可能让实验性API对最终用户造成困惑。在全屏模式的情况下，请注意规范将接口函数命名为`requestFullscreen`和`exitFullscreen`（其中`Fullscreen`一词仅大写第一个字母）。
- en: 'Every vendor prefix, except for Mozilla Firefox, follows the specification
    with regards to the function names—that is, `webkitRequestFullscreen` and `msRequestFullscreen`.
    Mozilla Firefox differs because it implements `mozRequestFullScreen`, which differs
    from the other vendors since it spells `FullScreen` as two words in the camel
    case. As a final detail, the folks at Webkit decided to please both the sides
    of the crowd by implementing both the versions: `webkitRequestFullscreen` and
    `webkitRequestFullScreen`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Mozilla Firefox之外，每个供应商前缀都遵循规范，关于函数名称——即`webkitRequestFullscreen`和`msRequestFullscreen`。Mozilla
    Firefox不同，因为它实现了`mozRequestFullScreen`，这与其他供应商不同，因为它在驼峰命名法中将`FullScreen`拼写为两个单词。最后一个细节是，Webkit的开发人员决定同时实现两个版本：`webkitRequestFullscreen`和`webkitRequestFullScreen`，以取悦所有人。
- en: '![Maximizing your game with the fullscreen mode](img/B04669_05_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![使用全屏模式最大化您的游戏](img/B04669_05_01.jpg)'
- en: 'In the previous image, our page is not in the the fullscreen mode. However,
    when you click on one of the elements, that element is presented in the fullscreen
    mode:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图像中，我们的页面不处于全屏模式。但是，当您单击其中一个元素时，该元素将以全屏模式呈现：
- en: '![Maximizing your game with the fullscreen mode](img/B04669_05_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使用全屏模式最大化您的游戏](img/B04669_05_02.jpg)'
- en: 'You may observe that the only requirement that the browser imposes is that
    a user action must initiate the request to enable fullscreen. This does not mean
    that the action must be on the same element that is set to fullscreen, as shown
    in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，浏览器强加的唯一要求是必须由用户操作发起请求以启用全屏模式。这并不意味着操作必须在设置为全屏的相同元素上，就像下面的例子所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding example binds to a button element. then add a click handler that
    sets some other element to enable in fullscreen mode.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例绑定到一个按钮元素，然后添加一个点击处理程序，将一些其他元素设置为全屏模式。
- en: We can check whether a specific element is in the fullscreen mode by looking
    up an automatically updated property of the document object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查找文档对象的一个自动更新的属性来检查特定元素是否处于全屏模式。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you run the previous statement, it will return a reference to any element
    that's currently in the fullscreen mode; otherwise, it will return a null value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述语句时，它将返回对当前处于全屏模式的任何元素的引用；否则，它将返回一个空值。
- en: We can also query the document to test whether the document can be enabled as
    fullscreen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查询文档，测试文档是否可以启用全屏。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, there is a special CSS pseudo selector that allows us to target the
    element in fullscreen. Again, this selector is also vendor prefixed as of this
    moment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个特殊的CSS伪选择器，允许我们定位全屏中的元素。同样，这个选择器目前也是供应商前缀的。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the selector targets the very element that called `requestFullscreen`.
    In the preceding example, the styles specified before apply to the **ul li span**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，选择器会定位调用`requestFullscreen`的元素。在前面的示例中，指定的样式适用于**ul li span**。
- en: Better controlling with gamepad
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地使用游戏手柄进行控制
- en: Over the last several years, we have seen a very welcome and robust list of
    new APIs added to HTML5\. These include WebSockets, canvas, local storage, WebGL,
    and many more. In the context of game development, the next natural step was to
    add standard support for a gamepad.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，我们已经看到HTML5中添加了一系列非常受欢迎和强大的新API。这些包括WebSockets、canvas、本地存储、WebGL等等。在游戏开发的背景下，下一个自然的步骤是为游戏手柄添加标准支持。
- en: Similar to the fullscreen mode, the gamepad API is still in the very early drafting
    stages. In fact, gamepad support is even more "primitive" than fullscreen. Although
    you will find browser support to be adequate, working with the API can be buggy
    and somewhat unpredictable. However, the gamepad API does provide a good enough
    interface for a great end user experience. As the specification matures, the prospect
    of adding a gamepad to the browser is very exciting and promising.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与全屏模式类似，游戏手柄API仍处于非常早期的起草阶段。实际上，游戏手柄支持甚至比全屏模式更“原始”。尽管您会发现浏览器支持是足够的，但使用API可能会出现错误和有些不可预测。然而，游戏手柄API确实提供了一个足够好的接口，以提供出色的最终用户体验。随着规范的成熟，将游戏手柄添加到浏览器中的前景是非常令人兴奋和有前途的。
- en: The first thing you'll notice about the gamepad API is the way in which it differs
    from all other input APIs in the DOM as it is not driven by events such as a mouse
    or keyboard. For example, although every input with a keyboard triggers an event
    (in other words, a registered callback is invoked), input from a connected gamepad
    can only be detected by manually polling the hardware. In other words, the browser
    will fire gamepad-related events to let you know that a gamepad has connected
    and disconnected. However, beyond these kinds of events, the browser does not
    fire an event every time a key is pressed on a connected gamepad.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于游戏手柄API的第一件事是，它与DOM中所有其他输入API的不同之处在于它不是由鼠标或键盘等事件驱动的。例如，尽管每个键盘输入都会触发一个事件（换句话说，会调用一个注册的回调），但来自连接的游戏手柄的输入只能通过手动轮询硬件来检测。换句话说，浏览器会触发与游戏手柄相关的事件，以让您知道游戏手柄已连接和断开连接。然而，除了这些类型的事件之外，浏览器不会在连接的游戏手柄上每次按键时触发事件。
- en: 'To start using a gamepad in your game, you will first need to wait for one
    to connect to the game. This is done by registering a callback to listen to the
    global `gamepadconnected` event:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在游戏中使用游戏手柄，您首先需要等待游戏手柄连接到游戏中。这是通过注册一个回调来监听全局的`gamepadconnected`事件来实现的：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `gamepadconnected` event will fire any time a gamepad is connected to your
    computer during the lifetime of your game. If a gamepad is already connected before
    the script loads, the `gamepadconnected` event will not fire until the player
    presses a button on the gamepad. While this may seem weird at first, this restriction
    was put in place for a very good reason—namely, to protect the player from being
    fingerprinted by ill-intentioned scripts. However, requiring the user to press
    a button before the controller is activated is not that big of a deal since the
    player will need to press a button at some point if he or she wishes to play your
    game. The only drawback to this, as you can imagine, is that we won't know right
    off the bat whether the user has a gamepad connected to the computer yet. Still,
    coming up with creative solutions to work around this limitation is not too difficult
    of a task.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`gamepadconnected`事件将在游戏运行期间任何时候在您的计算机上连接游戏手柄时触发。如果在脚本加载之前已经连接了游戏手柄，那么`gamepadconnected`事件将不会触发，直到玩家按下游戏手柄上的按钮。虽然这一开始可能看起来有点奇怪，但这一限制是有很好的原因的，即为了保护玩家不受恶意脚本的指纹识别。然而，要求用户在激活控制器之前按下按钮并不是什么大问题，因为玩家如果想玩游戏，总是需要在某个时候按下按钮。唯一的缺点是，我们一开始不知道用户是否已经连接了游戏手柄。不过，想出创造性的解决方案来解决这个限制并不是太困难的任务。'
- en: The `GamepadEvent` object exposes a gamepad property, which is a reference to
    the actual Gamepad object, which is what we're after. The interesting thing about
    this object is that it is not self updating like other objects in JavaScript.
    In other words, whenever the browser receives input from a connected gamepad,
    it keeps track of its state internally. Then, once you poll the `gamepad` state,
    the browser creates a new `Gamepad` object with all the updated properties to
    reflect the current state of the controller.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamepadEvent`对象公开了一个gamepad属性，它是对实际的Gamepad对象的引用，这正是我们想要的。这个对象的有趣之处在于它不像JavaScript中的其他对象那样自动更新。换句话说，每当浏览器接收到来自连接的游戏手柄的输入时，它会在内部跟踪其状态。然后，一旦您轮询`gamepad`状态，浏览器就会创建一个新的`Gamepad`对象，其中包含所有更新的属性，以反映控制器的当前状态。'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: During each `update` cycle, you will need to obtain the most recent snapshot
    of the gamepad object and look up its state.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个“update”周期中，您需要获取游戏手柄对象的最新快照并查找其状态。
- en: 'The `Gamepad` object interface defines no methods, but its several properties
    are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “Gamepad”对象接口定义了没有方法，但有几个属性：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `id` attribute describes the actual hardware connected to the application.
    If you connect a gamepad through some USB adapter, it is likely that the `id`
    will reference the adapter device rather than the actual controller that was used.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “id”属性描述了连接到应用程序的实际硬件。如果通过某个USB适配器连接游戏手柄，则“id”可能会引用适配器设备，而不是实际使用的控制器。
- en: The `index` will reference the `Gamepad` object within the `GamepadList` object,
    which is what the browser provides in response to `navigator.getGamepads()`. Using
    this index value, we can get a reference to a specific gamepad that we wish to
    query.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “index”将引用“GamepadList”对象中的“Gamepad”对象，这是浏览器响应“navigator.getGamepads()”提供的。使用此索引值，我们可以获取对我们希望查询的特定游戏手柄的引用。
- en: As expected, the `boolean connected` property indicates whether a particular
    gamepad is still connected to the application. If a gamepad disconnects prior
    to a call to `navigator.getGamepads()`, the corresponding element that is based
    on a `Gamepad.index` offset will be null in the `GamepadList`. However, if a reference
    to a `Gamepad` object is obtained, but the hardware disconnects, the object will
    still have its connected property set to true because those properties are not
    dynamically updated. In summary, this property is superfluous and will probably
    be removed from the spec in future updates.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，“boolean connected”属性指示特定游戏手柄是否仍连接到应用程序。如果在调用“navigator.getGamepads()”之前游戏手柄断开连接，则基于“Gamepad.index”偏移的相应元素将在“GamepadList”中为null。但是，如果获取了对“Gamepad”对象的引用，但硬件断开连接，那么对象的connected属性仍将设置为true，因为这些属性不是动态更新的。总之，这个属性是多余的，可能会在将来的更新中从规范中删除。
- en: We can check when the browser last updated the `gamepad` state by looking at
    the `timestamp` attribute on a `Gamepad` object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看“Gamepad”对象上的“timestamp”属性来检查浏览器上次更新“gamepad”状态的时间。
- en: A particularly interesting attribute is `mapping`. The idea behind this is that
    there can be several standard mappings so as to make it easier to wire up the
    application corresponding to the way the hardware is laid out.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有趣的属性是“mapping”。其背后的想法是可以有几种标准映射，以便更容易地连接到硬件的方式对应应用程序。
- en: '![Better controlling with gamepad](img/B04669_05_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用游戏手柄更好地控制](img/B04669_05_04.jpg)'
- en: 'Currently, there is only one standard mapping, which can be identified by the
    name `standard`, as demonstrated previously (for more information refer to, *Gamepad
    W3C Working Draft 29 April 2015*. [http://www.w3.org/TR/gamepad](http://www.w3.org/TR/gamepad)).
    If the browser doesn''t know how to layout the controller, it will respond with
    an empty string for the `mapping` attribute and map the buttons and axes in the
    best way that it can. In such cases, the application should probably ask the user
    to manually map the buttons that the application uses. Keep in mind that there
    are cases where the d-pad buttons are mapped to one of the axes, so handle each
    case with care:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只有一个标准映射，可以通过名称“standard”来识别，如先前演示的（有关更多信息，请参阅*Gamepad W3C Working Draft 29
    April 2015*。[http://www.w3.org/TR/gamepad](http://www.w3.org/TR/gamepad)）。如果浏览器不知道如何布局控制器，它将用空字符串响应“mapping”属性，并以最佳方式映射按钮和轴。在这种情况下，应用程序可能应该要求用户手动映射应用程序使用的按钮。请记住，有些情况下，方向键按钮映射到其中一个轴，因此要小心处理每种情况：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding example connects a gamepad with no recognizable mapping; thus,
    it assigns each button to a specific layout. Since the d-pad buttons map to the
    left axis in this particular case, we check for that state when we want to determine
    whether the d-pad is being used. The output of this demonstration can be seen
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例连接了一个没有可识别映射的游戏手柄；因此，它将每个按钮分配给特定的布局。由于在这种特殊情况下，方向键按钮映射到左轴，因此当我们想要确定是否正在使用方向键时，我们会检查该状态。此演示的输出如下：
- en: '![Better controlling with gamepad](img/B04669_05_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用游戏手柄更好地控制](img/B04669_05_03.jpg)'
- en: Often, you might wish to offer the user the ability to choose the way they would
    prefer to interact with your game—using a keyboard and mouse, a gamepad, or both.
    In the previous example, this is precisely the reason why the `btns` object referenced
    seemingly random and arbitrary `keyCode` values. These values are mapped to specific
    keyboard keys so that the player could use the arrow keys on a standard keyboard
    or a gamepad.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能希望为用户提供选择他们希望与您的游戏交互的方式的能力 - 使用键盘和鼠标，游戏手柄或两者兼而有之。在上一个示例中，这正是为什么“btns”对象引用看似随机和任意的“keyCode”值的原因。这些值被映射到特定的键盘键，以便玩家可以在标准键盘或游戏手柄上使用箭头键。
- en: Peer-to-peer with WebRTC
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebRTC进行点对点通信
- en: One of the most exciting APIs to come out in recent years is WebRTC (which stand
    for Web real-time communication). The purpose of this API is to allow users to
    communicate in real-time streaming audio and video across platforms that support
    the technology.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来最令人兴奋的API之一是WebRTC（代表Web实时通信）。该API的目的是允许用户在支持该技术的平台上进行实时流式音频和视频通信。
- en: WebRTC is made up of several individual APIs and can be broken down into three
    separate components, namely `getUserMedia` (which we'll discuss in more depth
    in the next section), `RTCPeerConnection`, and `RTCDataChannel`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC由几个单独的API组成，并可以分解为三个单独的组件，即“getUserMedia”（我们将在下一节中更深入地讨论）、“RTCPeerConnection”和“RTCDataChannel”。
- en: Since we'll discuss `getUserMedia` in the next section, we'll leave a more involved
    definition for it when we get there (although the name might give away what the
    API is intended to do).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在下一节中讨论“getUserMedia”，所以我们将在那里时留下更详细的定义（尽管名称可能会透露API的预期用途）。
- en: '`RTCPeerConnection` is what we use to connect two peers together. Once a connection
    has been established, we can use `RTCDataChannel` and transmit any data (including
    binary data) between the peers. In the context of game development, we can use
    `RTCDataChannel` to send a player''s state to each peer without the need for a
    server linking each player.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCPeerConnection`是我们用来连接两个对等方的。一旦建立了连接，我们可以使用`RTCDataChannel`在对等方之间传输任何数据（包括二进制数据）。在游戏开发的背景下，我们可以使用`RTCDataChannel`将玩家的状态发送给每个对等方，而无需一个服务器来连接每个玩家。'
- en: To get started with `RTCPeerConnection`, we need some way to tell each peer
    about the other one. Note that the WebRTC specification deliberately leaves out
    any specific way in which this data transfer should take place. In other words,
    we are free to use whatever method we like to manually connect two peers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`RTCPeerConnection`，我们需要一种方法来告诉每个对等方有关另一个对等方。请注意，WebRTC规范故意省略了应该进行数据传输的具体方式。换句话说，我们可以自由选择任何方法手动连接两个对等方。
- en: 'The first step to get a `RTCPeerConnection` is to instantiate `RTCPeerConnection`
    object, configuring it with the **STUN** servers that you wish to use and other
    options that are related to the type of connection that you expect:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`RTCPeerConnection`的第一步是实例化`RTCPeerConnection`对象，并配置它所需使用的**STUN**服务器以及与您期望的连接类型相关的其他选项：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we use a public `STUN` server that Google provides free of cost. We also
    use a vendor prefix to be consistent with the other examples in this chapter.
    As of this writing, every vendor that implements WebRTC in some fashion uses a
    vendor prefix.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Google免费提供的公共`STUN`服务器。我们还使用供应商前缀以保持与本章中其他示例的一致性。截至目前，每个以某种方式实现WebRTC的供应商都使用供应商前缀。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not too familiar with STUN, **Interactive Connectivity Establishment**
    (**ICE**), **NAT**, **TURN**, and **SDP**, don't worry too much about it. While
    this book won't explain these networking concepts in any depth, you won't really
    need to know too much about them in order to follow the examples in this chapter
    and to implement data channels in your own game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对STUN、**交互式连接建立**（**ICE**）、**NAT**、**TURN**和**SDP**不太熟悉，不用太担心。虽然本书不会深入解释这些网络概念，但您在本章中跟随示例并在自己的游戏中实现数据通道时，不需要对它们了解太多。
- en: In brief, a STUN server is used to tell a client about its public IP address
    and whether the client is behind a router's NAT, so another peer can connect to
    it. Thus, we use one in creating our `RTCPeerConnection`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，STUN服务器用于告知客户端其公共IP地址以及客户端是否在路由器的NAT后面，以便另一个对等方可以连接到它。因此，我们在创建`RTCPeerConnection`时使用一个STUN服务器。
- en: Again, with simplicity and brevity in mind, an ICE candidate allows the browser
    the reach another browser directly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调简单和简洁，ICE候选允许浏览器直接连接到另一个浏览器。
- en: 'Once we have an `RTCPeerConnection` ready, we connect to a peer by offering
    to connect with them. The first step is to create an offer, which describes how
    the other client would connect back to us. Here is where we use a protocol of
    our choosing to inform the other peer about our offer. Commonly, this would be
    done using a WebSocket, but in order to demonstrate each step more explicitly,
    we will use the oldest communication protocol known to man: **mouth to mouth**:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了`RTCPeerConnection`，我们通过提议与对等方连接。第一步是创建一个提议，描述了另一个客户端如何连接回我们。在这里，我们使用我们选择的协议通知其他对等方我们的提议。通常，这将使用WebSocket完成，但为了更明确地演示每个步骤，我们将使用人类已知的最古老的通信协议：**口头交流**：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this *hello world* demonstration of WebRTC's peer-to-peer connection, we'll
    build a simple chat room with no servers in the middle (except for the STUN server
    that we need to initiate the peer-to-peer connection).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个WebRTC点对点连接的*hello world*演示中，我们将构建一个简单的聊天室，中间没有服务器（除了我们需要启动点对点连接的STUN服务器）。
- en: Given the preceding sample code, we can assume some HTML structure with an input
    element where we can enter text and commands and use them to drive the WebRTC
    components.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的示例代码，我们可以假设有一些HTML结构，其中包含一个输入元素，我们可以在其中输入文本和命令，并使用它们来驱动WebRTC组件。
- en: '![Peer-to-peer with WebRTC](img/B04669_05_08.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用WebRTC进行点对点连接](img/B04669_05_08.jpg)'
- en: The previous screenshot shows the output once we invoke the `createOffer` function
    shown previously. We'll make extensive use of the `makeMessage` function to help
    us see messages initiated by the system (meaning the WebRTC API) as well as messages
    from the other peer with whom we're trying to connect and chat.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了我们调用先前显示的`createOffer`函数后的输出。我们将广泛使用`makeMessage`函数来帮助我们查看系统（即WebRTC
    API）发起的消息，以及来自我们试图连接和聊天的其他对等方的消息。
- en: '`Note #1` in the previous code sample is intended to draw your attention to
    the way we'' display the offer''s **Session Description Protocol** (**SDP**),
    which is a protocol for *negotiating session capabilities between the peers* (taken
    from Suhas Nandakumar article on, *SDP for the WebRTC*, [http://tools.ietf.org/id/draft-nandakumar-rtcweb-sdp-01.html](http://tools.ietf.org/id/draft-nandakumar-rtcweb-sdp-01.html)).
    Since line breaks are meaningful in the protocol, we need to preserve every character
    in that string. By encoding the string, we guarantee that the string provided
    to us by the framework is not altered in any way (although it makes it slightly
    less readable for us humans).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '前面代码示例中的`Note #1`旨在引起您对我们如何显示提议的**会话描述协议**（**SDP**）的注意，这是一种*在对等方之间协商会话能力的协议*（摘自Suhas
    Nandakumar的文章，*SDP for the WebRTC*，[http://tools.ietf.org/id/draft-nandakumar-rtcweb-sdp-01.html](http://tools.ietf.org/id/draft-nandakumar-rtcweb-sdp-01.html)）。由于协议中的换行符是有意义的，我们需要保留该字符串中的每个字符。通过对字符串进行编码，我们保证了框架提供给我们的字符串不会以任何方式被更改（尽管这使得对我们人类来说稍微不太可读）。'
- en: '`Note #2` shows the second step of this information exchange process that will
    connect us to another peer. Here, we need to set our own client''s session description.
    You can think of this as you remembering your own home address (or PO box, if
    you''re into engaging in a series of letter communications with a pen pal).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`注2`显示了这种信息交换过程的第二步，这将把我们连接到另一个对等方。在这里，我们需要设置自己客户端的会话描述。你可以把这看作是你记住自己家庭地址（或邮箱，如果你喜欢与笔友进行一系列信件交流）。'
- en: '`Note #3` and `Note #4` are the second and third arguments that we send to
    the `RTCSessionDescription` constructor. They are the success and error callback
    functions respectively, which we are not very concerned with at the moment. Actually,
    we do care about the `error` callback function because we wish to be informed
    about any possible error that might occur when we attempt to reach the STUN server,
    and so on.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`注3`和`注4`是我们发送给`RTCSessionDescription`构造函数的第二个和第三个参数。它们分别是成功和错误回调函数，目前我们并不太关心。实际上，我们确实关心“错误”回调函数，因为我们希望在尝试到达STUN服务器时等可能出现的错误时得到通知等。'
- en: Now that we have an `offer` object, we just need to let the other peer know
    what that offer looks like. The two things that make up the offer are the SDP
    block and the type of session description.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个“offer”对象，我们只需要让另一个对等方知道这个提议是什么样子的。构成提议的两个要素是SDP块和会话描述类型。
- en: Once our peer knows what the SDP block looks like, he or she can instantiate
    an `RTCSessionDescription` object and set the SDP and type properties. Next, the
    second peer sets that session description as his or her own remote session descriptor.
    In this case, we just open a new window to represent the second peer and transmit
    the SDP string via the ever-so-sophisticated *copy + paste* method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的对等方知道SDP块的样子，他或她就可以实例化一个`RTCSessionDescription`对象，并设置SDP和类型属性。接下来，第二个对等方将该会话描述设置为自己的远程会话描述。在这种情况下，我们只需打开一个新窗口来代表第二个对等方，并通过*复制+粘贴*方法传输SDP字符串。
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we manually create an `offer` object for the other client. We use the
    SDP data that we obtained from the first client and set the second client's session
    description type to `offer`. This offer is set to the second client's remote descriptor.
    You can think of this, in the example of you writing to a pen pal, as the pen
    pal writing down your home address so that he or she knows where to send their
    letters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为另一个客户端手动创建一个“offer”对象。我们使用从第一个客户端获得的SDP数据，并将第二个客户端的会话描述类型设置为“offer”。这个提议被设置为第二个客户端的远程描述。你可以把这看作是，在你写信给笔友的例子中，笔友写下你的家庭地址，这样他或她就知道该把信件寄到哪里了。
- en: After the second peer has made note of your session description, the next step
    is for that offer to be accepted. In RTC lingo, the second peer needs to answer
    to this offer. Similar to how we called `createOffer()` to create the initial
    offer, we call `createAnswer()` on the `webkitRTCPeerConnection` object. The output
    of this call is also a session description object, except that it contains the
    second user's SDP, and the session description type is `answer` instead of `offer`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个对等方记下你的会话描述后，下一步就是接受该提议。在RTC术语中，第二个对等方需要回应这个提议。类似于我们调用`createOffer()`来创建初始提议一样，我们在`webkitRTCPeerConnection`对象上调用`createAnswer()`。这个调用的输出也是一个会话描述对象，只是它包含了第二个用户的SDP，会话描述类型是`answer`而不是`offer`。
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the remote peer first sets its own local description from the SDP that
    it received from the `answer` object. Then, we display that to the screen so that
    we can use that same information as the first peer's (the `local peer`) remote
    description. This is representative of your pen pal first remembering their own
    home address and then letting you have a copy of it so that you now know where
    to send your letters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，远程对等方首先从来自“answer”对象的SDP中设置自己的本地描述。然后，我们将其显示到屏幕上，这样我们就可以使用与第一个对等方（“本地对等方”）相同的信息作为远程描述。这代表了你的笔友首先记住自己的家庭地址，然后让你拥有一份副本，这样你就知道该把你的信件寄到哪里了。
- en: Now that both peers know where the other can be reached, all that is needed
    is a way to reach the other peer. This level of detail is abstracted away from
    the data channel. So, before we can use the data channel, we need to add at least
    one ICE candidate to the peer connection object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两个对等方都知道对方可以被联系到，所需要的只是一种联系对方的方式。这种细节层次被抽象出来，不涉及数据通道。因此，在我们可以使用数据通道之前，我们需要向对等连接对象添加至少一个ICE候选。
- en: When each peer creates their `offer` and `answer` object, the peer connection
    object receives one or more ICE candidate references. In this demo, we print these
    out to the screen when we receive them, so that at this point we can copy and
    paste the data that makes up each ICE candidate, and thus we can recreate them
    on the opposing peer's machine, and add the ICE candidate to the peer connection
    object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个对等方创建他们的“offer”和“answer”对象时，对等连接对象会接收一个或多个ICE候选引用。在这个演示中，当我们接收到ICE候选时，我们将其打印到屏幕上，这样在这一点上我们可以复制和粘贴组成每个ICE候选的数据，因此我们可以在对方的机器上重新创建它们，并将ICE候选添加到对等连接对象中。
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once each peer has the other peer's session descriptor and there is an ICE candidate
    to guide the browser to the other peer, we can start sending messages directly
    from one to the other.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个对等方都有了另一个对等方的会话描述，并且有一个ICE候选来引导浏览器到另一个对等方，我们就可以开始直接从一个对等方发送消息到另一个对等方。
- en: 'The next step is to simply send and receive messages using the `DataChannel`
    object. Here, the API is very similar to WebSocket''s API, where we call a `send()`
    method on the channel object to send data to the peer, and we register a `onmessage`
    event handler from which we receive data from the other side of the peer-to-peer
    connection. The main difference here is that, unlike the WebSocket scenario, we''re
    now connected directly to the other peer, so sending a message is blazingly fast:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步就是简单地使用`DataChannel`对象发送和接收消息。在这里，API与WebSocket的API非常相似，我们在通道对象上调用`send()`方法向对等方发送数据，并注册一个`onmessage`事件处理程序，从中接收对等方连接的另一侧的数据。这里的主要区别是，与WebSocket场景不同，我们现在直接连接到另一个对等方，因此发送消息非常快：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Peer-to-peer with WebRTC](img/B04669_05_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用WebRTC进行点对点通信](img/B04669_05_07.jpg)'
- en: To summarize, before we can start using our `DataChannel` to communicate with
    the other peer, we need to manually (meaning, outside the real of WebRTC APIs)
    configure each peer relative to each other. Often, you will want to first connect
    the peers through a WebSocket and use that connection to create and answer the
    offer from the initiating peer. In addition, data sent through the `DataChannel`
    is not limited to text only. We can send binary data, such as video and audio
    using another WebRTC API, which we'll discuss in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在我们可以开始使用`DataChannel`与其他对等方通信之前，我们需要手动（意味着在WebRTC API的真实领域之外）相对于彼此配置每个对等方。通常，您将首先通过WebSocket连接对等方，并使用该连接创建并回答发起对等方的提议。此外，通过`DataChannel`发送的数据不仅限于文本。我们可以使用另一个WebRTC
    API发送二进制数据，例如视频和音频，我们将在下一节中讨论。
- en: Capturing the moment with Media Capture
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用媒体捕获捕获时刻
- en: One of the newer components of online multiplayer games is the social aspect
    that involves real-time voice and video communication. This last component can
    be perfectly satisfied by using HTML **Media Capture** APIs, which allow you to
    access your player's camera and microphone. Once you have gained access to a camera
    and microphone, you can broadcast that data to other players, save them as audio
    and video files, or even create a standalone experience that is based on that
    alone.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在线多人游戏的较新组件之一是涉及实时语音和视频通信的社交方面。这最后一个组件可以通过使用HTML **媒体捕获** API完美满足，它允许您访问玩家的摄像头和麦克风。一旦您获得了对摄像头和麦克风的访问权限，您可以将这些数据广播给其他玩家，将它们保存为音频和视频文件，甚至创建一个仅基于这些数据的独立体验。
- en: The *hello world* example of Media Capture is probably the eye candy of audio
    visualization demonstration. We can achieve this with a mixture of Media Capture
    and **Web Audio** API. With media capture, we can actually receive the raw audio
    data from the user's microphone; then, we can use Web Audio to connect the data
    and analyze it. With that data in place, we can lean on the canvas API to render
    the data representing the sound waves that was received by the microphone.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体捕获的*hello world*示例可能是音频可视化演示的吸引人之处。我们可以通过媒体捕获和**Web Audio** API的混合来实现这一点。通过媒体捕获，我们实际上可以从用户的麦克风接收原始音频数据；然后，我们可以使用Web
    Audio连接数据并对其进行分析。有了这些数据，我们可以依靠canvas API来呈现由麦克风接收的代表声波的数据。
- en: First, let us take a more involved look at Media Capture. Then, we'll look at
    the important pieces of Web Audio and leave it as an exercise for you to find
    a better, more complete, and dedicated source to deepen your' understanding of
    the rest of the Web Audio API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更深入地了解媒体捕获。然后，我们将看一下Web Audio的重要部分，并留给您找到更好、更完整和专门的来源来加深您对Web Audio API的理解。
- en: Currently, media capture is in candidate recommendation, so we still need to
    look for and include vendor prefixes. For brevity, we will assume **Webkit targetting**
    (*HTML Media Capture W3C Candidate Recommendation*, (September 2014). [http://www.w3.org/TR/html-media-capture/](http://www.w3.org/TR/html-media-capture/)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，媒体捕获处于候选推荐阶段，因此我们仍然需要寻找并包含供应商前缀。为简洁起见，我们将假定**Webkit目标**（*HTML媒体捕获W3C候选推荐*，（2014年9月）。[http://www.w3.org/TR/html-media-capture/](http://www.w3.org/TR/html-media-capture/)）。）
- en: 'We begin by calling the `getUserMedia` function on the navigator object. (for
    more information about the `window.navigator` property, go to [https://developer.mozilla.org/en-US/docs/Web/API/Window/navigator](https://developer.mozilla.org/en-US/docs/Web/API/Window/navigator).)
    In this, we specify any constraints about the media we wish to capture, such as
    the audio, the video frame rate that we want, and so on:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在navigator对象上调用`getUserMedia`函数。（有关`window.navigator`属性的更多信息，请转到[https://developer.mozilla.org/en-US/docs/Web/API/Window/navigator](https://developer.mozilla.org/en-US/docs/Web/API/Window/navigator)。）在此，我们指定有关我们希望捕获的媒体的任何约束，例如音频、我们想要的视频帧速率等等：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In its simplest form, the constraints dictionary only includes a key indicating
    the type of media that we wish to capture, followed by a `Boolean` value that
    represents our intent. Optionally, any false values can be shorthanded by leaving
    out the attribute altogether.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，约束字典只包括一个指示我们希望捕获的媒体类型的键，后面跟着一个代表我们意图的`Boolean`值。可选地，任何false值都可以通过完全省略属性来简写。
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the call to `getUserMedia` is executed, the browser will display a warning
    message to the user, alerting him or her that the page is attempting to access
    media devices; this will give the user a chance to allow or deny such a request:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了对`getUserMedia`的调用，浏览器将向用户显示警告消息，提醒用户页面正在尝试访问媒体设备；这将给用户一个机会允许或拒绝这样的请求：
- en: '![Capturing the moment with Media Capture](img/B04669_05_05.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用媒体捕获捕获时刻](img/B04669_05_05.jpg)'
- en: Although it is different from the old `window.alert`, `window.confirm`, and
    `window.prompt` APIs, the browser-generated prompt is always asynchronous and
    non-blocking. This is the reason for providing callback functions for the cases
    where the user allows or denies your request.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它与旧的`window.alert`、`window.confirm`和`window.prompt` API不同，但浏览器生成的提示始终是异步的和非阻塞的。这就是为什么在用户允许或拒绝请求的情况下提供回调函数的原因。
- en: 'Once we have been granted access to the user''s audio device, as in the previous
    example, we can leverage the Web Audio API and create an `AudioContext` object;
    from this, we can then create a media stream source:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了对用户音频设备的访问权限，就像前面的例子一样，我们可以利用Web Audio API并创建一个`AudioContext`对象；从这里，我们可以创建一个媒体流源：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you may have guessed, a `MediaStream` object represents the microphone as
    a source of data. With that reference, we can now connect the microphone to an
    `AnalyserNode` to help us break down the audio input into something that we can
    represent visually:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，`MediaStream`对象表示麦克风作为数据源。有了这个参考，我们现在可以将麦克风连接到`AnalyserNode`，以帮助我们将音频输入分解为我们可以以可视方式表示的内容：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next step is to use the `analyser` object and get the frequency data from
    the audio source. With this on hand, we can just render it to some existing canvas
    as we see fit:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`analyser`对象并从音频源获取频率数据。有了这个，我们可以根据需要将其渲染到现有画布上：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Capturing the moment with Media Capture](img/B04669_05_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![使用媒体捕获捕捉时刻](img/B04669_05_06.jpg)'
- en: 'Working with a video is equally simple, but it does require, as you would expect,
    that a camera to be connected to your computer. If you make the request to `getUserMedia`
    with a set video constraint, but no camera is present, the error callback will
    be executed and the `NavigatorUserMediaError` object will sent as the argument:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 处理视频同样简单，但是需要连接摄像头到您的计算机，这是您所期望的。如果您使用设置视频约束的`getUserMedia`请求，但没有摄像头，则将执行错误回调，并将`NavigatorUserMediaError`对象作为参数发送：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the other hand, when a video device is accessible, we can stream it to a
    video element in the most simple manner by setting its `src` attribute to a `objectUrl`,
    which is pointing to the stream source that we acquire from the user media:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当视频设备可访问时，我们可以通过将其`src`属性设置为`objectUrl`的方式将其流式传输到视频元素中，该`objectUrl`指向我们从用户媒体获取的流源：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took us forward in time, giving us a glimpse of the latest HTML5
    APIs that we can incorporate into our multiplayer games. These APIs include the
    Fullscreen mode, gamepad, media capture, and WebRTC. With these powerful additional
    features, your games will be that much more engaging and fun to play.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使我们向前迈进了一步，让我们一窥我们可以将其纳入我们的多人游戏中的最新HTML5 API。这些API包括全屏模式、游戏手柄、媒体捕获和WebRTC。有了这些强大的附加功能，您的游戏将更具吸引力和乐趣。
- en: However, the one takeaway point from the entire discussion is that all of the
    APIs that were described in this chapter are still in the early drafting stages;
    therefore, they can be subjected to drastic interface changes, or they can be
    deprecated as well. In the meantime, be sure to add the appropriate vendor prefixes
    to each API and look out for any one-off browser quirks or implementation differences.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，整个讨论中的一个要点是，本章中描述的所有API仍处于早期草拟阶段；因此，它们可能会受到严重的界面更改，或者也可能被弃用。与此同时，请确保为每个API添加适当的供应商前缀，并注意任何一次性浏览器怪癖或实现差异。
- en: In the next chapter, we'll conclude our journey through the wonderful world
    of multiplayer game development in JavaScript by discussing security vulnerabilities
    that are associated with network gaming. We'll describe common techniques to minimize
    opportunities for cheating, thus providing a fair and adequate playing experience.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过讨论与网络游戏相关的安全漏洞来结束我们在JavaScript中进行多人游戏开发的精彩旅程。我们将描述最常见的技术，以最小化作弊的机会，从而提供公平和充分的游戏体验。
